<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>XDPP1100 Firmware: PMBUS FW Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_infineon.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">XDPP1100 Firmware
   </div>
   <div id="projectbrief">The firmware documentation for the XDPP1100 device family.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('pg_shasta__p_m_b_u_s.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">PMBUS FW Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sctShasta_PMBUS_Intro"></a>
Introduction</h1>
<p>PMBUS driver handles version 1.3.1 of the PMBUS specification: <a href="http://www.pmbus.org/Specifications/CurrentSpecifications">http://www.pmbus.org/Specifications/CurrentSpecifications</a> It auto-generates its command support tables from: <a href="https://sec-ishare.infineon.com/sites/shasta/Shared%20Documents/00_Requirements/PMBus/Shasta_PMBus.xlsx">https://sec-ishare.infineon.com/sites/shasta/Shared%20Documents/00_Requirements/PMBus/Shasta_PMBus.xlsx</a></p>
<p>See register map documentation for documented PMBUS commands included in ROM code.</p>
<p>The PMBUS firmware module is a CMSIS style driver, but supports only slave access. See ARM_DRIVER_PMBUS for driver struct.</p>
<p>Terminology Assumptions: Handler - Call back function used to do work on a given PMBUS command. API - Application layer interface used by user for access to firmware module. Driver - Shortened to drv in file naming. Tends to wrap the hardware abstraction layer for accessing a particular hardware block.</p>
<h1><a class="anchor" id="sctShasta_PMBUS_HWFW"></a>
PMBUS HW/FW interface</h1>
<p>The PMBUS HW PHY is assisted by firmware module. The firmware is expected in general to decode PMBUS protocol while the hardware de-serializes I2C traffic. A FIFO depth of 4 interrupts is used by HW block to signal to firmware when work needs to be done allowing firmware to fall behind hardware for upto 4 bytes. FW responds when slave address matches programmed address and pushes HW state machine forward when given valid PMBUS protocol. The firmware tends to work 1 byte ahead of the incoming PMBUS data to ensure that FW latency does not interfere with bus speed. Since PMBUS is a lower priority than FAULTS or WDT interrupts it can still be starved out if enough faults occur. This is indicated via the busy bit of status word pmbus command if this occurs. The HW allows a 5us clock stretch in these cases then the packet is dropped (send all 1's/ nack until not busy). The PMBUS firmware is interrupt based for getting command data from the bus and putting into PMBUS RAM locations. Any operation on the command after protocol is done in the <a class="el" href="pmbus__drv_8c.html#a8523daa27189a0c995495262920a6d93">PMBUS_Thread</a>. The thread has a 32 deep message queue that stacks up with <a class="el" href="structpmbus__inter__thread__message__t.html">pmbus_inter_thread_message_t</a> type messages that tell the thread which command handles(callback functions from a bus command) to execute. The thread is always lower priority than the interrupts so incoming commands can modify data that thread is executing on.</p>
<div class="image">
<img src="pmbus_byte_sequences.jpg" alt="pmbus_byte_sequences.jpg"/>
<div class="caption">
General PMBUS HW Flow</div></div>
 <h1><a class="anchor" id="sctShasta_PMBUS_HWFW1"></a>
PMBUS HW/FW interface</h1>
<p>The firmware module is separated into a driver, auto-generated command structure, command handlers, and an API for other firmware blocks to access. The diagram below outlines the overview of the layering. It is recommended that <a class="el" href="pmbus__mfr__specific__handlers_8c.html">pmbus_mfr_specific_handlers.c</a> object is patched by customer for manufacturer specific commands using the <a class="el" href="pmbus__api_8c.html">pmbus_api.c</a> layer. </p><div class="image">
<img src="pmbus_fw_module.jpg" alt="pmbus_fw_module.jpg"/>
<div class="caption">
General PMBUS Firmware Module Flow</div></div>
 <h1><a class="anchor" id="sctShasta_PMBUS_GPIO"></a>
PMBUS GPIO Controls</h1>
<p>The PMBUS firmware module has control of VR_ENABLE, POWER_GOOD#, FAULT, VRHOT, WARN, and TEST_IN_PROGRESS GPIO pins. Using FW_CONFIG_PMBUS one can control the mapping and polarity of these pins. The GPIO0 bank is associated with loop 0 of the controller and GPIO1 bank associated with the loop 1 of the controller. The GPIO mapping is seen in <a class="el" href="pmbus__gpio__control_8h.html">pmbus_gpio_control.h</a>. The GPIO driver configuration, direction, polarity, and interrupt call-backs exist in <a class="el" href="pmbus__gpio__control_8c.html">pmbus_gpio_control.c</a>. The GPIO banks/pins are multiplexed to pads of the device by the gpio_sel field in MP_EN_SEL register. See HW register map for description.</p>
<h1><a class="anchor" id="sctXaddrOffsets"></a>
Using XADDR Pins to Offset PMBUS Address</h1>
<p>Using FW_CONFIG_PMBUS can enable xaddr resistor offsets. The hardware is capable of both 8 and 16 offset option resistor ranges. After the base address is programmed in this register and the resistive offset is enabled the address will be the base +offset. This allows the same OTP configuration of multiple parts to coexist in the same system with different slave addresses. If the resistive offset is disabled in this command the field for offset is used instead. This needs to be programmed differently for each part in the same bus. <a class="el" href="fw__params_8h.html#a8a306805262e90d46749cdbe7dcbd05e">FW_CONFIG_t</a> xv_en field must also be programmed to allow different OTP images to be loaded based on resistor.</p>
<h1><a class="anchor" id="sctShasta_PMBUS_Packets"></a>
PMBUS Packet Types</h1>
<p>Described in these FW/HW flow diagrams is the typical decision making process by the PMBUS interrupt handler for various types of PMBUS packets. </p>
<h2><a class="anchor" id="sctShasta_PMBUS_Packets_Write_Word"></a>
Write Word</h2>
<div class="image">
<img src="write_word.jpg" alt="write_word.jpg"/>
<div class="caption">
Write Word/Byte</div></div>
<h2><a class="anchor" id="sctShasta_PMBUS_Packets_Read_Word"></a>
Read Word</h2>
<div class="image">
<img src="read_word.jpg" alt="read_word.jpg"/>
<div class="caption">
Read Word/Byte</div></div>
<h2><a class="anchor" id="sctShasta_PMBUS_Packets_Block_Write"></a>
Block Write</h2>
<div class="image">
<img src="block_write.jpg" alt="block_write.jpg"/>
<div class="caption">
Block Write</div></div>
<h2><a class="anchor" id="sctShasta_PMBUS_Packets_Block_Read"></a>
Block Read</h2>
<div class="image">
<img src="block_read.jpg" alt="block_read.jpg"/>
<div class="caption">
Block Read</div></div>
 <h1><a class="anchor" id="sctShasta_I2C"></a>
PMBUS I2C AHB Bridge Interface</h1>
<p>A separate I2C address is supported for AHB access to the internal bus. This allows for HW registers that are not controlled by PMBUS to be accessed by the user. This bus is subject to MMU write protection, but no read protection. See the HW memory map for register addressing/offsets. </p>
<h2><a class="anchor" id="sctShasta_I2C_Read32"></a>
Read32</h2>
<div class="image">
<img src="read32.jpg" alt="read32.jpg"/>
<div class="caption">
I2C AHB Bridge Read</div></div>
<h2><a class="anchor" id="sctShasta_I2C_Write32"></a>
Write32</h2>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Nov 8 2023 10:17:01 for XDPP1100 Firmware by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
