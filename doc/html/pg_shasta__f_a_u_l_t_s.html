<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>XDPP1100 Firmware: Faults FW Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_infineon.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">XDPP1100 Firmware
   </div>
   <div id="projectbrief">The firmware documentation for the XDPP1100 device family.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('pg_shasta__f_a_u_l_t_s.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Faults FW Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sctShasta_FAULTS_Intro"></a>
Introduction</h1>
<p>FAULTS driver handles version 1.0. The Faults firmware module is a CMSIS style driver. See ARM_DRIVER_FAULTS for driver struct. Terminology Assumptions: API - Application layer interface used by user for access to firmware module. Driver - Shortened to drv in file naming. Tends to wrap the hardware abstraction layer for accessing a particular hardware block.</p>
<h1><a class="anchor" id="sctShasta_FAULTS_FAULT_HYSTERESIS"></a>
Fault detection and hysteresis</h1>
<p>When the driver detects a warning, condition where the problem is present but is not severe, the driver latches the status in fault_status_event_latch <a class="el" href="struct___f_a_u_l_t___d_r_v__s.html">_FAULT_DRV_s</a> and reports it via PMBUS. If the sensed condition is more serious and can damage the on-board devices or load it is said to be a fault. In case of fault the driver together with the hardware module provides shutdown and retry capability configured by PMBUS response command <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_RESPONSE">Fault Response</a>.</p>
<p>Fault hardware module has a comparator for each hardware fault and warn type with fault and warn limits configured by the driver from pmbus limit commands (for ex., VOUT_OV_FAULT_LIMIT and VOUT_OV_WARN_LIMIT). If enabled hardware module tristates the pwm output and sends a fault interrupt signal each time the fault or warn is set and cleared.</p>
<p>In order to avoid system overloading from an oscillating fault the driver supports a warning hysteresis. In other words, the fault condition is cleared not when the faulted signal is gone below the fault limit but when it is below the corresponding warn limit. For example, VOUT OV fault is latched when VOUT is above VOUT_OV_FAULT_LIMIT and is cleared when below VOUT_OV_WARN_LIMIT. Fault hysteresis is setup by <a class="el" href="faults__api_8h.html#a213603c8c6edc1e610869b4c77ca68e8">FAULTS_SETUP_FAULT</a> api by providing <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a> hysteresis argument. After fault is set it is disabled by the driver until the faulted signal has gone below the warn limit. Fault clear interrupt will occur when below the warn limit.</p>
<div class="image">
<img src="fault_with_hysteresis.jpg" alt="fault_with_hysteresis.jpg"/>
<div class="caption">
Fault With Hysteresis Set to Warn</div></div>
<p> Since not all the faults have a corresponding warn or hysteresis is not desired, the hysteresis fault clear can be avoided by setting <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a> hysteresis argument to itself.</p>
<div class="image">
<img src="fault_with_hysteresis_to_itself.jpg" alt="fault_with_hysteresis_to_itself.jpg"/>
<div class="caption">
Fault With Hysteresis Set to Itself</div></div>
<p> The driver also supports a "0" in the <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a> hysteresis argument dedicated to the faults that can't clear after the fault is latched and/or the device is shutdown. Example would be VOUT_UV_FAULT where after the device is shutdown VOUT can't go back above the fault limit until restarted. NOTE: VOUT_UV_FAULT is not disabled by the driver. It is disabled by regulation state machine <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_MASKING">Fault masking</a>.</p>
<div class="image">
<img src="fault_with_hysteresis_to_0.jpg" alt="fault_with_hysteresis_to_0.jpg"/>
<div class="caption">
Fault With Hysteresis Set to 0</div></div>
<p> The list of all supported fault types with its hysteresis type can be found in a table <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_TYPES">Supported Fault Types</a>.</p>
<h1><a class="anchor" id="sctShasta_FAULTS_FAULT_RESPONSE"></a>
Fault Response</h1>
<p>The options for response to a fault include shutting down the output immediately or after preset timeout, continuing to operate while maintaining the output current or ignoring the fault. The converter can also be programmed to restart in a number of ways including trying to restart when the fault is cleared, restarting in programmed number of times or restarting in programmed delay time.</p>
<h2><a class="anchor" id="sctShasta_FAULTS_FAULT_RESPONSE_TYPE"></a>
Fault Response Type</h2>
<p>The driver allows for 2 types of responses to a fault <a class="el" href="faults__api_8h.html#a4058c67156579dc97b9d54b2116d6919">RESPONSE_CONFIG_e</a> :</p>
<ul>
<li>VOLTAGE_RESPONSE_TYPE follows PMBUS SPEC 1.3 section 10.5.1 Response To Voltage, Temperature And TON_MAX Faults</li>
<li>CURRENT_RESPONSE_TYPE follows PMBUS SPEC 1.3 section 10.5.2 Response To Current Faults.</li>
</ul>
<p>A list of all responses is enumerated in <a class="el" href="faults__api_8h.html#a35cfd0b6e699f8eb9a4921e30a76b4ed">_FAULT_RESPONSE_TYPE__e</a> and described in a table:</p>
<table class="doxtable">
<tr>
<th>FAULT_RESPONSE__e </th><th>FAULT_ RESPONSE _TYPE_t </th><th>RESPONSE_CONFIG_e </th><th align="center">SPEC section </th><th align="center">Response Command bits[7:6] </th><th>Description  </th></tr>
<tr>
<td>FAULT_RESPONSE_IGNORE </td><td><div class="image">
<img src="fault_response_ignore.JPG" alt="fault_response_ignore.JPG"/>
<div class="caption">
0</div></div>
 </td><td>VOLTAGE_RESPONSE_TYPE </td><td align="center">10.5.1 </td><td align="center">00 </td><td>Device reports a fault on pmbus status bits and continues operation without interruption. </td></tr>
<tr>
<td>FAULT_RESPONSE_RETRY_OPERATION </td><td><div class="image">
<img src="fault_response_retry_operation.JPG" alt="fault_response_retry_operation.JPG"/>
<div class="caption">
1</div></div>
 </td><td>VOLTAGE_RESPONSE_TYPE </td><td align="center">10.5.1 </td><td align="center">01 </td><td>Device reports a fault on pmbus status bits and continues operation for the delay time. If the fault condition is still present the device shuts down at the end of the delay time. Retry number can be programmed. </td></tr>
<tr>
<td>FAULT_RESPONSE_RETRY_SHUTDOWN </td><td><div class="image">
<img src="fault_response_retry_shutdown.JPG" alt="fault_response_retry_shutdown.JPG"/>
<div class="caption">
2</div></div>
 </td><td>VOLTAGE_RESPONSE_TYPE </td><td align="center">10.5.1 </td><td align="center">10 </td><td>Device reports a fault on pmbus status bits and shuts down. Retry number can be programmed. </td></tr>
<tr>
<td>FAULT_RESPONSE_SHUTDOWN_RESTART _WHEN_REMOVED </td><td><div class="image">
<img src="fault_response_shutdown_restart_when_removed.JPG" alt="fault_response_shutdown_restart_when_removed.JPG"/>
<div class="caption">
3</div></div>
 </td><td>VOLTAGE_RESPONSE_TYPE </td><td align="center">10.5.1 </td><td align="center">11 </td><td>Device reports a fault on pmbus status bits, shuts down and restarts the operation when fault condition no longer exists. </td></tr>
<tr>
<td>FAULT_RESPONSE_IOUT_CONSTANT_CURRENT </td><td><div class="image">
<img src="fault_response_iout_constant_current.JPG" alt="fault_response_iout_constant_current.JPG"/>
<div class="caption">
4</div></div>
 </td><td>CURRENT_RESPONSE_TYPE </td><td align="center">10.5.2 </td><td align="center">00 </td><td>Device reports a fault on pmbus status bits and continues to operate while maintaining the output current. </td></tr>
<tr>
<td>FAULT_RESPONSE_IOUT_CONSTANT_CURRENT _WITH_OC_LV</td><td><div class="image">
<img src="fault_response_iout_constant_current_with_oc_lv.JPG" alt="fault_response_iout_constant_current_with_oc_lv.JPG"/>
<div class="caption">
5</div></div>
 </td><td>CURRENT_RESPONSE_TYPE </td><td align="center">10.5.2 </td><td align="center">01 </td><td>Device reports a fault on pmbus status bits and continues to operate while maintaining the output current. Device will shutdown when preset output under voltage threshold has been reached. Retry number can be programmed. </td></tr>
<tr>
<td>FAULT_RESPONSE_IOUT_DELAY_WITH_CC_RETRY </td><td><div class="image">
<img src="fault_response_iout_delay_with_cc_retry.JPG" alt="fault_response_iout_delay_with_cc_retry.JPG"/>
<div class="caption">
6</div></div>
 </td><td>CURRENT_RESPONSE_TYPE </td><td align="center">10.5.2 </td><td align="center">10 </td><td>Device reports a fault on pmbus status bits and continues to operate while maintaining the output current for the delay time. If the fault condition is still present the device shuts down at the end of the delay time. Retry number can be programmed. </td></tr>
<tr>
<td>FAULT_RESPONSE_IOUT_SHUTDOWN_AND_RETRY </td><td><div class="image">
<img src="fault_response_iout_shutdown_and_retry.JPG" alt="fault_response_iout_shutdown_and_retry.JPG"/>
<div class="caption">
7</div></div>
 </td><td>CURRENT_RESPONSE_TYPE </td><td align="center">10.5.2 </td><td align="center">11 </td><td>Device reports a fault on pmbus status bits and shuts down. Retry number can be programmed. </td></tr>
</table>
<h2><a class="anchor" id="sctShasta_FAULTS_FAULT_RESPONSE_RETRY_COUNT"></a>
Fault Response Retry Count</h2>
<p>For faults that have a supported pmbus response command fault retry count should be set by setting Retry_Setting bits[5:3] of fault response command byte (Section 10.5 of PMBUS SPEC 1.3). A value of 000 means that the device does not attempt to restart, value of 001 - 110 - device will restart 1 to 6 times according to the number set by these bits. Value of 111 means the device will continue to retry indefinitely.</p>
<p>The list of all supported fault types with its hysteresis, response type, associated pmbus limit, response, status and delay config can be found in a table <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_TYPES">Supported Fault Types</a>.</p>
<p>For other user faults retry count can be set through Retry_Setting[5:3] of fault_response_byte argument of <a class="el" href="faults__api_8h.html#a213603c8c6edc1e610869b4c77ca68e8">FAULTS_SETUP_FAULT</a> api. fault_response_byte follows pmbus response byte format: Response[7:6], Retry_Setting[5:3] and Delay_Time[2:0]. For fault setup example see <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_RESPONSE_SETUP">Fault Response Setup</a>.</p>
<p>Retry count is cleared in the following cases:</p><ul>
<li>On the case of the successful retry in REGULATION_CONTROLS_ENABLE control of REGULATION_STATE_AT_TARGET_VID state.</li>
<li>A CLEAR_FAULTS command clears every faults retry count.</li>
<li>When the ENABLE signal(depending on ON_OFF_CONFIG could be: CONTROL pin, OPERATION command, both CONTROL pin and OPERATION or just application of input power) is toggled off and then back on.</li>
</ul>
<h2><a class="anchor" id="sctShasta_FAULTS_FAULT_RESPONSE_RETRY_DELAY"></a>
Fault Response Retry Delay</h2>
<p>For faults that have a supported pmbus response command fault retry delay should be set by setting Delay_Time bits[2:0] of fault response command byte (Section 10.5 of PMBUS SPEC 1.3). Time delay between retries in milliseconds (Delay_time_ms) is equal to (1&lt;&lt;Delay_Time) * Delay_Unit, where Delay unit varies depending on the type of fault and is configured by FW_CONFIG_FAULTS pmbus command bit [7:0] <a class="el" href="faults__api_8h.html#a86064f49287f3c26581549ab1f0f5cf9">FAULTS_CONFIG_e</a>.</p>
<table class="doxtable">
<tr>
<th>Bit </th><th>Field Name </th><th>Meaning  </th></tr>
<tr>
<td>7:6 </td><td>Vout_Delay_Unit </td><td>Time unit for retry responses. 0: 1ms, 1: 4ms, 2: 16ms, 3: 256ms </td></tr>
<tr>
<td>5:4 </td><td>Vin_Delay_Unit </td><td>Time unit for retry responses. 0: 1ms, 1: 4ms, 2: 16ms, 3: 256m </td></tr>
<tr>
<td>3:2 </td><td>Iout_Delay_Unit </td><td>Time unit for retry responses. 0: 1ms, 1: 4ms, 2: 16ms, 3: 256m </td></tr>
<tr>
<td>1:0 </td><td>Temperature_Delay_Unit</td><td>Time unit for retry responses. 0: 1ms, 1: 4ms, 2: 16ms, 3: 256m </td></tr>
</table>
<p>The list of all supported fault types with its hysteresis, response type, associated pmbus limit, response, status and delay config can be found in a table <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_TYPES">Supported Fault Types</a>.</p>
<p>For other user faults that don't have a corresponding pmbus response command retry Delay can be set through Delay_Time[5:3] of fault_response_byte argument of <a class="el" href="faults__api_8h.html#a213603c8c6edc1e610869b4c77ca68e8">FAULTS_SETUP_FAULT</a> api. fault_response_byte follows pmbus response byte format: Response[7:6], Retry_Setting[5:3] and Delay_Time[2:0]. For fault setup example see <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_RESPONSE_SETUP">Fault Response Setup</a>.</p>
<h2><a class="anchor" id="sctShasta_FAULTS_FAULT_RESPONSE_SETUP"></a>
Fault Response Setup</h2>
<p>For faults that have a supported pmbus response command Fault response type, hiccup count and retry delay should be set by writing fault response byte (Response[7:6], Retry_Setting{5:3] and Delay_Time[2:0]) to that command (Section 10.5 of PMBUS SPEC 1.3).</p>
<p>For example, to set the response of VOUT_OV_FAULT to FAULT_RESPONSE_RETRY_SHUTDOWN with 6 hiccups and retry delay of (1&lt;&lt;0) * FW_CONFIG_FAULTS[FAULTS_CONFIG_VOUT_DELAY_UNIT] VOUT_OV_FAULT_RESPONSE command should be sent with the value of 0xB0. Not other setup is needed. FAULT_TYPE_VOUT_OV_FAULT is already configured as VOLTAGE_RESPONSE_TYPE with FAULTS_CONFIG_VOUT_DELAY_UNIT, FAULT_TYPE_VOUT_OV_WARN as hysteresis to be reported on PMBUS_CMDCODE_STATUS_VOUT with bit position of PMBUS_STATUS_VOUT_OV_FAULT.</p>
<p>The list of all supported fault types with its hysteresis, response type, associated pmbus limit, response, status and delay config can be found in a table <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_TYPES">Supported Fault Types</a>.</p>
<p>For other user faults fault response can be set through <a class="el" href="faults__api_8h.html#a213603c8c6edc1e610869b4c77ca68e8">FAULTS_SETUP_FAULT</a> api. Example shows how to setup an external fault with response FAULT_RESPONSE_RETRY_SHUTDOWN, 6 hiccups with retry delay of (1&lt;&lt;0) * FW_CONFIG_FAULTS[FAULTS_CONFIG_VOUT_DELAY_UNIT]</p>
<div class="fragment"><div class="line"><span class="comment">//Example of setting up the response on external fault to FAULT_RESPONSE_RETRY_SHUTDOWN with 6 hiccups</span></div>
<div class="line"><span class="comment">//with no hysteresis</span></div>
<div class="line"><span class="preprocessor">#define FAULT_TYPE_EXTERNAL fw_spare1</span></div>
<div class="line"><a class="code" href="faults__api_8c.html#a213603c8c6edc1e610869b4c77ca68e8">FAULTS_SETUP_FAULT</a>(</div>
<div class="line">        <a class="code" href="pmbus__autogen_8h.html#a153fe0ce3c320614ddc6651631226a14a1a20d32e44a4a8bbb2e6ac4524837583">PMBUS_PAGE_0</a> ,  <span class="comment">//PMBUS_PAGE_t pmbus page to update status on</span></div>
<div class="line">        <a class="code" href="regulation__state__machine__callbacks_8c.html#af21855ce2d508ac38ff7ef31f84f91b1">FAULT_TYPE_EXTERNAL</a>,</div>
<div class="line">        0xB0, <span class="comment">//fault response byte: Response[7:6], Retry_Setting[5:3] and Delay_Time[2:0]</span></div>
<div class="line">        <a class="code" href="faults__api_8h.html#a86064f49287f3c26581549ab1f0f5cf9af4a596fb2d2b6c46aaced3bf8fb0bcbe">FAULTS_CONFIG_VOUT_DELAY_UNIT</a>, <span class="comment">//Config_Delay_Unit This is used to decode the fields in FW_CONFIG_FAULTS PMBUS command (Time unit for retry responses)</span></div>
<div class="line">        <a class="code" href="faults__api_8h.html#a4058c67156579dc97b9d54b2116d6919ad5b18d484f6029b568997e969dafc726">VOLTAGE_RESPONSE_TYPE</a>, <span class="comment">//response_config This is used to decode response command byte. Voltage(Temp, TON MAX) type or CURRENT type response</span></div>
<div class="line">        (uint8_t)PMBUS_CMDCODE_STATUS_MFR_SPECIFIC, <span class="comment">//pmbus_status_command status command number STATUS_XXX used for reporting the fault on pmbus</span></div>
<div class="line">        (uint8_t)PMBUS_STATUS_MFR_SPECIFIC_0, <span class="comment">//pmbus_status_bit_position bit position in command STATUS_XXX used for reporting the fault on pmbus</span></div>
<div class="line">        (<a class="code" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a>) <a class="code" href="regulation__state__machine__callbacks_8c.html#af21855ce2d508ac38ff7ef31f84f91b1">FAULT_TYPE_EXTERNAL</a>); <span class="comment">//hysteresis sets the hysteresis FAULT_TYPE_t,</span></div>
</div><!-- fragment --><h2><a class="anchor" id="sctShasta_FAULTS_FAULT_RESPONSE_IOUT_UC_FAULT"></a>
Fault Response IOUT_UC_FAULT</h2>
<p>Even though FAULT_TYPE_IOUT_UC_FAULT is Iout related it follows VOLTAGE_RESPONSE_TYPE with a separate meaning of FAULT_RESPONSE_SHUTDOWN_RESTART_WHEN_REMOVED response : Device reports a fault on pmbus status bits, shuts down SR FETS ONLY and restarts SR FETS when fault condition no longer exists.</p>
<p>FAULT_TYPE_IOUT_UC_FAULT is hysteresis to itself type fault. It is set when IOUT is below the limit set by IOUT_UC_FAULT_LIMIT and cleared when IOUT is back above the same limit. It is configured as VOLTAGE_RESPONSE_TYPE with FAULTS_CONFIG_IOUT_DELAY_UNIT, It reports on PMBUS_CMDCODE_STATUS_IOUT with bit position of PMBUS_STATUS_IOUT_UC_FAULT(bit 4). Response type, retry count and retry delay are configured by IOUT_UC_FAULT_RESPONSE command. Retry delay unit is set by pmbus command FW_CONFIG_FAULTS[3:2] - "FAULTS_CONFIG_IOUT_DELAY_UNIT".</p>
<div class="image">
<img src="iout_uc_fault_response.jpg" alt="iout_uc_fault_response.jpg"/>
<div class="caption">
IOUT UC FAULT Responses</div></div>
 <h1><a class="anchor" id="sctShasta_FAULTS_FAULT_REPORTING_PMBUS"></a>
Fault Reporting and Clearing on PMBUS</h1>
<p>If the device detects one of the listed conditions it latches a bit in the corresponding PMBUS Status Command so that it could be read by the user. The table of all supported fault types <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_TYPES">Supported Fault Types</a> shows which Status bit in which Pmbus Command is set when fault/warn occurs.</p>
<p>The pmbus status bit is latched and remains set until until the following occurs(Section 10.2.3 of PMBUS SPEC 1.3):</p><ul>
<li>A write of 1 to the bits of any of the status commands except for STATUS_BYTE and STATUS_WORD individually clears the set status bit.</li>
<li>A CLEAR_FAULTS command clears all the status commands(Section 15.1 of PMBUS SPEC 1.3). If the fault still persists the fault status will be immediately re-asserted.</li>
<li><p class="startli">When the ENABLE signal(depending on ON_OFF_CONFIG could be: CONTROL pin, OPERATION command, both CONTROL pin and OPERATION or just application of input power) is toggled off and then back on.</p>
<p class="startli">Faults can be completely disabled and masked from being reported on PMBUS individually with the pmbus command FW_CONFIG_FAULTS.</p>
</li>
</ul>
<table class="doxtable">
<tr>
<th>Bit </th><th>Field Name </th><th>Meaning  </th></tr>
<tr>
<td>167:136 </td><td>Fault_enable_mask_loop_common </td><td>Masking for loop common faults enable </td></tr>
<tr>
<td>135:104 </td><td>Fault_enable_mask_loop_fw </td><td>Masking for loop fw faults enable </td></tr>
<tr>
<td>103:72 </td><td>Fault_enable_mask_loop_hw </td><td>Masking for loop hw faults enable </td></tr>
</table>
<h1><a class="anchor" id="sctShasta_FAULTS_FAULT_MASKING"></a>
Fault masking</h1>
<p>Fault masking is done through <a class="el" href="faults__drv_8h.html#a73e0bab17049a051de76f98262cd4fda">Faults_Mask_Fault</a> api by specifying loop, hw of fw fault type and setting set_mask of clear_mask. Setting 1 to the bits of set_mask will enable the corresponding fault and setting 1 to clear_mask disables the fault. Setting of 0 will remain the enable mask unchanged. Set_mask and clear_mask bits [32:0] correspond to <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a> enum 0 - 31 for hw faults and enum 31 - 63 for fw faults.</p>
<div class="fragment"><div class="line"><span class="comment">//Example: disable IOUT_OC_FAULT, VOUT_UV_FAULT and VOUT_UV_WARN</span></div>
<div class="line"><a class="code" href="faults__drv_8c.html#ae72aa9998e2158c8c47f7e2507edddee">Faults_Mask_Fault</a>(loop, 1, <span class="comment">//hw fault</span></div>
<div class="line">                    0, <span class="comment">//set_mask</span></div>
<div class="line">                    ((1u&lt;&lt;(uint32_t)FAULT_TYPE_IOUT_OC_FAULT) |</div>
<div class="line">                        (1u&lt;&lt;(uint32_t)FAULT_TYPE_VOUT_UV_FAULT) |</div>
<div class="line">                            (1u&lt;&lt;(uint32_t)<a class="code" href="faults__api_8h.html#a51d2b28744f39280b1b452d10120fd7fa5a2082e98b40ce050216939a459dd2d5">FAULT_TYPE_VOUT_UV_WARN</a>))); <span class="comment">//clear_mask</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//Example: disable IOUT_OC_FAULT, VOUT_UV_FAULT and VOUT_UV_WARN</span></div>
<div class="line"><a class="code" href="faults__drv_8c.html#ae72aa9998e2158c8c47f7e2507edddee">Faults_Mask_Fault</a>(loop, 0, <span class="comment">//fw fault</span></div>
<div class="line">                    0, <span class="comment">//set_mask</span></div>
<div class="line">                    ((1u&lt;&lt;(uint32_t)<a class="code" href="faults__api_8h.html#a51d2b28744f39280b1b452d10120fd7fab5256dbf061b4bdea0d945bd260b941b">FAULT_TYPE_VIN_INSUFFICIENT</a>))); <span class="comment">//clear_mask</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">//Example: enable IOUT_OC_FAULT, VOUT_UV_FAULT and VOUT_UV_WARN</span></div>
<div class="line"><a class="code" href="faults__drv_8c.html#ae72aa9998e2158c8c47f7e2507edddee">Faults_Mask_Fault</a>(loop, 1, <span class="comment">//hw fault</span></div>
<div class="line">                    ((1u&lt;&lt;(uint32_t)FAULT_TYPE_IOUT_OC_FAULT) |</div>
<div class="line">                        (1u&lt;&lt;(uint32_t)FAULT_TYPE_VOUT_UV_FAULT) |</div>
<div class="line">                            (1u&lt;&lt;(uint32_t)<a class="code" href="faults__api_8h.html#a51d2b28744f39280b1b452d10120fd7fa5a2082e98b40ce050216939a459dd2d5">FAULT_TYPE_VOUT_UV_WARN</a>)), <span class="comment">//set_mask</span></div>
<div class="line">                    0); <span class="comment">//clear_mask</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//Example: enable VIN_INSUFFICIENT</span></div>
<div class="line"><a class="code" href="faults__drv_8c.html#ae72aa9998e2158c8c47f7e2507edddee">Faults_Mask_Fault</a>(loop, 0, <span class="comment">//fw fault</span></div>
<div class="line">                        (1u&lt;&lt;(uint32_t)<a class="code" href="faults__api_8h.html#a51d2b28744f39280b1b452d10120fd7fab5256dbf061b4bdea0d945bd260b941b">FAULT_TYPE_VIN_INSUFFICIENT</a>), <span class="comment">//set_mask</span></div>
<div class="line">                            0); <span class="comment">//clear_mask</span></div>
</div><!-- fragment --><p>The faults that are already masked in certain states/controls by <a class="el" href="regulation__drv_8h.html#a39d415c87ca640f482d816d9ef1e8932">Regulation_Fault_Mask</a> are shown in the table.</p>
<table class="doxtable">
<tr>
<th>REGULATION_STATE </th><th>REGULATION_ CONTROLS_ SHUTDOWN</th><th>REGULATION_ CONTROLS_ SHUTDOWN_ IMMEDIATE</th><th>REGULATION_ CONTROLS_ ENABLE</th><th>REGULATION_ CONTROLS_ FAULT  </th></tr>
<tr>
<td>REGULATION_STATE_OFF </td><td>x FAULT_TYPE_VOUT_UV_FAULT </td><td>x FAULT_TYPE_VOUT_UV_FAULT </td><td></td><td></td></tr>
<tr>
<td></td><td>x FAULT_TYPE_VOUT_UV_WARN </td><td>x FAULT_TYPE_VOUT_UV_WARN </td><td></td><td></td></tr>
<tr>
<td></td><td>x FAULT_TYPE_IOUT_OC_LV_FAULT </td><td>x FAULT_TYPE_IOUT_OC_LV_FAULT </td><td></td><td></td></tr>
<tr>
<td></td><td>x FAULT_TYPE_PIN_OP_WARN </td><td>x FAULT_TYPE_PIN_OP_WARN </td><td></td><td></td></tr>
<tr>
<td></td><td>x FAULT_TYPE_POUT_OP_WARN </td><td>x FAULT_TYPE_POUT_OP_WARN </td><td></td><td></td></tr>
<tr>
<td>REGULATION_STATE_TON_DELAY </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>REGULATION_STATE_TON_RISE </td><td></td><td></td><td>FAULT_TYPE_IOUT_OC_LV_FAULT </td><td></td></tr>
<tr>
<td>REGULATION_STATE_AT_TARGET_VID </td><td></td><td></td><td>FAULT_TYPE_VOUT_UV_FAULT </td><td></td></tr>
<tr>
<td></td><td></td><td></td><td>FAULT_TYPE_VOUT_UV_WARN </td><td></td></tr>
<tr>
<td></td><td></td><td></td><td>FAULT_TYPE_PIN_OP_WARN </td><td></td></tr>
<tr>
<td></td><td></td><td></td><td>FAULT_TYPE_POUT_OP_WARN </td><td></td></tr>
<tr>
<td>REGULATION_STATE_TOFF_DELAY </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>REGULATION_STATE_TOFF_FALL </td><td>x FAULT_TYPE_VOUT_UV_FAULT </td><td>x FAULT_TYPE_VOUT_UV_FAULT </td><td></td><td></td></tr>
<tr>
<td></td><td>x FAULT_TYPE_VOUT_UV_WARN </td><td>x FAULT_TYPE_VOUT_UV_WARN </td><td></td><td></td></tr>
<tr>
<td></td><td>x FAULT_TYPE_IOUT_OC_LV_FAULT </td><td>x FAULT_TYPE_IOUT_OC_LV_FAULT </td><td></td><td></td></tr>
<tr>
<td></td><td>x FAULT_TYPE_PIN_OP_WARN </td><td>x FAULT_TYPE_PIN_OP_WARN </td><td></td><td></td></tr>
<tr>
<td></td><td>x FAULT_TYPE_POUT_OP_WARN </td><td>x FAULT_TYPE_POUT_OP_WARN </td><td></td><td></td></tr>
<tr>
<td>REGULATION_STATE_FAULT </td><td>x FAULT_TYPE_VOUT_UV_FAULT </td><td>x FAULT_TYPE_VOUT_UV_FAULT </td><td></td><td>x FAULT_TYPE_VOUT_UV_FAULT </td></tr>
<tr>
<td></td><td>x FAULT_TYPE_VOUT_UV_WARN </td><td>x FAULT_TYPE_VOUT_UV_WARN </td><td></td><td>x FAULT_TYPE_VOUT_UV_WARN </td></tr>
<tr>
<td></td><td>x FAULT_TYPE_IOUT_OC_LV_FAULT </td><td>x FAULT_TYPE_IOUT_OC_LV_FAULT </td><td></td><td>x FAULT_TYPE_IOUT_OC_LV_FAULT </td></tr>
<tr>
<td></td><td>x FAULT_TYPE_PIN_OP_WARN </td><td>x FAULT_TYPE_PIN_OP_WARN </td><td></td><td>x FAULT_TYPE_PIN_OP_WARN </td></tr>
<tr>
<td></td><td>x FAULT_TYPE_POUT_OP_WARN </td><td>x FAULT_TYPE_POUT_OP_WARN </td><td></td><td>x FAULT_TYPE_POUT_OP_WARN </td></tr>
</table>
<p>Example shows vout uv fault which is masked until the unit reaches target voltage and when the device is disabled.(Section 15.6 of PMBUS SPEC 1.3)</p>
<div class="image">
<img src="vout_uv_fault_masking.jpg" alt="vout_uv_fault_masking.jpg"/>
<div class="caption">
vout uv fault masking</div></div>
 <h1><a class="anchor" id="sctShasta_FAULTS_FAULT_PIN_MASKING"></a>
Fault pin masking</h1>
<p>Fault pin is asserted in Fault IRQ handler for both shutdown and warning event of any <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a>. Faults can be masked individually from being output on the Fault pin with the pmbus command FW_CONFIG_FAULTS.</p>
<table class="doxtable">
<tr>
<th>Bit </th><th>Field Name </th><th>Meaning  </th></tr>
<tr>
<td>71:40</td><td>Fault_pin_mask_fw </td><td>Masking for firmware faults </td></tr>
<tr>
<td>39:8 </td><td>Fault_pin_mask_hw </td><td>Masking for hardware faults </td></tr>
</table>
<h1><a class="anchor" id="sctShasta_FAULTS_OPERATION"></a>
Faults HW Module and Driver Operation</h1>
<h2><a class="anchor" id="sctShasta_FAULTS_HW"></a>
Fault HW Module Operation</h2>
<p>Fault hardware module has a comparator for each fault type <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a> and sets the FAULT_TYPE_t bit number in fault_status register for each rising and falling edge of fault comparator (if enabled by fault_enable). Since comparators used are level detect type comparators faults hardware uses fault_polarity to ensure fault_status is set only once for each fault set and clear detected. Fault_polarity is controlled by faults driver. The value of 0 assumes initial polarity of comparator (for ex., above the threshold for OV type and below the threshold for UV) and the value of 1 is inverses the comparator polarity. Faults module uses fault_shut_mask to determine which fault type <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a> disables the pwm output when the faulted signal goes depending on comparator polarity above or below the fault threshold. fault_shut_mask register is set by pmbus fault response or configured by <a class="el" href="faults__api_8h.html#a213603c8c6edc1e610869b4c77ca68e8">FAULTS_SETUP_FAULT</a> api <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_RESPONSE_SETUP">Fault Response Setup</a>. When fault for which fault_shut_mask is set occurs pwm outputs stay gated until the state machine is moved to the REGULATION_STATE_FAULT state. Shutdown sequence is executed in the fault state to turn off both primary and sr fets, set vramp_on signal, clear vcontrol irq and set OFF bit in STATUS_WORD. To signal the hardware that shutdown sequence is complete fault_shut_clr register is set.</p>
<p>Faults module triggers interrupt for each <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a> fault_status bit set on first come first serve basis. The status of which interrupt came in is read by the driver from fault_encode. Fault interrupt can't be triggered while fault_shut_o is set high. fault_shut_o is cleared by fault_shut_clr signal after the fault has been processed by the state machine (shutdown sequence and/or retry timer activation).</p>
<div class="image">
<img src="Fault_handler.jpg" alt="Fault_handler.jpg"/>
<div class="caption">
Faults Hardware Module Diagram</div></div>
 <h2><a class="anchor" id="sctShasta_FAULTS_Driver_HW"></a>
Fault Driver Operation Hardware faults</h2>
<p>Faults interrupt occurs each time the fault_status register is set meaning interrupt happens for each rising and falling edge of fault comparator. The faults driver determines which interrupt came in from the fault_encode register. Faults driver clears the fault status, latches the firmware fault status and flips the fault_polarity. Faults driver job is to determine the priority based on the fault response  and send the message REGULATION_CONTROLS_FAULT <a class="el" href="regulation__drv_8h.html#a6ce68e0adc0d7b47ee26747eba08bd36">REGULATION_CONTROLS</a> to regulation state machine REGULATION_Thread to move the sate to REGULATION_STATE_FAULT <a class="el" href="regulation__drv_8h.html#a3b960729126812964b017dabc31d764d">REGULATION_STATE</a> to perform the shutdown sequence or REGULATION_CONTROLS_FAULT with FAULT_CONTROL_RETRY (0x100) <a class="el" href="faults__drv_8h.html#aa0cc5b336c735233f83d99698f8e561f">FAULT_CONTROLS</a> to signal retry if fault cleared. In REGULATION_STATE_FAULT <a class="el" href="regulation__drv_8h.html#a6ce68e0adc0d7b47ee26747eba08bd36">REGULATION_CONTROLS</a> FW completes shutdown related cleanup (e.g., Vcontrol target returned to 0, appropriate blocks disabled) and activates the timer for retry delay in case of FAULT_CONTROL_RETRY (0x100) <a class="el" href="faults__drv_8h.html#aa0cc5b336c735233f83d99698f8e561f">FAULT_CONTROLS</a>.</p>
<p>The driver operates on each <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a> based on struct <a class="el" href="struct___f_a_u_l_t__s.html">_FAULT_s</a> that is setup by <a class="el" href="faults__api_8h.html#a213603c8c6edc1e610869b4c77ca68e8">FAULTS_SETUP_FAULT</a> and contains <a class="el" href="faults__api_8h.html#a1d42503724b4f80a8560de165bfdfcb3">FAULT_RESPONSE_TYPE_t</a>, retry count, delay time between retries, <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a> of its hysteresis, pmbus_status_command and pmbus_status_bit_position for reporting on pmbus status.</p>
<div class="image">
<img src="fault_irq.jpg" alt="fault_irq.jpg"/>
<div class="caption">
Fault Driver Operation Diagram</div></div>
 <h2><a class="anchor" id="sctShasta_FAULTS_DRIVER_FW"></a>
Fault Driver Operation Firmware faults</h2>
<p>The first 32 types of <a class="el" href="faults__api_8h.html#a16bcb3b5adca1e67a7515f3f96df46cb">FAULT_TYPE_t</a> are hardware type and have hardware comparators associated with them. The rest of 32 are firmware faults that are set by fault api.</p>
<p>Firmware fault is set by Set_Firmware_Fault:</p>
<div class="fragment"><div class="line"><span class="comment">//Example of setting an external fault</span></div>
<div class="line"><a class="code" href="faults__api_8c.html#aa2274676c3b2d4859597d4db2726b446">Set_Firmware_Fault</a>(</div>
<div class="line">        <a class="code" href="pmbus__autogen_8h.html#a153fe0ce3c320614ddc6651631226a14a1a20d32e44a4a8bbb2e6ac4524837583">PMBUS_PAGE_0</a> ,  <span class="comment">//PMBUS_PAGE_t pmbus page to update status on</span></div>
<div class="line">        <a class="code" href="regulation__state__machine__callbacks_8c.html#af21855ce2d508ac38ff7ef31f84f91b1">FAULT_TYPE_EXTERNAL</a>); <span class="comment">//FAULT_TYPE_t,</span></div>
</div><!-- fragment --><p>Firmware fault is cleared by Set_Firmware_Fault:</p>
<div class="fragment"><div class="line"><span class="comment">//Example of clearing an external fault</span></div>
<div class="line"><a class="code" href="faults__api_8c.html#aaa391f3aacf92d723686afaa803ac102">Clear_Firmware_Fault</a>(</div>
<div class="line">        <a class="code" href="pmbus__autogen_8h.html#a153fe0ce3c320614ddc6651631226a14a1a20d32e44a4a8bbb2e6ac4524837583">PMBUS_PAGE_0</a> ,  <span class="comment">//PMBUS_PAGE_t pmbus page to update status on</span></div>
<div class="line">        <a class="code" href="regulation__state__machine__callbacks_8c.html#af21855ce2d508ac38ff7ef31f84f91b1">FAULT_TYPE_EXTERNAL</a>); <span class="comment">//FAULT_TYPE_t,</span></div>
</div><!-- fragment --><p>Fault handler is executed each time the firmware fault is set and cleared. Faults handler is the same as for hw faults and uses the FAULT_TYPE_t argument of Set_Firmware_fault and Clear_Firmware_Fault for its fault_encode.</p>
<div class="image">
<img src="firmware_fault.jpg" alt="firmware_fault.jpg"/>
<div class="caption">
Fault Driver Operation Diagram</div></div>
 <h1><a class="anchor" id="sctShasta_FAULTS_FAULT_TYPES"></a>
Supported Fault Types</h1>
<h2><a class="anchor" id="sctShasta_FAULTS_FAULT_TYPES_ENUM"></a>
Fault Type Enum Table</h2>
<p>The faults driver supports both pmbus and non-pmbus faults and warns with a total of up to 60 fault/warn types: 30 hardware and 30 firmware faults. All of the supported faults and warns are enumerated in _FAULT_TYPE_t . Fault_types 0-31 are hardware faults with a comparator and fault status trigger in hardware. Fault_types 0 and 31 are reserved for driver operation as RESERVED_HW_NO_FAULT_NO_HYSTERSIS_CONDITION and FAULT_TYPE__END_OF_HW_FAULT_TYPES. Fault_types 32-63 are firmware faults that do not have a hardware comparator associated with them. Fault status set for these types of fault is in firmware. Fault types 32 and 63 are reserved for driver operation as RESERVED_FW_NO_FAULT_NO_HYSTERSIS_CONDITION and FAULT_TYPE__END_OF_FAULT_TYPES.</p>
<p>The list of all supported fault types with its hysteresis, response type, associated pmbus limit, response, status and delay config is presented in a table:</p>
<table class="doxtable">
<tr>
<th>FAULT_TYPE_t </th><th>hw / fw</th><th>Hysteresis FAULT_TYPE__e </th><th>Response config </th><th>Pmbus Threshold Command </th><th>Pmbus Response Command or Response Type </th><th>Pmbus Status Command</th><th>Pmbus Status Bit Position</th><th>Config_Delay_Unit  </th></tr>
<tr>
<td>reserved_hw_no_fault </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fault_type_vout_ov_fault </td><td>hw </td><td>fault_type_vout_ov_warn </td><td>voltage_response_type </td><td>vout_ov_fault_limit </td><td>vout_ov_fault_response </td><td>status_vout </td><td>7 vout ov fault </td><td>vout_delay_unit </td></tr>
<tr>
<td>fault_type_vout_ov_warn </td><td>hw </td><td>fault_type_vout_ov_fault </td><td>voltage_response_type </td><td>vout_ov_warn_limit </td><td>fault_response_ignore </td><td>status_vout </td><td>6 vout ov warning </td><td></td></tr>
<tr>
<td>fault_type_vout_uv_fault </td><td>hw </td><td>0 </td><td>voltage_response_type </td><td>vout_uv_fault_limit </td><td>vout_uv_fault_response </td><td>status_vout </td><td>4 vout uv fault </td><td>vout_delay_unit </td></tr>
<tr>
<td>fault_type_vout_uv_warn </td><td>hw </td><td>0 </td><td>voltage_response_type </td><td>vout_uv_warn_limit </td><td>fault_response_ignore </td><td>status_vout </td><td>5 vout uv warning </td><td></td></tr>
<tr>
<td>fault_type_vin_ov_fault </td><td>hw </td><td>fault_type_vin_ov_warn </td><td>voltage_response_type </td><td>vin_ov_fault_limit </td><td>vin_ov_fault_response </td><td>status_input </td><td>7 vin ov fault </td><td>vin_delay_unit </td></tr>
<tr>
<td>fault_type_vin_ov_warn </td><td>hw </td><td>fault_type_vin_ov_fault </td><td>voltage_response_type </td><td>vin_ov_warn_limit </td><td>fault_response_ignore </td><td>status_input </td><td>6 vin ov warning </td><td></td></tr>
<tr>
<td>fault_type_vin_uv_fault </td><td>hw </td><td>fault_type_vin_uv_warn </td><td>voltage_response_type </td><td>vin_uv_fault_limit </td><td>vin_uv_faultresponse </td><td>status_input </td><td>4 vin uv fault </td><td>vin_delay_unit </td></tr>
<tr>
<td>fault_type_vin_uv_warn </td><td>hw </td><td>fault_type_vin_uv_fault </td><td>voltage_response_type </td><td>vin_uv_warn_limit </td><td>fault_response_ignore </td><td>status_input </td><td>5 vin uv warning </td><td></td></tr>
<tr>
<td>fault_type_iout_oc_fault </td><td>hw </td><td>fault_type_iout_oc_warn </td><td>current_response_type </td><td>iout_oc_fault_limit </td><td>iout_ocfault_response </td><td>status_iout </td><td>7 iout oc fault </td><td>vout_delay_unit </td></tr>
<tr>
<td>fault_type_iout_oc_lv_fault </td><td>hw </td><td>0 </td><td>voltage_response_type </td><td>iout_oc_lv_fault_limit </td><td>fault_response_retry _shutdown </td><td>status_iout </td><td>6 iout oc fault w/LVShutdown</td><td>vout_delay_unit </td></tr>
<tr>
<td>fault_type_iout_oc_warn </td><td>hw </td><td>fault_type_iout_oc_fault </td><td>current_response_type </td><td>iout_oc_warn_limit </td><td>fault_response_ignore </td><td>status_iout </td><td>5 iout oc warning </td><td></td></tr>
<tr>
<td>fault_type_iout_uc_fault </td><td>hw </td><td>fault_type_iout_uc_fault </td><td>voltage_response_type </td><td>iout_uc_fault_limit </td><td>iout_uc_fault_response </td><td>status_iout </td><td>4 iout uc fault </td><td>iout_delay_unit </td></tr>
<tr>
<td>fault_type_mfr_iout_oc_fast </td><td>hw </td><td>fault_type_mfr_iout_oc_fast </td><td>current_response_type </td><td>mfr_iout_oc_fault_limit </td><td>mfr_iout_oc_fast_fault _response </td><td>status_mfr_specific</td><td>5 mfr </td><td>iout_delay_unit </td></tr>
<tr>
<td>fault_type_iin_oc_fault </td><td>hw </td><td>fault_type_iin_oc_warn </td><td>voltage_response_type </td><td>iin_oc_fault_limit </td><td>iin_oc_fault_response </td><td>status_input </td><td>2 iin oc fault </td><td>vin_delay_unit </td></tr>
<tr>
<td>fault_type_iin_oc_warn </td><td>hw </td><td>fault_type_iin_oc_fault </td><td>voltage_response_type </td><td>iin_oc_warn_limit </td><td>fault_response_ignore </td><td>status_input </td><td>1 iin oc warning </td><td></td></tr>
<tr>
<td>fault_type_ot_fault </td><td>hw </td><td>fault_type_ot_warn </td><td>voltage_response_type </td><td>ot_fault_limit </td><td>ot_fault_response </td><td>status_temperature </td><td>7 ot fault </td><td>temp_delay_unit </td></tr>
<tr>
<td>fault_type_ot_warn </td><td>hw </td><td>fault_type_ot_fault </td><td>voltage_response_type </td><td>ot_warn_limit </td><td>fault_response_ignore </td><td>status_temperature </td><td>6 ot warning </td><td></td></tr>
<tr>
<td>fault_type_ut_fault </td><td>hw </td><td>fault_type_ut_warn </td><td>voltage_response_type </td><td>ut_fault_limit </td><td>ut_fault_response </td><td>status_temperature </td><td>4 ut fault </td><td>temp_delay_unit </td></tr>
<tr>
<td>fault_type_ut_warn </td><td>hw </td><td>fault_type_ut_fault </td><td>voltage_response_type </td><td>ut_warn_limit </td><td>fault_response_ignore </td><td>status_temperature </td><td>5 ut warning </td><td></td></tr>
<tr>
<td>fault_type_in_power_limiting _mode</td><td>hw </td><td>0 </td><td>voltage_response_type </td><td></td><td>fault_response_ignore </td><td>status_iout </td><td>2 in power limiting mode </td><td></td></tr>
<tr>
<td>fault_type_current_share_fault</td><td>hw </td><td>0 </td><td>voltage_response_type </td><td></td><td>fault_response_ignore </td><td>status_iout </td><td>3 current share fault </td><td></td></tr>
<tr>
<td>fault_type_vout_max_mix_warn </td><td>hw </td><td>0 </td><td>voltage_response_type </td><td>vout_max, vout_min </td><td>fault_response_ignore </td><td>status_vout </td><td>3 vout max min warning </td><td></td></tr>
<tr>
<td>fault_type_sync_fault </td><td>hw </td><td>0 </td><td>voltage_response_type </td><td></td><td>fault_response_ignore </td><td>status_mfr_specific</td><td>7 mfr </td><td></td></tr>
<tr>
<td>fault_type_flux_balance_fault </td><td>hw </td><td>0 </td><td>voltage_response_type </td><td></td><td>fault_response_ignore </td><td>status_mfr_specific</td><td>6 mfr </td><td></td></tr>
<tr>
<td>hw_spare1 </td><td>hw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>hw_spare2 </td><td>hw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>hw_spare3 </td><td>hw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>hw_spare4 </td><td>hw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>hw_spare5 </td><td>hw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>hw_spare6 </td><td>hw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fault_type__end_of_hw_fault _types</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>reserved_fw_no_fault </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fault_type_common_shutdown </td><td>fw </td><td>0 </td><td>voltage_response_type </td><td></td><td>fault_response_retry _shutdown </td><td>status_mfr_specific</td><td>5 mfr </td><td></td></tr>
<tr>
<td>fault_type_ton_max_fault </td><td>fw </td><td>0 </td><td>voltage_response_type </td><td>ton_max_fault_limit </td><td>fault_response_ignore </td><td>status_vout </td><td>2 ton max fault </td><td>vout_delay_unit </td></tr>
<tr>
<td>fault_type_toff_max_warn </td><td>fw </td><td>0 </td><td>voltage_response_type </td><td>toff_max_fault_limit </td><td>fault_response_ignore </td><td>status_vout </td><td>1 toff max warning </td><td></td></tr>
<tr>
<td>fault_type_pin_op_warn </td><td>fw </td><td>0 </td><td>voltage_response_type </td><td>pin_op_warn_limit </td><td>fault_response_ignore </td><td>status_input </td><td>0 pin op warning </td><td></td></tr>
<tr>
<td>fault_type_pout_op_warn </td><td>fw </td><td>0 </td><td>voltage_response_type </td><td>pout_op_warn_limit </td><td>fault_response_ignore </td><td>status_iout </td><td>0 pout op warning </td><td></td></tr>
<tr>
<td>fw_spare1 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare2 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare3 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare4 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare5 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare6 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare7 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare8 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare9 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare10 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare11 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare12 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare13 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare14 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare15 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare16 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare17 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare18 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare19 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare20 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare21 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare22 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare23 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fw_spare24 </td><td>fw </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>fault_type__end_of_fault _types</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<h2><a class="anchor" id="sctShasta_FAULTS_FAULT_TYPES_VOUT_OV_FAULT"></a>
Fault Type Vout OV Fault Example</h2>
<p>FAULT_TYPE_VOUT_OV_FAULT is a hysteresis type fault. It is set when VOUT is above the limit set by VOUT_OV_FAULT_LIMIT and cleared when VOUT is below VOUT_OV_WARN_LIMIT. It is setup as VOLTAGE_RESPONSE_TYPE with FAULTS_CONFIG_VOUT_DELAY_UNIT. VOUT_OV_FAULT is reported on PMBUS_CMDCODE_STATUS_VOUT with bit position of PMBUS_STATUS_VOUT_OV_FAULT(bit 7). Response type, retry count and retry delay are configured by VOUT_OV_FAULT_RESPONSE command. Retry delay unit is set by pmbus command FW_CONFIG_FAULTS[7:6] - "FAULTS_CONFIG_VOUT_DELAY_UNIT".</p>
<div class="image">
<img src="vout_ov_fault_waves.jpg" alt="vout_ov_fault_waves.jpg"/>
<div class="caption">
vout ov fault example of shutdown and retry response type</div></div>
 <h2><a class="anchor" id="sctShasta_FAULTS_FAULT_TYPES_VOUT_UV_FAULT"></a>
Fault Type Vout UV Fault Example</h2>
<p>FAULT_TYPE_VOUT_UV_FAULT is a non hysteresis type fault. It is set when VOUT is below the limit set by VOUT_UV_FAULT_LIMIT and cleared by the driver in the REGULATION_STATE_FAULT. It is configured as VOLTAGE_RESPONSE_TYPE with FAULTS_CONFIG_VOUT_DELAY_UNIT, It reports on PMBUS_CMDCODE_STATUS_VOUT with bit position of PMBUS_STATUS_VOUT_UV_FAULT(bit 4). Response type, retry count and retry delay are configured by VOUT_UV_FAULT_RESPONSE command. Retry delay unit is set by pmbus command FW_CONFIG_FAULTS[7:6] - "FAULTS_CONFIG_VOUT_DELAY_UNIT". VOUT_UV_FAULT is masked until the unit reaches target voltage and when the device is disabled (Section 15.6 of PMBUS SPEC 1.3). Refer to vout uv fault masking picture in <a class="el" href="pg_shasta__f_a_u_l_t_s.html#sctShasta_FAULTS_FAULT_MASKING">Fault masking</a>. </p><div class="image">
<img src="vout_uv_fault_waves.jpg" alt="vout_uv_fault_waves.jpg"/>
<div class="caption">
vout uv fault example of shutdown and retry response type</div></div>
 <h2><a class="anchor" id="sctShasta_FAULTS_FAULT_TYPES_VIN_UV_FAULT"></a>
Fault Type Vin UV Fault Example</h2>
<p>FAULT_TYPE_VIN_UV_FAULT is a hysteresis type fault. It is set when VIN is below the limit set by VIN_UV_FAULT_LIMIT and cleared when VIN is above VIN_UV_WARN_LIMIT. It is configured as VOLTAGE_RESPONSE_TYPE with FAULTS_CONFIG_VIN_DELAY_UNIT, It reports on PMBUS_CMDCODE_STATUS_INPUT with bit position of PMBUS_STATUS_VIN_UV_FAULT(bit 4). Response type, retry count and retry delay are configured by VIN_UV_FAULT_RESPONSE command. Retry delay unit is set by pmbus command FW_CONFIG_FAULTS[5:4] - "FAULTS_CONFIG_VIN_DELAY_UNIT".</p>
<p>Vin is the input voltage applied to the primary side of the transformer. The device is capable of sensing this directly through the telemetry ADC (LSADC) but this requires additional isolation ($ and board area) and is generally too slow to be useful for PID Feed forward.</p>
<p>Vrect (rectification voltage) is Vin reflected to the secondary side of the transformer and is only available when the primary side is switching. We sense this using one of the high speed voltage sense ADC's. Since this voltage is only available after we start switching we do not have the actual Vin telemetry prior to attempting to startup. Input voltage source can be selected by tlm_vin_src_sel(regmap_telem) register. When input voltage source is set to Vrect1 or Vrect2 in order to avoid fault/warn tripping (input voltage telemetry is not available) and to have initial value for feed forward vrs_voltage_init</p>
<div class="image">
<img src="vin_uv_fault_waves.jpg" alt="vin_uv_fault_waves.jpg"/>
<div class="caption">
vin uv fault example of shutdown and retry response type</div></div>
 <h2><a class="anchor" id="sctShasta_FAULTS_FAULT_TYPES_IOUT_OC_FAULT"></a>
Fault Type IOUT OC Fault Example</h2>
<p>FAULT_TYPE_IOUT_OC_FAULT is a hysteresis type fault. It is set when IOUT is above the limit set by IOUT_OC_FAULT_LIMIT and cleared when IOUT is below IOUT_OC_WARN_LIMIT. It is setup as CURRENT_RESPONSE_TYPE with FAULTS_CONFIG_IOUT_DELAY_UNIT. IOUT_OC_FAULT is reported on PMBUS_CMDCODE_STATUS_IOUT with bit position of PMBUS_STATUS_IOUT_OC_FAULT(bit 7). Response type, retry count and retry delay are configured by IOUT_OC_FAULT_RESPONSE command. Retry delay unit is set by pmbus command FW_CONFIG_FAULTS[3:2] - "FAULTS_CONFIG_IOUT_DELAY_UNIT".</p>
<div class="image">
<img src="iout_oc_fault_shutdown_waves.jpg" alt="iout_oc_fault_shutdown_waves.jpg"/>
<div class="caption">
iout oc fault example of shutdown and retry response type</div></div>
<p> Picture below shows IOUT_OC_FAULT with constant current response. Constant current mechanism is implemented in hardware through adjustment of the vcontrol output. Fault IRQ is still triggered but since there is no shutdown fault control is not being sent to state machine. iout_cc_mode serves as an indicator of the constant current mode.</p>
<div class="image">
<img src="iout_oc_fault_cc_waves.jpg" alt="iout_oc_fault_cc_waves.jpg"/>
<div class="caption">
iout oc fault example of constant current response type</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Nov 8 2023 10:17:01 for XDPP1100 Firmware by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
