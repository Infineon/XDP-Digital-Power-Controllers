<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>XDPP1100 Firmware: Patch FW Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_infineon.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">XDPP1100 Firmware
   </div>
   <div id="projectbrief">The firmware documentation for the XDPP1100 device family.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('pg_shasta__patch.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Patch FW Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sctShasta_Patch_Introduction"></a>
Introduction</h1>
<p>The patch module allows to replace or extend existing firmware functionality which is stored in ROM. The code in ROM can be bug-fixed or extended by applying so-called patches. Patches modify the firmware functionality by either replacing single functions, by replacing major parts of the ROM code or by adding additional functions.</p>
<p>A patch can be download into RAM and stored in OTP for non-volatile storage. Such OTP-stored patches executed directly from OTP during the next system startup (Power-On-Reset, PoR).</p>
<h1><a class="anchor" id="pgShasta_Patch_Processing"></a>
OTP Patch Processing</h1>
<p>The patch module <a class="el" href="patch__app_8h.html#a12dc670ce670e36d8f3d9f196e067f7b">patch_otp_process</a> is called during the firmware startup. It scans the OTP patch memory area for patches (one or multiple patches).</p>
<p>Valid patches are executed directly from OTP. <br />
For <b>OTP Partial Patches</b>, the patch entry/init routine is called accordingly. The location and the patch entry routine address are part of the patch sub-command header Patch_Cmd_Image_t. The <code>make</code> <code>simvision_patch</code> command generates a binary patch file which contains such a patch sub-command header. <br />
For <b>OTP Full Patches</b>, the patch contains code which re-initializes the device and issues a reset. The REMAP bit ensures that the reset vector of the RAM IVT is used after reset. The RAM IVT is part of the patch image.</p>
<p>Multiple patches could be stored in OTP. All valid patches are executed and their initialization routines are called. Patches contain version information, and only patches intended for the current firmware version are applied. The initialization routines are called in sequence of loading the patches.</p>
<dl class="section user"><dt>Invalid Patches</dt><dd>The OTP command processing ignores patches which are marked as invalid commands (<a class="el" href="struct_otp___file___system___cmd___hdr__t.html#a83c1e98f4ef1a44bb4923a4ebb8fe492">Otp_File_System_Cmd_Hdr_t::cmd</a> = <a class="el" href="otp__fs_8h.html#a822d0027045dbf83793fc39bf6b55b23ac51365e713721e0a6d00de85008d71c7">OTP_FS_CMD_INVALID</a>). It jumps over these patches and to the next patch.</dd></dl>
<dl class="section user"><dt>Patch Size</dt><dd>The patch size fields inside the patch header are duplicated (redundant fields <a class="el" href="struct_otp___file___system___cmd___hdr__t.html#aaba88b24a21a6c70c895c0d55f4a69a0">Otp_File_System_Cmd_Hdr_t::size</a> and <a class="el" href="struct_otp___file___system___cmd___hdr__t.html#a1804b8e76bf5b844b532740034b9a809">Otp_File_System_Cmd_Hdr_t::size_red</a>). <br />
These redundant fields are used to compensate OTP programming errors. A patch effected by an OTP error might be lost but the patch routine can rely on the size parameter and jump to the next patch for further patch processing.</dd></dl>
<dl class="section user"><dt>CRC-32 Checksum</dt><dd>The patch contains CRC-32 checksum values for the header (<a class="el" href="struct_otp___file___system___cmd___hdr__t.html#aceda8e2bad71d55d75e6224474090885">Otp_File_System_Cmd_Hdr_t::crc_hdr</a>) and command data. The data crc is appended to the end of the patch. <br />
Patches with invalid header or data CRC-32 checksum are ignored.</dd></dl>
<dl class="section user"><dt>End of OTP Processing</dt><dd>The patch processing stops when the command termination word (<a class="el" href="struct_otp___file___system___cmd___hdr__t.html#a83c1e98f4ef1a44bb4923a4ebb8fe492">Otp_File_System_Cmd_Hdr_t::cmd</a> = <a class="el" href="otp__fs_8h.html#a822d0027045dbf83793fc39bf6b55b23a6fb628d703817180ba7b83efa2059f2a">OTP_FS_CMD_TERMINATION</a>) is found. <br />
This termination word (<a class="el" href="otp__fs_8h.html#a822d0027045dbf83793fc39bf6b55b23a6fb628d703817180ba7b83efa2059f2a">OTP_FS_CMD_TERMINATION</a>) is equal to the virgin memory state of the OTP memory technology. Further commands can be programmed in future at that location.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Ensure that all applied patches are linked against each other to avoid memory conflicts. For instance, patch1 and patch2 might show unexpected behavior in case both are linked into overlapping memory regions.</dd></dl>
<h1><a class="anchor" id="pgShasta_Patch_RAM_Patch_Table"></a>
RAM Patch Table</h1>
<p>A patch function lookup table is located in a patch. Some ROM functions check if an alternative function callback is placed inside the lookup table.</p>
<p>The size of the lookup table depends on the amount of supported functions to patch. A table entry is the 32-bit function pointer which should be called instead of the original (patched) function. if the patch entry is NULL then no patch is executed for this respective function.</p>
<h2><a class="anchor" id="pgShasta_Patch_Usage"></a>
Using A ROM Code Patch</h2>
<p>The patch function lookup table contains function pointer which replace existing functions. Each entry stands for a dedicated ROM function. Those ROM functions are manually instrumented by the patch macro <a class="el" href="patch__run_8h.html#ab9055c005494397f668d24f2f4572e01">PATCH_TABLE_RUN</a>, which checks if a patch for the current function is given. Any existing patch is then executed instead of the ROM function version.</p>
<h2><a class="anchor" id="pgShasta_Patch_RAM_Patch_Table_Example"></a>
Patched ROM Code Example</h2>
<p>The following example shows how the ROM function 'foo_original' calls the <a class="el" href="patch__run_8h.html#ab9055c005494397f668d24f2f4572e01">PATCH_TABLE_RUN</a> macro to check for an existing patch in the patch function lookup table. It would calculate 'a + b + c' in case no patch is found in the patch table. It would call 'foo_patch' in case it is located in the patch table, which would result in the calculation '(a + b + c )2'.</p>
<div class="fragment"><div class="line"><span class="comment">// local test routine which checks for a patch</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> foo_original(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> c)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="patch__run_8h.html#ab9055c005494397f668d24f2f4572e01">PATCH_TABLE_RUN</a>(foo_original, a, b, c);</div>
<div class="line">    <span class="comment">//origin calculation</span></div>
<div class="line">    <span class="keywordflow">return</span> a + b + c;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// routine that is used as patch</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> foo_patch(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> c)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//patched calculation</span></div>
<div class="line">    <span class="keywordflow">return</span> (a + b + c )2;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="pgShasta_Patch_Table_Example"></a>
Patch Table Example</h2>
<p>The following example shows how a RAM patch table could be declared allowing to patch 'foo_original'.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// this entry patches the function &#39;foo_original&#39;.</span></div>
<div class="line">    <span class="comment">// This entry contains three &#39;int&#39; parameter</span></div>
<div class="line">    <span class="comment">// Add other patch function need to added to this structure in the same</span></div>
<div class="line">    <span class="comment">// way, where the patch variable is generated out of the original</span></div>
<div class="line">    <span class="comment">// function name enhanced by the &quot;patch_...&quot; prefix.</span></div>
<div class="line">    int (*patch_foo_original)(int , int , int );</div>
<div class="line">}Patch_RAM_Table_t;</div>
<div class="line"></div>
<div class="line"><span class="comment">// patch table declaration</span></div>
<div class="line">PATCH_TABLE_t patch_table;</div>
</div><!-- fragment --><h2><a class="anchor" id="pgShasta_Patch_Table_Filling"></a>
Filling the Patch Table</h2>
<p>A patch updates the RAM patch table callback entry in case is wants to replace a ROM code function. The ROM will then call such callback (pointing to the RAM patch routine) instead of the original ROM function.</p>
<h1><a class="anchor" id="pgShasta_Patch_Interrupt"></a>
Interrupt and Exception Patching</h1>
<p>The firmware startup loads the RAM interrupt vector table (ROM version copy) before it starts the post RTX kernel initialization patching.</p>
<p>A patch entry routine could replace the existing interrupt vector table entries by functions that are provided with the patch. This overwrite mechanism allows to replace existing ROM interrupt handler routines by patched routines.</p>
<h1><a class="anchor" id="pgShasta_Patch_System_Startup_Precondition"></a>
System Startup Precondition</h1>
<p>During startup, the ROM code copies the exception vector table from ROM to RAM. It sets the REMAP bit in a way that the ARM core fetches the table content from RAM instead from ROM.</p>
<p>This startup also has to clear all patch function lookup table entries to zero (NULL).</p>
<h1><a class="anchor" id="pgShasta_Patch_Example"></a>
Patch Example</h1>
<p>The following figures illustrates an example where the ROM code is patched by an OTP patch. In the first figure, the patch entry routine ("foo1_patch_init") is called, which replaces a new RAM patch table entry that point to the foo1_patch() routine.</p>
<div class="image">
<img src="shasta_fw_otp_patch.svg" alt="shasta_fw_otp_patch.svg"/>
<div class="caption">
Loading the Patch Table from the Patch</div></div>
 The second figure illustrates that the foo1() ROM function calls the <a class="el" href="patch__run_8h.html#ab9055c005494397f668d24f2f4572e01">PATCH_TABLE_RUN</a> macro right after the function is entered. This macro checks if a RAM table entry is given for foo1(). It now executes the foo1_patch() function instead of the foo1() function instructions.</p>
<div class="image">
<img src="shasta_fw_otp_patch2.svg" alt="shasta_fw_otp_patch2.svg"/>
<div class="caption">
Executing the Patch Function</div></div>
 see <a class="el" href="pg_shasta_patch_user_guide.html">Patch Users Guide</a> and <a class="el" href="pg_shasta_otp_file_system.html">OTP File System</a> for more information. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Nov 8 2023 10:17:00 for XDPP1100 Firmware by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
