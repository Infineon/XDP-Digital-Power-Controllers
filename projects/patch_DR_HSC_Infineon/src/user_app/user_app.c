/*
 * user_app.c
 *
 *  Created on: Jun 13, 2017
 *      Author: dlewis4
 */


/** @page pgUser_App   User Example Code
 * The user application provides example code for various functions using the ROM linked API function calls.
 * @todo Add more descriptions here.
 *
 *
 * @section sfd Source File Documentation:
 *
 * Functions to execute periodically based on switching frequency.  Example includes frequency jitter/dither.
 *
 * @ref periodic_functions.c
 *
 * Autogenerated output from make target pmbus.  Takes spreadsheet and creates pmbus command handles.
 *
 * @ref pmbus_mfr_autogen.c
 *
 * Example of implementing callback function (handlers) for user pmbus commands.  These are executed
 * after pmbus transactions are received.
 *
 * @ref pmbus_mfr_specific_handlers.c
 *
 * Examples of callback (handles) for regulation state machine events.
 * Examples includes calling a function in ton rise state with enable controls.
 *
 * @ref regulation_state_machine_callbacks.c
 *
 * Example of a user implemented ntc lookup table.  Index of the array is the raw ADC code for TSEN A/B inputs.
 * Temperature is the return value of that ADC code.
 *
 * @ref user_ntc_temperature_lut.h
 *
 * Local init function:
 *
 * @ref user_drv_init
 */


#include "dtimer_drv.h"
#include "telemetry_drv.h"
#include "regulation_api.h"
#include "faults_api.h"
#include "faults_drv.h"
#include "pmbus_api.h"
#include "pmbus_gpio_control.h"
#include "shasta_hal_vsen.h"
#include "shasta_hal_vcontrol.h"
#include "shasta_hal_pwm.h"
#include "shasta_hal_pid.h"
//#include "shasta_hal_regulation.h"
#include "shasta_hal_scu.h"
#include "shasta_hal_cgu.h"
#include "shasta_hal_rgu.h"
#include "shasta_hal_telem.h"
#include "shasta_hal_common.h"
#include "shasta_hal_fault.h"
#include "shasta_hal_isen.h"
#include "regulation_state_machine_callbacks.h"
#include "pmbus_autogen.h"
#include "pmbus_mfr_autogen.h"
#include "user_app.h"
#include "cmsis_os.h"                   // ARM::CMSIS:RTOS:Keil RTX
#include "cmsis_os_ext.h"                   // ARM::CMSIS:RTOS:Keil RTX ext
#include "log_app.h"             /* Logging of errors */
#include "user_ntc_temperature_lut.h"
#include "patch_rom_table.h"
#include "string.h"
#include "add_on_features.h"
#include "ramp_data.h"
#include "uart_drv.h"                // uart driver functions
#include "pmbus_mfr_specific_handlers.h"
#include "shasta_hal_fault_common.h"
#include "shasta_hal_tsen.h"

void patch_Regulation_Shutdown_Sequence (PMBUS_PAGE_t loop, REGULATION_STATE state, REGULATION_CONTROLS control);
uint8_t patch_PMBUS_Get_On_Off_State (PMBUS_PAGE_t loop);
void patch_PMBUS_Gpio_Configure(void);
void patch_PMBUS_GPIO_CB (gpio_idx_t Bank, uint32_t Status);
#if 1
void patch_PMBUS_HANDLE_FW_CONFIG_FAULTS(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction);

void Telemetry_Setup_Irq_with_polarity(PMBUS_PAGE_t page, Telemetry_irq_src_t source, Telemetry_IRQ_TYPE_t Telemetry_type, Telemetry_handle handle, boolean polarity);
// VOUT UV fault -
//void patch_VOUT_UV_FAULT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction);
void patch_PMBUS_HANDLE_VOUT_UV_FAULT_LIMIT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction);
void patch_PMBUS_HANDLE_VOUT_UV_WARN_LIMIT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction);
void Telemetry_IRQ_VOUT_UV_FAULT_HANDLE(Telemetry_IRQ_TYPE_t Telemetry_type);

#if 0
// VIN UV fault
//void patch_VIN_UV_FAULT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction);
void patch_PMBUS_HANDLE_VIN_UV_FAULT_LIMIT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction);
void patch_PMBUS_HANDLE_VIN_UV_WARN_LIMIT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction);
void Telemetry_IRQ_VIN_UV_FAULT_HANDLE(Telemetry_IRQ_TYPE_t Telemetry_type);
#endif

#endif
//DTIMER_CONFIG_t dtimer6_cfg;
//DRIVER_DTIMER *drv6_info;

/**
 * Main entry point of the user application.  Good place to set breakpoint when debugging a patch.
 */
//void debug_example(void);
//void cb_test (uint32_t event);
void patch_pmbus_mfr_autogen_init(void);

void patch_pmbus_mfr_autogen_init(void)
{
	pmbus_mfr_autogen_init();

	// patch UVP fault response, OCP fault response, and OVP fault response
#if 1
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_UV_FAULT_RESPONSE] = patch_PMBUS_HANDLE_VOUT_UV_FAULT_LIMIT;
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT] = patch_PMBUS_HANDLE_VOUT_UV_FAULT_LIMIT;
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT] = patch_PMBUS_HANDLE_VOUT_UV_WARN_LIMIT;
#if 0
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_UV_FAULT_RESPONSE] = patch_PMBUS_HANDLE_VIN_UV_FAULT_LIMIT;
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT] = patch_PMBUS_HANDLE_VIN_UV_FAULT_LIMIT;
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_UV_WARN_LIMIT] = patch_PMBUS_HANDLE_VIN_UV_WARN_LIMIT;
#endif

	ptr_pmbus_callback[PMBUS_CMDCODE_FW_CONFIG_FAULTS] = patch_PMBUS_HANDLE_FW_CONFIG_FAULTS;
#endif

	// patch the MFR_FIRMWARE_COMMAND handle:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND] = patch_PMBUS_HANDLE_MFR_FIRMWARE_COMMAND;


}

void Telemetry_Setup_Irq_with_polarity(PMBUS_PAGE_t page, Telemetry_irq_src_t source, Telemetry_IRQ_TYPE_t Telemetry_type, Telemetry_handle handle, boolean polarity)
{
	uint16_t telem;
	telem = (uint16_t)TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__GET();
	//Clear hardware interrupt
	TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__SET(telem &~(1u<<(uint32_t)Telemetry_type));

	_Telemetry_s * Telemetry_str = Telemetry_GET_ARRAY_POINTER(Telemetry_type) ;
	Telemetry_str->loop = page;
	Telemetry_str->source = source;
	//Set the handle
	Telemetry_IRQ_Event_Handle_Set(Telemetry_type, handle);
	//Reset to initial polarity
	//Set the threshold
	//Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, source, Telemetry_str->mantissa, Telemetry_str->exponent);
	Telemetry_Set_Irq_Polarity(Telemetry_type, polarity);
	TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__SET(telem);
}

#if 1
void patch_PMBUS_HANDLE_FW_CONFIG_FAULTS(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction){
	if ((direction == PMBUS_WRITE)||(direction == OTP_RESTORE))
	{
		//SET ENABLE LOOP_HW
		FAULT_HW_App[page].enable_mask_pmbus = ~(FAULTS_Get_PMBUS_Configuration(page, FAULTS_CONFIG_FAULT_ENABLE_MASK_LOOP_HW));
		FAULT_HW_App[page].fault_enable = FAULT_HW_App[page].enable_mask &
											FAULT_HW_App[page].enable_mask_driver &
											FAULT_HW_App[page].enable_mask_pmbus;

		//Apply the fault mask
		FAULT_FAULT_ENABLE_LOOP__SET((fault_idx_t) page, FAULT_HW_App[page].fault_enable);

		//SET ENABLE LOOP_FW
		FAULT_FW_App[page].enable_mask_pmbus = ~(FAULTS_Get_PMBUS_Configuration(page, FAULTS_CONFIG_FAULT_ENABLE_MASK_LOOP_FW));
		FAULT_FW_App[page].fault_enable = FAULT_FW_App[page].enable_mask &
											FAULT_FW_App[page].enable_mask_driver &
											FAULT_FW_App[page].enable_mask_pmbus;

		//SET ENABLE COMMON
		FAULT_COMMON_App.enable_mask_pmbus = ~(FAULTS_Get_PMBUS_Configuration(PMBUS_PAGE_0, FAULTS_CONFIG_FAULT_ENABLE_MASK_LOOP_COMMON));
		FAULT_COMMON_App.fault_enable = FAULT_COMMON_App.enable_mask &
											FAULT_COMMON_App.enable_mask_driver &
												FAULT_COMMON_App.enable_mask_pmbus;
		FAULTCOM_FAULT_ENABLE_COM__SET(FAULT_COMMON_App.fault_enable);

		PMBUS_HANDLE_VIN_ON(page, PMBUS_WRITE);
		PMBUS_HANDLE_VOUT_MIN(page, PMBUS_WRITE);
		PMBUS_HANDLE_VOUT_MAX(page, PMBUS_WRITE);
		PMBUS_HANDLE_VOUT_OV_FAULT_LIMIT(page, PMBUS_WRITE);
		patch_PMBUS_HANDLE_VOUT_UV_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_VIN_OV_FAULT_LIMIT(page, PMBUS_WRITE);
#if 0
		patch_PMBUS_HANDLE_VIN_UV_FAULT_LIMIT(page, PMBUS_WRITE);
#else
		PMBUS_HANDLE_VIN_UV_FAULT_LIMIT(page, PMBUS_WRITE);
#endif
		PMBUS_HANDLE_IOUT_OC_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_MFR_IOUT_OC_FAST_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_IOUT_OC_LV_FAULT_LIMIT(page, PMBUS_WRITE);  // do after PMBUS_HANDLE_MFR_IOUT_OC_FAST_FAULT_LIMIT and PMBUS_HANDLE_IOUT_OC_FAULT_LIMIT
		PMBUS_HANDLE_IOUT_UC_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_IIN_OC_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_TON_MAX_FAULT_LIMIT(page, PMBUS_WRITE);


		PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR(page, PMBUS_WRITE);  // do UT and OT faults here to mask them while changing limits
		//PMBUS_HANDLE_OT_FAULT_LIMIT(page, PMBUS_WRITE); //this are done inside PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR
		//PMBUS_HANDLE_OT_WARN_LIMIT(page, PMBUS_WRITE); //this are done inside PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR
		//PMBUS_HANDLE_UT_WARN_LIMIT(page, PMBUS_WRITE); //this are done inside PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR
		//PMBUS_HANDLE_UT_FAULT_LIMIT(page, PMBUS_WRITE); //this are done inside PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR

		//if (Telemetry_Get_PMBUS_Configuration((PMBUS_PAGE_t)page, (TELEMETRY_CONFIG)TELEMETRY_CONFIG_GAIN_OFFSET_FAULT_THRESH_EN))
		//{
			PMBUS_HANDLE_VOUT_OV_WARN_LIMIT(page, PMBUS_WRITE);  // warns are not using fw_config_faults for delay time so no need to call here
			PMBUS_HANDLE_VOUT_UV_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_VIN_OV_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_VIN_UV_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_IOUT_OC_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_IIN_OC_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_POUT_OP_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_PIN_OP_WARN_LIMIT(page, PMBUS_WRITE);
		//}
		//Faults_Clear_Faults(page);
	}

}
void patch_PMBUS_HANDLE_VOUT_UV_FAULT_LIMIT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction)
{
	PMBUS_HANDLE_VOUT_UV_FAULT_LIMIT(page,  direction);
	if(page == PMBUS_PAGE_0)			// only track vout uv for loop 0 and modify this for three thresholds
		patch_VOUT_UV_FAULT(page,  direction);


}
void patch_PMBUS_HANDLE_VOUT_UV_WARN_LIMIT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction)
{
	PMBUS_HANDLE_VOUT_UV_WARN_LIMIT(page,  direction);
	if (direction == PMBUS_WRITE)
	{
		if(page == PMBUS_PAGE_0)
			patch_VOUT_UV_FAULT(page,  direction);	// only track vout uv for loop 0 and modify this for three thresholds
	}

}

void patch_VOUT_UV_FAULT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction)
{

	boolean polarity;
	//uint32_t vin;
	int8_t vout_read_exp[NUM_LOOPS];
	uint32_t vout,vout_shift,vout_02v,vout_warn,vout_fault;
	Telemetry_IRQ_TYPE_t Telemetry_type;

	if ((direction == PMBUS_WRITE))
	{
		uint16_t warn_mantissa = PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT);
		int32_t  exponent = PMBUS_Get_Vout_Mode_Exponent(page);
		uint16_t fault_mantissa = PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT);
		int32_t threshold_exponent = LINEAR11_TO_EXPONENT(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_MFR_CONFIG_THRESHOLD));
		uint16_t threshold_mantissa = (uint16_t)LINEAR11_TO_MANTISSA(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_MFR_CONFIG_THRESHOLD));

		//if(page == PMBUS_PAGE_0)
			Telemetry_type = TELEM_IRQ14;
		//else
		//	Telemetry_type = TELEM_IRQ15;


		//if (page==PMBUS_PAGE_1)
		//{
			/*
			Telemetry_Set_Irq_Threshold(TELEM_IRQ14, (int32_t)warn_mantissa, (int8_t)exponent);
			Telemetry_Set_Irq_Hysteresis_Threshold(TELEM_IRQ14, (int32_t)(fault_mantissa), (int8_t)exponent);
			Telemetry_Setup_Irq(page, VOUT_0, TELEM_IRQ14, Telemetry_IRQ_VOUT_UV_FAULT_HANDLE);
			Telemetry_Enable_IRQ_Type(TELEM_IRQ14);*/

			// set up the polarity and thresholds based on the output voltage
			vout_read_exp[page] = (int8_t)PMBUS_Get_Vout_Mode_Exponent((PMBUS_PAGE_t)page);
			vout_shift = (uint32_t)Telemetry_get((PMBUS_PAGE_t)page, VOUT_TELEM);
			vout_shift = (uint32_t)SHIFT_EXPONENT((int32_t)vout_shift,  PMBUS_Q_EXP - vout_read_exp[page]);  // convert to vout_mode format
			if (vout_shift>0xFFFF) vout_shift = 0xFFFF;

			vout = (uint32_t)SHIFT_EXPONENT((int32_t)vout_shift,  exponent - PMBUS_Q_EXP );
			vout_02v = (uint32_t)SHIFT_EXPONENT((int32_t)threshold_mantissa,  threshold_exponent - PMBUS_Q_EXP );
			vout_warn = (uint32_t)SHIFT_EXPONENT((int32_t)warn_mantissa, exponent - PMBUS_Q_EXP  );
			vout_fault = (uint32_t)SHIFT_EXPONENT((int32_t)fault_mantissa,  exponent - PMBUS_Q_EXP );

			Telemetry_Set_Irq_Threshold(Telemetry_type, (int32_t)warn_mantissa, (int8_t)exponent);

			if (vout > vout_warn)
			{
				polarity = 1;		// waiting for below the fault limit - look out for below fault , if the current vout is greater than earn limit
				Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)(fault_mantissa), (int8_t)exponent);
			}
			else if ((vout < vout_fault) && (vout > vout_02v))		// if vout is below fault limit and greater than 0.2v then still look out for the below update the hys
			{
				polarity = 1;		// waiting for below the 0.2v
				Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)(threshold_mantissa), (int8_t)threshold_exponent);
			}
			else if (vout < vout_02v)			// if vout is below 0.2v  look for above warn limit and update the hyst back to fault limit
			{
				polarity = 0;		//waiting for above the warn limit
				Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)(fault_mantissa), (int8_t)exponent);
			}
			else
			{
				polarity = 0;		//waiting for above the warn limit
				Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)(fault_mantissa), (int8_t)exponent);
			}

			if(page == PMBUS_PAGE_0)
				Telemetry_Setup_Irq_with_polarity(page, VOUT_0, Telemetry_type, Telemetry_IRQ_VOUT_UV_FAULT_HANDLE,polarity);
			else
				Telemetry_Setup_Irq_with_polarity(page, VOUT_1, Telemetry_type, Telemetry_IRQ_VOUT_UV_FAULT_HANDLE,polarity);

			Telemetry_Enable_IRQ_Type(Telemetry_type);
		//}
		/*
		else
		{
			Telemetry_Set_Irq_Threshold(TELEM_IRQ15, (int32_t)warn_mantissa, (int8_t)exponent);
			Telemetry_Set_Irq_Hysteresis_Threshold(TELEM_IRQ15, (int32_t)(fault_mantissa), (int8_t)exponent);
			Telemetry_Setup_Irq(page, VOUT_1, TELEM_IRQ15, Telemetry_IRQ_VOUT_UV_FAULT_HANDLE);
			Telemetry_Enable_IRQ_Type(TELEM_IRQ15);
		}*/
	}
}

void Telemetry_IRQ_VOUT_UV_FAULT_HANDLE(Telemetry_IRQ_TYPE_t Telemetry_type)
{
	_Telemetry_s * Telemetry_str = Telemetry_GET_ARRAY_POINTER(Telemetry_type);
	//uint16_t telem;
	PMBUS_PAGE_t page;

	//if(Telemetry_type == TELEM_IRQ14)
		page = PMBUS_PAGE_0;
	//else
	//	page = PMBUS_PAGE_1;

	uint16_t mantissa = PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT);
	int32_t  exponent = PMBUS_Get_Vout_Mode_Exponent(page);
	int32_t threshold_exponent = LINEAR11_TO_EXPONENT(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_MFR_CONFIG_THRESHOLD));
	uint16_t threshold_mantissa = (uint16_t)LINEAR11_TO_MANTISSA(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_MFR_CONFIG_THRESHOLD));
	//uint16_t hysteresis_mantissa = PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT);

   	if (~(Telemetry_str->polarity)&1) 				// if is executed vout is below the fault limit
   	{
   		if (Telemetry_str->hysteresis_mantissa == threshold_mantissa && Telemetry_str->hysteresis_exponent == threshold_exponent)		// check if the threshold is below 200 mv then shutdown
   		{
   			//telem = (uint16_t)TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__GET();
   			//Clear hardware interrupt
   			//TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__SET(telem &~(1u<<(uint32_t)Telemetry_type));
   			Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)mantissa, (int8_t)exponent);
   			if(Telemetry_type == TELEM_IRQ14)
   				Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VOUT_0, (int32_t)mantissa, (int8_t)exponent);
   			else
   				Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VOUT_1, (int32_t)mantissa, (int8_t)exponent);

   			Telemetry_Set_Irq_Polarity(Telemetry_type, 0);		// look for above and this sets the threshold as  threshold - Warn limt
   			//TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__SET(telem);

   			if (page ==0)
   			{
   				PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__SET(0);////
   			}
   			Regulation_Shutdown_Sequence (page, REGULATION_STATE_OFF, REGULATION_CONTROLS_SHUTDOWN_IMMEDIATE);
			REGULATION_INTER_THREAD_SET(page, REGULATION_CONTROLS_SHUTDOWN_IMMEDIATE, 0);
			// shutdown  loop1 right after loop 0 immedialty
   			Regulation_Shutdown_Sequence (PMBUS_PAGE_1, REGULATION_STATE_OFF, REGULATION_CONTROLS_SHUTDOWN_IMMEDIATE);
			REGULATION_INTER_THREAD_SET(PMBUS_PAGE_1, REGULATION_CONTROLS_SHUTDOWN_IMMEDIATE, 0);

   		}
   		else		// for the fist time vout is below the fault limit . change the lower threshold to 200 mv threshold.
   		{
   			//telem = (uint16_t)TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__GET();
   			//Clear hardware interrupt
   			//TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__SET(telem &~(1u<<(uint32_t)Telemetry_type));
   			Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)threshold_mantissa, (int8_t)threshold_exponent);
   			if(Telemetry_type == TELEM_IRQ14)
   				Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VOUT_0, (int32_t)threshold_mantissa, (int8_t)threshold_exponent);
   			else
   				Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VOUT_1, (int32_t)threshold_mantissa, (int8_t)threshold_exponent);

   			Telemetry_Set_Irq_Polarity(Telemetry_type, 1);		// look for below 200 mv . if it goes below 200 mv - shutdown.
   			//TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__SET(telem);

   			//enable the EFUSE - pull down on PWM -    // Send the GPIO EFUSE output signal

#ifdef SYNC_PIN_ENABLED
   			/*
   		   	uint8_t sync_pin_gpio_bit_index = 7; //bit7 - GPIO[7]
   		   	COMMON_MP_FUNC2__SYNC_FUNC__SET(1);  //SYNC pin - GPIO0[7]
   		   	COMMON_MP_FUNC2__SYNC_PD__SET(0); 	 //pulldown disabled
   		   	COMMON_MP_FUNC2__SYNC_PU_N__SET(1);  //pullup disabled
   		   	COMMON_MP_FUNC2__SYNC_PPEN__SET(1);  //CMOS output

   		   	GpioBit_SetCnfg (GPIO_0, sync_pin_gpio_bit_index);
   		   	GpioBit_SetDir (GPIO_0, sync_pin_gpio_bit_index, DIRECTION_OUTPUT);
   		   	GpioBit_DatWr(GPIO_0, sync_pin_gpio_bit_index, 0x00); // gpio driver requires a value of 1 on bus to be 0xff in index of that data location
   		   	*/
   			uint8_t imon_pin_gpio_bit_index = 3; //bit3
   			COMMON_MP_FUNC2__IMON_FUNC__SET(1);  //IMon pin - GPIO0[3] (mp imon pin )
   			COMMON_MP_FUNC2__IMON_PD__SET(0); 	 //pulldown disabled
   			COMMON_MP_FUNC2__IMON_PU_N__SET(1);  //pullup disabled
   			COMMON_MP_FUNC2__IMON_PPEN__SET(1);  //CMOS output

   			GpioBit_SetCnfg (GPIO_0, imon_pin_gpio_bit_index);
   			GpioBit_SetDir (GPIO_0, imon_pin_gpio_bit_index, DIRECTION_OUTPUT);
   			GpioBit_DatWr(GPIO_0, imon_pin_gpio_bit_index, 0x00); // gpio driver requires a value of 1 on bus to be 0xff in index of that data location

#else
   		 uint8_t pwm1_bit_index = 5; //bit5
   		   	COMMON_MP_FUNC3__PWM1_FUNC__SET(1);  //GPIO0[5]
   		   	COMMON_MP_FUNC3__PWM1_PD__SET(0); 	 //pulldown disabled
   		   	COMMON_MP_FUNC3__PWM1_PU_N__SET(1);  //pullup disabled
   		   	COMMON_MP_FUNC3__PWM1_PPEN__SET(1);  //CMOS output
   		   	GpioBit_SetCnfg (GPIO_0, pwm1_bit_index);
   		   	GpioBit_SetDir (GPIO_0, pwm1_bit_index, DIRECTION_OUTPUT);
   		   	GpioBit_DatWr(GPIO_0, pwm1_bit_index, 0); // gpio driver requires a value of 1 on bus to be 0xff in index of that data location
#endif
   		}
   	}
   	else		//else is executed when threshold is above the Warn limit
   	{
   		Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)mantissa, (int8_t)exponent);
   		if(Telemetry_type == TELEM_IRQ14)
   			Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VOUT_0, (int32_t)mantissa, (int8_t)exponent);
   		else
   			Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VOUT_1, (int32_t)mantissa, (int8_t)exponent);

		Telemetry_Set_Irq_Polarity(Telemetry_type, 1);			//look for below
   	}
}

#if 0
void patch_PMBUS_HANDLE_VIN_UV_WARN_LIMIT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction)
{
	PMBUS_HANDLE_VIN_UV_WARN_LIMIT(page,  direction);
	if (direction == PMBUS_WRITE)
		patch_VIN_UV_FAULT(page,  direction);
}

void patch_PMBUS_HANDLE_VIN_UV_FAULT_LIMIT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction)
{
	PMBUS_HANDLE_VIN_UV_FAULT_LIMIT(page,  direction);
	patch_VIN_UV_FAULT(page,  direction);
}

void patch_VIN_UV_FAULT(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction)
{

	if ((direction == PMBUS_WRITE))
	{
		int32_t warn_exponent = LINEAR11_TO_EXPONENT(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VIN_UV_WARN_LIMIT));
		uint16_t warn_mantissa = (uint16_t)LINEAR11_TO_MANTISSA(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VIN_UV_WARN_LIMIT));
		uint16_t fault_mantissa =  (uint16_t)LINEAR11_TO_MANTISSA(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT));
		int32_t fault_exponent = LINEAR11_TO_EXPONENT(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT));
		boolean polarity;
		uint32_t vin,vin_shift;
		//int8_t vout_read_exp[NUM_LOOPS];
		uint32_t vin_02v,vin_warn,vin_fault;
		Telemetry_IRQ_TYPE_t Telemetry_type;

		if(page == PMBUS_PAGE_0)
			Telemetry_type = TELEM_IRQ12;
		else
			Telemetry_type = TELEM_IRQ13;


		//if (page==PMBUS_PAGE_1)
		//{
			/*Telemetry_Set_Irq_Threshold(TELEM_IRQ12, (int32_t)warn_mantissa, (int8_t)exponent);
			Telemetry_Set_Irq_Hysteresis_Threshold(TELEM_IRQ12, (int32_t)(fault_mantissa), (int8_t)exponent);
			Telemetry_Setup_Irq(page, VIN_0, TELEM_IRQ12, Telemetry_IRQ_VIN_UV_FAULT_HANDLE);
			Telemetry_Enable_IRQ_Type(TELEM_IRQ12);*/

			// set up the polarity and thresholds based on the output voltage
			//vout_read_exp[page] = (int8_t)PMBUS_Get_Vout_Mode_Exponent((PMBUS_PAGE_t)page);
			vin_shift = (uint32_t)Telemetry_get((PMBUS_PAGE_t)page, VIN_TELEM);
			if (vin_shift>0x3FF) vin_shift = 0x3FF;

			vin = (uint32_t)SHIFT_EXPONENT((int32_t)vin_shift, -3- PMBUS_Q_EXP );
			vin_02v = (uint32_t)SHIFT_EXPONENT((int32_t)20,  -6 - PMBUS_Q_EXP );
			vin_warn = (uint32_t)SHIFT_EXPONENT((int32_t)warn_mantissa,  warn_exponent - PMBUS_Q_EXP  );
			vin_fault = (uint32_t)SHIFT_EXPONENT((int32_t)fault_mantissa,  fault_exponent - PMBUS_Q_EXP );

			Telemetry_Set_Irq_Threshold(Telemetry_type, (int32_t)warn_mantissa, (int8_t)warn_exponent);

			if (vin > vin_warn)
			{
				polarity = 1;		// waiting for below the fault limit - look out for below fault , if the current vout is greater than earn limit
				Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)(fault_mantissa), (int8_t)fault_exponent);
			}
			else if ((vin < vin_fault) && (vin > vin_02v))		// if vout is below fault limit and greater than 0.2v then still look out for the below update the hys
			{
				polarity = 1;		// waiting for below the 0.2v
				Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)(20), (int8_t)-2);
			}
			else if (vin < vin_02v)			// if vout is below 0.2v  look for above warn limit and update the hyst back to fault limit
			{
				polarity = 0;		//waiting for above the warn limit
				Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)(fault_mantissa), (int8_t)fault_exponent);
			}
			else
			{
				polarity = 0;		//waiting for above the warn limit
				Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)(fault_mantissa), (int8_t)fault_exponent);
			}
			if(page == PMBUS_PAGE_0)
				Telemetry_Setup_Irq_with_polarity(page, VIN_0, Telemetry_type, Telemetry_IRQ_VIN_UV_FAULT_HANDLE,polarity);
			else
				Telemetry_Setup_Irq_with_polarity(page, VIN_1, Telemetry_type, Telemetry_IRQ_VIN_UV_FAULT_HANDLE,polarity);

			Telemetry_Enable_IRQ_Type(Telemetry_type);
		//}
		/*
		else
		{
			Telemetry_Set_Irq_Threshold(TELEM_IRQ13, (int32_t)warn_mantissa, (int8_t)warn_exponent);
			Telemetry_Set_Irq_Hysteresis_Threshold(TELEM_IRQ13, (int32_t)(fault_mantissa), (int8_t)fault_exponent);
			Telemetry_Setup_Irq(page, VIN_1, TELEM_IRQ13, Telemetry_IRQ_VIN_UV_FAULT_HANDLE);
			Telemetry_Enable_IRQ_Type(TELEM_IRQ13);
		}*/
	}
}

void Telemetry_IRQ_VIN_UV_FAULT_HANDLE(Telemetry_IRQ_TYPE_t Telemetry_type)
{
	_Telemetry_s * Telemetry_str = Telemetry_GET_ARRAY_POINTER(Telemetry_type);
	//uint16_t telem;
	PMBUS_PAGE_t page;

	if(Telemetry_type == TELEM_IRQ12)
		page = PMBUS_PAGE_0;
	else
		page = PMBUS_PAGE_1;

	uint16_t mantissa = (uint16_t)LINEAR11_TO_MANTISSA(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT));
	int32_t  exponent = LINEAR11_TO_EXPONENT(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT));

   	if (~(Telemetry_str->polarity)&1) 				// if is executed vout is below the fault limit
   	{

   		if (Telemetry_str->hysteresis_mantissa == 20 && Telemetry_str->hysteresis_exponent == -2)		// check if the threshold is below 2000 mv then shutdown
   		{
   			Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)mantissa, (int8_t)exponent);
			if(page == PMBUS_PAGE_0)
				Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VIN_0, (int32_t)mantissa, (int8_t)exponent);
			else
				Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VIN_1, (int32_t)mantissa, (int8_t)exponent);

   			Telemetry_Set_Irq_Polarity(Telemetry_type, 0);		// look for above and this sets the threshold as  threshold - Warn limt
   			Regulation_Shutdown_Sequence (page, REGULATION_STATE_OFF, REGULATION_CONTROLS_SHUTDOWN_IMMEDIATE);
			REGULATION_INTER_THREAD_SET(page, REGULATION_CONTROLS_SHUTDOWN_IMMEDIATE, 0);

   		}
   		else		// for the fist time vout is below the fault limit . change the lower threshold to 2000 mv threshold.
   		{
   			Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)20, (int8_t)-2);
   			if(page == PMBUS_PAGE_0)
   				Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VIN_0, (int32_t)20, (int8_t)-2);
   			else
   				Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VIN_1, (int32_t)20, (int8_t)-2);

   			Telemetry_Set_Irq_Polarity(Telemetry_type, 1);		// look for below 200 mv . if it goes below 2000 mv - shutdown.

   			//enable the EFUSE - pull down on PWM -    // Send the GPIO EFUSE output signal

   			//COMMON_MP_FUNC3__PWM1_FUNC__SET(1);  //GPIO0[5]
#ifdef SYNC_PIN_ENABLED
   			uint8_t imon_pin_gpio_bit_index = 3; //bit3
   			COMMON_MP_FUNC2__IMON_FUNC__SET(1);  //IMon pin - GPIO0[3] (mp imon pin )
   			COMMON_MP_FUNC2__IMON_PD__SET(0); 	 //pulldown disabled
   			COMMON_MP_FUNC2__IMON_PU_N__SET(1);  //pullup disabled
   			COMMON_MP_FUNC2__IMON_PPEN__SET(1);  //CMOS output

   			GpioBit_SetCnfg (GPIO_0, imon_pin_gpio_bit_index);
   			GpioBit_SetDir (GPIO_0, imon_pin_gpio_bit_index, DIRECTION_OUTPUT);
   			GpioBit_DatWr(GPIO_0, imon_pin_gpio_bit_index, 0x00); // gpio driver requires a value of 1 on bus to be 0xff in index of that data location
#else
   	    	uint8_t pwm1_bit_index = 5; //bit5 - GPIO[5]
   		   	COMMON_MP_FUNC3__PWM1_FUNC__SET(1);  //GPIO0[5]
   		   	COMMON_MP_FUNC3__PWM1_PD__SET(0); 	 //pulldown disabled
   		   	COMMON_MP_FUNC3__PWM1_PU_N__SET(1);  //pullup disabled
   		   	COMMON_MP_FUNC3__PWM1_PPEN__SET(1);  //CMOS output
   		   	GpioBit_SetCnfg (GPIO_0, pwm1_bit_index);
   		   	GpioBit_SetDir (GPIO_0, pwm1_bit_index, DIRECTION_OUTPUT);
   		   	GpioBit_DatWr(GPIO_0, pwm1_bit_index, 0); // gpio driver requires a value of 1 on bus to be 0xff in index of that data location
#endif

   		}
   	}
   	else		//else is executed when threshold is above the Warn limit
   	{
   		Telemetry_Set_Irq_Hysteresis_Threshold(Telemetry_type, (int32_t)mantissa, (int8_t)exponent);
		if(page == PMBUS_PAGE_0)
			Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VIN_0, (int32_t)mantissa, (int8_t)exponent);
		else
			Telemetry_Generic_Irq_Threshold_Set(Telemetry_type, VIN_1, (int32_t)mantissa, (int8_t)exponent);

		Telemetry_Set_Irq_Polarity(Telemetry_type, 1);			//look for below
   	}
}

#endif
#endif

void user_drv_init(void)
{
	memset(&user_data, 0, sizeof(USER_DATA_t));  // ZI the user data
	//patch_rom_table.patch_FAULTS_Resolve_Shutdown_Priority = &FAULTS_User_Resolve_Shutdown_Priority;
	//ntc_temp = &user_ntc_temp_lut[0];  // set the ntc lut to rom constant table
	// this is the initialization of user pmbus commands autogenerated from pmbus spreadsheet

	patch_rom_table.patch_PMBUS_Gpio_Configure = &patch_PMBUS_Gpio_Configure;
	patch_rom_table.patch_PMBUS_GPIO_CB = &patch_PMBUS_GPIO_CB;
	patch_rom_table.patch_PMBUS_Get_On_Off_State = &patch_PMBUS_Get_On_Off_State;

	patch_rom_table.patch_Regulation_Shutdown_Sequence = &patch_Regulation_Shutdown_Sequence;

	ptr_mfr_specific_init = (mfr_specific_init_ptr) patch_pmbus_mfr_autogen_init;
	set_module_init_cb(MODULE_REGULATION, regulation_sm_callbacks_init);  // set the pointer funtion in init of regulation state machine to user callback setup for each state
	add_on_features_init();

	regulation_sm_callbacks_init();
}

void patch_PMBUS_Gpio_Configure(void)
{
    //python automated patch entry
    //VOID_PATCH_TABLE_RUN(PMBUS_Gpio_Configure)

	int32_t temp;
	for (uint8_t i=0; i<NUM_LOOPS; i++)
	{

		int32_t vr_enable_bit_index = PMBUS_Gpio_Get_PMBUS_Configuration((PMBUS_PAGE_t)i, PMBUS_GPIO_CONFIG_ENABLE_SELECT);
		int32_t power_good_bit_index = PMBUS_Gpio_Get_PMBUS_Configuration((PMBUS_PAGE_t)i, PMBUS_GPIO_CONFIG_POWER_GOOD_SELECT);
		int32_t fault_bit_index = PMBUS_Gpio_Get_PMBUS_Configuration((PMBUS_PAGE_t)i, PMBUS_GPIO_CONFIG_FAULT_SELECT);

		// if the bits are all configured the same way lets pick a normal default
		if ((vr_enable_bit_index==0)&&(power_good_bit_index==0)&&(fault_bit_index==0))
		{
			vr_enable_bit_index = 0;  	// gpio0
			power_good_bit_index = 1;  	// gpio1
			fault_bit_index = 2;		// gpio2
		}

		// VR_ENABLE
		GpioBit_SetCnfg ((gpio_idx_t) i, (uint8_t)vr_enable_bit_index);		//This one sets the confing
		GpioBit_SetDir ((gpio_idx_t) i, (uint8_t)vr_enable_bit_index, DIRECTION_INPUT);
		GpioBank_SetCallbackHandler(patch_PMBUS_GPIO_CB);
		GpioBit_IntrType((gpio_idx_t) i, (uint8_t)vr_enable_bit_index, GPIO_IRQ_TYPE_EDGE_BOTH);  // interrupt on both edges
#if  GPIO_DGLITCH
	    Gpio_Dglitch_activation((dtimer_instance_e) i+4, 2000);
	    GpioBit_Dglitch_IntrEnable((gpio_idx_t) i, vr_enable_bit_index);
#else
		GpioBit_IntrEnable((gpio_idx_t) i, (uint8_t)vr_enable_bit_index);
#endif

		// POWER_GOOD#
		GpioBit_SetCnfg ((gpio_idx_t) i, (uint8_t)power_good_bit_index);
		GpioBit_SetDir ((gpio_idx_t) i, (uint8_t)power_good_bit_index, DIRECTION_OUTPUT);
		PMBUS_Gpio_Set_Feature((PMBUS_PAGE_t)i, PMBUS_GPIO_CONFIG_POWER_GOOD_SELECT, 1);  // set to not good to start

		// FAULT
		GpioBit_SetCnfg ((gpio_idx_t) i, (uint8_t)fault_bit_index);
		GpioBit_SetDir ((gpio_idx_t) i, (uint8_t)fault_bit_index, DIRECTION_OUTPUT);
		GpioBit_DatWr((gpio_idx_t) i, (uint8_t)fault_bit_index, (0));  // default low
	}
}

void patch_PMBUS_GPIO_CB (gpio_idx_t Bank, uint32_t Status)
{

	// This patch code should support two enable pins
	//1. VR enable pin of shasta
	//2. GPIO enable pin on PWM2 - this is removed in the ZSC code - back to single enable pin.

	//uint8_t pwm2_bit_index = 0; //bit7
	int32_t vr_enable_bit_index = PMBUS_Gpio_Get_PMBUS_Configuration((PMBUS_PAGE_t)Bank, PMBUS_GPIO_CONFIG_ENABLE_SELECT);
	//RGU_SPARE_FF__SET(0xabcd0000 | (Bank<<16) | Status); // debug msg
	if (vr_enable_bit_index>=0)  // if enable is assgined
	{
		if ( (((Status)&(1u<<vr_enable_bit_index)) == (1u<<vr_enable_bit_index)))// ||
		//		(((Status)&(1u<<pwm2_bit_index)) == (1u<<pwm2_bit_index)) )  // check if bit index is set in status to indicate enable interrupt
		{
			// tell the pmbus thread that enable has changed
			//PWM_PWM_FORCE_HI_LO__SET(0x00);		// reset the PWM HI LO
			PMBUS_Inter_Thread_Set_Command(PMBUS_PAGE_WB_0, PMBUS_CMDCODE_OPERATION, PMBUS_WRITE);
			PMBUS_Inter_Thread_Set_Command(PMBUS_PAGE_WB_1, PMBUS_CMDCODE_OPERATION, PMBUS_WRITE);
		}

	}
}


uint8_t patch_PMBUS_Get_On_Off_State (PMBUS_PAGE_t loop)
{

	// This patch code should support two enable pins
	//1. VR enable pin of shasta
	//2. GPIO enable pin on PWM2

	uint8_t operation, on_off_config;
	uint8_t temp;
	//boolean pwm2_gpio;
	// GPIO - PWM2 input enable pin read - config and read
	uint8_t imon_thr,en_efuse;
	//uint8_t en_bit_index = 0; //bit5

	uint8_t state ; 		// 0 is off state and 1 is ON state
	uint32_t status_byte = PMBUS_Get_Command_Byte(0, PMBUS_CMDCODE_STATUS_BYTE);
	uint32_t status_word = PMBUS_Get_Command_Word(0, PMBUS_CMDCODE_STATUS_WORD);
	if (((status_byte|status_word)&0x40U)==0x40U)
	{
		state = 0;		// on state
	}
	else
	{
		state = 1;
	}
	//COMMON_MP_FUNC1__EN_FUNC__SET(0);  //EN (GPIO0[0] )
	//COMMON_MP_FUNC1__EN_PD__SET(0); 	 //pulldown disabled
	//COMMON_MP_FUNC1__EN_PU_N__SET(1);  //pullup disabled
	//COMMON_MP_FUNC1__EN_PPEN__SET(0);  //open drain
	//GpioBit_SetCnfg ((gpio_idx_t)GPIO_0, (uint8_t)en_bit_index);
	//GpioBit_SetDir ((gpio_idx_t)GPIO_0, en_bit_index, DIRECTION_INPUT);
	//GpioBit_IntrType((gpio_idx_t) GPIO_0, (uint8_t)pwm2_bit_index, GPIO_IRQ_TYPE_EDGE_BOTH);  // interrupt on both edges
	//GpioBit_IntrEnable((gpio_idx_t) GPIO_0, (uint8_t)pwm2_bit_index);

	//boolean enable = PMBUS_Gpio_Get_Feature(loop, PMBUS_GPIO_CONFIG_ENABLE_SELECT);

	// check enable from one loop either loop0 or loop 1
	boolean enable = PMBUS_Gpio_Get_Feature(0, PMBUS_GPIO_CONFIG_ENABLE_SELECT);
	en_efuse = enable_presence(loop,state);		// In off mode - for loop 1 to look for the


	operation = PMBUS_Get_Command_Byte(loop, PMBUS_CMDCODE_OPERATION);
	on_off_config = PMBUS_Get_Command_Byte(loop, PMBUS_CMDCODE_ON_OFF_CONFIG);

	if ((on_off_config&0x10)==0x10)
	{
		switch ((on_off_config & 0xc)>>2)
		{
			case 1:
				// controlled by ENABLE/CONTROL pin		// Adding the and operation of the pwm gpio Enable
				if (((on_off_config & 0x2) == 0x2))
				{
					//PWM_PWM_FORCE_HI_LO__SET(0x18);		// pull up PWM4 and PWM5 if the pwm2 is pullup and convertor is on
					return (enable)& (en_efuse);  // active high polarity
				}
				else
				{
					return (!(enable) & (en_efuse));  // active low polarity
				}
				//break;
			case 2:
				// controlled by OPERATION bit 7
				temp = operation & 0x80;
				temp = temp >> 7;
				temp = temp & (en_efuse);  // active high polarity
				return (temp);
				//break;
			case 3:
				// controlled by OPERATION bit 7 and ENABLE/CONTROL
				temp = operation & 0x80;
				temp = temp >> 7;
				if (((on_off_config & 0x2) == 0x2))
				{
					//PWM_PWM_FORCE_HI_LO__SET(0x18);		// pull up PWM4 and PWM5 if the pwm2 is pull up and convertor is on
					temp = temp & (enable);  // active high polarity
				}
				else
				{
					/* lint -elib(514) */
					temp = temp & (uint8_t)(!enable);  // active low polarity
				}
				//SCU_SPARE_FF__SET(0xcbbc0000 | temp);  // debug print
				return (temp) & (en_efuse);
				//break;
			default:
				return 0;  // weird combo meaning uncontrolled?
				//break;
		}
	}
	else
	{
		// unit powers up regardless of ENABLE pin or OPERATION bit7
		return 1;
	}
	//break;

}

uint8_t enable_presence(PMBUS_PAGE_t page, uint8_t mode)
{
	uint8_t is_en_presence = 0;
	uint16_t vprisen = TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__GET();
	uint16_t vin_pwl_slope = TSEN_TSEN_VIN__VIN_PWL_SLOPE__GET();

	uint16_t en_thr_manntisa;
	int8_t en_thr_exponent;
	int32_t en_thr;

	//48v_on = MFR_48V_ON_THRESH * 2^14 / (vin_pwl_slope * 0.0625)
	//48v_off = MFR_48V_OFF_THRESH * 2^14 / (vin_pwl_slope * 0.0625)

	int8_t vin_exponent = -4;
	if (mode == 1)		// In on mode, compare the result with 48v_off, if lower than 48v_off, turn off eFuse, shutdown loop1 pwms
	{
		en_thr_manntisa = LINEAR11_TO_MANTISSA(PMBUS_Get_Command_Word((PMBUS_PAGE_t)page, PMBUS_CMDCODE_MFR_48V_OFF_THRESH));
		en_thr_exponent = (int8_t)LINEAR11_TO_EXPONENT(PMBUS_Get_Command_Word((PMBUS_PAGE_t)page, PMBUS_CMDCODE_MFR_48V_OFF_THRESH));	// -1 or -2
		en_thr = SHIFT_EXPONENT(en_thr_manntisa, en_thr_exponent+18);

		//48v_on = MFR_48V_ON_THRESH * 2^14 / (vin_pwl_slope * 0.0625)
		if(vin_pwl_slope !=0)
			en_thr = en_thr / vin_pwl_slope ;

		//uint32_t temp = (vin_on_exp2 << 16) | (vin);
		if (en_thr !=0)
		{
			if (vprisen <= en_thr)
			{
				is_en_presence = 1;
			}
		}
	}
	else	//In off mode, compare the result with 48v_on, if higher than 48v_on, turn on loop1 ZSC pwms, enable eFuse.
	{
		en_thr_manntisa = LINEAR11_TO_MANTISSA(PMBUS_Get_Command_Word((PMBUS_PAGE_t)page, PMBUS_CMDCODE_MFR_48V_ON_THRESH));
		en_thr_exponent = (int8_t)LINEAR11_TO_EXPONENT(PMBUS_Get_Command_Word((PMBUS_PAGE_t)page, PMBUS_CMDCODE_MFR_48V_ON_THRESH));	// -1 or -2
		en_thr = SHIFT_EXPONENT(en_thr_manntisa, en_thr_exponent+18);

		//48v_on = MFR_48V_ON_THRESH * 2^14 / (vin_pwl_slope * 0.0625)
		if(vin_pwl_slope !=0)
			en_thr = en_thr / vin_pwl_slope ;

		//uint32_t temp = (vin_on_exp2 << 16) | (vin);
		if (en_thr !=0)
		{
			if (vprisen >= en_thr)
			{
				is_en_presence = 1;
			}
		}
	}
	return is_en_presence;
}
void patch_Regulation_Shutdown_Sequence (PMBUS_PAGE_t loop, REGULATION_STATE state, REGULATION_CONTROLS control)
{

    //uint16_t delay;
    //uint32_t load;
	//uint32_t command;
	//int32_t exponent;

    // Send the GPIO EFUSE output signal

#ifdef SYNC_PIN_ENABLED
	/*
   	uint8_t sync_pin_gpio_bit_index = 7; //bit7
   	COMMON_MP_FUNC2__SYNC_FUNC__SET(1);  //SYNC pin - GPIO0[7]
   	COMMON_MP_FUNC2__SYNC_PD__SET(0); 	 //pulldown disabled
   	COMMON_MP_FUNC2__SYNC_PU_N__SET(1);  //pullup disabled
   	COMMON_MP_FUNC2__SYNC_PPEN__SET(1);  //CMOS output

   	GpioBit_SetCnfg (GPIO_0, sync_pin_gpio_bit_index);
   	GpioBit_SetDir (GPIO_0, sync_pin_gpio_bit_index, DIRECTION_OUTPUT);
   	GpioBit_DatWr(GPIO_0, sync_pin_gpio_bit_index, 0x00); // gpio driver requires a value of 1 on bus to be 0xff in index of that data location
   	*/

		uint8_t imon_pin_gpio_bit_index = 3; //bit3
		COMMON_MP_FUNC2__IMON_FUNC__SET(1);  //IMon pin - GPIO0[3] (mp imon pin )
		COMMON_MP_FUNC2__IMON_PD__SET(0); 	 //pulldown disabled
		COMMON_MP_FUNC2__IMON_PU_N__SET(1);  //pullup disabled
		COMMON_MP_FUNC2__IMON_PPEN__SET(1);  //CMOS output

		GpioBit_SetCnfg (GPIO_0, imon_pin_gpio_bit_index);
		GpioBit_SetDir (GPIO_0, imon_pin_gpio_bit_index, DIRECTION_OUTPUT);
		GpioBit_DatWr(GPIO_0, imon_pin_gpio_bit_index, 0x00); // gpio driver requires a value of 1 on bus to be 0xff in index of that data location
#else
   	uint8_t pwm1_bit_index = 5; //bit5 - GPIO[5]

   	COMMON_MP_FUNC3__PWM1_FUNC__SET(1);  //GPIO0[5]
   	COMMON_MP_FUNC3__PWM1_PD__SET(0); 	 //pulldown disabled
   	COMMON_MP_FUNC3__PWM1_PU_N__SET(1);  //pullup disabled
   	COMMON_MP_FUNC3__PWM1_PPEN__SET(1);  //CMOS output

   	GpioBit_SetCnfg (GPIO_0, pwm1_bit_index);
   	GpioBit_SetDir (GPIO_0, pwm1_bit_index, DIRECTION_OUTPUT);
   	GpioBit_DatWr(GPIO_0, pwm1_bit_index, 0); // gpio driver requires a value of 1 on bus to be 0xff in index of that data location
#endif

#ifdef SYNC_PIN_ENABLED
	//PWM_PWM_FORCE_HI_LO__SET(0x18);		// not forcing any PWM4 and PWM5 are on
#else
	PWM_PWM_FORCE_HI_LO__SET(0x18);
#endif

	//Telemetry_Disable_IRQ_Type(TELEM_IRQ7);

	//////////////SHUTDOWN SEQUENCE//////////////

	//Regulation_Max_Duty_Set(page, duty, exponent);
	//PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__SET(255);
	//PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__SET(1);////
/*	if (loop == 0)
	{
		PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__SET(255);
		PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__SET(1);////
	}
*/
	//Mask faults
	Regulation_Fault_Mask (loop, state, control);

	Regulation_PWM_Control(loop, REGULATION_PWMS_OFF);  // ALL FET's OFF
	Regulation_Set_VID(loop, 0, 0, 0, 0, 1);
	VCONTROL_VC_VRAMP1__VC_VRAMP_ON__SET((vcontrol_idx_t)loop, 0);  // turn off vramp_on signal to allow pwms to stop regulation
	// clear the interrupt here in case it was left over from a fault
	VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__SET((vcontrol_idx_t) loop, 0);

	//disable the hardware blocks: (telemetry and faults are always active but masked at different times)
	Regulation_Power_Mode (loop, state);

	if (loop == PMBUS_PAGE_0)
	{
		// disable ton_max interrupts
		TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__SET(TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__GET() &
																	~((1u<<(uint32_t)VOUT_UV_TON_MAX_DISABLE_0)));
	}
	else
	{
		// disable ton_max interrupts
		TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__SET(TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__GET() &
																		~((1u<<(uint32_t)VOUT_UV_TON_MAX_DISABLE_1)));
	}

	// update pmbus status off bit:
	PMBUS_STATUS_OFF__SET((pmbus_status_loop_idx_t)loop, 1);
	// update status word from result:
	PMBUS_Inter_Thread_Set_Command((PMBUS_PAGE_W_BROADCAST_t)loop, PMBUS_CMDCODE_STATUS_WORD, PMBUS_READ);

	// Clear HW Fault Shutdown mask
	FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__SET((fault_idx_t) REGULATION_APP.loop, 1) ;

	if (loop == PMBUS_PAGE_0)
	{
	FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__SET(1) ;
	}
	///////////////////////////////


	call_system_cb(SHUTDOWN_SEQUENCE);

}
/*
void MFR_IMON_MONITOR_IRQ_Handler(PMBUS_PAGE_t loop)
{
	uint8_t en_6v;
	en_6v = imon_monitor_thresh(loop);
	if (en_6v == 0)	//out of range
	{
   			uint8_t imon_pin_gpio_bit_index = 3; //bit3
   			COMMON_MP_FUNC2__IMON_FUNC__SET(1);  //IMon pin - GPIO0[3] (mp imon pin )
   			COMMON_MP_FUNC2__IMON_PD__SET(0); 	 //pulldown disabled
   			COMMON_MP_FUNC2__IMON_PU_N__SET(1);  //pullup disabled
   			COMMON_MP_FUNC2__IMON_PPEN__SET(1);  //CMOS output

   			GpioBit_SetCnfg (GPIO_0, imon_pin_gpio_bit_index);
   			GpioBit_SetDir (GPIO_0, imon_pin_gpio_bit_index, DIRECTION_OUTPUT);
   			GpioBit_DatWr(GPIO_0, imon_pin_gpio_bit_index, 0x00); // gpio driver requires a value of 1 on bus to be 0xff in index of that data location


		Regulation_Shutdown_Sequence (loop, REGULATION_STATE_OFF, REGULATION_CONTROLS_SHUTDOWN_IMMEDIATE);
		REGULATION_INTER_THREAD_SET(loop, REGULATION_CONTROLS_SHUTDOWN_IMMEDIATE, 0);
	}
	else		// in range
	{
			PMBUS_Inter_Thread_Set_Command(PMBUS_PAGE_WB_0, PMBUS_CMDCODE_OPERATION, PMBUS_WRITE);
			PMBUS_Inter_Thread_Set_Command(PMBUS_PAGE_WB_1, PMBUS_CMDCODE_OPERATION, PMBUS_WRITE);
	}
}
*/
