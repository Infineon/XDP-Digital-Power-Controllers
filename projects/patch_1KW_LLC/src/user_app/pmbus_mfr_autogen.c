
/**
 * @file    ./src/user_app/pmbus_mfr_autogen.h
 * @brief   Automatically generated from output of pmbus compile script.
 */

/* ============================================================================
** Copyright (C) 2025 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
**
** Automatically generated by:  pmbus_xlsx2c.py shasta_pmbus.xlsx
** Created on:  2025-02-04
*/
/*lint -save -e960 */

#include <stdint.h>              /* uint*_t */
#include "fw_bool.h"             /* boolean type */
#include "pmbus_autogen.h"
#include "pmbus_mfr_autogen.h"




/* instantiate the command structure for FAN_CONFIG_1_2.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_FAN_CONFIG_1_2;
uint8_t	PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for FAN_COMMAND_1.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_FAN_COMMAND_1;
uint8_t	PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_FAN_COMMAND_1_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command structure for FAN_COMMAND_2.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_FAN_COMMAND_2;
uint8_t	PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_FAN_COMMAND_2_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command structure for MFR_VIN_TRIMMING_ACTIVE.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE;
uint8_t	PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP0[4];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_VIN_TRIMMING_STANDBY.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY;
uint8_t	PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP0[4];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_DBG_VIN_TRIMMING.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_DBG_VIN_TRIMMING;
uint8_t	PMBUS_CMD_MFR_DBG_VIN_TRIMMING_DATA_LOOP0[4];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_DBG_VIN_TRIMMING_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_DBG_VIN_TRIMMING_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_DBG_VIN_TRIMMING_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_SCP_FAULT_RESPONSE.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_SCP_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_MFR_SCP_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_SCP_FAULT_RESPONSE_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_SCP_FAULT_RESPONSE_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_SCP_FAULT_RESPONSE_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_STARTUP_SCP_THRESH.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_STARTUP_SCP_THRESH;
uint8_t	PMBUS_CMD_MFR_STARTUP_SCP_THRESH_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_STARTUP_SCP_THRESH_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_STEADY_SCP_THRESH.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_STEADY_SCP_THRESH;
uint8_t	PMBUS_CMD_MFR_STEADY_SCP_THRESH_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_STEADY_SCP_THRESH_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_SCP_DBG.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_SCP_DBG;
uint8_t	PMBUS_CMD_MFR_SCP_DBG_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_SCP_DBG_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_SOFTSTART_MAX_FREQUENCY.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY;
uint8_t	PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_SOFTSTART_IRQ_RATE_SEL.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL;
uint8_t	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[9];  	// data array for range (common for loops)

/* instantiate the command MFR_SOFTSTART_PWM_STEPSIZE.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE;
uint8_t	PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE_DATA_LOOP0[4];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE_DATA_LOOP1[4];    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_SOFTSTART_CYCLE_COUNT.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT;
uint8_t	PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT_DATA_LOOP0[4];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT_DATA_LOOP1[4];    // data array for command loop1 (pointer if common)

/*
 * Initializes all of our pmbus structs that were generated by the script
 * Function gets called to setup command support array, initialize pointers to command data, and describe commands 
 */
void pmbus_mfr_autogen_init(void)
{


	/* initialize command structure for FAN_CONFIG_1_2. */
	// FAN_CONFIG_1_2 COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FAN_CONFIG_1_2] = PMBUS_HANDLE_FAN_CONFIG_1_2;
	//PMBUS_CMD_FAN_CONFIG_1_2.OPCODE = PMBUS_CMDCODE_FAN_CONFIG_1_2;
	//PMBUS_CMD_FAN_CONFIG_1_2.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_FAN_CONFIG_1_2.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_FAN_CONFIG_1_2.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_FAN_CONFIG_1_2.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FAN_CONFIG_1_2.SUPPORTED = 1;
	//PMBUS_CMD_FAN_CONFIG_1_2.PROTECTED0 = 0;
	//PMBUS_CMD_FAN_CONFIG_1_2.PROTECTED1 = 0;
	//PMBUS_CMD_FAN_CONFIG_1_2.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_FAN_CONFIG_1_2.CMD_CONFIG = 0xc181233a;
	PMBUS_CMD_FAN_CONFIG_1_2.DATA0 = &PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_CONFIG_1_2.DATA1 = &PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP1 = &PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP0[0];
	// RANGE SUPPORT for FAN_CONFIG_1_2 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FAN_CONFIG_1_2] = &PMBUS_CMD_FAN_CONFIG_1_2;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_CONFIG_1_2] = &PMBUS_CMD_FAN_CONFIG_1_2;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FAN_CONFIG_1_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_CONFIG_1_2&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_CONFIG_1_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_CONFIG_1_2&31u));

	/* initialize command structure for FAN_COMMAND_1. */
	// FAN_COMMAND_1 COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FAN_COMMAND_1] = PMBUS_HANDLE_FAN_COMMAND_1;
	//PMBUS_CMD_FAN_COMMAND_1.OPCODE = PMBUS_CMDCODE_FAN_COMMAND_1;
	//PMBUS_CMD_FAN_COMMAND_1.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_FAN_COMMAND_1.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_FAN_COMMAND_1.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_FAN_COMMAND_1.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FAN_COMMAND_1.SUPPORTED = 1;
	//PMBUS_CMD_FAN_COMMAND_1.PROTECTED0 = 0;
	//PMBUS_CMD_FAN_COMMAND_1.PROTECTED1 = 0;
	//PMBUS_CMD_FAN_COMMAND_1.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_FAN_COMMAND_1.RANGE = &PMBUS_CMD_FAN_COMMAND_1_RANGE[0];
	PMBUS_CMD_FAN_COMMAND_1_RANGE[0] = 6;
	PMBUS_CMD_FAN_COMMAND_1_RANGE[1] = 2;
	PMBUS_CMD_FAN_COMMAND_1.CMD_CONFIG = 0xc382233b;
	PMBUS_CMD_FAN_COMMAND_1.DATA0 = &PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_COMMAND_1.DATA1 = &PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP1 = &PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP0[0];
	// RANGE SUPPORT for FAN_COMMAND_1 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FAN_COMMAND_1] = &PMBUS_CMD_FAN_COMMAND_1;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_COMMAND_1] = &PMBUS_CMD_FAN_COMMAND_1;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FAN_COMMAND_1/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_COMMAND_1&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_COMMAND_1/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_COMMAND_1&31u));

	/* initialize command structure for FAN_COMMAND_2. */
	// FAN_COMMAND_2 COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FAN_COMMAND_2] = PMBUS_HANDLE_FAN_COMMAND_2;
	//PMBUS_CMD_FAN_COMMAND_2.OPCODE = PMBUS_CMDCODE_FAN_COMMAND_2;
	//PMBUS_CMD_FAN_COMMAND_2.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_FAN_COMMAND_2.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_FAN_COMMAND_2.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_FAN_COMMAND_2.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FAN_COMMAND_2.SUPPORTED = 1;
	//PMBUS_CMD_FAN_COMMAND_2.PROTECTED0 = 0;
	//PMBUS_CMD_FAN_COMMAND_2.PROTECTED1 = 0;
	//PMBUS_CMD_FAN_COMMAND_2.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_FAN_COMMAND_2.RANGE = &PMBUS_CMD_FAN_COMMAND_2_RANGE[0];
	PMBUS_CMD_FAN_COMMAND_2_RANGE[0] = 6;
	PMBUS_CMD_FAN_COMMAND_2_RANGE[1] = 2;
	PMBUS_CMD_FAN_COMMAND_2.CMD_CONFIG = 0xc382233c;
	PMBUS_CMD_FAN_COMMAND_2.DATA0 = &PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_COMMAND_2.DATA1 = &PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP1 = &PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP0[0];
	// RANGE SUPPORT for FAN_COMMAND_2 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FAN_COMMAND_2] = &PMBUS_CMD_FAN_COMMAND_2;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_COMMAND_2] = &PMBUS_CMD_FAN_COMMAND_2;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FAN_COMMAND_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_COMMAND_2&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_COMMAND_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_COMMAND_2&31u));

	/* initialize command structure for MFR_VIN_TRIMMING_ACTIVE. */
	// MFR_VIN_TRIMMING_ACTIVE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE] = PMBUS_HANDLE_MFR_VIN_TRIMMING_ACTIVE;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.OPCODE = PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.NUM_BYTES = 4; // data only not including slave address and command
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.CMD_CONFIG = 0xc1c456b7;
	PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.DATA0 = &PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.DATA1 = &PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP1 = &PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_VIN_TRIMMING_ACTIVE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE] = &PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE] = &PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE&31u));

	/* initialize command structure for MFR_VIN_TRIMMING_STANDBY. */
	// MFR_VIN_TRIMMING_STANDBY COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY] = PMBUS_HANDLE_MFR_VIN_TRIMMING_STANDBY;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.OPCODE = PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.NUM_BYTES = 4; // data only not including slave address and command
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.CMD_CONFIG = 0xc1c456b8;
	PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.DATA0 = &PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.DATA1 = &PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP1 = &PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_VIN_TRIMMING_STANDBY COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY] = &PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY] = &PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY&31u));

	/* initialize command structure for MFR_DBG_VIN_TRIMMING. */
	// MFR_DBG_VIN_TRIMMING COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_DBG_VIN_TRIMMING] = PMBUS_HANDLE_MFR_DBG_VIN_TRIMMING;
	//PMBUS_CMD_MFR_DBG_VIN_TRIMMING.OPCODE = PMBUS_CMDCODE_MFR_DBG_VIN_TRIMMING;
	//PMBUS_CMD_MFR_DBG_VIN_TRIMMING.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_DBG_VIN_TRIMMING.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_DBG_VIN_TRIMMING.NUM_BYTES = 4; // data only not including slave address and command
	//PMBUS_CMD_MFR_DBG_VIN_TRIMMING.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_DBG_VIN_TRIMMING.SUPPORTED = 1;
	//PMBUS_CMD_MFR_DBG_VIN_TRIMMING.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_DBG_VIN_TRIMMING.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_DBG_VIN_TRIMMING.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_DBG_VIN_TRIMMING.CMD_CONFIG = 0xc1c456b9;
	PMBUS_CMD_MFR_DBG_VIN_TRIMMING.DATA0 = &PMBUS_CMD_MFR_DBG_VIN_TRIMMING_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_DBG_VIN_TRIMMING.DATA1 = &PMBUS_CMD_MFR_DBG_VIN_TRIMMING_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_DBG_VIN_TRIMMING_DATA_LOOP1 = &PMBUS_CMD_MFR_DBG_VIN_TRIMMING_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_DBG_VIN_TRIMMING COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_DBG_VIN_TRIMMING] = &PMBUS_CMD_MFR_DBG_VIN_TRIMMING;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_DBG_VIN_TRIMMING] = &PMBUS_CMD_MFR_DBG_VIN_TRIMMING;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_DBG_VIN_TRIMMING/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_DBG_VIN_TRIMMING&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_DBG_VIN_TRIMMING/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_DBG_VIN_TRIMMING&31u));

	/* initialize command structure for MFR_SCP_FAULT_RESPONSE. */
	// MFR_SCP_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_SCP_FAULT_RESPONSE] = PMBUS_HANDLE_MFR_SCP_FAULT_RESPONSE;
	//PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_MFR_SCP_FAULT_RESPONSE;
	//PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.CMD_CONFIG = 0xc18123ba;
	PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_MFR_SCP_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SCP_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_MFR_SCP_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SCP_FAULT_RESPONSE_DATA_LOOP1 = &PMBUS_CMD_MFR_SCP_FAULT_RESPONSE_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_SCP_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SCP_FAULT_RESPONSE] = &PMBUS_CMD_MFR_SCP_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SCP_FAULT_RESPONSE] = &PMBUS_CMD_MFR_SCP_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SCP_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SCP_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SCP_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SCP_FAULT_RESPONSE&31u));

	/* initialize command structure for MFR_STARTUP_SCP_THRESH. */
	// MFR_STARTUP_SCP_THRESH COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_STARTUP_SCP_THRESH] = PMBUS_HANDLE_MFR_STARTUP_SCP_THRESH;
	//PMBUS_CMD_MFR_STARTUP_SCP_THRESH.OPCODE = PMBUS_CMDCODE_MFR_STARTUP_SCP_THRESH;
	//PMBUS_CMD_MFR_STARTUP_SCP_THRESH.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_STARTUP_SCP_THRESH.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_STARTUP_SCP_THRESH.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_STARTUP_SCP_THRESH.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_STARTUP_SCP_THRESH.SUPPORTED = 1;
	//PMBUS_CMD_MFR_STARTUP_SCP_THRESH.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_STARTUP_SCP_THRESH.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_STARTUP_SCP_THRESH.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_STARTUP_SCP_THRESH.CMD_CONFIG = 0xc18123bb;
	PMBUS_CMD_MFR_STARTUP_SCP_THRESH.DATA0 = &PMBUS_CMD_MFR_STARTUP_SCP_THRESH_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_STARTUP_SCP_THRESH.DATA1 = &PMBUS_CMD_MFR_STARTUP_SCP_THRESH_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_STARTUP_SCP_THRESH COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_STARTUP_SCP_THRESH] = &PMBUS_CMD_MFR_STARTUP_SCP_THRESH;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_STARTUP_SCP_THRESH] = &PMBUS_CMD_MFR_STARTUP_SCP_THRESH;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_STARTUP_SCP_THRESH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_STARTUP_SCP_THRESH&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_STARTUP_SCP_THRESH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_STARTUP_SCP_THRESH&31u));

	/* initialize command structure for MFR_STEADY_SCP_THRESH. */
	// MFR_STEADY_SCP_THRESH COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_STEADY_SCP_THRESH] = PMBUS_HANDLE_MFR_STEADY_SCP_THRESH;
	//PMBUS_CMD_MFR_STEADY_SCP_THRESH.OPCODE = PMBUS_CMDCODE_MFR_STEADY_SCP_THRESH;
	//PMBUS_CMD_MFR_STEADY_SCP_THRESH.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_STEADY_SCP_THRESH.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_STEADY_SCP_THRESH.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_STEADY_SCP_THRESH.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_STEADY_SCP_THRESH.SUPPORTED = 1;
	//PMBUS_CMD_MFR_STEADY_SCP_THRESH.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_STEADY_SCP_THRESH.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_STEADY_SCP_THRESH.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_STEADY_SCP_THRESH.CMD_CONFIG = 0xc18123bc;
	PMBUS_CMD_MFR_STEADY_SCP_THRESH.DATA0 = &PMBUS_CMD_MFR_STEADY_SCP_THRESH_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_STEADY_SCP_THRESH.DATA1 = &PMBUS_CMD_MFR_STEADY_SCP_THRESH_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_STEADY_SCP_THRESH COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_STEADY_SCP_THRESH] = &PMBUS_CMD_MFR_STEADY_SCP_THRESH;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_STEADY_SCP_THRESH] = &PMBUS_CMD_MFR_STEADY_SCP_THRESH;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_STEADY_SCP_THRESH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_STEADY_SCP_THRESH&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_STEADY_SCP_THRESH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_STEADY_SCP_THRESH&31u));

	/* initialize command structure for MFR_SCP_DBG. */
	// MFR_SCP_DBG COMMAND:
	//PMBUS_CMD_MFR_SCP_DBG.OPCODE = PMBUS_CMDCODE_MFR_SCP_DBG;
	//PMBUS_CMD_MFR_SCP_DBG.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_SCP_DBG.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_SCP_DBG.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_SCP_DBG.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SCP_DBG.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SCP_DBG.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SCP_DBG.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SCP_DBG.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SCP_DBG.CMD_CONFIG = 0xc18123bd;
	PMBUS_CMD_MFR_SCP_DBG.DATA0 = &PMBUS_CMD_MFR_SCP_DBG_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SCP_DBG.DATA1 = &PMBUS_CMD_MFR_SCP_DBG_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_SCP_DBG COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SCP_DBG] = &PMBUS_CMD_MFR_SCP_DBG;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SCP_DBG] = &PMBUS_CMD_MFR_SCP_DBG;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SCP_DBG/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SCP_DBG&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SCP_DBG/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SCP_DBG&31u));

	/* initialize command structure for MFR_SOFTSTART_MAX_FREQUENCY. */
	// MFR_SOFTSTART_MAX_FREQUENCY COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_SOFTSTART_MAX_FREQUENCY] = PMBUS_HANDLE_MFR_SOFTSTART_MAX_FREQUENCY;
	//PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.OPCODE = PMBUS_CMDCODE_MFR_SOFTSTART_MAX_FREQUENCY;
	//PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.CMD_CONFIG = 0xc18223be;
	PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.DATA0 = &PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY.DATA1 = &PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_SOFTSTART_MAX_FREQUENCY COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SOFTSTART_MAX_FREQUENCY] = &PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SOFTSTART_MAX_FREQUENCY] = &PMBUS_CMD_MFR_SOFTSTART_MAX_FREQUENCY;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SOFTSTART_MAX_FREQUENCY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SOFTSTART_MAX_FREQUENCY&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SOFTSTART_MAX_FREQUENCY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SOFTSTART_MAX_FREQUENCY&31u));

	/* initialize command structure for MFR_SOFTSTART_IRQ_RATE_SEL. */
	// MFR_SOFTSTART_IRQ_RATE_SEL COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_SOFTSTART_IRQ_RATE_SEL] = PMBUS_HANDLE_MFR_SOFTSTART_IRQ_RATE_SEL;
	//PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.OPCODE = PMBUS_CMDCODE_MFR_SOFTSTART_IRQ_RATE_SEL;
	//PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.RANGE_TYPE = (uint8_t) PMBUS_RANGE_SPARSE8;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.RANGE = &PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[0];
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[0] = 8;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[1] = 0x00;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[2] =  0x01;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[3] =  0x02;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[4] =  0x03;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[5] =  0x04;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[6] =  0x05;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[7] =  0x06;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_RANGE[8] =  0x07;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.CMD_CONFIG = 0xc78123bf;
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.DATA0 = &PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL.DATA1 = &PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_DATA_LOOP1 = &PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_SOFTSTART_IRQ_RATE_SEL COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SOFTSTART_IRQ_RATE_SEL] = &PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SOFTSTART_IRQ_RATE_SEL] = &PMBUS_CMD_MFR_SOFTSTART_IRQ_RATE_SEL;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SOFTSTART_IRQ_RATE_SEL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SOFTSTART_IRQ_RATE_SEL&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SOFTSTART_IRQ_RATE_SEL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SOFTSTART_IRQ_RATE_SEL&31u));

	/* initialize command structure for MFR_SOFTSTART_PWM_STEPSIZE. */
	// MFR_SOFTSTART_PWM_STEPSIZE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_SOFTSTART_PWM_STEPSIZE] = PMBUS_HANDLE_MFR_SOFTSTART_PWM_STEPSIZE;
	//PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.OPCODE = PMBUS_CMDCODE_MFR_SOFTSTART_PWM_STEPSIZE;
	//PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.NUM_BYTES = 4; // data only not including slave address and command
	//PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.CMD_CONFIG = 0xc1c456c0;
	PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.DATA0 = &PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE.DATA1 = &PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_SOFTSTART_PWM_STEPSIZE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SOFTSTART_PWM_STEPSIZE] = &PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SOFTSTART_PWM_STEPSIZE] = &PMBUS_CMD_MFR_SOFTSTART_PWM_STEPSIZE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SOFTSTART_PWM_STEPSIZE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SOFTSTART_PWM_STEPSIZE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SOFTSTART_PWM_STEPSIZE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SOFTSTART_PWM_STEPSIZE&31u));

	/* initialize command structure for MFR_SOFTSTART_CYCLE_COUNT. */
	// MFR_SOFTSTART_CYCLE_COUNT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_SOFTSTART_CYCLE_COUNT] = PMBUS_HANDLE_MFR_SOFTSTART_CYCLE_COUNT;
	//PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.OPCODE = PMBUS_CMDCODE_MFR_SOFTSTART_CYCLE_COUNT;
	//PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.NUM_BYTES = 4; // data only not including slave address and command
	//PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.CMD_CONFIG = 0xc1c456c1;
	PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.DATA0 = &PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT.DATA1 = &PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_SOFTSTART_CYCLE_COUNT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SOFTSTART_CYCLE_COUNT] = &PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SOFTSTART_CYCLE_COUNT] = &PMBUS_CMD_MFR_SOFTSTART_CYCLE_COUNT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SOFTSTART_CYCLE_COUNT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SOFTSTART_CYCLE_COUNT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SOFTSTART_CYCLE_COUNT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SOFTSTART_CYCLE_COUNT&31u));

}


