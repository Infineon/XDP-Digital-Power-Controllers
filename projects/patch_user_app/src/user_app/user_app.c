/*
 * user_app.c
 *
 *  Created on: Jun 13, 2017
 *      Author: dlewis4
 */

/** @page pgUser_App   User Example Code
 * The user application provides example code for various functions using the ROM linked API function calls.
 *
 * @section aof Add On Features:
 *
 * Features that user can enable via a define
 *
 * @ref retry_if_removed_bug_fix
 *
 * @ref en_ishare
 *
 * @ref add_on_features.c
 *
 * @image html add_on_features.png "Add On Features"
 *
 * @section pf Periodic Functions:
 *
 * Functions to execute periodically based on switching frequency.  Example includes frequency jitter/dither.
 *
 * @ref periodic_functions.c
 *
 * @image html periodic_functions.png "Periodic Functions"
 *
 * @section apcd Autogenerated PMBus Command Descriptors:
 *
 * Autogenerated output from make target pmbus.  Takes spreadsheet and creates pmbus command handles.
 *
 * @ref pmbus_mfr_autogen.c
 *
 * @image html pmbus_mfr_autogen.png "Autogenerated PMBus Command Descriptors"
 *
 * @section upcc User PMBus Command Callbacks:
 *
 * Example of implementing callback function (handlers) for user pmbus commands.  These are executed
 * after pmbus transactions are received.
 *
 * @ref pmbus_mfr_specific_handlers.c
 *
 * @image html pmbus_mfr_specific_handlers.png "User PMBus Command Callbacks"
 *
 * @section rdse Ramp Data Snapshot Examples:
 *
 * Example of how to implement blackbox snapshot features.
 *
 * @ref ramp_data.c
 *
 * @image html ramp_data.png "Ramp Data Snapshot Examples"
 *
 * @section rsmcf Regulation State Machine Callback Functions:
 *
 * Examples of callback (handles) for regulation state machine events. Several functions are defined for
 * particular states examples:
 *
 * @ref TON_RISE_VID_REACHED
 *
 * @ref TON_RISE_ENABLE
 *
 * @ref AT_TARGET_ENABLE
 *
 * @ref AT_SHUTDOWN
 *
 * @ref regulation_state_machine_callbacks.c
 *
 * @image html regulation_state_machine_callbacks.png "Regulation State Machine Callback Functions"
 *
 *@section mua Main User Application:
 *
 * Local init function:
 *
 * @ref user_drv_init
 *
 * @image html user_app.png "Main User Application"
 *
 * @section untlut User NTC Temperature Look Up Table:
 *
 * Example of a user implemented ntc lookup table.  Index of the array is the raw ADC code for TSEN A/B inputs.
 * Temperature is the return value of that ADC code.
 *
 * @ref user_ntc_temperature_lut.h
 *
 * @image html user_ntc_temperature_lut.png "User NTC Temperature Look Up Table"
 *
 * @section mua Main User Application:
 *
 * Local init function:
 *
 * @ref user_drv_init
 *
 * @image html user_app.png "Main User Application"
 *
 * @section dda Debug Data App:
 *
 * Log debug data app provides a circular buffer and api for saving debug data scratchpad. This data can be read through the GUI, debugger or pmbus command. Use cases would be logging telemetry data, warnings or state machine states.
 *
 * Debug app is using a circular buffer Each log entry contains a header and a number of 4 byte payload chunks. Header contains count, loop and length of payload information.
 *
 * To use debug data app first uncomment #define debug_app in debuf_app_def.h and set the parameters to configure debug app: RAMP_DATA_BUFFER_BASE, RAMP_DATA_SIZE_IN_BYTES and CAPTURE_LOG_MAX_PAYLOAD. See comments in debug_app_def on how to set these.
 *
 * log_debug_data_examples contain examples on how to use debug data app. debug_example (#define debug_example) shows how to write data on scratchpad. read_log_data_by_pmbus (#define read_log_data_by_pmbus) is an example of pmbus handler that is used to read log data via pmbus State_machine_debug (#define State_machine_debug) is can be used to log state machine transitions.
 *
 * @ref debug_app.c
 *
 * @image html debug_app.png "Debug App"
 *
 */




#include "dtimer_drv.h"
#include "telemetry_drv.h"
#include "regulation_api.h"
#include "faults_api.h"
#include "faults_drv.h"
#include "pmbus_api.h"
#include "pmbus_gpio_control.h"
#include "shasta_hal_vsen.h"
#include "shasta_hal_vcontrol.h"
#include "shasta_hal_pwm.h"
#include "shasta_hal_pid.h"
#include "shasta_hal_scu.h"
#include "shasta_hal_cgu.h"
#include "shasta_hal_rgu.h"
#include "shasta_hal_telem.h"
#include "shasta_hal_common.h"
#include "shasta_hal_fault.h"
#include "shasta_hal_isen.h"
#include "regulation_state_machine_callbacks.h"
#include "pmbus_autogen.h"
#include "pmbus_mfr_autogen.h"
#include "user_app.h"
#include "cmsis_os.h"                   // ARM::CMSIS:RTOS:Keil RTX
#include "cmsis_os_ext.h"                   // ARM::CMSIS:RTOS:Keil RTX ext
#include "log_app.h"             /* Logging of errors */
#include "user_ntc_temperature_lut.h"
#include "patch_rom_table.h"
#include "string.h"
#include "add_on_features.h"
#include "ramp_data.h"
#include "debug_app.h"
#include "uart_drv.h"                // uart driver functions
#include "pmbus_mfr_specific_handlers.h"
#include "shasta_hal_fault_common.h"

/**
 * Main entry point of the user application.  Good place to set breakpoint when debugging a patch.
 */
void debug_example(void);

void patch_pmbus_mfr_autogen_init(void);
#ifdef VIN_ON_OFF_ISSUE
void patch_PMBUS_HANDLE_OPERATION(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction);
void patch_Telemetry_IRQ_VIN_ON_OFF_HANDLE(Telemetry_IRQ_TYPE_t Telemetry_type);
void patch_PMBUS_HANDLE_VIN_ON(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction);
void patch_PMBUS_HANDLE_FW_CONFIG_FAULTS(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction);
#endif
#ifdef JIRA_889_WRITE_CLEAR_FAULT
void patch_Faults_Clear_Faults(PMBUS_PAGE_t page);
#endif

void debug_example(void)
{
	///////////////debug using ramp data circular buffer example//////////////
	uint32_t debug_data[8];
    uint16_t count;
    PMBUS_PAGE_t loop;

	memset(RAMP_DATA_BUFFER_BASE, 0, RAMP_DATA_SIZE_IN_BYTES);
	Ramp_data_buffer_reset();
	debug_data[0] = 0x111111;
	debug_data[1] = 0x222222;
	debug_data[2] = 0x333333;
	debug_data[3] = 0x444444;
	debug_data[4] = 0x555555;
	debug_data[5] = 0x666666;
	debug_data[6] = 0x777777;
	debug_data[7] = 0x888888;
	//The number of 4-byte words of the log's content
	loop = PMBUS_PAGE_0;
	count = 0;
	uint8_t length = sizeof(debug_data)/sizeof(uint32_t);
	(void)Ramp_data_buffer_write(loop, count, length, (uint32_t *)debug_data);

	debug_data[0] = 0x999999;
	debug_data[1] = 0xAAAAAA;
	loop = PMBUS_PAGE_0;
	count = 1;
	length = 2;
	(void)Ramp_data_buffer_write(loop, count, length, (uint32_t *)debug_data);

	///////////////debug example//////////////
}
#ifdef JIRA_889_WRITE_CLEAR_FAULT
void patch_Faults_Clear_Faults(PMBUS_PAGE_t page)
{

	_FAULT_DESC_s * fault;

    if ((ON_OFF_STATE.Shutdown_State[page] == 1) &&
    	((FAULT_HW_App[page].last_high_priority_fault != (FAULT_TYPE_t)0)  ||
		(FAULT_FW_App[page].last_high_priority_fault != (FAULT_TYPE_t)0)))
    {

    	if ((uint32_t)FAULT_HW_App[page].last_high_priority_fault< 32)
    	{
    		//Leave Status Latch from last hight priority fault to allow retry
        	FAULT_HW_App[page].fault_status_event_latch =(uint32_t) (1u<<(uint32_t)FAULT_HW_App[page].last_high_priority_fault) ;
    	}

    	else
    	{
    		//Leave Status Latch from last hight priority fault to allow retry
        	FAULT_FW_App[page].fault_status_event_latch =(uint32_t) (1u<<((uint32_t)FAULT_FW_App[page].last_high_priority_fault-32));
    	}

    	//Since the fault is still latched re-report the fault on pmubus
		FAULTS_REPORT_PMBUS(page,FAULT_HW_App[page].last_high_priority_fault);

    }
    else
    {
    	// Clear the firmware latched fault bit
    	FAULT_HW_App[page].fault_status_event_latch = 0;
    	FAULT_FW_App[page].fault_status_event_latch = 0;
    }

	ON_OFF_STATE.Shutdown_State[page] = 0; // Clear shutdown from fault state
	FAULT_COMMON_App.fault_status_event_latch = 0;

	//Clear highest priority fault and ready to accept new faults
    //FAULT_HW_App[page].last_high_priority_fault = (FAULT_TYPE_t) 0;
    //FAULT_FW_App[page].last_high_priority_fault = (FAULT_TYPE_t) 0;

	//Enable faults masked by the driver
	FAULT_HW_App[page].enable_mask_driver = (0xFFFFFFFF);
	FAULT_FW_App[page].enable_mask_driver = (0xFFFFFFFF);

    /*lint -e534 */
	Regulation_Get_Vid(page); //this updates enable_mask_driver based on OPERATION (does fault masking on margining)

	FAULT_HW_App[page].fault_enable = FAULT_HW_App[page].enable_mask_driver &
										FAULT_HW_App[page].enable_mask &
											FAULT_HW_App[page].enable_mask_pmbus;

	FAULT_FW_App[page].fault_enable = FAULT_FW_App[page].enable_mask_driver &
										FAULT_FW_App[page].enable_mask &
											FAULT_FW_App[page].enable_mask_pmbus;
	//Clear the status
	FAULT_HW_App[page].fault_status = 0;
	FAULT_FW_App[page].fault_status = 0;
	FAULT_COMMON_App.fault_status = 0;
	FAULT_COMMON_App.open_sense_fault = 0;
	//Clear polarity
	FAULT_HW_App[page].fault_polarity = 0;
	FAULT_FW_App[page].fault_polarity = 0;


	//Clear HW Common Faults Status
	Faults_Clear_Common_Hardware_Faults(0xFFFFFFFF);
	//Clear HW Loop Faults Status
	Faults_Clear_Hardware_Faults(page, 0xFFFFFFFF) ;

	/*lint -esym(526,FAULTS_ARRAY) */
	extern _FAULT_DESC_s FAULTS_ARRAY [(uint8_t)FAULT_TYPE__END_OF_FAULT_TYPES + 1u + (uint8_t)FAULT_TYPE__END_OF_FAULT_TYPES + 1u];// in the fw faults and hw common cases we are using the fault types above 32 so just add 32 to the type to get an index between 64-95

	/* Clear retry count */
    for (uint8_t fault_cnt=(uint8_t)RESERVED_HW_NO_FAULT;fault_cnt<(uint8_t)FAULT_TYPE__END_OF_HW_FAULT_TYPES;fault_cnt++) {
		fault = (_FAULT_DESC_s *)(&FAULTS_ARRAY[(((uint8_t)page*32) + (uint8_t)fault_cnt)]);
		fault->retry_count &= 0xf0;
	}

    for (uint8_t fault_cnt=(uint8_t)RESERVED_FW_NO_FAULT;fault_cnt<(uint8_t)FAULT_TYPE__END_OF_FAULT_TYPES;fault_cnt++) {
		fault = (_FAULT_DESC_s *)(&FAULTS_ARRAY[(32 + (uint8_t)fault_cnt)]);
		fault->retry_count &= 0xf0;
	}

	//Clear HW Loop Faults
	/* re-initialize the POLARITY */
	Faults_Set_Polarity_Hardware_Faults(page, 0) ;
    /* Re-Enable the latched and possibly driver disabled faults */
	Faults_Enable_Hardware_Faults(page, FAULT_HW_App[page].fault_enable);
	//Enable faults masked by the driver
	FAULT_COMMON_App.enable_mask_driver = (0xFFFFFFFF);

	FAULT_COMMON_App.fault_enable = FAULT_COMMON_App.enable_mask_driver &
										FAULT_COMMON_App.enable_mask &
											FAULT_COMMON_App.enable_mask_pmbus;

	Faults_Enable_Common_Hardware_Faults(FAULT_COMMON_App.fault_enable);

}
#endif

/**
 * Callback or Handle function called by pmbus thread after a read or write of given command
 * Fix for power up when VIN present issue.  When on_off_config is 0 and VIN is above VIN_ON
 * the ROM code did not attempt to start the state machine.  Code is added here to check this
 * condition and trigger a startup in that case.  Note PRISEN must be used for this to make
 * sense.
 * @param page Selects the pmbus page to operate on.
 * @param direction Can either be PMBUS_WRITE or PMBUS_READ types
 */
#ifdef VIN_ON_OFF_ISSUE
void patch_PMBUS_HANDLE_OPERATION(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction)
{

	if (direction == PMBUS_VIN_OFF)
	{
		ON_OFF_STATE.On_Off_State[page] = 0; // latch new state
		REGULATION_INTER_THREAD_SET(page, REGULATION_CONTROLS_SHUTDOWN_IMMEDIATE, 0);
	}
	else if (direction == PMBUS_POKE)
	{
		// determine last on off state for pmbus loop, loop enable is gated based on state of VIN and operation/on_off_command + enable pin
		// grab the current commanded enable value and current vin enable level and or them together
		if (PMBUS_Get_On_Off_State(page) == 0)
		{
			//Regulation_Update_Vid(page);
			// compare against last known enable state of the loop
			if ((ON_OFF_STATE.On_Off_State[page] == 1)) // state where we were on now off
			{
				ON_OFF_STATE.On_Off_State[page] = 0; // latch new state
				//CGU_SPARE_FF__SET(0xaa000000 | page);
				//PMBUS_HANDLE_VOUT_COMMAND(page, direction); // treat like a vid change!
				// Read PMBUS ON_OFF_CONFIG and OPERATION Commands to figure out if TOFF_DELAY, TOFF_FALL are enabled, or to shutdown immediate
				uint8_t on_off_config = PMBUS_Get_Command_Byte(page, PMBUS_CMDCODE_ON_OFF_CONFIG);
				uint8_t operation = PMBUS_Get_Command_Byte(page, PMBUS_CMDCODE_OPERATION);
				if (((on_off_config&0x1d) == 0x15) ||(((on_off_config&0x1c)==0x18)&&((operation&0x40) == 0)) ||	(((on_off_config&0x1d)==0x1d)&&((operation&0x40) == 0)))
				{
					REGULATION_INTER_THREAD_SET(page, REGULATION_CONTROLS_SHUTDOWN_IMMEDIATE, 0); // hard shutdown no delays
				}
				else
				{
					REGULATION_INTER_THREAD_SET(page, REGULATION_CONTROLS_SHUTDOWN, 0); // soft shutdown with toff delay
				}
			}
		}
		else // if ((PMBUS_Get_On_Off_State(page) == 0) || ((VIN_ON_OFF_STATE == 0)))
		{
			// compare against last known enable state of the loop
			if ((ON_OFF_STATE.On_Off_State[page] == 0))// state where we were off but are now on:
			{
				ON_OFF_STATE.On_Off_State[page] = 1; // latch new state
				//CGU_SPARE_FF__SET(0xbb000000 | page);
				//PMBUS_HANDLE_VOUT_COMMAND(page, direction); // treat like a vid change!
				PMBUS_HANDLE_CLEAR_FAULTS(page, PMBUS_WRITE); // clear the faults on re-enable
				REGULATION_INTER_THREAD_SET(page, REGULATION_CONTROLS_OPERATION_ENABLE, 0);
				// clear HW faults on enable toggle

				//Faults_Clear_Faults(page); /** @todo already handled by PMBUS_HANDLE_CLEAR_FAULTS **/
			}
			else // state where we were on and are still on, vid change
			{
				REGULATION_INTER_THREAD_SET(page, REGULATION_CONTROLS_OPERATION_ENABLE, 0);
			}
		}
	}
	else
	{
		PMBUS_HANDLE_OPERATION(page, direction);
	}
}


/**
 * This function is called on VIN_ON and VIN_OFF IRQ events,  The difference from the ROM
 * version is that the qualifier to only send PMBUS_POKE on VRECT sense has been removed.
 * Because the ROM version only sends POKE on VRECT when using PRISEN for VIN we do not get
 * the POKE to enable us.
 */
void patch_Telemetry_IRQ_VIN_ON_OFF_HANDLE(Telemetry_IRQ_TYPE_t Telemetry_type)
{
	_Telemetry_s * Telemetry_str = Telemetry_GET_ARRAY_POINTER(Telemetry_type) ;
	PMBUS_PAGE_t loop = Telemetry_str->loop;

	ON_OFF_STATE.Vin_On_Off_State[loop] = Telemetry_str->polarity;

	//Enable FAULT_TYPE_VIN_UV_FAULT when above VIN_ON
	//Disable FAULT_TYPE_VIN_UV_FAULT when below VIN_OFF
	Faults_Mask_Fault(loop, 1,
			((ON_OFF_STATE.Vin_On_Off_State[loop]<<(uint32_t)FAULT_TYPE_VIN_UV_FAULT) |
							(ON_OFF_STATE.Vin_On_Off_State[loop]<<(uint32_t)FAULT_TYPE_VIN_UV_WARN)), //set_mask
			0); //clear_mask

	if (ON_OFF_STATE.Vin_On_Off_State[loop] == 1) //VIN_ON
	{
		RGU_SPARE_FF__SET(0xccdd0000);
		PMBUS_Inter_Thread_Set_Command((PMBUS_PAGE_W_BROADCAST_t)loop, PMBUS_CMDCODE_OPERATION, PMBUS_POKE);
	}
	else //VIN_OFF
	{
		RGU_SPARE_FF__SET(0xaadd0000);
		// disable vcontrol interrupt
		VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__SET((vcontrol_idx_t)loop, 0);  // 0 disables irq to avoid vid reached
		Set_Firmware_Fault((PMBUS_PAGE_t)loop, FAULT_TYPE_VIN_INSUFFICIENT);
		//PMBUS_VIN_OFF is used to disable when VIN_OFF
		PMBUS_Inter_Thread_Set_Command((PMBUS_PAGE_W_BROADCAST_t)loop, PMBUS_CMDCODE_OPERATION, PMBUS_VIN_OFF);
	}
}

/**
 * This function is the handle for the PMBus commands VIN_ON and VIN_OFF.  This is different from ROM
 * to call the patch_Telemetry_IRQ_VIN_ON_OFF_HANDLE insead of ROM version.  This may be able to be
 * smaller if we call the ROM version and then the patch version, but I suspect if written when above
 * VIN_ON the IRQ will not send the POKE on PRISEN.
 */
void patch_PMBUS_HANDLE_VIN_ON(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction)
{
	if (direction == PMBUS_WRITE)
	{
		int32_t src_exp;
		int32_t temp;
		uint32_t vin_on, vin_off;
		int32_t mantissa, hysteresis_mantissa;
		int8_t exponent, hysteresis_exponent;

		FAULTS_SETUP_FAULT(page, FAULT_TYPE_VIN_INSUFFICIENT, 0x00, //FAULT_RESPONSE_IGNORE
							FAULTS_CONFIG_VIN_DELAY_UNIT, VOLTAGE_RESPONSE_TYPE,
							(uint8_t)PMBUS_CMDCODE_STATUS_INPUT, (uint8_t)PMBUS_STATUS_INPUT_UNIT_OFF_LOW_INPUT_VOLTS, (FAULT_TYPE_t)0);

		exponent = (int8_t)LINEAR11_TO_EXPONENT(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VIN_ON));
		mantissa = LINEAR11_TO_MANTISSA(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VIN_ON));
		if (page == PMBUS_PAGE_0)
		{
			src_exp = -Telemetry_Get_Irq_Source_Exponent((Telemetry_irq_src_t)VIN_0);
		}
		else
		{
			src_exp = -Telemetry_Get_Irq_Source_Exponent((Telemetry_irq_src_t)VIN_1);
		}


		temp = SHIFT_EXPONENT(mantissa, (src_exp + exponent));  //first put in the threshold shifted to the resolution of the source

		if (temp>32767) temp = 32767;
		if (temp<-32767) temp = -32767;
		vin_on = TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Shift((uint32_t)temp);

		hysteresis_exponent = (int8_t)LINEAR11_TO_EXPONENT(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VIN_OFF));
		hysteresis_mantissa = LINEAR11_TO_MANTISSA(PMBUS_Get_Command_Word(page, PMBUS_CMDCODE_VIN_OFF));

		temp = SHIFT_EXPONENT(hysteresis_mantissa, (src_exp + hysteresis_exponent));  //first put in the threshold shifted to the resolution of the source
		if (temp>32767) temp = 32767;
		if (temp<-32767) temp = -32767;
		vin_off = TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Shift((uint32_t)temp);

		if (vin_off==vin_on)
		{
			if (vin_on!=0) //when both ==0 no change
			{
			//Add 1V hysteresis to VIN_ON
			mantissa += SHIFT_EXPONENT(1,-(exponent));
			}
		}
		else if (vin_off > vin_on)
		{
			//Set VIN_OFF 1V below VIN_OFF
			hysteresis_mantissa = mantissa - SHIFT_EXPONENT(1,-(exponent));
			if (hysteresis_mantissa<0) hysteresis_mantissa = 0;
			hysteresis_exponent = exponent;
		}

		//VIN_ON has a hysteresis of VIN_OFF
		if (page==PMBUS_PAGE_0)
		{
			Telemetry_Set_Irq_Threshold(VIN_ON_OFF_0, mantissa, exponent);
			Telemetry_Set_Irq_Hysteresis_Threshold(VIN_ON_OFF_0, hysteresis_mantissa, hysteresis_exponent);
			Telemetry_Setup_Irq(page, VIN_0, VIN_ON_OFF_0, patch_Telemetry_IRQ_VIN_ON_OFF_HANDLE);
		}
		else
		{
			Telemetry_Set_Irq_Threshold(VIN_ON_OFF_1, mantissa, exponent);
			Telemetry_Set_Irq_Hysteresis_Threshold(VIN_ON_OFF_1, hysteresis_mantissa, hysteresis_exponent);
			Telemetry_Setup_Irq(page, VIN_1, VIN_ON_OFF_1, patch_Telemetry_IRQ_VIN_ON_OFF_HANDLE);
		}

	}
}

/**
 * This function patched from ROM verision to call patch_PMBUS_HANDLE_VIN_ON instead of ROM version PMBUS_HANDLE_VIN_ON
 */
void patch_PMBUS_HANDLE_FW_CONFIG_FAULTS(PMBUS_PAGE_t page, PMBUS_DIRECTION_e direction)
{
	if ((direction == PMBUS_WRITE)||(direction == OTP_RESTORE))
	{
		//SET ENABLE LOOP_HW
		FAULT_HW_App[page].enable_mask_pmbus = ~(FAULTS_Get_PMBUS_Configuration(page, FAULTS_CONFIG_FAULT_ENABLE_MASK_LOOP_HW));
		FAULT_HW_App[page].fault_enable = FAULT_HW_App[page].enable_mask &
											FAULT_HW_App[page].enable_mask_driver &
											FAULT_HW_App[page].enable_mask_pmbus;

		//Apply the fault mask
		FAULT_FAULT_ENABLE_LOOP__SET((fault_idx_t) page, FAULT_HW_App[page].fault_enable);

		//SET ENABLE LOOP_FW
		FAULT_FW_App[page].enable_mask_pmbus = ~(FAULTS_Get_PMBUS_Configuration(page, FAULTS_CONFIG_FAULT_ENABLE_MASK_LOOP_FW));
		FAULT_FW_App[page].fault_enable = FAULT_FW_App[page].enable_mask &
											FAULT_FW_App[page].enable_mask_driver &
											FAULT_FW_App[page].enable_mask_pmbus;

		//SET ENABLE COMMON
		FAULT_COMMON_App.enable_mask_pmbus = ~(FAULTS_Get_PMBUS_Configuration(PMBUS_PAGE_0, FAULTS_CONFIG_FAULT_ENABLE_MASK_LOOP_COMMON));
		FAULT_COMMON_App.fault_enable = FAULT_COMMON_App.enable_mask &
											FAULT_COMMON_App.enable_mask_driver &
												FAULT_COMMON_App.enable_mask_pmbus;
		FAULTCOM_FAULT_ENABLE_COM__SET(FAULT_COMMON_App.fault_enable);

		patch_PMBUS_HANDLE_VIN_ON(page, PMBUS_WRITE);
		PMBUS_HANDLE_VOUT_MIN(page, PMBUS_WRITE);
		PMBUS_HANDLE_VOUT_MAX(page, PMBUS_WRITE);
		PMBUS_HANDLE_VOUT_OV_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_VOUT_UV_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_VIN_OV_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_VIN_UV_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_IOUT_OC_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_MFR_IOUT_OC_FAST_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_IOUT_OC_LV_FAULT_LIMIT(page, PMBUS_WRITE);  // do after PMBUS_HANDLE_MFR_IOUT_OC_FAST_FAULT_LIMIT and PMBUS_HANDLE_IOUT_OC_FAULT_LIMIT
		PMBUS_HANDLE_IOUT_UC_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_IIN_OC_FAULT_LIMIT(page, PMBUS_WRITE);
		PMBUS_HANDLE_TON_MAX_FAULT_LIMIT(page, PMBUS_WRITE);


		PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR(page, PMBUS_WRITE);  // do UT and OT faults here to mask them while changing limits
		//PMBUS_HANDLE_OT_FAULT_LIMIT(page, PMBUS_WRITE); //this are done inside PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR
		//PMBUS_HANDLE_OT_WARN_LIMIT(page, PMBUS_WRITE); //this are done inside PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR
		//PMBUS_HANDLE_UT_WARN_LIMIT(page, PMBUS_WRITE); //this are done inside PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR
		//PMBUS_HANDLE_UT_FAULT_LIMIT(page, PMBUS_WRITE); //this are done inside PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR

		//if (Telemetry_Get_PMBUS_Configuration((PMBUS_PAGE_t)page, (TELEMETRY_CONFIG)TELEMETRY_CONFIG_GAIN_OFFSET_FAULT_THRESH_EN))
		//{
			PMBUS_HANDLE_VOUT_OV_WARN_LIMIT(page, PMBUS_WRITE);  // warns are not using fw_config_faults for delay time so no need to call here
			PMBUS_HANDLE_VOUT_UV_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_VIN_OV_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_VIN_UV_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_IOUT_OC_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_IIN_OC_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_POUT_OP_WARN_LIMIT(page, PMBUS_WRITE);
			PMBUS_HANDLE_PIN_OP_WARN_LIMIT(page, PMBUS_WRITE);
		//}
		//Faults_Clear_Faults(page);
	}

}
#endif

/**
 * Function for reporting both an error to log buffer and pmbus status.
 * This can only be used for non fatal runtime errors that can be recoverable.
 * source is always USER type @ref Log_Source_t.
 * @param program_counter Current program counter logged.  Usually pass PROGRAM_COUNTER
 * @param cml_status @ref PMBUS_CML_STATUS_e cml error type defined by pmbus spec, value
 * provided will be used as the bit to set in STATUS_CML pmbus command
 */
void USER_Log_Error(uint32_t program_counter, PMBUS_CML_STATUS_e cml_status)
{
	PMBUS_Log_Error(USER, program_counter, cml_status);
}


void patch_pmbus_mfr_autogen_init(void)
{
	pmbus_mfr_autogen_init();

#ifdef VIN_ON_OFF_ISSUE
	ptr_pmbus_callback[PMBUS_CMDCODE_OPERATION] = patch_PMBUS_HANDLE_OPERATION;
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_ON] = patch_PMBUS_HANDLE_VIN_ON;
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_OFF] = patch_PMBUS_HANDLE_VIN_ON;
	ptr_pmbus_callback[PMBUS_CMDCODE_FW_CONFIG_FAULTS] = patch_PMBUS_HANDLE_FW_CONFIG_FAULTS;
#endif

#ifdef JIRA_769_SETUP_PASSWORD
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_SETUP_PASSWORD] = patch_PMBUS_HANDLE_MFR_SETUP_PASSWORD;
#endif

#ifdef JIRA_785_REMAP_CLEAR_NEEDED_ON_RESET
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND] = patch_PMBUS_HANDLE_MFR_FIRMWARE_COMMAND;
#endif


}

/**
 * Main entry point of the user application.  Good place to set breakpoint when debugging a patch.
 * This will only get executed a single time prior to configuration loading and before RTOS starts
 */
void user_drv_init(void)
{
	memset(&user_data, 0, sizeof(USER_DATA_t));  // ZI the user data
#ifdef JIRA_889_WRITE_CLEAR_FAULT
	//patch clear faults to allow retry if clear_faults called when signal is below fault but still above warn
	patch_rom_table.patch_Faults_Clear_Faults = & patch_Faults_Clear_Faults;
#endif
#ifdef PMBUS_MEMORY_ERROR_CML
	patch_rom_table.patch_PMBUS_Copy_From_Memory = &patch_PMBUS_Copy_From_Memory;
#endif
	ntc_temp = &user_ntc_temp_lut[0];  // set the ntc lut to rom constant table
	// this is the initialization of user pmbus commands autogenerated from pmbus spreadsheet
	ptr_mfr_specific_init = (mfr_specific_init_ptr) patch_pmbus_mfr_autogen_init;
	set_module_init_cb(MODULE_REGULATION, regulation_sm_callbacks_init);  // set the pointer funtion in init of regulation state machine to user callback setup for each state
#ifdef JIRA_972_I2C_FIFO
	set_module_init_cb(MODULE_PMBUS, pmbus_driver_init);
#endif
	/*lint -e522 */
	add_on_features_init();
	//regulation_sm_callbacks_init();

	///////////////debug using ramp data circular buffer example//////////////
	//debug_example();


}
