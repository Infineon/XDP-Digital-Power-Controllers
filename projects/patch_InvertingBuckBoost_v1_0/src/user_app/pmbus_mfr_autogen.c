
/**
 * @file    ./src/user_app/pmbus_mfr_autogen.h
 * @brief   Automatically generated from output of pmbus compile script.
 */

/* ============================================================================
** Copyright (C) 2023 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
**
** Automatically generated by:  pmbus_xlsx2c.py shasta_pmbus.xlsx
** Created on:  2023-10-30
*/
/*lint -save -e960 */

#include <stdint.h>              /* uint*_t */
#include "fw_bool.h"             /* boolean type */
#include "pmbus_autogen.h"
#include "pmbus_mfr_autogen.h"




/* instantiate the command structure for FAN_CONFIG_1_2.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_FAN_CONFIG_1_2;
uint8_t	PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for FAN_COMMAND_1.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_FAN_COMMAND_1;
uint8_t	PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_FAN_COMMAND_1_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command structure for FAN_COMMAND_2.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_FAN_COMMAND_2;
uint8_t	PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_FAN_COMMAND_2_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command structure for MFR_ESTIMATE_EFFICIENCY.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY;
uint8_t	PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command structure for MFR_ZVS_DISABLE_THRESHOLD.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD;
uint8_t	PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_LIGHT_LOAD_THRESH.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_LIGHT_LOAD_THRESH;
uint8_t	PMBUS_CMD_MFR_LIGHT_LOAD_THRESH_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_LIGHT_LOAD_THRESH_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_LIGHT_LOAD_THRESH_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_LIGHT_LOAD_THRESH_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_LIGHT_LOAD_MODE.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_LIGHT_LOAD_MODE;
uint8_t	PMBUS_CMD_MFR_LIGHT_LOAD_MODE_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_LIGHT_LOAD_MODE_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_LIGHT_LOAD_MODE_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_LIGHT_LOAD_MODE_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_BURST_CONFIG.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_BURST_CONFIG;
uint8_t	PMBUS_CMD_MFR_BURST_CONFIG_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_BURST_CONFIG_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_BURST_CONFIG_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_BURST_CONFIG_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_EN_BUCK_BOOST_FEED_FORWARD.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD;
uint8_t	PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR;
uint8_t	PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_IOUT_OFFSET_CORR_FACTOR.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR;
uint8_t	PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_VIN_TRIMMING_ACTIVE.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE;
uint8_t	PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP0[4];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_VIN_TRIMMING_STANDBY.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY;
uint8_t	PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP0[4];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_DEADTIME.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_DEADTIME;
uint8_t	PMBUS_CMD_MFR_DEADTIME_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_DEADTIME_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_DEADTIME_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_DEADTIME_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_SNAPSHOT_DATA.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_SNAPSHOT_DATA;
uint8_t	PMBUS_CMD_MFR_SNAPSHOT_DATA_DATA_LOOP0[31];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_SNAPSHOT_DATA_DATA_LOOP1[31];    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_VDD_SCALE.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_VDD_SCALE;
uint8_t	PMBUS_CMD_MFR_VDD_SCALE_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_VDD_SCALE_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_VDD_SCALE_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_VDD_SCALE_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_VIN_SCALE.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_VIN_SCALE;
uint8_t	PMBUS_CMD_MFR_VIN_SCALE_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_VIN_SCALE_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_VIN_SCALE_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_VIN_SCALE_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_ISHARE_THRESHOLD.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_ISHARE_THRESHOLD;
uint8_t	PMBUS_CMD_MFR_ISHARE_THRESHOLD_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_ISHARE_THRESHOLD_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_ISHARE_THRESHOLD_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_ISHARE_THRESHOLD_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_ADDED_DROOP_DURING_RAMP.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP;
uint8_t	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_RANGE[4];  	// data array for range (common for loops)

/*
 * Initializes all of our pmbus structs that were generated by the script
 * Function gets called to setup command support array, initialize pointers to command data, and describe commands 
 */
void pmbus_mfr_autogen_init(void)
{


	/* initialize command structure for FAN_CONFIG_1_2. */
	// FAN_CONFIG_1_2 COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FAN_CONFIG_1_2] = PMBUS_HANDLE_FAN_CONFIG_1_2;
	//PMBUS_CMD_FAN_CONFIG_1_2.OPCODE = PMBUS_CMDCODE_FAN_CONFIG_1_2;
	//PMBUS_CMD_FAN_CONFIG_1_2.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_FAN_CONFIG_1_2.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_FAN_CONFIG_1_2.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_FAN_CONFIG_1_2.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FAN_CONFIG_1_2.SUPPORTED = 1;
	//PMBUS_CMD_FAN_CONFIG_1_2.PROTECTED0 = 0;
	//PMBUS_CMD_FAN_CONFIG_1_2.PROTECTED1 = 0;
	//PMBUS_CMD_FAN_CONFIG_1_2.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_FAN_CONFIG_1_2.CMD_CONFIG = 0xc181233a;
	PMBUS_CMD_FAN_CONFIG_1_2.DATA0 = &PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_CONFIG_1_2.DATA1 = &PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP1 = &PMBUS_CMD_FAN_CONFIG_1_2_DATA_LOOP0[0];
	// RANGE SUPPORT for FAN_CONFIG_1_2 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FAN_CONFIG_1_2] = &PMBUS_CMD_FAN_CONFIG_1_2;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_CONFIG_1_2] = &PMBUS_CMD_FAN_CONFIG_1_2;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FAN_CONFIG_1_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_CONFIG_1_2&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_CONFIG_1_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_CONFIG_1_2&31u));

	/* initialize command structure for FAN_COMMAND_1. */
	// FAN_COMMAND_1 COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FAN_COMMAND_1] = PMBUS_HANDLE_FAN_COMMAND_1;
	//PMBUS_CMD_FAN_COMMAND_1.OPCODE = PMBUS_CMDCODE_FAN_COMMAND_1;
	//PMBUS_CMD_FAN_COMMAND_1.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_FAN_COMMAND_1.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_FAN_COMMAND_1.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_FAN_COMMAND_1.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FAN_COMMAND_1.SUPPORTED = 1;
	//PMBUS_CMD_FAN_COMMAND_1.PROTECTED0 = 0;
	//PMBUS_CMD_FAN_COMMAND_1.PROTECTED1 = 0;
	//PMBUS_CMD_FAN_COMMAND_1.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_FAN_COMMAND_1.RANGE = &PMBUS_CMD_FAN_COMMAND_1_RANGE[0];
	PMBUS_CMD_FAN_COMMAND_1_RANGE[0] = 6;
	PMBUS_CMD_FAN_COMMAND_1_RANGE[1] = 2;
	PMBUS_CMD_FAN_COMMAND_1.CMD_CONFIG = 0xc382233b;
	PMBUS_CMD_FAN_COMMAND_1.DATA0 = &PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_COMMAND_1.DATA1 = &PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP1 = &PMBUS_CMD_FAN_COMMAND_1_DATA_LOOP0[0];
	// RANGE SUPPORT for FAN_COMMAND_1 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FAN_COMMAND_1] = &PMBUS_CMD_FAN_COMMAND_1;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_COMMAND_1] = &PMBUS_CMD_FAN_COMMAND_1;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FAN_COMMAND_1/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_COMMAND_1&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_COMMAND_1/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_COMMAND_1&31u));

	/* initialize command structure for FAN_COMMAND_2. */
	// FAN_COMMAND_2 COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FAN_COMMAND_2] = PMBUS_HANDLE_FAN_COMMAND_2;
	//PMBUS_CMD_FAN_COMMAND_2.OPCODE = PMBUS_CMDCODE_FAN_COMMAND_2;
	//PMBUS_CMD_FAN_COMMAND_2.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_FAN_COMMAND_2.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_FAN_COMMAND_2.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_FAN_COMMAND_2.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FAN_COMMAND_2.SUPPORTED = 1;
	//PMBUS_CMD_FAN_COMMAND_2.PROTECTED0 = 0;
	//PMBUS_CMD_FAN_COMMAND_2.PROTECTED1 = 0;
	//PMBUS_CMD_FAN_COMMAND_2.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_FAN_COMMAND_2.RANGE = &PMBUS_CMD_FAN_COMMAND_2_RANGE[0];
	PMBUS_CMD_FAN_COMMAND_2_RANGE[0] = 6;
	PMBUS_CMD_FAN_COMMAND_2_RANGE[1] = 2;
	PMBUS_CMD_FAN_COMMAND_2.CMD_CONFIG = 0xc382233c;
	PMBUS_CMD_FAN_COMMAND_2.DATA0 = &PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_COMMAND_2.DATA1 = &PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP1 = &PMBUS_CMD_FAN_COMMAND_2_DATA_LOOP0[0];
	// RANGE SUPPORT for FAN_COMMAND_2 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FAN_COMMAND_2] = &PMBUS_CMD_FAN_COMMAND_2;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_COMMAND_2] = &PMBUS_CMD_FAN_COMMAND_2;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FAN_COMMAND_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_COMMAND_2&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FAN_COMMAND_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FAN_COMMAND_2&31u));

	/* initialize command structure for MFR_ESTIMATE_EFFICIENCY. */
	// MFR_ESTIMATE_EFFICIENCY COMMAND:
	//PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.OPCODE = PMBUS_CMDCODE_MFR_ESTIMATE_EFFICIENCY;
	//PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.SUPPORTED = 1;
	//PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.RANGE = &PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_RANGE[0];
	PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_RANGE[0] = 0;
	PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_RANGE[1] = 8;
	PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.CMD_CONFIG = 0xc38123b1;
	PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.DATA0 = &PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY.DATA1 = &PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_DATA_LOOP1 = &PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_ESTIMATE_EFFICIENCY COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_ESTIMATE_EFFICIENCY] = &PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_ESTIMATE_EFFICIENCY] = &PMBUS_CMD_MFR_ESTIMATE_EFFICIENCY;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_ESTIMATE_EFFICIENCY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_ESTIMATE_EFFICIENCY&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_ESTIMATE_EFFICIENCY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_ESTIMATE_EFFICIENCY&31u));

	/* initialize command structure for MFR_ZVS_DISABLE_THRESHOLD. */
	// MFR_ZVS_DISABLE_THRESHOLD COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_ZVS_DISABLE_THRESHOLD] = PMBUS_HANDLE_MFR_ZVS_DISABLE_THRESHOLD;
	//PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.OPCODE = PMBUS_CMDCODE_MFR_ZVS_DISABLE_THRESHOLD;
	//PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.SUPPORTED = 1;
	//PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.CMD_CONFIG = 0xc18223b2;
	PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.DATA0 = &PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD.DATA1 = &PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD_DATA_LOOP1 = &PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_ZVS_DISABLE_THRESHOLD COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_ZVS_DISABLE_THRESHOLD] = &PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_ZVS_DISABLE_THRESHOLD] = &PMBUS_CMD_MFR_ZVS_DISABLE_THRESHOLD;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_ZVS_DISABLE_THRESHOLD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_ZVS_DISABLE_THRESHOLD&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_ZVS_DISABLE_THRESHOLD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_ZVS_DISABLE_THRESHOLD&31u));

	/* initialize command structure for MFR_LIGHT_LOAD_THRESH. */
	// MFR_LIGHT_LOAD_THRESH COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_LIGHT_LOAD_THRESH] = PMBUS_HANDLE_MFR_LIGHT_LOAD_THRESH;
	//PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.OPCODE = PMBUS_CMDCODE_MFR_LIGHT_LOAD_THRESH;
	//PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.SUPPORTED = 1;
	//PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.CMD_CONFIG = 0xc18223b3;
	PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.DATA0 = &PMBUS_CMD_MFR_LIGHT_LOAD_THRESH_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_LIGHT_LOAD_THRESH.DATA1 = &PMBUS_CMD_MFR_LIGHT_LOAD_THRESH_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_LIGHT_LOAD_THRESH_DATA_LOOP1 = &PMBUS_CMD_MFR_LIGHT_LOAD_THRESH_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_LIGHT_LOAD_THRESH COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_LIGHT_LOAD_THRESH] = &PMBUS_CMD_MFR_LIGHT_LOAD_THRESH;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_LIGHT_LOAD_THRESH] = &PMBUS_CMD_MFR_LIGHT_LOAD_THRESH;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_LIGHT_LOAD_THRESH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_LIGHT_LOAD_THRESH&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_LIGHT_LOAD_THRESH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_LIGHT_LOAD_THRESH&31u));

	/* initialize command structure for MFR_LIGHT_LOAD_MODE. */
	// MFR_LIGHT_LOAD_MODE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_LIGHT_LOAD_MODE] = PMBUS_HANDLE_MFR_LIGHT_LOAD_MODE;
	//PMBUS_CMD_MFR_LIGHT_LOAD_MODE.OPCODE = PMBUS_CMDCODE_MFR_LIGHT_LOAD_MODE;
	//PMBUS_CMD_MFR_LIGHT_LOAD_MODE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_LIGHT_LOAD_MODE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_LIGHT_LOAD_MODE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_LIGHT_LOAD_MODE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_LIGHT_LOAD_MODE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_LIGHT_LOAD_MODE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_LIGHT_LOAD_MODE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_LIGHT_LOAD_MODE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_LIGHT_LOAD_MODE.CMD_CONFIG = 0xc18123b4;
	PMBUS_CMD_MFR_LIGHT_LOAD_MODE.DATA0 = &PMBUS_CMD_MFR_LIGHT_LOAD_MODE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_LIGHT_LOAD_MODE.DATA1 = &PMBUS_CMD_MFR_LIGHT_LOAD_MODE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_LIGHT_LOAD_MODE_DATA_LOOP1 = &PMBUS_CMD_MFR_LIGHT_LOAD_MODE_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_LIGHT_LOAD_MODE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_LIGHT_LOAD_MODE] = &PMBUS_CMD_MFR_LIGHT_LOAD_MODE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_LIGHT_LOAD_MODE] = &PMBUS_CMD_MFR_LIGHT_LOAD_MODE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_LIGHT_LOAD_MODE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_LIGHT_LOAD_MODE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_LIGHT_LOAD_MODE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_LIGHT_LOAD_MODE&31u));

	/* initialize command structure for MFR_BURST_CONFIG. */
	// MFR_BURST_CONFIG COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_BURST_CONFIG] = PMBUS_HANDLE_MFR_BURST_CONFIG;
	//PMBUS_CMD_MFR_BURST_CONFIG.OPCODE = PMBUS_CMDCODE_MFR_BURST_CONFIG;
	//PMBUS_CMD_MFR_BURST_CONFIG.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_BURST_CONFIG.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_BURST_CONFIG.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_BURST_CONFIG.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_BURST_CONFIG.SUPPORTED = 1;
	//PMBUS_CMD_MFR_BURST_CONFIG.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_BURST_CONFIG.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_BURST_CONFIG.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_BURST_CONFIG.CMD_CONFIG = 0xc18123b5;
	PMBUS_CMD_MFR_BURST_CONFIG.DATA0 = &PMBUS_CMD_MFR_BURST_CONFIG_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_BURST_CONFIG.DATA1 = &PMBUS_CMD_MFR_BURST_CONFIG_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_BURST_CONFIG_DATA_LOOP1 = &PMBUS_CMD_MFR_BURST_CONFIG_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_BURST_CONFIG COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_BURST_CONFIG] = &PMBUS_CMD_MFR_BURST_CONFIG;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_BURST_CONFIG] = &PMBUS_CMD_MFR_BURST_CONFIG;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_BURST_CONFIG/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_BURST_CONFIG&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_BURST_CONFIG/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_BURST_CONFIG&31u));

	/* initialize command structure for MFR_EN_BUCK_BOOST_FEED_FORWARD. */
	// MFR_EN_BUCK_BOOST_FEED_FORWARD COMMAND:
	//PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.OPCODE = PMBUS_CMDCODE_MFR_EN_BUCK_BOOST_FEED_FORWARD;
	//PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.SUPPORTED = 1;
	//PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.CMD_CONFIG = 0xc18123b6;
	PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.DATA0 = &PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD.DATA1 = &PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD_DATA_LOOP1 = &PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_EN_BUCK_BOOST_FEED_FORWARD COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_EN_BUCK_BOOST_FEED_FORWARD] = &PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_EN_BUCK_BOOST_FEED_FORWARD] = &PMBUS_CMD_MFR_EN_BUCK_BOOST_FEED_FORWARD;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_EN_BUCK_BOOST_FEED_FORWARD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_EN_BUCK_BOOST_FEED_FORWARD&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_EN_BUCK_BOOST_FEED_FORWARD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_EN_BUCK_BOOST_FEED_FORWARD&31u));

	/* initialize command structure for MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR. */
	// MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR] = PMBUS_HANDLE_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.OPCODE = PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.SUPPORTED = 1;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.CMD_CONFIG = 0xc18123b7;
	PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.DATA0 = &PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR.DATA1 = &PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR_DATA_LOOP1 = &PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR] = &PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR] = &PMBUS_CMD_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_SLOPE_FACTOR&31u));

	/* initialize command structure for MFR_IOUT_OFFSET_CORR_FACTOR. */
	// MFR_IOUT_OFFSET_CORR_FACTOR COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_FACTOR] = PMBUS_HANDLE_MFR_IOUT_OFFSET_CORR_FACTOR;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.OPCODE = PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_FACTOR;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.SUPPORTED = 1;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.CMD_CONFIG = 0xc18123bc;
	PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.DATA0 = &PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR.DATA1 = &PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR_DATA_LOOP1 = &PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_IOUT_OFFSET_CORR_FACTOR COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_FACTOR] = &PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_FACTOR] = &PMBUS_CMD_MFR_IOUT_OFFSET_CORR_FACTOR;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_FACTOR/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_FACTOR&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_FACTOR/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_OFFSET_CORR_FACTOR&31u));

	/* initialize command structure for MFR_VIN_TRIMMING_ACTIVE. */
	// MFR_VIN_TRIMMING_ACTIVE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE] = PMBUS_HANDLE_MFR_VIN_TRIMMING_ACTIVE;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.OPCODE = PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.NUM_BYTES = 4; // data only not including slave address and command
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.CMD_CONFIG = 0xc1c456bd;
	PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.DATA0 = &PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE.DATA1 = &PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP1 = &PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_VIN_TRIMMING_ACTIVE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE] = &PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE] = &PMBUS_CMD_MFR_VIN_TRIMMING_ACTIVE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_TRIMMING_ACTIVE&31u));

	/* initialize command structure for MFR_VIN_TRIMMING_STANDBY. */
	// MFR_VIN_TRIMMING_STANDBY COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY] = PMBUS_HANDLE_MFR_VIN_TRIMMING_STANDBY;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.OPCODE = PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.NUM_BYTES = 4; // data only not including slave address and command
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.CMD_CONFIG = 0xc1c456be;
	PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.DATA0 = &PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY.DATA1 = &PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP1 = &PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_VIN_TRIMMING_STANDBY COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY] = &PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY] = &PMBUS_CMD_MFR_VIN_TRIMMING_STANDBY;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_TRIMMING_STANDBY&31u));

	/* initialize command structure for MFR_DEADTIME. */
	// MFR_DEADTIME COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_DEADTIME] = PMBUS_HANDLE_MFR_DEADTIME;
	//PMBUS_CMD_MFR_DEADTIME.OPCODE = PMBUS_CMDCODE_MFR_DEADTIME;
	//PMBUS_CMD_MFR_DEADTIME.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_DEADTIME.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_DEADTIME.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_DEADTIME.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_DEADTIME.SUPPORTED = 1;
	//PMBUS_CMD_MFR_DEADTIME.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_DEADTIME.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_DEADTIME.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_DEADTIME.CMD_CONFIG = 0xc18123c0;
	PMBUS_CMD_MFR_DEADTIME.DATA0 = &PMBUS_CMD_MFR_DEADTIME_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_DEADTIME.DATA1 = &PMBUS_CMD_MFR_DEADTIME_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_DEADTIME_DATA_LOOP1 = &PMBUS_CMD_MFR_DEADTIME_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_DEADTIME COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_DEADTIME] = &PMBUS_CMD_MFR_DEADTIME;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_DEADTIME] = &PMBUS_CMD_MFR_DEADTIME;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_DEADTIME/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_DEADTIME&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_DEADTIME/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_DEADTIME&31u));

	/* initialize command structure for MFR_SNAPSHOT_DATA. */
	// MFR_SNAPSHOT_DATA COMMAND:
	//PMBUS_CMD_MFR_SNAPSHOT_DATA.OPCODE = PMBUS_CMDCODE_MFR_SNAPSHOT_DATA;
	//PMBUS_CMD_MFR_SNAPSHOT_DATA.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_SNAPSHOT_DATA.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_SNAPSHOT_DATA.NUM_BYTES = 31; // data only not including slave address and command
	//PMBUS_CMD_MFR_SNAPSHOT_DATA.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SNAPSHOT_DATA.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SNAPSHOT_DATA.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SNAPSHOT_DATA.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SNAPSHOT_DATA.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SNAPSHOT_DATA.CMD_CONFIG = 0x41df56d0;
	PMBUS_CMD_MFR_SNAPSHOT_DATA.DATA0 = &PMBUS_CMD_MFR_SNAPSHOT_DATA_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SNAPSHOT_DATA.DATA1 = &PMBUS_CMD_MFR_SNAPSHOT_DATA_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_SNAPSHOT_DATA COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SNAPSHOT_DATA] = &PMBUS_CMD_MFR_SNAPSHOT_DATA;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SNAPSHOT_DATA] = &PMBUS_CMD_MFR_SNAPSHOT_DATA;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SNAPSHOT_DATA/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SNAPSHOT_DATA&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SNAPSHOT_DATA/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SNAPSHOT_DATA&31u));

	/* initialize command structure for MFR_VDD_SCALE. */
	// MFR_VDD_SCALE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_VDD_SCALE] = PMBUS_HANDLE_MFR_VDD_SCALE;
	//PMBUS_CMD_MFR_VDD_SCALE.OPCODE = PMBUS_CMDCODE_MFR_VDD_SCALE;
	//PMBUS_CMD_MFR_VDD_SCALE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_VDD_SCALE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_VDD_SCALE.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_VDD_SCALE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VDD_SCALE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VDD_SCALE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VDD_SCALE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VDD_SCALE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_VDD_SCALE.CMD_CONFIG = 0xc18223d2;
	PMBUS_CMD_MFR_VDD_SCALE.DATA0 = &PMBUS_CMD_MFR_VDD_SCALE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VDD_SCALE.DATA1 = &PMBUS_CMD_MFR_VDD_SCALE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VDD_SCALE_DATA_LOOP1 = &PMBUS_CMD_MFR_VDD_SCALE_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_VDD_SCALE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VDD_SCALE] = &PMBUS_CMD_MFR_VDD_SCALE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VDD_SCALE] = &PMBUS_CMD_MFR_VDD_SCALE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VDD_SCALE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VDD_SCALE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VDD_SCALE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VDD_SCALE&31u));

	/* initialize command structure for MFR_VIN_SCALE. */
	// MFR_VIN_SCALE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_VIN_SCALE] = PMBUS_HANDLE_MFR_VIN_SCALE;
	//PMBUS_CMD_MFR_VIN_SCALE.OPCODE = PMBUS_CMDCODE_MFR_VIN_SCALE;
	//PMBUS_CMD_MFR_VIN_SCALE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_VIN_SCALE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_VIN_SCALE.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_VIN_SCALE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VIN_SCALE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VIN_SCALE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VIN_SCALE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VIN_SCALE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_VIN_SCALE.CMD_CONFIG = 0xc18223d3;
	PMBUS_CMD_MFR_VIN_SCALE.DATA0 = &PMBUS_CMD_MFR_VIN_SCALE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_SCALE.DATA1 = &PMBUS_CMD_MFR_VIN_SCALE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_SCALE_DATA_LOOP1 = &PMBUS_CMD_MFR_VIN_SCALE_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_VIN_SCALE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_SCALE] = &PMBUS_CMD_MFR_VIN_SCALE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_SCALE] = &PMBUS_CMD_MFR_VIN_SCALE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_SCALE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_SCALE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_SCALE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_SCALE&31u));

	/* initialize command structure for MFR_ISHARE_THRESHOLD. */
	// MFR_ISHARE_THRESHOLD COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_ISHARE_THRESHOLD] = PMBUS_HANDLE_MFR_ISHARE_THRESHOLD;
	//PMBUS_CMD_MFR_ISHARE_THRESHOLD.OPCODE = PMBUS_CMDCODE_MFR_ISHARE_THRESHOLD;
	//PMBUS_CMD_MFR_ISHARE_THRESHOLD.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_ISHARE_THRESHOLD.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_ISHARE_THRESHOLD.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_ISHARE_THRESHOLD.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_ISHARE_THRESHOLD.SUPPORTED = 1;
	//PMBUS_CMD_MFR_ISHARE_THRESHOLD.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_ISHARE_THRESHOLD.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_ISHARE_THRESHOLD.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_ISHARE_THRESHOLD.CMD_CONFIG = 0xc18223da;
	PMBUS_CMD_MFR_ISHARE_THRESHOLD.DATA0 = &PMBUS_CMD_MFR_ISHARE_THRESHOLD_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_ISHARE_THRESHOLD.DATA1 = &PMBUS_CMD_MFR_ISHARE_THRESHOLD_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_ISHARE_THRESHOLD_DATA_LOOP1 = &PMBUS_CMD_MFR_ISHARE_THRESHOLD_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_ISHARE_THRESHOLD COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_ISHARE_THRESHOLD] = &PMBUS_CMD_MFR_ISHARE_THRESHOLD;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_ISHARE_THRESHOLD] = &PMBUS_CMD_MFR_ISHARE_THRESHOLD;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_ISHARE_THRESHOLD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_ISHARE_THRESHOLD&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_ISHARE_THRESHOLD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_ISHARE_THRESHOLD&31u));

	/* initialize command structure for MFR_ADDED_DROOP_DURING_RAMP. */
	// MFR_ADDED_DROOP_DURING_RAMP COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_ADDED_DROOP_DURING_RAMP] = PMBUS_HANDLE_MFR_ADDED_DROOP_DURING_RAMP;
	//PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.OPCODE = PMBUS_CMDCODE_MFR_ADDED_DROOP_DURING_RAMP;
	//PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.SUPPORTED = 1;
	//PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.RANGE = &PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_RANGE[0];
	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_RANGE[0] = 3;
	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_RANGE[1] = 7;
	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_RANGE[2] = 4;
	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_RANGE[3] = 6;
	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.CMD_CONFIG = 0xc58223fc;
	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.DATA0 = &PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP.DATA1 = &PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_DATA_LOOP1 = &PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_ADDED_DROOP_DURING_RAMP COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_ADDED_DROOP_DURING_RAMP] = &PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_ADDED_DROOP_DURING_RAMP] = &PMBUS_CMD_MFR_ADDED_DROOP_DURING_RAMP;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_ADDED_DROOP_DURING_RAMP/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_ADDED_DROOP_DURING_RAMP&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_ADDED_DROOP_DURING_RAMP/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_ADDED_DROOP_DURING_RAMP&31u));

}


