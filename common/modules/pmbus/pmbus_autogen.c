
/**
 * @file    ../../common/modules/pmbus/pmbus_autogen.h
 * @brief   Automatically generated from output of pmbus compile script.
 */

/* ============================================================================
** Copyright (C) 2023 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
**
** Automatically generated by:  pmbus_xlsx2c.py shasta_pmbus.xlsx
** Created on:  2023-10-06
*/
/*lint -save -e960 */

#include <stdint.h>              /* uint*_t */
#include "fw_bool.h"             /* boolean type */
#include "pmbus_autogen.h"

// When bit7 is enabled No AVS source bits 5:4 = 'b11 and no margin bits 3:2='b11 no reserved bit 0 = 'b1
const uint32_t PMBUS_RANGE_OPERATION_ARRAY[8] =
{
		0x55555555,
		0x55555555,
		0x55555555,
		0x55555555,
		0x05555555,
		0x00000555,
		0x05555555,
		0x00000555
};

const uint32_t PMBUS_RANGE_SMBALERT_MASK_ARRAY[8] =
{
		0x00000002,	// bit 1 (in block reads)
		0x00000000,
		0x00000000,
		0xff000000,	// bits 120-127
		0x00000003,	// bits 128-129
		0x00000000,
		0x00000000,
		0x00000000
};

const uint32_t PMBUS_RANGE_MFR_IOUT_OC_FAST_FAULT_RESPONSE_ARRAY[8] =
{
	// Generated by parse_bins_for_range.py utility with line= wildcard bins response_current_limit = {8'b00??????}; wildcard bins response_shutdown_retry = {8'b11??????};
	0xffffffff,
	0xffffffff,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0xffffffff,
	0xffffffff
};

const uint32_t PMBUS_RANGE_UNSIGNED_LINEAR11_ARRAY[8] =
{
	// Generated by create_c_support_array.py utility with mask 0xfb
	0x0f0f0f0f,
	0x0f0f0f0f,
	0x0f0f0f0f,
	0x0f0f0f0f,
	0x0f0f0f0f,
	0x0f0f0f0f,
	0x0f0f0f0f,
	0x0f0f0f0f
};

// this is an array of pointers to the pmbus structs it gets initialized in the init routine:
//  one of these per loop:
PMBUS_CMD_t * PMBUS_CMD_ARRAY_LOOP [256] ;
//PMBUS_CMD_t * PMBUS_CMD_ARRAY_LOOP1 [256] ;
uint32_t PMBUS_CMD_SUPPORT_ARRAY_LOOP [8] ;
//uint32_t PMBUS_CMD_SUPPORT_ARRAY_LOOP1 [8] ;

mfr_specific_init_ptr ptr_mfr_specific_init;
pmbus_callback ptr_pmbus_callback[256];

PMBUS_CMD_t PMBUS_CMD_UNSUPPORTED;
uint8_t	PMBUS_CMD_UNSUPPORTED_DATA[1];  // data array for command
uint8_t	PMBUS_CMD_UNSUPPORTED_RANGE[1];  // data array for range




/* instantiate the command structure for PAGE.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_PAGE;
uint8_t	PMBUS_CMD_PAGE_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_PAGE_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_PAGE_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_PAGE_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_PAGE_RANGE[4];  	// data array for range (common for loops)

/* instantiate the command OPERATION.
 */
PMBUS_CMD_t PMBUS_CMD_OPERATION;
uint8_t	PMBUS_CMD_OPERATION_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_OPERATION_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command ON_OFF_CONFIG.
 */
PMBUS_CMD_t PMBUS_CMD_ON_OFF_CONFIG;
uint8_t	PMBUS_CMD_ON_OFF_CONFIG_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_ON_OFF_CONFIG_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_ON_OFF_CONFIG_RANGE[1];  	// data array for range (common for loops)

/* instantiate the command CLEAR_FAULTS.
 */
PMBUS_CMD_t PMBUS_CMD_CLEAR_FAULTS;

/* instantiate the command WRITE_PROTECT.
 */
PMBUS_CMD_t PMBUS_CMD_WRITE_PROTECT;
uint8_t	PMBUS_CMD_WRITE_PROTECT_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_WRITE_PROTECT_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_WRITE_PROTECT_RANGE[5];  	// data array for range (common for loops)

/* instantiate the command STORE_DEFAULT_ALL.
 */
PMBUS_CMD_t PMBUS_CMD_STORE_DEFAULT_ALL;

/* instantiate the command RESTORE_DEFAULT_ALL.
 */
PMBUS_CMD_t PMBUS_CMD_RESTORE_DEFAULT_ALL;

/* instantiate the command STORE_USER_ALL.
 */
PMBUS_CMD_t PMBUS_CMD_STORE_USER_ALL;

/* instantiate the command RESTORE_USER_ALL.
 */
PMBUS_CMD_t PMBUS_CMD_RESTORE_USER_ALL;

/* instantiate the command STORE_USER_CODE.
 */
PMBUS_CMD_t PMBUS_CMD_STORE_USER_CODE;
uint8_t	PMBUS_CMD_STORE_USER_CODE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_STORE_USER_CODE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command RESTORE_USER_CODE.
 */
PMBUS_CMD_t PMBUS_CMD_RESTORE_USER_CODE;
uint8_t	PMBUS_CMD_RESTORE_USER_CODE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_RESTORE_USER_CODE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command structure for CAPABILITY.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_CAPABILITY;
uint8_t	PMBUS_CMD_CAPABILITY_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_CAPABILITY_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_CAPABILITY_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_CAPABILITY_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command SMBALERT_MASK.
 */
PMBUS_CMD_t PMBUS_CMD_SMBALERT_MASK;
uint8_t	PMBUS_CMD_SMBALERT_MASK_DATA_LOOP0[11];  	// data array for command loop0
uint8_t	PMBUS_CMD_SMBALERT_MASK_DATA_LOOP1[11];    // data array for command loop1 (pointer if common)

/* instantiate the command VOUT_MODE.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_MODE;
uint8_t	PMBUS_CMD_VOUT_MODE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_MODE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_MODE_RANGE[3];  	// data array for range (common for loops)

/* instantiate the command VOUT_COMMAND.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_COMMAND;
uint8_t	PMBUS_CMD_VOUT_COMMAND_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_COMMAND_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_COMMAND_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_TRIM.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_TRIM;
uint8_t	PMBUS_CMD_VOUT_TRIM_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_TRIM_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_TRIM_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_CAL_OFFSET.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_CAL_OFFSET;
uint8_t	PMBUS_CMD_VOUT_CAL_OFFSET_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_CAL_OFFSET_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_CAL_OFFSET_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_MAX.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_MAX;
uint8_t	PMBUS_CMD_VOUT_MAX_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_MAX_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_MAX_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_MARGIN_HIGH.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_MARGIN_HIGH;
uint8_t	PMBUS_CMD_VOUT_MARGIN_HIGH_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_MARGIN_HIGH_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_MARGIN_HIGH_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_MARGIN_LOW.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_MARGIN_LOW;
uint8_t	PMBUS_CMD_VOUT_MARGIN_LOW_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_MARGIN_LOW_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_MARGIN_LOW_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_TRANSITION_RATE.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_TRANSITION_RATE;
uint8_t	PMBUS_CMD_VOUT_TRANSITION_RATE_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_TRANSITION_RATE_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_TRANSITION_RATE_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_DROOP.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_DROOP;
uint8_t	PMBUS_CMD_VOUT_DROOP_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_DROOP_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_DROOP_RANGE[4];  	// data array for range (common for loops)

/* instantiate the command VOUT_SCALE_LOOP.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_SCALE_LOOP;
uint8_t	PMBUS_CMD_VOUT_SCALE_LOOP_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_SCALE_LOOP_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)

/* instantiate the command VOUT_MIN.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_MIN;
uint8_t	PMBUS_CMD_VOUT_MIN_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_MIN_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_MIN_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MAX_DUTY.
 */
PMBUS_CMD_t PMBUS_CMD_MAX_DUTY;
uint8_t	PMBUS_CMD_MAX_DUTY_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MAX_DUTY_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MAX_DUTY_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command FREQUENCY_SWITCH.
 */
PMBUS_CMD_t PMBUS_CMD_FREQUENCY_SWITCH;
uint8_t	PMBUS_CMD_FREQUENCY_SWITCH_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_FREQUENCY_SWITCH_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_FREQUENCY_SWITCH_RANGE[3];  	// data array for range (common for loops)

/* instantiate the command POWER_MODE.
 */
PMBUS_CMD_t PMBUS_CMD_POWER_MODE;
uint8_t	PMBUS_CMD_POWER_MODE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_POWER_MODE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_POWER_MODE_RANGE[4];  	// data array for range (common for loops)

/* instantiate the command VIN_ON.
 */
PMBUS_CMD_t PMBUS_CMD_VIN_ON;
uint8_t	PMBUS_CMD_VIN_ON_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VIN_ON_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VIN_ON_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VIN_OFF.
 */
PMBUS_CMD_t PMBUS_CMD_VIN_OFF;
uint8_t	PMBUS_CMD_VIN_OFF_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VIN_OFF_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VIN_OFF_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command INTERLEAVE.
 */
PMBUS_CMD_t PMBUS_CMD_INTERLEAVE;
uint8_t	PMBUS_CMD_INTERLEAVE_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_INTERLEAVE_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_INTERLEAVE_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command IOUT_CAL_OFFSET.
 */
PMBUS_CMD_t PMBUS_CMD_IOUT_CAL_OFFSET;
uint8_t	PMBUS_CMD_IOUT_CAL_OFFSET_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_IOUT_CAL_OFFSET_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_IOUT_CAL_OFFSET_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_OV_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_OV_FAULT_LIMIT;
uint8_t	PMBUS_CMD_VOUT_OV_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_OV_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_OV_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_OV_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_OV_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_VOUT_OV_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_OV_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command VOUT_OV_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_OV_WARN_LIMIT;
uint8_t	PMBUS_CMD_VOUT_OV_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_OV_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_OV_WARN_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_UV_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_UV_WARN_LIMIT;
uint8_t	PMBUS_CMD_VOUT_UV_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_UV_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_UV_WARN_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_UV_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_UV_FAULT_LIMIT;
uint8_t	PMBUS_CMD_VOUT_UV_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_UV_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VOUT_UV_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VOUT_UV_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_VOUT_UV_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_VOUT_UV_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_VOUT_UV_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command IOUT_OC_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_IOUT_OC_FAULT_LIMIT;
uint8_t	PMBUS_CMD_IOUT_OC_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_IOUT_OC_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_IOUT_OC_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command IOUT_OC_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_IOUT_OC_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_IOUT_OC_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_IOUT_OC_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command IOUT_OC_LV_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT;
uint8_t	PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command IOUT_OC_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_IOUT_OC_WARN_LIMIT;
uint8_t	PMBUS_CMD_IOUT_OC_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_IOUT_OC_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_IOUT_OC_WARN_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command IOUT_UC_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_IOUT_UC_FAULT_LIMIT;
uint8_t	PMBUS_CMD_IOUT_UC_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_IOUT_UC_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_IOUT_UC_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command IOUT_UC_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_IOUT_UC_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_IOUT_UC_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_IOUT_UC_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command OT_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_OT_FAULT_LIMIT;
uint8_t	PMBUS_CMD_OT_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_OT_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_OT_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command OT_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_OT_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_OT_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_OT_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command OT_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_OT_WARN_LIMIT;
uint8_t	PMBUS_CMD_OT_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_OT_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_OT_WARN_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command UT_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_UT_WARN_LIMIT;
uint8_t	PMBUS_CMD_UT_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_UT_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_UT_WARN_LIMIT_RANGE[3];  	// data array for range (common for loops)

/* instantiate the command UT_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_UT_FAULT_LIMIT;
uint8_t	PMBUS_CMD_UT_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_UT_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_UT_FAULT_LIMIT_RANGE[3];  	// data array for range (common for loops)

/* instantiate the command UT_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_UT_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_UT_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_UT_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command VIN_OV_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_VIN_OV_FAULT_LIMIT;
uint8_t	PMBUS_CMD_VIN_OV_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VIN_OV_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VIN_OV_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VIN_OV_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_VIN_OV_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_VIN_OV_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_VIN_OV_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command VIN_OV_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_VIN_OV_WARN_LIMIT;
uint8_t	PMBUS_CMD_VIN_OV_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VIN_OV_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VIN_OV_WARN_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VIN_UV_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_VIN_UV_WARN_LIMIT;
uint8_t	PMBUS_CMD_VIN_UV_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VIN_UV_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VIN_UV_WARN_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VIN_UV_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_VIN_UV_FAULT_LIMIT;
uint8_t	PMBUS_CMD_VIN_UV_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_VIN_UV_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_VIN_UV_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command VIN_UV_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_VIN_UV_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_VIN_UV_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_VIN_UV_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command IIN_OC_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_IIN_OC_FAULT_LIMIT;
uint8_t	PMBUS_CMD_IIN_OC_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_IIN_OC_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_IIN_OC_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command IIN_OC_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_IIN_OC_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_IIN_OC_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_IIN_OC_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command IIN_OC_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_IIN_OC_WARN_LIMIT;
uint8_t	PMBUS_CMD_IIN_OC_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_IIN_OC_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_IIN_OC_WARN_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command POWER_GOOD_ON.
 */
PMBUS_CMD_t PMBUS_CMD_POWER_GOOD_ON;
uint8_t	PMBUS_CMD_POWER_GOOD_ON_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_POWER_GOOD_ON_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_POWER_GOOD_ON_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command POWER_GOOD_OFF.
 */
PMBUS_CMD_t PMBUS_CMD_POWER_GOOD_OFF;
uint8_t	PMBUS_CMD_POWER_GOOD_OFF_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_POWER_GOOD_OFF_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_POWER_GOOD_OFF_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command TON_DELAY.
 */
PMBUS_CMD_t PMBUS_CMD_TON_DELAY;
uint8_t	PMBUS_CMD_TON_DELAY_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_TON_DELAY_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_TON_DELAY_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command TON_RISE.
 */
PMBUS_CMD_t PMBUS_CMD_TON_RISE;
uint8_t	PMBUS_CMD_TON_RISE_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_TON_RISE_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_TON_RISE_RANGE[6];  	// data array for range (common for loops)

/* instantiate the command TON_MAX_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_TON_MAX_FAULT_LIMIT;
uint8_t	PMBUS_CMD_TON_MAX_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_TON_MAX_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_TON_MAX_FAULT_LIMIT_RANGE[6];  	// data array for range (common for loops)

/* instantiate the command TON_MAX_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_TON_MAX_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_TON_MAX_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_TON_MAX_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command TOFF_DELAY.
 */
PMBUS_CMD_t PMBUS_CMD_TOFF_DELAY;
uint8_t	PMBUS_CMD_TOFF_DELAY_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_TOFF_DELAY_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_TOFF_DELAY_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command TOFF_FALL.
 */
PMBUS_CMD_t PMBUS_CMD_TOFF_FALL;
uint8_t	PMBUS_CMD_TOFF_FALL_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_TOFF_FALL_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_TOFF_FALL_RANGE[6];  	// data array for range (common for loops)

/* instantiate the command TOFF_MAX_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_TOFF_MAX_WARN_LIMIT;
uint8_t	PMBUS_CMD_TOFF_MAX_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_TOFF_MAX_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_TOFF_MAX_WARN_LIMIT_RANGE[6];  	// data array for range (common for loops)

/* instantiate the command POUT_OP_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_POUT_OP_WARN_LIMIT;
uint8_t	PMBUS_CMD_POUT_OP_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_POUT_OP_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_POUT_OP_WARN_LIMIT_RANGE[6];  	// data array for range (common for loops)

/* instantiate the command PIN_OP_WARN_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_PIN_OP_WARN_LIMIT;
uint8_t	PMBUS_CMD_PIN_OP_WARN_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_PIN_OP_WARN_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_PIN_OP_WARN_LIMIT_RANGE[6];  	// data array for range (common for loops)

/* instantiate the command STATUS_BYTE.
 */
PMBUS_CMD_t PMBUS_CMD_STATUS_BYTE;
uint8_t	PMBUS_CMD_STATUS_BYTE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_STATUS_BYTE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command STATUS_WORD.
 */
PMBUS_CMD_t PMBUS_CMD_STATUS_WORD;
uint8_t	PMBUS_CMD_STATUS_WORD_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_STATUS_WORD_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)

/* instantiate the command STATUS_VOUT.
 */
PMBUS_CMD_t PMBUS_CMD_STATUS_VOUT;
uint8_t	PMBUS_CMD_STATUS_VOUT_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_STATUS_VOUT_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command STATUS_IOUT.
 */
PMBUS_CMD_t PMBUS_CMD_STATUS_IOUT;
uint8_t	PMBUS_CMD_STATUS_IOUT_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_STATUS_IOUT_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command STATUS_INPUT.
 */
PMBUS_CMD_t PMBUS_CMD_STATUS_INPUT;
uint8_t	PMBUS_CMD_STATUS_INPUT_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_STATUS_INPUT_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command STATUS_TEMPERATURE.
 */
PMBUS_CMD_t PMBUS_CMD_STATUS_TEMPERATURE;
uint8_t	PMBUS_CMD_STATUS_TEMPERATURE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_STATUS_TEMPERATURE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command STATUS_CML.
 */
PMBUS_CMD_t PMBUS_CMD_STATUS_CML;
uint8_t	PMBUS_CMD_STATUS_CML_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_STATUS_CML_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command STATUS_OTHER.
 */
PMBUS_CMD_t PMBUS_CMD_STATUS_OTHER;
uint8_t	PMBUS_CMD_STATUS_OTHER_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_STATUS_OTHER_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command STATUS_MFR_SPECIFIC.
 */
PMBUS_CMD_t PMBUS_CMD_STATUS_MFR_SPECIFIC;
uint8_t	PMBUS_CMD_STATUS_MFR_SPECIFIC_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_STATUS_MFR_SPECIFIC_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command STATUS_FANS_1_2.
 */
PMBUS_CMD_t PMBUS_CMD_STATUS_FANS_1_2;
uint8_t	PMBUS_CMD_STATUS_FANS_1_2_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_STATUS_FANS_1_2_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command READ_VIN.
 */
PMBUS_CMD_t PMBUS_CMD_READ_VIN;
uint8_t	PMBUS_CMD_READ_VIN_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_READ_VIN_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_VIN_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command READ_IIN.
 */
PMBUS_CMD_t PMBUS_CMD_READ_IIN;
uint8_t	PMBUS_CMD_READ_IIN_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_READ_IIN_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_IIN_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command READ_VOUT.
 */
PMBUS_CMD_t PMBUS_CMD_READ_VOUT;
uint8_t	PMBUS_CMD_READ_VOUT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_READ_VOUT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_VOUT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command READ_IOUT.
 */
PMBUS_CMD_t PMBUS_CMD_READ_IOUT;
uint8_t	PMBUS_CMD_READ_IOUT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_READ_IOUT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_IOUT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command READ_TEMPERATURE_1.
 */
PMBUS_CMD_t PMBUS_CMD_READ_TEMPERATURE_1;
uint8_t	PMBUS_CMD_READ_TEMPERATURE_1_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_READ_TEMPERATURE_1_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_TEMPERATURE_1_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command READ_TEMPERATURE_2.
 */
PMBUS_CMD_t PMBUS_CMD_READ_TEMPERATURE_2;
uint8_t	PMBUS_CMD_READ_TEMPERATURE_2_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_READ_TEMPERATURE_2_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_TEMPERATURE_2_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command structure for READ_FAN_SPEED_1.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_READ_FAN_SPEED_1;
uint8_t	PMBUS_CMD_READ_FAN_SPEED_1_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_READ_FAN_SPEED_1_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_READ_FAN_SPEED_1_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_READ_FAN_SPEED_1_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_FAN_SPEED_1_RANGE[3];  	// data array for range (common for loops)

/* instantiate the command structure for READ_FAN_SPEED_2.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_READ_FAN_SPEED_2;
uint8_t	PMBUS_CMD_READ_FAN_SPEED_2_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_READ_FAN_SPEED_2_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_READ_FAN_SPEED_2_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_READ_FAN_SPEED_2_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_FAN_SPEED_2_RANGE[3];  	// data array for range (common for loops)

/* instantiate the command READ_DUTY_CYCLE.
 */
PMBUS_CMD_t PMBUS_CMD_READ_DUTY_CYCLE;
uint8_t	PMBUS_CMD_READ_DUTY_CYCLE_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_READ_DUTY_CYCLE_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_DUTY_CYCLE_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command READ_FREQUENCY.
 */
PMBUS_CMD_t PMBUS_CMD_READ_FREQUENCY;
uint8_t	PMBUS_CMD_READ_FREQUENCY_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_READ_FREQUENCY_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_FREQUENCY_RANGE[3];  	// data array for range (common for loops)

/* instantiate the command READ_POUT.
 */
PMBUS_CMD_t PMBUS_CMD_READ_POUT;
uint8_t	PMBUS_CMD_READ_POUT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_READ_POUT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_POUT_RANGE[8];  	// data array for range (common for loops)

/* instantiate the command READ_PIN.
 */
PMBUS_CMD_t PMBUS_CMD_READ_PIN;
uint8_t	PMBUS_CMD_READ_PIN_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_READ_PIN_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_READ_PIN_RANGE[8];  	// data array for range (common for loops)

/* instantiate the command structure for PMBUS_REVISION.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_PMBUS_REVISION;
uint8_t	PMBUS_CMD_PMBUS_REVISION_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_PMBUS_REVISION_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_PMBUS_REVISION_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_PMBUS_REVISION_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_PMBUS_REVISION_RANGE[3];  	// data array for range (common for loops)

/* instantiate the command structure for MFR_ID.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_ID;
uint8_t	PMBUS_CMD_MFR_ID_DATA_LOOP0[12];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_ID_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_ID_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_ID_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_MODEL.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_MODEL;
uint8_t	PMBUS_CMD_MFR_MODEL_DATA_LOOP0[20];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_MODEL_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_MODEL_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_MODEL_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_REVISION.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_REVISION;
uint8_t	PMBUS_CMD_MFR_REVISION_DATA_LOOP0[12];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_REVISION_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_REVISION_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_REVISION_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_LOCATION.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_LOCATION;
uint8_t	PMBUS_CMD_MFR_LOCATION_DATA_LOOP0[12];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_LOCATION_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_LOCATION_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_LOCATION_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_DATE.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_DATE;
uint8_t	PMBUS_CMD_MFR_DATE_DATA_LOOP0[12];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_DATE_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_DATE_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_DATE_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_SERIAL.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_SERIAL;
uint8_t	PMBUS_CMD_MFR_SERIAL_DATA_LOOP0[20];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_SERIAL_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_SERIAL_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_SERIAL_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_VIN_MIN.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_VIN_MIN;
uint8_t	PMBUS_CMD_MFR_VIN_MIN_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_VIN_MIN_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_VIN_MIN_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_VIN_MAX.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_VIN_MAX;
uint8_t	PMBUS_CMD_MFR_VIN_MAX_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_VIN_MAX_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_VIN_MAX_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_IIN_MAX.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_IIN_MAX;
uint8_t	PMBUS_CMD_MFR_IIN_MAX_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_IIN_MAX_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_IIN_MAX_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_PIN_MAX.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_PIN_MAX;
uint8_t	PMBUS_CMD_MFR_PIN_MAX_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_PIN_MAX_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_PIN_MAX_RANGE[6];  	// data array for range (common for loops)

/* instantiate the command MFR_VOUT_MIN.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_VOUT_MIN;
uint8_t	PMBUS_CMD_MFR_VOUT_MIN_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_VOUT_MIN_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_VOUT_MIN_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_VOUT_MAX.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_VOUT_MAX;
uint8_t	PMBUS_CMD_MFR_VOUT_MAX_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_VOUT_MAX_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_VOUT_MAX_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_IOUT_MAX.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_IOUT_MAX;
uint8_t	PMBUS_CMD_MFR_IOUT_MAX_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_IOUT_MAX_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_IOUT_MAX_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_POUT_MAX.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_POUT_MAX;
uint8_t	PMBUS_CMD_MFR_POUT_MAX_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_POUT_MAX_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_POUT_MAX_RANGE[6];  	// data array for range (common for loops)

/* instantiate the command structure for MFR_TAMBIENT_MAX.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_TAMBIENT_MAX;
uint8_t	PMBUS_CMD_MFR_TAMBIENT_MAX_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_TAMBIENT_MAX_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_TAMBIENT_MAX_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_TAMBIENT_MAX_DATA_LOOP1;    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_TAMBIENT_MAX_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command structure for IC_DEVICE_ID.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_IC_DEVICE_ID;
uint8_t	PMBUS_CMD_IC_DEVICE_ID_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_IC_DEVICE_ID_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_IC_DEVICE_ID_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_IC_DEVICE_ID_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for IC_DEVICE_REV.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_IC_DEVICE_REV;
uint8_t	PMBUS_CMD_IC_DEVICE_REV_DATA_LOOP0[2];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_IC_DEVICE_REV_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_IC_DEVICE_REV_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_IC_DEVICE_REV_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command USER_DATA_00.
 */
PMBUS_CMD_t PMBUS_CMD_USER_DATA_00;
uint8_t	PMBUS_CMD_USER_DATA_00_DATA_LOOP0[16];  	// data array for command loop0
uint8_t	PMBUS_CMD_USER_DATA_00_DATA_LOOP1[16];    // data array for command loop1 (pointer if common)

/* instantiate the command FW_CONFIG_PWM.
 */
PMBUS_CMD_t PMBUS_CMD_FW_CONFIG_PWM;
uint8_t	PMBUS_CMD_FW_CONFIG_PWM_DATA_LOOP0[4];  	// data array for command loop0
uint8_t	PMBUS_CMD_FW_CONFIG_PWM_DATA_LOOP1[4];    // data array for command loop1 (pointer if common)

/* instantiate the command FW_CONFIG_REGULATION.
 */
PMBUS_CMD_t PMBUS_CMD_FW_CONFIG_REGULATION;
uint8_t	PMBUS_CMD_FW_CONFIG_REGULATION_DATA_LOOP0[14];  	// data array for command loop0
uint8_t	PMBUS_CMD_FW_CONFIG_REGULATION_DATA_LOOP1[14];    // data array for command loop1 (pointer if common)

/* instantiate the command FW_CONFIG_TELEMETRY.
 */
PMBUS_CMD_t PMBUS_CMD_FW_CONFIG_TELEMETRY;
uint8_t	PMBUS_CMD_FW_CONFIG_TELEMETRY_DATA_LOOP0[21];  	// data array for command loop0
uint8_t	PMBUS_CMD_FW_CONFIG_TELEMETRY_DATA_LOOP1[21];    // data array for command loop1 (pointer if common)

/* instantiate the command FW_CONFIG_FAULTS.
 */
PMBUS_CMD_t PMBUS_CMD_FW_CONFIG_FAULTS;
uint8_t	PMBUS_CMD_FW_CONFIG_FAULTS_DATA_LOOP0[25];  	// data array for command loop0
uint8_t	PMBUS_CMD_FW_CONFIG_FAULTS_DATA_LOOP1[25];    // data array for command loop1 (pointer if common)

/* instantiate the command FW_CONFIG_PMBUS.
 */
PMBUS_CMD_t PMBUS_CMD_FW_CONFIG_PMBUS;
uint8_t	PMBUS_CMD_FW_CONFIG_PMBUS_DATA_LOOP0[11];  	// data array for command loop0
uint8_t	PMBUS_CMD_FW_CONFIG_PMBUS_DATA_LOOP1[11];    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_IOUT_OC_FAST_FAULT_RESPONSE.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE;
uint8_t	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command FW_CONFIG_DE_THRESH.
 */
PMBUS_CMD_t PMBUS_CMD_FW_CONFIG_DE_THRESH;
uint8_t	PMBUS_CMD_FW_CONFIG_DE_THRESH_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_FW_CONFIG_DE_THRESH_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_FW_CONFIG_DE_THRESH_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_VRECT_SCALE.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_VRECT_SCALE;
uint8_t	PMBUS_CMD_MFR_VRECT_SCALE_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_VRECT_SCALE_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_VRECT_SCALE_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_TRANSFORMER_SCALE.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_TRANSFORMER_SCALE;
uint8_t	PMBUS_CMD_MFR_TRANSFORMER_SCALE_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_TRANSFORMER_SCALE_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_TRANSFORMER_SCALE_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command structure for PWM_DEADTIME.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_PWM_DEADTIME;
uint8_t	PMBUS_CMD_PWM_DEADTIME_DATA_LOOP0[24];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_PWM_DEADTIME_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_PWM_DEADTIME_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_PWM_DEADTIME_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_IOUT_OC_FAST_FAULT_LIMIT.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT;
uint8_t	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command structure for PWM_DEADTIME_ADJUSTMENT.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT;
uint8_t	PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT_DATA_LOOP0[24];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command MFR_SELECT_TEMPERATURE_SENSOR.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR;
uint8_t	PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)

/* instantiate the command FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.
 */
PMBUS_CMD_t PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD;
uint8_t	PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_IOUT_APC.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_IOUT_APC;
uint8_t	PMBUS_CMD_MFR_IOUT_APC_DATA_LOOP0[2];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_IOUT_APC_DATA_LOOP1[2];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_IOUT_APC_RANGE[4];  	// data array for range (common for loops)

/* instantiate the command MFR_MIN_PW.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_MIN_PW;
uint8_t	PMBUS_CMD_MFR_MIN_PW_DATA_LOOP0[1];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_MIN_PW_DATA_LOOP1[1];    // data array for command loop1 (pointer if common)
uint8_t	PMBUS_CMD_MFR_MIN_PW_RANGE[2];  	// data array for range (common for loops)

/* instantiate the command MFR_DEBUG_BUFF.
 */
PMBUS_CMD_t PMBUS_CMD_MFR_DEBUG_BUFF;
uint8_t	PMBUS_CMD_MFR_DEBUG_BUFF_DATA_LOOP0[8];  	// data array for command loop0
uint8_t	PMBUS_CMD_MFR_DEBUG_BUFF_DATA_LOOP1[8];    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_SETUP_PASSWORD.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_SETUP_PASSWORD;
uint8_t	PMBUS_CMD_MFR_SETUP_PASSWORD_DATA_LOOP0[6];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_SETUP_PASSWORD_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_SETUP_PASSWORD_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_SETUP_PASSWORD_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_DISABLE_SECURITY_ONCE.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE;
uint8_t	PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE_DATA_LOOP0[6];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_SECURITY_BIT_MASK_LOW.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW;
uint8_t	PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW_DATA_LOOP0[16];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_SECURITY_BIT_MASK_HIGH.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH;
uint8_t	PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH_DATA_LOOP0[16];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_FIRMWARE_COMMAND_DATA.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA;
uint8_t	PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_DATA_LOOP0[4];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/* instantiate the command structure for MFR_FIRMWARE_COMMAND.
 */
// instances of the struct one per command
PMBUS_CMD_t PMBUS_CMD_MFR_FIRMWARE_COMMAND;
uint8_t	PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_LOOP0[1];  	// data array for command loop0
/*lint -esym(552,PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_LOOP1) */
/*lint -esym(844,PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_LOOP1) */
uint8_t	* PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_LOOP1;    // data array for command loop1 (pointer if common)

/*
 * Initializes all of our pmbus structs that were generated by the script
 * Function gets called to setup command support array, initialize pointers to command data, and describe commands 
 */
void pmbus_autogen_init(void)
{
        // initialize the PMBUS_CMD_SUPPORT_ARRAY_LOOP arrays:
	for(uint32_t i=0; i<8; i++)
	{
		PMBUS_CMD_SUPPORT_ARRAY_LOOP[i] = 0;  // init the array to 0
		//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[i] = 0;  // init the array to 0
	}

	// initialize the array of pointers to the pmbus command structs:
	for(uint32_t i=0; i<256; i++)
	{
		PMBUS_CMD_ARRAY_LOOP[i] = &PMBUS_CMD_UNSUPPORTED;  // populate table with unsupported to start
		//PMBUS_CMD_ARRAY_LOOP1[i] = &PMBUS_CMD_UNSUPPORTED;  // populate table with unsupported to start
	}

        // UNSUPPORTED COMMAND:
        PMBUS_CMD_UNSUPPORTED.CMD_CONFIG = 0x000100ff;   // supported = 0, protected = 0, range_type = none, num_bytes= 1, wr and rd proto = TRANSACTION_PROTOCOL_NONE, cmdcode=0xff
	PMBUS_CMD_UNSUPPORTED.RANGE = &PMBUS_CMD_UNSUPPORTED_RANGE[0];
	PMBUS_CMD_UNSUPPORTED.DATA0 = &PMBUS_CMD_UNSUPPORTED_DATA[0];  // set the pointer to the data array
	PMBUS_CMD_UNSUPPORTED.DATA1 = &PMBUS_CMD_UNSUPPORTED_DATA[0];  // set the pointer to the data array
	PMBUS_CMD_UNSUPPORTED_DATA[0] = 0xff;  // send 0xff when we have an unsupported command


	/* initialize command structure for PAGE. */
	// PAGE COMMAND:
	//PMBUS_CMD_PAGE.OPCODE = PMBUS_CMDCODE_PAGE;
	//PMBUS_CMD_PAGE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_PAGE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_PAGE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_PAGE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_PAGE.SUPPORTED = 1;
	//PMBUS_CMD_PAGE.PROTECTED0 = 0;
	//PMBUS_CMD_PAGE.PROTECTED1 = 0;
	//PMBUS_CMD_PAGE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_SPARSE8;
	PMBUS_CMD_PAGE.RANGE = &PMBUS_CMD_PAGE_RANGE[0];
	PMBUS_CMD_PAGE_RANGE[0] = 3;
	PMBUS_CMD_PAGE_RANGE[1] = 0x0;
	PMBUS_CMD_PAGE_RANGE[2] = 0x1;
	PMBUS_CMD_PAGE_RANGE[3] = 0xFF;
	PMBUS_CMD_PAGE.CMD_CONFIG = 0x47812300;
	PMBUS_CMD_PAGE.DATA0 = &PMBUS_CMD_PAGE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_PAGE.DATA1 = &PMBUS_CMD_PAGE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_PAGE_DATA_LOOP1 = &PMBUS_CMD_PAGE_DATA_LOOP0[0];
	// RANGE SUPPORT for PAGE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_PAGE] = &PMBUS_CMD_PAGE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_PAGE] = &PMBUS_CMD_PAGE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_PAGE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_PAGE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_PAGE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_PAGE&31u));

	/* initialize command structure for OPERATION. */
	// OPERATION COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_OPERATION] = PMBUS_HANDLE_OPERATION;
	//PMBUS_CMD_OPERATION.OPCODE = PMBUS_CMDCODE_OPERATION;
	//PMBUS_CMD_OPERATION.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_OPERATION.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_OPERATION.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_OPERATION.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_OPERATION.SUPPORTED = 1;
	//PMBUS_CMD_OPERATION.PROTECTED0 = 0;
	//PMBUS_CMD_OPERATION.PROTECTED1 = 0;
	//PMBUS_CMD_OPERATION.RANGE_TYPE = (uint8_t) PMBUS_RANGE_OPERATION;
	PMBUS_CMD_OPERATION.CMD_CONFIG = 0xc9812301;
	PMBUS_CMD_OPERATION.DATA0 = &PMBUS_CMD_OPERATION_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_OPERATION.DATA1 = &PMBUS_CMD_OPERATION_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for OPERATION COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_OPERATION] = &PMBUS_CMD_OPERATION;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_OPERATION] = &PMBUS_CMD_OPERATION;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_OPERATION/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_OPERATION&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_OPERATION/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_OPERATION&31u));

	/* initialize command structure for ON_OFF_CONFIG. */
	// ON_OFF_CONFIG COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_ON_OFF_CONFIG] = PMBUS_HANDLE_OPERATION;
	//PMBUS_CMD_ON_OFF_CONFIG.OPCODE = PMBUS_CMDCODE_ON_OFF_CONFIG;
	//PMBUS_CMD_ON_OFF_CONFIG.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_ON_OFF_CONFIG.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_ON_OFF_CONFIG.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_ON_OFF_CONFIG.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_ON_OFF_CONFIG.SUPPORTED = 1;
	//PMBUS_CMD_ON_OFF_CONFIG.PROTECTED0 = 0;
	//PMBUS_CMD_ON_OFF_CONFIG.PROTECTED1 = 0;
	//PMBUS_CMD_ON_OFF_CONFIG.RANGE_TYPE = (uint8_t) PMBUS_RANGE_BYTE_MASKS;
	PMBUS_CMD_ON_OFF_CONFIG.RANGE = &PMBUS_CMD_ON_OFF_CONFIG_RANGE[0];
	PMBUS_CMD_ON_OFF_CONFIG_RANGE[0] = 0x1F;
	PMBUS_CMD_ON_OFF_CONFIG.CMD_CONFIG = 0xcc812302;
	PMBUS_CMD_ON_OFF_CONFIG.DATA0 = &PMBUS_CMD_ON_OFF_CONFIG_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_ON_OFF_CONFIG.DATA1 = &PMBUS_CMD_ON_OFF_CONFIG_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for ON_OFF_CONFIG COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_ON_OFF_CONFIG] = &PMBUS_CMD_ON_OFF_CONFIG;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_ON_OFF_CONFIG] = &PMBUS_CMD_ON_OFF_CONFIG;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_ON_OFF_CONFIG/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_ON_OFF_CONFIG&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_ON_OFF_CONFIG/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_ON_OFF_CONFIG&31u));

	/* initialize command structure for CLEAR_FAULTS. */
	// CLEAR_FAULTS COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_CLEAR_FAULTS] = PMBUS_HANDLE_CLEAR_FAULTS;
	//PMBUS_CMD_CLEAR_FAULTS.OPCODE = PMBUS_CMDCODE_CLEAR_FAULTS;
	//PMBUS_CMD_CLEAR_FAULTS.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_CLEAR_FAULTS.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_CLEAR_FAULTS.NUM_BYTES = 0; // data only not including slave address and command
	//PMBUS_CMD_CLEAR_FAULTS.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_CLEAR_FAULTS.SUPPORTED = 1;
	//PMBUS_CMD_CLEAR_FAULTS.PROTECTED0 = 0;
	//PMBUS_CMD_CLEAR_FAULTS.PROTECTED1 = 0;
	//PMBUS_CMD_CLEAR_FAULTS.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_CLEAR_FAULTS.CMD_CONFIG = 0x41800303;
	// RANGE SUPPORT for CLEAR_FAULTS COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_CLEAR_FAULTS] = &PMBUS_CMD_CLEAR_FAULTS;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_CLEAR_FAULTS] = &PMBUS_CMD_CLEAR_FAULTS;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_CLEAR_FAULTS/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_CLEAR_FAULTS&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_CLEAR_FAULTS/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_CLEAR_FAULTS&31u));

	/* initialize command structure for WRITE_PROTECT. */
	// WRITE_PROTECT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_WRITE_PROTECT] = PMBUS_HANDLE_WRITE_PROTECT;
	//PMBUS_CMD_WRITE_PROTECT.OPCODE = PMBUS_CMDCODE_WRITE_PROTECT;
	//PMBUS_CMD_WRITE_PROTECT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_WRITE_PROTECT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_WRITE_PROTECT.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_WRITE_PROTECT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_WRITE_PROTECT.SUPPORTED = 1;
	//PMBUS_CMD_WRITE_PROTECT.PROTECTED0 = 0;
	//PMBUS_CMD_WRITE_PROTECT.PROTECTED1 = 0;
	//PMBUS_CMD_WRITE_PROTECT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_SPARSE8;
	PMBUS_CMD_WRITE_PROTECT.RANGE = &PMBUS_CMD_WRITE_PROTECT_RANGE[0];
	PMBUS_CMD_WRITE_PROTECT_RANGE[0] = 4;
	PMBUS_CMD_WRITE_PROTECT_RANGE[1] = 0x00;
	PMBUS_CMD_WRITE_PROTECT_RANGE[2] =  0x20;
	PMBUS_CMD_WRITE_PROTECT_RANGE[3] =  0x40;
	PMBUS_CMD_WRITE_PROTECT_RANGE[4] =  0x80;
	PMBUS_CMD_WRITE_PROTECT.CMD_CONFIG = 0xc7812310;
	PMBUS_CMD_WRITE_PROTECT.DATA0 = &PMBUS_CMD_WRITE_PROTECT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_WRITE_PROTECT.DATA1 = &PMBUS_CMD_WRITE_PROTECT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for WRITE_PROTECT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_WRITE_PROTECT] = &PMBUS_CMD_WRITE_PROTECT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_WRITE_PROTECT] = &PMBUS_CMD_WRITE_PROTECT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_WRITE_PROTECT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_WRITE_PROTECT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_WRITE_PROTECT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_WRITE_PROTECT&31u));

	/* initialize command structure for STORE_DEFAULT_ALL. */
	// STORE_DEFAULT_ALL COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STORE_DEFAULT_ALL] = PMBUS_HANDLE_STORE_DEFAULT_ALL;
	//PMBUS_CMD_STORE_DEFAULT_ALL.OPCODE = PMBUS_CMDCODE_STORE_DEFAULT_ALL;
	//PMBUS_CMD_STORE_DEFAULT_ALL.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STORE_DEFAULT_ALL.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_STORE_DEFAULT_ALL.NUM_BYTES = 0; // data only not including slave address and command
	//PMBUS_CMD_STORE_DEFAULT_ALL.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STORE_DEFAULT_ALL.SUPPORTED = 1;
	//PMBUS_CMD_STORE_DEFAULT_ALL.PROTECTED0 = 0;
	//PMBUS_CMD_STORE_DEFAULT_ALL.PROTECTED1 = 0;
	//PMBUS_CMD_STORE_DEFAULT_ALL.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STORE_DEFAULT_ALL.CMD_CONFIG = 0x41800311;
	// RANGE SUPPORT for STORE_DEFAULT_ALL COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STORE_DEFAULT_ALL] = &PMBUS_CMD_STORE_DEFAULT_ALL;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STORE_DEFAULT_ALL] = &PMBUS_CMD_STORE_DEFAULT_ALL;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STORE_DEFAULT_ALL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STORE_DEFAULT_ALL&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STORE_DEFAULT_ALL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STORE_DEFAULT_ALL&31u));

	/* initialize command structure for RESTORE_DEFAULT_ALL. */
	// RESTORE_DEFAULT_ALL COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_RESTORE_DEFAULT_ALL] = PMBUS_HANDLE_RESTORE_DEFAULT_ALL;
	//PMBUS_CMD_RESTORE_DEFAULT_ALL.OPCODE = PMBUS_CMDCODE_RESTORE_DEFAULT_ALL;
	//PMBUS_CMD_RESTORE_DEFAULT_ALL.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_RESTORE_DEFAULT_ALL.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_RESTORE_DEFAULT_ALL.NUM_BYTES = 0; // data only not including slave address and command
	//PMBUS_CMD_RESTORE_DEFAULT_ALL.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_RESTORE_DEFAULT_ALL.SUPPORTED = 1;
	//PMBUS_CMD_RESTORE_DEFAULT_ALL.PROTECTED0 = 0;
	//PMBUS_CMD_RESTORE_DEFAULT_ALL.PROTECTED1 = 0;
	//PMBUS_CMD_RESTORE_DEFAULT_ALL.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_RESTORE_DEFAULT_ALL.CMD_CONFIG = 0x41800312;
	// RANGE SUPPORT for RESTORE_DEFAULT_ALL COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_RESTORE_DEFAULT_ALL] = &PMBUS_CMD_RESTORE_DEFAULT_ALL;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_RESTORE_DEFAULT_ALL] = &PMBUS_CMD_RESTORE_DEFAULT_ALL;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_RESTORE_DEFAULT_ALL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_RESTORE_DEFAULT_ALL&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_RESTORE_DEFAULT_ALL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_RESTORE_DEFAULT_ALL&31u));

	/* initialize command structure for STORE_USER_ALL. */
	// STORE_USER_ALL COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STORE_USER_ALL] = PMBUS_HANDLE_STORE_USER_ALL;
	//PMBUS_CMD_STORE_USER_ALL.OPCODE = PMBUS_CMDCODE_STORE_USER_ALL;
	//PMBUS_CMD_STORE_USER_ALL.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STORE_USER_ALL.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_STORE_USER_ALL.NUM_BYTES = 0; // data only not including slave address and command
	//PMBUS_CMD_STORE_USER_ALL.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STORE_USER_ALL.SUPPORTED = 1;
	//PMBUS_CMD_STORE_USER_ALL.PROTECTED0 = 0;
	//PMBUS_CMD_STORE_USER_ALL.PROTECTED1 = 0;
	//PMBUS_CMD_STORE_USER_ALL.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STORE_USER_ALL.CMD_CONFIG = 0x41800315;
	// RANGE SUPPORT for STORE_USER_ALL COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STORE_USER_ALL] = &PMBUS_CMD_STORE_USER_ALL;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STORE_USER_ALL] = &PMBUS_CMD_STORE_USER_ALL;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STORE_USER_ALL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STORE_USER_ALL&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STORE_USER_ALL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STORE_USER_ALL&31u));

	/* initialize command structure for RESTORE_USER_ALL. */
	// RESTORE_USER_ALL COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_RESTORE_USER_ALL] = PMBUS_HANDLE_RESTORE_USER_ALL;
	//PMBUS_CMD_RESTORE_USER_ALL.OPCODE = PMBUS_CMDCODE_RESTORE_USER_ALL;
	//PMBUS_CMD_RESTORE_USER_ALL.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_RESTORE_USER_ALL.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_RESTORE_USER_ALL.NUM_BYTES = 0; // data only not including slave address and command
	//PMBUS_CMD_RESTORE_USER_ALL.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_RESTORE_USER_ALL.SUPPORTED = 1;
	//PMBUS_CMD_RESTORE_USER_ALL.PROTECTED0 = 0;
	//PMBUS_CMD_RESTORE_USER_ALL.PROTECTED1 = 0;
	//PMBUS_CMD_RESTORE_USER_ALL.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_RESTORE_USER_ALL.CMD_CONFIG = 0x41800316;
	// RANGE SUPPORT for RESTORE_USER_ALL COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_RESTORE_USER_ALL] = &PMBUS_CMD_RESTORE_USER_ALL;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_RESTORE_USER_ALL] = &PMBUS_CMD_RESTORE_USER_ALL;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_RESTORE_USER_ALL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_RESTORE_USER_ALL&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_RESTORE_USER_ALL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_RESTORE_USER_ALL&31u));

	/* initialize command structure for STORE_USER_CODE. */
	// STORE_USER_CODE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STORE_USER_CODE] = PMBUS_HANDLE_STORE_USER_CODE;
	//PMBUS_CMD_STORE_USER_CODE.OPCODE = PMBUS_CMDCODE_STORE_USER_CODE;
	//PMBUS_CMD_STORE_USER_CODE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STORE_USER_CODE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_STORE_USER_CODE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_STORE_USER_CODE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STORE_USER_CODE.SUPPORTED = 1;
	//PMBUS_CMD_STORE_USER_CODE.PROTECTED0 = 0;
	//PMBUS_CMD_STORE_USER_CODE.PROTECTED1 = 0;
	//PMBUS_CMD_STORE_USER_CODE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STORE_USER_CODE.CMD_CONFIG = 0x41810317;
	PMBUS_CMD_STORE_USER_CODE.DATA0 = &PMBUS_CMD_STORE_USER_CODE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STORE_USER_CODE.DATA1 = &PMBUS_CMD_STORE_USER_CODE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STORE_USER_CODE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STORE_USER_CODE] = &PMBUS_CMD_STORE_USER_CODE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STORE_USER_CODE] = &PMBUS_CMD_STORE_USER_CODE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STORE_USER_CODE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STORE_USER_CODE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STORE_USER_CODE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STORE_USER_CODE&31u));

	/* initialize command structure for RESTORE_USER_CODE. */
	// RESTORE_USER_CODE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_RESTORE_USER_CODE] = PMBUS_HANDLE_RESTORE_USER_CODE;
	//PMBUS_CMD_RESTORE_USER_CODE.OPCODE = PMBUS_CMDCODE_RESTORE_USER_CODE;
	//PMBUS_CMD_RESTORE_USER_CODE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_RESTORE_USER_CODE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_RESTORE_USER_CODE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_RESTORE_USER_CODE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_RESTORE_USER_CODE.SUPPORTED = 1;
	//PMBUS_CMD_RESTORE_USER_CODE.PROTECTED0 = 0;
	//PMBUS_CMD_RESTORE_USER_CODE.PROTECTED1 = 0;
	//PMBUS_CMD_RESTORE_USER_CODE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_RESTORE_USER_CODE.CMD_CONFIG = 0x41810318;
	PMBUS_CMD_RESTORE_USER_CODE.DATA0 = &PMBUS_CMD_RESTORE_USER_CODE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_RESTORE_USER_CODE.DATA1 = &PMBUS_CMD_RESTORE_USER_CODE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for RESTORE_USER_CODE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_RESTORE_USER_CODE] = &PMBUS_CMD_RESTORE_USER_CODE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_RESTORE_USER_CODE] = &PMBUS_CMD_RESTORE_USER_CODE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_RESTORE_USER_CODE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_RESTORE_USER_CODE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_RESTORE_USER_CODE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_RESTORE_USER_CODE&31u));

	/* initialize command structure for CAPABILITY. */
	// CAPABILITY COMMAND:
	//PMBUS_CMD_CAPABILITY.OPCODE = PMBUS_CMDCODE_CAPABILITY;
	//PMBUS_CMD_CAPABILITY.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_CAPABILITY.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_CAPABILITY.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_CAPABILITY.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_CAPABILITY.SUPPORTED = 1;
	//PMBUS_CMD_CAPABILITY.PROTECTED0 = 0;
	//PMBUS_CMD_CAPABILITY.PROTECTED1 = 0;
	//PMBUS_CMD_CAPABILITY.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_CAPABILITY.CMD_CONFIG = 0xc0812019;
	PMBUS_CMD_CAPABILITY.DATA0 = &PMBUS_CMD_CAPABILITY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_CAPABILITY.DATA1 = &PMBUS_CMD_CAPABILITY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_CAPABILITY_DATA_LOOP1 = &PMBUS_CMD_CAPABILITY_DATA_LOOP0[0];
	// RANGE SUPPORT for CAPABILITY COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_CAPABILITY] = &PMBUS_CMD_CAPABILITY;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_CAPABILITY] = &PMBUS_CMD_CAPABILITY;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_CAPABILITY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_CAPABILITY&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_CAPABILITY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_CAPABILITY&31u));

	/* initialize command structure for SMBALERT_MASK. */
	// SMBALERT_MASK COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_SMBALERT_MASK] = PMBUS_HANDLE_SMBALERT_MASK;
	//PMBUS_CMD_SMBALERT_MASK.OPCODE = PMBUS_CMDCODE_SMBALERT_MASK;
	//PMBUS_CMD_SMBALERT_MASK.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_SMBALERT_MASK.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_SMBALERT_MASK.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_SMBALERT_MASK.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_SMBALERT_MASK.SUPPORTED = 1;
	//PMBUS_CMD_SMBALERT_MASK.PROTECTED0 = 0;
	//PMBUS_CMD_SMBALERT_MASK.PROTECTED1 = 0;
	//PMBUS_CMD_SMBALERT_MASK.RANGE_TYPE = (uint8_t) PMBUS_RANGE_SMBALERT_MASK;
	PMBUS_CMD_SMBALERT_MASK.CMD_CONFIG = 0xcac2531b;
	PMBUS_CMD_SMBALERT_MASK.DATA0 = &PMBUS_CMD_SMBALERT_MASK_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_SMBALERT_MASK.DATA1 = &PMBUS_CMD_SMBALERT_MASK_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for SMBALERT_MASK COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_SMBALERT_MASK] = &PMBUS_CMD_SMBALERT_MASK;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_SMBALERT_MASK] = &PMBUS_CMD_SMBALERT_MASK;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_SMBALERT_MASK/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_SMBALERT_MASK&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_SMBALERT_MASK/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_SMBALERT_MASK&31u));

	/* initialize command structure for VOUT_MODE. */
	// VOUT_MODE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_MODE] = PMBUS_HANDLE_VOUT_SCALE_LOOP;
	//PMBUS_CMD_VOUT_MODE.OPCODE = PMBUS_CMDCODE_VOUT_MODE;
	//PMBUS_CMD_VOUT_MODE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_MODE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_MODE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_VOUT_MODE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_MODE.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_MODE.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_MODE.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_MODE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_SPARSE8_PAIRS;
	PMBUS_CMD_VOUT_MODE.RANGE = &PMBUS_CMD_VOUT_MODE_RANGE[0];
	PMBUS_CMD_VOUT_MODE_RANGE[0] = 2;
	PMBUS_CMD_VOUT_MODE_RANGE[1] = 0x14;
	PMBUS_CMD_VOUT_MODE_RANGE[2] = 0x18;
	PMBUS_CMD_VOUT_MODE.CMD_CONFIG = 0xc6812320;
	PMBUS_CMD_VOUT_MODE.DATA0 = &PMBUS_CMD_VOUT_MODE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_MODE.DATA1 = &PMBUS_CMD_VOUT_MODE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_MODE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_MODE] = &PMBUS_CMD_VOUT_MODE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_MODE] = &PMBUS_CMD_VOUT_MODE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_MODE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_MODE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_MODE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_MODE&31u));

	/* initialize command structure for VOUT_COMMAND. */
	// VOUT_COMMAND COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_COMMAND] = PMBUS_HANDLE_VOUT_COMMAND;
	//PMBUS_CMD_VOUT_COMMAND.OPCODE = PMBUS_CMDCODE_VOUT_COMMAND;
	//PMBUS_CMD_VOUT_COMMAND.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_COMMAND.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_COMMAND.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_COMMAND.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_COMMAND.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_COMMAND.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_COMMAND.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_COMMAND.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_COMMAND.RANGE = &PMBUS_CMD_VOUT_COMMAND_RANGE[0];
	PMBUS_CMD_VOUT_COMMAND.CMD_CONFIG = 0xc8822321;
	PMBUS_CMD_VOUT_COMMAND.DATA0 = &PMBUS_CMD_VOUT_COMMAND_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_COMMAND.DATA1 = &PMBUS_CMD_VOUT_COMMAND_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_COMMAND COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_COMMAND] = &PMBUS_CMD_VOUT_COMMAND;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_COMMAND] = &PMBUS_CMD_VOUT_COMMAND;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_COMMAND/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_COMMAND&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_COMMAND/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_COMMAND&31u));

	/* initialize command structure for VOUT_TRIM. */
	// VOUT_TRIM COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_TRIM] = PMBUS_HANDLE_VOUT_COMMAND;
	//PMBUS_CMD_VOUT_TRIM.OPCODE = PMBUS_CMDCODE_VOUT_TRIM;
	//PMBUS_CMD_VOUT_TRIM.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_TRIM.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_TRIM.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_TRIM.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_TRIM.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_TRIM.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_TRIM.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_TRIM.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_TRIM.RANGE = &PMBUS_CMD_VOUT_TRIM_RANGE[0];
	PMBUS_CMD_VOUT_TRIM.CMD_CONFIG = 0xc8822322;
	PMBUS_CMD_VOUT_TRIM.DATA0 = &PMBUS_CMD_VOUT_TRIM_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_TRIM.DATA1 = &PMBUS_CMD_VOUT_TRIM_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_TRIM COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_TRIM] = &PMBUS_CMD_VOUT_TRIM;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_TRIM] = &PMBUS_CMD_VOUT_TRIM;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_TRIM/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_TRIM&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_TRIM/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_TRIM&31u));

	/* initialize command structure for VOUT_CAL_OFFSET. */
	// VOUT_CAL_OFFSET COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_CAL_OFFSET] = PMBUS_HANDLE_VOUT_COMMAND;
	//PMBUS_CMD_VOUT_CAL_OFFSET.OPCODE = PMBUS_CMDCODE_VOUT_CAL_OFFSET;
	//PMBUS_CMD_VOUT_CAL_OFFSET.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_CAL_OFFSET.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_CAL_OFFSET.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_CAL_OFFSET.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_CAL_OFFSET.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_CAL_OFFSET.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_CAL_OFFSET.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_CAL_OFFSET.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_CAL_OFFSET.RANGE = &PMBUS_CMD_VOUT_CAL_OFFSET_RANGE[0];
	PMBUS_CMD_VOUT_CAL_OFFSET.CMD_CONFIG = 0xc8822323;
	PMBUS_CMD_VOUT_CAL_OFFSET.DATA0 = &PMBUS_CMD_VOUT_CAL_OFFSET_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_CAL_OFFSET.DATA1 = &PMBUS_CMD_VOUT_CAL_OFFSET_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_CAL_OFFSET COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_CAL_OFFSET] = &PMBUS_CMD_VOUT_CAL_OFFSET;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_CAL_OFFSET] = &PMBUS_CMD_VOUT_CAL_OFFSET;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_CAL_OFFSET/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_CAL_OFFSET&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_CAL_OFFSET/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_CAL_OFFSET&31u));

	/* initialize command structure for VOUT_MAX. */
	// VOUT_MAX COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_MAX] = PMBUS_HANDLE_VOUT_MAX;
	//PMBUS_CMD_VOUT_MAX.OPCODE = PMBUS_CMDCODE_VOUT_MAX;
	//PMBUS_CMD_VOUT_MAX.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_MAX.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_MAX.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_MAX.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_MAX.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_MAX.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_MAX.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_MAX.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_MAX.RANGE = &PMBUS_CMD_VOUT_MAX_RANGE[0];
	PMBUS_CMD_VOUT_MAX.CMD_CONFIG = 0xc8822324;
	PMBUS_CMD_VOUT_MAX.DATA0 = &PMBUS_CMD_VOUT_MAX_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_MAX.DATA1 = &PMBUS_CMD_VOUT_MAX_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_MAX COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_MAX] = &PMBUS_CMD_VOUT_MAX;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_MAX] = &PMBUS_CMD_VOUT_MAX;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_MAX&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_MAX&31u));

	/* initialize command structure for VOUT_MARGIN_HIGH. */
	// VOUT_MARGIN_HIGH COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_MARGIN_HIGH] = PMBUS_HANDLE_VOUT_COMMAND;
	//PMBUS_CMD_VOUT_MARGIN_HIGH.OPCODE = PMBUS_CMDCODE_VOUT_MARGIN_HIGH;
	//PMBUS_CMD_VOUT_MARGIN_HIGH.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_MARGIN_HIGH.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_MARGIN_HIGH.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_MARGIN_HIGH.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_MARGIN_HIGH.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_MARGIN_HIGH.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_MARGIN_HIGH.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_MARGIN_HIGH.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_MARGIN_HIGH.RANGE = &PMBUS_CMD_VOUT_MARGIN_HIGH_RANGE[0];
	PMBUS_CMD_VOUT_MARGIN_HIGH.CMD_CONFIG = 0xc8822325;
	PMBUS_CMD_VOUT_MARGIN_HIGH.DATA0 = &PMBUS_CMD_VOUT_MARGIN_HIGH_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_MARGIN_HIGH.DATA1 = &PMBUS_CMD_VOUT_MARGIN_HIGH_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_MARGIN_HIGH COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_MARGIN_HIGH] = &PMBUS_CMD_VOUT_MARGIN_HIGH;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_MARGIN_HIGH] = &PMBUS_CMD_VOUT_MARGIN_HIGH;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_MARGIN_HIGH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_MARGIN_HIGH&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_MARGIN_HIGH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_MARGIN_HIGH&31u));

	/* initialize command structure for VOUT_MARGIN_LOW. */
	// VOUT_MARGIN_LOW COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_MARGIN_LOW] = PMBUS_HANDLE_VOUT_COMMAND;
	//PMBUS_CMD_VOUT_MARGIN_LOW.OPCODE = PMBUS_CMDCODE_VOUT_MARGIN_LOW;
	//PMBUS_CMD_VOUT_MARGIN_LOW.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_MARGIN_LOW.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_MARGIN_LOW.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_MARGIN_LOW.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_MARGIN_LOW.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_MARGIN_LOW.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_MARGIN_LOW.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_MARGIN_LOW.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_MARGIN_LOW.RANGE = &PMBUS_CMD_VOUT_MARGIN_LOW_RANGE[0];
	PMBUS_CMD_VOUT_MARGIN_LOW.CMD_CONFIG = 0xc8822326;
	PMBUS_CMD_VOUT_MARGIN_LOW.DATA0 = &PMBUS_CMD_VOUT_MARGIN_LOW_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_MARGIN_LOW.DATA1 = &PMBUS_CMD_VOUT_MARGIN_LOW_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_MARGIN_LOW COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_MARGIN_LOW] = &PMBUS_CMD_VOUT_MARGIN_LOW;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_MARGIN_LOW] = &PMBUS_CMD_VOUT_MARGIN_LOW;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_MARGIN_LOW/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_MARGIN_LOW&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_MARGIN_LOW/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_MARGIN_LOW&31u));

	/* initialize command structure for VOUT_TRANSITION_RATE. */
	// VOUT_TRANSITION_RATE COMMAND:
	//PMBUS_CMD_VOUT_TRANSITION_RATE.OPCODE = PMBUS_CMDCODE_VOUT_TRANSITION_RATE;
	//PMBUS_CMD_VOUT_TRANSITION_RATE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_TRANSITION_RATE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_TRANSITION_RATE.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_TRANSITION_RATE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_TRANSITION_RATE.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_TRANSITION_RATE.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_TRANSITION_RATE.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_TRANSITION_RATE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_VOUT_TRANSITION_RATE.RANGE = &PMBUS_CMD_VOUT_TRANSITION_RATE_RANGE[0];
	PMBUS_CMD_VOUT_TRANSITION_RATE_RANGE[0] = 6;
	PMBUS_CMD_VOUT_TRANSITION_RATE_RANGE[1] = 3;
	PMBUS_CMD_VOUT_TRANSITION_RATE.CMD_CONFIG = 0xc3822327;
	PMBUS_CMD_VOUT_TRANSITION_RATE.DATA0 = &PMBUS_CMD_VOUT_TRANSITION_RATE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_TRANSITION_RATE.DATA1 = &PMBUS_CMD_VOUT_TRANSITION_RATE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_TRANSITION_RATE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_TRANSITION_RATE] = &PMBUS_CMD_VOUT_TRANSITION_RATE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_TRANSITION_RATE] = &PMBUS_CMD_VOUT_TRANSITION_RATE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_TRANSITION_RATE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_TRANSITION_RATE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_TRANSITION_RATE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_TRANSITION_RATE&31u));

	/* initialize command structure for VOUT_DROOP. */
	// VOUT_DROOP COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_DROOP] = PMBUS_HANDLE_VOUT_DROOP;
	//PMBUS_CMD_VOUT_DROOP.OPCODE = PMBUS_CMDCODE_VOUT_DROOP;
	//PMBUS_CMD_VOUT_DROOP.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_DROOP.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_DROOP.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_DROOP.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_DROOP.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_DROOP.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_DROOP.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_DROOP.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_VOUT_DROOP.RANGE = &PMBUS_CMD_VOUT_DROOP_RANGE[0];
	PMBUS_CMD_VOUT_DROOP_RANGE[0] = 3;
	PMBUS_CMD_VOUT_DROOP_RANGE[1] = 7;
	PMBUS_CMD_VOUT_DROOP_RANGE[2] = 4;
	PMBUS_CMD_VOUT_DROOP_RANGE[3] = 6;
	PMBUS_CMD_VOUT_DROOP.CMD_CONFIG = 0xc5822328;
	PMBUS_CMD_VOUT_DROOP.DATA0 = &PMBUS_CMD_VOUT_DROOP_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_DROOP.DATA1 = &PMBUS_CMD_VOUT_DROOP_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_DROOP COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_DROOP] = &PMBUS_CMD_VOUT_DROOP;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_DROOP] = &PMBUS_CMD_VOUT_DROOP;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_DROOP/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_DROOP&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_DROOP/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_DROOP&31u));

	/* initialize command structure for VOUT_SCALE_LOOP. */
	// VOUT_SCALE_LOOP COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_SCALE_LOOP] = PMBUS_HANDLE_VOUT_SCALE_LOOP;
	//PMBUS_CMD_VOUT_SCALE_LOOP.OPCODE = PMBUS_CMDCODE_VOUT_SCALE_LOOP;
	//PMBUS_CMD_VOUT_SCALE_LOOP.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_SCALE_LOOP.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_SCALE_LOOP.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_SCALE_LOOP.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_SCALE_LOOP.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_SCALE_LOOP.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_SCALE_LOOP.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_SCALE_LOOP.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_VOUT_SCALE_LOOP.CMD_CONFIG = 0xc1822329;
	PMBUS_CMD_VOUT_SCALE_LOOP.DATA0 = &PMBUS_CMD_VOUT_SCALE_LOOP_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_SCALE_LOOP.DATA1 = &PMBUS_CMD_VOUT_SCALE_LOOP_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_SCALE_LOOP COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_SCALE_LOOP] = &PMBUS_CMD_VOUT_SCALE_LOOP;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_SCALE_LOOP] = &PMBUS_CMD_VOUT_SCALE_LOOP;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_SCALE_LOOP/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_SCALE_LOOP&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_SCALE_LOOP/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_SCALE_LOOP&31u));

	/* initialize command structure for VOUT_MIN. */
	// VOUT_MIN COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_MIN] = PMBUS_HANDLE_VOUT_MIN;
	//PMBUS_CMD_VOUT_MIN.OPCODE = PMBUS_CMDCODE_VOUT_MIN;
	//PMBUS_CMD_VOUT_MIN.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_MIN.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_MIN.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_MIN.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_MIN.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_MIN.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_MIN.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_MIN.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_MIN.RANGE = &PMBUS_CMD_VOUT_MIN_RANGE[0];
	PMBUS_CMD_VOUT_MIN.CMD_CONFIG = 0xc882232b;
	PMBUS_CMD_VOUT_MIN.DATA0 = &PMBUS_CMD_VOUT_MIN_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_MIN.DATA1 = &PMBUS_CMD_VOUT_MIN_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_MIN COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_MIN] = &PMBUS_CMD_VOUT_MIN;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_MIN] = &PMBUS_CMD_VOUT_MIN;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_MIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_MIN&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_MIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_MIN&31u));

	/* initialize command structure for MAX_DUTY. */
	// MAX_DUTY COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MAX_DUTY] = PMBUS_HANDLE_MAX_DUTY;
	//PMBUS_CMD_MAX_DUTY.OPCODE = PMBUS_CMDCODE_MAX_DUTY;
	//PMBUS_CMD_MAX_DUTY.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MAX_DUTY.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MAX_DUTY.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MAX_DUTY.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MAX_DUTY.SUPPORTED = 1;
	//PMBUS_CMD_MAX_DUTY.PROTECTED0 = 0;
	//PMBUS_CMD_MAX_DUTY.PROTECTED1 = 0;
	//PMBUS_CMD_MAX_DUTY.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MAX_DUTY.RANGE = &PMBUS_CMD_MAX_DUTY_RANGE[0];
	PMBUS_CMD_MAX_DUTY_RANGE[0] = 7;
	PMBUS_CMD_MAX_DUTY_RANGE[1] = 2;
	PMBUS_CMD_MAX_DUTY.CMD_CONFIG = 0xc3822332;
	PMBUS_CMD_MAX_DUTY.DATA0 = &PMBUS_CMD_MAX_DUTY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MAX_DUTY.DATA1 = &PMBUS_CMD_MAX_DUTY_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MAX_DUTY COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MAX_DUTY] = &PMBUS_CMD_MAX_DUTY;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MAX_DUTY] = &PMBUS_CMD_MAX_DUTY;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MAX_DUTY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MAX_DUTY&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MAX_DUTY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MAX_DUTY&31u));

	/* initialize command structure for FREQUENCY_SWITCH. */
	// FREQUENCY_SWITCH COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FREQUENCY_SWITCH] = PMBUS_HANDLE_FREQUENCY_SWITCH;
	//PMBUS_CMD_FREQUENCY_SWITCH.OPCODE = PMBUS_CMDCODE_FREQUENCY_SWITCH;
	//PMBUS_CMD_FREQUENCY_SWITCH.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_FREQUENCY_SWITCH.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_FREQUENCY_SWITCH.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_FREQUENCY_SWITCH.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FREQUENCY_SWITCH.SUPPORTED = 1;
	//PMBUS_CMD_FREQUENCY_SWITCH.PROTECTED0 = 0;
	//PMBUS_CMD_FREQUENCY_SWITCH.PROTECTED1 = 0;
	//PMBUS_CMD_FREQUENCY_SWITCH.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_FREQUENCY_SWITCH.RANGE = &PMBUS_CMD_FREQUENCY_SWITCH_RANGE[0];
	PMBUS_CMD_FREQUENCY_SWITCH_RANGE[0] = 11;
	PMBUS_CMD_FREQUENCY_SWITCH_RANGE[1] = 31;
	PMBUS_CMD_FREQUENCY_SWITCH.CMD_CONFIG = 0xc3822333;
	PMBUS_CMD_FREQUENCY_SWITCH.DATA0 = &PMBUS_CMD_FREQUENCY_SWITCH_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FREQUENCY_SWITCH.DATA1 = &PMBUS_CMD_FREQUENCY_SWITCH_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for FREQUENCY_SWITCH COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FREQUENCY_SWITCH] = &PMBUS_CMD_FREQUENCY_SWITCH;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FREQUENCY_SWITCH] = &PMBUS_CMD_FREQUENCY_SWITCH;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FREQUENCY_SWITCH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FREQUENCY_SWITCH&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FREQUENCY_SWITCH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FREQUENCY_SWITCH&31u));

	/* initialize command structure for POWER_MODE. */
	// POWER_MODE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_POWER_MODE] = PMBUS_HANDLE_VOUT_COMMAND;
	//PMBUS_CMD_POWER_MODE.OPCODE = PMBUS_CMDCODE_POWER_MODE;
	//PMBUS_CMD_POWER_MODE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_POWER_MODE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_POWER_MODE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_POWER_MODE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_POWER_MODE.SUPPORTED = 1;
	//PMBUS_CMD_POWER_MODE.PROTECTED0 = 0;
	//PMBUS_CMD_POWER_MODE.PROTECTED1 = 0;
	//PMBUS_CMD_POWER_MODE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_SPARSE8;
	PMBUS_CMD_POWER_MODE.RANGE = &PMBUS_CMD_POWER_MODE_RANGE[0];
	PMBUS_CMD_POWER_MODE_RANGE[0] = 3;
	PMBUS_CMD_POWER_MODE_RANGE[1] = 0x00;
	PMBUS_CMD_POWER_MODE_RANGE[2] =  0x03;
	PMBUS_CMD_POWER_MODE_RANGE[3] =  0x04;
	PMBUS_CMD_POWER_MODE.CMD_CONFIG = 0xc7812334;
	PMBUS_CMD_POWER_MODE.DATA0 = &PMBUS_CMD_POWER_MODE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_POWER_MODE.DATA1 = &PMBUS_CMD_POWER_MODE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for POWER_MODE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_POWER_MODE] = &PMBUS_CMD_POWER_MODE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_POWER_MODE] = &PMBUS_CMD_POWER_MODE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_POWER_MODE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_POWER_MODE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_POWER_MODE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_POWER_MODE&31u));

	/* initialize command structure for VIN_ON. */
	// VIN_ON COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_ON] = PMBUS_HANDLE_VIN_ON;
	//PMBUS_CMD_VIN_ON.OPCODE = PMBUS_CMDCODE_VIN_ON;
	//PMBUS_CMD_VIN_ON.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VIN_ON.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VIN_ON.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VIN_ON.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VIN_ON.SUPPORTED = 1;
	//PMBUS_CMD_VIN_ON.PROTECTED0 = 0;
	//PMBUS_CMD_VIN_ON.PROTECTED1 = 0;
	//PMBUS_CMD_VIN_ON.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_VIN_ON.RANGE = &PMBUS_CMD_VIN_ON_RANGE[0];
	PMBUS_CMD_VIN_ON_RANGE[0] = 6;
	PMBUS_CMD_VIN_ON_RANGE[1] = 2;
	PMBUS_CMD_VIN_ON.CMD_CONFIG = 0xc3822335;
	PMBUS_CMD_VIN_ON.DATA0 = &PMBUS_CMD_VIN_ON_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VIN_ON.DATA1 = &PMBUS_CMD_VIN_ON_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VIN_ON COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VIN_ON] = &PMBUS_CMD_VIN_ON;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_ON] = &PMBUS_CMD_VIN_ON;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VIN_ON/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_ON&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_ON/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_ON&31u));

	/* initialize command structure for VIN_OFF. */
	// VIN_OFF COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_OFF] = PMBUS_HANDLE_VIN_ON;
	//PMBUS_CMD_VIN_OFF.OPCODE = PMBUS_CMDCODE_VIN_OFF;
	//PMBUS_CMD_VIN_OFF.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VIN_OFF.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VIN_OFF.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VIN_OFF.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VIN_OFF.SUPPORTED = 1;
	//PMBUS_CMD_VIN_OFF.PROTECTED0 = 0;
	//PMBUS_CMD_VIN_OFF.PROTECTED1 = 0;
	//PMBUS_CMD_VIN_OFF.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_VIN_OFF.RANGE = &PMBUS_CMD_VIN_OFF_RANGE[0];
	PMBUS_CMD_VIN_OFF_RANGE[0] = 6;
	PMBUS_CMD_VIN_OFF_RANGE[1] = 2;
	PMBUS_CMD_VIN_OFF.CMD_CONFIG = 0xc3822336;
	PMBUS_CMD_VIN_OFF.DATA0 = &PMBUS_CMD_VIN_OFF_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VIN_OFF.DATA1 = &PMBUS_CMD_VIN_OFF_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VIN_OFF COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VIN_OFF] = &PMBUS_CMD_VIN_OFF;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_OFF] = &PMBUS_CMD_VIN_OFF;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VIN_OFF/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_OFF&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_OFF/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_OFF&31u));

	/* initialize command structure for INTERLEAVE. */
	// INTERLEAVE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_INTERLEAVE] = PMBUS_HANDLE_INTERLEAVE;
	//PMBUS_CMD_INTERLEAVE.OPCODE = PMBUS_CMDCODE_INTERLEAVE;
	//PMBUS_CMD_INTERLEAVE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_INTERLEAVE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_INTERLEAVE.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_INTERLEAVE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_INTERLEAVE.SUPPORTED = 1;
	//PMBUS_CMD_INTERLEAVE.PROTECTED0 = 0;
	//PMBUS_CMD_INTERLEAVE.PROTECTED1 = 0;
	//PMBUS_CMD_INTERLEAVE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_BYTE_MASKS;
	PMBUS_CMD_INTERLEAVE.RANGE = &PMBUS_CMD_INTERLEAVE_RANGE[0];
	PMBUS_CMD_INTERLEAVE_RANGE[0] = 0xFF;
	PMBUS_CMD_INTERLEAVE_RANGE[1] = 0x0F;
	PMBUS_CMD_INTERLEAVE.CMD_CONFIG = 0xcc822337;
	PMBUS_CMD_INTERLEAVE.DATA0 = &PMBUS_CMD_INTERLEAVE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_INTERLEAVE.DATA1 = &PMBUS_CMD_INTERLEAVE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for INTERLEAVE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_INTERLEAVE] = &PMBUS_CMD_INTERLEAVE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_INTERLEAVE] = &PMBUS_CMD_INTERLEAVE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_INTERLEAVE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_INTERLEAVE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_INTERLEAVE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_INTERLEAVE&31u));

	/* initialize command structure for IOUT_CAL_OFFSET. */
	// IOUT_CAL_OFFSET COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IOUT_CAL_OFFSET] = PMBUS_HANDLE_IOUT_CAL_OFFSET;
	//PMBUS_CMD_IOUT_CAL_OFFSET.OPCODE = PMBUS_CMDCODE_IOUT_CAL_OFFSET;
	//PMBUS_CMD_IOUT_CAL_OFFSET.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_IOUT_CAL_OFFSET.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_IOUT_CAL_OFFSET.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_IOUT_CAL_OFFSET.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IOUT_CAL_OFFSET.SUPPORTED = 1;
	//PMBUS_CMD_IOUT_CAL_OFFSET.PROTECTED0 = 0;
	//PMBUS_CMD_IOUT_CAL_OFFSET.PROTECTED1 = 0;
	//PMBUS_CMD_IOUT_CAL_OFFSET.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_SIGNED;
	PMBUS_CMD_IOUT_CAL_OFFSET.RANGE = &PMBUS_CMD_IOUT_CAL_OFFSET_RANGE[0];
	PMBUS_CMD_IOUT_CAL_OFFSET_RANGE[0] = 5;
	PMBUS_CMD_IOUT_CAL_OFFSET_RANGE[1] = 3;
	PMBUS_CMD_IOUT_CAL_OFFSET.CMD_CONFIG = 0xc2822339;
	PMBUS_CMD_IOUT_CAL_OFFSET.DATA0 = &PMBUS_CMD_IOUT_CAL_OFFSET_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IOUT_CAL_OFFSET.DATA1 = &PMBUS_CMD_IOUT_CAL_OFFSET_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for IOUT_CAL_OFFSET COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_CAL_OFFSET] = &PMBUS_CMD_IOUT_CAL_OFFSET;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_CAL_OFFSET] = &PMBUS_CMD_IOUT_CAL_OFFSET;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_CAL_OFFSET/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_CAL_OFFSET&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_CAL_OFFSET/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_CAL_OFFSET&31u));

	/* initialize command structure for VOUT_OV_FAULT_LIMIT. */
	// VOUT_OV_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_OV_FAULT_LIMIT] = PMBUS_HANDLE_VOUT_OV_FAULT_LIMIT;
	//PMBUS_CMD_VOUT_OV_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_VOUT_OV_FAULT_LIMIT;
	//PMBUS_CMD_VOUT_OV_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_OV_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_OV_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_OV_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_OV_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_OV_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_OV_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_OV_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_OV_FAULT_LIMIT.RANGE = &PMBUS_CMD_VOUT_OV_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_VOUT_OV_FAULT_LIMIT.CMD_CONFIG = 0xc8822340;
	PMBUS_CMD_VOUT_OV_FAULT_LIMIT.DATA0 = &PMBUS_CMD_VOUT_OV_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_OV_FAULT_LIMIT.DATA1 = &PMBUS_CMD_VOUT_OV_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_OV_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_OV_FAULT_LIMIT] = &PMBUS_CMD_VOUT_OV_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_OV_FAULT_LIMIT] = &PMBUS_CMD_VOUT_OV_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_OV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_OV_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_OV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_OV_FAULT_LIMIT&31u));

	/* initialize command structure for VOUT_OV_FAULT_RESPONSE. */
	// VOUT_OV_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_OV_FAULT_RESPONSE] = PMBUS_HANDLE_VOUT_OV_FAULT_LIMIT;
	//PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_VOUT_OV_FAULT_RESPONSE;
	//PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.CMD_CONFIG = 0xc1812341;
	PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_VOUT_OV_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_OV_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_VOUT_OV_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_OV_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_OV_FAULT_RESPONSE] = &PMBUS_CMD_VOUT_OV_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_OV_FAULT_RESPONSE] = &PMBUS_CMD_VOUT_OV_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_OV_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_OV_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_OV_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_OV_FAULT_RESPONSE&31u));

	/* initialize command structure for VOUT_OV_WARN_LIMIT. */
	// VOUT_OV_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_OV_WARN_LIMIT] = PMBUS_HANDLE_VOUT_OV_WARN_LIMIT;
	//PMBUS_CMD_VOUT_OV_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_VOUT_OV_WARN_LIMIT;
	//PMBUS_CMD_VOUT_OV_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_OV_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_OV_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_OV_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_OV_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_OV_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_OV_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_OV_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_OV_WARN_LIMIT.RANGE = &PMBUS_CMD_VOUT_OV_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_VOUT_OV_WARN_LIMIT.CMD_CONFIG = 0xc8822342;
	PMBUS_CMD_VOUT_OV_WARN_LIMIT.DATA0 = &PMBUS_CMD_VOUT_OV_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_OV_WARN_LIMIT.DATA1 = &PMBUS_CMD_VOUT_OV_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_OV_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_OV_WARN_LIMIT] = &PMBUS_CMD_VOUT_OV_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_OV_WARN_LIMIT] = &PMBUS_CMD_VOUT_OV_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_OV_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_OV_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_OV_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_OV_WARN_LIMIT&31u));

	/* initialize command structure for VOUT_UV_WARN_LIMIT. */
	// VOUT_UV_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT] = PMBUS_HANDLE_VOUT_UV_WARN_LIMIT;
	//PMBUS_CMD_VOUT_UV_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT;
	//PMBUS_CMD_VOUT_UV_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_UV_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_UV_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_UV_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_UV_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_UV_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_UV_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_UV_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_UV_WARN_LIMIT.RANGE = &PMBUS_CMD_VOUT_UV_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_VOUT_UV_WARN_LIMIT.CMD_CONFIG = 0xc8822343;
	PMBUS_CMD_VOUT_UV_WARN_LIMIT.DATA0 = &PMBUS_CMD_VOUT_UV_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_UV_WARN_LIMIT.DATA1 = &PMBUS_CMD_VOUT_UV_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_UV_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT] = &PMBUS_CMD_VOUT_UV_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT] = &PMBUS_CMD_VOUT_UV_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_UV_WARN_LIMIT&31u));

	/* initialize command structure for VOUT_UV_FAULT_LIMIT. */
	// VOUT_UV_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT] = PMBUS_HANDLE_VOUT_UV_FAULT_LIMIT;
	//PMBUS_CMD_VOUT_UV_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT;
	//PMBUS_CMD_VOUT_UV_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_UV_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_UV_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VOUT_UV_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_UV_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_UV_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_UV_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_UV_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_VOUT_UV_FAULT_LIMIT.RANGE = &PMBUS_CMD_VOUT_UV_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_VOUT_UV_FAULT_LIMIT.CMD_CONFIG = 0xc8822344;
	PMBUS_CMD_VOUT_UV_FAULT_LIMIT.DATA0 = &PMBUS_CMD_VOUT_UV_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_UV_FAULT_LIMIT.DATA1 = &PMBUS_CMD_VOUT_UV_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_UV_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT] = &PMBUS_CMD_VOUT_UV_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT] = &PMBUS_CMD_VOUT_UV_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_UV_FAULT_LIMIT&31u));

	/* initialize command structure for VOUT_UV_FAULT_RESPONSE. */
	// VOUT_UV_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VOUT_UV_FAULT_RESPONSE] = PMBUS_HANDLE_VOUT_UV_FAULT_LIMIT;
	//PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_VOUT_UV_FAULT_RESPONSE;
	//PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.CMD_CONFIG = 0xc1812345;
	PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_VOUT_UV_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VOUT_UV_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_VOUT_UV_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VOUT_UV_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_UV_FAULT_RESPONSE] = &PMBUS_CMD_VOUT_UV_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_UV_FAULT_RESPONSE] = &PMBUS_CMD_VOUT_UV_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VOUT_UV_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_UV_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VOUT_UV_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VOUT_UV_FAULT_RESPONSE&31u));

	/* initialize command structure for IOUT_OC_FAULT_LIMIT. */
	// IOUT_OC_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IOUT_OC_FAULT_LIMIT] = PMBUS_HANDLE_IOUT_OC_FAULT_LIMIT;
	//PMBUS_CMD_IOUT_OC_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_IOUT_OC_FAULT_LIMIT;
	//PMBUS_CMD_IOUT_OC_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_IOUT_OC_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_IOUT_OC_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_IOUT_OC_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IOUT_OC_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_IOUT_OC_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_IOUT_OC_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_IOUT_OC_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_IOUT_OC_FAULT_LIMIT.RANGE = &PMBUS_CMD_IOUT_OC_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_IOUT_OC_FAULT_LIMIT_RANGE[0] = 8;
	PMBUS_CMD_IOUT_OC_FAULT_LIMIT_RANGE[1] = 0;
	PMBUS_CMD_IOUT_OC_FAULT_LIMIT.CMD_CONFIG = 0xc3822346;
	PMBUS_CMD_IOUT_OC_FAULT_LIMIT.DATA0 = &PMBUS_CMD_IOUT_OC_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IOUT_OC_FAULT_LIMIT.DATA1 = &PMBUS_CMD_IOUT_OC_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for IOUT_OC_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_OC_FAULT_LIMIT] = &PMBUS_CMD_IOUT_OC_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_OC_FAULT_LIMIT] = &PMBUS_CMD_IOUT_OC_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_OC_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_OC_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_OC_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_OC_FAULT_LIMIT&31u));

	/* initialize command structure for IOUT_OC_FAULT_RESPONSE. */
	// IOUT_OC_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IOUT_OC_FAULT_RESPONSE] = PMBUS_HANDLE_IOUT_OC_FAULT_RESPONSE;
	//PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_IOUT_OC_FAULT_RESPONSE;
	//PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.CMD_CONFIG = 0xc1812347;
	PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_IOUT_OC_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IOUT_OC_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_IOUT_OC_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for IOUT_OC_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_OC_FAULT_RESPONSE] = &PMBUS_CMD_IOUT_OC_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_OC_FAULT_RESPONSE] = &PMBUS_CMD_IOUT_OC_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_OC_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_OC_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_OC_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_OC_FAULT_RESPONSE&31u));

	/* initialize command structure for IOUT_OC_LV_FAULT_LIMIT. */
	// IOUT_OC_LV_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IOUT_OC_LV_FAULT_LIMIT] = PMBUS_HANDLE_IOUT_OC_LV_FAULT_LIMIT;
	//PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_IOUT_OC_LV_FAULT_LIMIT;
	//PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.RANGE = &PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.CMD_CONFIG = 0xc8822348;
	PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.DATA0 = &PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT.DATA1 = &PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for IOUT_OC_LV_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_OC_LV_FAULT_LIMIT] = &PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_OC_LV_FAULT_LIMIT] = &PMBUS_CMD_IOUT_OC_LV_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_OC_LV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_OC_LV_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_OC_LV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_OC_LV_FAULT_LIMIT&31u));

	/* initialize command structure for IOUT_OC_WARN_LIMIT. */
	// IOUT_OC_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IOUT_OC_WARN_LIMIT] = PMBUS_HANDLE_IOUT_OC_WARN_LIMIT;
	//PMBUS_CMD_IOUT_OC_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_IOUT_OC_WARN_LIMIT;
	//PMBUS_CMD_IOUT_OC_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_IOUT_OC_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_IOUT_OC_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_IOUT_OC_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IOUT_OC_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_IOUT_OC_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_IOUT_OC_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_IOUT_OC_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_IOUT_OC_WARN_LIMIT.RANGE = &PMBUS_CMD_IOUT_OC_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_IOUT_OC_WARN_LIMIT_RANGE[0] = 8;
	PMBUS_CMD_IOUT_OC_WARN_LIMIT_RANGE[1] = 0;
	PMBUS_CMD_IOUT_OC_WARN_LIMIT.CMD_CONFIG = 0xc382234a;
	PMBUS_CMD_IOUT_OC_WARN_LIMIT.DATA0 = &PMBUS_CMD_IOUT_OC_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IOUT_OC_WARN_LIMIT.DATA1 = &PMBUS_CMD_IOUT_OC_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for IOUT_OC_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_OC_WARN_LIMIT] = &PMBUS_CMD_IOUT_OC_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_OC_WARN_LIMIT] = &PMBUS_CMD_IOUT_OC_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_OC_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_OC_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_OC_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_OC_WARN_LIMIT&31u));

	/* initialize command structure for IOUT_UC_FAULT_LIMIT. */
	// IOUT_UC_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IOUT_UC_FAULT_LIMIT] = PMBUS_HANDLE_IOUT_UC_FAULT_LIMIT;
	//PMBUS_CMD_IOUT_UC_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_IOUT_UC_FAULT_LIMIT;
	//PMBUS_CMD_IOUT_UC_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_IOUT_UC_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_IOUT_UC_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_IOUT_UC_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IOUT_UC_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_IOUT_UC_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_IOUT_UC_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_IOUT_UC_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_SIGNED;
	PMBUS_CMD_IOUT_UC_FAULT_LIMIT.RANGE = &PMBUS_CMD_IOUT_UC_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_IOUT_UC_FAULT_LIMIT_RANGE[0] = 8;
	PMBUS_CMD_IOUT_UC_FAULT_LIMIT_RANGE[1] = 0;
	PMBUS_CMD_IOUT_UC_FAULT_LIMIT.CMD_CONFIG = 0xc282234b;
	PMBUS_CMD_IOUT_UC_FAULT_LIMIT.DATA0 = &PMBUS_CMD_IOUT_UC_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IOUT_UC_FAULT_LIMIT.DATA1 = &PMBUS_CMD_IOUT_UC_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for IOUT_UC_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_UC_FAULT_LIMIT] = &PMBUS_CMD_IOUT_UC_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_UC_FAULT_LIMIT] = &PMBUS_CMD_IOUT_UC_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_UC_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_UC_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_UC_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_UC_FAULT_LIMIT&31u));

	/* initialize command structure for IOUT_UC_FAULT_RESPONSE. */
	// IOUT_UC_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IOUT_UC_FAULT_RESPONSE] = PMBUS_HANDLE_IOUT_UC_FAULT_LIMIT;
	//PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_IOUT_UC_FAULT_RESPONSE;
	//PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.CMD_CONFIG = 0xc181234c;
	PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_IOUT_UC_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IOUT_UC_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_IOUT_UC_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for IOUT_UC_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_UC_FAULT_RESPONSE] = &PMBUS_CMD_IOUT_UC_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_UC_FAULT_RESPONSE] = &PMBUS_CMD_IOUT_UC_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IOUT_UC_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_UC_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IOUT_UC_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IOUT_UC_FAULT_RESPONSE&31u));

	/* initialize command structure for OT_FAULT_LIMIT. */
	// OT_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_OT_FAULT_LIMIT] = PMBUS_HANDLE_OT_FAULT_LIMIT;
	//PMBUS_CMD_OT_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_OT_FAULT_LIMIT;
	//PMBUS_CMD_OT_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_OT_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_OT_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_OT_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_OT_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_OT_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_OT_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_OT_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_OT_FAULT_LIMIT.RANGE = &PMBUS_CMD_OT_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_OT_FAULT_LIMIT_RANGE[0] = 8;
	PMBUS_CMD_OT_FAULT_LIMIT_RANGE[1] = 0;
	PMBUS_CMD_OT_FAULT_LIMIT.CMD_CONFIG = 0xc382234f;
	PMBUS_CMD_OT_FAULT_LIMIT.DATA0 = &PMBUS_CMD_OT_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_OT_FAULT_LIMIT.DATA1 = &PMBUS_CMD_OT_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for OT_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_OT_FAULT_LIMIT] = &PMBUS_CMD_OT_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_OT_FAULT_LIMIT] = &PMBUS_CMD_OT_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_OT_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_OT_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_OT_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_OT_FAULT_LIMIT&31u));

	/* initialize command structure for OT_FAULT_RESPONSE. */
	// OT_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_OT_FAULT_RESPONSE] = PMBUS_HANDLE_OT_FAULT_LIMIT;
	//PMBUS_CMD_OT_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_OT_FAULT_RESPONSE;
	//PMBUS_CMD_OT_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_OT_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_OT_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_OT_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_OT_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_OT_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_OT_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_OT_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_OT_FAULT_RESPONSE.CMD_CONFIG = 0xc1812350;
	PMBUS_CMD_OT_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_OT_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_OT_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_OT_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for OT_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_OT_FAULT_RESPONSE] = &PMBUS_CMD_OT_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_OT_FAULT_RESPONSE] = &PMBUS_CMD_OT_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_OT_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_OT_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_OT_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_OT_FAULT_RESPONSE&31u));

	/* initialize command structure for OT_WARN_LIMIT. */
	// OT_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_OT_WARN_LIMIT] = PMBUS_HANDLE_OT_WARN_LIMIT;
	//PMBUS_CMD_OT_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_OT_WARN_LIMIT;
	//PMBUS_CMD_OT_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_OT_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_OT_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_OT_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_OT_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_OT_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_OT_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_OT_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_OT_WARN_LIMIT.RANGE = &PMBUS_CMD_OT_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_OT_WARN_LIMIT_RANGE[0] = 8;
	PMBUS_CMD_OT_WARN_LIMIT_RANGE[1] = 0;
	PMBUS_CMD_OT_WARN_LIMIT.CMD_CONFIG = 0xc3822351;
	PMBUS_CMD_OT_WARN_LIMIT.DATA0 = &PMBUS_CMD_OT_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_OT_WARN_LIMIT.DATA1 = &PMBUS_CMD_OT_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for OT_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_OT_WARN_LIMIT] = &PMBUS_CMD_OT_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_OT_WARN_LIMIT] = &PMBUS_CMD_OT_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_OT_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_OT_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_OT_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_OT_WARN_LIMIT&31u));

	/* initialize command structure for UT_WARN_LIMIT. */
	// UT_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_UT_WARN_LIMIT] = PMBUS_HANDLE_UT_WARN_LIMIT;
	//PMBUS_CMD_UT_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_UT_WARN_LIMIT;
	//PMBUS_CMD_UT_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_UT_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_UT_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_UT_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_UT_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_UT_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_UT_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_UT_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_SIGNED;
	PMBUS_CMD_UT_WARN_LIMIT.RANGE = &PMBUS_CMD_UT_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_UT_WARN_LIMIT_RANGE[0] = 9;
	PMBUS_CMD_UT_WARN_LIMIT_RANGE[1] = 31;
	PMBUS_CMD_UT_WARN_LIMIT.CMD_CONFIG = 0xc2822352;
	PMBUS_CMD_UT_WARN_LIMIT.DATA0 = &PMBUS_CMD_UT_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_UT_WARN_LIMIT.DATA1 = &PMBUS_CMD_UT_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for UT_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_UT_WARN_LIMIT] = &PMBUS_CMD_UT_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_UT_WARN_LIMIT] = &PMBUS_CMD_UT_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_UT_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_UT_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_UT_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_UT_WARN_LIMIT&31u));

	/* initialize command structure for UT_FAULT_LIMIT. */
	// UT_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_UT_FAULT_LIMIT] = PMBUS_HANDLE_UT_FAULT_LIMIT;
	//PMBUS_CMD_UT_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_UT_FAULT_LIMIT;
	//PMBUS_CMD_UT_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_UT_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_UT_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_UT_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_UT_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_UT_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_UT_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_UT_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_SIGNED;
	PMBUS_CMD_UT_FAULT_LIMIT.RANGE = &PMBUS_CMD_UT_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_UT_FAULT_LIMIT_RANGE[0] = 9;
	PMBUS_CMD_UT_FAULT_LIMIT_RANGE[1] = 31;
	PMBUS_CMD_UT_FAULT_LIMIT.CMD_CONFIG = 0xc2822353;
	PMBUS_CMD_UT_FAULT_LIMIT.DATA0 = &PMBUS_CMD_UT_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_UT_FAULT_LIMIT.DATA1 = &PMBUS_CMD_UT_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for UT_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_UT_FAULT_LIMIT] = &PMBUS_CMD_UT_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_UT_FAULT_LIMIT] = &PMBUS_CMD_UT_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_UT_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_UT_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_UT_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_UT_FAULT_LIMIT&31u));

	/* initialize command structure for UT_FAULT_RESPONSE. */
	// UT_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_UT_FAULT_RESPONSE] = PMBUS_HANDLE_UT_FAULT_LIMIT;
	//PMBUS_CMD_UT_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_UT_FAULT_RESPONSE;
	//PMBUS_CMD_UT_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_UT_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_UT_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_UT_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_UT_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_UT_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_UT_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_UT_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_UT_FAULT_RESPONSE.CMD_CONFIG = 0xc1812354;
	PMBUS_CMD_UT_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_UT_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_UT_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_UT_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for UT_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_UT_FAULT_RESPONSE] = &PMBUS_CMD_UT_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_UT_FAULT_RESPONSE] = &PMBUS_CMD_UT_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_UT_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_UT_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_UT_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_UT_FAULT_RESPONSE&31u));

	/* initialize command structure for VIN_OV_FAULT_LIMIT. */
	// VIN_OV_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_OV_FAULT_LIMIT] = PMBUS_HANDLE_VIN_OV_FAULT_LIMIT;
	//PMBUS_CMD_VIN_OV_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_VIN_OV_FAULT_LIMIT;
	//PMBUS_CMD_VIN_OV_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VIN_OV_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VIN_OV_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VIN_OV_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VIN_OV_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_VIN_OV_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_VIN_OV_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_VIN_OV_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_VIN_OV_FAULT_LIMIT.RANGE = &PMBUS_CMD_VIN_OV_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_VIN_OV_FAULT_LIMIT_RANGE[0] = 7;
	PMBUS_CMD_VIN_OV_FAULT_LIMIT_RANGE[1] = 2;
	PMBUS_CMD_VIN_OV_FAULT_LIMIT.CMD_CONFIG = 0xc3822355;
	PMBUS_CMD_VIN_OV_FAULT_LIMIT.DATA0 = &PMBUS_CMD_VIN_OV_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VIN_OV_FAULT_LIMIT.DATA1 = &PMBUS_CMD_VIN_OV_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VIN_OV_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VIN_OV_FAULT_LIMIT] = &PMBUS_CMD_VIN_OV_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_OV_FAULT_LIMIT] = &PMBUS_CMD_VIN_OV_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VIN_OV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_OV_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_OV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_OV_FAULT_LIMIT&31u));

	/* initialize command structure for VIN_OV_FAULT_RESPONSE. */
	// VIN_OV_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_OV_FAULT_RESPONSE] = PMBUS_HANDLE_VIN_OV_FAULT_LIMIT;
	//PMBUS_CMD_VIN_OV_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_VIN_OV_FAULT_RESPONSE;
	//PMBUS_CMD_VIN_OV_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VIN_OV_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VIN_OV_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_VIN_OV_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VIN_OV_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_VIN_OV_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_VIN_OV_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_VIN_OV_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_VIN_OV_FAULT_RESPONSE.CMD_CONFIG = 0xc1812356;
	PMBUS_CMD_VIN_OV_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_VIN_OV_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VIN_OV_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_VIN_OV_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VIN_OV_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VIN_OV_FAULT_RESPONSE] = &PMBUS_CMD_VIN_OV_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_OV_FAULT_RESPONSE] = &PMBUS_CMD_VIN_OV_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VIN_OV_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_OV_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_OV_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_OV_FAULT_RESPONSE&31u));

	/* initialize command structure for VIN_OV_WARN_LIMIT. */
	// VIN_OV_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_OV_WARN_LIMIT] = PMBUS_HANDLE_VIN_OV_WARN_LIMIT;
	//PMBUS_CMD_VIN_OV_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_VIN_OV_WARN_LIMIT;
	//PMBUS_CMD_VIN_OV_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VIN_OV_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VIN_OV_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VIN_OV_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VIN_OV_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_VIN_OV_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_VIN_OV_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_VIN_OV_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_VIN_OV_WARN_LIMIT.RANGE = &PMBUS_CMD_VIN_OV_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_VIN_OV_WARN_LIMIT_RANGE[0] = 7;
	PMBUS_CMD_VIN_OV_WARN_LIMIT_RANGE[1] = 2;
	PMBUS_CMD_VIN_OV_WARN_LIMIT.CMD_CONFIG = 0xc3822357;
	PMBUS_CMD_VIN_OV_WARN_LIMIT.DATA0 = &PMBUS_CMD_VIN_OV_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VIN_OV_WARN_LIMIT.DATA1 = &PMBUS_CMD_VIN_OV_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VIN_OV_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VIN_OV_WARN_LIMIT] = &PMBUS_CMD_VIN_OV_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_OV_WARN_LIMIT] = &PMBUS_CMD_VIN_OV_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VIN_OV_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_OV_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_OV_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_OV_WARN_LIMIT&31u));

	/* initialize command structure for VIN_UV_WARN_LIMIT. */
	// VIN_UV_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_UV_WARN_LIMIT] = PMBUS_HANDLE_VIN_UV_WARN_LIMIT;
	//PMBUS_CMD_VIN_UV_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_VIN_UV_WARN_LIMIT;
	//PMBUS_CMD_VIN_UV_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VIN_UV_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VIN_UV_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VIN_UV_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VIN_UV_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_VIN_UV_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_VIN_UV_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_VIN_UV_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_VIN_UV_WARN_LIMIT.RANGE = &PMBUS_CMD_VIN_UV_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_VIN_UV_WARN_LIMIT_RANGE[0] = 6;
	PMBUS_CMD_VIN_UV_WARN_LIMIT_RANGE[1] = 2;
	PMBUS_CMD_VIN_UV_WARN_LIMIT.CMD_CONFIG = 0xc3822358;
	PMBUS_CMD_VIN_UV_WARN_LIMIT.DATA0 = &PMBUS_CMD_VIN_UV_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VIN_UV_WARN_LIMIT.DATA1 = &PMBUS_CMD_VIN_UV_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VIN_UV_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VIN_UV_WARN_LIMIT] = &PMBUS_CMD_VIN_UV_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_UV_WARN_LIMIT] = &PMBUS_CMD_VIN_UV_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VIN_UV_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_UV_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_UV_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_UV_WARN_LIMIT&31u));

	/* initialize command structure for VIN_UV_FAULT_LIMIT. */
	// VIN_UV_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT] = PMBUS_HANDLE_VIN_UV_FAULT_LIMIT;
	//PMBUS_CMD_VIN_UV_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT;
	//PMBUS_CMD_VIN_UV_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VIN_UV_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VIN_UV_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_VIN_UV_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VIN_UV_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_VIN_UV_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_VIN_UV_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_VIN_UV_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_VIN_UV_FAULT_LIMIT.RANGE = &PMBUS_CMD_VIN_UV_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_VIN_UV_FAULT_LIMIT_RANGE[0] = 6;
	PMBUS_CMD_VIN_UV_FAULT_LIMIT_RANGE[1] = 2;
	PMBUS_CMD_VIN_UV_FAULT_LIMIT.CMD_CONFIG = 0xc3822359;
	PMBUS_CMD_VIN_UV_FAULT_LIMIT.DATA0 = &PMBUS_CMD_VIN_UV_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VIN_UV_FAULT_LIMIT.DATA1 = &PMBUS_CMD_VIN_UV_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VIN_UV_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT] = &PMBUS_CMD_VIN_UV_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT] = &PMBUS_CMD_VIN_UV_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_UV_FAULT_LIMIT&31u));

	/* initialize command structure for VIN_UV_FAULT_RESPONSE. */
	// VIN_UV_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_VIN_UV_FAULT_RESPONSE] = PMBUS_HANDLE_VIN_UV_FAULT_LIMIT;
	//PMBUS_CMD_VIN_UV_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_VIN_UV_FAULT_RESPONSE;
	//PMBUS_CMD_VIN_UV_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_VIN_UV_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_VIN_UV_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_VIN_UV_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_VIN_UV_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_VIN_UV_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_VIN_UV_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_VIN_UV_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_VIN_UV_FAULT_RESPONSE.CMD_CONFIG = 0xc181235a;
	PMBUS_CMD_VIN_UV_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_VIN_UV_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_VIN_UV_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_VIN_UV_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for VIN_UV_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_VIN_UV_FAULT_RESPONSE] = &PMBUS_CMD_VIN_UV_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_UV_FAULT_RESPONSE] = &PMBUS_CMD_VIN_UV_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_VIN_UV_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_UV_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_VIN_UV_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_VIN_UV_FAULT_RESPONSE&31u));

	/* initialize command structure for IIN_OC_FAULT_LIMIT. */
	// IIN_OC_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IIN_OC_FAULT_LIMIT] = PMBUS_HANDLE_IIN_OC_FAULT_LIMIT;
	//PMBUS_CMD_IIN_OC_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_IIN_OC_FAULT_LIMIT;
	//PMBUS_CMD_IIN_OC_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_IIN_OC_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_IIN_OC_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_IIN_OC_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IIN_OC_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_IIN_OC_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_IIN_OC_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_IIN_OC_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_IIN_OC_FAULT_LIMIT.RANGE = &PMBUS_CMD_IIN_OC_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_IIN_OC_FAULT_LIMIT_RANGE[0] = 7;
	PMBUS_CMD_IIN_OC_FAULT_LIMIT_RANGE[1] = 0;
	PMBUS_CMD_IIN_OC_FAULT_LIMIT.CMD_CONFIG = 0xc382235b;
	PMBUS_CMD_IIN_OC_FAULT_LIMIT.DATA0 = &PMBUS_CMD_IIN_OC_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IIN_OC_FAULT_LIMIT.DATA1 = &PMBUS_CMD_IIN_OC_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for IIN_OC_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IIN_OC_FAULT_LIMIT] = &PMBUS_CMD_IIN_OC_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IIN_OC_FAULT_LIMIT] = &PMBUS_CMD_IIN_OC_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IIN_OC_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IIN_OC_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IIN_OC_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IIN_OC_FAULT_LIMIT&31u));

	/* initialize command structure for IIN_OC_FAULT_RESPONSE. */
	// IIN_OC_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IIN_OC_FAULT_RESPONSE] = PMBUS_HANDLE_IIN_OC_FAULT_LIMIT;
	//PMBUS_CMD_IIN_OC_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_IIN_OC_FAULT_RESPONSE;
	//PMBUS_CMD_IIN_OC_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_IIN_OC_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_IIN_OC_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_IIN_OC_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IIN_OC_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_IIN_OC_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_IIN_OC_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_IIN_OC_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_IIN_OC_FAULT_RESPONSE.CMD_CONFIG = 0xc181235c;
	PMBUS_CMD_IIN_OC_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_IIN_OC_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IIN_OC_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_IIN_OC_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for IIN_OC_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IIN_OC_FAULT_RESPONSE] = &PMBUS_CMD_IIN_OC_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IIN_OC_FAULT_RESPONSE] = &PMBUS_CMD_IIN_OC_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IIN_OC_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IIN_OC_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IIN_OC_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IIN_OC_FAULT_RESPONSE&31u));

	/* initialize command structure for IIN_OC_WARN_LIMIT. */
	// IIN_OC_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IIN_OC_WARN_LIMIT] = PMBUS_HANDLE_IIN_OC_WARN_LIMIT;
	//PMBUS_CMD_IIN_OC_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_IIN_OC_WARN_LIMIT;
	//PMBUS_CMD_IIN_OC_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_IIN_OC_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_IIN_OC_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_IIN_OC_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IIN_OC_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_IIN_OC_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_IIN_OC_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_IIN_OC_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_IIN_OC_WARN_LIMIT.RANGE = &PMBUS_CMD_IIN_OC_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_IIN_OC_WARN_LIMIT_RANGE[0] = 7;
	PMBUS_CMD_IIN_OC_WARN_LIMIT_RANGE[1] = 0;
	PMBUS_CMD_IIN_OC_WARN_LIMIT.CMD_CONFIG = 0xc382235d;
	PMBUS_CMD_IIN_OC_WARN_LIMIT.DATA0 = &PMBUS_CMD_IIN_OC_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IIN_OC_WARN_LIMIT.DATA1 = &PMBUS_CMD_IIN_OC_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for IIN_OC_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IIN_OC_WARN_LIMIT] = &PMBUS_CMD_IIN_OC_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IIN_OC_WARN_LIMIT] = &PMBUS_CMD_IIN_OC_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IIN_OC_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IIN_OC_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IIN_OC_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IIN_OC_WARN_LIMIT&31u));

	/* initialize command structure for POWER_GOOD_ON. */
	// POWER_GOOD_ON COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_POWER_GOOD_ON] = PMBUS_HANDLE_POWER_GOOD_ON;
	//PMBUS_CMD_POWER_GOOD_ON.OPCODE = PMBUS_CMDCODE_POWER_GOOD_ON;
	//PMBUS_CMD_POWER_GOOD_ON.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_POWER_GOOD_ON.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_POWER_GOOD_ON.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_POWER_GOOD_ON.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_POWER_GOOD_ON.SUPPORTED = 1;
	//PMBUS_CMD_POWER_GOOD_ON.PROTECTED0 = 0;
	//PMBUS_CMD_POWER_GOOD_ON.PROTECTED1 = 0;
	//PMBUS_CMD_POWER_GOOD_ON.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_POWER_GOOD_ON.RANGE = &PMBUS_CMD_POWER_GOOD_ON_RANGE[0];
	PMBUS_CMD_POWER_GOOD_ON.CMD_CONFIG = 0xc882235e;
	PMBUS_CMD_POWER_GOOD_ON.DATA0 = &PMBUS_CMD_POWER_GOOD_ON_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_POWER_GOOD_ON.DATA1 = &PMBUS_CMD_POWER_GOOD_ON_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for POWER_GOOD_ON COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_POWER_GOOD_ON] = &PMBUS_CMD_POWER_GOOD_ON;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_POWER_GOOD_ON] = &PMBUS_CMD_POWER_GOOD_ON;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_POWER_GOOD_ON/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_POWER_GOOD_ON&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_POWER_GOOD_ON/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_POWER_GOOD_ON&31u));

	/* initialize command structure for POWER_GOOD_OFF. */
	// POWER_GOOD_OFF COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_POWER_GOOD_OFF] = PMBUS_HANDLE_POWER_GOOD_ON;
	//PMBUS_CMD_POWER_GOOD_OFF.OPCODE = PMBUS_CMDCODE_POWER_GOOD_OFF;
	//PMBUS_CMD_POWER_GOOD_OFF.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_POWER_GOOD_OFF.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_POWER_GOOD_OFF.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_POWER_GOOD_OFF.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_POWER_GOOD_OFF.SUPPORTED = 1;
	//PMBUS_CMD_POWER_GOOD_OFF.PROTECTED0 = 0;
	//PMBUS_CMD_POWER_GOOD_OFF.PROTECTED1 = 0;
	//PMBUS_CMD_POWER_GOOD_OFF.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_POWER_GOOD_OFF.RANGE = &PMBUS_CMD_POWER_GOOD_OFF_RANGE[0];
	PMBUS_CMD_POWER_GOOD_OFF.CMD_CONFIG = 0xc882235f;
	PMBUS_CMD_POWER_GOOD_OFF.DATA0 = &PMBUS_CMD_POWER_GOOD_OFF_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_POWER_GOOD_OFF.DATA1 = &PMBUS_CMD_POWER_GOOD_OFF_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for POWER_GOOD_OFF COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_POWER_GOOD_OFF] = &PMBUS_CMD_POWER_GOOD_OFF;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_POWER_GOOD_OFF] = &PMBUS_CMD_POWER_GOOD_OFF;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_POWER_GOOD_OFF/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_POWER_GOOD_OFF&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_POWER_GOOD_OFF/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_POWER_GOOD_OFF&31u));

	/* initialize command structure for TON_DELAY. */
	// TON_DELAY COMMAND:
	//PMBUS_CMD_TON_DELAY.OPCODE = PMBUS_CMDCODE_TON_DELAY;
	//PMBUS_CMD_TON_DELAY.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_TON_DELAY.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_TON_DELAY.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_TON_DELAY.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_TON_DELAY.SUPPORTED = 1;
	//PMBUS_CMD_TON_DELAY.PROTECTED0 = 0;
	//PMBUS_CMD_TON_DELAY.PROTECTED1 = 0;
	//PMBUS_CMD_TON_DELAY.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_TON_DELAY.RANGE = &PMBUS_CMD_TON_DELAY_RANGE[0];
	PMBUS_CMD_TON_DELAY_RANGE[0] = 7;
	PMBUS_CMD_TON_DELAY_RANGE[1] = 1;
	PMBUS_CMD_TON_DELAY.CMD_CONFIG = 0xc3822360;
	PMBUS_CMD_TON_DELAY.DATA0 = &PMBUS_CMD_TON_DELAY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_TON_DELAY.DATA1 = &PMBUS_CMD_TON_DELAY_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for TON_DELAY COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_TON_DELAY] = &PMBUS_CMD_TON_DELAY;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_TON_DELAY] = &PMBUS_CMD_TON_DELAY;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_TON_DELAY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TON_DELAY&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_TON_DELAY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TON_DELAY&31u));

	/* initialize command structure for TON_RISE. */
	// TON_RISE COMMAND:
	//PMBUS_CMD_TON_RISE.OPCODE = PMBUS_CMDCODE_TON_RISE;
	//PMBUS_CMD_TON_RISE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_TON_RISE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_TON_RISE.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_TON_RISE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_TON_RISE.SUPPORTED = 1;
	//PMBUS_CMD_TON_RISE.PROTECTED0 = 0;
	//PMBUS_CMD_TON_RISE.PROTECTED1 = 0;
	//PMBUS_CMD_TON_RISE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_TON_RISE.RANGE = &PMBUS_CMD_TON_RISE_RANGE[0];
	PMBUS_CMD_TON_RISE_RANGE[0] = 8;
	PMBUS_CMD_TON_RISE_RANGE[1] = 2;
	PMBUS_CMD_TON_RISE_RANGE[2] = 9;
	PMBUS_CMD_TON_RISE_RANGE[3] = 1;
	PMBUS_CMD_TON_RISE_RANGE[4] = 10;
	PMBUS_CMD_TON_RISE_RANGE[5] = 0;
	PMBUS_CMD_TON_RISE.CMD_CONFIG = 0xc5822361;
	PMBUS_CMD_TON_RISE.DATA0 = &PMBUS_CMD_TON_RISE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_TON_RISE.DATA1 = &PMBUS_CMD_TON_RISE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for TON_RISE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_TON_RISE] = &PMBUS_CMD_TON_RISE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_TON_RISE] = &PMBUS_CMD_TON_RISE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_TON_RISE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TON_RISE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_TON_RISE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TON_RISE&31u));

	/* initialize command structure for TON_MAX_FAULT_LIMIT. */
	// TON_MAX_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_TON_MAX_FAULT_LIMIT] = PMBUS_HANDLE_TON_MAX_FAULT_LIMIT;
	//PMBUS_CMD_TON_MAX_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_TON_MAX_FAULT_LIMIT;
	//PMBUS_CMD_TON_MAX_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_TON_MAX_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_TON_MAX_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_TON_MAX_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_TON_MAX_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_TON_MAX_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_TON_MAX_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_TON_MAX_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_TON_MAX_FAULT_LIMIT.RANGE = &PMBUS_CMD_TON_MAX_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_TON_MAX_FAULT_LIMIT_RANGE[0] = 8;
	PMBUS_CMD_TON_MAX_FAULT_LIMIT_RANGE[1] = 2;
	PMBUS_CMD_TON_MAX_FAULT_LIMIT_RANGE[2] = 9;
	PMBUS_CMD_TON_MAX_FAULT_LIMIT_RANGE[3] = 1;
	PMBUS_CMD_TON_MAX_FAULT_LIMIT_RANGE[4] = 10;
	PMBUS_CMD_TON_MAX_FAULT_LIMIT_RANGE[5] = 0;
	PMBUS_CMD_TON_MAX_FAULT_LIMIT.CMD_CONFIG = 0xc5822362;
	PMBUS_CMD_TON_MAX_FAULT_LIMIT.DATA0 = &PMBUS_CMD_TON_MAX_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_TON_MAX_FAULT_LIMIT.DATA1 = &PMBUS_CMD_TON_MAX_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for TON_MAX_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_TON_MAX_FAULT_LIMIT] = &PMBUS_CMD_TON_MAX_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_TON_MAX_FAULT_LIMIT] = &PMBUS_CMD_TON_MAX_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_TON_MAX_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TON_MAX_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_TON_MAX_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TON_MAX_FAULT_LIMIT&31u));

	/* initialize command structure for TON_MAX_FAULT_RESPONSE. */
	// TON_MAX_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_TON_MAX_FAULT_RESPONSE] = PMBUS_HANDLE_TON_MAX_FAULT_LIMIT;
	//PMBUS_CMD_TON_MAX_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_TON_MAX_FAULT_RESPONSE;
	//PMBUS_CMD_TON_MAX_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_TON_MAX_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_TON_MAX_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_TON_MAX_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_TON_MAX_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_TON_MAX_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_TON_MAX_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_TON_MAX_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_TON_MAX_FAULT_RESPONSE.CMD_CONFIG = 0xc1812363;
	PMBUS_CMD_TON_MAX_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_TON_MAX_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_TON_MAX_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_TON_MAX_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for TON_MAX_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_TON_MAX_FAULT_RESPONSE] = &PMBUS_CMD_TON_MAX_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_TON_MAX_FAULT_RESPONSE] = &PMBUS_CMD_TON_MAX_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_TON_MAX_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TON_MAX_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_TON_MAX_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TON_MAX_FAULT_RESPONSE&31u));

	/* initialize command structure for TOFF_DELAY. */
	// TOFF_DELAY COMMAND:
	//PMBUS_CMD_TOFF_DELAY.OPCODE = PMBUS_CMDCODE_TOFF_DELAY;
	//PMBUS_CMD_TOFF_DELAY.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_TOFF_DELAY.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_TOFF_DELAY.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_TOFF_DELAY.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_TOFF_DELAY.SUPPORTED = 1;
	//PMBUS_CMD_TOFF_DELAY.PROTECTED0 = 0;
	//PMBUS_CMD_TOFF_DELAY.PROTECTED1 = 0;
	//PMBUS_CMD_TOFF_DELAY.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_TOFF_DELAY.RANGE = &PMBUS_CMD_TOFF_DELAY_RANGE[0];
	PMBUS_CMD_TOFF_DELAY_RANGE[0] = 7;
	PMBUS_CMD_TOFF_DELAY_RANGE[1] = 1;
	PMBUS_CMD_TOFF_DELAY.CMD_CONFIG = 0xc3822364;
	PMBUS_CMD_TOFF_DELAY.DATA0 = &PMBUS_CMD_TOFF_DELAY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_TOFF_DELAY.DATA1 = &PMBUS_CMD_TOFF_DELAY_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for TOFF_DELAY COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_TOFF_DELAY] = &PMBUS_CMD_TOFF_DELAY;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_TOFF_DELAY] = &PMBUS_CMD_TOFF_DELAY;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_TOFF_DELAY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TOFF_DELAY&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_TOFF_DELAY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TOFF_DELAY&31u));

	/* initialize command structure for TOFF_FALL. */
	// TOFF_FALL COMMAND:
	//PMBUS_CMD_TOFF_FALL.OPCODE = PMBUS_CMDCODE_TOFF_FALL;
	//PMBUS_CMD_TOFF_FALL.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_TOFF_FALL.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_TOFF_FALL.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_TOFF_FALL.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_TOFF_FALL.SUPPORTED = 1;
	//PMBUS_CMD_TOFF_FALL.PROTECTED0 = 0;
	//PMBUS_CMD_TOFF_FALL.PROTECTED1 = 0;
	//PMBUS_CMD_TOFF_FALL.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_TOFF_FALL.RANGE = &PMBUS_CMD_TOFF_FALL_RANGE[0];
	PMBUS_CMD_TOFF_FALL_RANGE[0] = 8;
	PMBUS_CMD_TOFF_FALL_RANGE[1] = 2;
	PMBUS_CMD_TOFF_FALL_RANGE[2] = 9;
	PMBUS_CMD_TOFF_FALL_RANGE[3] = 1;
	PMBUS_CMD_TOFF_FALL_RANGE[4] = 10;
	PMBUS_CMD_TOFF_FALL_RANGE[5] = 0;
	PMBUS_CMD_TOFF_FALL.CMD_CONFIG = 0xc5822365;
	PMBUS_CMD_TOFF_FALL.DATA0 = &PMBUS_CMD_TOFF_FALL_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_TOFF_FALL.DATA1 = &PMBUS_CMD_TOFF_FALL_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for TOFF_FALL COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_TOFF_FALL] = &PMBUS_CMD_TOFF_FALL;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_TOFF_FALL] = &PMBUS_CMD_TOFF_FALL;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_TOFF_FALL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TOFF_FALL&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_TOFF_FALL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TOFF_FALL&31u));

	/* initialize command structure for TOFF_MAX_WARN_LIMIT. */
	// TOFF_MAX_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_TOFF_MAX_WARN_LIMIT] = PMBUS_HANDLE_TOFF_MAX_WARN_LIMIT;
	//PMBUS_CMD_TOFF_MAX_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_TOFF_MAX_WARN_LIMIT;
	//PMBUS_CMD_TOFF_MAX_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_TOFF_MAX_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_TOFF_MAX_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_TOFF_MAX_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_TOFF_MAX_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_TOFF_MAX_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_TOFF_MAX_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_TOFF_MAX_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_TOFF_MAX_WARN_LIMIT.RANGE = &PMBUS_CMD_TOFF_MAX_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_TOFF_MAX_WARN_LIMIT_RANGE[0] = 8;
	PMBUS_CMD_TOFF_MAX_WARN_LIMIT_RANGE[1] = 2;
	PMBUS_CMD_TOFF_MAX_WARN_LIMIT_RANGE[2] = 9;
	PMBUS_CMD_TOFF_MAX_WARN_LIMIT_RANGE[3] = 1;
	PMBUS_CMD_TOFF_MAX_WARN_LIMIT_RANGE[4] = 10;
	PMBUS_CMD_TOFF_MAX_WARN_LIMIT_RANGE[5] = 0;
	PMBUS_CMD_TOFF_MAX_WARN_LIMIT.CMD_CONFIG = 0xc5822366;
	PMBUS_CMD_TOFF_MAX_WARN_LIMIT.DATA0 = &PMBUS_CMD_TOFF_MAX_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_TOFF_MAX_WARN_LIMIT.DATA1 = &PMBUS_CMD_TOFF_MAX_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for TOFF_MAX_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_TOFF_MAX_WARN_LIMIT] = &PMBUS_CMD_TOFF_MAX_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_TOFF_MAX_WARN_LIMIT] = &PMBUS_CMD_TOFF_MAX_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_TOFF_MAX_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TOFF_MAX_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_TOFF_MAX_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_TOFF_MAX_WARN_LIMIT&31u));

	/* initialize command structure for POUT_OP_WARN_LIMIT. */
	// POUT_OP_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_POUT_OP_WARN_LIMIT] = PMBUS_HANDLE_POUT_OP_WARN_LIMIT;
	//PMBUS_CMD_POUT_OP_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_POUT_OP_WARN_LIMIT;
	//PMBUS_CMD_POUT_OP_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_POUT_OP_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_POUT_OP_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_POUT_OP_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_POUT_OP_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_POUT_OP_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_POUT_OP_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_POUT_OP_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_POUT_OP_WARN_LIMIT.RANGE = &PMBUS_CMD_POUT_OP_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_POUT_OP_WARN_LIMIT_RANGE[0] = 10;
	PMBUS_CMD_POUT_OP_WARN_LIMIT_RANGE[1] = 0;
	PMBUS_CMD_POUT_OP_WARN_LIMIT_RANGE[2] = 11;
	PMBUS_CMD_POUT_OP_WARN_LIMIT_RANGE[3] = 31;
	PMBUS_CMD_POUT_OP_WARN_LIMIT_RANGE[4] = 12;
	PMBUS_CMD_POUT_OP_WARN_LIMIT_RANGE[5] = 30;
	PMBUS_CMD_POUT_OP_WARN_LIMIT.CMD_CONFIG = 0xc582236a;
	PMBUS_CMD_POUT_OP_WARN_LIMIT.DATA0 = &PMBUS_CMD_POUT_OP_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_POUT_OP_WARN_LIMIT.DATA1 = &PMBUS_CMD_POUT_OP_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for POUT_OP_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_POUT_OP_WARN_LIMIT] = &PMBUS_CMD_POUT_OP_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_POUT_OP_WARN_LIMIT] = &PMBUS_CMD_POUT_OP_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_POUT_OP_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_POUT_OP_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_POUT_OP_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_POUT_OP_WARN_LIMIT&31u));

	/* initialize command structure for PIN_OP_WARN_LIMIT. */
	// PIN_OP_WARN_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_PIN_OP_WARN_LIMIT] = PMBUS_HANDLE_PIN_OP_WARN_LIMIT;
	//PMBUS_CMD_PIN_OP_WARN_LIMIT.OPCODE = PMBUS_CMDCODE_PIN_OP_WARN_LIMIT;
	//PMBUS_CMD_PIN_OP_WARN_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_PIN_OP_WARN_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_PIN_OP_WARN_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_PIN_OP_WARN_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_PIN_OP_WARN_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_PIN_OP_WARN_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_PIN_OP_WARN_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_PIN_OP_WARN_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_PIN_OP_WARN_LIMIT.RANGE = &PMBUS_CMD_PIN_OP_WARN_LIMIT_RANGE[0];
	PMBUS_CMD_PIN_OP_WARN_LIMIT_RANGE[0] = 10;
	PMBUS_CMD_PIN_OP_WARN_LIMIT_RANGE[1] = 0;
	PMBUS_CMD_PIN_OP_WARN_LIMIT_RANGE[2] = 11;
	PMBUS_CMD_PIN_OP_WARN_LIMIT_RANGE[3] = 31;
	PMBUS_CMD_PIN_OP_WARN_LIMIT_RANGE[4] = 12;
	PMBUS_CMD_PIN_OP_WARN_LIMIT_RANGE[5] = 30;
	PMBUS_CMD_PIN_OP_WARN_LIMIT.CMD_CONFIG = 0xc582236b;
	PMBUS_CMD_PIN_OP_WARN_LIMIT.DATA0 = &PMBUS_CMD_PIN_OP_WARN_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_PIN_OP_WARN_LIMIT.DATA1 = &PMBUS_CMD_PIN_OP_WARN_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for PIN_OP_WARN_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_PIN_OP_WARN_LIMIT] = &PMBUS_CMD_PIN_OP_WARN_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_PIN_OP_WARN_LIMIT] = &PMBUS_CMD_PIN_OP_WARN_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_PIN_OP_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_PIN_OP_WARN_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_PIN_OP_WARN_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_PIN_OP_WARN_LIMIT&31u));

	/* initialize command structure for STATUS_BYTE. */
	// STATUS_BYTE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STATUS_BYTE] = PMBUS_HANDLE_STATUS_WORD;
	//PMBUS_CMD_STATUS_BYTE.OPCODE = PMBUS_CMDCODE_STATUS_BYTE;
	//PMBUS_CMD_STATUS_BYTE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STATUS_BYTE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_STATUS_BYTE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_STATUS_BYTE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STATUS_BYTE.SUPPORTED = 1;
	//PMBUS_CMD_STATUS_BYTE.PROTECTED0 = 0;
	//PMBUS_CMD_STATUS_BYTE.PROTECTED1 = 0;
	//PMBUS_CMD_STATUS_BYTE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STATUS_BYTE.CMD_CONFIG = 0x41812378;
	PMBUS_CMD_STATUS_BYTE.DATA0 = &PMBUS_CMD_STATUS_BYTE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STATUS_BYTE.DATA1 = &PMBUS_CMD_STATUS_BYTE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STATUS_BYTE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_BYTE] = &PMBUS_CMD_STATUS_BYTE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_BYTE] = &PMBUS_CMD_STATUS_BYTE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_BYTE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_BYTE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_BYTE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_BYTE&31u));

	/* initialize command structure for STATUS_WORD. */
	// STATUS_WORD COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STATUS_WORD] = PMBUS_HANDLE_STATUS_WORD;
	//PMBUS_CMD_STATUS_WORD.OPCODE = PMBUS_CMDCODE_STATUS_WORD;
	//PMBUS_CMD_STATUS_WORD.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STATUS_WORD.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_STATUS_WORD.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_STATUS_WORD.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STATUS_WORD.SUPPORTED = 1;
	//PMBUS_CMD_STATUS_WORD.PROTECTED0 = 0;
	//PMBUS_CMD_STATUS_WORD.PROTECTED1 = 0;
	//PMBUS_CMD_STATUS_WORD.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STATUS_WORD.CMD_CONFIG = 0x41822379;
	PMBUS_CMD_STATUS_WORD.DATA0 = &PMBUS_CMD_STATUS_WORD_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STATUS_WORD.DATA1 = &PMBUS_CMD_STATUS_WORD_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STATUS_WORD COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_WORD] = &PMBUS_CMD_STATUS_WORD;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_WORD] = &PMBUS_CMD_STATUS_WORD;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_WORD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_WORD&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_WORD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_WORD&31u));

	/* initialize command structure for STATUS_VOUT. */
	// STATUS_VOUT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STATUS_VOUT] = PMBUS_HANDLE_STATUS_VOUT;
	//PMBUS_CMD_STATUS_VOUT.OPCODE = PMBUS_CMDCODE_STATUS_VOUT;
	//PMBUS_CMD_STATUS_VOUT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STATUS_VOUT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_STATUS_VOUT.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_STATUS_VOUT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STATUS_VOUT.SUPPORTED = 1;
	//PMBUS_CMD_STATUS_VOUT.PROTECTED0 = 0;
	//PMBUS_CMD_STATUS_VOUT.PROTECTED1 = 0;
	//PMBUS_CMD_STATUS_VOUT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STATUS_VOUT.CMD_CONFIG = 0x4181237a;
	PMBUS_CMD_STATUS_VOUT.DATA0 = &PMBUS_CMD_STATUS_VOUT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STATUS_VOUT.DATA1 = &PMBUS_CMD_STATUS_VOUT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STATUS_VOUT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_VOUT] = &PMBUS_CMD_STATUS_VOUT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_VOUT] = &PMBUS_CMD_STATUS_VOUT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_VOUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_VOUT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_VOUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_VOUT&31u));

	/* initialize command structure for STATUS_IOUT. */
	// STATUS_IOUT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STATUS_IOUT] = PMBUS_HANDLE_STATUS_IOUT;
	//PMBUS_CMD_STATUS_IOUT.OPCODE = PMBUS_CMDCODE_STATUS_IOUT;
	//PMBUS_CMD_STATUS_IOUT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STATUS_IOUT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_STATUS_IOUT.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_STATUS_IOUT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STATUS_IOUT.SUPPORTED = 1;
	//PMBUS_CMD_STATUS_IOUT.PROTECTED0 = 0;
	//PMBUS_CMD_STATUS_IOUT.PROTECTED1 = 0;
	//PMBUS_CMD_STATUS_IOUT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STATUS_IOUT.CMD_CONFIG = 0x4181237b;
	PMBUS_CMD_STATUS_IOUT.DATA0 = &PMBUS_CMD_STATUS_IOUT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STATUS_IOUT.DATA1 = &PMBUS_CMD_STATUS_IOUT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STATUS_IOUT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_IOUT] = &PMBUS_CMD_STATUS_IOUT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_IOUT] = &PMBUS_CMD_STATUS_IOUT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_IOUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_IOUT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_IOUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_IOUT&31u));

	/* initialize command structure for STATUS_INPUT. */
	// STATUS_INPUT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STATUS_INPUT] = PMBUS_HANDLE_STATUS_INPUT;
	//PMBUS_CMD_STATUS_INPUT.OPCODE = PMBUS_CMDCODE_STATUS_INPUT;
	//PMBUS_CMD_STATUS_INPUT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STATUS_INPUT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_STATUS_INPUT.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_STATUS_INPUT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STATUS_INPUT.SUPPORTED = 1;
	//PMBUS_CMD_STATUS_INPUT.PROTECTED0 = 0;
	//PMBUS_CMD_STATUS_INPUT.PROTECTED1 = 0;
	//PMBUS_CMD_STATUS_INPUT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STATUS_INPUT.CMD_CONFIG = 0x4181237c;
	PMBUS_CMD_STATUS_INPUT.DATA0 = &PMBUS_CMD_STATUS_INPUT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STATUS_INPUT.DATA1 = &PMBUS_CMD_STATUS_INPUT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STATUS_INPUT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_INPUT] = &PMBUS_CMD_STATUS_INPUT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_INPUT] = &PMBUS_CMD_STATUS_INPUT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_INPUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_INPUT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_INPUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_INPUT&31u));

	/* initialize command structure for STATUS_TEMPERATURE. */
	// STATUS_TEMPERATURE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STATUS_TEMPERATURE] = PMBUS_HANDLE_STATUS_TEMPERATURE;
	//PMBUS_CMD_STATUS_TEMPERATURE.OPCODE = PMBUS_CMDCODE_STATUS_TEMPERATURE;
	//PMBUS_CMD_STATUS_TEMPERATURE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STATUS_TEMPERATURE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_STATUS_TEMPERATURE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_STATUS_TEMPERATURE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STATUS_TEMPERATURE.SUPPORTED = 1;
	//PMBUS_CMD_STATUS_TEMPERATURE.PROTECTED0 = 0;
	//PMBUS_CMD_STATUS_TEMPERATURE.PROTECTED1 = 0;
	//PMBUS_CMD_STATUS_TEMPERATURE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STATUS_TEMPERATURE.CMD_CONFIG = 0x4181237d;
	PMBUS_CMD_STATUS_TEMPERATURE.DATA0 = &PMBUS_CMD_STATUS_TEMPERATURE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STATUS_TEMPERATURE.DATA1 = &PMBUS_CMD_STATUS_TEMPERATURE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STATUS_TEMPERATURE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_TEMPERATURE] = &PMBUS_CMD_STATUS_TEMPERATURE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_TEMPERATURE] = &PMBUS_CMD_STATUS_TEMPERATURE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_TEMPERATURE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_TEMPERATURE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_TEMPERATURE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_TEMPERATURE&31u));

	/* initialize command structure for STATUS_CML. */
	// STATUS_CML COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STATUS_CML] = PMBUS_HANDLE_STATUS_CML;
	//PMBUS_CMD_STATUS_CML.OPCODE = PMBUS_CMDCODE_STATUS_CML;
	//PMBUS_CMD_STATUS_CML.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STATUS_CML.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_STATUS_CML.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_STATUS_CML.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STATUS_CML.SUPPORTED = 1;
	//PMBUS_CMD_STATUS_CML.PROTECTED0 = 0;
	//PMBUS_CMD_STATUS_CML.PROTECTED1 = 0;
	//PMBUS_CMD_STATUS_CML.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STATUS_CML.CMD_CONFIG = 0x4181237e;
	PMBUS_CMD_STATUS_CML.DATA0 = &PMBUS_CMD_STATUS_CML_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STATUS_CML.DATA1 = &PMBUS_CMD_STATUS_CML_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STATUS_CML COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_CML] = &PMBUS_CMD_STATUS_CML;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_CML] = &PMBUS_CMD_STATUS_CML;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_CML/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_CML&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_CML/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_CML&31u));

	/* initialize command structure for STATUS_OTHER. */
	// STATUS_OTHER COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STATUS_OTHER] = PMBUS_HANDLE_STATUS_OTHER;
	//PMBUS_CMD_STATUS_OTHER.OPCODE = PMBUS_CMDCODE_STATUS_OTHER;
	//PMBUS_CMD_STATUS_OTHER.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STATUS_OTHER.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_STATUS_OTHER.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_STATUS_OTHER.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STATUS_OTHER.SUPPORTED = 1;
	//PMBUS_CMD_STATUS_OTHER.PROTECTED0 = 0;
	//PMBUS_CMD_STATUS_OTHER.PROTECTED1 = 0;
	//PMBUS_CMD_STATUS_OTHER.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STATUS_OTHER.CMD_CONFIG = 0x4181237f;
	PMBUS_CMD_STATUS_OTHER.DATA0 = &PMBUS_CMD_STATUS_OTHER_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STATUS_OTHER.DATA1 = &PMBUS_CMD_STATUS_OTHER_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STATUS_OTHER COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_OTHER] = &PMBUS_CMD_STATUS_OTHER;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_OTHER] = &PMBUS_CMD_STATUS_OTHER;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_OTHER/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_OTHER&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_OTHER/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_OTHER&31u));

	/* initialize command structure for STATUS_MFR_SPECIFIC. */
	// STATUS_MFR_SPECIFIC COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STATUS_MFR_SPECIFIC] = PMBUS_HANDLE_STATUS_MFR_SPECIFIC;
	//PMBUS_CMD_STATUS_MFR_SPECIFIC.OPCODE = PMBUS_CMDCODE_STATUS_MFR_SPECIFIC;
	//PMBUS_CMD_STATUS_MFR_SPECIFIC.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STATUS_MFR_SPECIFIC.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_STATUS_MFR_SPECIFIC.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_STATUS_MFR_SPECIFIC.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STATUS_MFR_SPECIFIC.SUPPORTED = 1;
	//PMBUS_CMD_STATUS_MFR_SPECIFIC.PROTECTED0 = 0;
	//PMBUS_CMD_STATUS_MFR_SPECIFIC.PROTECTED1 = 0;
	//PMBUS_CMD_STATUS_MFR_SPECIFIC.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STATUS_MFR_SPECIFIC.CMD_CONFIG = 0x41812380;
	PMBUS_CMD_STATUS_MFR_SPECIFIC.DATA0 = &PMBUS_CMD_STATUS_MFR_SPECIFIC_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STATUS_MFR_SPECIFIC.DATA1 = &PMBUS_CMD_STATUS_MFR_SPECIFIC_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STATUS_MFR_SPECIFIC COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_MFR_SPECIFIC] = &PMBUS_CMD_STATUS_MFR_SPECIFIC;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_MFR_SPECIFIC] = &PMBUS_CMD_STATUS_MFR_SPECIFIC;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_MFR_SPECIFIC/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_MFR_SPECIFIC&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_MFR_SPECIFIC/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_MFR_SPECIFIC&31u));

	/* initialize command structure for STATUS_FANS_1_2. */
	// STATUS_FANS_1_2 COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_STATUS_FANS_1_2] = PMBUS_HANDLE_STATUS_FANS_1_2;
	//PMBUS_CMD_STATUS_FANS_1_2.OPCODE = PMBUS_CMDCODE_STATUS_FANS_1_2;
	//PMBUS_CMD_STATUS_FANS_1_2.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_STATUS_FANS_1_2.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_STATUS_FANS_1_2.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_STATUS_FANS_1_2.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_STATUS_FANS_1_2.SUPPORTED = 1;
	//PMBUS_CMD_STATUS_FANS_1_2.PROTECTED0 = 0;
	//PMBUS_CMD_STATUS_FANS_1_2.PROTECTED1 = 0;
	//PMBUS_CMD_STATUS_FANS_1_2.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_STATUS_FANS_1_2.CMD_CONFIG = 0x41812381;
	PMBUS_CMD_STATUS_FANS_1_2.DATA0 = &PMBUS_CMD_STATUS_FANS_1_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_STATUS_FANS_1_2.DATA1 = &PMBUS_CMD_STATUS_FANS_1_2_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for STATUS_FANS_1_2 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_FANS_1_2] = &PMBUS_CMD_STATUS_FANS_1_2;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_FANS_1_2] = &PMBUS_CMD_STATUS_FANS_1_2;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_STATUS_FANS_1_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_FANS_1_2&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_STATUS_FANS_1_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_STATUS_FANS_1_2&31u));

	/* initialize command structure for READ_VIN. */
	// READ_VIN COMMAND:
	//PMBUS_CMD_READ_VIN.OPCODE = PMBUS_CMDCODE_READ_VIN;
	//PMBUS_CMD_READ_VIN.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_VIN.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_VIN.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_VIN.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_VIN.SUPPORTED = 1;
	//PMBUS_CMD_READ_VIN.PROTECTED0 = 0;
	//PMBUS_CMD_READ_VIN.PROTECTED1 = 0;
	//PMBUS_CMD_READ_VIN.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_VIN.CMD_CONFIG = 0x40822088;
	PMBUS_CMD_READ_VIN.DATA0 = &PMBUS_CMD_READ_VIN_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_VIN.DATA1 = &PMBUS_CMD_READ_VIN_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for READ_VIN COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_VIN] = &PMBUS_CMD_READ_VIN;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_VIN] = &PMBUS_CMD_READ_VIN;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_VIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_VIN&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_VIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_VIN&31u));

	/* initialize command structure for READ_IIN. */
	// READ_IIN COMMAND:
	//PMBUS_CMD_READ_IIN.OPCODE = PMBUS_CMDCODE_READ_IIN;
	//PMBUS_CMD_READ_IIN.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_IIN.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_IIN.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_IIN.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_IIN.SUPPORTED = 1;
	//PMBUS_CMD_READ_IIN.PROTECTED0 = 0;
	//PMBUS_CMD_READ_IIN.PROTECTED1 = 0;
	//PMBUS_CMD_READ_IIN.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_IIN.CMD_CONFIG = 0x40822089;
	PMBUS_CMD_READ_IIN.DATA0 = &PMBUS_CMD_READ_IIN_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_IIN.DATA1 = &PMBUS_CMD_READ_IIN_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for READ_IIN COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_IIN] = &PMBUS_CMD_READ_IIN;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_IIN] = &PMBUS_CMD_READ_IIN;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_IIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_IIN&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_IIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_IIN&31u));

	/* initialize command structure for READ_VOUT. */
	// READ_VOUT COMMAND:
	//PMBUS_CMD_READ_VOUT.OPCODE = PMBUS_CMDCODE_READ_VOUT;
	//PMBUS_CMD_READ_VOUT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_VOUT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_VOUT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_VOUT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_VOUT.SUPPORTED = 1;
	//PMBUS_CMD_READ_VOUT.PROTECTED0 = 0;
	//PMBUS_CMD_READ_VOUT.PROTECTED1 = 0;
	//PMBUS_CMD_READ_VOUT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_VOUT.CMD_CONFIG = 0x4082208b;
	PMBUS_CMD_READ_VOUT.DATA0 = &PMBUS_CMD_READ_VOUT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_VOUT.DATA1 = &PMBUS_CMD_READ_VOUT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for READ_VOUT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_VOUT] = &PMBUS_CMD_READ_VOUT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_VOUT] = &PMBUS_CMD_READ_VOUT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_VOUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_VOUT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_VOUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_VOUT&31u));

	/* initialize command structure for READ_IOUT. */
	// READ_IOUT COMMAND:
	//PMBUS_CMD_READ_IOUT.OPCODE = PMBUS_CMDCODE_READ_IOUT;
	//PMBUS_CMD_READ_IOUT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_IOUT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_IOUT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_IOUT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_IOUT.SUPPORTED = 1;
	//PMBUS_CMD_READ_IOUT.PROTECTED0 = 0;
	//PMBUS_CMD_READ_IOUT.PROTECTED1 = 0;
	//PMBUS_CMD_READ_IOUT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_IOUT.CMD_CONFIG = 0x4082208c;
	PMBUS_CMD_READ_IOUT.DATA0 = &PMBUS_CMD_READ_IOUT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_IOUT.DATA1 = &PMBUS_CMD_READ_IOUT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for READ_IOUT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_IOUT] = &PMBUS_CMD_READ_IOUT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_IOUT] = &PMBUS_CMD_READ_IOUT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_IOUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_IOUT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_IOUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_IOUT&31u));

	/* initialize command structure for READ_TEMPERATURE_1. */
	// READ_TEMPERATURE_1 COMMAND:
	//PMBUS_CMD_READ_TEMPERATURE_1.OPCODE = PMBUS_CMDCODE_READ_TEMPERATURE_1;
	//PMBUS_CMD_READ_TEMPERATURE_1.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_TEMPERATURE_1.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_TEMPERATURE_1.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_TEMPERATURE_1.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_TEMPERATURE_1.SUPPORTED = 1;
	//PMBUS_CMD_READ_TEMPERATURE_1.PROTECTED0 = 0;
	//PMBUS_CMD_READ_TEMPERATURE_1.PROTECTED1 = 0;
	//PMBUS_CMD_READ_TEMPERATURE_1.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_TEMPERATURE_1.CMD_CONFIG = 0x4082208d;
	PMBUS_CMD_READ_TEMPERATURE_1.DATA0 = &PMBUS_CMD_READ_TEMPERATURE_1_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_TEMPERATURE_1.DATA1 = &PMBUS_CMD_READ_TEMPERATURE_1_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for READ_TEMPERATURE_1 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_TEMPERATURE_1] = &PMBUS_CMD_READ_TEMPERATURE_1;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_TEMPERATURE_1] = &PMBUS_CMD_READ_TEMPERATURE_1;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_TEMPERATURE_1/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_TEMPERATURE_1&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_TEMPERATURE_1/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_TEMPERATURE_1&31u));

	/* initialize command structure for READ_TEMPERATURE_2. */
	// READ_TEMPERATURE_2 COMMAND:
	//PMBUS_CMD_READ_TEMPERATURE_2.OPCODE = PMBUS_CMDCODE_READ_TEMPERATURE_2;
	//PMBUS_CMD_READ_TEMPERATURE_2.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_TEMPERATURE_2.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_TEMPERATURE_2.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_TEMPERATURE_2.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_TEMPERATURE_2.SUPPORTED = 1;
	//PMBUS_CMD_READ_TEMPERATURE_2.PROTECTED0 = 0;
	//PMBUS_CMD_READ_TEMPERATURE_2.PROTECTED1 = 0;
	//PMBUS_CMD_READ_TEMPERATURE_2.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_TEMPERATURE_2.CMD_CONFIG = 0x4082208e;
	PMBUS_CMD_READ_TEMPERATURE_2.DATA0 = &PMBUS_CMD_READ_TEMPERATURE_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_TEMPERATURE_2.DATA1 = &PMBUS_CMD_READ_TEMPERATURE_2_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for READ_TEMPERATURE_2 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_TEMPERATURE_2] = &PMBUS_CMD_READ_TEMPERATURE_2;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_TEMPERATURE_2] = &PMBUS_CMD_READ_TEMPERATURE_2;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_TEMPERATURE_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_TEMPERATURE_2&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_TEMPERATURE_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_TEMPERATURE_2&31u));

	/* initialize command structure for READ_FAN_SPEED_1. */
	// READ_FAN_SPEED_1 COMMAND:
	//PMBUS_CMD_READ_FAN_SPEED_1.OPCODE = PMBUS_CMDCODE_READ_FAN_SPEED_1;
	//PMBUS_CMD_READ_FAN_SPEED_1.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_FAN_SPEED_1.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_FAN_SPEED_1.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_FAN_SPEED_1.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_FAN_SPEED_1.SUPPORTED = 1;
	//PMBUS_CMD_READ_FAN_SPEED_1.PROTECTED0 = 0;
	//PMBUS_CMD_READ_FAN_SPEED_1.PROTECTED1 = 0;
	//PMBUS_CMD_READ_FAN_SPEED_1.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_FAN_SPEED_1.CMD_CONFIG = 0x40822090;
	PMBUS_CMD_READ_FAN_SPEED_1.DATA0 = &PMBUS_CMD_READ_FAN_SPEED_1_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_FAN_SPEED_1.DATA1 = &PMBUS_CMD_READ_FAN_SPEED_1_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_FAN_SPEED_1_DATA_LOOP1 = &PMBUS_CMD_READ_FAN_SPEED_1_DATA_LOOP0[0];
	// RANGE SUPPORT for READ_FAN_SPEED_1 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_FAN_SPEED_1] = &PMBUS_CMD_READ_FAN_SPEED_1;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_FAN_SPEED_1] = &PMBUS_CMD_READ_FAN_SPEED_1;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_FAN_SPEED_1/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_FAN_SPEED_1&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_FAN_SPEED_1/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_FAN_SPEED_1&31u));

	/* initialize command structure for READ_FAN_SPEED_2. */
	// READ_FAN_SPEED_2 COMMAND:
	//PMBUS_CMD_READ_FAN_SPEED_2.OPCODE = PMBUS_CMDCODE_READ_FAN_SPEED_2;
	//PMBUS_CMD_READ_FAN_SPEED_2.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_FAN_SPEED_2.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_FAN_SPEED_2.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_FAN_SPEED_2.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_FAN_SPEED_2.SUPPORTED = 1;
	//PMBUS_CMD_READ_FAN_SPEED_2.PROTECTED0 = 0;
	//PMBUS_CMD_READ_FAN_SPEED_2.PROTECTED1 = 0;
	//PMBUS_CMD_READ_FAN_SPEED_2.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_FAN_SPEED_2.CMD_CONFIG = 0x40822091;
	PMBUS_CMD_READ_FAN_SPEED_2.DATA0 = &PMBUS_CMD_READ_FAN_SPEED_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_FAN_SPEED_2.DATA1 = &PMBUS_CMD_READ_FAN_SPEED_2_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_FAN_SPEED_2_DATA_LOOP1 = &PMBUS_CMD_READ_FAN_SPEED_2_DATA_LOOP0[0];
	// RANGE SUPPORT for READ_FAN_SPEED_2 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_FAN_SPEED_2] = &PMBUS_CMD_READ_FAN_SPEED_2;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_FAN_SPEED_2] = &PMBUS_CMD_READ_FAN_SPEED_2;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_FAN_SPEED_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_FAN_SPEED_2&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_FAN_SPEED_2/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_FAN_SPEED_2&31u));

	/* initialize command structure for READ_DUTY_CYCLE. */
	// READ_DUTY_CYCLE COMMAND:
	//PMBUS_CMD_READ_DUTY_CYCLE.OPCODE = PMBUS_CMDCODE_READ_DUTY_CYCLE;
	//PMBUS_CMD_READ_DUTY_CYCLE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_DUTY_CYCLE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_DUTY_CYCLE.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_DUTY_CYCLE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_DUTY_CYCLE.SUPPORTED = 1;
	//PMBUS_CMD_READ_DUTY_CYCLE.PROTECTED0 = 0;
	//PMBUS_CMD_READ_DUTY_CYCLE.PROTECTED1 = 0;
	//PMBUS_CMD_READ_DUTY_CYCLE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_DUTY_CYCLE.CMD_CONFIG = 0x40822094;
	PMBUS_CMD_READ_DUTY_CYCLE.DATA0 = &PMBUS_CMD_READ_DUTY_CYCLE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_DUTY_CYCLE.DATA1 = &PMBUS_CMD_READ_DUTY_CYCLE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for READ_DUTY_CYCLE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_DUTY_CYCLE] = &PMBUS_CMD_READ_DUTY_CYCLE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_DUTY_CYCLE] = &PMBUS_CMD_READ_DUTY_CYCLE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_DUTY_CYCLE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_DUTY_CYCLE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_DUTY_CYCLE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_DUTY_CYCLE&31u));

	/* initialize command structure for READ_FREQUENCY. */
	// READ_FREQUENCY COMMAND:
	//PMBUS_CMD_READ_FREQUENCY.OPCODE = PMBUS_CMDCODE_READ_FREQUENCY;
	//PMBUS_CMD_READ_FREQUENCY.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_FREQUENCY.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_FREQUENCY.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_FREQUENCY.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_FREQUENCY.SUPPORTED = 1;
	//PMBUS_CMD_READ_FREQUENCY.PROTECTED0 = 0;
	//PMBUS_CMD_READ_FREQUENCY.PROTECTED1 = 0;
	//PMBUS_CMD_READ_FREQUENCY.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_FREQUENCY.CMD_CONFIG = 0x40822095;
	PMBUS_CMD_READ_FREQUENCY.DATA0 = &PMBUS_CMD_READ_FREQUENCY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_FREQUENCY.DATA1 = &PMBUS_CMD_READ_FREQUENCY_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for READ_FREQUENCY COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_FREQUENCY] = &PMBUS_CMD_READ_FREQUENCY;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_FREQUENCY] = &PMBUS_CMD_READ_FREQUENCY;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_FREQUENCY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_FREQUENCY&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_FREQUENCY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_FREQUENCY&31u));

	/* initialize command structure for READ_POUT. */
	// READ_POUT COMMAND:
	//PMBUS_CMD_READ_POUT.OPCODE = PMBUS_CMDCODE_READ_POUT;
	//PMBUS_CMD_READ_POUT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_POUT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_POUT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_POUT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_POUT.SUPPORTED = 1;
	//PMBUS_CMD_READ_POUT.PROTECTED0 = 0;
	//PMBUS_CMD_READ_POUT.PROTECTED1 = 0;
	//PMBUS_CMD_READ_POUT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_POUT.CMD_CONFIG = 0x40822096;
	PMBUS_CMD_READ_POUT.DATA0 = &PMBUS_CMD_READ_POUT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_POUT.DATA1 = &PMBUS_CMD_READ_POUT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for READ_POUT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_POUT] = &PMBUS_CMD_READ_POUT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_POUT] = &PMBUS_CMD_READ_POUT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_POUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_POUT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_POUT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_POUT&31u));

	/* initialize command structure for READ_PIN. */
	// READ_PIN COMMAND:
	//PMBUS_CMD_READ_PIN.OPCODE = PMBUS_CMDCODE_READ_PIN;
	//PMBUS_CMD_READ_PIN.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_READ_PIN.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_READ_PIN.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_READ_PIN.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_READ_PIN.SUPPORTED = 1;
	//PMBUS_CMD_READ_PIN.PROTECTED0 = 0;
	//PMBUS_CMD_READ_PIN.PROTECTED1 = 0;
	//PMBUS_CMD_READ_PIN.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_READ_PIN.CMD_CONFIG = 0x40822097;
	PMBUS_CMD_READ_PIN.DATA0 = &PMBUS_CMD_READ_PIN_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_READ_PIN.DATA1 = &PMBUS_CMD_READ_PIN_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for READ_PIN COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_READ_PIN] = &PMBUS_CMD_READ_PIN;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_READ_PIN] = &PMBUS_CMD_READ_PIN;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_READ_PIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_PIN&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_READ_PIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_READ_PIN&31u));

	/* initialize command structure for PMBUS_REVISION. */
	// PMBUS_REVISION COMMAND:
	//PMBUS_CMD_PMBUS_REVISION.OPCODE = PMBUS_CMDCODE_PMBUS_REVISION;
	//PMBUS_CMD_PMBUS_REVISION.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_PMBUS_REVISION.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_PMBUS_REVISION.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_PMBUS_REVISION.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_PMBUS_REVISION.SUPPORTED = 1;
	//PMBUS_CMD_PMBUS_REVISION.PROTECTED0 = 0;
	//PMBUS_CMD_PMBUS_REVISION.PROTECTED1 = 0;
	//PMBUS_CMD_PMBUS_REVISION.RANGE_TYPE = (uint8_t) PMBUS_RANGE_NONE;
	PMBUS_CMD_PMBUS_REVISION.CMD_CONFIG = 0xc0812098;
	PMBUS_CMD_PMBUS_REVISION.DATA0 = &PMBUS_CMD_PMBUS_REVISION_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_PMBUS_REVISION.DATA1 = &PMBUS_CMD_PMBUS_REVISION_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_PMBUS_REVISION_DATA_LOOP1 = &PMBUS_CMD_PMBUS_REVISION_DATA_LOOP0[0];
	// RANGE SUPPORT for PMBUS_REVISION COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_PMBUS_REVISION] = &PMBUS_CMD_PMBUS_REVISION;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_PMBUS_REVISION] = &PMBUS_CMD_PMBUS_REVISION;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_PMBUS_REVISION/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_PMBUS_REVISION&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_PMBUS_REVISION/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_PMBUS_REVISION&31u));

	/* initialize command structure for MFR_ID. */
	// MFR_ID COMMAND:
	//PMBUS_CMD_MFR_ID.OPCODE = PMBUS_CMDCODE_MFR_ID;
	//PMBUS_CMD_MFR_ID.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_ID.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_ID.NUM_BYTES = 12; // data only not including slave address and command
	//PMBUS_CMD_MFR_ID.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_ID.SUPPORTED = 1;
	//PMBUS_CMD_MFR_ID.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_ID.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_ID.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_ID.CMD_CONFIG = 0xc1cc5699;
	PMBUS_CMD_MFR_ID.DATA0 = &PMBUS_CMD_MFR_ID_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_ID.DATA1 = &PMBUS_CMD_MFR_ID_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_ID_DATA_LOOP1 = &PMBUS_CMD_MFR_ID_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_ID COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_ID] = &PMBUS_CMD_MFR_ID;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_ID] = &PMBUS_CMD_MFR_ID;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_ID/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_ID&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_ID/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_ID&31u));

	/* initialize command structure for MFR_MODEL. */
	// MFR_MODEL COMMAND:
	//PMBUS_CMD_MFR_MODEL.OPCODE = PMBUS_CMDCODE_MFR_MODEL;
	//PMBUS_CMD_MFR_MODEL.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_MODEL.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_MODEL.NUM_BYTES = 20; // data only not including slave address and command
	//PMBUS_CMD_MFR_MODEL.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_MODEL.SUPPORTED = 1;
	//PMBUS_CMD_MFR_MODEL.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_MODEL.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_MODEL.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_MODEL.CMD_CONFIG = 0xc1d4569a;
	PMBUS_CMD_MFR_MODEL.DATA0 = &PMBUS_CMD_MFR_MODEL_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_MODEL.DATA1 = &PMBUS_CMD_MFR_MODEL_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_MODEL_DATA_LOOP1 = &PMBUS_CMD_MFR_MODEL_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_MODEL COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_MODEL] = &PMBUS_CMD_MFR_MODEL;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_MODEL] = &PMBUS_CMD_MFR_MODEL;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_MODEL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_MODEL&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_MODEL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_MODEL&31u));

	/* initialize command structure for MFR_REVISION. */
	// MFR_REVISION COMMAND:
	//PMBUS_CMD_MFR_REVISION.OPCODE = PMBUS_CMDCODE_MFR_REVISION;
	//PMBUS_CMD_MFR_REVISION.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_REVISION.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_REVISION.NUM_BYTES = 12; // data only not including slave address and command
	//PMBUS_CMD_MFR_REVISION.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_REVISION.SUPPORTED = 1;
	//PMBUS_CMD_MFR_REVISION.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_REVISION.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_REVISION.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_REVISION.CMD_CONFIG = 0xc1cc569b;
	PMBUS_CMD_MFR_REVISION.DATA0 = &PMBUS_CMD_MFR_REVISION_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_REVISION.DATA1 = &PMBUS_CMD_MFR_REVISION_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_REVISION_DATA_LOOP1 = &PMBUS_CMD_MFR_REVISION_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_REVISION COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_REVISION] = &PMBUS_CMD_MFR_REVISION;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_REVISION] = &PMBUS_CMD_MFR_REVISION;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_REVISION/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_REVISION&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_REVISION/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_REVISION&31u));

	/* initialize command structure for MFR_LOCATION. */
	// MFR_LOCATION COMMAND:
	//PMBUS_CMD_MFR_LOCATION.OPCODE = PMBUS_CMDCODE_MFR_LOCATION;
	//PMBUS_CMD_MFR_LOCATION.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_LOCATION.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_LOCATION.NUM_BYTES = 12; // data only not including slave address and command
	//PMBUS_CMD_MFR_LOCATION.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_LOCATION.SUPPORTED = 1;
	//PMBUS_CMD_MFR_LOCATION.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_LOCATION.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_LOCATION.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_LOCATION.CMD_CONFIG = 0xc1cc569c;
	PMBUS_CMD_MFR_LOCATION.DATA0 = &PMBUS_CMD_MFR_LOCATION_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_LOCATION.DATA1 = &PMBUS_CMD_MFR_LOCATION_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_LOCATION_DATA_LOOP1 = &PMBUS_CMD_MFR_LOCATION_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_LOCATION COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_LOCATION] = &PMBUS_CMD_MFR_LOCATION;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_LOCATION] = &PMBUS_CMD_MFR_LOCATION;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_LOCATION/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_LOCATION&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_LOCATION/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_LOCATION&31u));

	/* initialize command structure for MFR_DATE. */
	// MFR_DATE COMMAND:
	//PMBUS_CMD_MFR_DATE.OPCODE = PMBUS_CMDCODE_MFR_DATE;
	//PMBUS_CMD_MFR_DATE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_DATE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_DATE.NUM_BYTES = 12; // data only not including slave address and command
	//PMBUS_CMD_MFR_DATE.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_DATE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_DATE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_DATE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_DATE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_DATE.CMD_CONFIG = 0xc1cc569d;
	PMBUS_CMD_MFR_DATE.DATA0 = &PMBUS_CMD_MFR_DATE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_DATE.DATA1 = &PMBUS_CMD_MFR_DATE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_DATE_DATA_LOOP1 = &PMBUS_CMD_MFR_DATE_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_DATE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_DATE] = &PMBUS_CMD_MFR_DATE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_DATE] = &PMBUS_CMD_MFR_DATE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_DATE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_DATE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_DATE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_DATE&31u));

	/* initialize command structure for MFR_SERIAL. */
	// MFR_SERIAL COMMAND:
	//PMBUS_CMD_MFR_SERIAL.OPCODE = PMBUS_CMDCODE_MFR_SERIAL;
	//PMBUS_CMD_MFR_SERIAL.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_SERIAL.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_SERIAL.NUM_BYTES = 20; // data only not including slave address and command
	//PMBUS_CMD_MFR_SERIAL.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SERIAL.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SERIAL.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SERIAL.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SERIAL.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SERIAL.CMD_CONFIG = 0xc1d4569e;
	PMBUS_CMD_MFR_SERIAL.DATA0 = &PMBUS_CMD_MFR_SERIAL_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SERIAL.DATA1 = &PMBUS_CMD_MFR_SERIAL_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SERIAL_DATA_LOOP1 = &PMBUS_CMD_MFR_SERIAL_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_SERIAL COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SERIAL] = &PMBUS_CMD_MFR_SERIAL;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SERIAL] = &PMBUS_CMD_MFR_SERIAL;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SERIAL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SERIAL&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SERIAL/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SERIAL&31u));

	/* initialize command structure for MFR_VIN_MIN. */
	// MFR_VIN_MIN COMMAND:
	//PMBUS_CMD_MFR_VIN_MIN.OPCODE = PMBUS_CMDCODE_MFR_VIN_MIN;
	//PMBUS_CMD_MFR_VIN_MIN.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_VIN_MIN.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_VIN_MIN.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_VIN_MIN.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VIN_MIN.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VIN_MIN.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VIN_MIN.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VIN_MIN.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MFR_VIN_MIN.RANGE = &PMBUS_CMD_MFR_VIN_MIN_RANGE[0];
	PMBUS_CMD_MFR_VIN_MIN_RANGE[0] = 7;
	PMBUS_CMD_MFR_VIN_MIN_RANGE[1] = 0;
	PMBUS_CMD_MFR_VIN_MIN.CMD_CONFIG = 0xc38223a0;
	PMBUS_CMD_MFR_VIN_MIN.DATA0 = &PMBUS_CMD_MFR_VIN_MIN_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_MIN.DATA1 = &PMBUS_CMD_MFR_VIN_MIN_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_VIN_MIN COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_MIN] = &PMBUS_CMD_MFR_VIN_MIN;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_MIN] = &PMBUS_CMD_MFR_VIN_MIN;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_MIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_MIN&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_MIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_MIN&31u));

	/* initialize command structure for MFR_VIN_MAX. */
	// MFR_VIN_MAX COMMAND:
	//PMBUS_CMD_MFR_VIN_MAX.OPCODE = PMBUS_CMDCODE_MFR_VIN_MAX;
	//PMBUS_CMD_MFR_VIN_MAX.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_VIN_MAX.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_VIN_MAX.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_VIN_MAX.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VIN_MAX.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VIN_MAX.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VIN_MAX.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VIN_MAX.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MFR_VIN_MAX.RANGE = &PMBUS_CMD_MFR_VIN_MAX_RANGE[0];
	PMBUS_CMD_MFR_VIN_MAX_RANGE[0] = 7;
	PMBUS_CMD_MFR_VIN_MAX_RANGE[1] = 0;
	PMBUS_CMD_MFR_VIN_MAX.CMD_CONFIG = 0xc38223a1;
	PMBUS_CMD_MFR_VIN_MAX.DATA0 = &PMBUS_CMD_MFR_VIN_MAX_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VIN_MAX.DATA1 = &PMBUS_CMD_MFR_VIN_MAX_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_VIN_MAX COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_MAX] = &PMBUS_CMD_MFR_VIN_MAX;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_MAX] = &PMBUS_CMD_MFR_VIN_MAX;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VIN_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_MAX&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VIN_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VIN_MAX&31u));

	/* initialize command structure for MFR_IIN_MAX. */
	// MFR_IIN_MAX COMMAND:
	//PMBUS_CMD_MFR_IIN_MAX.OPCODE = PMBUS_CMDCODE_MFR_IIN_MAX;
	//PMBUS_CMD_MFR_IIN_MAX.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_IIN_MAX.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_IIN_MAX.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_IIN_MAX.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_IIN_MAX.SUPPORTED = 1;
	//PMBUS_CMD_MFR_IIN_MAX.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_IIN_MAX.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_IIN_MAX.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MFR_IIN_MAX.RANGE = &PMBUS_CMD_MFR_IIN_MAX_RANGE[0];
	PMBUS_CMD_MFR_IIN_MAX_RANGE[0] = 7;
	PMBUS_CMD_MFR_IIN_MAX_RANGE[1] = 0;
	PMBUS_CMD_MFR_IIN_MAX.CMD_CONFIG = 0xc38223a2;
	PMBUS_CMD_MFR_IIN_MAX.DATA0 = &PMBUS_CMD_MFR_IIN_MAX_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_IIN_MAX.DATA1 = &PMBUS_CMD_MFR_IIN_MAX_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_IIN_MAX COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IIN_MAX] = &PMBUS_CMD_MFR_IIN_MAX;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IIN_MAX] = &PMBUS_CMD_MFR_IIN_MAX;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IIN_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IIN_MAX&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IIN_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IIN_MAX&31u));

	/* initialize command structure for MFR_PIN_MAX. */
	// MFR_PIN_MAX COMMAND:
	//PMBUS_CMD_MFR_PIN_MAX.OPCODE = PMBUS_CMDCODE_MFR_PIN_MAX;
	//PMBUS_CMD_MFR_PIN_MAX.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_PIN_MAX.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_PIN_MAX.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_PIN_MAX.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_PIN_MAX.SUPPORTED = 1;
	//PMBUS_CMD_MFR_PIN_MAX.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_PIN_MAX.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_PIN_MAX.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_MFR_PIN_MAX.RANGE = &PMBUS_CMD_MFR_PIN_MAX_RANGE[0];
	PMBUS_CMD_MFR_PIN_MAX_RANGE[0] = 10;
	PMBUS_CMD_MFR_PIN_MAX_RANGE[1] = 0;
	PMBUS_CMD_MFR_PIN_MAX_RANGE[2] = 11;
	PMBUS_CMD_MFR_PIN_MAX_RANGE[3] = 31;
	PMBUS_CMD_MFR_PIN_MAX_RANGE[4] = 12;
	PMBUS_CMD_MFR_PIN_MAX_RANGE[5] = 30;
	PMBUS_CMD_MFR_PIN_MAX.CMD_CONFIG = 0xc58223a3;
	PMBUS_CMD_MFR_PIN_MAX.DATA0 = &PMBUS_CMD_MFR_PIN_MAX_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_PIN_MAX.DATA1 = &PMBUS_CMD_MFR_PIN_MAX_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_PIN_MAX COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_PIN_MAX] = &PMBUS_CMD_MFR_PIN_MAX;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_PIN_MAX] = &PMBUS_CMD_MFR_PIN_MAX;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_PIN_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_PIN_MAX&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_PIN_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_PIN_MAX&31u));

	/* initialize command structure for MFR_VOUT_MIN. */
	// MFR_VOUT_MIN COMMAND:
	//PMBUS_CMD_MFR_VOUT_MIN.OPCODE = PMBUS_CMDCODE_MFR_VOUT_MIN;
	//PMBUS_CMD_MFR_VOUT_MIN.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_VOUT_MIN.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_VOUT_MIN.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_VOUT_MIN.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VOUT_MIN.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VOUT_MIN.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VOUT_MIN.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VOUT_MIN.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_MFR_VOUT_MIN.RANGE = &PMBUS_CMD_MFR_VOUT_MIN_RANGE[0];
	PMBUS_CMD_MFR_VOUT_MIN.CMD_CONFIG = 0xc88223a4;
	PMBUS_CMD_MFR_VOUT_MIN.DATA0 = &PMBUS_CMD_MFR_VOUT_MIN_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VOUT_MIN.DATA1 = &PMBUS_CMD_MFR_VOUT_MIN_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_VOUT_MIN COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VOUT_MIN] = &PMBUS_CMD_MFR_VOUT_MIN;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VOUT_MIN] = &PMBUS_CMD_MFR_VOUT_MIN;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VOUT_MIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VOUT_MIN&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VOUT_MIN/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VOUT_MIN&31u));

	/* initialize command structure for MFR_VOUT_MAX. */
	// MFR_VOUT_MAX COMMAND:
	//PMBUS_CMD_MFR_VOUT_MAX.OPCODE = PMBUS_CMDCODE_MFR_VOUT_MAX;
	//PMBUS_CMD_MFR_VOUT_MAX.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_VOUT_MAX.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_VOUT_MAX.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_VOUT_MAX.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VOUT_MAX.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VOUT_MAX.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VOUT_MAX.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VOUT_MAX.RANGE_TYPE = (uint8_t) PMBUS_RANGE_VOUT_MODE;
	PMBUS_CMD_MFR_VOUT_MAX.RANGE = &PMBUS_CMD_MFR_VOUT_MAX_RANGE[0];
	PMBUS_CMD_MFR_VOUT_MAX.CMD_CONFIG = 0xc88223a5;
	PMBUS_CMD_MFR_VOUT_MAX.DATA0 = &PMBUS_CMD_MFR_VOUT_MAX_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VOUT_MAX.DATA1 = &PMBUS_CMD_MFR_VOUT_MAX_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_VOUT_MAX COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VOUT_MAX] = &PMBUS_CMD_MFR_VOUT_MAX;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VOUT_MAX] = &PMBUS_CMD_MFR_VOUT_MAX;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VOUT_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VOUT_MAX&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VOUT_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VOUT_MAX&31u));

	/* initialize command structure for MFR_IOUT_MAX. */
	// MFR_IOUT_MAX COMMAND:
	//PMBUS_CMD_MFR_IOUT_MAX.OPCODE = PMBUS_CMDCODE_MFR_IOUT_MAX;
	//PMBUS_CMD_MFR_IOUT_MAX.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_IOUT_MAX.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_IOUT_MAX.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_IOUT_MAX.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_IOUT_MAX.SUPPORTED = 1;
	//PMBUS_CMD_MFR_IOUT_MAX.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_IOUT_MAX.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_IOUT_MAX.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MFR_IOUT_MAX.RANGE = &PMBUS_CMD_MFR_IOUT_MAX_RANGE[0];
	PMBUS_CMD_MFR_IOUT_MAX_RANGE[0] = 8;
	PMBUS_CMD_MFR_IOUT_MAX_RANGE[1] = 0;
	PMBUS_CMD_MFR_IOUT_MAX.CMD_CONFIG = 0xc38223a6;
	PMBUS_CMD_MFR_IOUT_MAX.DATA0 = &PMBUS_CMD_MFR_IOUT_MAX_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_IOUT_MAX.DATA1 = &PMBUS_CMD_MFR_IOUT_MAX_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_IOUT_MAX COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_MAX] = &PMBUS_CMD_MFR_IOUT_MAX;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_MAX] = &PMBUS_CMD_MFR_IOUT_MAX;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_MAX&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_MAX&31u));

	/* initialize command structure for MFR_POUT_MAX. */
	// MFR_POUT_MAX COMMAND:
	//PMBUS_CMD_MFR_POUT_MAX.OPCODE = PMBUS_CMDCODE_MFR_POUT_MAX;
	//PMBUS_CMD_MFR_POUT_MAX.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_POUT_MAX.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_POUT_MAX.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_POUT_MAX.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_POUT_MAX.SUPPORTED = 1;
	//PMBUS_CMD_MFR_POUT_MAX.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_POUT_MAX.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_POUT_MAX.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_MFR_POUT_MAX.RANGE = &PMBUS_CMD_MFR_POUT_MAX_RANGE[0];
	PMBUS_CMD_MFR_POUT_MAX_RANGE[0] = 10;
	PMBUS_CMD_MFR_POUT_MAX_RANGE[1] = 0;
	PMBUS_CMD_MFR_POUT_MAX_RANGE[2] = 11;
	PMBUS_CMD_MFR_POUT_MAX_RANGE[3] = 31;
	PMBUS_CMD_MFR_POUT_MAX_RANGE[4] = 12;
	PMBUS_CMD_MFR_POUT_MAX_RANGE[5] = 30;
	PMBUS_CMD_MFR_POUT_MAX.CMD_CONFIG = 0xc58223a7;
	PMBUS_CMD_MFR_POUT_MAX.DATA0 = &PMBUS_CMD_MFR_POUT_MAX_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_POUT_MAX.DATA1 = &PMBUS_CMD_MFR_POUT_MAX_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_POUT_MAX COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_POUT_MAX] = &PMBUS_CMD_MFR_POUT_MAX;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_POUT_MAX] = &PMBUS_CMD_MFR_POUT_MAX;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_POUT_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_POUT_MAX&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_POUT_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_POUT_MAX&31u));

	/* initialize command structure for MFR_TAMBIENT_MAX. */
	// MFR_TAMBIENT_MAX COMMAND:
	//PMBUS_CMD_MFR_TAMBIENT_MAX.OPCODE = PMBUS_CMDCODE_MFR_TAMBIENT_MAX;
	//PMBUS_CMD_MFR_TAMBIENT_MAX.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_TAMBIENT_MAX.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_TAMBIENT_MAX.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_TAMBIENT_MAX.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_TAMBIENT_MAX.SUPPORTED = 1;
	//PMBUS_CMD_MFR_TAMBIENT_MAX.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_TAMBIENT_MAX.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_TAMBIENT_MAX.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MFR_TAMBIENT_MAX.RANGE = &PMBUS_CMD_MFR_TAMBIENT_MAX_RANGE[0];
	PMBUS_CMD_MFR_TAMBIENT_MAX_RANGE[0] = 8;
	PMBUS_CMD_MFR_TAMBIENT_MAX_RANGE[1] = 0;
	PMBUS_CMD_MFR_TAMBIENT_MAX.CMD_CONFIG = 0xc38223a8;
	PMBUS_CMD_MFR_TAMBIENT_MAX.DATA0 = &PMBUS_CMD_MFR_TAMBIENT_MAX_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_TAMBIENT_MAX.DATA1 = &PMBUS_CMD_MFR_TAMBIENT_MAX_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_TAMBIENT_MAX_DATA_LOOP1 = &PMBUS_CMD_MFR_TAMBIENT_MAX_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_TAMBIENT_MAX COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_TAMBIENT_MAX] = &PMBUS_CMD_MFR_TAMBIENT_MAX;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_TAMBIENT_MAX] = &PMBUS_CMD_MFR_TAMBIENT_MAX;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_TAMBIENT_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_TAMBIENT_MAX&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_TAMBIENT_MAX/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_TAMBIENT_MAX&31u));

	/* initialize command structure for IC_DEVICE_ID. */
	// IC_DEVICE_ID COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IC_DEVICE_ID] = PMBUS_HANDLE_IC_DEVICE_ID;
	//PMBUS_CMD_IC_DEVICE_ID.OPCODE = PMBUS_CMDCODE_IC_DEVICE_ID;
	//PMBUS_CMD_IC_DEVICE_ID.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_IC_DEVICE_ID.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_IC_DEVICE_ID.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_IC_DEVICE_ID.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IC_DEVICE_ID.SUPPORTED = 1;
	//PMBUS_CMD_IC_DEVICE_ID.PROTECTED0 = 0;
	//PMBUS_CMD_IC_DEVICE_ID.PROTECTED1 = 0;
	//PMBUS_CMD_IC_DEVICE_ID.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_IC_DEVICE_ID.CMD_CONFIG = 0x41c250ad;
	PMBUS_CMD_IC_DEVICE_ID.DATA0 = &PMBUS_CMD_IC_DEVICE_ID_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IC_DEVICE_ID.DATA1 = &PMBUS_CMD_IC_DEVICE_ID_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IC_DEVICE_ID_DATA_LOOP1 = &PMBUS_CMD_IC_DEVICE_ID_DATA_LOOP0[0];
	// RANGE SUPPORT for IC_DEVICE_ID COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IC_DEVICE_ID] = &PMBUS_CMD_IC_DEVICE_ID;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IC_DEVICE_ID] = &PMBUS_CMD_IC_DEVICE_ID;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IC_DEVICE_ID/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IC_DEVICE_ID&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IC_DEVICE_ID/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IC_DEVICE_ID&31u));

	/* initialize command structure for IC_DEVICE_REV. */
	// IC_DEVICE_REV COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_IC_DEVICE_REV] = PMBUS_HANDLE_IC_DEVICE_REV;
	//PMBUS_CMD_IC_DEVICE_REV.OPCODE = PMBUS_CMDCODE_IC_DEVICE_REV;
	//PMBUS_CMD_IC_DEVICE_REV.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_IC_DEVICE_REV.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_IC_DEVICE_REV.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_IC_DEVICE_REV.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_IC_DEVICE_REV.SUPPORTED = 1;
	//PMBUS_CMD_IC_DEVICE_REV.PROTECTED0 = 0;
	//PMBUS_CMD_IC_DEVICE_REV.PROTECTED1 = 0;
	//PMBUS_CMD_IC_DEVICE_REV.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_IC_DEVICE_REV.CMD_CONFIG = 0x41c250ae;
	PMBUS_CMD_IC_DEVICE_REV.DATA0 = &PMBUS_CMD_IC_DEVICE_REV_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IC_DEVICE_REV.DATA1 = &PMBUS_CMD_IC_DEVICE_REV_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_IC_DEVICE_REV_DATA_LOOP1 = &PMBUS_CMD_IC_DEVICE_REV_DATA_LOOP0[0];
	// RANGE SUPPORT for IC_DEVICE_REV COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_IC_DEVICE_REV] = &PMBUS_CMD_IC_DEVICE_REV;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_IC_DEVICE_REV] = &PMBUS_CMD_IC_DEVICE_REV;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_IC_DEVICE_REV/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IC_DEVICE_REV&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_IC_DEVICE_REV/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_IC_DEVICE_REV&31u));

	/* initialize command structure for USER_DATA_00. */
	// USER_DATA_00 COMMAND:
	//PMBUS_CMD_USER_DATA_00.OPCODE = PMBUS_CMDCODE_USER_DATA_00;
	//PMBUS_CMD_USER_DATA_00.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_USER_DATA_00.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_USER_DATA_00.NUM_BYTES = 16; // data only not including slave address and command
	//PMBUS_CMD_USER_DATA_00.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_USER_DATA_00.SUPPORTED = 1;
	//PMBUS_CMD_USER_DATA_00.PROTECTED0 = 0;
	//PMBUS_CMD_USER_DATA_00.PROTECTED1 = 0;
	//PMBUS_CMD_USER_DATA_00.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_USER_DATA_00.CMD_CONFIG = 0xc1d056b0;
	PMBUS_CMD_USER_DATA_00.DATA0 = &PMBUS_CMD_USER_DATA_00_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_USER_DATA_00.DATA1 = &PMBUS_CMD_USER_DATA_00_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for USER_DATA_00 COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_USER_DATA_00] = &PMBUS_CMD_USER_DATA_00;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_USER_DATA_00] = &PMBUS_CMD_USER_DATA_00;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_USER_DATA_00/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_USER_DATA_00&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_USER_DATA_00/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_USER_DATA_00&31u));

	/* initialize command structure for FW_CONFIG_PWM. */
	// FW_CONFIG_PWM COMMAND:
	//PMBUS_CMD_FW_CONFIG_PWM.OPCODE = PMBUS_CMDCODE_FW_CONFIG_PWM;
	//PMBUS_CMD_FW_CONFIG_PWM.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_FW_CONFIG_PWM.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_FW_CONFIG_PWM.NUM_BYTES = 4; // data only not including slave address and command
	//PMBUS_CMD_FW_CONFIG_PWM.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FW_CONFIG_PWM.SUPPORTED = 1;
	//PMBUS_CMD_FW_CONFIG_PWM.PROTECTED0 = 0;
	//PMBUS_CMD_FW_CONFIG_PWM.PROTECTED1 = 0;
	//PMBUS_CMD_FW_CONFIG_PWM.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_FW_CONFIG_PWM.CMD_CONFIG = 0xc1c456c4;
	PMBUS_CMD_FW_CONFIG_PWM.DATA0 = &PMBUS_CMD_FW_CONFIG_PWM_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FW_CONFIG_PWM.DATA1 = &PMBUS_CMD_FW_CONFIG_PWM_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for FW_CONFIG_PWM COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_PWM] = &PMBUS_CMD_FW_CONFIG_PWM;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_PWM] = &PMBUS_CMD_FW_CONFIG_PWM;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_PWM/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_PWM&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_PWM/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_PWM&31u));

	/* initialize command structure for FW_CONFIG_REGULATION. */
	// FW_CONFIG_REGULATION COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FW_CONFIG_REGULATION] = PMBUS_HANDLE_FW_CONFIG_REGULATION;
	//PMBUS_CMD_FW_CONFIG_REGULATION.OPCODE = PMBUS_CMDCODE_FW_CONFIG_REGULATION;
	//PMBUS_CMD_FW_CONFIG_REGULATION.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_FW_CONFIG_REGULATION.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_FW_CONFIG_REGULATION.NUM_BYTES = 14; // data only not including slave address and command
	//PMBUS_CMD_FW_CONFIG_REGULATION.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FW_CONFIG_REGULATION.SUPPORTED = 1;
	//PMBUS_CMD_FW_CONFIG_REGULATION.PROTECTED0 = 0;
	//PMBUS_CMD_FW_CONFIG_REGULATION.PROTECTED1 = 0;
	//PMBUS_CMD_FW_CONFIG_REGULATION.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_FW_CONFIG_REGULATION.CMD_CONFIG = 0xc1ce56c5;
	PMBUS_CMD_FW_CONFIG_REGULATION.DATA0 = &PMBUS_CMD_FW_CONFIG_REGULATION_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FW_CONFIG_REGULATION.DATA1 = &PMBUS_CMD_FW_CONFIG_REGULATION_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for FW_CONFIG_REGULATION COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_REGULATION] = &PMBUS_CMD_FW_CONFIG_REGULATION;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_REGULATION] = &PMBUS_CMD_FW_CONFIG_REGULATION;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_REGULATION/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_REGULATION&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_REGULATION/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_REGULATION&31u));

	/* initialize command structure for FW_CONFIG_TELEMETRY. */
	// FW_CONFIG_TELEMETRY COMMAND:
	//PMBUS_CMD_FW_CONFIG_TELEMETRY.OPCODE = PMBUS_CMDCODE_FW_CONFIG_TELEMETRY;
	//PMBUS_CMD_FW_CONFIG_TELEMETRY.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_FW_CONFIG_TELEMETRY.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_FW_CONFIG_TELEMETRY.NUM_BYTES = 21; // data only not including slave address and command
	//PMBUS_CMD_FW_CONFIG_TELEMETRY.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FW_CONFIG_TELEMETRY.SUPPORTED = 1;
	//PMBUS_CMD_FW_CONFIG_TELEMETRY.PROTECTED0 = 0;
	//PMBUS_CMD_FW_CONFIG_TELEMETRY.PROTECTED1 = 0;
	//PMBUS_CMD_FW_CONFIG_TELEMETRY.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_FW_CONFIG_TELEMETRY.CMD_CONFIG = 0xc1d556c6;
	PMBUS_CMD_FW_CONFIG_TELEMETRY.DATA0 = &PMBUS_CMD_FW_CONFIG_TELEMETRY_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FW_CONFIG_TELEMETRY.DATA1 = &PMBUS_CMD_FW_CONFIG_TELEMETRY_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for FW_CONFIG_TELEMETRY COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_TELEMETRY] = &PMBUS_CMD_FW_CONFIG_TELEMETRY;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_TELEMETRY] = &PMBUS_CMD_FW_CONFIG_TELEMETRY;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_TELEMETRY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_TELEMETRY&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_TELEMETRY/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_TELEMETRY&31u));

	/* initialize command structure for FW_CONFIG_FAULTS. */
	// FW_CONFIG_FAULTS COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FW_CONFIG_FAULTS] = PMBUS_HANDLE_FW_CONFIG_FAULTS;
	//PMBUS_CMD_FW_CONFIG_FAULTS.OPCODE = PMBUS_CMDCODE_FW_CONFIG_FAULTS;
	//PMBUS_CMD_FW_CONFIG_FAULTS.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_FW_CONFIG_FAULTS.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_FW_CONFIG_FAULTS.NUM_BYTES = 25; // data only not including slave address and command
	//PMBUS_CMD_FW_CONFIG_FAULTS.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FW_CONFIG_FAULTS.SUPPORTED = 1;
	//PMBUS_CMD_FW_CONFIG_FAULTS.PROTECTED0 = 0;
	//PMBUS_CMD_FW_CONFIG_FAULTS.PROTECTED1 = 0;
	//PMBUS_CMD_FW_CONFIG_FAULTS.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_FW_CONFIG_FAULTS.CMD_CONFIG = 0xc1d956c8;
	PMBUS_CMD_FW_CONFIG_FAULTS.DATA0 = &PMBUS_CMD_FW_CONFIG_FAULTS_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FW_CONFIG_FAULTS.DATA1 = &PMBUS_CMD_FW_CONFIG_FAULTS_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for FW_CONFIG_FAULTS COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_FAULTS] = &PMBUS_CMD_FW_CONFIG_FAULTS;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_FAULTS] = &PMBUS_CMD_FW_CONFIG_FAULTS;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_FAULTS/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_FAULTS&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_FAULTS/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_FAULTS&31u));

	/* initialize command structure for FW_CONFIG_PMBUS. */
	// FW_CONFIG_PMBUS COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FW_CONFIG_PMBUS] = PMBUS_HANDLE_FW_CONFIG_PMBUS;
	//PMBUS_CMD_FW_CONFIG_PMBUS.OPCODE = PMBUS_CMDCODE_FW_CONFIG_PMBUS;
	//PMBUS_CMD_FW_CONFIG_PMBUS.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_FW_CONFIG_PMBUS.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_FW_CONFIG_PMBUS.NUM_BYTES = 11; // data only not including slave address and command
	//PMBUS_CMD_FW_CONFIG_PMBUS.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FW_CONFIG_PMBUS.SUPPORTED = 1;
	//PMBUS_CMD_FW_CONFIG_PMBUS.PROTECTED0 = 0;
	//PMBUS_CMD_FW_CONFIG_PMBUS.PROTECTED1 = 0;
	//PMBUS_CMD_FW_CONFIG_PMBUS.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_FW_CONFIG_PMBUS.CMD_CONFIG = 0xc1cb56c9;
	PMBUS_CMD_FW_CONFIG_PMBUS.DATA0 = &PMBUS_CMD_FW_CONFIG_PMBUS_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FW_CONFIG_PMBUS.DATA1 = &PMBUS_CMD_FW_CONFIG_PMBUS_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for FW_CONFIG_PMBUS COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_PMBUS] = &PMBUS_CMD_FW_CONFIG_PMBUS;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_PMBUS] = &PMBUS_CMD_FW_CONFIG_PMBUS;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_PMBUS/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_PMBUS&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_PMBUS/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_PMBUS&31u));

	/* initialize command structure for MFR_IOUT_OC_FAST_FAULT_RESPONSE. */
	// MFR_IOUT_OC_FAST_FAULT_RESPONSE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_RESPONSE] = PMBUS_HANDLE_MFR_IOUT_OC_FAST_FAULT_RESPONSE;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.OPCODE = PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_RESPONSE;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_MFR_IOUT_OC_FAST_FAULT_RESPONSE;
	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.CMD_CONFIG = 0xcb8123ca;
	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.DATA0 = &PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE.DATA1 = &PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_IOUT_OC_FAST_FAULT_RESPONSE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_RESPONSE] = &PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_RESPONSE] = &PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_RESPONSE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_RESPONSE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_RESPONSE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_RESPONSE&31u));

	/* initialize command structure for FW_CONFIG_DE_THRESH. */
	// FW_CONFIG_DE_THRESH COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_FW_CONFIG_DE_THRESH] = PMBUS_HANDLE_FW_CONFIG_DE_THRESH;
	//PMBUS_CMD_FW_CONFIG_DE_THRESH.OPCODE = PMBUS_CMDCODE_FW_CONFIG_DE_THRESH;
	//PMBUS_CMD_FW_CONFIG_DE_THRESH.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_FW_CONFIG_DE_THRESH.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_FW_CONFIG_DE_THRESH.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_FW_CONFIG_DE_THRESH.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FW_CONFIG_DE_THRESH.SUPPORTED = 1;
	//PMBUS_CMD_FW_CONFIG_DE_THRESH.PROTECTED0 = 0;
	//PMBUS_CMD_FW_CONFIG_DE_THRESH.PROTECTED1 = 0;
	//PMBUS_CMD_FW_CONFIG_DE_THRESH.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_SIGNED;
	PMBUS_CMD_FW_CONFIG_DE_THRESH.RANGE = &PMBUS_CMD_FW_CONFIG_DE_THRESH_RANGE[0];
	PMBUS_CMD_FW_CONFIG_DE_THRESH_RANGE[0] = 9;
	PMBUS_CMD_FW_CONFIG_DE_THRESH_RANGE[1] = 2;
	PMBUS_CMD_FW_CONFIG_DE_THRESH.CMD_CONFIG = 0xc28223cb;
	PMBUS_CMD_FW_CONFIG_DE_THRESH.DATA0 = &PMBUS_CMD_FW_CONFIG_DE_THRESH_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FW_CONFIG_DE_THRESH.DATA1 = &PMBUS_CMD_FW_CONFIG_DE_THRESH_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for FW_CONFIG_DE_THRESH COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_DE_THRESH] = &PMBUS_CMD_FW_CONFIG_DE_THRESH;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_DE_THRESH] = &PMBUS_CMD_FW_CONFIG_DE_THRESH;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_DE_THRESH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_DE_THRESH&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_DE_THRESH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_DE_THRESH&31u));

	/* initialize command structure for MFR_VRECT_SCALE. */
	// MFR_VRECT_SCALE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_VRECT_SCALE] = PMBUS_HANDLE_VOUT_SCALE_LOOP;
	//PMBUS_CMD_MFR_VRECT_SCALE.OPCODE = PMBUS_CMDCODE_MFR_VRECT_SCALE;
	//PMBUS_CMD_MFR_VRECT_SCALE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_VRECT_SCALE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_VRECT_SCALE.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_VRECT_SCALE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_VRECT_SCALE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_VRECT_SCALE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_VRECT_SCALE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_VRECT_SCALE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MFR_VRECT_SCALE.RANGE = &PMBUS_CMD_MFR_VRECT_SCALE_RANGE[0];
	PMBUS_CMD_MFR_VRECT_SCALE_RANGE[0] = 0;
	PMBUS_CMD_MFR_VRECT_SCALE_RANGE[1] = 10;
	PMBUS_CMD_MFR_VRECT_SCALE.CMD_CONFIG = 0xc38223cd;
	PMBUS_CMD_MFR_VRECT_SCALE.DATA0 = &PMBUS_CMD_MFR_VRECT_SCALE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_VRECT_SCALE.DATA1 = &PMBUS_CMD_MFR_VRECT_SCALE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_VRECT_SCALE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VRECT_SCALE] = &PMBUS_CMD_MFR_VRECT_SCALE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VRECT_SCALE] = &PMBUS_CMD_MFR_VRECT_SCALE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_VRECT_SCALE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VRECT_SCALE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_VRECT_SCALE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_VRECT_SCALE&31u));

	/* initialize command structure for MFR_TRANSFORMER_SCALE. */
	// MFR_TRANSFORMER_SCALE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_TRANSFORMER_SCALE] = PMBUS_HANDLE_VOUT_SCALE_LOOP;
	//PMBUS_CMD_MFR_TRANSFORMER_SCALE.OPCODE = PMBUS_CMDCODE_MFR_TRANSFORMER_SCALE;
	//PMBUS_CMD_MFR_TRANSFORMER_SCALE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_TRANSFORMER_SCALE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_TRANSFORMER_SCALE.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_TRANSFORMER_SCALE.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_TRANSFORMER_SCALE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_TRANSFORMER_SCALE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_TRANSFORMER_SCALE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_TRANSFORMER_SCALE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MFR_TRANSFORMER_SCALE.RANGE = &PMBUS_CMD_MFR_TRANSFORMER_SCALE_RANGE[0];
	PMBUS_CMD_MFR_TRANSFORMER_SCALE_RANGE[0] = 0;
	PMBUS_CMD_MFR_TRANSFORMER_SCALE_RANGE[1] = 10;
	PMBUS_CMD_MFR_TRANSFORMER_SCALE.CMD_CONFIG = 0xc38223ce;
	PMBUS_CMD_MFR_TRANSFORMER_SCALE.DATA0 = &PMBUS_CMD_MFR_TRANSFORMER_SCALE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_TRANSFORMER_SCALE.DATA1 = &PMBUS_CMD_MFR_TRANSFORMER_SCALE_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_TRANSFORMER_SCALE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_TRANSFORMER_SCALE] = &PMBUS_CMD_MFR_TRANSFORMER_SCALE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_TRANSFORMER_SCALE] = &PMBUS_CMD_MFR_TRANSFORMER_SCALE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_TRANSFORMER_SCALE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_TRANSFORMER_SCALE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_TRANSFORMER_SCALE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_TRANSFORMER_SCALE&31u));

	/* initialize command structure for PWM_DEADTIME. */
	// PWM_DEADTIME COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_PWM_DEADTIME] = PMBUS_HANDLE_PWM_DEADTIME;
	//PMBUS_CMD_PWM_DEADTIME.OPCODE = PMBUS_CMDCODE_PWM_DEADTIME;
	//PMBUS_CMD_PWM_DEADTIME.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_PWM_DEADTIME.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_PWM_DEADTIME.NUM_BYTES = 24; // data only not including slave address and command
	//PMBUS_CMD_PWM_DEADTIME.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_PWM_DEADTIME.SUPPORTED = 1;
	//PMBUS_CMD_PWM_DEADTIME.PROTECTED0 = 0;
	//PMBUS_CMD_PWM_DEADTIME.PROTECTED1 = 0;
	//PMBUS_CMD_PWM_DEADTIME.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_PWM_DEADTIME.CMD_CONFIG = 0xc1d856cf;
	PMBUS_CMD_PWM_DEADTIME.DATA0 = &PMBUS_CMD_PWM_DEADTIME_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_PWM_DEADTIME.DATA1 = &PMBUS_CMD_PWM_DEADTIME_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_PWM_DEADTIME_DATA_LOOP1 = &PMBUS_CMD_PWM_DEADTIME_DATA_LOOP0[0];
	// RANGE SUPPORT for PWM_DEADTIME COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_PWM_DEADTIME] = &PMBUS_CMD_PWM_DEADTIME;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_PWM_DEADTIME] = &PMBUS_CMD_PWM_DEADTIME;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_PWM_DEADTIME/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_PWM_DEADTIME&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_PWM_DEADTIME/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_PWM_DEADTIME&31u));

	/* initialize command structure for MFR_IOUT_OC_FAST_FAULT_LIMIT. */
	// MFR_IOUT_OC_FAST_FAULT_LIMIT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_LIMIT] = PMBUS_HANDLE_MFR_IOUT_OC_FAST_FAULT_LIMIT;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.OPCODE = PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_LIMIT;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.SUPPORTED = 1;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.RANGE = &PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT_RANGE[0];
	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT_RANGE[0] = 8;
	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT_RANGE[1] = 0;
	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.CMD_CONFIG = 0xc38223d1;
	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.DATA0 = &PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT.DATA1 = &PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_IOUT_OC_FAST_FAULT_LIMIT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_LIMIT] = &PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_LIMIT] = &PMBUS_CMD_MFR_IOUT_OC_FAST_FAULT_LIMIT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_LIMIT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_LIMIT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_OC_FAST_FAULT_LIMIT&31u));

	/* initialize command structure for PWM_DEADTIME_ADJUSTMENT. */
	// PWM_DEADTIME_ADJUSTMENT COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_PWM_DEADTIME_ADJUSTMENT] = PMBUS_HANDLE_PWM_DEADTIME_ADJUSTMENT;
	//PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.OPCODE = PMBUS_CMDCODE_PWM_DEADTIME_ADJUSTMENT;
	//PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.NUM_BYTES = 24; // data only not including slave address and command
	//PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.SUPPORTED = 1;
	//PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.PROTECTED0 = 0;
	//PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.PROTECTED1 = 0;
	//PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.CMD_CONFIG = 0xc1d856d6;
	PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.DATA0 = &PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT.DATA1 = &PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT_DATA_LOOP1 = &PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT_DATA_LOOP0[0];
	// RANGE SUPPORT for PWM_DEADTIME_ADJUSTMENT COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_PWM_DEADTIME_ADJUSTMENT] = &PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_PWM_DEADTIME_ADJUSTMENT] = &PMBUS_CMD_PWM_DEADTIME_ADJUSTMENT;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_PWM_DEADTIME_ADJUSTMENT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_PWM_DEADTIME_ADJUSTMENT&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_PWM_DEADTIME_ADJUSTMENT/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_PWM_DEADTIME_ADJUSTMENT&31u));

	/* initialize command structure for MFR_SELECT_TEMPERATURE_SENSOR. */
	// MFR_SELECT_TEMPERATURE_SENSOR COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_SELECT_TEMPERATURE_SENSOR] = PMBUS_HANDLE_MFR_SELECT_TEMPERATURE_SENSOR;
	//PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.OPCODE = PMBUS_CMDCODE_MFR_SELECT_TEMPERATURE_SENSOR;
	//PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.CMD_CONFIG = 0xc18123dc;
	PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.DATA0 = &PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR.DATA1 = &PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_SELECT_TEMPERATURE_SENSOR COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SELECT_TEMPERATURE_SENSOR] = &PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SELECT_TEMPERATURE_SENSOR] = &PMBUS_CMD_MFR_SELECT_TEMPERATURE_SENSOR;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SELECT_TEMPERATURE_SENSOR/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SELECT_TEMPERATURE_SENSOR&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SELECT_TEMPERATURE_SENSOR/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SELECT_TEMPERATURE_SENSOR&31u));

	/* initialize command structure for FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD. */
	// FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD COMMAND:
	//PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.OPCODE = PMBUS_CMDCODE_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD;
	//PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.SUPPORTED = 1;
	//PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.PROTECTED0 = 0;
	//PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.PROTECTED1 = 0;
	//PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_SIGNED;
	PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.RANGE = &PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD_RANGE[0];
	PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD_RANGE[0] = 9;
	PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD_RANGE[1] = 2;
	PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.CMD_CONFIG = 0xc28223e4;
	PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.DATA0 = &PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD.DATA1 = &PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD] = &PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD] = &PMBUS_CMD_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_FW_CONFIG_DEADTIME_ADJUSMENT_THRESHOLD&31u));

	/* initialize command structure for MFR_IOUT_APC. */
	// MFR_IOUT_APC COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_IOUT_APC] = PMBUS_HANDLE_MFR_IOUT_APC;
	//PMBUS_CMD_MFR_IOUT_APC.OPCODE = PMBUS_CMDCODE_MFR_IOUT_APC;
	//PMBUS_CMD_MFR_IOUT_APC.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_IOUT_APC.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_IOUT_APC.NUM_BYTES = 2; // data only not including slave address and command
	//PMBUS_CMD_MFR_IOUT_APC.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_IOUT_APC.SUPPORTED = 1;
	//PMBUS_CMD_MFR_IOUT_APC.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_IOUT_APC.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_IOUT_APC.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED_ARRAY;
	PMBUS_CMD_MFR_IOUT_APC.RANGE = &PMBUS_CMD_MFR_IOUT_APC_RANGE[0];
	PMBUS_CMD_MFR_IOUT_APC_RANGE[0] = 1;
	PMBUS_CMD_MFR_IOUT_APC_RANGE[1] = 9;
	PMBUS_CMD_MFR_IOUT_APC_RANGE[2] = 2;
	PMBUS_CMD_MFR_IOUT_APC_RANGE[3] = 8;
	PMBUS_CMD_MFR_IOUT_APC.CMD_CONFIG = 0xc58223ea;
	PMBUS_CMD_MFR_IOUT_APC.DATA0 = &PMBUS_CMD_MFR_IOUT_APC_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_IOUT_APC.DATA1 = &PMBUS_CMD_MFR_IOUT_APC_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_IOUT_APC COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_APC] = &PMBUS_CMD_MFR_IOUT_APC;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_APC] = &PMBUS_CMD_MFR_IOUT_APC;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_IOUT_APC/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_APC&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_IOUT_APC/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_IOUT_APC&31u));

	/* initialize command structure for MFR_MIN_PW. */
	// MFR_MIN_PW COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_MIN_PW] = PMBUS_HANDLE_MFR_MIN_PW;
	//PMBUS_CMD_MFR_MIN_PW.OPCODE = PMBUS_CMDCODE_MFR_MIN_PW;
	//PMBUS_CMD_MFR_MIN_PW.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_MIN_PW.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_READ;
	//PMBUS_CMD_MFR_MIN_PW.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_MIN_PW.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_MIN_PW.SUPPORTED = 1;
	//PMBUS_CMD_MFR_MIN_PW.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_MIN_PW.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_MIN_PW.RANGE_TYPE = (uint8_t) PMBUS_RANGE_LINEAR11_UNSIGNED;
	PMBUS_CMD_MFR_MIN_PW.RANGE = &PMBUS_CMD_MFR_MIN_PW_RANGE[0];
	PMBUS_CMD_MFR_MIN_PW_RANGE[0] = 8;
	PMBUS_CMD_MFR_MIN_PW_RANGE[1] = 0;
	PMBUS_CMD_MFR_MIN_PW.CMD_CONFIG = 0xc38123eb;
	PMBUS_CMD_MFR_MIN_PW.DATA0 = &PMBUS_CMD_MFR_MIN_PW_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_MIN_PW.DATA1 = &PMBUS_CMD_MFR_MIN_PW_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_MIN_PW COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_MIN_PW] = &PMBUS_CMD_MFR_MIN_PW;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_MIN_PW] = &PMBUS_CMD_MFR_MIN_PW;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_MIN_PW/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_MIN_PW&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_MIN_PW/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_MIN_PW&31u));

	/* initialize command structure for MFR_DEBUG_BUFF. */
	// MFR_DEBUG_BUFF COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_DEBUG_BUFF] = PMBUS_HANDLE_MFR_DEBUG_BUFF;
	//PMBUS_CMD_MFR_DEBUG_BUFF.OPCODE = PMBUS_CMDCODE_MFR_DEBUG_BUFF;
	//PMBUS_CMD_MFR_DEBUG_BUFF.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_MFR_DEBUG_BUFF.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_DEBUG_BUFF.NUM_BYTES = 8; // data only not including slave address and command
	//PMBUS_CMD_MFR_DEBUG_BUFF.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_DEBUG_BUFF.SUPPORTED = 1;
	//PMBUS_CMD_MFR_DEBUG_BUFF.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_DEBUG_BUFF.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_DEBUG_BUFF.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_DEBUG_BUFF.CMD_CONFIG = 0x41c850f0;
	PMBUS_CMD_MFR_DEBUG_BUFF.DATA0 = &PMBUS_CMD_MFR_DEBUG_BUFF_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_DEBUG_BUFF.DATA1 = &PMBUS_CMD_MFR_DEBUG_BUFF_DATA_LOOP1[0];  // set the pointer to the data array
	// RANGE SUPPORT for MFR_DEBUG_BUFF COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_DEBUG_BUFF] = &PMBUS_CMD_MFR_DEBUG_BUFF;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_DEBUG_BUFF] = &PMBUS_CMD_MFR_DEBUG_BUFF;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_DEBUG_BUFF/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_DEBUG_BUFF&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_DEBUG_BUFF/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_DEBUG_BUFF&31u));

	/* initialize command structure for MFR_SETUP_PASSWORD. */
	// MFR_SETUP_PASSWORD COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_SETUP_PASSWORD] = PMBUS_HANDLE_MFR_SETUP_PASSWORD;
	//PMBUS_CMD_MFR_SETUP_PASSWORD.OPCODE = PMBUS_CMDCODE_MFR_SETUP_PASSWORD;
	//PMBUS_CMD_MFR_SETUP_PASSWORD.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_SETUP_PASSWORD.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_SETUP_PASSWORD.NUM_BYTES = 6; // data only not including slave address and command
	//PMBUS_CMD_MFR_SETUP_PASSWORD.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SETUP_PASSWORD.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SETUP_PASSWORD.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SETUP_PASSWORD.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SETUP_PASSWORD.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SETUP_PASSWORD.CMD_CONFIG = 0xc1c656f1;
	PMBUS_CMD_MFR_SETUP_PASSWORD.DATA0 = &PMBUS_CMD_MFR_SETUP_PASSWORD_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SETUP_PASSWORD.DATA1 = &PMBUS_CMD_MFR_SETUP_PASSWORD_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SETUP_PASSWORD_DATA_LOOP1 = &PMBUS_CMD_MFR_SETUP_PASSWORD_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_SETUP_PASSWORD COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SETUP_PASSWORD] = &PMBUS_CMD_MFR_SETUP_PASSWORD;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SETUP_PASSWORD] = &PMBUS_CMD_MFR_SETUP_PASSWORD;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SETUP_PASSWORD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SETUP_PASSWORD&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SETUP_PASSWORD/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SETUP_PASSWORD&31u));

	/* initialize command structure for MFR_DISABLE_SECURITY_ONCE. */
	// MFR_DISABLE_SECURITY_ONCE COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_DISABLE_SECURITY_ONCE] = PMBUS_HANDLE_MFR_DISABLE_SECURITY_ONCE;
	//PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.OPCODE = PMBUS_CMDCODE_MFR_DISABLE_SECURITY_ONCE;
	//PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.NUM_BYTES = 6; // data only not including slave address and command
	//PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.SUPPORTED = 1;
	//PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.CMD_CONFIG = 0x41c656f2;
	PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.DATA0 = &PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE.DATA1 = &PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE_DATA_LOOP1 = &PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_DISABLE_SECURITY_ONCE COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_DISABLE_SECURITY_ONCE] = &PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_DISABLE_SECURITY_ONCE] = &PMBUS_CMD_MFR_DISABLE_SECURITY_ONCE;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_DISABLE_SECURITY_ONCE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_DISABLE_SECURITY_ONCE&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_DISABLE_SECURITY_ONCE/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_DISABLE_SECURITY_ONCE&31u));

	/* initialize command structure for MFR_SECURITY_BIT_MASK_LOW. */
	// MFR_SECURITY_BIT_MASK_LOW COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_LOW] = PMBUS_HANDLE_MFR_SECURITY_BIT_MASK_LOW;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.OPCODE = PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_LOW;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.NUM_BYTES = 16; // data only not including slave address and command
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.CMD_CONFIG = 0xc1d056f4;
	PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.DATA0 = &PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW.DATA1 = &PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW_DATA_LOOP1 = &PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_SECURITY_BIT_MASK_LOW COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_LOW] = &PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_LOW] = &PMBUS_CMD_MFR_SECURITY_BIT_MASK_LOW;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_LOW/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_LOW&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_LOW/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_LOW&31u));

	/* initialize command structure for MFR_SECURITY_BIT_MASK_HIGH. */
	// MFR_SECURITY_BIT_MASK_HIGH COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_HIGH] = PMBUS_HANDLE_MFR_SECURITY_BIT_MASK_HIGH;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.OPCODE = PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_HIGH;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.NUM_BYTES = 16; // data only not including slave address and command
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.SUPPORTED = 1;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.CMD_CONFIG = 0xc1d056f5;
	PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.DATA0 = &PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH.DATA1 = &PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH_DATA_LOOP1 = &PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_SECURITY_BIT_MASK_HIGH COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_HIGH] = &PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_HIGH] = &PMBUS_CMD_MFR_SECURITY_BIT_MASK_HIGH;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_HIGH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_HIGH&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_HIGH/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_SECURITY_BIT_MASK_HIGH&31u));

	/* initialize command structure for MFR_FIRMWARE_COMMAND_DATA. */
	// MFR_FIRMWARE_COMMAND_DATA COMMAND:
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.OPCODE = PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND_DATA;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_WRITE;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_BLOCK_READ;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.NUM_BYTES = 4; // data only not including slave address and command
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.NUM_PROTOCOL_BYTES = 3;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.SUPPORTED = 1;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.CMD_CONFIG = 0x41c456fd;
	PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.DATA0 = &PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA.DATA1 = &PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_DATA_LOOP1 = &PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_FIRMWARE_COMMAND_DATA COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND_DATA] = &PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND_DATA] = &PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND_DATA/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND_DATA&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND_DATA/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND_DATA&31u));

	/* initialize command structure for MFR_FIRMWARE_COMMAND. */
	// MFR_FIRMWARE_COMMAND COMMAND:
	ptr_pmbus_callback[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND] = PMBUS_HANDLE_MFR_FIRMWARE_COMMAND;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND.OPCODE = PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND.WRITE_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_WRITE;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND.READ_PROTOCOL = (uint8_t) TRANSACTION_PROTOCOL_NONE;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND.NUM_BYTES = 1; // data only not including slave address and command
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND.NUM_PROTOCOL_BYTES = 2;  // slave address command and any other non-data bytes
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND.SUPPORTED = 1;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND.PROTECTED0 = 0;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND.PROTECTED1 = 0;
	//PMBUS_CMD_MFR_FIRMWARE_COMMAND.RANGE_TYPE = (uint8_t) PMBUS_RANGE_ALL;
	PMBUS_CMD_MFR_FIRMWARE_COMMAND.CMD_CONFIG = 0x418103fe;
	PMBUS_CMD_MFR_FIRMWARE_COMMAND.DATA0 = &PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_FIRMWARE_COMMAND.DATA1 = &PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_LOOP0[0];  // set the pointer to the data array
	PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_LOOP1 = &PMBUS_CMD_MFR_FIRMWARE_COMMAND_DATA_LOOP0[0];
	// RANGE SUPPORT for MFR_FIRMWARE_COMMAND COMMAND:
	// now populate pointers to the supported commands for each page
	PMBUS_CMD_ARRAY_LOOP[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND] = &PMBUS_CMD_MFR_FIRMWARE_COMMAND;
	//PMBUS_CMD_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND] = &PMBUS_CMD_MFR_FIRMWARE_COMMAND;
	//lint -e{778} suppress "Constant expression evaluates to 0 in operation '&'" 
	PMBUS_CMD_SUPPORT_ARRAY_LOOP[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND&31u));
	//PMBUS_CMD_SUPPORT_ARRAY_LOOP1[PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND/32] |= (uint32_t) ((uint32_t)1u << ((uint32_t)PMBUS_CMDCODE_MFR_FIRMWARE_COMMAND&31u));

	// Here we call all the command handles with OTP restore direction
	if (ptr_mfr_specific_init != (mfr_specific_init_ptr)NULL)
	{
		(*ptr_mfr_specific_init)();
	}

	PMBUS_CMD_HANDLER(PMBUS_PAGE_0, PMBUS_CMDCODE_RESTORE_DEFAULT_ALL, PMBUS_WRITE); // trigger data restore from OTP configurator
	PMBUS_CMD_HANDLER(PMBUS_PAGE_1, PMBUS_CMDCODE_RESTORE_DEFAULT_ALL, PMBUS_WRITE); // trigger data restore from OTP configurator
	PMBUS_CMD_HANDLER(PMBUS_PAGE_0, PMBUS_CMDCODE_RESTORE_USER_ALL, PMBUS_WRITE); // trigger data restore from OTP configurator
	PMBUS_CMD_HANDLER(PMBUS_PAGE_1, PMBUS_CMDCODE_RESTORE_USER_ALL, PMBUS_WRITE); // trigger data restore from OTP configurator
	//PMBUS_CMD_HANDLER(0xff, PMBUS_CMDCODE_RESTORE_USER_ALL, PMBUS_WRITE);
	
	//for(uint32_t cmd = 1u; cmd < 255u; cmd++)  
	//{
	//	PMBUS_CMD_HANDLER(PMBUS_PAGE_0, cmd, OTP_RESTORE);  // execute all the commands that need to be from OTP restore
	//	PMBUS_CMD_HANDLER(PMBUS_PAGE_1, cmd, OTP_RESTORE);  // execute all the commands that need to be from OTP restore
	//}
	// do write protect and operation last in sequence:
	//PMBUS_CMD_HANDLER(PMBUS_PAGE_0, PMBUS_CMDCODE_WRITE_PROTECT, PMBUS_WRITE);
 	//PMBUS_CMD_HANDLER(PMBUS_PAGE_1, PMBUS_CMDCODE_WRITE_PROTECT, PMBUS_WRITE);       
        
}


/*
* Function to handle all pmbus commands.  Decodes proper callback/handle function based on command number
* @param page Loop to operate on.  Only supports 0 or 1.  Broadcast MUST be handled upstream.
* @param command Pmbus command number to handle.
* @param direction PMBUS_DIRECTION_e type direction to handle.  Can indicate read/write peek/poke otp restore types.
*/
void PMBUS_CMD_HANDLER(PMBUS_PAGE_t page, uint8_t command, PMBUS_DIRECTION_e direction)
{
	// so we divide out the array assuming max of 16 controls and expect only 7 states to exist but could expand.
	// we take state and <<4 to do the state*16 controls.  Then we add control as an offset for the index of array.
	pmbus_callback ptr_pmbus_cb = ptr_pmbus_callback[(uint32_t)(command)];

	// check if pointer is null and if not null call it
	if (ptr_pmbus_cb != (pmbus_callback)NULL)
	{
		(*ptr_pmbus_cb)((PMBUS_PAGE_t) page, direction);
	}
}
