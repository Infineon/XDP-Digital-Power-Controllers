/**
 * @file     shasta_hal_tstctrl.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_TSTCTRL_H_
#define _SHASTA_HAL_TSTCTRL_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup tstctrl
 * @{
 */

#if defined ( __CC_ARM )
#define __TSTCTRL_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __TSTCTRL_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __TSTCTRL_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __TSTCTRL_INLINE  static inline
#endif

/** register file of the tstctrl block.
 */
typedef struct _TSTCTRL_s
{
    volatile        uint32_t        ATE_TEST_MODE               ; /*!< (@0x00000000) ATE TEST MODE Register */
    volatile        uint32_t        TEST_CONF                   ; /*!< (@0x00000004) IDCODE register  */
    volatile        uint32_t        MBIST                       ; /*!< (@0x00000008) IDCODE register  */
    volatile        uint32_t        ROM_MISR                    ; /*!< (@0x0000000C) ROM MISR Register */
    volatile        uint32_t        SYSRESET                    ; /*!< (@0x00000010) SYSRESET Register */
} TSTCTRL_t;


#define TSTCTRL_BASE (0x40005000u)                                                          /*!< tstctrl base address */

/** __TSTCTRL_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__TSTCTRL_INLINE uint32_t* __TSTCTRL_BASE_PTR(void)
{
    return (uint32_t*)(TSTCTRL_BASE);
}


/* -------------------------------------------------------------------------- */
/*                     ATE_TEST_MODE member of TSTCTRL_t                     */
/* -------------------------------------------------------------------------- */

/** __TSTCTRL_ATE_TEST_MODE__ADDRESS returns the address of member ATE_TEST_MODE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ATE_TEST_MODE
 */
__TSTCTRL_INLINE uint32_t* __TSTCTRL_ATE_TEST_MODE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSTCTRL_BASE_PTR() + (uint32_t)(offsetof(TSTCTRL_t, ATE_TEST_MODE)));
}

/** TSTCTRL_ATE_TEST_MODE__GET() gets ATE_TEST_MODE's current value.
 *
 * When reading from ATE_TEST_MODE, this is mandatory to use.
 *
 * @return current value of ATE_TEST_MODE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_ATE_TEST_MODE__GET(void)
{
    return HAL_GET32(__TSTCTRL_ATE_TEST_MODE__ADDRESS());
}

/* -------------------- TSTCTRL.ATE_TEST_MODE.XADDR1_IN -------------------- */

/**
<pre>
  TSTCTRL.ATE_TEST_MODE.XADDR1_IN:

    1: XADDR1_IN input buffer at Logic1

</pre> */

#define TSTCTRL_ATE_TEST_MODE__XADDR1_IN__Pos                   17                                                                     /*!< Right-most bit position of XADDR1_IN in TSTCTRL.ATE_TEST_MODE */
#define TSTCTRL_ATE_TEST_MODE__XADDR1_IN__Msk                   (0x00000001UL << TSTCTRL_ATE_TEST_MODE__XADDR1_IN__Pos)                /*!< Mask for XADDR1_IN in TSTCTRL.ATE_TEST_MODE */
#define TSTCTRL_ATE_TEST_MODE__XADDR1_IN__Shift(v)              (((v) << TSTCTRL_ATE_TEST_MODE__XADDR1_IN__Pos) & TSTCTRL_ATE_TEST_MODE__XADDR1_IN__Msk) /*!< Shift value 'v' into XADDR1_IN and mask 'v' to fit it into XADDR1_IN field */

/** TSTCTRL_ATE_TEST_MODE__XADDR1_IN__GET() gets ATE_TEST_MODE.XADDR1_IN's current value.
 *
 * When reading from ATE_TEST_MODE.XADDR1_IN, this is recommended to use.
 *
 * @return current value of ATE_TEST_MODE.XADDR1_IN
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_ATE_TEST_MODE__XADDR1_IN__GET(void)
{
    uint32_t reg = TSTCTRL_ATE_TEST_MODE__GET();
    reg = (reg & TSTCTRL_ATE_TEST_MODE__XADDR1_IN__Msk);
    reg = (reg >> TSTCTRL_ATE_TEST_MODE__XADDR1_IN__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_ATE_TEST_MODE__XADDR1_IN__EXTRACT() extracts ATE_TEST_MODE.XADDR1_IN.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.ATE_TEST_MODE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.ATE_TEST_MODE
 * @return current value of ATE_TEST_MODE.XADDR1_IN
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_ATE_TEST_MODE__XADDR1_IN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_ATE_TEST_MODE__XADDR1_IN__Msk);
    reg = (reg >> TSTCTRL_ATE_TEST_MODE__XADDR1_IN__Pos);
    return (uint32_t)reg;
}

/* -------------------- TSTCTRL.ATE_TEST_MODE.TEST_GATE -------------------- */

/**
<pre>
  TSTCTRL.ATE_TEST_MODE.TEST_GATE:

    1: XADDR1_IN Latched Logic1


</pre> */

#define TSTCTRL_ATE_TEST_MODE__TEST_GATE__Pos                   16                                                                     /*!< Right-most bit position of TEST_GATE in TSTCTRL.ATE_TEST_MODE */
#define TSTCTRL_ATE_TEST_MODE__TEST_GATE__Msk                   (0x00000001UL << TSTCTRL_ATE_TEST_MODE__TEST_GATE__Pos)                /*!< Mask for TEST_GATE in TSTCTRL.ATE_TEST_MODE */
#define TSTCTRL_ATE_TEST_MODE__TEST_GATE__Shift(v)              (((v) << TSTCTRL_ATE_TEST_MODE__TEST_GATE__Pos) & TSTCTRL_ATE_TEST_MODE__TEST_GATE__Msk) /*!< Shift value 'v' into TEST_GATE and mask 'v' to fit it into TEST_GATE field */

/** TSTCTRL_ATE_TEST_MODE__TEST_GATE__GET() gets ATE_TEST_MODE.TEST_GATE's current value.
 *
 * When reading from ATE_TEST_MODE.TEST_GATE, this is recommended to use.
 *
 * @return current value of ATE_TEST_MODE.TEST_GATE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_ATE_TEST_MODE__TEST_GATE__GET(void)
{
    uint32_t reg = TSTCTRL_ATE_TEST_MODE__GET();
    reg = (reg & TSTCTRL_ATE_TEST_MODE__TEST_GATE__Msk);
    reg = (reg >> TSTCTRL_ATE_TEST_MODE__TEST_GATE__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_ATE_TEST_MODE__TEST_GATE__EXTRACT() extracts ATE_TEST_MODE.TEST_GATE.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.ATE_TEST_MODE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.ATE_TEST_MODE
 * @return current value of ATE_TEST_MODE.TEST_GATE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_ATE_TEST_MODE__TEST_GATE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_ATE_TEST_MODE__TEST_GATE__Msk);
    reg = (reg >> TSTCTRL_ATE_TEST_MODE__TEST_GATE__Pos);
    return (uint32_t)reg;
}

/* ------------------- TSTCTRL.ATE_TEST_MODE.ATE_TM_STATE ------------------- */

/**
<pre>
  TSTCTRL.ATE_TEST_MODE.ATE_TM_STATE:

    1: TEST MODE ON

</pre> */

#define TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__Pos                0                                                                      /*!< Right-most bit position of ATE_TM_STATE in TSTCTRL.ATE_TEST_MODE */
#define TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__Msk                (0x00000001UL << TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__Pos)             /*!< Mask for ATE_TM_STATE in TSTCTRL.ATE_TEST_MODE */
#define TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__Shift(v)           (((v) << TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__Pos) & TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__Msk) /*!< Shift value 'v' into ATE_TM_STATE and mask 'v' to fit it into ATE_TM_STATE field */

/** TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__GET() gets ATE_TEST_MODE.ATE_TM_STATE's current value.
 *
 * When reading from ATE_TEST_MODE.ATE_TM_STATE, this is recommended to use.
 *
 * @return current value of ATE_TEST_MODE.ATE_TM_STATE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__GET(void)
{
    uint32_t reg = TSTCTRL_ATE_TEST_MODE__GET();
    reg = (reg & TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__Msk);
    reg = (reg >> TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__EXTRACT() extracts ATE_TEST_MODE.ATE_TM_STATE.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.ATE_TEST_MODE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.ATE_TEST_MODE
 * @return current value of ATE_TEST_MODE.ATE_TM_STATE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__Msk);
    reg = (reg >> TSTCTRL_ATE_TEST_MODE__ATE_TM_STATE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TEST_CONF member of TSTCTRL_t                       */
/* -------------------------------------------------------------------------- */

/** __TSTCTRL_TEST_CONF__ADDRESS returns the address of member TEST_CONF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_CONF
 */
__TSTCTRL_INLINE uint32_t* __TSTCTRL_TEST_CONF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSTCTRL_BASE_PTR() + (uint32_t)(offsetof(TSTCTRL_t, TEST_CONF)));
}

/** TSTCTRL_TEST_CONF__GET() gets TEST_CONF's current value.
 *
 * When reading from TEST_CONF, this is mandatory to use.
 *
 * @return current value of TEST_CONF
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__GET(void)
{
    return HAL_GET32(__TSTCTRL_TEST_CONF__ADDRESS());
}

/* --------------------- TSTCTRL.TEST_CONF.SP_REGA_DIS --------------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.SP_REGA_DIS:

    SP_REGA_DIS status

</pre> */

#define TSTCTRL_TEST_CONF__SP_REGA_DIS__Pos                     31                                                                     /*!< Right-most bit position of SP_REGA_DIS in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__SP_REGA_DIS__Msk                     (0x00000001UL << TSTCTRL_TEST_CONF__SP_REGA_DIS__Pos)                  /*!< Mask for SP_REGA_DIS in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__SP_REGA_DIS__Shift(v)                (((v) << TSTCTRL_TEST_CONF__SP_REGA_DIS__Pos) & TSTCTRL_TEST_CONF__SP_REGA_DIS__Msk) /*!< Shift value 'v' into SP_REGA_DIS and mask 'v' to fit it into SP_REGA_DIS field */

/** TSTCTRL_TEST_CONF__SP_REGA_DIS__GET() gets TEST_CONF.SP_REGA_DIS's current value.
 *
 * When reading from TEST_CONF.SP_REGA_DIS, this is recommended to use.
 *
 * @return current value of TEST_CONF.SP_REGA_DIS
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__SP_REGA_DIS__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__SP_REGA_DIS__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__SP_REGA_DIS__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__SP_REGA_DIS__EXTRACT() extracts TEST_CONF.SP_REGA_DIS.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.SP_REGA_DIS
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__SP_REGA_DIS__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__SP_REGA_DIS__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__SP_REGA_DIS__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TSTCTRL.TEST_CONF.SP_LDO_DIS ---------------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.SP_LDO_DIS:

    SP_LDO_DIS status

</pre> */

#define TSTCTRL_TEST_CONF__SP_LDO_DIS__Pos                      30                                                                     /*!< Right-most bit position of SP_LDO_DIS in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__SP_LDO_DIS__Msk                      (0x00000001UL << TSTCTRL_TEST_CONF__SP_LDO_DIS__Pos)                   /*!< Mask for SP_LDO_DIS in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__SP_LDO_DIS__Shift(v)                 (((v) << TSTCTRL_TEST_CONF__SP_LDO_DIS__Pos) & TSTCTRL_TEST_CONF__SP_LDO_DIS__Msk) /*!< Shift value 'v' into SP_LDO_DIS and mask 'v' to fit it into SP_LDO_DIS field */

/** TSTCTRL_TEST_CONF__SP_LDO_DIS__GET() gets TEST_CONF.SP_LDO_DIS's current value.
 *
 * When reading from TEST_CONF.SP_LDO_DIS, this is recommended to use.
 *
 * @return current value of TEST_CONF.SP_LDO_DIS
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__SP_LDO_DIS__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__SP_LDO_DIS__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__SP_LDO_DIS__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__SP_LDO_DIS__EXTRACT() extracts TEST_CONF.SP_LDO_DIS.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.SP_LDO_DIS
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__SP_LDO_DIS__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__SP_LDO_DIS__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__SP_LDO_DIS__Pos);
    return (uint32_t)reg;
}

/* --------------------- TSTCTRL.TEST_CONF.LO_SLEEP_EN --------------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.LO_SLEEP_EN:

    LO_SLEEP_EN status

</pre> */

#define TSTCTRL_TEST_CONF__LO_SLEEP_EN__Pos                     18                                                                     /*!< Right-most bit position of LO_SLEEP_EN in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__LO_SLEEP_EN__Msk                     (0x00000001UL << TSTCTRL_TEST_CONF__LO_SLEEP_EN__Pos)                  /*!< Mask for LO_SLEEP_EN in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__LO_SLEEP_EN__Shift(v)                (((v) << TSTCTRL_TEST_CONF__LO_SLEEP_EN__Pos) & TSTCTRL_TEST_CONF__LO_SLEEP_EN__Msk) /*!< Shift value 'v' into LO_SLEEP_EN and mask 'v' to fit it into LO_SLEEP_EN field */

/** TSTCTRL_TEST_CONF__LO_SLEEP_EN__GET() gets TEST_CONF.LO_SLEEP_EN's current value.
 *
 * When reading from TEST_CONF.LO_SLEEP_EN, this is recommended to use.
 *
 * @return current value of TEST_CONF.LO_SLEEP_EN
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__LO_SLEEP_EN__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__LO_SLEEP_EN__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__LO_SLEEP_EN__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__LO_SLEEP_EN__EXTRACT() extracts TEST_CONF.LO_SLEEP_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.LO_SLEEP_EN
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__LO_SLEEP_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__LO_SLEEP_EN__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__LO_SLEEP_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.TEST_CONF.LO_DIS ------------------------ */

/**
<pre>
  TSTCTRL.TEST_CONF.LO_DIS:

    LO_DIS status

</pre> */

#define TSTCTRL_TEST_CONF__LO_DIS__Pos                          17                                                                     /*!< Right-most bit position of LO_DIS in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__LO_DIS__Msk                          (0x00000001UL << TSTCTRL_TEST_CONF__LO_DIS__Pos)                       /*!< Mask for LO_DIS in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__LO_DIS__Shift(v)                     (((v) << TSTCTRL_TEST_CONF__LO_DIS__Pos) & TSTCTRL_TEST_CONF__LO_DIS__Msk) /*!< Shift value 'v' into LO_DIS and mask 'v' to fit it into LO_DIS field */

/** TSTCTRL_TEST_CONF__LO_DIS__GET() gets TEST_CONF.LO_DIS's current value.
 *
 * When reading from TEST_CONF.LO_DIS, this is recommended to use.
 *
 * @return current value of TEST_CONF.LO_DIS
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__LO_DIS__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__LO_DIS__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__LO_DIS__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__LO_DIS__EXTRACT() extracts TEST_CONF.LO_DIS.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.LO_DIS
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__LO_DIS__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__LO_DIS__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__LO_DIS__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TSTCTRL.TEST_CONF.CLK_SEL ----------------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.CLK_SEL:

    CLK_SEL status

</pre> */

#define TSTCTRL_TEST_CONF__CLK_SEL__Pos                         16                                                                     /*!< Right-most bit position of CLK_SEL in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__CLK_SEL__Msk                         (0x00000001UL << TSTCTRL_TEST_CONF__CLK_SEL__Pos)                      /*!< Mask for CLK_SEL in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__CLK_SEL__Shift(v)                    (((v) << TSTCTRL_TEST_CONF__CLK_SEL__Pos) & TSTCTRL_TEST_CONF__CLK_SEL__Msk) /*!< Shift value 'v' into CLK_SEL and mask 'v' to fit it into CLK_SEL field */

/** TSTCTRL_TEST_CONF__CLK_SEL__GET() gets TEST_CONF.CLK_SEL's current value.
 *
 * When reading from TEST_CONF.CLK_SEL, this is recommended to use.
 *
 * @return current value of TEST_CONF.CLK_SEL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__CLK_SEL__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__CLK_SEL__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__CLK_SEL__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__CLK_SEL__EXTRACT() extracts TEST_CONF.CLK_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.CLK_SEL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__CLK_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__CLK_SEL__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__CLK_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------- TSTCTRL.TEST_CONF.ATE_TM_FULL_BOOT ------------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.ATE_TM_FULL_BOOT:

    1: Enables the full boot

</pre> */

#define TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__Pos                10                                                                     /*!< Right-most bit position of ATE_TM_FULL_BOOT in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__Msk                (0x00000001UL << TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__Pos)             /*!< Mask for ATE_TM_FULL_BOOT in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__Shift(v)           (((v) << TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__Pos) & TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__Msk) /*!< Shift value 'v' into ATE_TM_FULL_BOOT and mask 'v' to fit it into ATE_TM_FULL_BOOT field */

/** TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__GET() gets TEST_CONF.ATE_TM_FULL_BOOT's current value.
 *
 * When reading from TEST_CONF.ATE_TM_FULL_BOOT, this is recommended to use.
 *
 * @return current value of TEST_CONF.ATE_TM_FULL_BOOT
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__EXTRACT() extracts TEST_CONF.ATE_TM_FULL_BOOT.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.ATE_TM_FULL_BOOT
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__ATE_TM_FULL_BOOT__Pos);
    return (uint32_t)reg;
}

/* ----------------- TSTCTRL.TEST_CONF.ATE_TM_TRIM_DOWNLOAD ----------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.ATE_TM_TRIM_DOWNLOAD:

    1: Enables the trimming configuration download

</pre> */

#define TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__Pos            9                                                                      /*!< Right-most bit position of ATE_TM_TRIM_DOWNLOAD in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__Msk            (0x00000001UL << TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__Pos)         /*!< Mask for ATE_TM_TRIM_DOWNLOAD in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__Shift(v)       (((v) << TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__Pos) & TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__Msk) /*!< Shift value 'v' into ATE_TM_TRIM_DOWNLOAD and mask 'v' to fit it into ATE_TM_TRIM_DOWNLOAD field */

/** TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__GET() gets TEST_CONF.ATE_TM_TRIM_DOWNLOAD's current value.
 *
 * When reading from TEST_CONF.ATE_TM_TRIM_DOWNLOAD, this is recommended to use.
 *
 * @return current value of TEST_CONF.ATE_TM_TRIM_DOWNLOAD
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__EXTRACT() extracts TEST_CONF.ATE_TM_TRIM_DOWNLOAD.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.ATE_TM_TRIM_DOWNLOAD
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__ATE_TM_TRIM_DOWNLOAD__Pos);
    return (uint32_t)reg;
}

/* -------------------- TSTCTRL.TEST_CONF.ATE_TM_CLK_EN -------------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.ATE_TM_CLK_EN:

    1: Enables clock configuration

</pre> */

#define TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__Pos                   8                                                                      /*!< Right-most bit position of ATE_TM_CLK_EN in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__Msk                   (0x00000001UL << TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__Pos)                /*!< Mask for ATE_TM_CLK_EN in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__Shift(v)              (((v) << TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__Pos) & TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__Msk) /*!< Shift value 'v' into ATE_TM_CLK_EN and mask 'v' to fit it into ATE_TM_CLK_EN field */

/** TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__GET() gets TEST_CONF.ATE_TM_CLK_EN's current value.
 *
 * When reading from TEST_CONF.ATE_TM_CLK_EN, this is recommended to use.
 *
 * @return current value of TEST_CONF.ATE_TM_CLK_EN
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__EXTRACT() extracts TEST_CONF.ATE_TM_CLK_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.ATE_TM_CLK_EN
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__ATE_TM_CLK_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TSTCTRL.TEST_CONF.SCAN_ANA_BYPASS ------------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.SCAN_ANA_BYPASS:

    SCAN_ANA_BYPASS status

</pre> */

#define TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__Pos                 3                                                                      /*!< Right-most bit position of SCAN_ANA_BYPASS in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__Msk                 (0x00000001UL << TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__Pos)              /*!< Mask for SCAN_ANA_BYPASS in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__Shift(v)            (((v) << TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__Pos) & TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__Msk) /*!< Shift value 'v' into SCAN_ANA_BYPASS and mask 'v' to fit it into SCAN_ANA_BYPASS field */

/** TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__GET() gets TEST_CONF.SCAN_ANA_BYPASS's current value.
 *
 * When reading from TEST_CONF.SCAN_ANA_BYPASS, this is recommended to use.
 *
 * @return current value of TEST_CONF.SCAN_ANA_BYPASS
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__EXTRACT() extracts TEST_CONF.SCAN_ANA_BYPASS.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.SCAN_ANA_BYPASS
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__SCAN_ANA_BYPASS__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TSTCTRL.TEST_CONF.SCAN_MODE ---------------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.SCAN_MODE:

    SCAN_MODEstatus

</pre> */

#define TSTCTRL_TEST_CONF__SCAN_MODE__Pos                       2                                                                      /*!< Right-most bit position of SCAN_MODE in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__SCAN_MODE__Msk                       (0x00000001UL << TSTCTRL_TEST_CONF__SCAN_MODE__Pos)                    /*!< Mask for SCAN_MODE in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__SCAN_MODE__Shift(v)                  (((v) << TSTCTRL_TEST_CONF__SCAN_MODE__Pos) & TSTCTRL_TEST_CONF__SCAN_MODE__Msk) /*!< Shift value 'v' into SCAN_MODE and mask 'v' to fit it into SCAN_MODE field */

/** TSTCTRL_TEST_CONF__SCAN_MODE__GET() gets TEST_CONF.SCAN_MODE's current value.
 *
 * When reading from TEST_CONF.SCAN_MODE, this is recommended to use.
 *
 * @return current value of TEST_CONF.SCAN_MODE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__SCAN_MODE__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__SCAN_MODE__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__SCAN_MODE__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__SCAN_MODE__EXTRACT() extracts TEST_CONF.SCAN_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.SCAN_MODE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__SCAN_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__SCAN_MODE__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__SCAN_MODE__Pos);
    return (uint32_t)reg;
}

/* -------------------- TSTCTRL.TEST_CONF.SCAN_TYPE_SEL -------------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.SCAN_TYPE_SEL:

    SCAN_TYPE_SEL status

</pre> */

#define TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__Pos                   1                                                                      /*!< Right-most bit position of SCAN_TYPE_SEL in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__Msk                   (0x00000001UL << TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__Pos)                /*!< Mask for SCAN_TYPE_SEL in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__Shift(v)              (((v) << TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__Pos) & TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__Msk) /*!< Shift value 'v' into SCAN_TYPE_SEL and mask 'v' to fit it into SCAN_TYPE_SEL field */

/** TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__GET() gets TEST_CONF.SCAN_TYPE_SEL's current value.
 *
 * When reading from TEST_CONF.SCAN_TYPE_SEL, this is recommended to use.
 *
 * @return current value of TEST_CONF.SCAN_TYPE_SEL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__EXTRACT() extracts TEST_CONF.SCAN_TYPE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.SCAN_TYPE_SEL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__SCAN_TYPE_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TSTCTRL.TEST_CONF.EDT_BYPASS ---------------------- */

/**
<pre>
  TSTCTRL.TEST_CONF.EDT_BYPASS:

    EDT_BYPASS status

</pre> */

#define TSTCTRL_TEST_CONF__EDT_BYPASS__Pos                      0                                                                      /*!< Right-most bit position of EDT_BYPASS in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__EDT_BYPASS__Msk                      (0x00000001UL << TSTCTRL_TEST_CONF__EDT_BYPASS__Pos)                   /*!< Mask for EDT_BYPASS in TSTCTRL.TEST_CONF */
#define TSTCTRL_TEST_CONF__EDT_BYPASS__Shift(v)                 (((v) << TSTCTRL_TEST_CONF__EDT_BYPASS__Pos) & TSTCTRL_TEST_CONF__EDT_BYPASS__Msk) /*!< Shift value 'v' into EDT_BYPASS and mask 'v' to fit it into EDT_BYPASS field */

/** TSTCTRL_TEST_CONF__EDT_BYPASS__GET() gets TEST_CONF.EDT_BYPASS's current value.
 *
 * When reading from TEST_CONF.EDT_BYPASS, this is recommended to use.
 *
 * @return current value of TEST_CONF.EDT_BYPASS
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__EDT_BYPASS__GET(void)
{
    uint32_t reg = TSTCTRL_TEST_CONF__GET();
    reg = (reg & TSTCTRL_TEST_CONF__EDT_BYPASS__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__EDT_BYPASS__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_TEST_CONF__EDT_BYPASS__EXTRACT() extracts TEST_CONF.EDT_BYPASS.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.TEST_CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.TEST_CONF
 * @return current value of TEST_CONF.EDT_BYPASS
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_TEST_CONF__EDT_BYPASS__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_TEST_CONF__EDT_BYPASS__Msk);
    reg = (reg >> TSTCTRL_TEST_CONF__EDT_BYPASS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         MBIST member of TSTCTRL_t                         */
/* -------------------------------------------------------------------------- */

/** __TSTCTRL_MBIST__ADDRESS returns the address of member MBIST.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MBIST
 */
__TSTCTRL_INLINE uint32_t* __TSTCTRL_MBIST__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSTCTRL_BASE_PTR() + (uint32_t)(offsetof(TSTCTRL_t, MBIST)));
}

/** TSTCTRL_MBIST__GET() gets MBIST's current value.
 *
 * When reading from MBIST, this is mandatory to use.
 *
 * @return current value of MBIST
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__GET(void)
{
    return HAL_GET32(__TSTCTRL_MBIST__ADDRESS());
}

/* ------------------------ TSTCTRL.MBIST.MBIST_MODE ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.MBIST_MODE:

    MBIST_MODE status

</pre> */

#define TSTCTRL_MBIST__MBIST_MODE__Pos                          31                                                                     /*!< Right-most bit position of MBIST_MODE in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__MBIST_MODE__Msk                          (0x00000001UL << TSTCTRL_MBIST__MBIST_MODE__Pos)                       /*!< Mask for MBIST_MODE in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__MBIST_MODE__Shift(v)                     (((v) << TSTCTRL_MBIST__MBIST_MODE__Pos) & TSTCTRL_MBIST__MBIST_MODE__Msk) /*!< Shift value 'v' into MBIST_MODE and mask 'v' to fit it into MBIST_MODE field */

/** TSTCTRL_MBIST__MBIST_MODE__GET() gets MBIST.MBIST_MODE's current value.
 *
 * When reading from MBIST.MBIST_MODE, this is recommended to use.
 *
 * @return current value of MBIST.MBIST_MODE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__MBIST_MODE__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__MBIST_MODE__Msk);
    reg = (reg >> TSTCTRL_MBIST__MBIST_MODE__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__MBIST_MODE__EXTRACT() extracts MBIST.MBIST_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.MBIST_MODE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__MBIST_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__MBIST_MODE__Msk);
    reg = (reg >> TSTCTRL_MBIST__MBIST_MODE__Pos);
    return (uint32_t)reg;
}

/* ------------------------- TSTCTRL.MBIST.RAM_SEL ------------------------- */

/**
<pre>
  TSTCTRL.MBIST.RAM_SEL:

    RAM_SEL status

</pre> */

#define TSTCTRL_MBIST__RAM_SEL__Pos                             30                                                                     /*!< Right-most bit position of RAM_SEL in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM_SEL__Msk                             (0x00000001UL << TSTCTRL_MBIST__RAM_SEL__Pos)                          /*!< Mask for RAM_SEL in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM_SEL__Shift(v)                        (((v) << TSTCTRL_MBIST__RAM_SEL__Pos) & TSTCTRL_MBIST__RAM_SEL__Msk)   /*!< Shift value 'v' into RAM_SEL and mask 'v' to fit it into RAM_SEL field */

/** TSTCTRL_MBIST__RAM_SEL__GET() gets MBIST.RAM_SEL's current value.
 *
 * When reading from MBIST.RAM_SEL, this is recommended to use.
 *
 * @return current value of MBIST.RAM_SEL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM_SEL__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__RAM_SEL__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM_SEL__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__RAM_SEL__EXTRACT() extracts MBIST.RAM_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.RAM_SEL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__RAM_SEL__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.IOMUX_CTRL ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.IOMUX_CTRL:

    IOMUX_CTRL status

</pre> */

#define TSTCTRL_MBIST__IOMUX_CTRL__Pos                          29                                                                     /*!< Right-most bit position of IOMUX_CTRL in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__IOMUX_CTRL__Msk                          (0x00000001UL << TSTCTRL_MBIST__IOMUX_CTRL__Pos)                       /*!< Mask for IOMUX_CTRL in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__IOMUX_CTRL__Shift(v)                     (((v) << TSTCTRL_MBIST__IOMUX_CTRL__Pos) & TSTCTRL_MBIST__IOMUX_CTRL__Msk) /*!< Shift value 'v' into IOMUX_CTRL and mask 'v' to fit it into IOMUX_CTRL field */

/** TSTCTRL_MBIST__IOMUX_CTRL__GET() gets MBIST.IOMUX_CTRL's current value.
 *
 * When reading from MBIST.IOMUX_CTRL, this is recommended to use.
 *
 * @return current value of MBIST.IOMUX_CTRL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__IOMUX_CTRL__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__IOMUX_CTRL__Msk);
    reg = (reg >> TSTCTRL_MBIST__IOMUX_CTRL__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__IOMUX_CTRL__EXTRACT() extracts MBIST.IOMUX_CTRL.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.IOMUX_CTRL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__IOMUX_CTRL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__IOMUX_CTRL__Msk);
    reg = (reg >> TSTCTRL_MBIST__IOMUX_CTRL__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.ROM_SLOWB ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.ROM_SLOWB:

    ROM_SLOWB status

</pre> */

#define TSTCTRL_MBIST__ROM_SLOWB__Pos                           27                                                                     /*!< Right-most bit position of ROM_SLOWB in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__ROM_SLOWB__Msk                           (0x00000003UL << TSTCTRL_MBIST__ROM_SLOWB__Pos)                        /*!< Mask for ROM_SLOWB in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__ROM_SLOWB__Shift(v)                      (((v) << TSTCTRL_MBIST__ROM_SLOWB__Pos) & TSTCTRL_MBIST__ROM_SLOWB__Msk) /*!< Shift value 'v' into ROM_SLOWB and mask 'v' to fit it into ROM_SLOWB field */

/** TSTCTRL_MBIST__ROM_SLOWB__GET() gets MBIST.ROM_SLOWB's current value.
 *
 * When reading from MBIST.ROM_SLOWB, this is recommended to use.
 *
 * @return current value of MBIST.ROM_SLOWB
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__ROM_SLOWB__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__ROM_SLOWB__Msk);
    reg = (reg >> TSTCTRL_MBIST__ROM_SLOWB__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__ROM_SLOWB__EXTRACT() extracts MBIST.ROM_SLOWB.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.ROM_SLOWB
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__ROM_SLOWB__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__ROM_SLOWB__Msk);
    reg = (reg >> TSTCTRL_MBIST__ROM_SLOWB__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.RAM2_SLOWB ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.RAM2_SLOWB:

    RAM2_SLOWB status

</pre> */

#define TSTCTRL_MBIST__RAM2_SLOWB__Pos                          25                                                                     /*!< Right-most bit position of RAM2_SLOWB in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM2_SLOWB__Msk                          (0x00000003UL << TSTCTRL_MBIST__RAM2_SLOWB__Pos)                       /*!< Mask for RAM2_SLOWB in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM2_SLOWB__Shift(v)                     (((v) << TSTCTRL_MBIST__RAM2_SLOWB__Pos) & TSTCTRL_MBIST__RAM2_SLOWB__Msk) /*!< Shift value 'v' into RAM2_SLOWB and mask 'v' to fit it into RAM2_SLOWB field */

/** TSTCTRL_MBIST__RAM2_SLOWB__GET() gets MBIST.RAM2_SLOWB's current value.
 *
 * When reading from MBIST.RAM2_SLOWB, this is recommended to use.
 *
 * @return current value of MBIST.RAM2_SLOWB
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM2_SLOWB__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__RAM2_SLOWB__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM2_SLOWB__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__RAM2_SLOWB__EXTRACT() extracts MBIST.RAM2_SLOWB.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.RAM2_SLOWB
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM2_SLOWB__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__RAM2_SLOWB__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM2_SLOWB__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.RAM1_SLOWB ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.RAM1_SLOWB:

    RAM1_SLOWB status

</pre> */

#define TSTCTRL_MBIST__RAM1_SLOWB__Pos                          23                                                                     /*!< Right-most bit position of RAM1_SLOWB in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM1_SLOWB__Msk                          (0x00000003UL << TSTCTRL_MBIST__RAM1_SLOWB__Pos)                       /*!< Mask for RAM1_SLOWB in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM1_SLOWB__Shift(v)                     (((v) << TSTCTRL_MBIST__RAM1_SLOWB__Pos) & TSTCTRL_MBIST__RAM1_SLOWB__Msk) /*!< Shift value 'v' into RAM1_SLOWB and mask 'v' to fit it into RAM1_SLOWB field */

/** TSTCTRL_MBIST__RAM1_SLOWB__GET() gets MBIST.RAM1_SLOWB's current value.
 *
 * When reading from MBIST.RAM1_SLOWB, this is recommended to use.
 *
 * @return current value of MBIST.RAM1_SLOWB
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM1_SLOWB__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__RAM1_SLOWB__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM1_SLOWB__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__RAM1_SLOWB__EXTRACT() extracts MBIST.RAM1_SLOWB.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.RAM1_SLOWB
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM1_SLOWB__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__RAM1_SLOWB__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM1_SLOWB__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.RAM2_FAIL ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.RAM2_FAIL:

    RAM2_FAIL status

</pre> */

#define TSTCTRL_MBIST__RAM2_FAIL__Pos                           17                                                                     /*!< Right-most bit position of RAM2_FAIL in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM2_FAIL__Msk                           (0x00000001UL << TSTCTRL_MBIST__RAM2_FAIL__Pos)                        /*!< Mask for RAM2_FAIL in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM2_FAIL__Shift(v)                      (((v) << TSTCTRL_MBIST__RAM2_FAIL__Pos) & TSTCTRL_MBIST__RAM2_FAIL__Msk) /*!< Shift value 'v' into RAM2_FAIL and mask 'v' to fit it into RAM2_FAIL field */

/** TSTCTRL_MBIST__RAM2_FAIL__GET() gets MBIST.RAM2_FAIL's current value.
 *
 * When reading from MBIST.RAM2_FAIL, this is recommended to use.
 *
 * @return current value of MBIST.RAM2_FAIL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM2_FAIL__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__RAM2_FAIL__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM2_FAIL__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__RAM2_FAIL__EXTRACT() extracts MBIST.RAM2_FAIL.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.RAM2_FAIL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM2_FAIL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__RAM2_FAIL__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM2_FAIL__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.RAM1_FAIL ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.RAM1_FAIL:

    RAM1_FAIL status

</pre> */

#define TSTCTRL_MBIST__RAM1_FAIL__Pos                           16                                                                     /*!< Right-most bit position of RAM1_FAIL in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM1_FAIL__Msk                           (0x00000001UL << TSTCTRL_MBIST__RAM1_FAIL__Pos)                        /*!< Mask for RAM1_FAIL in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM1_FAIL__Shift(v)                      (((v) << TSTCTRL_MBIST__RAM1_FAIL__Pos) & TSTCTRL_MBIST__RAM1_FAIL__Msk) /*!< Shift value 'v' into RAM1_FAIL and mask 'v' to fit it into RAM1_FAIL field */

/** TSTCTRL_MBIST__RAM1_FAIL__GET() gets MBIST.RAM1_FAIL's current value.
 *
 * When reading from MBIST.RAM1_FAIL, this is recommended to use.
 *
 * @return current value of MBIST.RAM1_FAIL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM1_FAIL__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__RAM1_FAIL__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM1_FAIL__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__RAM1_FAIL__EXTRACT() extracts MBIST.RAM1_FAIL.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.RAM1_FAIL
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM1_FAIL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__RAM1_FAIL__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM1_FAIL__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.MBIST_RSTN ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.MBIST_RSTN:

    MBIST_RSTN status

</pre> */

#define TSTCTRL_MBIST__MBIST_RSTN__Pos                          15                                                                     /*!< Right-most bit position of MBIST_RSTN in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__MBIST_RSTN__Msk                          (0x00000001UL << TSTCTRL_MBIST__MBIST_RSTN__Pos)                       /*!< Mask for MBIST_RSTN in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__MBIST_RSTN__Shift(v)                     (((v) << TSTCTRL_MBIST__MBIST_RSTN__Pos) & TSTCTRL_MBIST__MBIST_RSTN__Msk) /*!< Shift value 'v' into MBIST_RSTN and mask 'v' to fit it into MBIST_RSTN field */

/** TSTCTRL_MBIST__MBIST_RSTN__GET() gets MBIST.MBIST_RSTN's current value.
 *
 * When reading from MBIST.MBIST_RSTN, this is recommended to use.
 *
 * @return current value of MBIST.MBIST_RSTN
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__MBIST_RSTN__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__MBIST_RSTN__Msk);
    reg = (reg >> TSTCTRL_MBIST__MBIST_RSTN__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__MBIST_RSTN__EXTRACT() extracts MBIST.MBIST_RSTN.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.MBIST_RSTN
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__MBIST_RSTN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__MBIST_RSTN__Msk);
    reg = (reg >> TSTCTRL_MBIST__MBIST_RSTN__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.RAM_DEBUG ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.RAM_DEBUG:

    RAM_DEBUG status

</pre> */

#define TSTCTRL_MBIST__RAM_DEBUG__Pos                           14                                                                     /*!< Right-most bit position of RAM_DEBUG in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM_DEBUG__Msk                           (0x00000001UL << TSTCTRL_MBIST__RAM_DEBUG__Pos)                        /*!< Mask for RAM_DEBUG in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM_DEBUG__Shift(v)                      (((v) << TSTCTRL_MBIST__RAM_DEBUG__Pos) & TSTCTRL_MBIST__RAM_DEBUG__Msk) /*!< Shift value 'v' into RAM_DEBUG and mask 'v' to fit it into RAM_DEBUG field */

/** TSTCTRL_MBIST__RAM_DEBUG__GET() gets MBIST.RAM_DEBUG's current value.
 *
 * When reading from MBIST.RAM_DEBUG, this is recommended to use.
 *
 * @return current value of MBIST.RAM_DEBUG
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM_DEBUG__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__RAM_DEBUG__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM_DEBUG__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__RAM_DEBUG__EXTRACT() extracts MBIST.RAM_DEBUG.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.RAM_DEBUG
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM_DEBUG__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__RAM_DEBUG__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM_DEBUG__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.ROM_DEBUG ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.ROM_DEBUG:

    ROM_DEBUG status

</pre> */

#define TSTCTRL_MBIST__ROM_DEBUG__Pos                           13                                                                     /*!< Right-most bit position of ROM_DEBUG in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__ROM_DEBUG__Msk                           (0x00000001UL << TSTCTRL_MBIST__ROM_DEBUG__Pos)                        /*!< Mask for ROM_DEBUG in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__ROM_DEBUG__Shift(v)                      (((v) << TSTCTRL_MBIST__ROM_DEBUG__Pos) & TSTCTRL_MBIST__ROM_DEBUG__Msk) /*!< Shift value 'v' into ROM_DEBUG and mask 'v' to fit it into ROM_DEBUG field */

/** TSTCTRL_MBIST__ROM_DEBUG__GET() gets MBIST.ROM_DEBUG's current value.
 *
 * When reading from MBIST.ROM_DEBUG, this is recommended to use.
 *
 * @return current value of MBIST.ROM_DEBUG
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__ROM_DEBUG__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__ROM_DEBUG__Msk);
    reg = (reg >> TSTCTRL_MBIST__ROM_DEBUG__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__ROM_DEBUG__EXTRACT() extracts MBIST.ROM_DEBUG.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.ROM_DEBUG
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__ROM_DEBUG__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__ROM_DEBUG__Msk);
    reg = (reg >> TSTCTRL_MBIST__ROM_DEBUG__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.ROM_START ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.ROM_START:

    ROM_START status

</pre> */

#define TSTCTRL_MBIST__ROM_START__Pos                           11                                                                     /*!< Right-most bit position of ROM_START in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__ROM_START__Msk                           (0x00000001UL << TSTCTRL_MBIST__ROM_START__Pos)                        /*!< Mask for ROM_START in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__ROM_START__Shift(v)                      (((v) << TSTCTRL_MBIST__ROM_START__Pos) & TSTCTRL_MBIST__ROM_START__Msk) /*!< Shift value 'v' into ROM_START and mask 'v' to fit it into ROM_START field */

/** TSTCTRL_MBIST__ROM_START__GET() gets MBIST.ROM_START's current value.
 *
 * When reading from MBIST.ROM_START, this is recommended to use.
 *
 * @return current value of MBIST.ROM_START
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__ROM_START__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__ROM_START__Msk);
    reg = (reg >> TSTCTRL_MBIST__ROM_START__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__ROM_START__EXTRACT() extracts MBIST.ROM_START.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.ROM_START
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__ROM_START__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__ROM_START__Msk);
    reg = (reg >> TSTCTRL_MBIST__ROM_START__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.RAM2_START ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.RAM2_START:

    RAM2_START status

</pre> */

#define TSTCTRL_MBIST__RAM2_START__Pos                          10                                                                     /*!< Right-most bit position of RAM2_START in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM2_START__Msk                          (0x00000001UL << TSTCTRL_MBIST__RAM2_START__Pos)                       /*!< Mask for RAM2_START in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM2_START__Shift(v)                     (((v) << TSTCTRL_MBIST__RAM2_START__Pos) & TSTCTRL_MBIST__RAM2_START__Msk) /*!< Shift value 'v' into RAM2_START and mask 'v' to fit it into RAM2_START field */

/** TSTCTRL_MBIST__RAM2_START__GET() gets MBIST.RAM2_START's current value.
 *
 * When reading from MBIST.RAM2_START, this is recommended to use.
 *
 * @return current value of MBIST.RAM2_START
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM2_START__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__RAM2_START__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM2_START__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__RAM2_START__EXTRACT() extracts MBIST.RAM2_START.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.RAM2_START
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM2_START__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__RAM2_START__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM2_START__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.RAM1_START ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.RAM1_START:

    RAM1_START status

</pre> */

#define TSTCTRL_MBIST__RAM1_START__Pos                          9                                                                      /*!< Right-most bit position of RAM1_START in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM1_START__Msk                          (0x00000001UL << TSTCTRL_MBIST__RAM1_START__Pos)                       /*!< Mask for RAM1_START in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM1_START__Shift(v)                     (((v) << TSTCTRL_MBIST__RAM1_START__Pos) & TSTCTRL_MBIST__RAM1_START__Msk) /*!< Shift value 'v' into RAM1_START and mask 'v' to fit it into RAM1_START field */

/** TSTCTRL_MBIST__RAM1_START__GET() gets MBIST.RAM1_START's current value.
 *
 * When reading from MBIST.RAM1_START, this is recommended to use.
 *
 * @return current value of MBIST.RAM1_START
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM1_START__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__RAM1_START__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM1_START__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__RAM1_START__EXTRACT() extracts MBIST.RAM1_START.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.RAM1_START
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM1_START__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__RAM1_START__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM1_START__Pos);
    return (uint32_t)reg;
}

/* ------------------------- TSTCTRL.MBIST.ROM_DONE ------------------------- */

/**
<pre>
  TSTCTRL.MBIST.ROM_DONE:

    ROM_DONE status

</pre> */

#define TSTCTRL_MBIST__ROM_DONE__Pos                            2                                                                      /*!< Right-most bit position of ROM_DONE in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__ROM_DONE__Msk                            (0x00000001UL << TSTCTRL_MBIST__ROM_DONE__Pos)                         /*!< Mask for ROM_DONE in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__ROM_DONE__Shift(v)                       (((v) << TSTCTRL_MBIST__ROM_DONE__Pos) & TSTCTRL_MBIST__ROM_DONE__Msk) /*!< Shift value 'v' into ROM_DONE and mask 'v' to fit it into ROM_DONE field */

/** TSTCTRL_MBIST__ROM_DONE__GET() gets MBIST.ROM_DONE's current value.
 *
 * When reading from MBIST.ROM_DONE, this is recommended to use.
 *
 * @return current value of MBIST.ROM_DONE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__ROM_DONE__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__ROM_DONE__Msk);
    reg = (reg >> TSTCTRL_MBIST__ROM_DONE__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__ROM_DONE__EXTRACT() extracts MBIST.ROM_DONE.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.ROM_DONE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__ROM_DONE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__ROM_DONE__Msk);
    reg = (reg >> TSTCTRL_MBIST__ROM_DONE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.RAM2_DONE ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.RAM2_DONE:

    RAM2_DONE status

</pre> */

#define TSTCTRL_MBIST__RAM2_DONE__Pos                           1                                                                      /*!< Right-most bit position of RAM2_DONE in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM2_DONE__Msk                           (0x00000001UL << TSTCTRL_MBIST__RAM2_DONE__Pos)                        /*!< Mask for RAM2_DONE in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM2_DONE__Shift(v)                      (((v) << TSTCTRL_MBIST__RAM2_DONE__Pos) & TSTCTRL_MBIST__RAM2_DONE__Msk) /*!< Shift value 'v' into RAM2_DONE and mask 'v' to fit it into RAM2_DONE field */

/** TSTCTRL_MBIST__RAM2_DONE__GET() gets MBIST.RAM2_DONE's current value.
 *
 * When reading from MBIST.RAM2_DONE, this is recommended to use.
 *
 * @return current value of MBIST.RAM2_DONE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM2_DONE__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__RAM2_DONE__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM2_DONE__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__RAM2_DONE__EXTRACT() extracts MBIST.RAM2_DONE.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.RAM2_DONE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM2_DONE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__RAM2_DONE__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM2_DONE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSTCTRL.MBIST.RAM1_DONE ------------------------ */

/**
<pre>
  TSTCTRL.MBIST.RAM1_DONE:

    RAM1_DONE status

</pre> */

#define TSTCTRL_MBIST__RAM1_DONE__Pos                           0                                                                      /*!< Right-most bit position of RAM1_DONE in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM1_DONE__Msk                           (0x00000001UL << TSTCTRL_MBIST__RAM1_DONE__Pos)                        /*!< Mask for RAM1_DONE in TSTCTRL.MBIST */
#define TSTCTRL_MBIST__RAM1_DONE__Shift(v)                      (((v) << TSTCTRL_MBIST__RAM1_DONE__Pos) & TSTCTRL_MBIST__RAM1_DONE__Msk) /*!< Shift value 'v' into RAM1_DONE and mask 'v' to fit it into RAM1_DONE field */

/** TSTCTRL_MBIST__RAM1_DONE__GET() gets MBIST.RAM1_DONE's current value.
 *
 * When reading from MBIST.RAM1_DONE, this is recommended to use.
 *
 * @return current value of MBIST.RAM1_DONE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM1_DONE__GET(void)
{
    uint32_t reg = TSTCTRL_MBIST__GET();
    reg = (reg & TSTCTRL_MBIST__RAM1_DONE__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM1_DONE__Pos);
    return (uint32_t)reg;
}

/** TSTCTRL_MBIST__RAM1_DONE__EXTRACT() extracts MBIST.RAM1_DONE.
 *
 * This is recommended to use when extracting more than one bitfield from TSTCTRL.MBIST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSTCTRL.MBIST
 * @return current value of MBIST.RAM1_DONE
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_MBIST__RAM1_DONE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSTCTRL_MBIST__RAM1_DONE__Msk);
    reg = (reg >> TSTCTRL_MBIST__RAM1_DONE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        ROM_MISR member of TSTCTRL_t                        */
/* -------------------------------------------------------------------------- */

/** __TSTCTRL_ROM_MISR__ADDRESS returns the address of member ROM_MISR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ROM_MISR
 */
__TSTCTRL_INLINE uint32_t* __TSTCTRL_ROM_MISR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSTCTRL_BASE_PTR() + (uint32_t)(offsetof(TSTCTRL_t, ROM_MISR)));
}

/** TSTCTRL_ROM_MISR__GET() gets ROM_MISR's current value.
 *
 * When reading from ROM_MISR, this is mandatory to use.
 *
 * @return current value of ROM_MISR
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_ROM_MISR__GET(void)
{
    return HAL_GET32(__TSTCTRL_ROM_MISR__ADDRESS());
}

/* -------------------------------------------------------------------------- */
/*                        SYSRESET member of TSTCTRL_t                        */
/* -------------------------------------------------------------------------- */

/** __TSTCTRL_SYSRESET__ADDRESS returns the address of member SYSRESET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of SYSRESET
 */
__TSTCTRL_INLINE uint32_t* __TSTCTRL_SYSRESET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSTCTRL_BASE_PTR() + (uint32_t)(offsetof(TSTCTRL_t, SYSRESET)));
}

/** TSTCTRL_SYSRESET__GET() gets SYSRESET's current value.
 *
 * When reading from SYSRESET, this is mandatory to use.
 *
 * @return current value of SYSRESET
 */
__TSTCTRL_INLINE uint32_t TSTCTRL_SYSRESET__GET(void)
{
    return HAL_GET32(__TSTCTRL_SYSRESET__ADDRESS());
}

/** @} */ /* End of group tstctrl block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_TSTCTRL_H_ */
