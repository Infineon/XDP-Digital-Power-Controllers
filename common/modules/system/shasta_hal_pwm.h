/**
 * @file     shasta_hal_pwm.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_PWM_H_
#define _SHASTA_HAL_PWM_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup pwm
 * @{
 */

#if defined ( __CC_ARM )
#define __PWM_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __PWM_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __PWM_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __PWM_INLINE  static inline
#endif

/** register file of the pwm block.
 */
typedef struct _PWM_s
{
    volatile        uint32_t        RAMP_CONFIG                 ; /*!< (@0x00000000) PID source select for Ramp 0.  PID0 receives its error input from the VSEN input.  PID1 receives its error input from the BVSEN input.  Generally, Ramp 0 sh...(more) */
    volatile        uint32_t        PWM_TOPO_1                  ; /*!< (@0x00000004) Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at ti...(more) */
    volatile        uint32_t        PWM_TOPO_2                  ; /*!< (@0x00000008) Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at ti...(more) */
    volatile        uint32_t        PWM_TOPO_3                  ; /*!< (@0x0000000C) Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at ti...(more) */
    volatile        uint32_t        PWM_MAP                     ; /*!< (@0x00000010) Defines the loop and phase mapping of the PWM1 output <start table> 0 "PWM not in use" 1 "Loop 0, Phase 0" 2 "Loop 1, Phase 0" 3 "Loop 0, Phase 1" <end table> */
    volatile        uint32_t        MAX_DUTY_SCALE              ; /*!< (@0x00000014) Ramp 0 nominal max duty cycle scaled by the rectification voltage (Vrect).  The PMBus command MAX_DUTY defines a fixed max duty cycle limit.  This parameter...(more) */
    volatile        uint32_t        PWM_FTR                     ; /*!< (@0x00000018) Loop 0 Fast Transient Response (FTR) input voltage threshold.  Below this threshold, the FTR pulsewidth is based on the feed forward duty cycle from the PID...(more) */
    volatile        uint32_t        RAMP0_PHASE                 ; /*!< (@0x0000001C) Ramp 0 phase alignment with respect to sync signal selected with ramp0_sync_sel. Computed from PMBus as follows: <start table> "ramp0_phase(U0.8) = 2^8 * PA...(more) */
    volatile        uint32_t        RAMP1_PHASE                 ; /*!< (@0x00000020) Ramp 1 phase alignment with respect to sync signal selected with ramp1_sync_sel. Computed from PMBus as follows: <start table> "ramp1_phase(U0.8) = 2^8 * PA...(more) */
    volatile        uint32_t        PWM_FORCE_HI_LO             ; /*!< (@0x00000024) Force PWM output high, [0] corresponds to PWM1, [11] corresponds to PWM12. */
    volatile        uint32_t        PWM_ON                      ; /*!< (@0x00000028) PWM channel enabled when bit position high, [0] corresponds to PWM1, [11] corresponds to PWM12. Note: Intended to be driven by FW only. */
    volatile        uint32_t        RAMP0_TSWITCH0              ; /*!< (@0x0000002C) PWM Ramp 0 switching period.  This register defines the switching period of ramp 0 when ramp0_sync_sel is set to internal sync or when ramp0_sync_sel is set...(more) */
    volatile        uint32_t        RAMP0_PW_MINMAX             ; /*!< (@0x00000030) PWM Ramp 0 max duty cycle (fixed).  See ramp0_dc_max_nom description for scaled max duty cycle information. Computed from PMBus as follows: <start table> "r...(more) */
    volatile        uint32_t        RAMP0_FORCE_DUTY            ; /*!< (@0x00000034) Forced duty cycle value overrides ramp 0 input when selected by ramp0_force_duty_en.  Since this force is applied at the ramp input, upstream adjustments to...(more) */
    volatile        uint32_t        RAMP0_FORCE_T1              ; /*!< (@0x00000038) PWM Ramp 0 forced T1 setting selected by ramp0_force_t1_en.  T1 is the time of the first PWM "edge" in a ramp cycle.  In a trailing edge modulation scheme T...(more) */
    volatile        uint32_t        RAMP0_FORCE_T2              ; /*!< (@0x0000003C) PWM Ramp 0 forced T2 setting selected by ramp0_force_t2_en.  T2 is the time of the second PWM "edge" in a ramp cycle.  In a leading edge modulation scheme T...(more) */
    volatile        uint32_t        RAMP1_TSWITCH1              ; /*!< (@0x00000040) PWM Ramp 1 switching period.  This register defines the switching period of ramp 1 when ramp1_sync_sel is set to internal sync or when ramp1_sync_sel is set...(more) */
    volatile        uint32_t        RAMP1_PW_MINMAX             ; /*!< (@0x00000044) PWM Ramp 1 max duty cycle (absolute).  See ramp1_dc_max_nom description for scaled max duty cycle information. Computed from PMBus as follows: <start table>...(more) */
    volatile        uint32_t        RAMP1_FORCE_DUTY            ; /*!< (@0x00000048) Forced duty cycle value overrides ramp 1 input when selected by ramp1_force_duty_en.  Since this force is applied at the ramp input, upstream adjustments to...(more) */
    volatile        uint32_t        RAMP1_FORCE_T1              ; /*!< (@0x0000004C) PWM Ramp 1 forced T1 setting selected by ramp1_force_t1_en.  T1 is the time of the first PWM "edge" in a ramp cycle.  In a trailing edge modulation scheme T...(more) */
    volatile        uint32_t        RAMP1_FORCE_T2              ; /*!< (@0x00000050) PWM Ramp 1 forced T2 setting selected by ramp1_force_t2_en.  T2 is the time of the second PWM "edge" in a ramp cycle.  In a leading edge modulation scheme T...(more) */
    volatile        uint32_t        PWM1_DEADTIME               ; /*!< (@0x00000054) PWM1 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm1_rise_sel.  In order to synchronously update all de...(more) */
    volatile        uint32_t        PWM2_DEADTIME               ; /*!< (@0x00000058) PWM2 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm2_rise_sel.  In order to synchronously update all de...(more) */
    volatile        uint32_t        PWM3_DEADTIME               ; /*!< (@0x0000005C) PWM3 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm3_rise_sel.  In order to synchronously update all de...(more) */
    volatile        uint32_t        PWM4_DEADTIME               ; /*!< (@0x00000060) PWM4 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm4_rise_sel.  In order to synchronously update all de...(more) */
    volatile        uint32_t        PWM5_DEADTIME               ; /*!< (@0x00000064) PWM5 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm5_rise_sel.  In order to synchronously update all de...(more) */
    volatile        uint32_t        PWM6_DEADTIME               ; /*!< (@0x00000068) PWM6 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm6_rise_sel.  In order to synchronously update all de...(more) */
    volatile        uint32_t        PWM7_DEADTIME               ; /*!< (@0x0000006C) PWM7 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm7_rise_sel.  In order to synchronously update all de...(more) */
    volatile        uint32_t        PWM8_DEADTIME               ; /*!< (@0x00000070) PWM8 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm8_rise_sel.  In order to synchronously update all de...(more) */
    volatile        uint32_t        PWM9_DEADTIME               ; /*!< (@0x00000074) PWM9 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm9_rise_sel.  In order to synchronously update all de...(more) */
    volatile        uint32_t        PWM10_DEADTIME              ; /*!< (@0x00000078) PWM10 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm10_rise_sel.  In order to synchronously update all ...(more) */
    volatile        uint32_t        PWM11_DEADTIME              ; /*!< (@0x0000007C) PWM11 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm11_rise_sel.  In order to synchronously update all ...(more) */
    volatile        uint32_t        PWM12_DEADTIME              ; /*!< (@0x00000080) PWM12 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm12_rise_sel.  In order to synchronously update all ...(more) */
    volatile        uint32_t        PWM_DUTYC_RD                ; /*!< (@0x00000084) This register bit is set when a new duty cycle force has been applied on ramp 0. It is cleared when either ramp0_force_duty_en or ramp0_force_duty changes. */
    volatile        uint32_t        CAL_DONE                    ; /*!< (@0x00000088) This register bit is set when the initial current sense calibration is complete.  Current sense calibration is performed continuously after the first output...(more) */
    volatile        uint32_t        RAMP_IRQ                    ; /*!< (@0x0000008C) PWM Ramp 0 T1 Interrupt (IRQ) select. <start table_with_header> [2:0] "IRQ Trigger" 0 "disabled" 1 "T1" 2 "T1 even" 3 "T1 odd" 4-7 "Phase set by ramp0_irq_p...(more) */
    volatile        uint32_t        PWM_IN_MASK                 ; /*!< (@0x00000090) When bit X is low, enables input buffer on PWM[X+1] input pin.  The input buffer can then be used for polling the state of the PWM output via the common.io_...(more) */
} PWM_t;


#define PWM_BASE (0x70002C00u)                                                          /*!< pwm base address */

/** __PWM_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__PWM_INLINE uint32_t* __PWM_BASE_PTR(void)
{
    return (uint32_t*)(PWM_BASE);
}


/* -------------------------------------------------------------------------- */
/*                        RAMP_CONFIG member of PWM_t                        */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP_CONFIG__ADDRESS returns the address of member RAMP_CONFIG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP_CONFIG
 */
__PWM_INLINE uint32_t* __PWM_RAMP_CONFIG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP_CONFIG)));
}

/** PWM_RAMP_CONFIG__SET() sets RAMP_CONFIG to given value.
 *
 * When writing to RAMP_CONFIG, this is mandatory to use.
 *
 * @param value new value for RAMP_CONFIG
 */
__PWM_INLINE void PWM_RAMP_CONFIG__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP_CONFIG__ADDRESS(), value);
}

/** PWM_RAMP_CONFIG__GET() gets RAMP_CONFIG's current value.
 *
 * When reading from RAMP_CONFIG, this is mandatory to use.
 *
 * @return current value of RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__GET(void)
{
    return HAL_GET32(__PWM_RAMP_CONFIG__ADDRESS());
}

/* ------------------- PWM.RAMP_CONFIG.COMPENSATION_SLOPE ------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.COMPENSATION_SLOPE:

    Defines the compensation ramp slope when Peack Current Mode Control selected as modulation type by mode_control_loop0 or mode_control_loop1.
    <start table>
    0 "Vout / L"
    1 "Vout / 2L"
    2 "Vout / 4L"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Pos                18                                                                     /*!< Right-most bit position of compensation_slope in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Msk                (0x00000003UL << PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Pos)             /*!< Mask for compensation_slope in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Shift(v)           (((v) << PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Pos) & PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Msk) /*!< Shift value 'v' into compensation_slope and mask 'v' to fit it into compensation_slope field */

/** PWM_RAMP_CONFIG__COMPENSATION_SLOPE__SET() sets RAMP_CONFIG.COMPENSATION_SLOPE to given value.
 *
 * When writing to RAMP_CONFIG.COMPENSATION_SLOPE, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.COMPENSATION_SLOPE
 */
__PWM_INLINE void PWM_RAMP_CONFIG__COMPENSATION_SLOPE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__COMPENSATION_SLOPE__GET() gets RAMP_CONFIG.COMPENSATION_SLOPE's current value.
 *
 * When reading from RAMP_CONFIG.COMPENSATION_SLOPE, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.COMPENSATION_SLOPE
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__COMPENSATION_SLOPE__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__COMPENSATION_SLOPE__MODIFY() modifies RAMP_CONFIG.COMPENSATION_SLOPE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.COMPENSATION_SLOPE
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__COMPENSATION_SLOPE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__COMPENSATION_SLOPE__EXTRACT() extracts RAMP_CONFIG.COMPENSATION_SLOPE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.COMPENSATION_SLOPE
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__COMPENSATION_SLOPE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__COMPENSATION_SLOPE__Pos);
    return (uint32_t)reg;
}

/* -------------------- PWM.RAMP_CONFIG.RAMP1_DUTYC_LOCK -------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP1_DUTYC_LOCK:

    Ramp 1 duty cycle lock enable.  When enabled, the odd half cycle duty cycle is locked to the even half cycle duty cycle prior to applying any flux balance correction.  Duty cycle lock is required when using flux balancing but may also be used without flux balance.
    <start table>
    0 "duty lock disabled"
    1 "duty lock enabled"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Pos                  17                                                                     /*!< Right-most bit position of ramp1_dutyc_lock in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Msk                  (0x00000001UL << PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Pos)               /*!< Mask for ramp1_dutyc_lock in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Shift(v)             (((v) << PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Pos) & PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Msk) /*!< Shift value 'v' into ramp1_dutyc_lock and mask 'v' to fit it into ramp1_dutyc_lock field */

/** PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__SET() sets RAMP_CONFIG.RAMP1_DUTYC_LOCK to given value.
 *
 * When writing to RAMP_CONFIG.RAMP1_DUTYC_LOCK, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP1_DUTYC_LOCK
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__GET() gets RAMP_CONFIG.RAMP1_DUTYC_LOCK's current value.
 *
 * When reading from RAMP_CONFIG.RAMP1_DUTYC_LOCK, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP1_DUTYC_LOCK
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__MODIFY() modifies RAMP_CONFIG.RAMP1_DUTYC_LOCK.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP1_DUTYC_LOCK
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__EXTRACT() extracts RAMP_CONFIG.RAMP1_DUTYC_LOCK.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP1_DUTYC_LOCK
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_DUTYC_LOCK__Pos);
    return (uint32_t)reg;
}

/* -------------------- PWM.RAMP_CONFIG.RAMP0_DUTYC_LOCK -------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP0_DUTYC_LOCK:

    Ramp 0 duty cycle lock enable.  When enabled, the odd half cycle duty cycle is locked to the even half cycle duty cycle prior to applying any flux balance correction.  Duty cycle lock is required when using flux balancing but may also be used without flux balance.
    <start table>
    0 "duty lock disabled"
    1 "duty lock enabled"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Pos                  16                                                                     /*!< Right-most bit position of ramp0_dutyc_lock in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Msk                  (0x00000001UL << PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Pos)               /*!< Mask for ramp0_dutyc_lock in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Shift(v)             (((v) << PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Pos) & PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Msk) /*!< Shift value 'v' into ramp0_dutyc_lock and mask 'v' to fit it into ramp0_dutyc_lock field */

/** PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__SET() sets RAMP_CONFIG.RAMP0_DUTYC_LOCK to given value.
 *
 * When writing to RAMP_CONFIG.RAMP0_DUTYC_LOCK, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP0_DUTYC_LOCK
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__GET() gets RAMP_CONFIG.RAMP0_DUTYC_LOCK's current value.
 *
 * When reading from RAMP_CONFIG.RAMP0_DUTYC_LOCK, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP0_DUTYC_LOCK
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__MODIFY() modifies RAMP_CONFIG.RAMP0_DUTYC_LOCK.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP0_DUTYC_LOCK
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__EXTRACT() extracts RAMP_CONFIG.RAMP0_DUTYC_LOCK.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP0_DUTYC_LOCK
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_DUTYC_LOCK__Pos);
    return (uint32_t)reg;
}

/* ------------------- PWM.RAMP_CONFIG.MODE_CONTROL_LOOP1 ------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.MODE_CONTROL_LOOP1:

    Loop 1 control mode select
    <start table>
    0 "voltage mode control (VMC)"
    1 "peak current mode control (PCMC) on secondary"
    2 "peak current mode control (PCMC) on primary"
    3 "reserved"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Pos                14                                                                     /*!< Right-most bit position of mode_control_loop1 in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Msk                (0x00000003UL << PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Pos)             /*!< Mask for mode_control_loop1 in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Shift(v)           (((v) << PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Pos) & PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Msk) /*!< Shift value 'v' into mode_control_loop1 and mask 'v' to fit it into mode_control_loop1 field */

/** PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__SET() sets RAMP_CONFIG.MODE_CONTROL_LOOP1 to given value.
 *
 * When writing to RAMP_CONFIG.MODE_CONTROL_LOOP1, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.MODE_CONTROL_LOOP1
 */
__PWM_INLINE void PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__GET() gets RAMP_CONFIG.MODE_CONTROL_LOOP1's current value.
 *
 * When reading from RAMP_CONFIG.MODE_CONTROL_LOOP1, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.MODE_CONTROL_LOOP1
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__MODIFY() modifies RAMP_CONFIG.MODE_CONTROL_LOOP1.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.MODE_CONTROL_LOOP1
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__EXTRACT() extracts RAMP_CONFIG.MODE_CONTROL_LOOP1.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.MODE_CONTROL_LOOP1
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__MODE_CONTROL_LOOP1__Pos);
    return (uint32_t)reg;
}

/* ------------------- PWM.RAMP_CONFIG.MODE_CONTROL_LOOP0 ------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.MODE_CONTROL_LOOP0:

    Loop 0 control mode select
    <start table>
    0 "voltage mode control (VMC)"
    1 "peak current mode control (PCMC) on secondary"
    2 "peak current mode control (PCMC) on primary"
    3 "reserved"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Pos                12                                                                     /*!< Right-most bit position of mode_control_loop0 in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Msk                (0x00000003UL << PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Pos)             /*!< Mask for mode_control_loop0 in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Shift(v)           (((v) << PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Pos) & PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Msk) /*!< Shift value 'v' into mode_control_loop0 and mask 'v' to fit it into mode_control_loop0 field */

/** PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__SET() sets RAMP_CONFIG.MODE_CONTROL_LOOP0 to given value.
 *
 * When writing to RAMP_CONFIG.MODE_CONTROL_LOOP0, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.MODE_CONTROL_LOOP0
 */
__PWM_INLINE void PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__GET() gets RAMP_CONFIG.MODE_CONTROL_LOOP0's current value.
 *
 * When reading from RAMP_CONFIG.MODE_CONTROL_LOOP0, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.MODE_CONTROL_LOOP0
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__MODIFY() modifies RAMP_CONFIG.MODE_CONTROL_LOOP0.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.MODE_CONTROL_LOOP0
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__EXTRACT() extracts RAMP_CONFIG.MODE_CONTROL_LOOP0.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.MODE_CONTROL_LOOP0
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__MODE_CONTROL_LOOP0__Pos);
    return (uint32_t)reg;
}

/* ------------------- PWM.RAMP_CONFIG.RAMP1_MIN_PW_STATE ------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP1_MIN_PW_STATE:

    Selects pulse generator response when pulse width from PID duty cycle is less than ramp1_pw_min.
    <start table>
    0 "Set pulse width to 0 (i.e., blank pulse)"
    1 "Set pulse width to ramp1_pw_min (i.e., lamp to min)"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Pos                11                                                                     /*!< Right-most bit position of ramp1_min_pw_state in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Msk                (0x00000001UL << PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Pos)             /*!< Mask for ramp1_min_pw_state in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Shift(v)           (((v) << PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Pos) & PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Msk) /*!< Shift value 'v' into ramp1_min_pw_state and mask 'v' to fit it into ramp1_min_pw_state field */

/** PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__SET() sets RAMP_CONFIG.RAMP1_MIN_PW_STATE to given value.
 *
 * When writing to RAMP_CONFIG.RAMP1_MIN_PW_STATE, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP1_MIN_PW_STATE
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__GET() gets RAMP_CONFIG.RAMP1_MIN_PW_STATE's current value.
 *
 * When reading from RAMP_CONFIG.RAMP1_MIN_PW_STATE, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP1_MIN_PW_STATE
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__MODIFY() modifies RAMP_CONFIG.RAMP1_MIN_PW_STATE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP1_MIN_PW_STATE
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__EXTRACT() extracts RAMP_CONFIG.RAMP1_MIN_PW_STATE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP1_MIN_PW_STATE
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_MIN_PW_STATE__Pos);
    return (uint32_t)reg;
}

/* -------------------- PWM.RAMP_CONFIG.RAMP1_HALF_MODE -------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP1_HALF_MODE:

    Half mode enable for Ramp 1.  When half mode is enabled, the ramp count is equal to half of tswitch, otherwise it is equal to tswitch.  Half mode should be enabled for the Full- and Half-Bridge topologies and disabled otherwise.
    <start table>
    0 "Half mode disabled (non-bridge topology)"
    1 "Half mode enabled (bridge topology)"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Pos                   10                                                                     /*!< Right-most bit position of ramp1_half_mode in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Msk                   (0x00000001UL << PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Pos)                /*!< Mask for ramp1_half_mode in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Shift(v)              (((v) << PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Pos) & PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Msk) /*!< Shift value 'v' into ramp1_half_mode and mask 'v' to fit it into ramp1_half_mode field */

/** PWM_RAMP_CONFIG__RAMP1_HALF_MODE__SET() sets RAMP_CONFIG.RAMP1_HALF_MODE to given value.
 *
 * When writing to RAMP_CONFIG.RAMP1_HALF_MODE, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP1_HALF_MODE
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP1_HALF_MODE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP1_HALF_MODE__GET() gets RAMP_CONFIG.RAMP1_HALF_MODE's current value.
 *
 * When reading from RAMP_CONFIG.RAMP1_HALF_MODE, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP1_HALF_MODE
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_HALF_MODE__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP1_HALF_MODE__MODIFY() modifies RAMP_CONFIG.RAMP1_HALF_MODE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP1_HALF_MODE
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_HALF_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP1_HALF_MODE__EXTRACT() extracts RAMP_CONFIG.RAMP1_HALF_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP1_HALF_MODE
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_HALF_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_HALF_MODE__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.RAMP_CONFIG.RAMP1_M_FLAVOR --------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP1_M_FLAVOR:

    Edge modulation type for Ramp 1.  Ramp 1 is used on interleaved (dual phase) or dual loop designs.  In an interleaved design, this register should match the setting of ramp0_m_flavor.
    <start table>
    00 "Dual Edge"
    01 "Leading Edge"
    1x "Trailing Edge"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Pos                    8                                                                      /*!< Right-most bit position of ramp1_m_flavor in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Msk                    (0x00000003UL << PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Pos)                 /*!< Mask for ramp1_m_flavor in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Shift(v)               (((v) << PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Pos) & PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Msk) /*!< Shift value 'v' into ramp1_m_flavor and mask 'v' to fit it into ramp1_m_flavor field */

/** PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__SET() sets RAMP_CONFIG.RAMP1_M_FLAVOR to given value.
 *
 * When writing to RAMP_CONFIG.RAMP1_M_FLAVOR, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP1_M_FLAVOR
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__GET() gets RAMP_CONFIG.RAMP1_M_FLAVOR's current value.
 *
 * When reading from RAMP_CONFIG.RAMP1_M_FLAVOR, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP1_M_FLAVOR
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__MODIFY() modifies RAMP_CONFIG.RAMP1_M_FLAVOR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP1_M_FLAVOR
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__EXTRACT() extracts RAMP_CONFIG.RAMP1_M_FLAVOR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP1_M_FLAVOR
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_M_FLAVOR__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.RAMP_CONFIG.RAMP1_SYNC_SEL --------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP1_SYNC_SEL:

    Sync select for Ramp 1.  Ramp 1 is used on interleaved (dual phase) or dual loop designs.
    <start table_with_header>
    ramp1_sync_sel "sync to" cases
    0 "Fswitch1 / no external sync" "Dual Loop with Fsw1 != Fsw0, Loop 1 only"
    1 "Fswitch0 or external sync" "Dual Loop with Fsw1 = Fsw0, Single Loop interleave phase"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Pos                    7                                                                      /*!< Right-most bit position of ramp1_sync_sel in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Msk                    (0x00000001UL << PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Pos)                 /*!< Mask for ramp1_sync_sel in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Shift(v)               (((v) << PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Pos) & PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Msk) /*!< Shift value 'v' into ramp1_sync_sel and mask 'v' to fit it into ramp1_sync_sel field */

/** PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__SET() sets RAMP_CONFIG.RAMP1_SYNC_SEL to given value.
 *
 * When writing to RAMP_CONFIG.RAMP1_SYNC_SEL, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP1_SYNC_SEL
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__GET() gets RAMP_CONFIG.RAMP1_SYNC_SEL's current value.
 *
 * When reading from RAMP_CONFIG.RAMP1_SYNC_SEL, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP1_SYNC_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__MODIFY() modifies RAMP_CONFIG.RAMP1_SYNC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP1_SYNC_SEL
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__EXTRACT() extracts RAMP_CONFIG.RAMP1_SYNC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP1_SYNC_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_SYNC_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.RAMP_CONFIG.RAMP1_PID_SEL --------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP1_PID_SEL:

    PID source select for Ramp 1.  PID0 receives its error input from the VSEN input.  PID1 receives its error input from the BVSEN input.  Ramp 1 is used on interleaved (dual phase) or dual loop designs.  PID0 should be selected on interleaved designs due to the shared Vout sense source (VSEN) on both phases.  PID1 should be selected on dual loop designs due to the different Vout sense sources on both loops.
    <start table>
    0 "PID0 (interleave)"
    1 "PID1 (dual loop)"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP1_PID_SEL__Pos                     6                                                                      /*!< Right-most bit position of ramp1_pid_sel in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_PID_SEL__Msk                     (0x00000001UL << PWM_RAMP_CONFIG__RAMP1_PID_SEL__Pos)                  /*!< Mask for ramp1_pid_sel in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP1_PID_SEL__Shift(v)                (((v) << PWM_RAMP_CONFIG__RAMP1_PID_SEL__Pos) & PWM_RAMP_CONFIG__RAMP1_PID_SEL__Msk) /*!< Shift value 'v' into ramp1_pid_sel and mask 'v' to fit it into ramp1_pid_sel field */

/** PWM_RAMP_CONFIG__RAMP1_PID_SEL__SET() sets RAMP_CONFIG.RAMP1_PID_SEL to given value.
 *
 * When writing to RAMP_CONFIG.RAMP1_PID_SEL, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP1_PID_SEL
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP1_PID_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_PID_SEL__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_PID_SEL__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP1_PID_SEL__GET() gets RAMP_CONFIG.RAMP1_PID_SEL's current value.
 *
 * When reading from RAMP_CONFIG.RAMP1_PID_SEL, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP1_PID_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_PID_SEL__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_PID_SEL__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_PID_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP1_PID_SEL__MODIFY() modifies RAMP_CONFIG.RAMP1_PID_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP1_PID_SEL
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_PID_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP1_PID_SEL__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP1_PID_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP1_PID_SEL__EXTRACT() extracts RAMP_CONFIG.RAMP1_PID_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP1_PID_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP1_PID_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP1_PID_SEL__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP1_PID_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------- PWM.RAMP_CONFIG.RAMP0_MIN_PW_STATE ------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP0_MIN_PW_STATE:

    Selects pulse generator response when pulse width from PID duty cycle is less than ramp0_pw_min.
    <start table>
    0 "Set pulse width to 0 (i.e., blank pulse)"
    1 "Set pulse width to ramp0_pw_min (i.e., clamp to min)"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Pos                5                                                                      /*!< Right-most bit position of ramp0_min_pw_state in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Msk                (0x00000001UL << PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Pos)             /*!< Mask for ramp0_min_pw_state in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Shift(v)           (((v) << PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Pos) & PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Msk) /*!< Shift value 'v' into ramp0_min_pw_state and mask 'v' to fit it into ramp0_min_pw_state field */

/** PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__SET() sets RAMP_CONFIG.RAMP0_MIN_PW_STATE to given value.
 *
 * When writing to RAMP_CONFIG.RAMP0_MIN_PW_STATE, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP0_MIN_PW_STATE
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__GET() gets RAMP_CONFIG.RAMP0_MIN_PW_STATE's current value.
 *
 * When reading from RAMP_CONFIG.RAMP0_MIN_PW_STATE, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP0_MIN_PW_STATE
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__MODIFY() modifies RAMP_CONFIG.RAMP0_MIN_PW_STATE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP0_MIN_PW_STATE
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__EXTRACT() extracts RAMP_CONFIG.RAMP0_MIN_PW_STATE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP0_MIN_PW_STATE
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_MIN_PW_STATE__Pos);
    return (uint32_t)reg;
}

/* -------------------- PWM.RAMP_CONFIG.RAMP0_HALF_MODE -------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP0_HALF_MODE:

    Half mode enable for Ramp 0.  When half mode is enabled, the ramp count is equal to half of tswitch, otherwise it is equal to tswitch.  Half mode should be enabled for the Full- and Half-Bridge primary side topologies and disabled otherwise.
    <start table>
    0 "Half mode disabled (non-bridge topology)"
    1 "Half mode enabled (bridge topology)"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Pos                   4                                                                      /*!< Right-most bit position of ramp0_half_mode in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Msk                   (0x00000001UL << PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Pos)                /*!< Mask for ramp0_half_mode in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Shift(v)              (((v) << PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Pos) & PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Msk) /*!< Shift value 'v' into ramp0_half_mode and mask 'v' to fit it into ramp0_half_mode field */

/** PWM_RAMP_CONFIG__RAMP0_HALF_MODE__SET() sets RAMP_CONFIG.RAMP0_HALF_MODE to given value.
 *
 * When writing to RAMP_CONFIG.RAMP0_HALF_MODE, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP0_HALF_MODE
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP0_HALF_MODE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP0_HALF_MODE__GET() gets RAMP_CONFIG.RAMP0_HALF_MODE's current value.
 *
 * When reading from RAMP_CONFIG.RAMP0_HALF_MODE, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP0_HALF_MODE
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_HALF_MODE__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP0_HALF_MODE__MODIFY() modifies RAMP_CONFIG.RAMP0_HALF_MODE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP0_HALF_MODE
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_HALF_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP0_HALF_MODE__EXTRACT() extracts RAMP_CONFIG.RAMP0_HALF_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP0_HALF_MODE
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_HALF_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_HALF_MODE__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.RAMP_CONFIG.RAMP0_M_FLAVOR --------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP0_M_FLAVOR:

    Edge modulation type for Ramp 0
    <start table>
    00 "Dual Edge"
    01 "Leading Edge"
    1x "Trailing Edge"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Pos                    2                                                                      /*!< Right-most bit position of ramp0_m_flavor in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Msk                    (0x00000003UL << PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Pos)                 /*!< Mask for ramp0_m_flavor in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Shift(v)               (((v) << PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Pos) & PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Msk) /*!< Shift value 'v' into ramp0_m_flavor and mask 'v' to fit it into ramp0_m_flavor field */

/** PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__SET() sets RAMP_CONFIG.RAMP0_M_FLAVOR to given value.
 *
 * When writing to RAMP_CONFIG.RAMP0_M_FLAVOR, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP0_M_FLAVOR
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__GET() gets RAMP_CONFIG.RAMP0_M_FLAVOR's current value.
 *
 * When reading from RAMP_CONFIG.RAMP0_M_FLAVOR, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP0_M_FLAVOR
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__MODIFY() modifies RAMP_CONFIG.RAMP0_M_FLAVOR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP0_M_FLAVOR
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__EXTRACT() extracts RAMP_CONFIG.RAMP0_M_FLAVOR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP0_M_FLAVOR
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_M_FLAVOR__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.RAMP_CONFIG.RAMP0_SYNC_SEL --------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP0_SYNC_SEL:

    Sync select for Ramp 0
    <start table>
    "Should always be set to 1."
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Pos                    1                                                                      /*!< Right-most bit position of ramp0_sync_sel in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Msk                    (0x00000001UL << PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Pos)                 /*!< Mask for ramp0_sync_sel in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Shift(v)               (((v) << PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Pos) & PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Msk) /*!< Shift value 'v' into ramp0_sync_sel and mask 'v' to fit it into ramp0_sync_sel field */

/** PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__SET() sets RAMP_CONFIG.RAMP0_SYNC_SEL to given value.
 *
 * When writing to RAMP_CONFIG.RAMP0_SYNC_SEL, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP0_SYNC_SEL
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__GET() gets RAMP_CONFIG.RAMP0_SYNC_SEL's current value.
 *
 * When reading from RAMP_CONFIG.RAMP0_SYNC_SEL, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP0_SYNC_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__MODIFY() modifies RAMP_CONFIG.RAMP0_SYNC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP0_SYNC_SEL
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__EXTRACT() extracts RAMP_CONFIG.RAMP0_SYNC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP0_SYNC_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_SYNC_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.RAMP_CONFIG.RAMP0_PID_SEL --------------------- */

/**
<pre>
  PWM.RAMP_CONFIG.RAMP0_PID_SEL:

    PID source select for Ramp 0.  PID0 receives its error input from the VSEN input.  PID1 receives its error input from the BVSEN input.  Generally, Ramp 0 should always use PID0.
    <start table>
    0 "PID0 (typical setting)"
    1 "PID1"
    <end table>

</pre> */

#define PWM_RAMP_CONFIG__RAMP0_PID_SEL__Pos                     0                                                                      /*!< Right-most bit position of ramp0_pid_sel in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_PID_SEL__Msk                     (0x00000001UL << PWM_RAMP_CONFIG__RAMP0_PID_SEL__Pos)                  /*!< Mask for ramp0_pid_sel in PWM.RAMP_CONFIG */
#define PWM_RAMP_CONFIG__RAMP0_PID_SEL__Shift(v)                (((v) << PWM_RAMP_CONFIG__RAMP0_PID_SEL__Pos) & PWM_RAMP_CONFIG__RAMP0_PID_SEL__Msk) /*!< Shift value 'v' into ramp0_pid_sel and mask 'v' to fit it into ramp0_pid_sel field */

/** PWM_RAMP_CONFIG__RAMP0_PID_SEL__SET() sets RAMP_CONFIG.RAMP0_PID_SEL to given value.
 *
 * When writing to RAMP_CONFIG.RAMP0_PID_SEL, this is recommended to use.
 *
 * @param bf_value new value for RAMP_CONFIG.RAMP0_PID_SEL
 */
__PWM_INLINE void PWM_RAMP_CONFIG__RAMP0_PID_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_PID_SEL__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_PID_SEL__Shift((uint32_t)bf_value)));
    PWM_RAMP_CONFIG__SET(reg);
}

/** PWM_RAMP_CONFIG__RAMP0_PID_SEL__GET() gets RAMP_CONFIG.RAMP0_PID_SEL's current value.
 *
 * When reading from RAMP_CONFIG.RAMP0_PID_SEL, this is recommended to use.
 *
 * @return current value of RAMP_CONFIG.RAMP0_PID_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_PID_SEL__GET(void)
{
    uint32_t reg = PWM_RAMP_CONFIG__GET();
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_PID_SEL__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_PID_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_CONFIG__RAMP0_PID_SEL__MODIFY() modifies RAMP_CONFIG.RAMP0_PID_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @param bf_value new value for RAMP_CONFIG.RAMP0_PID_SEL
 * @return new value of PWM.RAMP_CONFIG
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_PID_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_CONFIG__RAMP0_PID_SEL__Msk);
    reg = (reg | (PWM_RAMP_CONFIG__RAMP0_PID_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_CONFIG__RAMP0_PID_SEL__EXTRACT() extracts RAMP_CONFIG.RAMP0_PID_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_CONFIG
 * @return current value of RAMP_CONFIG.RAMP0_PID_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_CONFIG__RAMP0_PID_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_CONFIG__RAMP0_PID_SEL__Msk);
    reg = (reg >> PWM_RAMP_CONFIG__RAMP0_PID_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         PWM_TOPO_1 member of PWM_t                         */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM_TOPO_1__ADDRESS returns the address of member PWM_TOPO_1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM_TOPO_1
 */
__PWM_INLINE uint32_t* __PWM_PWM_TOPO_1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM_TOPO_1)));
}

/** PWM_PWM_TOPO_1__SET() sets PWM_TOPO_1 to given value.
 *
 * When writing to PWM_TOPO_1, this is mandatory to use.
 *
 * @param value new value for PWM_TOPO_1
 */
__PWM_INLINE void PWM_PWM_TOPO_1__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM_TOPO_1__ADDRESS(), value);
}

/** PWM_PWM_TOPO_1__GET() gets PWM_TOPO_1's current value.
 *
 * When reading from PWM_TOPO_1, this is mandatory to use.
 *
 * @return current value of PWM_TOPO_1
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__GET(void)
{
    return HAL_GET32(__PWM_PWM_TOPO_1__ADDRESS());
}

/* ---------------------- PWM.PWM_TOPO_1.PWM4_RISE_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_1.PWM4_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_1__PWM4_RISE_SEL__Pos                      24                                                                     /*!< Right-most bit position of pwm4_rise_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM4_RISE_SEL__Msk                      (0x0000000FUL << PWM_PWM_TOPO_1__PWM4_RISE_SEL__Pos)                   /*!< Mask for pwm4_rise_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM4_RISE_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_1__PWM4_RISE_SEL__Pos) & PWM_PWM_TOPO_1__PWM4_RISE_SEL__Msk) /*!< Shift value 'v' into pwm4_rise_sel and mask 'v' to fit it into pwm4_rise_sel field */

/** PWM_PWM_TOPO_1__PWM4_RISE_SEL__SET() sets PWM_TOPO_1.PWM4_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_1.PWM4_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_1.PWM4_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_1__PWM4_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & ~PWM_PWM_TOPO_1__PWM4_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM4_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_1__SET(reg);
}

/** PWM_PWM_TOPO_1__PWM4_RISE_SEL__GET() gets PWM_TOPO_1.PWM4_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_1.PWM4_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_1.PWM4_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM4_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & PWM_PWM_TOPO_1__PWM4_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM4_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_1__PWM4_RISE_SEL__MODIFY() modifies PWM_TOPO_1.PWM4_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @param bf_value new value for PWM_TOPO_1.PWM4_RISE_SEL
 * @return new value of PWM.PWM_TOPO_1
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM4_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_1__PWM4_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM4_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_1__PWM4_RISE_SEL__EXTRACT() extracts PWM_TOPO_1.PWM4_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @return current value of PWM_TOPO_1.PWM4_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM4_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_1__PWM4_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM4_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_1.PWM4_FALL_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_1.PWM4_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_1__PWM4_FALL_SEL__Pos                      21                                                                     /*!< Right-most bit position of pwm4_fall_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM4_FALL_SEL__Msk                      (0x00000007UL << PWM_PWM_TOPO_1__PWM4_FALL_SEL__Pos)                   /*!< Mask for pwm4_fall_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM4_FALL_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_1__PWM4_FALL_SEL__Pos) & PWM_PWM_TOPO_1__PWM4_FALL_SEL__Msk) /*!< Shift value 'v' into pwm4_fall_sel and mask 'v' to fit it into pwm4_fall_sel field */

/** PWM_PWM_TOPO_1__PWM4_FALL_SEL__SET() sets PWM_TOPO_1.PWM4_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_1.PWM4_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_1.PWM4_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_1__PWM4_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & ~PWM_PWM_TOPO_1__PWM4_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM4_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_1__SET(reg);
}

/** PWM_PWM_TOPO_1__PWM4_FALL_SEL__GET() gets PWM_TOPO_1.PWM4_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_1.PWM4_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_1.PWM4_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM4_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & PWM_PWM_TOPO_1__PWM4_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM4_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_1__PWM4_FALL_SEL__MODIFY() modifies PWM_TOPO_1.PWM4_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @param bf_value new value for PWM_TOPO_1.PWM4_FALL_SEL
 * @return new value of PWM.PWM_TOPO_1
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM4_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_1__PWM4_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM4_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_1__PWM4_FALL_SEL__EXTRACT() extracts PWM_TOPO_1.PWM4_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @return current value of PWM_TOPO_1.PWM4_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM4_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_1__PWM4_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM4_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_1.PWM3_RISE_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_1.PWM3_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_1__PWM3_RISE_SEL__Pos                      17                                                                     /*!< Right-most bit position of pwm3_rise_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM3_RISE_SEL__Msk                      (0x0000000FUL << PWM_PWM_TOPO_1__PWM3_RISE_SEL__Pos)                   /*!< Mask for pwm3_rise_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM3_RISE_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_1__PWM3_RISE_SEL__Pos) & PWM_PWM_TOPO_1__PWM3_RISE_SEL__Msk) /*!< Shift value 'v' into pwm3_rise_sel and mask 'v' to fit it into pwm3_rise_sel field */

/** PWM_PWM_TOPO_1__PWM3_RISE_SEL__SET() sets PWM_TOPO_1.PWM3_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_1.PWM3_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_1.PWM3_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_1__PWM3_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & ~PWM_PWM_TOPO_1__PWM3_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM3_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_1__SET(reg);
}

/** PWM_PWM_TOPO_1__PWM3_RISE_SEL__GET() gets PWM_TOPO_1.PWM3_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_1.PWM3_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_1.PWM3_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM3_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & PWM_PWM_TOPO_1__PWM3_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM3_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_1__PWM3_RISE_SEL__MODIFY() modifies PWM_TOPO_1.PWM3_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @param bf_value new value for PWM_TOPO_1.PWM3_RISE_SEL
 * @return new value of PWM.PWM_TOPO_1
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM3_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_1__PWM3_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM3_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_1__PWM3_RISE_SEL__EXTRACT() extracts PWM_TOPO_1.PWM3_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @return current value of PWM_TOPO_1.PWM3_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM3_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_1__PWM3_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM3_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_1.PWM3_FALL_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_1.PWM3_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_1__PWM3_FALL_SEL__Pos                      14                                                                     /*!< Right-most bit position of pwm3_fall_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM3_FALL_SEL__Msk                      (0x00000007UL << PWM_PWM_TOPO_1__PWM3_FALL_SEL__Pos)                   /*!< Mask for pwm3_fall_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM3_FALL_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_1__PWM3_FALL_SEL__Pos) & PWM_PWM_TOPO_1__PWM3_FALL_SEL__Msk) /*!< Shift value 'v' into pwm3_fall_sel and mask 'v' to fit it into pwm3_fall_sel field */

/** PWM_PWM_TOPO_1__PWM3_FALL_SEL__SET() sets PWM_TOPO_1.PWM3_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_1.PWM3_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_1.PWM3_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_1__PWM3_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & ~PWM_PWM_TOPO_1__PWM3_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM3_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_1__SET(reg);
}

/** PWM_PWM_TOPO_1__PWM3_FALL_SEL__GET() gets PWM_TOPO_1.PWM3_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_1.PWM3_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_1.PWM3_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM3_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & PWM_PWM_TOPO_1__PWM3_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM3_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_1__PWM3_FALL_SEL__MODIFY() modifies PWM_TOPO_1.PWM3_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @param bf_value new value for PWM_TOPO_1.PWM3_FALL_SEL
 * @return new value of PWM.PWM_TOPO_1
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM3_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_1__PWM3_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM3_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_1__PWM3_FALL_SEL__EXTRACT() extracts PWM_TOPO_1.PWM3_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @return current value of PWM_TOPO_1.PWM3_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM3_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_1__PWM3_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM3_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_1.PWM2_RISE_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_1.PWM2_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table>
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_1__PWM2_RISE_SEL__Pos                      10                                                                     /*!< Right-most bit position of pwm2_rise_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM2_RISE_SEL__Msk                      (0x0000000FUL << PWM_PWM_TOPO_1__PWM2_RISE_SEL__Pos)                   /*!< Mask for pwm2_rise_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM2_RISE_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_1__PWM2_RISE_SEL__Pos) & PWM_PWM_TOPO_1__PWM2_RISE_SEL__Msk) /*!< Shift value 'v' into pwm2_rise_sel and mask 'v' to fit it into pwm2_rise_sel field */

/** PWM_PWM_TOPO_1__PWM2_RISE_SEL__SET() sets PWM_TOPO_1.PWM2_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_1.PWM2_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_1.PWM2_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_1__PWM2_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & ~PWM_PWM_TOPO_1__PWM2_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM2_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_1__SET(reg);
}

/** PWM_PWM_TOPO_1__PWM2_RISE_SEL__GET() gets PWM_TOPO_1.PWM2_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_1.PWM2_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_1.PWM2_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM2_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & PWM_PWM_TOPO_1__PWM2_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM2_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_1__PWM2_RISE_SEL__MODIFY() modifies PWM_TOPO_1.PWM2_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @param bf_value new value for PWM_TOPO_1.PWM2_RISE_SEL
 * @return new value of PWM.PWM_TOPO_1
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM2_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_1__PWM2_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM2_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_1__PWM2_RISE_SEL__EXTRACT() extracts PWM_TOPO_1.PWM2_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @return current value of PWM_TOPO_1.PWM2_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM2_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_1__PWM2_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM2_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_1.PWM2_FALL_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_1.PWM2_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_1__PWM2_FALL_SEL__Pos                      7                                                                      /*!< Right-most bit position of pwm2_fall_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM2_FALL_SEL__Msk                      (0x00000007UL << PWM_PWM_TOPO_1__PWM2_FALL_SEL__Pos)                   /*!< Mask for pwm2_fall_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM2_FALL_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_1__PWM2_FALL_SEL__Pos) & PWM_PWM_TOPO_1__PWM2_FALL_SEL__Msk) /*!< Shift value 'v' into pwm2_fall_sel and mask 'v' to fit it into pwm2_fall_sel field */

/** PWM_PWM_TOPO_1__PWM2_FALL_SEL__SET() sets PWM_TOPO_1.PWM2_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_1.PWM2_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_1.PWM2_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_1__PWM2_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & ~PWM_PWM_TOPO_1__PWM2_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM2_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_1__SET(reg);
}

/** PWM_PWM_TOPO_1__PWM2_FALL_SEL__GET() gets PWM_TOPO_1.PWM2_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_1.PWM2_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_1.PWM2_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM2_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & PWM_PWM_TOPO_1__PWM2_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM2_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_1__PWM2_FALL_SEL__MODIFY() modifies PWM_TOPO_1.PWM2_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @param bf_value new value for PWM_TOPO_1.PWM2_FALL_SEL
 * @return new value of PWM.PWM_TOPO_1
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM2_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_1__PWM2_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM2_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_1__PWM2_FALL_SEL__EXTRACT() extracts PWM_TOPO_1.PWM2_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @return current value of PWM_TOPO_1.PWM2_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM2_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_1__PWM2_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM2_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_1.PWM1_RISE_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_1.PWM1_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_1__PWM1_RISE_SEL__Pos                      3                                                                      /*!< Right-most bit position of pwm1_rise_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM1_RISE_SEL__Msk                      (0x0000000FUL << PWM_PWM_TOPO_1__PWM1_RISE_SEL__Pos)                   /*!< Mask for pwm1_rise_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM1_RISE_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_1__PWM1_RISE_SEL__Pos) & PWM_PWM_TOPO_1__PWM1_RISE_SEL__Msk) /*!< Shift value 'v' into pwm1_rise_sel and mask 'v' to fit it into pwm1_rise_sel field */

/** PWM_PWM_TOPO_1__PWM1_RISE_SEL__SET() sets PWM_TOPO_1.PWM1_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_1.PWM1_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_1.PWM1_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_1__PWM1_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & ~PWM_PWM_TOPO_1__PWM1_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM1_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_1__SET(reg);
}

/** PWM_PWM_TOPO_1__PWM1_RISE_SEL__GET() gets PWM_TOPO_1.PWM1_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_1.PWM1_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_1.PWM1_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM1_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & PWM_PWM_TOPO_1__PWM1_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM1_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_1__PWM1_RISE_SEL__MODIFY() modifies PWM_TOPO_1.PWM1_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @param bf_value new value for PWM_TOPO_1.PWM1_RISE_SEL
 * @return new value of PWM.PWM_TOPO_1
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM1_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_1__PWM1_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM1_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_1__PWM1_RISE_SEL__EXTRACT() extracts PWM_TOPO_1.PWM1_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @return current value of PWM_TOPO_1.PWM1_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM1_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_1__PWM1_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM1_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_1.PWM1_FALL_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_1.PWM1_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_1__PWM1_FALL_SEL__Pos                      0                                                                      /*!< Right-most bit position of pwm1_fall_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM1_FALL_SEL__Msk                      (0x00000007UL << PWM_PWM_TOPO_1__PWM1_FALL_SEL__Pos)                   /*!< Mask for pwm1_fall_sel in PWM.PWM_TOPO_1 */
#define PWM_PWM_TOPO_1__PWM1_FALL_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_1__PWM1_FALL_SEL__Pos) & PWM_PWM_TOPO_1__PWM1_FALL_SEL__Msk) /*!< Shift value 'v' into pwm1_fall_sel and mask 'v' to fit it into pwm1_fall_sel field */

/** PWM_PWM_TOPO_1__PWM1_FALL_SEL__SET() sets PWM_TOPO_1.PWM1_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_1.PWM1_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_1.PWM1_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_1__PWM1_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & ~PWM_PWM_TOPO_1__PWM1_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM1_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_1__SET(reg);
}

/** PWM_PWM_TOPO_1__PWM1_FALL_SEL__GET() gets PWM_TOPO_1.PWM1_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_1.PWM1_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_1.PWM1_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM1_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_1__GET();
    reg = (reg & PWM_PWM_TOPO_1__PWM1_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM1_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_1__PWM1_FALL_SEL__MODIFY() modifies PWM_TOPO_1.PWM1_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @param bf_value new value for PWM_TOPO_1.PWM1_FALL_SEL
 * @return new value of PWM.PWM_TOPO_1
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM1_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_1__PWM1_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_1__PWM1_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_1__PWM1_FALL_SEL__EXTRACT() extracts PWM_TOPO_1.PWM1_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_1
 * @return current value of PWM_TOPO_1.PWM1_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_1__PWM1_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_1__PWM1_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_1__PWM1_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         PWM_TOPO_2 member of PWM_t                         */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM_TOPO_2__ADDRESS returns the address of member PWM_TOPO_2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM_TOPO_2
 */
__PWM_INLINE uint32_t* __PWM_PWM_TOPO_2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM_TOPO_2)));
}

/** PWM_PWM_TOPO_2__SET() sets PWM_TOPO_2 to given value.
 *
 * When writing to PWM_TOPO_2, this is mandatory to use.
 *
 * @param value new value for PWM_TOPO_2
 */
__PWM_INLINE void PWM_PWM_TOPO_2__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM_TOPO_2__ADDRESS(), value);
}

/** PWM_PWM_TOPO_2__GET() gets PWM_TOPO_2's current value.
 *
 * When reading from PWM_TOPO_2, this is mandatory to use.
 *
 * @return current value of PWM_TOPO_2
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__GET(void)
{
    return HAL_GET32(__PWM_PWM_TOPO_2__ADDRESS());
}

/* ---------------------- PWM.PWM_TOPO_2.PWM8_RISE_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_2.PWM8_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_2__PWM8_RISE_SEL__Pos                      24                                                                     /*!< Right-most bit position of pwm8_rise_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM8_RISE_SEL__Msk                      (0x0000000FUL << PWM_PWM_TOPO_2__PWM8_RISE_SEL__Pos)                   /*!< Mask for pwm8_rise_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM8_RISE_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_2__PWM8_RISE_SEL__Pos) & PWM_PWM_TOPO_2__PWM8_RISE_SEL__Msk) /*!< Shift value 'v' into pwm8_rise_sel and mask 'v' to fit it into pwm8_rise_sel field */

/** PWM_PWM_TOPO_2__PWM8_RISE_SEL__SET() sets PWM_TOPO_2.PWM8_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_2.PWM8_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_2.PWM8_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_2__PWM8_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & ~PWM_PWM_TOPO_2__PWM8_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM8_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_2__SET(reg);
}

/** PWM_PWM_TOPO_2__PWM8_RISE_SEL__GET() gets PWM_TOPO_2.PWM8_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_2.PWM8_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_2.PWM8_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM8_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & PWM_PWM_TOPO_2__PWM8_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM8_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_2__PWM8_RISE_SEL__MODIFY() modifies PWM_TOPO_2.PWM8_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @param bf_value new value for PWM_TOPO_2.PWM8_RISE_SEL
 * @return new value of PWM.PWM_TOPO_2
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM8_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_2__PWM8_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM8_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_2__PWM8_RISE_SEL__EXTRACT() extracts PWM_TOPO_2.PWM8_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @return current value of PWM_TOPO_2.PWM8_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM8_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_2__PWM8_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM8_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_2.PWM8_FALL_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_2.PWM8_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_2__PWM8_FALL_SEL__Pos                      21                                                                     /*!< Right-most bit position of pwm8_fall_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM8_FALL_SEL__Msk                      (0x00000007UL << PWM_PWM_TOPO_2__PWM8_FALL_SEL__Pos)                   /*!< Mask for pwm8_fall_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM8_FALL_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_2__PWM8_FALL_SEL__Pos) & PWM_PWM_TOPO_2__PWM8_FALL_SEL__Msk) /*!< Shift value 'v' into pwm8_fall_sel and mask 'v' to fit it into pwm8_fall_sel field */

/** PWM_PWM_TOPO_2__PWM8_FALL_SEL__SET() sets PWM_TOPO_2.PWM8_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_2.PWM8_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_2.PWM8_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_2__PWM8_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & ~PWM_PWM_TOPO_2__PWM8_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM8_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_2__SET(reg);
}

/** PWM_PWM_TOPO_2__PWM8_FALL_SEL__GET() gets PWM_TOPO_2.PWM8_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_2.PWM8_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_2.PWM8_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM8_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & PWM_PWM_TOPO_2__PWM8_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM8_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_2__PWM8_FALL_SEL__MODIFY() modifies PWM_TOPO_2.PWM8_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @param bf_value new value for PWM_TOPO_2.PWM8_FALL_SEL
 * @return new value of PWM.PWM_TOPO_2
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM8_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_2__PWM8_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM8_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_2__PWM8_FALL_SEL__EXTRACT() extracts PWM_TOPO_2.PWM8_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @return current value of PWM_TOPO_2.PWM8_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM8_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_2__PWM8_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM8_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_2.PWM7_RISE_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_2.PWM7_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_2__PWM7_RISE_SEL__Pos                      17                                                                     /*!< Right-most bit position of pwm7_rise_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM7_RISE_SEL__Msk                      (0x0000000FUL << PWM_PWM_TOPO_2__PWM7_RISE_SEL__Pos)                   /*!< Mask for pwm7_rise_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM7_RISE_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_2__PWM7_RISE_SEL__Pos) & PWM_PWM_TOPO_2__PWM7_RISE_SEL__Msk) /*!< Shift value 'v' into pwm7_rise_sel and mask 'v' to fit it into pwm7_rise_sel field */

/** PWM_PWM_TOPO_2__PWM7_RISE_SEL__SET() sets PWM_TOPO_2.PWM7_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_2.PWM7_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_2.PWM7_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_2__PWM7_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & ~PWM_PWM_TOPO_2__PWM7_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM7_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_2__SET(reg);
}

/** PWM_PWM_TOPO_2__PWM7_RISE_SEL__GET() gets PWM_TOPO_2.PWM7_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_2.PWM7_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_2.PWM7_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM7_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & PWM_PWM_TOPO_2__PWM7_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM7_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_2__PWM7_RISE_SEL__MODIFY() modifies PWM_TOPO_2.PWM7_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @param bf_value new value for PWM_TOPO_2.PWM7_RISE_SEL
 * @return new value of PWM.PWM_TOPO_2
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM7_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_2__PWM7_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM7_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_2__PWM7_RISE_SEL__EXTRACT() extracts PWM_TOPO_2.PWM7_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @return current value of PWM_TOPO_2.PWM7_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM7_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_2__PWM7_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM7_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_2.PWM7_FALL_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_2.PWM7_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_2__PWM7_FALL_SEL__Pos                      14                                                                     /*!< Right-most bit position of pwm7_fall_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM7_FALL_SEL__Msk                      (0x00000007UL << PWM_PWM_TOPO_2__PWM7_FALL_SEL__Pos)                   /*!< Mask for pwm7_fall_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM7_FALL_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_2__PWM7_FALL_SEL__Pos) & PWM_PWM_TOPO_2__PWM7_FALL_SEL__Msk) /*!< Shift value 'v' into pwm7_fall_sel and mask 'v' to fit it into pwm7_fall_sel field */

/** PWM_PWM_TOPO_2__PWM7_FALL_SEL__SET() sets PWM_TOPO_2.PWM7_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_2.PWM7_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_2.PWM7_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_2__PWM7_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & ~PWM_PWM_TOPO_2__PWM7_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM7_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_2__SET(reg);
}

/** PWM_PWM_TOPO_2__PWM7_FALL_SEL__GET() gets PWM_TOPO_2.PWM7_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_2.PWM7_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_2.PWM7_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM7_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & PWM_PWM_TOPO_2__PWM7_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM7_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_2__PWM7_FALL_SEL__MODIFY() modifies PWM_TOPO_2.PWM7_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @param bf_value new value for PWM_TOPO_2.PWM7_FALL_SEL
 * @return new value of PWM.PWM_TOPO_2
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM7_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_2__PWM7_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM7_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_2__PWM7_FALL_SEL__EXTRACT() extracts PWM_TOPO_2.PWM7_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @return current value of PWM_TOPO_2.PWM7_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM7_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_2__PWM7_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM7_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_2.PWM6_RISE_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_2.PWM6_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_2__PWM6_RISE_SEL__Pos                      10                                                                     /*!< Right-most bit position of pwm6_rise_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM6_RISE_SEL__Msk                      (0x0000000FUL << PWM_PWM_TOPO_2__PWM6_RISE_SEL__Pos)                   /*!< Mask for pwm6_rise_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM6_RISE_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_2__PWM6_RISE_SEL__Pos) & PWM_PWM_TOPO_2__PWM6_RISE_SEL__Msk) /*!< Shift value 'v' into pwm6_rise_sel and mask 'v' to fit it into pwm6_rise_sel field */

/** PWM_PWM_TOPO_2__PWM6_RISE_SEL__SET() sets PWM_TOPO_2.PWM6_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_2.PWM6_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_2.PWM6_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_2__PWM6_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & ~PWM_PWM_TOPO_2__PWM6_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM6_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_2__SET(reg);
}

/** PWM_PWM_TOPO_2__PWM6_RISE_SEL__GET() gets PWM_TOPO_2.PWM6_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_2.PWM6_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_2.PWM6_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM6_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & PWM_PWM_TOPO_2__PWM6_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM6_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_2__PWM6_RISE_SEL__MODIFY() modifies PWM_TOPO_2.PWM6_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @param bf_value new value for PWM_TOPO_2.PWM6_RISE_SEL
 * @return new value of PWM.PWM_TOPO_2
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM6_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_2__PWM6_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM6_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_2__PWM6_RISE_SEL__EXTRACT() extracts PWM_TOPO_2.PWM6_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @return current value of PWM_TOPO_2.PWM6_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM6_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_2__PWM6_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM6_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_2.PWM6_FALL_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_2.PWM6_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_2__PWM6_FALL_SEL__Pos                      7                                                                      /*!< Right-most bit position of pwm6_fall_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM6_FALL_SEL__Msk                      (0x00000007UL << PWM_PWM_TOPO_2__PWM6_FALL_SEL__Pos)                   /*!< Mask for pwm6_fall_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM6_FALL_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_2__PWM6_FALL_SEL__Pos) & PWM_PWM_TOPO_2__PWM6_FALL_SEL__Msk) /*!< Shift value 'v' into pwm6_fall_sel and mask 'v' to fit it into pwm6_fall_sel field */

/** PWM_PWM_TOPO_2__PWM6_FALL_SEL__SET() sets PWM_TOPO_2.PWM6_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_2.PWM6_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_2.PWM6_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_2__PWM6_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & ~PWM_PWM_TOPO_2__PWM6_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM6_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_2__SET(reg);
}

/** PWM_PWM_TOPO_2__PWM6_FALL_SEL__GET() gets PWM_TOPO_2.PWM6_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_2.PWM6_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_2.PWM6_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM6_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & PWM_PWM_TOPO_2__PWM6_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM6_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_2__PWM6_FALL_SEL__MODIFY() modifies PWM_TOPO_2.PWM6_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @param bf_value new value for PWM_TOPO_2.PWM6_FALL_SEL
 * @return new value of PWM.PWM_TOPO_2
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM6_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_2__PWM6_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM6_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_2__PWM6_FALL_SEL__EXTRACT() extracts PWM_TOPO_2.PWM6_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @return current value of PWM_TOPO_2.PWM6_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM6_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_2__PWM6_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM6_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_2.PWM5_RISE_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_2.PWM5_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_2__PWM5_RISE_SEL__Pos                      3                                                                      /*!< Right-most bit position of pwm5_rise_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM5_RISE_SEL__Msk                      (0x0000000FUL << PWM_PWM_TOPO_2__PWM5_RISE_SEL__Pos)                   /*!< Mask for pwm5_rise_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM5_RISE_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_2__PWM5_RISE_SEL__Pos) & PWM_PWM_TOPO_2__PWM5_RISE_SEL__Msk) /*!< Shift value 'v' into pwm5_rise_sel and mask 'v' to fit it into pwm5_rise_sel field */

/** PWM_PWM_TOPO_2__PWM5_RISE_SEL__SET() sets PWM_TOPO_2.PWM5_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_2.PWM5_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_2.PWM5_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_2__PWM5_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & ~PWM_PWM_TOPO_2__PWM5_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM5_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_2__SET(reg);
}

/** PWM_PWM_TOPO_2__PWM5_RISE_SEL__GET() gets PWM_TOPO_2.PWM5_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_2.PWM5_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_2.PWM5_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM5_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & PWM_PWM_TOPO_2__PWM5_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM5_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_2__PWM5_RISE_SEL__MODIFY() modifies PWM_TOPO_2.PWM5_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @param bf_value new value for PWM_TOPO_2.PWM5_RISE_SEL
 * @return new value of PWM.PWM_TOPO_2
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM5_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_2__PWM5_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM5_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_2__PWM5_RISE_SEL__EXTRACT() extracts PWM_TOPO_2.PWM5_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @return current value of PWM_TOPO_2.PWM5_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM5_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_2__PWM5_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM5_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_2.PWM5_FALL_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_2.PWM5_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_2__PWM5_FALL_SEL__Pos                      0                                                                      /*!< Right-most bit position of pwm5_fall_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM5_FALL_SEL__Msk                      (0x00000007UL << PWM_PWM_TOPO_2__PWM5_FALL_SEL__Pos)                   /*!< Mask for pwm5_fall_sel in PWM.PWM_TOPO_2 */
#define PWM_PWM_TOPO_2__PWM5_FALL_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_2__PWM5_FALL_SEL__Pos) & PWM_PWM_TOPO_2__PWM5_FALL_SEL__Msk) /*!< Shift value 'v' into pwm5_fall_sel and mask 'v' to fit it into pwm5_fall_sel field */

/** PWM_PWM_TOPO_2__PWM5_FALL_SEL__SET() sets PWM_TOPO_2.PWM5_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_2.PWM5_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_2.PWM5_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_2__PWM5_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & ~PWM_PWM_TOPO_2__PWM5_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM5_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_2__SET(reg);
}

/** PWM_PWM_TOPO_2__PWM5_FALL_SEL__GET() gets PWM_TOPO_2.PWM5_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_2.PWM5_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_2.PWM5_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM5_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_2__GET();
    reg = (reg & PWM_PWM_TOPO_2__PWM5_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM5_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_2__PWM5_FALL_SEL__MODIFY() modifies PWM_TOPO_2.PWM5_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @param bf_value new value for PWM_TOPO_2.PWM5_FALL_SEL
 * @return new value of PWM.PWM_TOPO_2
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM5_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_2__PWM5_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_2__PWM5_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_2__PWM5_FALL_SEL__EXTRACT() extracts PWM_TOPO_2.PWM5_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_2
 * @return current value of PWM_TOPO_2.PWM5_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_2__PWM5_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_2__PWM5_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_2__PWM5_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         PWM_TOPO_3 member of PWM_t                         */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM_TOPO_3__ADDRESS returns the address of member PWM_TOPO_3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM_TOPO_3
 */
__PWM_INLINE uint32_t* __PWM_PWM_TOPO_3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM_TOPO_3)));
}

/** PWM_PWM_TOPO_3__SET() sets PWM_TOPO_3 to given value.
 *
 * When writing to PWM_TOPO_3, this is mandatory to use.
 *
 * @param value new value for PWM_TOPO_3
 */
__PWM_INLINE void PWM_PWM_TOPO_3__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM_TOPO_3__ADDRESS(), value);
}

/** PWM_PWM_TOPO_3__GET() gets PWM_TOPO_3's current value.
 *
 * When reading from PWM_TOPO_3, this is mandatory to use.
 *
 * @return current value of PWM_TOPO_3
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__GET(void)
{
    return HAL_GET32(__PWM_PWM_TOPO_3__ADDRESS());
}

/* --------------------- PWM.PWM_TOPO_3.PWM12_RISE_SEL --------------------- */

/**
<pre>
  PWM.PWM_TOPO_3.PWM12_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_3__PWM12_RISE_SEL__Pos                     24                                                                     /*!< Right-most bit position of pwm12_rise_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM12_RISE_SEL__Msk                     (0x0000000FUL << PWM_PWM_TOPO_3__PWM12_RISE_SEL__Pos)                  /*!< Mask for pwm12_rise_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM12_RISE_SEL__Shift(v)                (((v) << PWM_PWM_TOPO_3__PWM12_RISE_SEL__Pos) & PWM_PWM_TOPO_3__PWM12_RISE_SEL__Msk) /*!< Shift value 'v' into pwm12_rise_sel and mask 'v' to fit it into pwm12_rise_sel field */

/** PWM_PWM_TOPO_3__PWM12_RISE_SEL__SET() sets PWM_TOPO_3.PWM12_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_3.PWM12_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_3.PWM12_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_3__PWM12_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & ~PWM_PWM_TOPO_3__PWM12_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM12_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_3__SET(reg);
}

/** PWM_PWM_TOPO_3__PWM12_RISE_SEL__GET() gets PWM_TOPO_3.PWM12_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_3.PWM12_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_3.PWM12_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM12_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & PWM_PWM_TOPO_3__PWM12_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM12_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_3__PWM12_RISE_SEL__MODIFY() modifies PWM_TOPO_3.PWM12_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @param bf_value new value for PWM_TOPO_3.PWM12_RISE_SEL
 * @return new value of PWM.PWM_TOPO_3
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM12_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_3__PWM12_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM12_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_3__PWM12_RISE_SEL__EXTRACT() extracts PWM_TOPO_3.PWM12_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @return current value of PWM_TOPO_3.PWM12_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM12_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_3__PWM12_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM12_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.PWM_TOPO_3.PWM12_FALL_SEL --------------------- */

/**
<pre>
  PWM.PWM_TOPO_3.PWM12_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_3__PWM12_FALL_SEL__Pos                     21                                                                     /*!< Right-most bit position of pwm12_fall_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM12_FALL_SEL__Msk                     (0x00000007UL << PWM_PWM_TOPO_3__PWM12_FALL_SEL__Pos)                  /*!< Mask for pwm12_fall_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM12_FALL_SEL__Shift(v)                (((v) << PWM_PWM_TOPO_3__PWM12_FALL_SEL__Pos) & PWM_PWM_TOPO_3__PWM12_FALL_SEL__Msk) /*!< Shift value 'v' into pwm12_fall_sel and mask 'v' to fit it into pwm12_fall_sel field */

/** PWM_PWM_TOPO_3__PWM12_FALL_SEL__SET() sets PWM_TOPO_3.PWM12_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_3.PWM12_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_3.PWM12_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_3__PWM12_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & ~PWM_PWM_TOPO_3__PWM12_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM12_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_3__SET(reg);
}

/** PWM_PWM_TOPO_3__PWM12_FALL_SEL__GET() gets PWM_TOPO_3.PWM12_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_3.PWM12_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_3.PWM12_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM12_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & PWM_PWM_TOPO_3__PWM12_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM12_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_3__PWM12_FALL_SEL__MODIFY() modifies PWM_TOPO_3.PWM12_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @param bf_value new value for PWM_TOPO_3.PWM12_FALL_SEL
 * @return new value of PWM.PWM_TOPO_3
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM12_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_3__PWM12_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM12_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_3__PWM12_FALL_SEL__EXTRACT() extracts PWM_TOPO_3.PWM12_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @return current value of PWM_TOPO_3.PWM12_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM12_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_3__PWM12_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM12_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.PWM_TOPO_3.PWM11_RISE_SEL --------------------- */

/**
<pre>
  PWM.PWM_TOPO_3.PWM11_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_3__PWM11_RISE_SEL__Pos                     17                                                                     /*!< Right-most bit position of pwm11_rise_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM11_RISE_SEL__Msk                     (0x0000000FUL << PWM_PWM_TOPO_3__PWM11_RISE_SEL__Pos)                  /*!< Mask for pwm11_rise_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM11_RISE_SEL__Shift(v)                (((v) << PWM_PWM_TOPO_3__PWM11_RISE_SEL__Pos) & PWM_PWM_TOPO_3__PWM11_RISE_SEL__Msk) /*!< Shift value 'v' into pwm11_rise_sel and mask 'v' to fit it into pwm11_rise_sel field */

/** PWM_PWM_TOPO_3__PWM11_RISE_SEL__SET() sets PWM_TOPO_3.PWM11_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_3.PWM11_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_3.PWM11_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_3__PWM11_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & ~PWM_PWM_TOPO_3__PWM11_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM11_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_3__SET(reg);
}

/** PWM_PWM_TOPO_3__PWM11_RISE_SEL__GET() gets PWM_TOPO_3.PWM11_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_3.PWM11_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_3.PWM11_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM11_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & PWM_PWM_TOPO_3__PWM11_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM11_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_3__PWM11_RISE_SEL__MODIFY() modifies PWM_TOPO_3.PWM11_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @param bf_value new value for PWM_TOPO_3.PWM11_RISE_SEL
 * @return new value of PWM.PWM_TOPO_3
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM11_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_3__PWM11_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM11_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_3__PWM11_RISE_SEL__EXTRACT() extracts PWM_TOPO_3.PWM11_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @return current value of PWM_TOPO_3.PWM11_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM11_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_3__PWM11_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM11_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.PWM_TOPO_3.PWM11_FALL_SEL --------------------- */

/**
<pre>
  PWM.PWM_TOPO_3.PWM11_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_3__PWM11_FALL_SEL__Pos                     14                                                                     /*!< Right-most bit position of pwm11_fall_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM11_FALL_SEL__Msk                     (0x00000007UL << PWM_PWM_TOPO_3__PWM11_FALL_SEL__Pos)                  /*!< Mask for pwm11_fall_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM11_FALL_SEL__Shift(v)                (((v) << PWM_PWM_TOPO_3__PWM11_FALL_SEL__Pos) & PWM_PWM_TOPO_3__PWM11_FALL_SEL__Msk) /*!< Shift value 'v' into pwm11_fall_sel and mask 'v' to fit it into pwm11_fall_sel field */

/** PWM_PWM_TOPO_3__PWM11_FALL_SEL__SET() sets PWM_TOPO_3.PWM11_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_3.PWM11_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_3.PWM11_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_3__PWM11_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & ~PWM_PWM_TOPO_3__PWM11_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM11_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_3__SET(reg);
}

/** PWM_PWM_TOPO_3__PWM11_FALL_SEL__GET() gets PWM_TOPO_3.PWM11_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_3.PWM11_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_3.PWM11_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM11_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & PWM_PWM_TOPO_3__PWM11_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM11_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_3__PWM11_FALL_SEL__MODIFY() modifies PWM_TOPO_3.PWM11_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @param bf_value new value for PWM_TOPO_3.PWM11_FALL_SEL
 * @return new value of PWM.PWM_TOPO_3
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM11_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_3__PWM11_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM11_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_3__PWM11_FALL_SEL__EXTRACT() extracts PWM_TOPO_3.PWM11_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @return current value of PWM_TOPO_3.PWM11_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM11_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_3__PWM11_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM11_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.PWM_TOPO_3.PWM10_RISE_SEL --------------------- */

/**
<pre>
  PWM.PWM_TOPO_3.PWM10_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_3__PWM10_RISE_SEL__Pos                     10                                                                     /*!< Right-most bit position of pwm10_rise_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM10_RISE_SEL__Msk                     (0x0000000FUL << PWM_PWM_TOPO_3__PWM10_RISE_SEL__Pos)                  /*!< Mask for pwm10_rise_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM10_RISE_SEL__Shift(v)                (((v) << PWM_PWM_TOPO_3__PWM10_RISE_SEL__Pos) & PWM_PWM_TOPO_3__PWM10_RISE_SEL__Msk) /*!< Shift value 'v' into pwm10_rise_sel and mask 'v' to fit it into pwm10_rise_sel field */

/** PWM_PWM_TOPO_3__PWM10_RISE_SEL__SET() sets PWM_TOPO_3.PWM10_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_3.PWM10_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_3.PWM10_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_3__PWM10_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & ~PWM_PWM_TOPO_3__PWM10_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM10_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_3__SET(reg);
}

/** PWM_PWM_TOPO_3__PWM10_RISE_SEL__GET() gets PWM_TOPO_3.PWM10_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_3.PWM10_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_3.PWM10_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM10_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & PWM_PWM_TOPO_3__PWM10_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM10_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_3__PWM10_RISE_SEL__MODIFY() modifies PWM_TOPO_3.PWM10_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @param bf_value new value for PWM_TOPO_3.PWM10_RISE_SEL
 * @return new value of PWM.PWM_TOPO_3
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM10_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_3__PWM10_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM10_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_3__PWM10_RISE_SEL__EXTRACT() extracts PWM_TOPO_3.PWM10_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @return current value of PWM_TOPO_3.PWM10_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM10_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_3__PWM10_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM10_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.PWM_TOPO_3.PWM10_FALL_SEL --------------------- */

/**
<pre>
  PWM.PWM_TOPO_3.PWM10_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_3__PWM10_FALL_SEL__Pos                     7                                                                      /*!< Right-most bit position of pwm10_fall_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM10_FALL_SEL__Msk                     (0x00000007UL << PWM_PWM_TOPO_3__PWM10_FALL_SEL__Pos)                  /*!< Mask for pwm10_fall_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM10_FALL_SEL__Shift(v)                (((v) << PWM_PWM_TOPO_3__PWM10_FALL_SEL__Pos) & PWM_PWM_TOPO_3__PWM10_FALL_SEL__Msk) /*!< Shift value 'v' into pwm10_fall_sel and mask 'v' to fit it into pwm10_fall_sel field */

/** PWM_PWM_TOPO_3__PWM10_FALL_SEL__SET() sets PWM_TOPO_3.PWM10_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_3.PWM10_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_3.PWM10_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_3__PWM10_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & ~PWM_PWM_TOPO_3__PWM10_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM10_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_3__SET(reg);
}

/** PWM_PWM_TOPO_3__PWM10_FALL_SEL__GET() gets PWM_TOPO_3.PWM10_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_3.PWM10_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_3.PWM10_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM10_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & PWM_PWM_TOPO_3__PWM10_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM10_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_3__PWM10_FALL_SEL__MODIFY() modifies PWM_TOPO_3.PWM10_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @param bf_value new value for PWM_TOPO_3.PWM10_FALL_SEL
 * @return new value of PWM.PWM_TOPO_3
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM10_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_3__PWM10_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM10_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_3__PWM10_FALL_SEL__EXTRACT() extracts PWM_TOPO_3.PWM10_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @return current value of PWM_TOPO_3.PWM10_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM10_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_3__PWM10_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM10_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_3.PWM9_RISE_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_3.PWM9_RISE_SEL:

    Topology driven PWM risng edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    The VRSEN  and BVRSEN options allow a PWM to be set high after detection of the falling transition of the rectification voltage.
    <start table_with_header>
    [2:0] Edge [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle" 8 "VRSEN neg edge"
    1 "t2" 5 "t2 odd cycle" 9-15 "BVRSEN neg edge"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_3__PWM9_RISE_SEL__Pos                      3                                                                      /*!< Right-most bit position of pwm9_rise_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM9_RISE_SEL__Msk                      (0x0000000FUL << PWM_PWM_TOPO_3__PWM9_RISE_SEL__Pos)                   /*!< Mask for pwm9_rise_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM9_RISE_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_3__PWM9_RISE_SEL__Pos) & PWM_PWM_TOPO_3__PWM9_RISE_SEL__Msk) /*!< Shift value 'v' into pwm9_rise_sel and mask 'v' to fit it into pwm9_rise_sel field */

/** PWM_PWM_TOPO_3__PWM9_RISE_SEL__SET() sets PWM_TOPO_3.PWM9_RISE_SEL to given value.
 *
 * When writing to PWM_TOPO_3.PWM9_RISE_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_3.PWM9_RISE_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_3__PWM9_RISE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & ~PWM_PWM_TOPO_3__PWM9_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM9_RISE_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_3__SET(reg);
}

/** PWM_PWM_TOPO_3__PWM9_RISE_SEL__GET() gets PWM_TOPO_3.PWM9_RISE_SEL's current value.
 *
 * When reading from PWM_TOPO_3.PWM9_RISE_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_3.PWM9_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM9_RISE_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & PWM_PWM_TOPO_3__PWM9_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM9_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_3__PWM9_RISE_SEL__MODIFY() modifies PWM_TOPO_3.PWM9_RISE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @param bf_value new value for PWM_TOPO_3.PWM9_RISE_SEL
 * @return new value of PWM.PWM_TOPO_3
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM9_RISE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_3__PWM9_RISE_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM9_RISE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_3__PWM9_RISE_SEL__EXTRACT() extracts PWM_TOPO_3.PWM9_RISE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @return current value of PWM_TOPO_3.PWM9_RISE_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM9_RISE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_3__PWM9_RISE_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM9_RISE_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM_TOPO_3.PWM9_FALL_SEL ---------------------- */

/**
<pre>
  PWM.PWM_TOPO_3.PWM9_FALL_SEL:

    Topology driven PWM falling edge select. t1 and t2 refer to the modulated edges created by the Ramp.  When using trailing edge modulation, t1 is fixed at time 0 and t2 is modulated.  When using leading edge modulation, t2 is fixed at tswitch (or tswitch/2 for bridge topologies) and t1 is modulated.  When using dual edge modualtion, t1 and t2 are centered around tswitch/2 (or tswitch/4 for bridge topologies) and both are modulated.  Odd and even cycle designations are for use with bridge topologies to distinguish between half cycles.
    <start table_with_header>
    [2:0] Edge [2:0] Edge
    0 "t1" 4 "t1 odd cycle"
    1 "t2" 5 "t2 odd cycle"
    2 "t1 even cycle" 6 "t1 delay"
    3 "t2 even cycle" 7 "t2 delay"
    <end table>

</pre> */

#define PWM_PWM_TOPO_3__PWM9_FALL_SEL__Pos                      0                                                                      /*!< Right-most bit position of pwm9_fall_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM9_FALL_SEL__Msk                      (0x00000007UL << PWM_PWM_TOPO_3__PWM9_FALL_SEL__Pos)                   /*!< Mask for pwm9_fall_sel in PWM.PWM_TOPO_3 */
#define PWM_PWM_TOPO_3__PWM9_FALL_SEL__Shift(v)                 (((v) << PWM_PWM_TOPO_3__PWM9_FALL_SEL__Pos) & PWM_PWM_TOPO_3__PWM9_FALL_SEL__Msk) /*!< Shift value 'v' into pwm9_fall_sel and mask 'v' to fit it into pwm9_fall_sel field */

/** PWM_PWM_TOPO_3__PWM9_FALL_SEL__SET() sets PWM_TOPO_3.PWM9_FALL_SEL to given value.
 *
 * When writing to PWM_TOPO_3.PWM9_FALL_SEL, this is recommended to use.
 *
 * @param bf_value new value for PWM_TOPO_3.PWM9_FALL_SEL
 */
__PWM_INLINE void PWM_PWM_TOPO_3__PWM9_FALL_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & ~PWM_PWM_TOPO_3__PWM9_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM9_FALL_SEL__Shift((uint32_t)bf_value)));
    PWM_PWM_TOPO_3__SET(reg);
}

/** PWM_PWM_TOPO_3__PWM9_FALL_SEL__GET() gets PWM_TOPO_3.PWM9_FALL_SEL's current value.
 *
 * When reading from PWM_TOPO_3.PWM9_FALL_SEL, this is recommended to use.
 *
 * @return current value of PWM_TOPO_3.PWM9_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM9_FALL_SEL__GET(void)
{
    uint32_t reg = PWM_PWM_TOPO_3__GET();
    reg = (reg & PWM_PWM_TOPO_3__PWM9_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM9_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_TOPO_3__PWM9_FALL_SEL__MODIFY() modifies PWM_TOPO_3.PWM9_FALL_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_TOPO_3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @param bf_value new value for PWM_TOPO_3.PWM9_FALL_SEL
 * @return new value of PWM.PWM_TOPO_3
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM9_FALL_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_TOPO_3__PWM9_FALL_SEL__Msk);
    reg = (reg | (PWM_PWM_TOPO_3__PWM9_FALL_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_TOPO_3__PWM9_FALL_SEL__EXTRACT() extracts PWM_TOPO_3.PWM9_FALL_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_TOPO_3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_TOPO_3
 * @return current value of PWM_TOPO_3.PWM9_FALL_SEL
 */
__PWM_INLINE uint32_t PWM_PWM_TOPO_3__PWM9_FALL_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_TOPO_3__PWM9_FALL_SEL__Msk);
    reg = (reg >> PWM_PWM_TOPO_3__PWM9_FALL_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          PWM_MAP member of PWM_t                          */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM_MAP__ADDRESS returns the address of member PWM_MAP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM_MAP
 */
__PWM_INLINE uint32_t* __PWM_PWM_MAP__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM_MAP)));
}

/** PWM_PWM_MAP__SET() sets PWM_MAP to given value.
 *
 * When writing to PWM_MAP, this is mandatory to use.
 *
 * @param value new value for PWM_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM_MAP__ADDRESS(), value);
}

/** PWM_PWM_MAP__GET() gets PWM_MAP's current value.
 *
 * When reading from PWM_MAP, this is mandatory to use.
 *
 * @return current value of PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__GET(void)
{
    return HAL_GET32(__PWM_PWM_MAP__ADDRESS());
}

/* ----------------------- PWM.PWM_MAP.PWM12_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM12_LOOP_MAP:

    Defines the loop and phase mapping of the PWM12 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM12_LOOP_MAP__Pos                        22                                                                     /*!< Right-most bit position of pwm12_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM12_LOOP_MAP__Msk                        (0x00000003UL << PWM_PWM_MAP__PWM12_LOOP_MAP__Pos)                     /*!< Mask for pwm12_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM12_LOOP_MAP__Shift(v)                   (((v) << PWM_PWM_MAP__PWM12_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM12_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm12_loop_map and mask 'v' to fit it into pwm12_loop_map field */

/** PWM_PWM_MAP__PWM12_LOOP_MAP__SET() sets PWM_MAP.PWM12_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM12_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM12_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM12_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM12_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM12_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM12_LOOP_MAP__GET() gets PWM_MAP.PWM12_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM12_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM12_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM12_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM12_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM12_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM12_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM12_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM12_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM12_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM12_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM12_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM12_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM12_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM12_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM12_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM12_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM12_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM11_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM11_LOOP_MAP:

    Defines the loop and phase mapping of the PWM11 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM11_LOOP_MAP__Pos                        20                                                                     /*!< Right-most bit position of pwm11_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM11_LOOP_MAP__Msk                        (0x00000003UL << PWM_PWM_MAP__PWM11_LOOP_MAP__Pos)                     /*!< Mask for pwm11_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM11_LOOP_MAP__Shift(v)                   (((v) << PWM_PWM_MAP__PWM11_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM11_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm11_loop_map and mask 'v' to fit it into pwm11_loop_map field */

/** PWM_PWM_MAP__PWM11_LOOP_MAP__SET() sets PWM_MAP.PWM11_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM11_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM11_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM11_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM11_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM11_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM11_LOOP_MAP__GET() gets PWM_MAP.PWM11_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM11_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM11_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM11_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM11_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM11_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM11_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM11_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM11_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM11_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM11_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM11_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM11_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM11_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM11_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM11_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM11_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM11_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM10_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM10_LOOP_MAP:

    Defines the loop and phase mapping of the PWM10 utput
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM10_LOOP_MAP__Pos                        18                                                                     /*!< Right-most bit position of pwm10_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM10_LOOP_MAP__Msk                        (0x00000003UL << PWM_PWM_MAP__PWM10_LOOP_MAP__Pos)                     /*!< Mask for pwm10_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM10_LOOP_MAP__Shift(v)                   (((v) << PWM_PWM_MAP__PWM10_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM10_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm10_loop_map and mask 'v' to fit it into pwm10_loop_map field */

/** PWM_PWM_MAP__PWM10_LOOP_MAP__SET() sets PWM_MAP.PWM10_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM10_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM10_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM10_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM10_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM10_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM10_LOOP_MAP__GET() gets PWM_MAP.PWM10_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM10_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM10_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM10_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM10_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM10_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM10_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM10_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM10_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM10_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM10_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM10_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM10_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM10_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM10_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM10_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM10_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM10_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM9_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM9_LOOP_MAP:

    Defines the loop and phase mapping of the PWM9 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM9_LOOP_MAP__Pos                         16                                                                     /*!< Right-most bit position of pwm9_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM9_LOOP_MAP__Msk                         (0x00000003UL << PWM_PWM_MAP__PWM9_LOOP_MAP__Pos)                      /*!< Mask for pwm9_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM9_LOOP_MAP__Shift(v)                    (((v) << PWM_PWM_MAP__PWM9_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM9_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm9_loop_map and mask 'v' to fit it into pwm9_loop_map field */

/** PWM_PWM_MAP__PWM9_LOOP_MAP__SET() sets PWM_MAP.PWM9_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM9_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM9_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM9_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM9_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM9_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM9_LOOP_MAP__GET() gets PWM_MAP.PWM9_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM9_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM9_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM9_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM9_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM9_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM9_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM9_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM9_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM9_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM9_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM9_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM9_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM9_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM9_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM9_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM9_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM9_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM8_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM8_LOOP_MAP:

    Defines the loop and phase mapping of the PWM6 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM8_LOOP_MAP__Pos                         14                                                                     /*!< Right-most bit position of pwm8_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM8_LOOP_MAP__Msk                         (0x00000003UL << PWM_PWM_MAP__PWM8_LOOP_MAP__Pos)                      /*!< Mask for pwm8_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM8_LOOP_MAP__Shift(v)                    (((v) << PWM_PWM_MAP__PWM8_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM8_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm8_loop_map and mask 'v' to fit it into pwm8_loop_map field */

/** PWM_PWM_MAP__PWM8_LOOP_MAP__SET() sets PWM_MAP.PWM8_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM8_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM8_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM8_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM8_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM8_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM8_LOOP_MAP__GET() gets PWM_MAP.PWM8_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM8_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM8_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM8_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM8_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM8_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM8_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM8_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM8_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM8_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM8_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM8_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM8_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM8_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM8_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM8_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM8_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM8_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM7_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM7_LOOP_MAP:

    Defines the loop and phase mapping of the PWM7 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM7_LOOP_MAP__Pos                         12                                                                     /*!< Right-most bit position of pwm7_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM7_LOOP_MAP__Msk                         (0x00000003UL << PWM_PWM_MAP__PWM7_LOOP_MAP__Pos)                      /*!< Mask for pwm7_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM7_LOOP_MAP__Shift(v)                    (((v) << PWM_PWM_MAP__PWM7_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM7_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm7_loop_map and mask 'v' to fit it into pwm7_loop_map field */

/** PWM_PWM_MAP__PWM7_LOOP_MAP__SET() sets PWM_MAP.PWM7_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM7_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM7_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM7_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM7_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM7_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM7_LOOP_MAP__GET() gets PWM_MAP.PWM7_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM7_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM7_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM7_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM7_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM7_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM7_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM7_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM7_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM7_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM7_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM7_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM7_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM7_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM7_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM7_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM7_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM7_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM6_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM6_LOOP_MAP:

    Defines the loop and phase mapping of the PWM6 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM6_LOOP_MAP__Pos                         10                                                                     /*!< Right-most bit position of pwm6_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM6_LOOP_MAP__Msk                         (0x00000003UL << PWM_PWM_MAP__PWM6_LOOP_MAP__Pos)                      /*!< Mask for pwm6_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM6_LOOP_MAP__Shift(v)                    (((v) << PWM_PWM_MAP__PWM6_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM6_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm6_loop_map and mask 'v' to fit it into pwm6_loop_map field */

/** PWM_PWM_MAP__PWM6_LOOP_MAP__SET() sets PWM_MAP.PWM6_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM6_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM6_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM6_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM6_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM6_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM6_LOOP_MAP__GET() gets PWM_MAP.PWM6_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM6_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM6_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM6_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM6_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM6_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM6_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM6_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM6_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM6_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM6_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM6_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM6_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM6_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM6_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM6_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM6_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM6_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM5_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM5_LOOP_MAP:

    Defines the loop and phase mapping of the PWM5 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM5_LOOP_MAP__Pos                         8                                                                      /*!< Right-most bit position of pwm5_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM5_LOOP_MAP__Msk                         (0x00000003UL << PWM_PWM_MAP__PWM5_LOOP_MAP__Pos)                      /*!< Mask for pwm5_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM5_LOOP_MAP__Shift(v)                    (((v) << PWM_PWM_MAP__PWM5_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM5_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm5_loop_map and mask 'v' to fit it into pwm5_loop_map field */

/** PWM_PWM_MAP__PWM5_LOOP_MAP__SET() sets PWM_MAP.PWM5_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM5_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM5_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM5_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM5_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM5_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM5_LOOP_MAP__GET() gets PWM_MAP.PWM5_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM5_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM5_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM5_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM5_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM5_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM5_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM5_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM5_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM5_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM5_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM5_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM5_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM5_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM5_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM5_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM5_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM5_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM4_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM4_LOOP_MAP:

    Defines the loop and phase mapping of the PWM4 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM4_LOOP_MAP__Pos                         6                                                                      /*!< Right-most bit position of pwm4_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM4_LOOP_MAP__Msk                         (0x00000003UL << PWM_PWM_MAP__PWM4_LOOP_MAP__Pos)                      /*!< Mask for pwm4_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM4_LOOP_MAP__Shift(v)                    (((v) << PWM_PWM_MAP__PWM4_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM4_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm4_loop_map and mask 'v' to fit it into pwm4_loop_map field */

/** PWM_PWM_MAP__PWM4_LOOP_MAP__SET() sets PWM_MAP.PWM4_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM4_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM4_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM4_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM4_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM4_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM4_LOOP_MAP__GET() gets PWM_MAP.PWM4_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM4_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM4_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM4_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM4_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM4_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM4_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM4_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM4_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM4_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM4_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM4_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM4_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM4_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM4_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM4_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM4_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM4_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM3_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM3_LOOP_MAP:

    Defines the loop and phase mapping of the PWM3 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM3_LOOP_MAP__Pos                         4                                                                      /*!< Right-most bit position of pwm3_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM3_LOOP_MAP__Msk                         (0x00000003UL << PWM_PWM_MAP__PWM3_LOOP_MAP__Pos)                      /*!< Mask for pwm3_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM3_LOOP_MAP__Shift(v)                    (((v) << PWM_PWM_MAP__PWM3_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM3_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm3_loop_map and mask 'v' to fit it into pwm3_loop_map field */

/** PWM_PWM_MAP__PWM3_LOOP_MAP__SET() sets PWM_MAP.PWM3_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM3_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM3_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM3_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM3_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM3_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM3_LOOP_MAP__GET() gets PWM_MAP.PWM3_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM3_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM3_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM3_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM3_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM3_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM3_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM3_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM3_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM3_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM3_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM3_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM3_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM3_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM3_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM3_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM3_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM3_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM2_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM2_LOOP_MAP:

    Defines the loop and phase mapping of the PWM2 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM2_LOOP_MAP__Pos                         2                                                                      /*!< Right-most bit position of pwm2_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM2_LOOP_MAP__Msk                         (0x00000003UL << PWM_PWM_MAP__PWM2_LOOP_MAP__Pos)                      /*!< Mask for pwm2_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM2_LOOP_MAP__Shift(v)                    (((v) << PWM_PWM_MAP__PWM2_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM2_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm2_loop_map and mask 'v' to fit it into pwm2_loop_map field */

/** PWM_PWM_MAP__PWM2_LOOP_MAP__SET() sets PWM_MAP.PWM2_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM2_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM2_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM2_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM2_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM2_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM2_LOOP_MAP__GET() gets PWM_MAP.PWM2_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM2_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM2_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM2_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM2_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM2_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM2_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM2_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM2_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM2_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM2_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM2_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM2_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM2_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM2_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM2_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM2_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM2_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM_MAP.PWM1_LOOP_MAP ----------------------- */

/**
<pre>
  PWM.PWM_MAP.PWM1_LOOP_MAP:

    Defines the loop and phase mapping of the PWM1 output
    <start table>
    0 "PWM not in use"
    1 "Loop 0, Phase 0"
    2 "Loop 1, Phase 0"
    3 "Loop 0, Phase 1"
    <end table>

</pre> */

#define PWM_PWM_MAP__PWM1_LOOP_MAP__Pos                         0                                                                      /*!< Right-most bit position of pwm1_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM1_LOOP_MAP__Msk                         (0x00000003UL << PWM_PWM_MAP__PWM1_LOOP_MAP__Pos)                      /*!< Mask for pwm1_loop_map in PWM.PWM_MAP */
#define PWM_PWM_MAP__PWM1_LOOP_MAP__Shift(v)                    (((v) << PWM_PWM_MAP__PWM1_LOOP_MAP__Pos) & PWM_PWM_MAP__PWM1_LOOP_MAP__Msk) /*!< Shift value 'v' into pwm1_loop_map and mask 'v' to fit it into pwm1_loop_map field */

/** PWM_PWM_MAP__PWM1_LOOP_MAP__SET() sets PWM_MAP.PWM1_LOOP_MAP to given value.
 *
 * When writing to PWM_MAP.PWM1_LOOP_MAP, this is recommended to use.
 *
 * @param bf_value new value for PWM_MAP.PWM1_LOOP_MAP
 */
__PWM_INLINE void PWM_PWM_MAP__PWM1_LOOP_MAP__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & ~PWM_PWM_MAP__PWM1_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM1_LOOP_MAP__Shift((uint32_t)bf_value)));
    PWM_PWM_MAP__SET(reg);
}

/** PWM_PWM_MAP__PWM1_LOOP_MAP__GET() gets PWM_MAP.PWM1_LOOP_MAP's current value.
 *
 * When reading from PWM_MAP.PWM1_LOOP_MAP, this is recommended to use.
 *
 * @return current value of PWM_MAP.PWM1_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM1_LOOP_MAP__GET(void)
{
    uint32_t reg = PWM_PWM_MAP__GET();
    reg = (reg & PWM_PWM_MAP__PWM1_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM1_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_MAP__PWM1_LOOP_MAP__MODIFY() modifies PWM_MAP.PWM1_LOOP_MAP.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_MAP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_MAP
 * @param bf_value new value for PWM_MAP.PWM1_LOOP_MAP
 * @return new value of PWM.PWM_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM1_LOOP_MAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_MAP__PWM1_LOOP_MAP__Msk);
    reg = (reg | (PWM_PWM_MAP__PWM1_LOOP_MAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_MAP__PWM1_LOOP_MAP__EXTRACT() extracts PWM_MAP.PWM1_LOOP_MAP.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_MAP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_MAP
 * @return current value of PWM_MAP.PWM1_LOOP_MAP
 */
__PWM_INLINE uint32_t PWM_PWM_MAP__PWM1_LOOP_MAP__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_MAP__PWM1_LOOP_MAP__Msk);
    reg = (reg >> PWM_PWM_MAP__PWM1_LOOP_MAP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       MAX_DUTY_SCALE member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_MAX_DUTY_SCALE__ADDRESS returns the address of member MAX_DUTY_SCALE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MAX_DUTY_SCALE
 */
__PWM_INLINE uint32_t* __PWM_MAX_DUTY_SCALE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, MAX_DUTY_SCALE)));
}

/** PWM_MAX_DUTY_SCALE__SET() sets MAX_DUTY_SCALE to given value.
 *
 * When writing to MAX_DUTY_SCALE, this is mandatory to use.
 *
 * @param value new value for MAX_DUTY_SCALE
 */
__PWM_INLINE void PWM_MAX_DUTY_SCALE__SET(uint32_t value)
{
    HAL_SET32(__PWM_MAX_DUTY_SCALE__ADDRESS(), value);
}

/** PWM_MAX_DUTY_SCALE__GET() gets MAX_DUTY_SCALE's current value.
 *
 * When reading from MAX_DUTY_SCALE, this is mandatory to use.
 *
 * @return current value of MAX_DUTY_SCALE
 */
__PWM_INLINE uint32_t PWM_MAX_DUTY_SCALE__GET(void)
{
    return HAL_GET32(__PWM_MAX_DUTY_SCALE__ADDRESS());
}

/* ------------------ PWM.MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM ------------------ */

/**
<pre>
  PWM.MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM:

    Ramp 1 nominal max duty cycle scaled by the rectification voltage (Vrect).  The PMBus command MAX_DUTY defines a fixed max duty cycle limit.  This parameter defines a variable max duty cycle limit that scales with the rectification voltage.  The lower of the two limits will be enforced.  The max duty cycle limit is scaled with respect to the Vref reference defined by parameter pid1.pid_vrect_ref as shown below.
    <start table>
    "Max Duty Scaled = ramp1_dc_max_nom * pid1.pid_vrect_ref / (measured Vrect)"
    <end table>
    A setting of 0 will disable the scaled max duty cycle limit and only MAX_DUTY will apply.
    LSB = 0.5%, Range = 0.0 to 99.5%

</pre> */

#define PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Pos               8                                                                      /*!< Right-most bit position of ramp1_dc_max_nom in PWM.MAX_DUTY_SCALE */
#define PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Msk               (0x000000FFUL << PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Pos)            /*!< Mask for ramp1_dc_max_nom in PWM.MAX_DUTY_SCALE */
#define PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Shift(v)          (((v) << PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Pos) & PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Msk) /*!< Shift value 'v' into ramp1_dc_max_nom and mask 'v' to fit it into ramp1_dc_max_nom field */

/** PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__SET() sets MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM to given value.
 *
 * When writing to MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM, this is recommended to use.
 *
 * @param bf_value new value for MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM
 */
__PWM_INLINE void PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_MAX_DUTY_SCALE__GET();
    reg = (reg & ~PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Msk);
    reg = (reg | (PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Shift((uint32_t)bf_value)));
    PWM_MAX_DUTY_SCALE__SET(reg);
}

/** PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__GET() gets MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM's current value.
 *
 * When reading from MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM, this is recommended to use.
 *
 * @return current value of MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM
 */
__PWM_INLINE uint32_t PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__GET(void)
{
    uint32_t reg = PWM_MAX_DUTY_SCALE__GET();
    reg = (reg & PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Msk);
    reg = (reg >> PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Pos);
    return (uint32_t)reg;
}

/** PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__MODIFY() modifies MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM.
 *
 * This is recommended to use when setting more than one bitfield of PWM.MAX_DUTY_SCALE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.MAX_DUTY_SCALE
 * @param bf_value new value for MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM
 * @return new value of PWM.MAX_DUTY_SCALE
 */
__PWM_INLINE uint32_t PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Msk);
    reg = (reg | (PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__EXTRACT() extracts MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.MAX_DUTY_SCALE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.MAX_DUTY_SCALE
 * @return current value of MAX_DUTY_SCALE.RAMP1_DC_MAX_NOM
 */
__PWM_INLINE uint32_t PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Msk);
    reg = (reg >> PWM_MAX_DUTY_SCALE__RAMP1_DC_MAX_NOM__Pos);
    return (uint32_t)reg;
}

/* ------------------ PWM.MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM ------------------ */

/**
<pre>
  PWM.MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM:

    Ramp 0 nominal max duty cycle scaled by the rectification voltage (Vrect).  The PMBus command MAX_DUTY defines a fixed max duty cycle limit.  This parameter defines a variable max duty cycle limit that scales with the rectification voltage.  The lower of the two limits will be enforced.  The max duty cycle limit is scaled with respect to the Vref reference defined by parameter pid0.pid_vrect_ref as shown below.
    <start table>
    "Max Duty Scaled = ramp0_dc_max_nom * pid0.pid_vrect_ref / (measured Vrect)"
    <end table>
    A setting of 0 will disable the scaled max duty cycle limit and only MAX_DUTY will apply.
    LSB = 0.5%, Range = 0.0 to 99.5%

</pre> */

#define PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Pos               0                                                                      /*!< Right-most bit position of ramp0_dc_max_nom in PWM.MAX_DUTY_SCALE */
#define PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Msk               (0x000000FFUL << PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Pos)            /*!< Mask for ramp0_dc_max_nom in PWM.MAX_DUTY_SCALE */
#define PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Shift(v)          (((v) << PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Pos) & PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Msk) /*!< Shift value 'v' into ramp0_dc_max_nom and mask 'v' to fit it into ramp0_dc_max_nom field */

/** PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__SET() sets MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM to given value.
 *
 * When writing to MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM, this is recommended to use.
 *
 * @param bf_value new value for MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM
 */
__PWM_INLINE void PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_MAX_DUTY_SCALE__GET();
    reg = (reg & ~PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Msk);
    reg = (reg | (PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Shift((uint32_t)bf_value)));
    PWM_MAX_DUTY_SCALE__SET(reg);
}

/** PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__GET() gets MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM's current value.
 *
 * When reading from MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM, this is recommended to use.
 *
 * @return current value of MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM
 */
__PWM_INLINE uint32_t PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__GET(void)
{
    uint32_t reg = PWM_MAX_DUTY_SCALE__GET();
    reg = (reg & PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Msk);
    reg = (reg >> PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Pos);
    return (uint32_t)reg;
}

/** PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__MODIFY() modifies MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM.
 *
 * This is recommended to use when setting more than one bitfield of PWM.MAX_DUTY_SCALE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.MAX_DUTY_SCALE
 * @param bf_value new value for MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM
 * @return new value of PWM.MAX_DUTY_SCALE
 */
__PWM_INLINE uint32_t PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Msk);
    reg = (reg | (PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__EXTRACT() extracts MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.MAX_DUTY_SCALE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.MAX_DUTY_SCALE
 * @return current value of MAX_DUTY_SCALE.RAMP0_DC_MAX_NOM
 */
__PWM_INLINE uint32_t PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Msk);
    reg = (reg >> PWM_MAX_DUTY_SCALE__RAMP0_DC_MAX_NOM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          PWM_FTR member of PWM_t                          */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM_FTR__ADDRESS returns the address of member PWM_FTR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM_FTR
 */
__PWM_INLINE uint32_t* __PWM_PWM_FTR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM_FTR)));
}

/** PWM_PWM_FTR__SET() sets PWM_FTR to given value.
 *
 * When writing to PWM_FTR, this is mandatory to use.
 *
 * @param value new value for PWM_FTR
 */
__PWM_INLINE void PWM_PWM_FTR__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM_FTR__ADDRESS(), value);
}

/** PWM_PWM_FTR__GET() gets PWM_FTR's current value.
 *
 * When reading from PWM_FTR, this is mandatory to use.
 *
 * @return current value of PWM_FTR
 */
__PWM_INLINE uint32_t PWM_PWM_FTR__GET(void)
{
    return HAL_GET32(__PWM_PWM_FTR__ADDRESS());
}

/* --------------------- PWM.PWM_FTR.LP1_FTR_VIN_THRESH --------------------- */

/**
<pre>
  PWM.PWM_FTR.LP1_FTR_VIN_THRESH:

    Loop 1 Fast Transient Response (FTR) input voltage threshold.  Below this threshold, the FTR pulsewidth is based on the feed forward duty cycle from the PID.  Above this threshold, the FTR pulse width is reduced in proportion to Vin.
    <start table>
    "if (Vin < lp1_ftr_vin_thresh)"
    "    FTR PW = (Vout/Vrect) * (Tswitch/2)"
    "else"
    "    FTR PW = (Vout/Vrect) * (Tswitch/2) * (lp1_ftr_vin_thresh/Vin)"
    <end table>
    LSB = 1V, Range = 0 to 127V

</pre> */

#define PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Pos                    7                                                                      /*!< Right-most bit position of lp1_ftr_vin_thresh in PWM.PWM_FTR */
#define PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Msk                    (0x0000007FUL << PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Pos)                 /*!< Mask for lp1_ftr_vin_thresh in PWM.PWM_FTR */
#define PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Shift(v)               (((v) << PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Pos) & PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Msk) /*!< Shift value 'v' into lp1_ftr_vin_thresh and mask 'v' to fit it into lp1_ftr_vin_thresh field */

/** PWM_PWM_FTR__LP1_FTR_VIN_THRESH__SET() sets PWM_FTR.LP1_FTR_VIN_THRESH to given value.
 *
 * When writing to PWM_FTR.LP1_FTR_VIN_THRESH, this is recommended to use.
 *
 * @param bf_value new value for PWM_FTR.LP1_FTR_VIN_THRESH
 */
__PWM_INLINE void PWM_PWM_FTR__LP1_FTR_VIN_THRESH__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_FTR__GET();
    reg = (reg & ~PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Msk);
    reg = (reg | (PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Shift((uint32_t)bf_value)));
    PWM_PWM_FTR__SET(reg);
}

/** PWM_PWM_FTR__LP1_FTR_VIN_THRESH__GET() gets PWM_FTR.LP1_FTR_VIN_THRESH's current value.
 *
 * When reading from PWM_FTR.LP1_FTR_VIN_THRESH, this is recommended to use.
 *
 * @return current value of PWM_FTR.LP1_FTR_VIN_THRESH
 */
__PWM_INLINE uint32_t PWM_PWM_FTR__LP1_FTR_VIN_THRESH__GET(void)
{
    uint32_t reg = PWM_PWM_FTR__GET();
    reg = (reg & PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Msk);
    reg = (reg >> PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_FTR__LP1_FTR_VIN_THRESH__MODIFY() modifies PWM_FTR.LP1_FTR_VIN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_FTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_FTR
 * @param bf_value new value for PWM_FTR.LP1_FTR_VIN_THRESH
 * @return new value of PWM.PWM_FTR
 */
__PWM_INLINE uint32_t PWM_PWM_FTR__LP1_FTR_VIN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Msk);
    reg = (reg | (PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_FTR__LP1_FTR_VIN_THRESH__EXTRACT() extracts PWM_FTR.LP1_FTR_VIN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_FTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_FTR
 * @return current value of PWM_FTR.LP1_FTR_VIN_THRESH
 */
__PWM_INLINE uint32_t PWM_PWM_FTR__LP1_FTR_VIN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Msk);
    reg = (reg >> PWM_PWM_FTR__LP1_FTR_VIN_THRESH__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.PWM_FTR.LP0_FTR_VIN_THRESH --------------------- */

/**
<pre>
  PWM.PWM_FTR.LP0_FTR_VIN_THRESH:

    Loop 0 Fast Transient Response (FTR) input voltage threshold.  Below this threshold, the FTR pulsewidth is based on the feed forward duty cycle from the PID.  Above this threshold, the FTR pulse width is reduced in proportion to Vin.
    <start table>
    "if (Vin < lp0_ftr_vin_thresh)"
    "    FTR PW = (Vout/Vrect) * (Tswitch/2)"
    "else"
    "    FTR PW = (Vout/Vrect) * (Tswitch/2) * (lp0_ftr_vin_thresh/Vin)"
    <end table>
    LSB = 1V, Range = 0 to 127V

</pre> */

#define PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Pos                    0                                                                      /*!< Right-most bit position of lp0_ftr_vin_thresh in PWM.PWM_FTR */
#define PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Msk                    (0x0000007FUL << PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Pos)                 /*!< Mask for lp0_ftr_vin_thresh in PWM.PWM_FTR */
#define PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Shift(v)               (((v) << PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Pos) & PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Msk) /*!< Shift value 'v' into lp0_ftr_vin_thresh and mask 'v' to fit it into lp0_ftr_vin_thresh field */

/** PWM_PWM_FTR__LP0_FTR_VIN_THRESH__SET() sets PWM_FTR.LP0_FTR_VIN_THRESH to given value.
 *
 * When writing to PWM_FTR.LP0_FTR_VIN_THRESH, this is recommended to use.
 *
 * @param bf_value new value for PWM_FTR.LP0_FTR_VIN_THRESH
 */
__PWM_INLINE void PWM_PWM_FTR__LP0_FTR_VIN_THRESH__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_FTR__GET();
    reg = (reg & ~PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Msk);
    reg = (reg | (PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Shift((uint32_t)bf_value)));
    PWM_PWM_FTR__SET(reg);
}

/** PWM_PWM_FTR__LP0_FTR_VIN_THRESH__GET() gets PWM_FTR.LP0_FTR_VIN_THRESH's current value.
 *
 * When reading from PWM_FTR.LP0_FTR_VIN_THRESH, this is recommended to use.
 *
 * @return current value of PWM_FTR.LP0_FTR_VIN_THRESH
 */
__PWM_INLINE uint32_t PWM_PWM_FTR__LP0_FTR_VIN_THRESH__GET(void)
{
    uint32_t reg = PWM_PWM_FTR__GET();
    reg = (reg & PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Msk);
    reg = (reg >> PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_FTR__LP0_FTR_VIN_THRESH__MODIFY() modifies PWM_FTR.LP0_FTR_VIN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_FTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_FTR
 * @param bf_value new value for PWM_FTR.LP0_FTR_VIN_THRESH
 * @return new value of PWM.PWM_FTR
 */
__PWM_INLINE uint32_t PWM_PWM_FTR__LP0_FTR_VIN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Msk);
    reg = (reg | (PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_FTR__LP0_FTR_VIN_THRESH__EXTRACT() extracts PWM_FTR.LP0_FTR_VIN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_FTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_FTR
 * @return current value of PWM_FTR.LP0_FTR_VIN_THRESH
 */
__PWM_INLINE uint32_t PWM_PWM_FTR__LP0_FTR_VIN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Msk);
    reg = (reg >> PWM_PWM_FTR__LP0_FTR_VIN_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        RAMP0_PHASE member of PWM_t                        */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP0_PHASE__ADDRESS returns the address of member RAMP0_PHASE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP0_PHASE
 */
__PWM_INLINE uint32_t* __PWM_RAMP0_PHASE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP0_PHASE)));
}

/** PWM_RAMP0_PHASE__SET() sets RAMP0_PHASE to given value.
 *
 * When writing to RAMP0_PHASE, this is mandatory to use.
 *
 * @param value new value for RAMP0_PHASE
 */
__PWM_INLINE void PWM_RAMP0_PHASE__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP0_PHASE__ADDRESS(), value);
}

/** PWM_RAMP0_PHASE__GET() gets RAMP0_PHASE's current value.
 *
 * When reading from RAMP0_PHASE, this is mandatory to use.
 *
 * @return current value of RAMP0_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP0_PHASE__GET(void)
{
    return HAL_GET32(__PWM_RAMP0_PHASE__ADDRESS());
}

/* ---------------------- PWM.RAMP0_PHASE.RAMP0_PHASE ---------------------- */

/**
<pre>
  PWM.RAMP0_PHASE.RAMP0_PHASE:

    Ramp 0 phase alignment with respect to sync signal selected with ramp0_sync_sel.
    Computed from PMBus as follows:
    <start table>
    "ramp0_phase(U0.8) = 2^8 * PAGE0.INTERLEAVE[3:0] / PAGE0.INTERLEAVE[7:4]"
    <end table>
    LSB = 1.40625 degrees, Range = 0.0 to 358.59375 degrees

</pre> */

#define PWM_RAMP0_PHASE__RAMP0_PHASE__Pos                       0                                                                      /*!< Right-most bit position of ramp0_phase in PWM.RAMP0_PHASE */
#define PWM_RAMP0_PHASE__RAMP0_PHASE__Msk                       (0x000000FFUL << PWM_RAMP0_PHASE__RAMP0_PHASE__Pos)                    /*!< Mask for ramp0_phase in PWM.RAMP0_PHASE */
#define PWM_RAMP0_PHASE__RAMP0_PHASE__Shift(v)                  (((v) << PWM_RAMP0_PHASE__RAMP0_PHASE__Pos) & PWM_RAMP0_PHASE__RAMP0_PHASE__Msk) /*!< Shift value 'v' into ramp0_phase and mask 'v' to fit it into ramp0_phase field */

/** PWM_RAMP0_PHASE__RAMP0_PHASE__SET() sets RAMP0_PHASE.RAMP0_PHASE to given value.
 *
 * When writing to RAMP0_PHASE.RAMP0_PHASE, this is recommended to use.
 *
 * @param bf_value new value for RAMP0_PHASE.RAMP0_PHASE
 */
__PWM_INLINE void PWM_RAMP0_PHASE__RAMP0_PHASE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP0_PHASE__GET();
    reg = (reg & ~PWM_RAMP0_PHASE__RAMP0_PHASE__Msk);
    reg = (reg | (PWM_RAMP0_PHASE__RAMP0_PHASE__Shift((uint32_t)bf_value)));
    PWM_RAMP0_PHASE__SET(reg);
}

/** PWM_RAMP0_PHASE__RAMP0_PHASE__GET() gets RAMP0_PHASE.RAMP0_PHASE's current value.
 *
 * When reading from RAMP0_PHASE.RAMP0_PHASE, this is recommended to use.
 *
 * @return current value of RAMP0_PHASE.RAMP0_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP0_PHASE__RAMP0_PHASE__GET(void)
{
    uint32_t reg = PWM_RAMP0_PHASE__GET();
    reg = (reg & PWM_RAMP0_PHASE__RAMP0_PHASE__Msk);
    reg = (reg >> PWM_RAMP0_PHASE__RAMP0_PHASE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP0_PHASE__RAMP0_PHASE__MODIFY() modifies RAMP0_PHASE.RAMP0_PHASE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP0_PHASE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP0_PHASE
 * @param bf_value new value for RAMP0_PHASE.RAMP0_PHASE
 * @return new value of PWM.RAMP0_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP0_PHASE__RAMP0_PHASE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP0_PHASE__RAMP0_PHASE__Msk);
    reg = (reg | (PWM_RAMP0_PHASE__RAMP0_PHASE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP0_PHASE__RAMP0_PHASE__EXTRACT() extracts RAMP0_PHASE.RAMP0_PHASE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP0_PHASE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP0_PHASE
 * @return current value of RAMP0_PHASE.RAMP0_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP0_PHASE__RAMP0_PHASE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP0_PHASE__RAMP0_PHASE__Msk);
    reg = (reg >> PWM_RAMP0_PHASE__RAMP0_PHASE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        RAMP1_PHASE member of PWM_t                        */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP1_PHASE__ADDRESS returns the address of member RAMP1_PHASE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP1_PHASE
 */
__PWM_INLINE uint32_t* __PWM_RAMP1_PHASE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP1_PHASE)));
}

/** PWM_RAMP1_PHASE__SET() sets RAMP1_PHASE to given value.
 *
 * When writing to RAMP1_PHASE, this is mandatory to use.
 *
 * @param value new value for RAMP1_PHASE
 */
__PWM_INLINE void PWM_RAMP1_PHASE__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP1_PHASE__ADDRESS(), value);
}

/** PWM_RAMP1_PHASE__GET() gets RAMP1_PHASE's current value.
 *
 * When reading from RAMP1_PHASE, this is mandatory to use.
 *
 * @return current value of RAMP1_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP1_PHASE__GET(void)
{
    return HAL_GET32(__PWM_RAMP1_PHASE__ADDRESS());
}

/* ---------------------- PWM.RAMP1_PHASE.RAMP1_PHASE ---------------------- */

/**
<pre>
  PWM.RAMP1_PHASE.RAMP1_PHASE:

    Ramp 1 phase alignment with respect to sync signal selected with ramp1_sync_sel.
    Computed from PMBus as follows:
    <start table>
    "ramp1_phase(U0.8) = 2^8 * PAGE1.INTERLEAVE[3:0] / PAGE1.INTERLEAVE[7:4]"
    <end table>
    LSB = 1.40625 degrees, Range = 0.0 to 358.59375 degrees

</pre> */

#define PWM_RAMP1_PHASE__RAMP1_PHASE__Pos                       0                                                                      /*!< Right-most bit position of ramp1_phase in PWM.RAMP1_PHASE */
#define PWM_RAMP1_PHASE__RAMP1_PHASE__Msk                       (0x000000FFUL << PWM_RAMP1_PHASE__RAMP1_PHASE__Pos)                    /*!< Mask for ramp1_phase in PWM.RAMP1_PHASE */
#define PWM_RAMP1_PHASE__RAMP1_PHASE__Shift(v)                  (((v) << PWM_RAMP1_PHASE__RAMP1_PHASE__Pos) & PWM_RAMP1_PHASE__RAMP1_PHASE__Msk) /*!< Shift value 'v' into ramp1_phase and mask 'v' to fit it into ramp1_phase field */

/** PWM_RAMP1_PHASE__RAMP1_PHASE__SET() sets RAMP1_PHASE.RAMP1_PHASE to given value.
 *
 * When writing to RAMP1_PHASE.RAMP1_PHASE, this is recommended to use.
 *
 * @param bf_value new value for RAMP1_PHASE.RAMP1_PHASE
 */
__PWM_INLINE void PWM_RAMP1_PHASE__RAMP1_PHASE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP1_PHASE__GET();
    reg = (reg & ~PWM_RAMP1_PHASE__RAMP1_PHASE__Msk);
    reg = (reg | (PWM_RAMP1_PHASE__RAMP1_PHASE__Shift((uint32_t)bf_value)));
    PWM_RAMP1_PHASE__SET(reg);
}

/** PWM_RAMP1_PHASE__RAMP1_PHASE__GET() gets RAMP1_PHASE.RAMP1_PHASE's current value.
 *
 * When reading from RAMP1_PHASE.RAMP1_PHASE, this is recommended to use.
 *
 * @return current value of RAMP1_PHASE.RAMP1_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP1_PHASE__RAMP1_PHASE__GET(void)
{
    uint32_t reg = PWM_RAMP1_PHASE__GET();
    reg = (reg & PWM_RAMP1_PHASE__RAMP1_PHASE__Msk);
    reg = (reg >> PWM_RAMP1_PHASE__RAMP1_PHASE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP1_PHASE__RAMP1_PHASE__MODIFY() modifies RAMP1_PHASE.RAMP1_PHASE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP1_PHASE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP1_PHASE
 * @param bf_value new value for RAMP1_PHASE.RAMP1_PHASE
 * @return new value of PWM.RAMP1_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP1_PHASE__RAMP1_PHASE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP1_PHASE__RAMP1_PHASE__Msk);
    reg = (reg | (PWM_RAMP1_PHASE__RAMP1_PHASE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP1_PHASE__RAMP1_PHASE__EXTRACT() extracts RAMP1_PHASE.RAMP1_PHASE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP1_PHASE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP1_PHASE
 * @return current value of RAMP1_PHASE.RAMP1_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP1_PHASE__RAMP1_PHASE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP1_PHASE__RAMP1_PHASE__Msk);
    reg = (reg >> PWM_RAMP1_PHASE__RAMP1_PHASE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      PWM_FORCE_HI_LO member of PWM_t                      */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM_FORCE_HI_LO__ADDRESS returns the address of member PWM_FORCE_HI_LO.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM_FORCE_HI_LO
 */
__PWM_INLINE uint32_t* __PWM_PWM_FORCE_HI_LO__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM_FORCE_HI_LO)));
}

/** PWM_PWM_FORCE_HI_LO__SET() sets PWM_FORCE_HI_LO to given value.
 *
 * When writing to PWM_FORCE_HI_LO, this is mandatory to use.
 *
 * @param value new value for PWM_FORCE_HI_LO
 */
__PWM_INLINE void PWM_PWM_FORCE_HI_LO__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM_FORCE_HI_LO__ADDRESS(), value);
}

/** PWM_PWM_FORCE_HI_LO__GET() gets PWM_FORCE_HI_LO's current value.
 *
 * When reading from PWM_FORCE_HI_LO, this is mandatory to use.
 *
 * @return current value of PWM_FORCE_HI_LO
 */
__PWM_INLINE uint32_t PWM_PWM_FORCE_HI_LO__GET(void)
{
    return HAL_GET32(__PWM_PWM_FORCE_HI_LO__ADDRESS());
}

/* -------------------- PWM.PWM_FORCE_HI_LO.PWM_FORCE_LO -------------------- */

/**
<pre>
  PWM.PWM_FORCE_HI_LO.PWM_FORCE_LO:

    Force PWM output low, [0] corresponds to PWM1, [11] corresponds to PWM12.  This register has higher priority than pwm_force_hi.

</pre> */

#define PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Pos                  12                                                                     /*!< Right-most bit position of pwm_force_lo in PWM.PWM_FORCE_HI_LO */
#define PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Msk                  (0x00000FFFUL << PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Pos)               /*!< Mask for pwm_force_lo in PWM.PWM_FORCE_HI_LO */
#define PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Shift(v)             (((v) << PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Pos) & PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Msk) /*!< Shift value 'v' into pwm_force_lo and mask 'v' to fit it into pwm_force_lo field */

/** PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__SET() sets PWM_FORCE_HI_LO.PWM_FORCE_LO to given value.
 *
 * When writing to PWM_FORCE_HI_LO.PWM_FORCE_LO, this is recommended to use.
 *
 * @param bf_value new value for PWM_FORCE_HI_LO.PWM_FORCE_LO
 */
__PWM_INLINE void PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_FORCE_HI_LO__GET();
    reg = (reg & ~PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Msk);
    reg = (reg | (PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Shift((uint32_t)bf_value)));
    PWM_PWM_FORCE_HI_LO__SET(reg);
}

/** PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__GET() gets PWM_FORCE_HI_LO.PWM_FORCE_LO's current value.
 *
 * When reading from PWM_FORCE_HI_LO.PWM_FORCE_LO, this is recommended to use.
 *
 * @return current value of PWM_FORCE_HI_LO.PWM_FORCE_LO
 */
__PWM_INLINE uint32_t PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__GET(void)
{
    uint32_t reg = PWM_PWM_FORCE_HI_LO__GET();
    reg = (reg & PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Msk);
    reg = (reg >> PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__MODIFY() modifies PWM_FORCE_HI_LO.PWM_FORCE_LO.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_FORCE_HI_LO.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_FORCE_HI_LO
 * @param bf_value new value for PWM_FORCE_HI_LO.PWM_FORCE_LO
 * @return new value of PWM.PWM_FORCE_HI_LO
 */
__PWM_INLINE uint32_t PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Msk);
    reg = (reg | (PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__EXTRACT() extracts PWM_FORCE_HI_LO.PWM_FORCE_LO.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_FORCE_HI_LO.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_FORCE_HI_LO
 * @return current value of PWM_FORCE_HI_LO.PWM_FORCE_LO
 */
__PWM_INLINE uint32_t PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Msk);
    reg = (reg >> PWM_PWM_FORCE_HI_LO__PWM_FORCE_LO__Pos);
    return (uint32_t)reg;
}

/* -------------------- PWM.PWM_FORCE_HI_LO.PWM_FORCE_HI -------------------- */

/**
<pre>
  PWM.PWM_FORCE_HI_LO.PWM_FORCE_HI:

    Force PWM output high, [0] corresponds to PWM1, [11] corresponds to PWM12.

</pre> */

#define PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Pos                  0                                                                      /*!< Right-most bit position of pwm_force_hi in PWM.PWM_FORCE_HI_LO */
#define PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Msk                  (0x00000FFFUL << PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Pos)               /*!< Mask for pwm_force_hi in PWM.PWM_FORCE_HI_LO */
#define PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Shift(v)             (((v) << PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Pos) & PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Msk) /*!< Shift value 'v' into pwm_force_hi and mask 'v' to fit it into pwm_force_hi field */

/** PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__SET() sets PWM_FORCE_HI_LO.PWM_FORCE_HI to given value.
 *
 * When writing to PWM_FORCE_HI_LO.PWM_FORCE_HI, this is recommended to use.
 *
 * @param bf_value new value for PWM_FORCE_HI_LO.PWM_FORCE_HI
 */
__PWM_INLINE void PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_FORCE_HI_LO__GET();
    reg = (reg & ~PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Msk);
    reg = (reg | (PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Shift((uint32_t)bf_value)));
    PWM_PWM_FORCE_HI_LO__SET(reg);
}

/** PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__GET() gets PWM_FORCE_HI_LO.PWM_FORCE_HI's current value.
 *
 * When reading from PWM_FORCE_HI_LO.PWM_FORCE_HI, this is recommended to use.
 *
 * @return current value of PWM_FORCE_HI_LO.PWM_FORCE_HI
 */
__PWM_INLINE uint32_t PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__GET(void)
{
    uint32_t reg = PWM_PWM_FORCE_HI_LO__GET();
    reg = (reg & PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Msk);
    reg = (reg >> PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__MODIFY() modifies PWM_FORCE_HI_LO.PWM_FORCE_HI.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_FORCE_HI_LO.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_FORCE_HI_LO
 * @param bf_value new value for PWM_FORCE_HI_LO.PWM_FORCE_HI
 * @return new value of PWM.PWM_FORCE_HI_LO
 */
__PWM_INLINE uint32_t PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Msk);
    reg = (reg | (PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__EXTRACT() extracts PWM_FORCE_HI_LO.PWM_FORCE_HI.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_FORCE_HI_LO.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_FORCE_HI_LO
 * @return current value of PWM_FORCE_HI_LO.PWM_FORCE_HI
 */
__PWM_INLINE uint32_t PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Msk);
    reg = (reg >> PWM_PWM_FORCE_HI_LO__PWM_FORCE_HI__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           PWM_ON member of PWM_t                           */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM_ON__ADDRESS returns the address of member PWM_ON.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM_ON
 */
__PWM_INLINE uint32_t* __PWM_PWM_ON__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM_ON)));
}

/** PWM_PWM_ON__SET() sets PWM_ON to given value.
 *
 * When writing to PWM_ON, this is mandatory to use.
 *
 * @param value new value for PWM_ON
 */
__PWM_INLINE void PWM_PWM_ON__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM_ON__ADDRESS(), value);
}

/** PWM_PWM_ON__GET() gets PWM_ON's current value.
 *
 * When reading from PWM_ON, this is mandatory to use.
 *
 * @return current value of PWM_ON
 */
__PWM_INLINE uint32_t PWM_PWM_ON__GET(void)
{
    return HAL_GET32(__PWM_PWM_ON__ADDRESS());
}

/* --------------------------- PWM.PWM_ON.PWM_ON --------------------------- */

/**
<pre>
  PWM.PWM_ON.PWM_ON:

    PWM channel enabled when bit position high, [0] corresponds to PWM1, [11] corresponds to PWM12.
    Note:
    Intended to be driven by FW only.

</pre> */

#define PWM_PWM_ON__PWM_ON__Pos                                 0                                                                      /*!< Right-most bit position of pwm_on in PWM.PWM_ON */
#define PWM_PWM_ON__PWM_ON__Msk                                 (0x00000FFFUL << PWM_PWM_ON__PWM_ON__Pos)                              /*!< Mask for pwm_on in PWM.PWM_ON */
#define PWM_PWM_ON__PWM_ON__Shift(v)                            (((v) << PWM_PWM_ON__PWM_ON__Pos) & PWM_PWM_ON__PWM_ON__Msk)           /*!< Shift value 'v' into pwm_on and mask 'v' to fit it into pwm_on field */

/** PWM_PWM_ON__PWM_ON__SET() sets PWM_ON.PWM_ON to given value.
 *
 * When writing to PWM_ON.PWM_ON, this is recommended to use.
 *
 * @param bf_value new value for PWM_ON.PWM_ON
 */
__PWM_INLINE void PWM_PWM_ON__PWM_ON__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_ON__GET();
    reg = (reg & ~PWM_PWM_ON__PWM_ON__Msk);
    reg = (reg | (PWM_PWM_ON__PWM_ON__Shift((uint32_t)bf_value)));
    PWM_PWM_ON__SET(reg);
}

/** PWM_PWM_ON__PWM_ON__GET() gets PWM_ON.PWM_ON's current value.
 *
 * When reading from PWM_ON.PWM_ON, this is recommended to use.
 *
 * @return current value of PWM_ON.PWM_ON
 */
__PWM_INLINE uint32_t PWM_PWM_ON__PWM_ON__GET(void)
{
    uint32_t reg = PWM_PWM_ON__GET();
    reg = (reg & PWM_PWM_ON__PWM_ON__Msk);
    reg = (reg >> PWM_PWM_ON__PWM_ON__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_ON__PWM_ON__MODIFY() modifies PWM_ON.PWM_ON.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_ON.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_ON
 * @param bf_value new value for PWM_ON.PWM_ON
 * @return new value of PWM.PWM_ON
 */
__PWM_INLINE uint32_t PWM_PWM_ON__PWM_ON__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_ON__PWM_ON__Msk);
    reg = (reg | (PWM_PWM_ON__PWM_ON__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_ON__PWM_ON__EXTRACT() extracts PWM_ON.PWM_ON.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_ON.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_ON
 * @return current value of PWM_ON.PWM_ON
 */
__PWM_INLINE uint32_t PWM_PWM_ON__PWM_ON__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_ON__PWM_ON__Msk);
    reg = (reg >> PWM_PWM_ON__PWM_ON__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       RAMP0_TSWITCH0 member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP0_TSWITCH0__ADDRESS returns the address of member RAMP0_TSWITCH0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP0_TSWITCH0
 */
__PWM_INLINE uint32_t* __PWM_RAMP0_TSWITCH0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP0_TSWITCH0)));
}

/** PWM_RAMP0_TSWITCH0__SET() sets RAMP0_TSWITCH0 to given value.
 *
 * When writing to RAMP0_TSWITCH0, this is mandatory to use.
 *
 * @param value new value for RAMP0_TSWITCH0
 */
__PWM_INLINE void PWM_RAMP0_TSWITCH0__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP0_TSWITCH0__ADDRESS(), value);
}

/** PWM_RAMP0_TSWITCH0__GET() gets RAMP0_TSWITCH0's current value.
 *
 * When reading from RAMP0_TSWITCH0, this is mandatory to use.
 *
 * @return current value of RAMP0_TSWITCH0
 */
__PWM_INLINE uint32_t PWM_RAMP0_TSWITCH0__GET(void)
{
    return HAL_GET32(__PWM_RAMP0_TSWITCH0__ADDRESS());
}

/* ---------------------- PWM.RAMP0_TSWITCH0.TSWITCH0 ---------------------- */

/**
<pre>
  PWM.RAMP0_TSWITCH0.TSWITCH0:

    PWM Ramp 0 switching period.  This register defines the switching period of ramp 0 when ramp0_sync_sel is set to internal sync or when ramp0_sync_sel is set to external sync but and exteranl sync signal is not provided.
    Computed from PMBus as follows:
    <start table>
    "tswitch0(U11.-2) = 1 / (Fswitch(Hz) * 20ns)"
    "&emsp;= 25,000 / FREQUENCY_SWITCH(U11.-1)"
    <end table>
    LSB = 20ns, Range = 0.0 to 10,22us

</pre> */

#define PWM_RAMP0_TSWITCH0__TSWITCH0__Pos                       0                                                                      /*!< Right-most bit position of tswitch0 in PWM.RAMP0_TSWITCH0 */
#define PWM_RAMP0_TSWITCH0__TSWITCH0__Msk                       (0x000001FFUL << PWM_RAMP0_TSWITCH0__TSWITCH0__Pos)                    /*!< Mask for tswitch0 in PWM.RAMP0_TSWITCH0 */
#define PWM_RAMP0_TSWITCH0__TSWITCH0__Shift(v)                  (((v) << PWM_RAMP0_TSWITCH0__TSWITCH0__Pos) & PWM_RAMP0_TSWITCH0__TSWITCH0__Msk) /*!< Shift value 'v' into tswitch0 and mask 'v' to fit it into tswitch0 field */

/** PWM_RAMP0_TSWITCH0__TSWITCH0__SET() sets RAMP0_TSWITCH0.TSWITCH0 to given value.
 *
 * When writing to RAMP0_TSWITCH0.TSWITCH0, this is recommended to use.
 *
 * @param bf_value new value for RAMP0_TSWITCH0.TSWITCH0
 */
__PWM_INLINE void PWM_RAMP0_TSWITCH0__TSWITCH0__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP0_TSWITCH0__GET();
    reg = (reg & ~PWM_RAMP0_TSWITCH0__TSWITCH0__Msk);
    reg = (reg | (PWM_RAMP0_TSWITCH0__TSWITCH0__Shift((uint32_t)bf_value)));
    PWM_RAMP0_TSWITCH0__SET(reg);
}

/** PWM_RAMP0_TSWITCH0__TSWITCH0__GET() gets RAMP0_TSWITCH0.TSWITCH0's current value.
 *
 * When reading from RAMP0_TSWITCH0.TSWITCH0, this is recommended to use.
 *
 * @return current value of RAMP0_TSWITCH0.TSWITCH0
 */
__PWM_INLINE uint32_t PWM_RAMP0_TSWITCH0__TSWITCH0__GET(void)
{
    uint32_t reg = PWM_RAMP0_TSWITCH0__GET();
    reg = (reg & PWM_RAMP0_TSWITCH0__TSWITCH0__Msk);
    reg = (reg >> PWM_RAMP0_TSWITCH0__TSWITCH0__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP0_TSWITCH0__TSWITCH0__MODIFY() modifies RAMP0_TSWITCH0.TSWITCH0.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP0_TSWITCH0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP0_TSWITCH0
 * @param bf_value new value for RAMP0_TSWITCH0.TSWITCH0
 * @return new value of PWM.RAMP0_TSWITCH0
 */
__PWM_INLINE uint32_t PWM_RAMP0_TSWITCH0__TSWITCH0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP0_TSWITCH0__TSWITCH0__Msk);
    reg = (reg | (PWM_RAMP0_TSWITCH0__TSWITCH0__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP0_TSWITCH0__TSWITCH0__EXTRACT() extracts RAMP0_TSWITCH0.TSWITCH0.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP0_TSWITCH0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP0_TSWITCH0
 * @return current value of RAMP0_TSWITCH0.TSWITCH0
 */
__PWM_INLINE uint32_t PWM_RAMP0_TSWITCH0__TSWITCH0__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP0_TSWITCH0__TSWITCH0__Msk);
    reg = (reg >> PWM_RAMP0_TSWITCH0__TSWITCH0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      RAMP0_PW_MINMAX member of PWM_t                      */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP0_PW_MINMAX__ADDRESS returns the address of member RAMP0_PW_MINMAX.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP0_PW_MINMAX
 */
__PWM_INLINE uint32_t* __PWM_RAMP0_PW_MINMAX__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP0_PW_MINMAX)));
}

/** PWM_RAMP0_PW_MINMAX__SET() sets RAMP0_PW_MINMAX to given value.
 *
 * When writing to RAMP0_PW_MINMAX, this is mandatory to use.
 *
 * @param value new value for RAMP0_PW_MINMAX
 */
__PWM_INLINE void PWM_RAMP0_PW_MINMAX__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP0_PW_MINMAX__ADDRESS(), value);
}

/** PWM_RAMP0_PW_MINMAX__GET() gets RAMP0_PW_MINMAX's current value.
 *
 * When reading from RAMP0_PW_MINMAX, this is mandatory to use.
 *
 * @return current value of RAMP0_PW_MINMAX
 */
__PWM_INLINE uint32_t PWM_RAMP0_PW_MINMAX__GET(void)
{
    return HAL_GET32(__PWM_RAMP0_PW_MINMAX__ADDRESS());
}

/* -------------------- PWM.RAMP0_PW_MINMAX.RAMP0_PW_MIN -------------------- */

/**
<pre>
  PWM.RAMP0_PW_MINMAX.RAMP0_PW_MIN:

    PWM Ramp 0 min pulse width.  When the duty cycle from the PID is less than this value the duty cycle input to the ramp is either clamped to this value or set to 0 as determined by the setting of ramp0_pw_min_state.
    Computed from PMBus as follows:
    <start table>
    "ramp0_pw_min(U8.0) = MFR_MIN_PW(U8.0)"
    <end table>
    LSB = 5ns, Range = 0 to 1275ns

</pre> */

#define PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Pos                  8                                                                      /*!< Right-most bit position of ramp0_pw_min in PWM.RAMP0_PW_MINMAX */
#define PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Msk                  (0x000000FFUL << PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Pos)               /*!< Mask for ramp0_pw_min in PWM.RAMP0_PW_MINMAX */
#define PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Shift(v)             (((v) << PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Pos) & PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Msk) /*!< Shift value 'v' into ramp0_pw_min and mask 'v' to fit it into ramp0_pw_min field */

/** PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__SET() sets RAMP0_PW_MINMAX.RAMP0_PW_MIN to given value.
 *
 * When writing to RAMP0_PW_MINMAX.RAMP0_PW_MIN, this is recommended to use.
 *
 * @param bf_value new value for RAMP0_PW_MINMAX.RAMP0_PW_MIN
 */
__PWM_INLINE void PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP0_PW_MINMAX__GET();
    reg = (reg & ~PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Msk);
    reg = (reg | (PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Shift((uint32_t)bf_value)));
    PWM_RAMP0_PW_MINMAX__SET(reg);
}

/** PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__GET() gets RAMP0_PW_MINMAX.RAMP0_PW_MIN's current value.
 *
 * When reading from RAMP0_PW_MINMAX.RAMP0_PW_MIN, this is recommended to use.
 *
 * @return current value of RAMP0_PW_MINMAX.RAMP0_PW_MIN
 */
__PWM_INLINE uint32_t PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__GET(void)
{
    uint32_t reg = PWM_RAMP0_PW_MINMAX__GET();
    reg = (reg & PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Msk);
    reg = (reg >> PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__MODIFY() modifies RAMP0_PW_MINMAX.RAMP0_PW_MIN.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP0_PW_MINMAX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP0_PW_MINMAX
 * @param bf_value new value for RAMP0_PW_MINMAX.RAMP0_PW_MIN
 * @return new value of PWM.RAMP0_PW_MINMAX
 */
__PWM_INLINE uint32_t PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Msk);
    reg = (reg | (PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__EXTRACT() extracts RAMP0_PW_MINMAX.RAMP0_PW_MIN.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP0_PW_MINMAX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP0_PW_MINMAX
 * @return current value of RAMP0_PW_MINMAX.RAMP0_PW_MIN
 */
__PWM_INLINE uint32_t PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Msk);
    reg = (reg >> PWM_RAMP0_PW_MINMAX__RAMP0_PW_MIN__Pos);
    return (uint32_t)reg;
}

/* -------------------- PWM.RAMP0_PW_MINMAX.RAMP0_DC_MAX -------------------- */

/**
<pre>
  PWM.RAMP0_PW_MINMAX.RAMP0_DC_MAX:

    PWM Ramp 0 max duty cycle (fixed).  See ramp0_dc_max_nom description for scaled max duty cycle information.
    Computed from PMBus as follows:
    <start table>
    "ramp0_dc_max(U7.1) = MAX_DUTY(U7.1)"
    <end table>
    LSB = 0.5%, Range = 0.0 to 99.5%

</pre> */

#define PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Pos                  0                                                                      /*!< Right-most bit position of ramp0_dc_max in PWM.RAMP0_PW_MINMAX */
#define PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Msk                  (0x000000FFUL << PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Pos)               /*!< Mask for ramp0_dc_max in PWM.RAMP0_PW_MINMAX */
#define PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Shift(v)             (((v) << PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Pos) & PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Msk) /*!< Shift value 'v' into ramp0_dc_max and mask 'v' to fit it into ramp0_dc_max field */

/** PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__SET() sets RAMP0_PW_MINMAX.RAMP0_DC_MAX to given value.
 *
 * When writing to RAMP0_PW_MINMAX.RAMP0_DC_MAX, this is recommended to use.
 *
 * @param bf_value new value for RAMP0_PW_MINMAX.RAMP0_DC_MAX
 */
__PWM_INLINE void PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP0_PW_MINMAX__GET();
    reg = (reg & ~PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Msk);
    reg = (reg | (PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Shift((uint32_t)bf_value)));
    PWM_RAMP0_PW_MINMAX__SET(reg);
}

/** PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__GET() gets RAMP0_PW_MINMAX.RAMP0_DC_MAX's current value.
 *
 * When reading from RAMP0_PW_MINMAX.RAMP0_DC_MAX, this is recommended to use.
 *
 * @return current value of RAMP0_PW_MINMAX.RAMP0_DC_MAX
 */
__PWM_INLINE uint32_t PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__GET(void)
{
    uint32_t reg = PWM_RAMP0_PW_MINMAX__GET();
    reg = (reg & PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Msk);
    reg = (reg >> PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__MODIFY() modifies RAMP0_PW_MINMAX.RAMP0_DC_MAX.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP0_PW_MINMAX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP0_PW_MINMAX
 * @param bf_value new value for RAMP0_PW_MINMAX.RAMP0_DC_MAX
 * @return new value of PWM.RAMP0_PW_MINMAX
 */
__PWM_INLINE uint32_t PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Msk);
    reg = (reg | (PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__EXTRACT() extracts RAMP0_PW_MINMAX.RAMP0_DC_MAX.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP0_PW_MINMAX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP0_PW_MINMAX
 * @return current value of RAMP0_PW_MINMAX.RAMP0_DC_MAX
 */
__PWM_INLINE uint32_t PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Msk);
    reg = (reg >> PWM_RAMP0_PW_MINMAX__RAMP0_DC_MAX__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      RAMP0_FORCE_DUTY member of PWM_t                      */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP0_FORCE_DUTY__ADDRESS returns the address of member RAMP0_FORCE_DUTY.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP0_FORCE_DUTY
 */
__PWM_INLINE uint32_t* __PWM_RAMP0_FORCE_DUTY__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP0_FORCE_DUTY)));
}

/** PWM_RAMP0_FORCE_DUTY__SET() sets RAMP0_FORCE_DUTY to given value.
 *
 * When writing to RAMP0_FORCE_DUTY, this is mandatory to use.
 *
 * @param value new value for RAMP0_FORCE_DUTY
 */
__PWM_INLINE void PWM_RAMP0_FORCE_DUTY__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP0_FORCE_DUTY__ADDRESS(), value);
}

/** PWM_RAMP0_FORCE_DUTY__GET() gets RAMP0_FORCE_DUTY's current value.
 *
 * When reading from RAMP0_FORCE_DUTY, this is mandatory to use.
 *
 * @return current value of RAMP0_FORCE_DUTY
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_DUTY__GET(void)
{
    return HAL_GET32(__PWM_RAMP0_FORCE_DUTY__ADDRESS());
}

/* ---------------- PWM.RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN ---------------- */

/**
<pre>
  PWM.RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN:

    PWM Ramp 0 forced duty cycle select.
    <start table>
    0 "use PID computed Duty Cycle"
    1 "use ramp0_force_duty"
    <end table>

</pre> */

#define PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Pos          8                                                                      /*!< Right-most bit position of ramp0_force_duty_en in PWM.RAMP0_FORCE_DUTY */
#define PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Msk          (0x00000001UL << PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Pos)       /*!< Mask for ramp0_force_duty_en in PWM.RAMP0_FORCE_DUTY */
#define PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Shift(v)     (((v) << PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Pos) & PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Msk) /*!< Shift value 'v' into ramp0_force_duty_en and mask 'v' to fit it into ramp0_force_duty_en field */

/** PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__SET() sets RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN to given value.
 *
 * When writing to RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN, this is recommended to use.
 *
 * @param bf_value new value for RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN
 */
__PWM_INLINE void PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP0_FORCE_DUTY__GET();
    reg = (reg & ~PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Shift((uint32_t)bf_value)));
    PWM_RAMP0_FORCE_DUTY__SET(reg);
}

/** PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__GET() gets RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN's current value.
 *
 * When reading from RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN, this is recommended to use.
 *
 * @return current value of RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__GET(void)
{
    uint32_t reg = PWM_RAMP0_FORCE_DUTY__GET();
    reg = (reg & PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__MODIFY() modifies RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP0_FORCE_DUTY.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP0_FORCE_DUTY
 * @param bf_value new value for RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN
 * @return new value of PWM.RAMP0_FORCE_DUTY
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__EXTRACT() extracts RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP0_FORCE_DUTY.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP0_FORCE_DUTY
 * @return current value of RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY_EN
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------- PWM.RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY ----------------- */

/**
<pre>
  PWM.RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY:

    Forced duty cycle value overrides ramp 0 input when selected by ramp0_force_duty_en.  Since this force is applied at the ramp input, upstream adjustments to the duty cycle such as current balance in an interleaved (multi-phase) design are overwritten.  To not override the current balance adjust use pid0.pid_force_duty or pid1.pid_force_duty which apply the force prior to downstream adjustments.
    LSB = 0.3906%, Range = 0.0 to 99.6094%

</pre> */

#define PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Pos             0                                                                      /*!< Right-most bit position of ramp0_force_duty in PWM.RAMP0_FORCE_DUTY */
#define PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Msk             (0x000000FFUL << PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Pos)          /*!< Mask for ramp0_force_duty in PWM.RAMP0_FORCE_DUTY */
#define PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Shift(v)        (((v) << PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Pos) & PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Msk) /*!< Shift value 'v' into ramp0_force_duty and mask 'v' to fit it into ramp0_force_duty field */

/** PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__SET() sets RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY to given value.
 *
 * When writing to RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY, this is recommended to use.
 *
 * @param bf_value new value for RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY
 */
__PWM_INLINE void PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP0_FORCE_DUTY__GET();
    reg = (reg & ~PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Shift((uint32_t)bf_value)));
    PWM_RAMP0_FORCE_DUTY__SET(reg);
}

/** PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__GET() gets RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY's current value.
 *
 * When reading from RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY, this is recommended to use.
 *
 * @return current value of RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__GET(void)
{
    uint32_t reg = PWM_RAMP0_FORCE_DUTY__GET();
    reg = (reg & PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__MODIFY() modifies RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP0_FORCE_DUTY.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP0_FORCE_DUTY
 * @param bf_value new value for RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY
 * @return new value of PWM.RAMP0_FORCE_DUTY
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__EXTRACT() extracts RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP0_FORCE_DUTY.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP0_FORCE_DUTY
 * @return current value of RAMP0_FORCE_DUTY.RAMP0_FORCE_DUTY
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_DUTY__RAMP0_FORCE_DUTY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       RAMP0_FORCE_T1 member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP0_FORCE_T1__ADDRESS returns the address of member RAMP0_FORCE_T1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP0_FORCE_T1
 */
__PWM_INLINE uint32_t* __PWM_RAMP0_FORCE_T1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP0_FORCE_T1)));
}

/** PWM_RAMP0_FORCE_T1__SET() sets RAMP0_FORCE_T1 to given value.
 *
 * When writing to RAMP0_FORCE_T1, this is mandatory to use.
 *
 * @param value new value for RAMP0_FORCE_T1
 */
__PWM_INLINE void PWM_RAMP0_FORCE_T1__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP0_FORCE_T1__ADDRESS(), value);
}

/** PWM_RAMP0_FORCE_T1__GET() gets RAMP0_FORCE_T1's current value.
 *
 * When reading from RAMP0_FORCE_T1, this is mandatory to use.
 *
 * @return current value of RAMP0_FORCE_T1
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T1__GET(void)
{
    return HAL_GET32(__PWM_RAMP0_FORCE_T1__ADDRESS());
}

/* ------------------ PWM.RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN ------------------ */

/**
<pre>
  PWM.RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN:

    PWM Ramp 0 T1 force enable.
    <start table>
    0 "T1 determined by modulation scheme and duty cycle"
    1 "T1 set by ramp0_force_t1"
    <end table>

</pre> */

#define PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Pos              11                                                                     /*!< Right-most bit position of ramp0_force_t1_en in PWM.RAMP0_FORCE_T1 */
#define PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Msk              (0x00000001UL << PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Pos)           /*!< Mask for ramp0_force_t1_en in PWM.RAMP0_FORCE_T1 */
#define PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Shift(v)         (((v) << PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Pos) & PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Msk) /*!< Shift value 'v' into ramp0_force_t1_en and mask 'v' to fit it into ramp0_force_t1_en field */

/** PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__SET() sets RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN to given value.
 *
 * When writing to RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN, this is recommended to use.
 *
 * @param bf_value new value for RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN
 */
__PWM_INLINE void PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP0_FORCE_T1__GET();
    reg = (reg & ~PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Shift((uint32_t)bf_value)));
    PWM_RAMP0_FORCE_T1__SET(reg);
}

/** PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__GET() gets RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN's current value.
 *
 * When reading from RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN, this is recommended to use.
 *
 * @return current value of RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__GET(void)
{
    uint32_t reg = PWM_RAMP0_FORCE_T1__GET();
    reg = (reg & PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__MODIFY() modifies RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP0_FORCE_T1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP0_FORCE_T1
 * @param bf_value new value for RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN
 * @return new value of PWM.RAMP0_FORCE_T1
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__EXTRACT() extracts RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP0_FORCE_T1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP0_FORCE_T1
 * @return current value of RAMP0_FORCE_T1.RAMP0_FORCE_T1_EN
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- PWM.RAMP0_FORCE_T1.RAMP0_FORCE_T1 ------------------- */

/**
<pre>
  PWM.RAMP0_FORCE_T1.RAMP0_FORCE_T1:

    PWM Ramp 0 forced T1 setting selected by ramp0_force_t1_en.  T1 is the time of the first PWM "edge" in a ramp cycle.  In a trailing edge modulation scheme T1 is fixed at 0.  In the leading and dual edge modulation schemes T1 is determined based on the duty cycle.
    LSB = 5ns, Range = 0 to 10235ns

</pre> */

#define PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Pos                 0                                                                      /*!< Right-most bit position of ramp0_force_t1 in PWM.RAMP0_FORCE_T1 */
#define PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Msk                 (0x000007FFUL << PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Pos)              /*!< Mask for ramp0_force_t1 in PWM.RAMP0_FORCE_T1 */
#define PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Shift(v)            (((v) << PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Pos) & PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Msk) /*!< Shift value 'v' into ramp0_force_t1 and mask 'v' to fit it into ramp0_force_t1 field */

/** PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__SET() sets RAMP0_FORCE_T1.RAMP0_FORCE_T1 to given value.
 *
 * When writing to RAMP0_FORCE_T1.RAMP0_FORCE_T1, this is recommended to use.
 *
 * @param bf_value new value for RAMP0_FORCE_T1.RAMP0_FORCE_T1
 */
__PWM_INLINE void PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP0_FORCE_T1__GET();
    reg = (reg & ~PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Shift((uint32_t)bf_value)));
    PWM_RAMP0_FORCE_T1__SET(reg);
}

/** PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__GET() gets RAMP0_FORCE_T1.RAMP0_FORCE_T1's current value.
 *
 * When reading from RAMP0_FORCE_T1.RAMP0_FORCE_T1, this is recommended to use.
 *
 * @return current value of RAMP0_FORCE_T1.RAMP0_FORCE_T1
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__GET(void)
{
    uint32_t reg = PWM_RAMP0_FORCE_T1__GET();
    reg = (reg & PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__MODIFY() modifies RAMP0_FORCE_T1.RAMP0_FORCE_T1.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP0_FORCE_T1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP0_FORCE_T1
 * @param bf_value new value for RAMP0_FORCE_T1.RAMP0_FORCE_T1
 * @return new value of PWM.RAMP0_FORCE_T1
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__EXTRACT() extracts RAMP0_FORCE_T1.RAMP0_FORCE_T1.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP0_FORCE_T1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP0_FORCE_T1
 * @return current value of RAMP0_FORCE_T1.RAMP0_FORCE_T1
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_T1__RAMP0_FORCE_T1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       RAMP0_FORCE_T2 member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP0_FORCE_T2__ADDRESS returns the address of member RAMP0_FORCE_T2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP0_FORCE_T2
 */
__PWM_INLINE uint32_t* __PWM_RAMP0_FORCE_T2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP0_FORCE_T2)));
}

/** PWM_RAMP0_FORCE_T2__SET() sets RAMP0_FORCE_T2 to given value.
 *
 * When writing to RAMP0_FORCE_T2, this is mandatory to use.
 *
 * @param value new value for RAMP0_FORCE_T2
 */
__PWM_INLINE void PWM_RAMP0_FORCE_T2__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP0_FORCE_T2__ADDRESS(), value);
}

/** PWM_RAMP0_FORCE_T2__GET() gets RAMP0_FORCE_T2's current value.
 *
 * When reading from RAMP0_FORCE_T2, this is mandatory to use.
 *
 * @return current value of RAMP0_FORCE_T2
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T2__GET(void)
{
    return HAL_GET32(__PWM_RAMP0_FORCE_T2__ADDRESS());
}

/* ------------------ PWM.RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN ------------------ */

/**
<pre>
  PWM.RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN:

    PWM Ramp 0 T2 force enable.
    <start table>
    0 "T2 determined by modulation scheme and duty cycle"
    1 "T2 set by ramp0_force_t2"
    <end table>

</pre> */

#define PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Pos              11                                                                     /*!< Right-most bit position of ramp0_force_t2_en in PWM.RAMP0_FORCE_T2 */
#define PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Msk              (0x00000001UL << PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Pos)           /*!< Mask for ramp0_force_t2_en in PWM.RAMP0_FORCE_T2 */
#define PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Shift(v)         (((v) << PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Pos) & PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Msk) /*!< Shift value 'v' into ramp0_force_t2_en and mask 'v' to fit it into ramp0_force_t2_en field */

/** PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__SET() sets RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN to given value.
 *
 * When writing to RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN, this is recommended to use.
 *
 * @param bf_value new value for RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN
 */
__PWM_INLINE void PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP0_FORCE_T2__GET();
    reg = (reg & ~PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Shift((uint32_t)bf_value)));
    PWM_RAMP0_FORCE_T2__SET(reg);
}

/** PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__GET() gets RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN's current value.
 *
 * When reading from RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN, this is recommended to use.
 *
 * @return current value of RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__GET(void)
{
    uint32_t reg = PWM_RAMP0_FORCE_T2__GET();
    reg = (reg & PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__MODIFY() modifies RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP0_FORCE_T2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP0_FORCE_T2
 * @param bf_value new value for RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN
 * @return new value of PWM.RAMP0_FORCE_T2
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__EXTRACT() extracts RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP0_FORCE_T2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP0_FORCE_T2
 * @return current value of RAMP0_FORCE_T2.RAMP0_FORCE_T2_EN
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- PWM.RAMP0_FORCE_T2.RAMP0_FORCE_T2 ------------------- */

/**
<pre>
  PWM.RAMP0_FORCE_T2.RAMP0_FORCE_T2:

    PWM Ramp 0 forced T2 setting selected by ramp0_force_t2_en.  T2 is the time of the second PWM "edge" in a ramp cycle.  In a leading edge modulation scheme T1 is fixed at Tswitch (or Tswitch/2 in bridge topologies).  In the trailing and dual edge modulation schemes T2 is determined based on the duty cycle.
    LSB = 5ns, Range = 0 to 10235ns

</pre> */

#define PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Pos                 0                                                                      /*!< Right-most bit position of ramp0_force_t2 in PWM.RAMP0_FORCE_T2 */
#define PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Msk                 (0x000007FFUL << PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Pos)              /*!< Mask for ramp0_force_t2 in PWM.RAMP0_FORCE_T2 */
#define PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Shift(v)            (((v) << PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Pos) & PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Msk) /*!< Shift value 'v' into ramp0_force_t2 and mask 'v' to fit it into ramp0_force_t2 field */

/** PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__SET() sets RAMP0_FORCE_T2.RAMP0_FORCE_T2 to given value.
 *
 * When writing to RAMP0_FORCE_T2.RAMP0_FORCE_T2, this is recommended to use.
 *
 * @param bf_value new value for RAMP0_FORCE_T2.RAMP0_FORCE_T2
 */
__PWM_INLINE void PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP0_FORCE_T2__GET();
    reg = (reg & ~PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Shift((uint32_t)bf_value)));
    PWM_RAMP0_FORCE_T2__SET(reg);
}

/** PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__GET() gets RAMP0_FORCE_T2.RAMP0_FORCE_T2's current value.
 *
 * When reading from RAMP0_FORCE_T2.RAMP0_FORCE_T2, this is recommended to use.
 *
 * @return current value of RAMP0_FORCE_T2.RAMP0_FORCE_T2
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__GET(void)
{
    uint32_t reg = PWM_RAMP0_FORCE_T2__GET();
    reg = (reg & PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__MODIFY() modifies RAMP0_FORCE_T2.RAMP0_FORCE_T2.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP0_FORCE_T2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP0_FORCE_T2
 * @param bf_value new value for RAMP0_FORCE_T2.RAMP0_FORCE_T2
 * @return new value of PWM.RAMP0_FORCE_T2
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Msk);
    reg = (reg | (PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__EXTRACT() extracts RAMP0_FORCE_T2.RAMP0_FORCE_T2.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP0_FORCE_T2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP0_FORCE_T2
 * @return current value of RAMP0_FORCE_T2.RAMP0_FORCE_T2
 */
__PWM_INLINE uint32_t PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Msk);
    reg = (reg >> PWM_RAMP0_FORCE_T2__RAMP0_FORCE_T2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       RAMP1_TSWITCH1 member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP1_TSWITCH1__ADDRESS returns the address of member RAMP1_TSWITCH1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP1_TSWITCH1
 */
__PWM_INLINE uint32_t* __PWM_RAMP1_TSWITCH1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP1_TSWITCH1)));
}

/** PWM_RAMP1_TSWITCH1__SET() sets RAMP1_TSWITCH1 to given value.
 *
 * When writing to RAMP1_TSWITCH1, this is mandatory to use.
 *
 * @param value new value for RAMP1_TSWITCH1
 */
__PWM_INLINE void PWM_RAMP1_TSWITCH1__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP1_TSWITCH1__ADDRESS(), value);
}

/** PWM_RAMP1_TSWITCH1__GET() gets RAMP1_TSWITCH1's current value.
 *
 * When reading from RAMP1_TSWITCH1, this is mandatory to use.
 *
 * @return current value of RAMP1_TSWITCH1
 */
__PWM_INLINE uint32_t PWM_RAMP1_TSWITCH1__GET(void)
{
    return HAL_GET32(__PWM_RAMP1_TSWITCH1__ADDRESS());
}

/* ---------------------- PWM.RAMP1_TSWITCH1.TSWITCH1 ---------------------- */

/**
<pre>
  PWM.RAMP1_TSWITCH1.TSWITCH1:

    PWM Ramp 1 switching period.  This register defines the switching period of ramp 1 when ramp1_sync_sel is set to internal sync or when ramp1_sync_sel is set to external sync but and exteranl sync signal is not provided.
    Computed from PMBus as follows:
    <start table>
    "tswitch1(U11.-2) = 1 / (Fswitch(Hz) * 20ns)"
    "&emsp;= 25,000 / FREQUENCY_SWITCH(U11.-1)"
    <end table>
    LSB = 20ns, Range = 0.0 to 10,22us

</pre> */

#define PWM_RAMP1_TSWITCH1__TSWITCH1__Pos                       0                                                                      /*!< Right-most bit position of tswitch1 in PWM.RAMP1_TSWITCH1 */
#define PWM_RAMP1_TSWITCH1__TSWITCH1__Msk                       (0x000001FFUL << PWM_RAMP1_TSWITCH1__TSWITCH1__Pos)                    /*!< Mask for tswitch1 in PWM.RAMP1_TSWITCH1 */
#define PWM_RAMP1_TSWITCH1__TSWITCH1__Shift(v)                  (((v) << PWM_RAMP1_TSWITCH1__TSWITCH1__Pos) & PWM_RAMP1_TSWITCH1__TSWITCH1__Msk) /*!< Shift value 'v' into tswitch1 and mask 'v' to fit it into tswitch1 field */

/** PWM_RAMP1_TSWITCH1__TSWITCH1__SET() sets RAMP1_TSWITCH1.TSWITCH1 to given value.
 *
 * When writing to RAMP1_TSWITCH1.TSWITCH1, this is recommended to use.
 *
 * @param bf_value new value for RAMP1_TSWITCH1.TSWITCH1
 */
__PWM_INLINE void PWM_RAMP1_TSWITCH1__TSWITCH1__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP1_TSWITCH1__GET();
    reg = (reg & ~PWM_RAMP1_TSWITCH1__TSWITCH1__Msk);
    reg = (reg | (PWM_RAMP1_TSWITCH1__TSWITCH1__Shift((uint32_t)bf_value)));
    PWM_RAMP1_TSWITCH1__SET(reg);
}

/** PWM_RAMP1_TSWITCH1__TSWITCH1__GET() gets RAMP1_TSWITCH1.TSWITCH1's current value.
 *
 * When reading from RAMP1_TSWITCH1.TSWITCH1, this is recommended to use.
 *
 * @return current value of RAMP1_TSWITCH1.TSWITCH1
 */
__PWM_INLINE uint32_t PWM_RAMP1_TSWITCH1__TSWITCH1__GET(void)
{
    uint32_t reg = PWM_RAMP1_TSWITCH1__GET();
    reg = (reg & PWM_RAMP1_TSWITCH1__TSWITCH1__Msk);
    reg = (reg >> PWM_RAMP1_TSWITCH1__TSWITCH1__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP1_TSWITCH1__TSWITCH1__MODIFY() modifies RAMP1_TSWITCH1.TSWITCH1.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP1_TSWITCH1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP1_TSWITCH1
 * @param bf_value new value for RAMP1_TSWITCH1.TSWITCH1
 * @return new value of PWM.RAMP1_TSWITCH1
 */
__PWM_INLINE uint32_t PWM_RAMP1_TSWITCH1__TSWITCH1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP1_TSWITCH1__TSWITCH1__Msk);
    reg = (reg | (PWM_RAMP1_TSWITCH1__TSWITCH1__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP1_TSWITCH1__TSWITCH1__EXTRACT() extracts RAMP1_TSWITCH1.TSWITCH1.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP1_TSWITCH1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP1_TSWITCH1
 * @return current value of RAMP1_TSWITCH1.TSWITCH1
 */
__PWM_INLINE uint32_t PWM_RAMP1_TSWITCH1__TSWITCH1__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP1_TSWITCH1__TSWITCH1__Msk);
    reg = (reg >> PWM_RAMP1_TSWITCH1__TSWITCH1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      RAMP1_PW_MINMAX member of PWM_t                      */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP1_PW_MINMAX__ADDRESS returns the address of member RAMP1_PW_MINMAX.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP1_PW_MINMAX
 */
__PWM_INLINE uint32_t* __PWM_RAMP1_PW_MINMAX__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP1_PW_MINMAX)));
}

/** PWM_RAMP1_PW_MINMAX__SET() sets RAMP1_PW_MINMAX to given value.
 *
 * When writing to RAMP1_PW_MINMAX, this is mandatory to use.
 *
 * @param value new value for RAMP1_PW_MINMAX
 */
__PWM_INLINE void PWM_RAMP1_PW_MINMAX__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP1_PW_MINMAX__ADDRESS(), value);
}

/** PWM_RAMP1_PW_MINMAX__GET() gets RAMP1_PW_MINMAX's current value.
 *
 * When reading from RAMP1_PW_MINMAX, this is mandatory to use.
 *
 * @return current value of RAMP1_PW_MINMAX
 */
__PWM_INLINE uint32_t PWM_RAMP1_PW_MINMAX__GET(void)
{
    return HAL_GET32(__PWM_RAMP1_PW_MINMAX__ADDRESS());
}

/* -------------------- PWM.RAMP1_PW_MINMAX.RAMP1_PW_MIN -------------------- */

/**
<pre>
  PWM.RAMP1_PW_MINMAX.RAMP1_PW_MIN:

    PWM Ramp 1 min pulse width.  When the duty cycle from the PID is less than this value the duty cycle input to the ramp is either clamped to this value or set to 0 as determined by the setting of ramp1_pw_min_state.
    Computed from PMBus as follows:
    <start table>
    "ramp1_pw_min(U8.0) = MFR_MIN_PW(U8.0)"
    <end table>
    LSB = 5ns, Range = 0 to 1275ns

</pre> */

#define PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Pos                  8                                                                      /*!< Right-most bit position of ramp1_pw_min in PWM.RAMP1_PW_MINMAX */
#define PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Msk                  (0x000000FFUL << PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Pos)               /*!< Mask for ramp1_pw_min in PWM.RAMP1_PW_MINMAX */
#define PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Shift(v)             (((v) << PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Pos) & PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Msk) /*!< Shift value 'v' into ramp1_pw_min and mask 'v' to fit it into ramp1_pw_min field */

/** PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__SET() sets RAMP1_PW_MINMAX.RAMP1_PW_MIN to given value.
 *
 * When writing to RAMP1_PW_MINMAX.RAMP1_PW_MIN, this is recommended to use.
 *
 * @param bf_value new value for RAMP1_PW_MINMAX.RAMP1_PW_MIN
 */
__PWM_INLINE void PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP1_PW_MINMAX__GET();
    reg = (reg & ~PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Msk);
    reg = (reg | (PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Shift((uint32_t)bf_value)));
    PWM_RAMP1_PW_MINMAX__SET(reg);
}

/** PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__GET() gets RAMP1_PW_MINMAX.RAMP1_PW_MIN's current value.
 *
 * When reading from RAMP1_PW_MINMAX.RAMP1_PW_MIN, this is recommended to use.
 *
 * @return current value of RAMP1_PW_MINMAX.RAMP1_PW_MIN
 */
__PWM_INLINE uint32_t PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__GET(void)
{
    uint32_t reg = PWM_RAMP1_PW_MINMAX__GET();
    reg = (reg & PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Msk);
    reg = (reg >> PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__MODIFY() modifies RAMP1_PW_MINMAX.RAMP1_PW_MIN.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP1_PW_MINMAX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP1_PW_MINMAX
 * @param bf_value new value for RAMP1_PW_MINMAX.RAMP1_PW_MIN
 * @return new value of PWM.RAMP1_PW_MINMAX
 */
__PWM_INLINE uint32_t PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Msk);
    reg = (reg | (PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__EXTRACT() extracts RAMP1_PW_MINMAX.RAMP1_PW_MIN.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP1_PW_MINMAX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP1_PW_MINMAX
 * @return current value of RAMP1_PW_MINMAX.RAMP1_PW_MIN
 */
__PWM_INLINE uint32_t PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Msk);
    reg = (reg >> PWM_RAMP1_PW_MINMAX__RAMP1_PW_MIN__Pos);
    return (uint32_t)reg;
}

/* -------------------- PWM.RAMP1_PW_MINMAX.RAMP1_DC_MAX -------------------- */

/**
<pre>
  PWM.RAMP1_PW_MINMAX.RAMP1_DC_MAX:

    PWM Ramp 1 max duty cycle (absolute).  See ramp1_dc_max_nom description for scaled max duty cycle information.
    Computed from PMBus as follows:
    <start table>
    "ramp1_dc_max(U7.1) = MAX_DUTY(U7.1)"
    <end table>
    LSB = 0.5%, Range = 0.0 to 99.5%

</pre> */

#define PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Pos                  0                                                                      /*!< Right-most bit position of ramp1_dc_max in PWM.RAMP1_PW_MINMAX */
#define PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Msk                  (0x000000FFUL << PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Pos)               /*!< Mask for ramp1_dc_max in PWM.RAMP1_PW_MINMAX */
#define PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Shift(v)             (((v) << PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Pos) & PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Msk) /*!< Shift value 'v' into ramp1_dc_max and mask 'v' to fit it into ramp1_dc_max field */

/** PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__SET() sets RAMP1_PW_MINMAX.RAMP1_DC_MAX to given value.
 *
 * When writing to RAMP1_PW_MINMAX.RAMP1_DC_MAX, this is recommended to use.
 *
 * @param bf_value new value for RAMP1_PW_MINMAX.RAMP1_DC_MAX
 */
__PWM_INLINE void PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP1_PW_MINMAX__GET();
    reg = (reg & ~PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Msk);
    reg = (reg | (PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Shift((uint32_t)bf_value)));
    PWM_RAMP1_PW_MINMAX__SET(reg);
}

/** PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__GET() gets RAMP1_PW_MINMAX.RAMP1_DC_MAX's current value.
 *
 * When reading from RAMP1_PW_MINMAX.RAMP1_DC_MAX, this is recommended to use.
 *
 * @return current value of RAMP1_PW_MINMAX.RAMP1_DC_MAX
 */
__PWM_INLINE uint32_t PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__GET(void)
{
    uint32_t reg = PWM_RAMP1_PW_MINMAX__GET();
    reg = (reg & PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Msk);
    reg = (reg >> PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__MODIFY() modifies RAMP1_PW_MINMAX.RAMP1_DC_MAX.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP1_PW_MINMAX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP1_PW_MINMAX
 * @param bf_value new value for RAMP1_PW_MINMAX.RAMP1_DC_MAX
 * @return new value of PWM.RAMP1_PW_MINMAX
 */
__PWM_INLINE uint32_t PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Msk);
    reg = (reg | (PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__EXTRACT() extracts RAMP1_PW_MINMAX.RAMP1_DC_MAX.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP1_PW_MINMAX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP1_PW_MINMAX
 * @return current value of RAMP1_PW_MINMAX.RAMP1_DC_MAX
 */
__PWM_INLINE uint32_t PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Msk);
    reg = (reg >> PWM_RAMP1_PW_MINMAX__RAMP1_DC_MAX__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      RAMP1_FORCE_DUTY member of PWM_t                      */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP1_FORCE_DUTY__ADDRESS returns the address of member RAMP1_FORCE_DUTY.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP1_FORCE_DUTY
 */
__PWM_INLINE uint32_t* __PWM_RAMP1_FORCE_DUTY__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP1_FORCE_DUTY)));
}

/** PWM_RAMP1_FORCE_DUTY__SET() sets RAMP1_FORCE_DUTY to given value.
 *
 * When writing to RAMP1_FORCE_DUTY, this is mandatory to use.
 *
 * @param value new value for RAMP1_FORCE_DUTY
 */
__PWM_INLINE void PWM_RAMP1_FORCE_DUTY__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP1_FORCE_DUTY__ADDRESS(), value);
}

/** PWM_RAMP1_FORCE_DUTY__GET() gets RAMP1_FORCE_DUTY's current value.
 *
 * When reading from RAMP1_FORCE_DUTY, this is mandatory to use.
 *
 * @return current value of RAMP1_FORCE_DUTY
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_DUTY__GET(void)
{
    return HAL_GET32(__PWM_RAMP1_FORCE_DUTY__ADDRESS());
}

/* ---------------- PWM.RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN ---------------- */

/**
<pre>
  PWM.RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN:

    PWM Ramp 1 forced duty cycle select.
    <start table>
    0 "use PID computed Duty Cycle"
    1 "use ramp1_force_duty"
    <end table>

</pre> */

#define PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Pos          8                                                                      /*!< Right-most bit position of ramp1_force_duty_en in PWM.RAMP1_FORCE_DUTY */
#define PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Msk          (0x00000001UL << PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Pos)       /*!< Mask for ramp1_force_duty_en in PWM.RAMP1_FORCE_DUTY */
#define PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Shift(v)     (((v) << PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Pos) & PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Msk) /*!< Shift value 'v' into ramp1_force_duty_en and mask 'v' to fit it into ramp1_force_duty_en field */

/** PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__SET() sets RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN to given value.
 *
 * When writing to RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN, this is recommended to use.
 *
 * @param bf_value new value for RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN
 */
__PWM_INLINE void PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP1_FORCE_DUTY__GET();
    reg = (reg & ~PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Shift((uint32_t)bf_value)));
    PWM_RAMP1_FORCE_DUTY__SET(reg);
}

/** PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__GET() gets RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN's current value.
 *
 * When reading from RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN, this is recommended to use.
 *
 * @return current value of RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__GET(void)
{
    uint32_t reg = PWM_RAMP1_FORCE_DUTY__GET();
    reg = (reg & PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__MODIFY() modifies RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP1_FORCE_DUTY.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP1_FORCE_DUTY
 * @param bf_value new value for RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN
 * @return new value of PWM.RAMP1_FORCE_DUTY
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__EXTRACT() extracts RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP1_FORCE_DUTY.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP1_FORCE_DUTY
 * @return current value of RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY_EN
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------- PWM.RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY ----------------- */

/**
<pre>
  PWM.RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY:

    Forced duty cycle value overrides ramp 1 input when selected by ramp1_force_duty_en.  Since this force is applied at the ramp input, upstream adjustments to the duty cycle such as current balance in an interleaved (multi-phase) design are overwritten.  To not override the current balance adjust use pid0.pid_force_duty or pid1.pid_force_duty which apply the force prior to downstream adjustments.
    LSB = 0.3906%, Range = 0.0 to 99.6094%

</pre> */

#define PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Pos             0                                                                      /*!< Right-most bit position of ramp1_force_duty in PWM.RAMP1_FORCE_DUTY */
#define PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Msk             (0x000000FFUL << PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Pos)          /*!< Mask for ramp1_force_duty in PWM.RAMP1_FORCE_DUTY */
#define PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Shift(v)        (((v) << PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Pos) & PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Msk) /*!< Shift value 'v' into ramp1_force_duty and mask 'v' to fit it into ramp1_force_duty field */

/** PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__SET() sets RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY to given value.
 *
 * When writing to RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY, this is recommended to use.
 *
 * @param bf_value new value for RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY
 */
__PWM_INLINE void PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP1_FORCE_DUTY__GET();
    reg = (reg & ~PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Shift((uint32_t)bf_value)));
    PWM_RAMP1_FORCE_DUTY__SET(reg);
}

/** PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__GET() gets RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY's current value.
 *
 * When reading from RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY, this is recommended to use.
 *
 * @return current value of RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__GET(void)
{
    uint32_t reg = PWM_RAMP1_FORCE_DUTY__GET();
    reg = (reg & PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__MODIFY() modifies RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP1_FORCE_DUTY.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP1_FORCE_DUTY
 * @param bf_value new value for RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY
 * @return new value of PWM.RAMP1_FORCE_DUTY
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__EXTRACT() extracts RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP1_FORCE_DUTY.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP1_FORCE_DUTY
 * @return current value of RAMP1_FORCE_DUTY.RAMP1_FORCE_DUTY
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_DUTY__RAMP1_FORCE_DUTY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       RAMP1_FORCE_T1 member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP1_FORCE_T1__ADDRESS returns the address of member RAMP1_FORCE_T1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP1_FORCE_T1
 */
__PWM_INLINE uint32_t* __PWM_RAMP1_FORCE_T1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP1_FORCE_T1)));
}

/** PWM_RAMP1_FORCE_T1__SET() sets RAMP1_FORCE_T1 to given value.
 *
 * When writing to RAMP1_FORCE_T1, this is mandatory to use.
 *
 * @param value new value for RAMP1_FORCE_T1
 */
__PWM_INLINE void PWM_RAMP1_FORCE_T1__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP1_FORCE_T1__ADDRESS(), value);
}

/** PWM_RAMP1_FORCE_T1__GET() gets RAMP1_FORCE_T1's current value.
 *
 * When reading from RAMP1_FORCE_T1, this is mandatory to use.
 *
 * @return current value of RAMP1_FORCE_T1
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T1__GET(void)
{
    return HAL_GET32(__PWM_RAMP1_FORCE_T1__ADDRESS());
}

/* ------------------ PWM.RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN ------------------ */

/**
<pre>
  PWM.RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN:

    PWM Ramp 1 T1 force enable.
    <start table>
    0 "T1 determined by modulation scheme and duty cycle"
    1 "T1 set by ramp1_force_t1"
    <end table>

</pre> */

#define PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Pos              11                                                                     /*!< Right-most bit position of ramp1_force_t1_en in PWM.RAMP1_FORCE_T1 */
#define PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Msk              (0x00000001UL << PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Pos)           /*!< Mask for ramp1_force_t1_en in PWM.RAMP1_FORCE_T1 */
#define PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Shift(v)         (((v) << PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Pos) & PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Msk) /*!< Shift value 'v' into ramp1_force_t1_en and mask 'v' to fit it into ramp1_force_t1_en field */

/** PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__SET() sets RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN to given value.
 *
 * When writing to RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN, this is recommended to use.
 *
 * @param bf_value new value for RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN
 */
__PWM_INLINE void PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP1_FORCE_T1__GET();
    reg = (reg & ~PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Shift((uint32_t)bf_value)));
    PWM_RAMP1_FORCE_T1__SET(reg);
}

/** PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__GET() gets RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN's current value.
 *
 * When reading from RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN, this is recommended to use.
 *
 * @return current value of RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__GET(void)
{
    uint32_t reg = PWM_RAMP1_FORCE_T1__GET();
    reg = (reg & PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__MODIFY() modifies RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP1_FORCE_T1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP1_FORCE_T1
 * @param bf_value new value for RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN
 * @return new value of PWM.RAMP1_FORCE_T1
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__EXTRACT() extracts RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP1_FORCE_T1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP1_FORCE_T1
 * @return current value of RAMP1_FORCE_T1.RAMP1_FORCE_T1_EN
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- PWM.RAMP1_FORCE_T1.RAMP1_FORCE_T1 ------------------- */

/**
<pre>
  PWM.RAMP1_FORCE_T1.RAMP1_FORCE_T1:

    PWM Ramp 1 forced T1 setting selected by ramp1_force_t1_en.  T1 is the time of the first PWM "edge" in a ramp cycle.  In a trailing edge modulation scheme T1 is fixed at 0.  In the leading and dual edge modulation schemes T1 is determined based on the duty cycle.
    LSB = 5ns, Range = 0 to 10235ns

</pre> */

#define PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Pos                 0                                                                      /*!< Right-most bit position of ramp1_force_t1 in PWM.RAMP1_FORCE_T1 */
#define PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Msk                 (0x000007FFUL << PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Pos)              /*!< Mask for ramp1_force_t1 in PWM.RAMP1_FORCE_T1 */
#define PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Shift(v)            (((v) << PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Pos) & PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Msk) /*!< Shift value 'v' into ramp1_force_t1 and mask 'v' to fit it into ramp1_force_t1 field */

/** PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__SET() sets RAMP1_FORCE_T1.RAMP1_FORCE_T1 to given value.
 *
 * When writing to RAMP1_FORCE_T1.RAMP1_FORCE_T1, this is recommended to use.
 *
 * @param bf_value new value for RAMP1_FORCE_T1.RAMP1_FORCE_T1
 */
__PWM_INLINE void PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP1_FORCE_T1__GET();
    reg = (reg & ~PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Shift((uint32_t)bf_value)));
    PWM_RAMP1_FORCE_T1__SET(reg);
}

/** PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__GET() gets RAMP1_FORCE_T1.RAMP1_FORCE_T1's current value.
 *
 * When reading from RAMP1_FORCE_T1.RAMP1_FORCE_T1, this is recommended to use.
 *
 * @return current value of RAMP1_FORCE_T1.RAMP1_FORCE_T1
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__GET(void)
{
    uint32_t reg = PWM_RAMP1_FORCE_T1__GET();
    reg = (reg & PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__MODIFY() modifies RAMP1_FORCE_T1.RAMP1_FORCE_T1.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP1_FORCE_T1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP1_FORCE_T1
 * @param bf_value new value for RAMP1_FORCE_T1.RAMP1_FORCE_T1
 * @return new value of PWM.RAMP1_FORCE_T1
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__EXTRACT() extracts RAMP1_FORCE_T1.RAMP1_FORCE_T1.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP1_FORCE_T1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP1_FORCE_T1
 * @return current value of RAMP1_FORCE_T1.RAMP1_FORCE_T1
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_T1__RAMP1_FORCE_T1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       RAMP1_FORCE_T2 member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP1_FORCE_T2__ADDRESS returns the address of member RAMP1_FORCE_T2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP1_FORCE_T2
 */
__PWM_INLINE uint32_t* __PWM_RAMP1_FORCE_T2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP1_FORCE_T2)));
}

/** PWM_RAMP1_FORCE_T2__SET() sets RAMP1_FORCE_T2 to given value.
 *
 * When writing to RAMP1_FORCE_T2, this is mandatory to use.
 *
 * @param value new value for RAMP1_FORCE_T2
 */
__PWM_INLINE void PWM_RAMP1_FORCE_T2__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP1_FORCE_T2__ADDRESS(), value);
}

/** PWM_RAMP1_FORCE_T2__GET() gets RAMP1_FORCE_T2's current value.
 *
 * When reading from RAMP1_FORCE_T2, this is mandatory to use.
 *
 * @return current value of RAMP1_FORCE_T2
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T2__GET(void)
{
    return HAL_GET32(__PWM_RAMP1_FORCE_T2__ADDRESS());
}

/* ------------------ PWM.RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN ------------------ */

/**
<pre>
  PWM.RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN:

    PWM Ramp 1 T2 force enable.
    <start table>
    0 "T2 determined by modulation scheme and duty cycle"
    1 "T2 set by ramp1_force_t2"
    <end table>

</pre> */

#define PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Pos              11                                                                     /*!< Right-most bit position of ramp1_force_t2_en in PWM.RAMP1_FORCE_T2 */
#define PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Msk              (0x00000001UL << PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Pos)           /*!< Mask for ramp1_force_t2_en in PWM.RAMP1_FORCE_T2 */
#define PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Shift(v)         (((v) << PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Pos) & PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Msk) /*!< Shift value 'v' into ramp1_force_t2_en and mask 'v' to fit it into ramp1_force_t2_en field */

/** PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__SET() sets RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN to given value.
 *
 * When writing to RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN, this is recommended to use.
 *
 * @param bf_value new value for RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN
 */
__PWM_INLINE void PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP1_FORCE_T2__GET();
    reg = (reg & ~PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Shift((uint32_t)bf_value)));
    PWM_RAMP1_FORCE_T2__SET(reg);
}

/** PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__GET() gets RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN's current value.
 *
 * When reading from RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN, this is recommended to use.
 *
 * @return current value of RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__GET(void)
{
    uint32_t reg = PWM_RAMP1_FORCE_T2__GET();
    reg = (reg & PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__MODIFY() modifies RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP1_FORCE_T2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP1_FORCE_T2
 * @param bf_value new value for RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN
 * @return new value of PWM.RAMP1_FORCE_T2
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__EXTRACT() extracts RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP1_FORCE_T2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP1_FORCE_T2
 * @return current value of RAMP1_FORCE_T2.RAMP1_FORCE_T2_EN
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- PWM.RAMP1_FORCE_T2.RAMP1_FORCE_T2 ------------------- */

/**
<pre>
  PWM.RAMP1_FORCE_T2.RAMP1_FORCE_T2:

    PWM Ramp 1 forced T2 setting selected by ramp1_force_t2_en.  T2 is the time of the second PWM "edge" in a ramp cycle.  In a leading edge modulation scheme T1 is fixed at Tswitch (or Tswitch/2 in bridge topologies).  In the trailing and dual edge modulation schemes T2 is determined based on the duty cycle.
    LSB = 5ns, Range = 0 to 10235ns

</pre> */

#define PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Pos                 0                                                                      /*!< Right-most bit position of ramp1_force_t2 in PWM.RAMP1_FORCE_T2 */
#define PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Msk                 (0x000007FFUL << PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Pos)              /*!< Mask for ramp1_force_t2 in PWM.RAMP1_FORCE_T2 */
#define PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Shift(v)            (((v) << PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Pos) & PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Msk) /*!< Shift value 'v' into ramp1_force_t2 and mask 'v' to fit it into ramp1_force_t2 field */

/** PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__SET() sets RAMP1_FORCE_T2.RAMP1_FORCE_T2 to given value.
 *
 * When writing to RAMP1_FORCE_T2.RAMP1_FORCE_T2, this is recommended to use.
 *
 * @param bf_value new value for RAMP1_FORCE_T2.RAMP1_FORCE_T2
 */
__PWM_INLINE void PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP1_FORCE_T2__GET();
    reg = (reg & ~PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Shift((uint32_t)bf_value)));
    PWM_RAMP1_FORCE_T2__SET(reg);
}

/** PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__GET() gets RAMP1_FORCE_T2.RAMP1_FORCE_T2's current value.
 *
 * When reading from RAMP1_FORCE_T2.RAMP1_FORCE_T2, this is recommended to use.
 *
 * @return current value of RAMP1_FORCE_T2.RAMP1_FORCE_T2
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__GET(void)
{
    uint32_t reg = PWM_RAMP1_FORCE_T2__GET();
    reg = (reg & PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__MODIFY() modifies RAMP1_FORCE_T2.RAMP1_FORCE_T2.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP1_FORCE_T2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP1_FORCE_T2
 * @param bf_value new value for RAMP1_FORCE_T2.RAMP1_FORCE_T2
 * @return new value of PWM.RAMP1_FORCE_T2
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Msk);
    reg = (reg | (PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__EXTRACT() extracts RAMP1_FORCE_T2.RAMP1_FORCE_T2.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP1_FORCE_T2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP1_FORCE_T2
 * @return current value of RAMP1_FORCE_T2.RAMP1_FORCE_T2
 */
__PWM_INLINE uint32_t PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Msk);
    reg = (reg >> PWM_RAMP1_FORCE_T2__RAMP1_FORCE_T2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM1_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM1_DEADTIME__ADDRESS returns the address of member PWM1_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM1_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM1_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM1_DEADTIME)));
}

/** PWM_PWM1_DEADTIME__SET() sets PWM1_DEADTIME to given value.
 *
 * When writing to PWM1_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM1_DEADTIME
 */
__PWM_INLINE void PWM_PWM1_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM1_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM1_DEADTIME__GET() gets PWM1_DEADTIME's current value.
 *
 * When reading from PWM1_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM1_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM1_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM1_DEADTIME__ADDRESS());
}

/* ----------------------- PWM.PWM1_DEADTIME.PWM1_DF ----------------------- */

/**
<pre>
  PWM.PWM1_DEADTIME.PWM1_DF:

    PWM1 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm1_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm1_df[7:0] = PWM_DEADTIME[7:0]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM1_DEADTIME__PWM1_DF__Pos                         8                                                                      /*!< Right-most bit position of pwm1_df in PWM.PWM1_DEADTIME */
#define PWM_PWM1_DEADTIME__PWM1_DF__Msk                         (0x000000FFUL << PWM_PWM1_DEADTIME__PWM1_DF__Pos)                      /*!< Mask for pwm1_df in PWM.PWM1_DEADTIME */
#define PWM_PWM1_DEADTIME__PWM1_DF__Shift(v)                    (((v) << PWM_PWM1_DEADTIME__PWM1_DF__Pos) & PWM_PWM1_DEADTIME__PWM1_DF__Msk) /*!< Shift value 'v' into pwm1_df and mask 'v' to fit it into pwm1_df field */

/** PWM_PWM1_DEADTIME__PWM1_DF__SET() sets PWM1_DEADTIME.PWM1_DF to given value.
 *
 * When writing to PWM1_DEADTIME.PWM1_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM1_DEADTIME.PWM1_DF
 */
__PWM_INLINE void PWM_PWM1_DEADTIME__PWM1_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM1_DEADTIME__GET();
    reg = (reg & ~PWM_PWM1_DEADTIME__PWM1_DF__Msk);
    reg = (reg | (PWM_PWM1_DEADTIME__PWM1_DF__Shift((uint32_t)bf_value)));
    PWM_PWM1_DEADTIME__SET(reg);
}

/** PWM_PWM1_DEADTIME__PWM1_DF__GET() gets PWM1_DEADTIME.PWM1_DF's current value.
 *
 * When reading from PWM1_DEADTIME.PWM1_DF, this is recommended to use.
 *
 * @return current value of PWM1_DEADTIME.PWM1_DF
 */
__PWM_INLINE uint32_t PWM_PWM1_DEADTIME__PWM1_DF__GET(void)
{
    uint32_t reg = PWM_PWM1_DEADTIME__GET();
    reg = (reg & PWM_PWM1_DEADTIME__PWM1_DF__Msk);
    reg = (reg >> PWM_PWM1_DEADTIME__PWM1_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM1_DEADTIME__PWM1_DF__MODIFY() modifies PWM1_DEADTIME.PWM1_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM1_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM1_DEADTIME
 * @param bf_value new value for PWM1_DEADTIME.PWM1_DF
 * @return new value of PWM.PWM1_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM1_DEADTIME__PWM1_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM1_DEADTIME__PWM1_DF__Msk);
    reg = (reg | (PWM_PWM1_DEADTIME__PWM1_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM1_DEADTIME__PWM1_DF__EXTRACT() extracts PWM1_DEADTIME.PWM1_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM1_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM1_DEADTIME
 * @return current value of PWM1_DEADTIME.PWM1_DF
 */
__PWM_INLINE uint32_t PWM_PWM1_DEADTIME__PWM1_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM1_DEADTIME__PWM1_DF__Msk);
    reg = (reg >> PWM_PWM1_DEADTIME__PWM1_DF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM1_DEADTIME.PWM1_DR ----------------------- */

/**
<pre>
  PWM.PWM1_DEADTIME.PWM1_DR:

    PWM1 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm1_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm1_dr[7:0] = PWM_DEADTIME[15:8]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM1_DEADTIME__PWM1_DR__Pos                         0                                                                      /*!< Right-most bit position of pwm1_dr in PWM.PWM1_DEADTIME */
#define PWM_PWM1_DEADTIME__PWM1_DR__Msk                         (0x000000FFUL << PWM_PWM1_DEADTIME__PWM1_DR__Pos)                      /*!< Mask for pwm1_dr in PWM.PWM1_DEADTIME */
#define PWM_PWM1_DEADTIME__PWM1_DR__Shift(v)                    (((v) << PWM_PWM1_DEADTIME__PWM1_DR__Pos) & PWM_PWM1_DEADTIME__PWM1_DR__Msk) /*!< Shift value 'v' into pwm1_dr and mask 'v' to fit it into pwm1_dr field */

/** PWM_PWM1_DEADTIME__PWM1_DR__SET() sets PWM1_DEADTIME.PWM1_DR to given value.
 *
 * When writing to PWM1_DEADTIME.PWM1_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM1_DEADTIME.PWM1_DR
 */
__PWM_INLINE void PWM_PWM1_DEADTIME__PWM1_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM1_DEADTIME__GET();
    reg = (reg & ~PWM_PWM1_DEADTIME__PWM1_DR__Msk);
    reg = (reg | (PWM_PWM1_DEADTIME__PWM1_DR__Shift((uint32_t)bf_value)));
    PWM_PWM1_DEADTIME__SET(reg);
}

/** PWM_PWM1_DEADTIME__PWM1_DR__GET() gets PWM1_DEADTIME.PWM1_DR's current value.
 *
 * When reading from PWM1_DEADTIME.PWM1_DR, this is recommended to use.
 *
 * @return current value of PWM1_DEADTIME.PWM1_DR
 */
__PWM_INLINE uint32_t PWM_PWM1_DEADTIME__PWM1_DR__GET(void)
{
    uint32_t reg = PWM_PWM1_DEADTIME__GET();
    reg = (reg & PWM_PWM1_DEADTIME__PWM1_DR__Msk);
    reg = (reg >> PWM_PWM1_DEADTIME__PWM1_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM1_DEADTIME__PWM1_DR__MODIFY() modifies PWM1_DEADTIME.PWM1_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM1_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM1_DEADTIME
 * @param bf_value new value for PWM1_DEADTIME.PWM1_DR
 * @return new value of PWM.PWM1_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM1_DEADTIME__PWM1_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM1_DEADTIME__PWM1_DR__Msk);
    reg = (reg | (PWM_PWM1_DEADTIME__PWM1_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM1_DEADTIME__PWM1_DR__EXTRACT() extracts PWM1_DEADTIME.PWM1_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM1_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM1_DEADTIME
 * @return current value of PWM1_DEADTIME.PWM1_DR
 */
__PWM_INLINE uint32_t PWM_PWM1_DEADTIME__PWM1_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM1_DEADTIME__PWM1_DR__Msk);
    reg = (reg >> PWM_PWM1_DEADTIME__PWM1_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM2_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM2_DEADTIME__ADDRESS returns the address of member PWM2_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM2_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM2_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM2_DEADTIME)));
}

/** PWM_PWM2_DEADTIME__SET() sets PWM2_DEADTIME to given value.
 *
 * When writing to PWM2_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM2_DEADTIME
 */
__PWM_INLINE void PWM_PWM2_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM2_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM2_DEADTIME__GET() gets PWM2_DEADTIME's current value.
 *
 * When reading from PWM2_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM2_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM2_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM2_DEADTIME__ADDRESS());
}

/* ----------------------- PWM.PWM2_DEADTIME.PWM2_DF ----------------------- */

/**
<pre>
  PWM.PWM2_DEADTIME.PWM2_DF:

    PWM2 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm2_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm2_df[7:0] = PWM_DEADTIME[23:16]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM2_DEADTIME__PWM2_DF__Pos                         8                                                                      /*!< Right-most bit position of pwm2_df in PWM.PWM2_DEADTIME */
#define PWM_PWM2_DEADTIME__PWM2_DF__Msk                         (0x000000FFUL << PWM_PWM2_DEADTIME__PWM2_DF__Pos)                      /*!< Mask for pwm2_df in PWM.PWM2_DEADTIME */
#define PWM_PWM2_DEADTIME__PWM2_DF__Shift(v)                    (((v) << PWM_PWM2_DEADTIME__PWM2_DF__Pos) & PWM_PWM2_DEADTIME__PWM2_DF__Msk) /*!< Shift value 'v' into pwm2_df and mask 'v' to fit it into pwm2_df field */

/** PWM_PWM2_DEADTIME__PWM2_DF__SET() sets PWM2_DEADTIME.PWM2_DF to given value.
 *
 * When writing to PWM2_DEADTIME.PWM2_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM2_DEADTIME.PWM2_DF
 */
__PWM_INLINE void PWM_PWM2_DEADTIME__PWM2_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM2_DEADTIME__GET();
    reg = (reg & ~PWM_PWM2_DEADTIME__PWM2_DF__Msk);
    reg = (reg | (PWM_PWM2_DEADTIME__PWM2_DF__Shift((uint32_t)bf_value)));
    PWM_PWM2_DEADTIME__SET(reg);
}

/** PWM_PWM2_DEADTIME__PWM2_DF__GET() gets PWM2_DEADTIME.PWM2_DF's current value.
 *
 * When reading from PWM2_DEADTIME.PWM2_DF, this is recommended to use.
 *
 * @return current value of PWM2_DEADTIME.PWM2_DF
 */
__PWM_INLINE uint32_t PWM_PWM2_DEADTIME__PWM2_DF__GET(void)
{
    uint32_t reg = PWM_PWM2_DEADTIME__GET();
    reg = (reg & PWM_PWM2_DEADTIME__PWM2_DF__Msk);
    reg = (reg >> PWM_PWM2_DEADTIME__PWM2_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM2_DEADTIME__PWM2_DF__MODIFY() modifies PWM2_DEADTIME.PWM2_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM2_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM2_DEADTIME
 * @param bf_value new value for PWM2_DEADTIME.PWM2_DF
 * @return new value of PWM.PWM2_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM2_DEADTIME__PWM2_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM2_DEADTIME__PWM2_DF__Msk);
    reg = (reg | (PWM_PWM2_DEADTIME__PWM2_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM2_DEADTIME__PWM2_DF__EXTRACT() extracts PWM2_DEADTIME.PWM2_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM2_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM2_DEADTIME
 * @return current value of PWM2_DEADTIME.PWM2_DF
 */
__PWM_INLINE uint32_t PWM_PWM2_DEADTIME__PWM2_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM2_DEADTIME__PWM2_DF__Msk);
    reg = (reg >> PWM_PWM2_DEADTIME__PWM2_DF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM2_DEADTIME.PWM2_DR ----------------------- */

/**
<pre>
  PWM.PWM2_DEADTIME.PWM2_DR:

    PWM2 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm2_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm2_dr[7:0] = PWM_DEADTIME[31:24]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM2_DEADTIME__PWM2_DR__Pos                         0                                                                      /*!< Right-most bit position of pwm2_dr in PWM.PWM2_DEADTIME */
#define PWM_PWM2_DEADTIME__PWM2_DR__Msk                         (0x000000FFUL << PWM_PWM2_DEADTIME__PWM2_DR__Pos)                      /*!< Mask for pwm2_dr in PWM.PWM2_DEADTIME */
#define PWM_PWM2_DEADTIME__PWM2_DR__Shift(v)                    (((v) << PWM_PWM2_DEADTIME__PWM2_DR__Pos) & PWM_PWM2_DEADTIME__PWM2_DR__Msk) /*!< Shift value 'v' into pwm2_dr and mask 'v' to fit it into pwm2_dr field */

/** PWM_PWM2_DEADTIME__PWM2_DR__SET() sets PWM2_DEADTIME.PWM2_DR to given value.
 *
 * When writing to PWM2_DEADTIME.PWM2_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM2_DEADTIME.PWM2_DR
 */
__PWM_INLINE void PWM_PWM2_DEADTIME__PWM2_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM2_DEADTIME__GET();
    reg = (reg & ~PWM_PWM2_DEADTIME__PWM2_DR__Msk);
    reg = (reg | (PWM_PWM2_DEADTIME__PWM2_DR__Shift((uint32_t)bf_value)));
    PWM_PWM2_DEADTIME__SET(reg);
}

/** PWM_PWM2_DEADTIME__PWM2_DR__GET() gets PWM2_DEADTIME.PWM2_DR's current value.
 *
 * When reading from PWM2_DEADTIME.PWM2_DR, this is recommended to use.
 *
 * @return current value of PWM2_DEADTIME.PWM2_DR
 */
__PWM_INLINE uint32_t PWM_PWM2_DEADTIME__PWM2_DR__GET(void)
{
    uint32_t reg = PWM_PWM2_DEADTIME__GET();
    reg = (reg & PWM_PWM2_DEADTIME__PWM2_DR__Msk);
    reg = (reg >> PWM_PWM2_DEADTIME__PWM2_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM2_DEADTIME__PWM2_DR__MODIFY() modifies PWM2_DEADTIME.PWM2_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM2_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM2_DEADTIME
 * @param bf_value new value for PWM2_DEADTIME.PWM2_DR
 * @return new value of PWM.PWM2_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM2_DEADTIME__PWM2_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM2_DEADTIME__PWM2_DR__Msk);
    reg = (reg | (PWM_PWM2_DEADTIME__PWM2_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM2_DEADTIME__PWM2_DR__EXTRACT() extracts PWM2_DEADTIME.PWM2_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM2_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM2_DEADTIME
 * @return current value of PWM2_DEADTIME.PWM2_DR
 */
__PWM_INLINE uint32_t PWM_PWM2_DEADTIME__PWM2_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM2_DEADTIME__PWM2_DR__Msk);
    reg = (reg >> PWM_PWM2_DEADTIME__PWM2_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM3_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM3_DEADTIME__ADDRESS returns the address of member PWM3_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM3_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM3_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM3_DEADTIME)));
}

/** PWM_PWM3_DEADTIME__SET() sets PWM3_DEADTIME to given value.
 *
 * When writing to PWM3_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM3_DEADTIME
 */
__PWM_INLINE void PWM_PWM3_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM3_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM3_DEADTIME__GET() gets PWM3_DEADTIME's current value.
 *
 * When reading from PWM3_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM3_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM3_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM3_DEADTIME__ADDRESS());
}

/* ----------------------- PWM.PWM3_DEADTIME.PWM3_DF ----------------------- */

/**
<pre>
  PWM.PWM3_DEADTIME.PWM3_DF:

    PWM3 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm3_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm3_df[7:0] = PWM_DEADTIME[39:32]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM3_DEADTIME__PWM3_DF__Pos                         8                                                                      /*!< Right-most bit position of pwm3_df in PWM.PWM3_DEADTIME */
#define PWM_PWM3_DEADTIME__PWM3_DF__Msk                         (0x000000FFUL << PWM_PWM3_DEADTIME__PWM3_DF__Pos)                      /*!< Mask for pwm3_df in PWM.PWM3_DEADTIME */
#define PWM_PWM3_DEADTIME__PWM3_DF__Shift(v)                    (((v) << PWM_PWM3_DEADTIME__PWM3_DF__Pos) & PWM_PWM3_DEADTIME__PWM3_DF__Msk) /*!< Shift value 'v' into pwm3_df and mask 'v' to fit it into pwm3_df field */

/** PWM_PWM3_DEADTIME__PWM3_DF__SET() sets PWM3_DEADTIME.PWM3_DF to given value.
 *
 * When writing to PWM3_DEADTIME.PWM3_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM3_DEADTIME.PWM3_DF
 */
__PWM_INLINE void PWM_PWM3_DEADTIME__PWM3_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM3_DEADTIME__GET();
    reg = (reg & ~PWM_PWM3_DEADTIME__PWM3_DF__Msk);
    reg = (reg | (PWM_PWM3_DEADTIME__PWM3_DF__Shift((uint32_t)bf_value)));
    PWM_PWM3_DEADTIME__SET(reg);
}

/** PWM_PWM3_DEADTIME__PWM3_DF__GET() gets PWM3_DEADTIME.PWM3_DF's current value.
 *
 * When reading from PWM3_DEADTIME.PWM3_DF, this is recommended to use.
 *
 * @return current value of PWM3_DEADTIME.PWM3_DF
 */
__PWM_INLINE uint32_t PWM_PWM3_DEADTIME__PWM3_DF__GET(void)
{
    uint32_t reg = PWM_PWM3_DEADTIME__GET();
    reg = (reg & PWM_PWM3_DEADTIME__PWM3_DF__Msk);
    reg = (reg >> PWM_PWM3_DEADTIME__PWM3_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM3_DEADTIME__PWM3_DF__MODIFY() modifies PWM3_DEADTIME.PWM3_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM3_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM3_DEADTIME
 * @param bf_value new value for PWM3_DEADTIME.PWM3_DF
 * @return new value of PWM.PWM3_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM3_DEADTIME__PWM3_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM3_DEADTIME__PWM3_DF__Msk);
    reg = (reg | (PWM_PWM3_DEADTIME__PWM3_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM3_DEADTIME__PWM3_DF__EXTRACT() extracts PWM3_DEADTIME.PWM3_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM3_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM3_DEADTIME
 * @return current value of PWM3_DEADTIME.PWM3_DF
 */
__PWM_INLINE uint32_t PWM_PWM3_DEADTIME__PWM3_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM3_DEADTIME__PWM3_DF__Msk);
    reg = (reg >> PWM_PWM3_DEADTIME__PWM3_DF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM3_DEADTIME.PWM3_DR ----------------------- */

/**
<pre>
  PWM.PWM3_DEADTIME.PWM3_DR:

    PWM3 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm3_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm3_dr[7:0] = PWM_DEADTIME[47:40]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM3_DEADTIME__PWM3_DR__Pos                         0                                                                      /*!< Right-most bit position of pwm3_dr in PWM.PWM3_DEADTIME */
#define PWM_PWM3_DEADTIME__PWM3_DR__Msk                         (0x000000FFUL << PWM_PWM3_DEADTIME__PWM3_DR__Pos)                      /*!< Mask for pwm3_dr in PWM.PWM3_DEADTIME */
#define PWM_PWM3_DEADTIME__PWM3_DR__Shift(v)                    (((v) << PWM_PWM3_DEADTIME__PWM3_DR__Pos) & PWM_PWM3_DEADTIME__PWM3_DR__Msk) /*!< Shift value 'v' into pwm3_dr and mask 'v' to fit it into pwm3_dr field */

/** PWM_PWM3_DEADTIME__PWM3_DR__SET() sets PWM3_DEADTIME.PWM3_DR to given value.
 *
 * When writing to PWM3_DEADTIME.PWM3_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM3_DEADTIME.PWM3_DR
 */
__PWM_INLINE void PWM_PWM3_DEADTIME__PWM3_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM3_DEADTIME__GET();
    reg = (reg & ~PWM_PWM3_DEADTIME__PWM3_DR__Msk);
    reg = (reg | (PWM_PWM3_DEADTIME__PWM3_DR__Shift((uint32_t)bf_value)));
    PWM_PWM3_DEADTIME__SET(reg);
}

/** PWM_PWM3_DEADTIME__PWM3_DR__GET() gets PWM3_DEADTIME.PWM3_DR's current value.
 *
 * When reading from PWM3_DEADTIME.PWM3_DR, this is recommended to use.
 *
 * @return current value of PWM3_DEADTIME.PWM3_DR
 */
__PWM_INLINE uint32_t PWM_PWM3_DEADTIME__PWM3_DR__GET(void)
{
    uint32_t reg = PWM_PWM3_DEADTIME__GET();
    reg = (reg & PWM_PWM3_DEADTIME__PWM3_DR__Msk);
    reg = (reg >> PWM_PWM3_DEADTIME__PWM3_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM3_DEADTIME__PWM3_DR__MODIFY() modifies PWM3_DEADTIME.PWM3_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM3_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM3_DEADTIME
 * @param bf_value new value for PWM3_DEADTIME.PWM3_DR
 * @return new value of PWM.PWM3_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM3_DEADTIME__PWM3_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM3_DEADTIME__PWM3_DR__Msk);
    reg = (reg | (PWM_PWM3_DEADTIME__PWM3_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM3_DEADTIME__PWM3_DR__EXTRACT() extracts PWM3_DEADTIME.PWM3_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM3_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM3_DEADTIME
 * @return current value of PWM3_DEADTIME.PWM3_DR
 */
__PWM_INLINE uint32_t PWM_PWM3_DEADTIME__PWM3_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM3_DEADTIME__PWM3_DR__Msk);
    reg = (reg >> PWM_PWM3_DEADTIME__PWM3_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM4_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM4_DEADTIME__ADDRESS returns the address of member PWM4_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM4_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM4_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM4_DEADTIME)));
}

/** PWM_PWM4_DEADTIME__SET() sets PWM4_DEADTIME to given value.
 *
 * When writing to PWM4_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM4_DEADTIME
 */
__PWM_INLINE void PWM_PWM4_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM4_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM4_DEADTIME__GET() gets PWM4_DEADTIME's current value.
 *
 * When reading from PWM4_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM4_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM4_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM4_DEADTIME__ADDRESS());
}

/* ----------------------- PWM.PWM4_DEADTIME.PWM4_DF ----------------------- */

/**
<pre>
  PWM.PWM4_DEADTIME.PWM4_DF:

    PWM4 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm4_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm4_df[7:0] = PWM_DEADTIME[55:48]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM4_DEADTIME__PWM4_DF__Pos                         8                                                                      /*!< Right-most bit position of pwm4_df in PWM.PWM4_DEADTIME */
#define PWM_PWM4_DEADTIME__PWM4_DF__Msk                         (0x000000FFUL << PWM_PWM4_DEADTIME__PWM4_DF__Pos)                      /*!< Mask for pwm4_df in PWM.PWM4_DEADTIME */
#define PWM_PWM4_DEADTIME__PWM4_DF__Shift(v)                    (((v) << PWM_PWM4_DEADTIME__PWM4_DF__Pos) & PWM_PWM4_DEADTIME__PWM4_DF__Msk) /*!< Shift value 'v' into pwm4_df and mask 'v' to fit it into pwm4_df field */

/** PWM_PWM4_DEADTIME__PWM4_DF__SET() sets PWM4_DEADTIME.PWM4_DF to given value.
 *
 * When writing to PWM4_DEADTIME.PWM4_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM4_DEADTIME.PWM4_DF
 */
__PWM_INLINE void PWM_PWM4_DEADTIME__PWM4_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM4_DEADTIME__GET();
    reg = (reg & ~PWM_PWM4_DEADTIME__PWM4_DF__Msk);
    reg = (reg | (PWM_PWM4_DEADTIME__PWM4_DF__Shift((uint32_t)bf_value)));
    PWM_PWM4_DEADTIME__SET(reg);
}

/** PWM_PWM4_DEADTIME__PWM4_DF__GET() gets PWM4_DEADTIME.PWM4_DF's current value.
 *
 * When reading from PWM4_DEADTIME.PWM4_DF, this is recommended to use.
 *
 * @return current value of PWM4_DEADTIME.PWM4_DF
 */
__PWM_INLINE uint32_t PWM_PWM4_DEADTIME__PWM4_DF__GET(void)
{
    uint32_t reg = PWM_PWM4_DEADTIME__GET();
    reg = (reg & PWM_PWM4_DEADTIME__PWM4_DF__Msk);
    reg = (reg >> PWM_PWM4_DEADTIME__PWM4_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM4_DEADTIME__PWM4_DF__MODIFY() modifies PWM4_DEADTIME.PWM4_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM4_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM4_DEADTIME
 * @param bf_value new value for PWM4_DEADTIME.PWM4_DF
 * @return new value of PWM.PWM4_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM4_DEADTIME__PWM4_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM4_DEADTIME__PWM4_DF__Msk);
    reg = (reg | (PWM_PWM4_DEADTIME__PWM4_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM4_DEADTIME__PWM4_DF__EXTRACT() extracts PWM4_DEADTIME.PWM4_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM4_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM4_DEADTIME
 * @return current value of PWM4_DEADTIME.PWM4_DF
 */
__PWM_INLINE uint32_t PWM_PWM4_DEADTIME__PWM4_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM4_DEADTIME__PWM4_DF__Msk);
    reg = (reg >> PWM_PWM4_DEADTIME__PWM4_DF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM4_DEADTIME.PWM4_DR ----------------------- */

/**
<pre>
  PWM.PWM4_DEADTIME.PWM4_DR:

    PWM4 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm4_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm4_dr[7:0] = PWM_DEADTIME[63:56]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM4_DEADTIME__PWM4_DR__Pos                         0                                                                      /*!< Right-most bit position of pwm4_dr in PWM.PWM4_DEADTIME */
#define PWM_PWM4_DEADTIME__PWM4_DR__Msk                         (0x000000FFUL << PWM_PWM4_DEADTIME__PWM4_DR__Pos)                      /*!< Mask for pwm4_dr in PWM.PWM4_DEADTIME */
#define PWM_PWM4_DEADTIME__PWM4_DR__Shift(v)                    (((v) << PWM_PWM4_DEADTIME__PWM4_DR__Pos) & PWM_PWM4_DEADTIME__PWM4_DR__Msk) /*!< Shift value 'v' into pwm4_dr and mask 'v' to fit it into pwm4_dr field */

/** PWM_PWM4_DEADTIME__PWM4_DR__SET() sets PWM4_DEADTIME.PWM4_DR to given value.
 *
 * When writing to PWM4_DEADTIME.PWM4_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM4_DEADTIME.PWM4_DR
 */
__PWM_INLINE void PWM_PWM4_DEADTIME__PWM4_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM4_DEADTIME__GET();
    reg = (reg & ~PWM_PWM4_DEADTIME__PWM4_DR__Msk);
    reg = (reg | (PWM_PWM4_DEADTIME__PWM4_DR__Shift((uint32_t)bf_value)));
    PWM_PWM4_DEADTIME__SET(reg);
}

/** PWM_PWM4_DEADTIME__PWM4_DR__GET() gets PWM4_DEADTIME.PWM4_DR's current value.
 *
 * When reading from PWM4_DEADTIME.PWM4_DR, this is recommended to use.
 *
 * @return current value of PWM4_DEADTIME.PWM4_DR
 */
__PWM_INLINE uint32_t PWM_PWM4_DEADTIME__PWM4_DR__GET(void)
{
    uint32_t reg = PWM_PWM4_DEADTIME__GET();
    reg = (reg & PWM_PWM4_DEADTIME__PWM4_DR__Msk);
    reg = (reg >> PWM_PWM4_DEADTIME__PWM4_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM4_DEADTIME__PWM4_DR__MODIFY() modifies PWM4_DEADTIME.PWM4_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM4_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM4_DEADTIME
 * @param bf_value new value for PWM4_DEADTIME.PWM4_DR
 * @return new value of PWM.PWM4_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM4_DEADTIME__PWM4_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM4_DEADTIME__PWM4_DR__Msk);
    reg = (reg | (PWM_PWM4_DEADTIME__PWM4_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM4_DEADTIME__PWM4_DR__EXTRACT() extracts PWM4_DEADTIME.PWM4_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM4_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM4_DEADTIME
 * @return current value of PWM4_DEADTIME.PWM4_DR
 */
__PWM_INLINE uint32_t PWM_PWM4_DEADTIME__PWM4_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM4_DEADTIME__PWM4_DR__Msk);
    reg = (reg >> PWM_PWM4_DEADTIME__PWM4_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM5_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM5_DEADTIME__ADDRESS returns the address of member PWM5_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM5_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM5_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM5_DEADTIME)));
}

/** PWM_PWM5_DEADTIME__SET() sets PWM5_DEADTIME to given value.
 *
 * When writing to PWM5_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM5_DEADTIME
 */
__PWM_INLINE void PWM_PWM5_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM5_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM5_DEADTIME__GET() gets PWM5_DEADTIME's current value.
 *
 * When reading from PWM5_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM5_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM5_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM5_DEADTIME__ADDRESS());
}

/* ----------------------- PWM.PWM5_DEADTIME.PWM5_DF ----------------------- */

/**
<pre>
  PWM.PWM5_DEADTIME.PWM5_DF:

    PWM5 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm5_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm5_df[7:0] = PWM_DEADTIME[71:64]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM5_DEADTIME__PWM5_DF__Pos                         8                                                                      /*!< Right-most bit position of pwm5_df in PWM.PWM5_DEADTIME */
#define PWM_PWM5_DEADTIME__PWM5_DF__Msk                         (0x000000FFUL << PWM_PWM5_DEADTIME__PWM5_DF__Pos)                      /*!< Mask for pwm5_df in PWM.PWM5_DEADTIME */
#define PWM_PWM5_DEADTIME__PWM5_DF__Shift(v)                    (((v) << PWM_PWM5_DEADTIME__PWM5_DF__Pos) & PWM_PWM5_DEADTIME__PWM5_DF__Msk) /*!< Shift value 'v' into pwm5_df and mask 'v' to fit it into pwm5_df field */

/** PWM_PWM5_DEADTIME__PWM5_DF__SET() sets PWM5_DEADTIME.PWM5_DF to given value.
 *
 * When writing to PWM5_DEADTIME.PWM5_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM5_DEADTIME.PWM5_DF
 */
__PWM_INLINE void PWM_PWM5_DEADTIME__PWM5_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM5_DEADTIME__GET();
    reg = (reg & ~PWM_PWM5_DEADTIME__PWM5_DF__Msk);
    reg = (reg | (PWM_PWM5_DEADTIME__PWM5_DF__Shift((uint32_t)bf_value)));
    PWM_PWM5_DEADTIME__SET(reg);
}

/** PWM_PWM5_DEADTIME__PWM5_DF__GET() gets PWM5_DEADTIME.PWM5_DF's current value.
 *
 * When reading from PWM5_DEADTIME.PWM5_DF, this is recommended to use.
 *
 * @return current value of PWM5_DEADTIME.PWM5_DF
 */
__PWM_INLINE uint32_t PWM_PWM5_DEADTIME__PWM5_DF__GET(void)
{
    uint32_t reg = PWM_PWM5_DEADTIME__GET();
    reg = (reg & PWM_PWM5_DEADTIME__PWM5_DF__Msk);
    reg = (reg >> PWM_PWM5_DEADTIME__PWM5_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM5_DEADTIME__PWM5_DF__MODIFY() modifies PWM5_DEADTIME.PWM5_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM5_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM5_DEADTIME
 * @param bf_value new value for PWM5_DEADTIME.PWM5_DF
 * @return new value of PWM.PWM5_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM5_DEADTIME__PWM5_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM5_DEADTIME__PWM5_DF__Msk);
    reg = (reg | (PWM_PWM5_DEADTIME__PWM5_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM5_DEADTIME__PWM5_DF__EXTRACT() extracts PWM5_DEADTIME.PWM5_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM5_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM5_DEADTIME
 * @return current value of PWM5_DEADTIME.PWM5_DF
 */
__PWM_INLINE uint32_t PWM_PWM5_DEADTIME__PWM5_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM5_DEADTIME__PWM5_DF__Msk);
    reg = (reg >> PWM_PWM5_DEADTIME__PWM5_DF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM5_DEADTIME.PWM5_DR ----------------------- */

/**
<pre>
  PWM.PWM5_DEADTIME.PWM5_DR:

    PWM5 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm5_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm5_dr[7:0] = PWM_DEADTIME[79:72]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM5_DEADTIME__PWM5_DR__Pos                         0                                                                      /*!< Right-most bit position of pwm5_dr in PWM.PWM5_DEADTIME */
#define PWM_PWM5_DEADTIME__PWM5_DR__Msk                         (0x000000FFUL << PWM_PWM5_DEADTIME__PWM5_DR__Pos)                      /*!< Mask for pwm5_dr in PWM.PWM5_DEADTIME */
#define PWM_PWM5_DEADTIME__PWM5_DR__Shift(v)                    (((v) << PWM_PWM5_DEADTIME__PWM5_DR__Pos) & PWM_PWM5_DEADTIME__PWM5_DR__Msk) /*!< Shift value 'v' into pwm5_dr and mask 'v' to fit it into pwm5_dr field */

/** PWM_PWM5_DEADTIME__PWM5_DR__SET() sets PWM5_DEADTIME.PWM5_DR to given value.
 *
 * When writing to PWM5_DEADTIME.PWM5_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM5_DEADTIME.PWM5_DR
 */
__PWM_INLINE void PWM_PWM5_DEADTIME__PWM5_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM5_DEADTIME__GET();
    reg = (reg & ~PWM_PWM5_DEADTIME__PWM5_DR__Msk);
    reg = (reg | (PWM_PWM5_DEADTIME__PWM5_DR__Shift((uint32_t)bf_value)));
    PWM_PWM5_DEADTIME__SET(reg);
}

/** PWM_PWM5_DEADTIME__PWM5_DR__GET() gets PWM5_DEADTIME.PWM5_DR's current value.
 *
 * When reading from PWM5_DEADTIME.PWM5_DR, this is recommended to use.
 *
 * @return current value of PWM5_DEADTIME.PWM5_DR
 */
__PWM_INLINE uint32_t PWM_PWM5_DEADTIME__PWM5_DR__GET(void)
{
    uint32_t reg = PWM_PWM5_DEADTIME__GET();
    reg = (reg & PWM_PWM5_DEADTIME__PWM5_DR__Msk);
    reg = (reg >> PWM_PWM5_DEADTIME__PWM5_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM5_DEADTIME__PWM5_DR__MODIFY() modifies PWM5_DEADTIME.PWM5_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM5_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM5_DEADTIME
 * @param bf_value new value for PWM5_DEADTIME.PWM5_DR
 * @return new value of PWM.PWM5_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM5_DEADTIME__PWM5_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM5_DEADTIME__PWM5_DR__Msk);
    reg = (reg | (PWM_PWM5_DEADTIME__PWM5_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM5_DEADTIME__PWM5_DR__EXTRACT() extracts PWM5_DEADTIME.PWM5_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM5_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM5_DEADTIME
 * @return current value of PWM5_DEADTIME.PWM5_DR
 */
__PWM_INLINE uint32_t PWM_PWM5_DEADTIME__PWM5_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM5_DEADTIME__PWM5_DR__Msk);
    reg = (reg >> PWM_PWM5_DEADTIME__PWM5_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM6_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM6_DEADTIME__ADDRESS returns the address of member PWM6_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM6_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM6_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM6_DEADTIME)));
}

/** PWM_PWM6_DEADTIME__SET() sets PWM6_DEADTIME to given value.
 *
 * When writing to PWM6_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM6_DEADTIME
 */
__PWM_INLINE void PWM_PWM6_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM6_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM6_DEADTIME__GET() gets PWM6_DEADTIME's current value.
 *
 * When reading from PWM6_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM6_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM6_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM6_DEADTIME__ADDRESS());
}

/* ----------------------- PWM.PWM6_DEADTIME.PWM6_DF ----------------------- */

/**
<pre>
  PWM.PWM6_DEADTIME.PWM6_DF:

    PWM6 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm6_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm6_df[7:0] = PWM_DEADTIME[87:80]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM6_DEADTIME__PWM6_DF__Pos                         8                                                                      /*!< Right-most bit position of pwm6_df in PWM.PWM6_DEADTIME */
#define PWM_PWM6_DEADTIME__PWM6_DF__Msk                         (0x000000FFUL << PWM_PWM6_DEADTIME__PWM6_DF__Pos)                      /*!< Mask for pwm6_df in PWM.PWM6_DEADTIME */
#define PWM_PWM6_DEADTIME__PWM6_DF__Shift(v)                    (((v) << PWM_PWM6_DEADTIME__PWM6_DF__Pos) & PWM_PWM6_DEADTIME__PWM6_DF__Msk) /*!< Shift value 'v' into pwm6_df and mask 'v' to fit it into pwm6_df field */

/** PWM_PWM6_DEADTIME__PWM6_DF__SET() sets PWM6_DEADTIME.PWM6_DF to given value.
 *
 * When writing to PWM6_DEADTIME.PWM6_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM6_DEADTIME.PWM6_DF
 */
__PWM_INLINE void PWM_PWM6_DEADTIME__PWM6_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM6_DEADTIME__GET();
    reg = (reg & ~PWM_PWM6_DEADTIME__PWM6_DF__Msk);
    reg = (reg | (PWM_PWM6_DEADTIME__PWM6_DF__Shift((uint32_t)bf_value)));
    PWM_PWM6_DEADTIME__SET(reg);
}

/** PWM_PWM6_DEADTIME__PWM6_DF__GET() gets PWM6_DEADTIME.PWM6_DF's current value.
 *
 * When reading from PWM6_DEADTIME.PWM6_DF, this is recommended to use.
 *
 * @return current value of PWM6_DEADTIME.PWM6_DF
 */
__PWM_INLINE uint32_t PWM_PWM6_DEADTIME__PWM6_DF__GET(void)
{
    uint32_t reg = PWM_PWM6_DEADTIME__GET();
    reg = (reg & PWM_PWM6_DEADTIME__PWM6_DF__Msk);
    reg = (reg >> PWM_PWM6_DEADTIME__PWM6_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM6_DEADTIME__PWM6_DF__MODIFY() modifies PWM6_DEADTIME.PWM6_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM6_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM6_DEADTIME
 * @param bf_value new value for PWM6_DEADTIME.PWM6_DF
 * @return new value of PWM.PWM6_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM6_DEADTIME__PWM6_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM6_DEADTIME__PWM6_DF__Msk);
    reg = (reg | (PWM_PWM6_DEADTIME__PWM6_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM6_DEADTIME__PWM6_DF__EXTRACT() extracts PWM6_DEADTIME.PWM6_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM6_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM6_DEADTIME
 * @return current value of PWM6_DEADTIME.PWM6_DF
 */
__PWM_INLINE uint32_t PWM_PWM6_DEADTIME__PWM6_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM6_DEADTIME__PWM6_DF__Msk);
    reg = (reg >> PWM_PWM6_DEADTIME__PWM6_DF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM6_DEADTIME.PWM6_DR ----------------------- */

/**
<pre>
  PWM.PWM6_DEADTIME.PWM6_DR:

    PWM6 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm6_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm6_dr[7:0] = PWM_DEADTIME[95:88]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM6_DEADTIME__PWM6_DR__Pos                         0                                                                      /*!< Right-most bit position of pwm6_dr in PWM.PWM6_DEADTIME */
#define PWM_PWM6_DEADTIME__PWM6_DR__Msk                         (0x000000FFUL << PWM_PWM6_DEADTIME__PWM6_DR__Pos)                      /*!< Mask for pwm6_dr in PWM.PWM6_DEADTIME */
#define PWM_PWM6_DEADTIME__PWM6_DR__Shift(v)                    (((v) << PWM_PWM6_DEADTIME__PWM6_DR__Pos) & PWM_PWM6_DEADTIME__PWM6_DR__Msk) /*!< Shift value 'v' into pwm6_dr and mask 'v' to fit it into pwm6_dr field */

/** PWM_PWM6_DEADTIME__PWM6_DR__SET() sets PWM6_DEADTIME.PWM6_DR to given value.
 *
 * When writing to PWM6_DEADTIME.PWM6_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM6_DEADTIME.PWM6_DR
 */
__PWM_INLINE void PWM_PWM6_DEADTIME__PWM6_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM6_DEADTIME__GET();
    reg = (reg & ~PWM_PWM6_DEADTIME__PWM6_DR__Msk);
    reg = (reg | (PWM_PWM6_DEADTIME__PWM6_DR__Shift((uint32_t)bf_value)));
    PWM_PWM6_DEADTIME__SET(reg);
}

/** PWM_PWM6_DEADTIME__PWM6_DR__GET() gets PWM6_DEADTIME.PWM6_DR's current value.
 *
 * When reading from PWM6_DEADTIME.PWM6_DR, this is recommended to use.
 *
 * @return current value of PWM6_DEADTIME.PWM6_DR
 */
__PWM_INLINE uint32_t PWM_PWM6_DEADTIME__PWM6_DR__GET(void)
{
    uint32_t reg = PWM_PWM6_DEADTIME__GET();
    reg = (reg & PWM_PWM6_DEADTIME__PWM6_DR__Msk);
    reg = (reg >> PWM_PWM6_DEADTIME__PWM6_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM6_DEADTIME__PWM6_DR__MODIFY() modifies PWM6_DEADTIME.PWM6_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM6_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM6_DEADTIME
 * @param bf_value new value for PWM6_DEADTIME.PWM6_DR
 * @return new value of PWM.PWM6_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM6_DEADTIME__PWM6_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM6_DEADTIME__PWM6_DR__Msk);
    reg = (reg | (PWM_PWM6_DEADTIME__PWM6_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM6_DEADTIME__PWM6_DR__EXTRACT() extracts PWM6_DEADTIME.PWM6_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM6_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM6_DEADTIME
 * @return current value of PWM6_DEADTIME.PWM6_DR
 */
__PWM_INLINE uint32_t PWM_PWM6_DEADTIME__PWM6_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM6_DEADTIME__PWM6_DR__Msk);
    reg = (reg >> PWM_PWM6_DEADTIME__PWM6_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM7_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM7_DEADTIME__ADDRESS returns the address of member PWM7_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM7_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM7_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM7_DEADTIME)));
}

/** PWM_PWM7_DEADTIME__SET() sets PWM7_DEADTIME to given value.
 *
 * When writing to PWM7_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM7_DEADTIME
 */
__PWM_INLINE void PWM_PWM7_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM7_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM7_DEADTIME__GET() gets PWM7_DEADTIME's current value.
 *
 * When reading from PWM7_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM7_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM7_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM7_DEADTIME__ADDRESS());
}

/* ----------------------- PWM.PWM7_DEADTIME.PWM7_DF ----------------------- */

/**
<pre>
  PWM.PWM7_DEADTIME.PWM7_DF:

    PWM7 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm7_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm7_df[7:0] = PWM_DEADTIME[103:96]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM7_DEADTIME__PWM7_DF__Pos                         8                                                                      /*!< Right-most bit position of pwm7_df in PWM.PWM7_DEADTIME */
#define PWM_PWM7_DEADTIME__PWM7_DF__Msk                         (0x000000FFUL << PWM_PWM7_DEADTIME__PWM7_DF__Pos)                      /*!< Mask for pwm7_df in PWM.PWM7_DEADTIME */
#define PWM_PWM7_DEADTIME__PWM7_DF__Shift(v)                    (((v) << PWM_PWM7_DEADTIME__PWM7_DF__Pos) & PWM_PWM7_DEADTIME__PWM7_DF__Msk) /*!< Shift value 'v' into pwm7_df and mask 'v' to fit it into pwm7_df field */

/** PWM_PWM7_DEADTIME__PWM7_DF__SET() sets PWM7_DEADTIME.PWM7_DF to given value.
 *
 * When writing to PWM7_DEADTIME.PWM7_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM7_DEADTIME.PWM7_DF
 */
__PWM_INLINE void PWM_PWM7_DEADTIME__PWM7_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM7_DEADTIME__GET();
    reg = (reg & ~PWM_PWM7_DEADTIME__PWM7_DF__Msk);
    reg = (reg | (PWM_PWM7_DEADTIME__PWM7_DF__Shift((uint32_t)bf_value)));
    PWM_PWM7_DEADTIME__SET(reg);
}

/** PWM_PWM7_DEADTIME__PWM7_DF__GET() gets PWM7_DEADTIME.PWM7_DF's current value.
 *
 * When reading from PWM7_DEADTIME.PWM7_DF, this is recommended to use.
 *
 * @return current value of PWM7_DEADTIME.PWM7_DF
 */
__PWM_INLINE uint32_t PWM_PWM7_DEADTIME__PWM7_DF__GET(void)
{
    uint32_t reg = PWM_PWM7_DEADTIME__GET();
    reg = (reg & PWM_PWM7_DEADTIME__PWM7_DF__Msk);
    reg = (reg >> PWM_PWM7_DEADTIME__PWM7_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM7_DEADTIME__PWM7_DF__MODIFY() modifies PWM7_DEADTIME.PWM7_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM7_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM7_DEADTIME
 * @param bf_value new value for PWM7_DEADTIME.PWM7_DF
 * @return new value of PWM.PWM7_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM7_DEADTIME__PWM7_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM7_DEADTIME__PWM7_DF__Msk);
    reg = (reg | (PWM_PWM7_DEADTIME__PWM7_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM7_DEADTIME__PWM7_DF__EXTRACT() extracts PWM7_DEADTIME.PWM7_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM7_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM7_DEADTIME
 * @return current value of PWM7_DEADTIME.PWM7_DF
 */
__PWM_INLINE uint32_t PWM_PWM7_DEADTIME__PWM7_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM7_DEADTIME__PWM7_DF__Msk);
    reg = (reg >> PWM_PWM7_DEADTIME__PWM7_DF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM7_DEADTIME.PWM7_DR ----------------------- */

/**
<pre>
  PWM.PWM7_DEADTIME.PWM7_DR:

    PWM7 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm7_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm7_dr[7:0] = PWM_DEADTIME[111:104]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM7_DEADTIME__PWM7_DR__Pos                         0                                                                      /*!< Right-most bit position of pwm7_dr in PWM.PWM7_DEADTIME */
#define PWM_PWM7_DEADTIME__PWM7_DR__Msk                         (0x000000FFUL << PWM_PWM7_DEADTIME__PWM7_DR__Pos)                      /*!< Mask for pwm7_dr in PWM.PWM7_DEADTIME */
#define PWM_PWM7_DEADTIME__PWM7_DR__Shift(v)                    (((v) << PWM_PWM7_DEADTIME__PWM7_DR__Pos) & PWM_PWM7_DEADTIME__PWM7_DR__Msk) /*!< Shift value 'v' into pwm7_dr and mask 'v' to fit it into pwm7_dr field */

/** PWM_PWM7_DEADTIME__PWM7_DR__SET() sets PWM7_DEADTIME.PWM7_DR to given value.
 *
 * When writing to PWM7_DEADTIME.PWM7_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM7_DEADTIME.PWM7_DR
 */
__PWM_INLINE void PWM_PWM7_DEADTIME__PWM7_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM7_DEADTIME__GET();
    reg = (reg & ~PWM_PWM7_DEADTIME__PWM7_DR__Msk);
    reg = (reg | (PWM_PWM7_DEADTIME__PWM7_DR__Shift((uint32_t)bf_value)));
    PWM_PWM7_DEADTIME__SET(reg);
}

/** PWM_PWM7_DEADTIME__PWM7_DR__GET() gets PWM7_DEADTIME.PWM7_DR's current value.
 *
 * When reading from PWM7_DEADTIME.PWM7_DR, this is recommended to use.
 *
 * @return current value of PWM7_DEADTIME.PWM7_DR
 */
__PWM_INLINE uint32_t PWM_PWM7_DEADTIME__PWM7_DR__GET(void)
{
    uint32_t reg = PWM_PWM7_DEADTIME__GET();
    reg = (reg & PWM_PWM7_DEADTIME__PWM7_DR__Msk);
    reg = (reg >> PWM_PWM7_DEADTIME__PWM7_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM7_DEADTIME__PWM7_DR__MODIFY() modifies PWM7_DEADTIME.PWM7_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM7_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM7_DEADTIME
 * @param bf_value new value for PWM7_DEADTIME.PWM7_DR
 * @return new value of PWM.PWM7_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM7_DEADTIME__PWM7_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM7_DEADTIME__PWM7_DR__Msk);
    reg = (reg | (PWM_PWM7_DEADTIME__PWM7_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM7_DEADTIME__PWM7_DR__EXTRACT() extracts PWM7_DEADTIME.PWM7_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM7_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM7_DEADTIME
 * @return current value of PWM7_DEADTIME.PWM7_DR
 */
__PWM_INLINE uint32_t PWM_PWM7_DEADTIME__PWM7_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM7_DEADTIME__PWM7_DR__Msk);
    reg = (reg >> PWM_PWM7_DEADTIME__PWM7_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM8_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM8_DEADTIME__ADDRESS returns the address of member PWM8_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM8_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM8_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM8_DEADTIME)));
}

/** PWM_PWM8_DEADTIME__SET() sets PWM8_DEADTIME to given value.
 *
 * When writing to PWM8_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM8_DEADTIME
 */
__PWM_INLINE void PWM_PWM8_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM8_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM8_DEADTIME__GET() gets PWM8_DEADTIME's current value.
 *
 * When reading from PWM8_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM8_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM8_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM8_DEADTIME__ADDRESS());
}

/* ----------------------- PWM.PWM8_DEADTIME.PWM8_DF ----------------------- */

/**
<pre>
  PWM.PWM8_DEADTIME.PWM8_DF:

    PWM8 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm8_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm8_df[7:0] = PWM_DEADTIME[119:112]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM8_DEADTIME__PWM8_DF__Pos                         8                                                                      /*!< Right-most bit position of pwm8_df in PWM.PWM8_DEADTIME */
#define PWM_PWM8_DEADTIME__PWM8_DF__Msk                         (0x000000FFUL << PWM_PWM8_DEADTIME__PWM8_DF__Pos)                      /*!< Mask for pwm8_df in PWM.PWM8_DEADTIME */
#define PWM_PWM8_DEADTIME__PWM8_DF__Shift(v)                    (((v) << PWM_PWM8_DEADTIME__PWM8_DF__Pos) & PWM_PWM8_DEADTIME__PWM8_DF__Msk) /*!< Shift value 'v' into pwm8_df and mask 'v' to fit it into pwm8_df field */

/** PWM_PWM8_DEADTIME__PWM8_DF__SET() sets PWM8_DEADTIME.PWM8_DF to given value.
 *
 * When writing to PWM8_DEADTIME.PWM8_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM8_DEADTIME.PWM8_DF
 */
__PWM_INLINE void PWM_PWM8_DEADTIME__PWM8_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM8_DEADTIME__GET();
    reg = (reg & ~PWM_PWM8_DEADTIME__PWM8_DF__Msk);
    reg = (reg | (PWM_PWM8_DEADTIME__PWM8_DF__Shift((uint32_t)bf_value)));
    PWM_PWM8_DEADTIME__SET(reg);
}

/** PWM_PWM8_DEADTIME__PWM8_DF__GET() gets PWM8_DEADTIME.PWM8_DF's current value.
 *
 * When reading from PWM8_DEADTIME.PWM8_DF, this is recommended to use.
 *
 * @return current value of PWM8_DEADTIME.PWM8_DF
 */
__PWM_INLINE uint32_t PWM_PWM8_DEADTIME__PWM8_DF__GET(void)
{
    uint32_t reg = PWM_PWM8_DEADTIME__GET();
    reg = (reg & PWM_PWM8_DEADTIME__PWM8_DF__Msk);
    reg = (reg >> PWM_PWM8_DEADTIME__PWM8_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM8_DEADTIME__PWM8_DF__MODIFY() modifies PWM8_DEADTIME.PWM8_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM8_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM8_DEADTIME
 * @param bf_value new value for PWM8_DEADTIME.PWM8_DF
 * @return new value of PWM.PWM8_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM8_DEADTIME__PWM8_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM8_DEADTIME__PWM8_DF__Msk);
    reg = (reg | (PWM_PWM8_DEADTIME__PWM8_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM8_DEADTIME__PWM8_DF__EXTRACT() extracts PWM8_DEADTIME.PWM8_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM8_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM8_DEADTIME
 * @return current value of PWM8_DEADTIME.PWM8_DF
 */
__PWM_INLINE uint32_t PWM_PWM8_DEADTIME__PWM8_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM8_DEADTIME__PWM8_DF__Msk);
    reg = (reg >> PWM_PWM8_DEADTIME__PWM8_DF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM8_DEADTIME.PWM8_DR ----------------------- */

/**
<pre>
  PWM.PWM8_DEADTIME.PWM8_DR:

    PWM8 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm8_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm8_dr[7:0] = PWM_DEADTIME[127:120]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM8_DEADTIME__PWM8_DR__Pos                         0                                                                      /*!< Right-most bit position of pwm8_dr in PWM.PWM8_DEADTIME */
#define PWM_PWM8_DEADTIME__PWM8_DR__Msk                         (0x000000FFUL << PWM_PWM8_DEADTIME__PWM8_DR__Pos)                      /*!< Mask for pwm8_dr in PWM.PWM8_DEADTIME */
#define PWM_PWM8_DEADTIME__PWM8_DR__Shift(v)                    (((v) << PWM_PWM8_DEADTIME__PWM8_DR__Pos) & PWM_PWM8_DEADTIME__PWM8_DR__Msk) /*!< Shift value 'v' into pwm8_dr and mask 'v' to fit it into pwm8_dr field */

/** PWM_PWM8_DEADTIME__PWM8_DR__SET() sets PWM8_DEADTIME.PWM8_DR to given value.
 *
 * When writing to PWM8_DEADTIME.PWM8_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM8_DEADTIME.PWM8_DR
 */
__PWM_INLINE void PWM_PWM8_DEADTIME__PWM8_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM8_DEADTIME__GET();
    reg = (reg & ~PWM_PWM8_DEADTIME__PWM8_DR__Msk);
    reg = (reg | (PWM_PWM8_DEADTIME__PWM8_DR__Shift((uint32_t)bf_value)));
    PWM_PWM8_DEADTIME__SET(reg);
}

/** PWM_PWM8_DEADTIME__PWM8_DR__GET() gets PWM8_DEADTIME.PWM8_DR's current value.
 *
 * When reading from PWM8_DEADTIME.PWM8_DR, this is recommended to use.
 *
 * @return current value of PWM8_DEADTIME.PWM8_DR
 */
__PWM_INLINE uint32_t PWM_PWM8_DEADTIME__PWM8_DR__GET(void)
{
    uint32_t reg = PWM_PWM8_DEADTIME__GET();
    reg = (reg & PWM_PWM8_DEADTIME__PWM8_DR__Msk);
    reg = (reg >> PWM_PWM8_DEADTIME__PWM8_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM8_DEADTIME__PWM8_DR__MODIFY() modifies PWM8_DEADTIME.PWM8_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM8_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM8_DEADTIME
 * @param bf_value new value for PWM8_DEADTIME.PWM8_DR
 * @return new value of PWM.PWM8_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM8_DEADTIME__PWM8_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM8_DEADTIME__PWM8_DR__Msk);
    reg = (reg | (PWM_PWM8_DEADTIME__PWM8_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM8_DEADTIME__PWM8_DR__EXTRACT() extracts PWM8_DEADTIME.PWM8_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM8_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM8_DEADTIME
 * @return current value of PWM8_DEADTIME.PWM8_DR
 */
__PWM_INLINE uint32_t PWM_PWM8_DEADTIME__PWM8_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM8_DEADTIME__PWM8_DR__Msk);
    reg = (reg >> PWM_PWM8_DEADTIME__PWM8_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM9_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM9_DEADTIME__ADDRESS returns the address of member PWM9_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM9_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM9_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM9_DEADTIME)));
}

/** PWM_PWM9_DEADTIME__SET() sets PWM9_DEADTIME to given value.
 *
 * When writing to PWM9_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM9_DEADTIME
 */
__PWM_INLINE void PWM_PWM9_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM9_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM9_DEADTIME__GET() gets PWM9_DEADTIME's current value.
 *
 * When reading from PWM9_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM9_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM9_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM9_DEADTIME__ADDRESS());
}

/* ----------------------- PWM.PWM9_DEADTIME.PWM9_DF ----------------------- */

/**
<pre>
  PWM.PWM9_DEADTIME.PWM9_DF:

    PWM9 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm9_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm9_df[7:0] = PWM_DEADTIME[135:128]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM9_DEADTIME__PWM9_DF__Pos                         8                                                                      /*!< Right-most bit position of pwm9_df in PWM.PWM9_DEADTIME */
#define PWM_PWM9_DEADTIME__PWM9_DF__Msk                         (0x000000FFUL << PWM_PWM9_DEADTIME__PWM9_DF__Pos)                      /*!< Mask for pwm9_df in PWM.PWM9_DEADTIME */
#define PWM_PWM9_DEADTIME__PWM9_DF__Shift(v)                    (((v) << PWM_PWM9_DEADTIME__PWM9_DF__Pos) & PWM_PWM9_DEADTIME__PWM9_DF__Msk) /*!< Shift value 'v' into pwm9_df and mask 'v' to fit it into pwm9_df field */

/** PWM_PWM9_DEADTIME__PWM9_DF__SET() sets PWM9_DEADTIME.PWM9_DF to given value.
 *
 * When writing to PWM9_DEADTIME.PWM9_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM9_DEADTIME.PWM9_DF
 */
__PWM_INLINE void PWM_PWM9_DEADTIME__PWM9_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM9_DEADTIME__GET();
    reg = (reg & ~PWM_PWM9_DEADTIME__PWM9_DF__Msk);
    reg = (reg | (PWM_PWM9_DEADTIME__PWM9_DF__Shift((uint32_t)bf_value)));
    PWM_PWM9_DEADTIME__SET(reg);
}

/** PWM_PWM9_DEADTIME__PWM9_DF__GET() gets PWM9_DEADTIME.PWM9_DF's current value.
 *
 * When reading from PWM9_DEADTIME.PWM9_DF, this is recommended to use.
 *
 * @return current value of PWM9_DEADTIME.PWM9_DF
 */
__PWM_INLINE uint32_t PWM_PWM9_DEADTIME__PWM9_DF__GET(void)
{
    uint32_t reg = PWM_PWM9_DEADTIME__GET();
    reg = (reg & PWM_PWM9_DEADTIME__PWM9_DF__Msk);
    reg = (reg >> PWM_PWM9_DEADTIME__PWM9_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM9_DEADTIME__PWM9_DF__MODIFY() modifies PWM9_DEADTIME.PWM9_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM9_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM9_DEADTIME
 * @param bf_value new value for PWM9_DEADTIME.PWM9_DF
 * @return new value of PWM.PWM9_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM9_DEADTIME__PWM9_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM9_DEADTIME__PWM9_DF__Msk);
    reg = (reg | (PWM_PWM9_DEADTIME__PWM9_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM9_DEADTIME__PWM9_DF__EXTRACT() extracts PWM9_DEADTIME.PWM9_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM9_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM9_DEADTIME
 * @return current value of PWM9_DEADTIME.PWM9_DF
 */
__PWM_INLINE uint32_t PWM_PWM9_DEADTIME__PWM9_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM9_DEADTIME__PWM9_DF__Msk);
    reg = (reg >> PWM_PWM9_DEADTIME__PWM9_DF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PWM.PWM9_DEADTIME.PWM9_DR ----------------------- */

/**
<pre>
  PWM.PWM9_DEADTIME.PWM9_DR:

    PWM9 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm9_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm9_dr[7:0] = PWM_DEADTIME[143:136]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM9_DEADTIME__PWM9_DR__Pos                         0                                                                      /*!< Right-most bit position of pwm9_dr in PWM.PWM9_DEADTIME */
#define PWM_PWM9_DEADTIME__PWM9_DR__Msk                         (0x000000FFUL << PWM_PWM9_DEADTIME__PWM9_DR__Pos)                      /*!< Mask for pwm9_dr in PWM.PWM9_DEADTIME */
#define PWM_PWM9_DEADTIME__PWM9_DR__Shift(v)                    (((v) << PWM_PWM9_DEADTIME__PWM9_DR__Pos) & PWM_PWM9_DEADTIME__PWM9_DR__Msk) /*!< Shift value 'v' into pwm9_dr and mask 'v' to fit it into pwm9_dr field */

/** PWM_PWM9_DEADTIME__PWM9_DR__SET() sets PWM9_DEADTIME.PWM9_DR to given value.
 *
 * When writing to PWM9_DEADTIME.PWM9_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM9_DEADTIME.PWM9_DR
 */
__PWM_INLINE void PWM_PWM9_DEADTIME__PWM9_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM9_DEADTIME__GET();
    reg = (reg & ~PWM_PWM9_DEADTIME__PWM9_DR__Msk);
    reg = (reg | (PWM_PWM9_DEADTIME__PWM9_DR__Shift((uint32_t)bf_value)));
    PWM_PWM9_DEADTIME__SET(reg);
}

/** PWM_PWM9_DEADTIME__PWM9_DR__GET() gets PWM9_DEADTIME.PWM9_DR's current value.
 *
 * When reading from PWM9_DEADTIME.PWM9_DR, this is recommended to use.
 *
 * @return current value of PWM9_DEADTIME.PWM9_DR
 */
__PWM_INLINE uint32_t PWM_PWM9_DEADTIME__PWM9_DR__GET(void)
{
    uint32_t reg = PWM_PWM9_DEADTIME__GET();
    reg = (reg & PWM_PWM9_DEADTIME__PWM9_DR__Msk);
    reg = (reg >> PWM_PWM9_DEADTIME__PWM9_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM9_DEADTIME__PWM9_DR__MODIFY() modifies PWM9_DEADTIME.PWM9_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM9_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM9_DEADTIME
 * @param bf_value new value for PWM9_DEADTIME.PWM9_DR
 * @return new value of PWM.PWM9_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM9_DEADTIME__PWM9_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM9_DEADTIME__PWM9_DR__Msk);
    reg = (reg | (PWM_PWM9_DEADTIME__PWM9_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM9_DEADTIME__PWM9_DR__EXTRACT() extracts PWM9_DEADTIME.PWM9_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM9_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM9_DEADTIME
 * @return current value of PWM9_DEADTIME.PWM9_DR
 */
__PWM_INLINE uint32_t PWM_PWM9_DEADTIME__PWM9_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM9_DEADTIME__PWM9_DR__Msk);
    reg = (reg >> PWM_PWM9_DEADTIME__PWM9_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM10_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM10_DEADTIME__ADDRESS returns the address of member PWM10_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM10_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM10_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM10_DEADTIME)));
}

/** PWM_PWM10_DEADTIME__SET() sets PWM10_DEADTIME to given value.
 *
 * When writing to PWM10_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM10_DEADTIME
 */
__PWM_INLINE void PWM_PWM10_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM10_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM10_DEADTIME__GET() gets PWM10_DEADTIME's current value.
 *
 * When reading from PWM10_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM10_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM10_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM10_DEADTIME__ADDRESS());
}

/* ---------------------- PWM.PWM10_DEADTIME.PWM10_DF ---------------------- */

/**
<pre>
  PWM.PWM10_DEADTIME.PWM10_DF:

    PWM10 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm10_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm10_df[7:0] = PWM_DEADTIME[151:144]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM10_DEADTIME__PWM10_DF__Pos                       8                                                                      /*!< Right-most bit position of pwm10_df in PWM.PWM10_DEADTIME */
#define PWM_PWM10_DEADTIME__PWM10_DF__Msk                       (0x000000FFUL << PWM_PWM10_DEADTIME__PWM10_DF__Pos)                    /*!< Mask for pwm10_df in PWM.PWM10_DEADTIME */
#define PWM_PWM10_DEADTIME__PWM10_DF__Shift(v)                  (((v) << PWM_PWM10_DEADTIME__PWM10_DF__Pos) & PWM_PWM10_DEADTIME__PWM10_DF__Msk) /*!< Shift value 'v' into pwm10_df and mask 'v' to fit it into pwm10_df field */

/** PWM_PWM10_DEADTIME__PWM10_DF__SET() sets PWM10_DEADTIME.PWM10_DF to given value.
 *
 * When writing to PWM10_DEADTIME.PWM10_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM10_DEADTIME.PWM10_DF
 */
__PWM_INLINE void PWM_PWM10_DEADTIME__PWM10_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM10_DEADTIME__GET();
    reg = (reg & ~PWM_PWM10_DEADTIME__PWM10_DF__Msk);
    reg = (reg | (PWM_PWM10_DEADTIME__PWM10_DF__Shift((uint32_t)bf_value)));
    PWM_PWM10_DEADTIME__SET(reg);
}

/** PWM_PWM10_DEADTIME__PWM10_DF__GET() gets PWM10_DEADTIME.PWM10_DF's current value.
 *
 * When reading from PWM10_DEADTIME.PWM10_DF, this is recommended to use.
 *
 * @return current value of PWM10_DEADTIME.PWM10_DF
 */
__PWM_INLINE uint32_t PWM_PWM10_DEADTIME__PWM10_DF__GET(void)
{
    uint32_t reg = PWM_PWM10_DEADTIME__GET();
    reg = (reg & PWM_PWM10_DEADTIME__PWM10_DF__Msk);
    reg = (reg >> PWM_PWM10_DEADTIME__PWM10_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM10_DEADTIME__PWM10_DF__MODIFY() modifies PWM10_DEADTIME.PWM10_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM10_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM10_DEADTIME
 * @param bf_value new value for PWM10_DEADTIME.PWM10_DF
 * @return new value of PWM.PWM10_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM10_DEADTIME__PWM10_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM10_DEADTIME__PWM10_DF__Msk);
    reg = (reg | (PWM_PWM10_DEADTIME__PWM10_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM10_DEADTIME__PWM10_DF__EXTRACT() extracts PWM10_DEADTIME.PWM10_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM10_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM10_DEADTIME
 * @return current value of PWM10_DEADTIME.PWM10_DF
 */
__PWM_INLINE uint32_t PWM_PWM10_DEADTIME__PWM10_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM10_DEADTIME__PWM10_DF__Msk);
    reg = (reg >> PWM_PWM10_DEADTIME__PWM10_DF__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM10_DEADTIME.PWM10_DR ---------------------- */

/**
<pre>
  PWM.PWM10_DEADTIME.PWM10_DR:

    PWM10 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm10_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm10_dr[7:0] = PWM_DEADTIME[159:152]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM10_DEADTIME__PWM10_DR__Pos                       0                                                                      /*!< Right-most bit position of pwm10_dr in PWM.PWM10_DEADTIME */
#define PWM_PWM10_DEADTIME__PWM10_DR__Msk                       (0x000000FFUL << PWM_PWM10_DEADTIME__PWM10_DR__Pos)                    /*!< Mask for pwm10_dr in PWM.PWM10_DEADTIME */
#define PWM_PWM10_DEADTIME__PWM10_DR__Shift(v)                  (((v) << PWM_PWM10_DEADTIME__PWM10_DR__Pos) & PWM_PWM10_DEADTIME__PWM10_DR__Msk) /*!< Shift value 'v' into pwm10_dr and mask 'v' to fit it into pwm10_dr field */

/** PWM_PWM10_DEADTIME__PWM10_DR__SET() sets PWM10_DEADTIME.PWM10_DR to given value.
 *
 * When writing to PWM10_DEADTIME.PWM10_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM10_DEADTIME.PWM10_DR
 */
__PWM_INLINE void PWM_PWM10_DEADTIME__PWM10_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM10_DEADTIME__GET();
    reg = (reg & ~PWM_PWM10_DEADTIME__PWM10_DR__Msk);
    reg = (reg | (PWM_PWM10_DEADTIME__PWM10_DR__Shift((uint32_t)bf_value)));
    PWM_PWM10_DEADTIME__SET(reg);
}

/** PWM_PWM10_DEADTIME__PWM10_DR__GET() gets PWM10_DEADTIME.PWM10_DR's current value.
 *
 * When reading from PWM10_DEADTIME.PWM10_DR, this is recommended to use.
 *
 * @return current value of PWM10_DEADTIME.PWM10_DR
 */
__PWM_INLINE uint32_t PWM_PWM10_DEADTIME__PWM10_DR__GET(void)
{
    uint32_t reg = PWM_PWM10_DEADTIME__GET();
    reg = (reg & PWM_PWM10_DEADTIME__PWM10_DR__Msk);
    reg = (reg >> PWM_PWM10_DEADTIME__PWM10_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM10_DEADTIME__PWM10_DR__MODIFY() modifies PWM10_DEADTIME.PWM10_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM10_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM10_DEADTIME
 * @param bf_value new value for PWM10_DEADTIME.PWM10_DR
 * @return new value of PWM.PWM10_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM10_DEADTIME__PWM10_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM10_DEADTIME__PWM10_DR__Msk);
    reg = (reg | (PWM_PWM10_DEADTIME__PWM10_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM10_DEADTIME__PWM10_DR__EXTRACT() extracts PWM10_DEADTIME.PWM10_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM10_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM10_DEADTIME
 * @return current value of PWM10_DEADTIME.PWM10_DR
 */
__PWM_INLINE uint32_t PWM_PWM10_DEADTIME__PWM10_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM10_DEADTIME__PWM10_DR__Msk);
    reg = (reg >> PWM_PWM10_DEADTIME__PWM10_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM11_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM11_DEADTIME__ADDRESS returns the address of member PWM11_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM11_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM11_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM11_DEADTIME)));
}

/** PWM_PWM11_DEADTIME__SET() sets PWM11_DEADTIME to given value.
 *
 * When writing to PWM11_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM11_DEADTIME
 */
__PWM_INLINE void PWM_PWM11_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM11_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM11_DEADTIME__GET() gets PWM11_DEADTIME's current value.
 *
 * When reading from PWM11_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM11_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM11_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM11_DEADTIME__ADDRESS());
}

/* ---------------------- PWM.PWM11_DEADTIME.PWM11_DF ---------------------- */

/**
<pre>
  PWM.PWM11_DEADTIME.PWM11_DF:

    PWM11 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm11_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm11_df[7:0] = PWM_DEADTIME[167:160]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM11_DEADTIME__PWM11_DF__Pos                       8                                                                      /*!< Right-most bit position of pwm11_df in PWM.PWM11_DEADTIME */
#define PWM_PWM11_DEADTIME__PWM11_DF__Msk                       (0x000000FFUL << PWM_PWM11_DEADTIME__PWM11_DF__Pos)                    /*!< Mask for pwm11_df in PWM.PWM11_DEADTIME */
#define PWM_PWM11_DEADTIME__PWM11_DF__Shift(v)                  (((v) << PWM_PWM11_DEADTIME__PWM11_DF__Pos) & PWM_PWM11_DEADTIME__PWM11_DF__Msk) /*!< Shift value 'v' into pwm11_df and mask 'v' to fit it into pwm11_df field */

/** PWM_PWM11_DEADTIME__PWM11_DF__SET() sets PWM11_DEADTIME.PWM11_DF to given value.
 *
 * When writing to PWM11_DEADTIME.PWM11_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM11_DEADTIME.PWM11_DF
 */
__PWM_INLINE void PWM_PWM11_DEADTIME__PWM11_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM11_DEADTIME__GET();
    reg = (reg & ~PWM_PWM11_DEADTIME__PWM11_DF__Msk);
    reg = (reg | (PWM_PWM11_DEADTIME__PWM11_DF__Shift((uint32_t)bf_value)));
    PWM_PWM11_DEADTIME__SET(reg);
}

/** PWM_PWM11_DEADTIME__PWM11_DF__GET() gets PWM11_DEADTIME.PWM11_DF's current value.
 *
 * When reading from PWM11_DEADTIME.PWM11_DF, this is recommended to use.
 *
 * @return current value of PWM11_DEADTIME.PWM11_DF
 */
__PWM_INLINE uint32_t PWM_PWM11_DEADTIME__PWM11_DF__GET(void)
{
    uint32_t reg = PWM_PWM11_DEADTIME__GET();
    reg = (reg & PWM_PWM11_DEADTIME__PWM11_DF__Msk);
    reg = (reg >> PWM_PWM11_DEADTIME__PWM11_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM11_DEADTIME__PWM11_DF__MODIFY() modifies PWM11_DEADTIME.PWM11_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM11_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM11_DEADTIME
 * @param bf_value new value for PWM11_DEADTIME.PWM11_DF
 * @return new value of PWM.PWM11_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM11_DEADTIME__PWM11_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM11_DEADTIME__PWM11_DF__Msk);
    reg = (reg | (PWM_PWM11_DEADTIME__PWM11_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM11_DEADTIME__PWM11_DF__EXTRACT() extracts PWM11_DEADTIME.PWM11_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM11_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM11_DEADTIME
 * @return current value of PWM11_DEADTIME.PWM11_DF
 */
__PWM_INLINE uint32_t PWM_PWM11_DEADTIME__PWM11_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM11_DEADTIME__PWM11_DF__Msk);
    reg = (reg >> PWM_PWM11_DEADTIME__PWM11_DF__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM11_DEADTIME.PWM11_DR ---------------------- */

/**
<pre>
  PWM.PWM11_DEADTIME.PWM11_DR:

    PWM11 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm11_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm11_dr[7:0] = PWM_DEADTIME[175:168]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM11_DEADTIME__PWM11_DR__Pos                       0                                                                      /*!< Right-most bit position of pwm11_dr in PWM.PWM11_DEADTIME */
#define PWM_PWM11_DEADTIME__PWM11_DR__Msk                       (0x000000FFUL << PWM_PWM11_DEADTIME__PWM11_DR__Pos)                    /*!< Mask for pwm11_dr in PWM.PWM11_DEADTIME */
#define PWM_PWM11_DEADTIME__PWM11_DR__Shift(v)                  (((v) << PWM_PWM11_DEADTIME__PWM11_DR__Pos) & PWM_PWM11_DEADTIME__PWM11_DR__Msk) /*!< Shift value 'v' into pwm11_dr and mask 'v' to fit it into pwm11_dr field */

/** PWM_PWM11_DEADTIME__PWM11_DR__SET() sets PWM11_DEADTIME.PWM11_DR to given value.
 *
 * When writing to PWM11_DEADTIME.PWM11_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM11_DEADTIME.PWM11_DR
 */
__PWM_INLINE void PWM_PWM11_DEADTIME__PWM11_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM11_DEADTIME__GET();
    reg = (reg & ~PWM_PWM11_DEADTIME__PWM11_DR__Msk);
    reg = (reg | (PWM_PWM11_DEADTIME__PWM11_DR__Shift((uint32_t)bf_value)));
    PWM_PWM11_DEADTIME__SET(reg);
}

/** PWM_PWM11_DEADTIME__PWM11_DR__GET() gets PWM11_DEADTIME.PWM11_DR's current value.
 *
 * When reading from PWM11_DEADTIME.PWM11_DR, this is recommended to use.
 *
 * @return current value of PWM11_DEADTIME.PWM11_DR
 */
__PWM_INLINE uint32_t PWM_PWM11_DEADTIME__PWM11_DR__GET(void)
{
    uint32_t reg = PWM_PWM11_DEADTIME__GET();
    reg = (reg & PWM_PWM11_DEADTIME__PWM11_DR__Msk);
    reg = (reg >> PWM_PWM11_DEADTIME__PWM11_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM11_DEADTIME__PWM11_DR__MODIFY() modifies PWM11_DEADTIME.PWM11_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM11_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM11_DEADTIME
 * @param bf_value new value for PWM11_DEADTIME.PWM11_DR
 * @return new value of PWM.PWM11_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM11_DEADTIME__PWM11_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM11_DEADTIME__PWM11_DR__Msk);
    reg = (reg | (PWM_PWM11_DEADTIME__PWM11_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM11_DEADTIME__PWM11_DR__EXTRACT() extracts PWM11_DEADTIME.PWM11_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM11_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM11_DEADTIME
 * @return current value of PWM11_DEADTIME.PWM11_DR
 */
__PWM_INLINE uint32_t PWM_PWM11_DEADTIME__PWM11_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM11_DEADTIME__PWM11_DR__Msk);
    reg = (reg >> PWM_PWM11_DEADTIME__PWM11_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       PWM12_DEADTIME member of PWM_t                       */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM12_DEADTIME__ADDRESS returns the address of member PWM12_DEADTIME.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM12_DEADTIME
 */
__PWM_INLINE uint32_t* __PWM_PWM12_DEADTIME__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM12_DEADTIME)));
}

/** PWM_PWM12_DEADTIME__SET() sets PWM12_DEADTIME to given value.
 *
 * When writing to PWM12_DEADTIME, this is mandatory to use.
 *
 * @param value new value for PWM12_DEADTIME
 */
__PWM_INLINE void PWM_PWM12_DEADTIME__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM12_DEADTIME__ADDRESS(), value);
}

/** PWM_PWM12_DEADTIME__GET() gets PWM12_DEADTIME's current value.
 *
 * When reading from PWM12_DEADTIME, this is mandatory to use.
 *
 * @return current value of PWM12_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM12_DEADTIME__GET(void)
{
    return HAL_GET32(__PWM_PWM12_DEADTIME__ADDRESS());
}

/* ---------------------- PWM.PWM12_DEADTIME.PWM12_DF ---------------------- */

/**
<pre>
  PWM.PWM12_DEADTIME.PWM12_DF:

    PWM12 falling edge delay (dead) time from T1 or T2.  Mapping of the falling edge to T1 or T2 defined by pwm12_fall_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm12_df[7:0] = PWM_DEADTIME[181:176]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM12_DEADTIME__PWM12_DF__Pos                       8                                                                      /*!< Right-most bit position of pwm12_df in PWM.PWM12_DEADTIME */
#define PWM_PWM12_DEADTIME__PWM12_DF__Msk                       (0x000000FFUL << PWM_PWM12_DEADTIME__PWM12_DF__Pos)                    /*!< Mask for pwm12_df in PWM.PWM12_DEADTIME */
#define PWM_PWM12_DEADTIME__PWM12_DF__Shift(v)                  (((v) << PWM_PWM12_DEADTIME__PWM12_DF__Pos) & PWM_PWM12_DEADTIME__PWM12_DF__Msk) /*!< Shift value 'v' into pwm12_df and mask 'v' to fit it into pwm12_df field */

/** PWM_PWM12_DEADTIME__PWM12_DF__SET() sets PWM12_DEADTIME.PWM12_DF to given value.
 *
 * When writing to PWM12_DEADTIME.PWM12_DF, this is recommended to use.
 *
 * @param bf_value new value for PWM12_DEADTIME.PWM12_DF
 */
__PWM_INLINE void PWM_PWM12_DEADTIME__PWM12_DF__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM12_DEADTIME__GET();
    reg = (reg & ~PWM_PWM12_DEADTIME__PWM12_DF__Msk);
    reg = (reg | (PWM_PWM12_DEADTIME__PWM12_DF__Shift((uint32_t)bf_value)));
    PWM_PWM12_DEADTIME__SET(reg);
}

/** PWM_PWM12_DEADTIME__PWM12_DF__GET() gets PWM12_DEADTIME.PWM12_DF's current value.
 *
 * When reading from PWM12_DEADTIME.PWM12_DF, this is recommended to use.
 *
 * @return current value of PWM12_DEADTIME.PWM12_DF
 */
__PWM_INLINE uint32_t PWM_PWM12_DEADTIME__PWM12_DF__GET(void)
{
    uint32_t reg = PWM_PWM12_DEADTIME__GET();
    reg = (reg & PWM_PWM12_DEADTIME__PWM12_DF__Msk);
    reg = (reg >> PWM_PWM12_DEADTIME__PWM12_DF__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM12_DEADTIME__PWM12_DF__MODIFY() modifies PWM12_DEADTIME.PWM12_DF.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM12_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM12_DEADTIME
 * @param bf_value new value for PWM12_DEADTIME.PWM12_DF
 * @return new value of PWM.PWM12_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM12_DEADTIME__PWM12_DF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM12_DEADTIME__PWM12_DF__Msk);
    reg = (reg | (PWM_PWM12_DEADTIME__PWM12_DF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM12_DEADTIME__PWM12_DF__EXTRACT() extracts PWM12_DEADTIME.PWM12_DF.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM12_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM12_DEADTIME
 * @return current value of PWM12_DEADTIME.PWM12_DF
 */
__PWM_INLINE uint32_t PWM_PWM12_DEADTIME__PWM12_DF__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM12_DEADTIME__PWM12_DF__Msk);
    reg = (reg >> PWM_PWM12_DEADTIME__PWM12_DF__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.PWM12_DEADTIME.PWM12_DR ---------------------- */

/**
<pre>
  PWM.PWM12_DEADTIME.PWM12_DR:

    PWM12 rising edge delay (dead) time from T1 or T2.  Mapping of the rising edge to T1 or T2 defined by pwm12_rise_sel.  In order to synchronously update all dead times simultaneously, an update to any dead time register only becomes effective after PWM12_DEADTIME is written.
    Computed from PMBus as follows:
    <start table>
    "pwm12_dr[7:0] = PWM_DEADTIME[189:182]"
    <end table>
    LSB = 1.25ns, Range = 0.0 to 318.75ns

</pre> */

#define PWM_PWM12_DEADTIME__PWM12_DR__Pos                       0                                                                      /*!< Right-most bit position of pwm12_dr in PWM.PWM12_DEADTIME */
#define PWM_PWM12_DEADTIME__PWM12_DR__Msk                       (0x000000FFUL << PWM_PWM12_DEADTIME__PWM12_DR__Pos)                    /*!< Mask for pwm12_dr in PWM.PWM12_DEADTIME */
#define PWM_PWM12_DEADTIME__PWM12_DR__Shift(v)                  (((v) << PWM_PWM12_DEADTIME__PWM12_DR__Pos) & PWM_PWM12_DEADTIME__PWM12_DR__Msk) /*!< Shift value 'v' into pwm12_dr and mask 'v' to fit it into pwm12_dr field */

/** PWM_PWM12_DEADTIME__PWM12_DR__SET() sets PWM12_DEADTIME.PWM12_DR to given value.
 *
 * When writing to PWM12_DEADTIME.PWM12_DR, this is recommended to use.
 *
 * @param bf_value new value for PWM12_DEADTIME.PWM12_DR
 */
__PWM_INLINE void PWM_PWM12_DEADTIME__PWM12_DR__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM12_DEADTIME__GET();
    reg = (reg & ~PWM_PWM12_DEADTIME__PWM12_DR__Msk);
    reg = (reg | (PWM_PWM12_DEADTIME__PWM12_DR__Shift((uint32_t)bf_value)));
    PWM_PWM12_DEADTIME__SET(reg);
}

/** PWM_PWM12_DEADTIME__PWM12_DR__GET() gets PWM12_DEADTIME.PWM12_DR's current value.
 *
 * When reading from PWM12_DEADTIME.PWM12_DR, this is recommended to use.
 *
 * @return current value of PWM12_DEADTIME.PWM12_DR
 */
__PWM_INLINE uint32_t PWM_PWM12_DEADTIME__PWM12_DR__GET(void)
{
    uint32_t reg = PWM_PWM12_DEADTIME__GET();
    reg = (reg & PWM_PWM12_DEADTIME__PWM12_DR__Msk);
    reg = (reg >> PWM_PWM12_DEADTIME__PWM12_DR__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM12_DEADTIME__PWM12_DR__MODIFY() modifies PWM12_DEADTIME.PWM12_DR.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM12_DEADTIME.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM12_DEADTIME
 * @param bf_value new value for PWM12_DEADTIME.PWM12_DR
 * @return new value of PWM.PWM12_DEADTIME
 */
__PWM_INLINE uint32_t PWM_PWM12_DEADTIME__PWM12_DR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM12_DEADTIME__PWM12_DR__Msk);
    reg = (reg | (PWM_PWM12_DEADTIME__PWM12_DR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM12_DEADTIME__PWM12_DR__EXTRACT() extracts PWM12_DEADTIME.PWM12_DR.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM12_DEADTIME.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM12_DEADTIME
 * @return current value of PWM12_DEADTIME.PWM12_DR
 */
__PWM_INLINE uint32_t PWM_PWM12_DEADTIME__PWM12_DR__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM12_DEADTIME__PWM12_DR__Msk);
    reg = (reg >> PWM_PWM12_DEADTIME__PWM12_DR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        PWM_DUTYC_RD member of PWM_t                        */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM_DUTYC_RD__ADDRESS returns the address of member PWM_DUTYC_RD.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM_DUTYC_RD
 */
__PWM_INLINE uint32_t* __PWM_PWM_DUTYC_RD__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM_DUTYC_RD)));
}

/** PWM_PWM_DUTYC_RD__GET() gets PWM_DUTYC_RD's current value.
 *
 * When reading from PWM_DUTYC_RD, this is mandatory to use.
 *
 * @return current value of PWM_DUTYC_RD
 */
__PWM_INLINE uint32_t PWM_PWM_DUTYC_RD__GET(void)
{
    return HAL_GET32(__PWM_PWM_DUTYC_RD__ADDRESS());
}

/* --------------- PWM.PWM_DUTYC_RD.RAMP1_DUTYC_FORCE_STATUS --------------- */

/**
<pre>
  PWM.PWM_DUTYC_RD.RAMP1_DUTYC_FORCE_STATUS:

    This register bit is set when a new duty cycle force has been applied on ramp 1. It is cleared when either ramp1_force_duty_en or ramp1_force_duty changes.

</pre> */

#define PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__Pos         1                                                                      /*!< Right-most bit position of ramp1_dutyc_force_status in PWM.PWM_DUTYC_RD */
#define PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__Msk         (0x00000001UL << PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__Pos)      /*!< Mask for ramp1_dutyc_force_status in PWM.PWM_DUTYC_RD */
#define PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__Shift(v)    (((v) << PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__Pos) & PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__Msk) /*!< Shift value 'v' into ramp1_dutyc_force_status and mask 'v' to fit it into ramp1_dutyc_force_status field */

/** PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__GET() gets PWM_DUTYC_RD.RAMP1_DUTYC_FORCE_STATUS's current value.
 *
 * When reading from PWM_DUTYC_RD.RAMP1_DUTYC_FORCE_STATUS, this is recommended to use.
 *
 * @return current value of PWM_DUTYC_RD.RAMP1_DUTYC_FORCE_STATUS
 */
__PWM_INLINE uint32_t PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__GET(void)
{
    uint32_t reg = PWM_PWM_DUTYC_RD__GET();
    reg = (reg & PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__Msk);
    reg = (reg >> PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__EXTRACT() extracts PWM_DUTYC_RD.RAMP1_DUTYC_FORCE_STATUS.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_DUTYC_RD.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_DUTYC_RD
 * @return current value of PWM_DUTYC_RD.RAMP1_DUTYC_FORCE_STATUS
 */
__PWM_INLINE uint32_t PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__Msk);
    reg = (reg >> PWM_PWM_DUTYC_RD__RAMP1_DUTYC_FORCE_STATUS__Pos);
    return (uint32_t)reg;
}

/* --------------- PWM.PWM_DUTYC_RD.RAMP0_DUTYC_FORCE_STATUS --------------- */

/**
<pre>
  PWM.PWM_DUTYC_RD.RAMP0_DUTYC_FORCE_STATUS:

    This register bit is set when a new duty cycle force has been applied on ramp 0. It is cleared when either ramp0_force_duty_en or ramp0_force_duty changes.

</pre> */

#define PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__Pos         0                                                                      /*!< Right-most bit position of ramp0_dutyc_force_status in PWM.PWM_DUTYC_RD */
#define PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__Msk         (0x00000001UL << PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__Pos)      /*!< Mask for ramp0_dutyc_force_status in PWM.PWM_DUTYC_RD */
#define PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__Shift(v)    (((v) << PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__Pos) & PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__Msk) /*!< Shift value 'v' into ramp0_dutyc_force_status and mask 'v' to fit it into ramp0_dutyc_force_status field */

/** PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__GET() gets PWM_DUTYC_RD.RAMP0_DUTYC_FORCE_STATUS's current value.
 *
 * When reading from PWM_DUTYC_RD.RAMP0_DUTYC_FORCE_STATUS, this is recommended to use.
 *
 * @return current value of PWM_DUTYC_RD.RAMP0_DUTYC_FORCE_STATUS
 */
__PWM_INLINE uint32_t PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__GET(void)
{
    uint32_t reg = PWM_PWM_DUTYC_RD__GET();
    reg = (reg & PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__Msk);
    reg = (reg >> PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__EXTRACT() extracts PWM_DUTYC_RD.RAMP0_DUTYC_FORCE_STATUS.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_DUTYC_RD.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_DUTYC_RD
 * @return current value of PWM_DUTYC_RD.RAMP0_DUTYC_FORCE_STATUS
 */
__PWM_INLINE uint32_t PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__Msk);
    reg = (reg >> PWM_PWM_DUTYC_RD__RAMP0_DUTYC_FORCE_STATUS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          CAL_DONE member of PWM_t                          */
/* -------------------------------------------------------------------------- */

/** __PWM_CAL_DONE__ADDRESS returns the address of member CAL_DONE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CAL_DONE
 */
__PWM_INLINE uint32_t* __PWM_CAL_DONE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, CAL_DONE)));
}

/** PWM_CAL_DONE__GET() gets CAL_DONE's current value.
 *
 * When reading from CAL_DONE, this is mandatory to use.
 *
 * @return current value of CAL_DONE
 */
__PWM_INLINE uint32_t PWM_CAL_DONE__GET(void)
{
    return HAL_GET32(__PWM_CAL_DONE__ADDRESS());
}

/* ----------------------- PWM.CAL_DONE.CAL_ALL_DONE ----------------------- */

/**
<pre>
  PWM.CAL_DONE.CAL_ALL_DONE:

    This register bit is set when the initial current sense calibration is complete.  Current sense calibration is performed continuously after the first output enable after a VDD power up.

</pre> */

#define PWM_CAL_DONE__CAL_ALL_DONE__Pos                         0                                                                      /*!< Right-most bit position of cal_all_done in PWM.CAL_DONE */
#define PWM_CAL_DONE__CAL_ALL_DONE__Msk                         (0x00000001UL << PWM_CAL_DONE__CAL_ALL_DONE__Pos)                      /*!< Mask for cal_all_done in PWM.CAL_DONE */
#define PWM_CAL_DONE__CAL_ALL_DONE__Shift(v)                    (((v) << PWM_CAL_DONE__CAL_ALL_DONE__Pos) & PWM_CAL_DONE__CAL_ALL_DONE__Msk) /*!< Shift value 'v' into cal_all_done and mask 'v' to fit it into cal_all_done field */

/** PWM_CAL_DONE__CAL_ALL_DONE__GET() gets CAL_DONE.CAL_ALL_DONE's current value.
 *
 * When reading from CAL_DONE.CAL_ALL_DONE, this is recommended to use.
 *
 * @return current value of CAL_DONE.CAL_ALL_DONE
 */
__PWM_INLINE uint32_t PWM_CAL_DONE__CAL_ALL_DONE__GET(void)
{
    uint32_t reg = PWM_CAL_DONE__GET();
    reg = (reg & PWM_CAL_DONE__CAL_ALL_DONE__Msk);
    reg = (reg >> PWM_CAL_DONE__CAL_ALL_DONE__Pos);
    return (uint32_t)reg;
}

/** PWM_CAL_DONE__CAL_ALL_DONE__EXTRACT() extracts CAL_DONE.CAL_ALL_DONE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.CAL_DONE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.CAL_DONE
 * @return current value of CAL_DONE.CAL_ALL_DONE
 */
__PWM_INLINE uint32_t PWM_CAL_DONE__CAL_ALL_DONE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_CAL_DONE__CAL_ALL_DONE__Msk);
    reg = (reg >> PWM_CAL_DONE__CAL_ALL_DONE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          RAMP_IRQ member of PWM_t                          */
/* -------------------------------------------------------------------------- */

/** __PWM_RAMP_IRQ__ADDRESS returns the address of member RAMP_IRQ.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RAMP_IRQ
 */
__PWM_INLINE uint32_t* __PWM_RAMP_IRQ__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, RAMP_IRQ)));
}

/** PWM_RAMP_IRQ__SET() sets RAMP_IRQ to given value.
 *
 * When writing to RAMP_IRQ, this is mandatory to use.
 *
 * @param value new value for RAMP_IRQ
 */
__PWM_INLINE void PWM_RAMP_IRQ__SET(uint32_t value)
{
    HAL_SET32(__PWM_RAMP_IRQ__ADDRESS(), value);
}

/** PWM_RAMP_IRQ__GET() gets RAMP_IRQ's current value.
 *
 * When reading from RAMP_IRQ, this is mandatory to use.
 *
 * @return current value of RAMP_IRQ
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__GET(void)
{
    return HAL_GET32(__PWM_RAMP_IRQ__ADDRESS());
}

/* -------------------- PWM.RAMP_IRQ.CAL_ALL_DONE_IRQ_EN -------------------- */

/**
<pre>
  PWM.RAMP_IRQ.CAL_ALL_DONE_IRQ_EN:

    Enable for current sense calibration complete IRQ to CPU.
    <start table>
    0 "IRQ disabled"
    1 "IRQ enabled"
    <end table>

</pre> */

#define PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Pos                  26                                                                     /*!< Right-most bit position of cal_all_done_irq_en in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Msk                  (0x00000001UL << PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Pos)               /*!< Mask for cal_all_done_irq_en in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Shift(v)             (((v) << PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Pos) & PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Msk) /*!< Shift value 'v' into cal_all_done_irq_en and mask 'v' to fit it into cal_all_done_irq_en field */

/** PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__SET() sets RAMP_IRQ.CAL_ALL_DONE_IRQ_EN to given value.
 *
 * When writing to RAMP_IRQ.CAL_ALL_DONE_IRQ_EN, this is recommended to use.
 *
 * @param bf_value new value for RAMP_IRQ.CAL_ALL_DONE_IRQ_EN
 */
__PWM_INLINE void PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & ~PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Msk);
    reg = (reg | (PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Shift((uint32_t)bf_value)));
    PWM_RAMP_IRQ__SET(reg);
}

/** PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__GET() gets RAMP_IRQ.CAL_ALL_DONE_IRQ_EN's current value.
 *
 * When reading from RAMP_IRQ.CAL_ALL_DONE_IRQ_EN, this is recommended to use.
 *
 * @return current value of RAMP_IRQ.CAL_ALL_DONE_IRQ_EN
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__GET(void)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Msk);
    reg = (reg >> PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__MODIFY() modifies RAMP_IRQ.CAL_ALL_DONE_IRQ_EN.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_IRQ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @param bf_value new value for RAMP_IRQ.CAL_ALL_DONE_IRQ_EN
 * @return new value of PWM.RAMP_IRQ
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Msk);
    reg = (reg | (PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__EXTRACT() extracts RAMP_IRQ.CAL_ALL_DONE_IRQ_EN.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_IRQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @return current value of RAMP_IRQ.CAL_ALL_DONE_IRQ_EN
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Msk);
    reg = (reg >> PWM_RAMP_IRQ__CAL_ALL_DONE_IRQ_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.RAMP_IRQ.RAMP1_IRQ_RATE ---------------------- */

/**
<pre>
  PWM.RAMP_IRQ.RAMP1_IRQ_RATE:

    Defines frequency of interrupts selected by ramp1_t1(2)_irq_sel.
    <start table>
    0 "every Tswitch" 4 "every 16 Tswitch"
    1 "every 2 Tswitch" 5 "every 32 Tswitch"
    2 "every 4 Tswitch" 6 "every 64 Tswitch"
    3 "every 8 Tswitch" 7 "every 64 Tswitch"
    <end table>

</pre> */

#define PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Pos                       23                                                                     /*!< Right-most bit position of ramp1_irq_rate in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Msk                       (0x00000007UL << PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Pos)                    /*!< Mask for ramp1_irq_rate in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Shift(v)                  (((v) << PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Pos) & PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Msk) /*!< Shift value 'v' into ramp1_irq_rate and mask 'v' to fit it into ramp1_irq_rate field */

/** PWM_RAMP_IRQ__RAMP1_IRQ_RATE__SET() sets RAMP_IRQ.RAMP1_IRQ_RATE to given value.
 *
 * When writing to RAMP_IRQ.RAMP1_IRQ_RATE, this is recommended to use.
 *
 * @param bf_value new value for RAMP_IRQ.RAMP1_IRQ_RATE
 */
__PWM_INLINE void PWM_RAMP_IRQ__RAMP1_IRQ_RATE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & ~PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Shift((uint32_t)bf_value)));
    PWM_RAMP_IRQ__SET(reg);
}

/** PWM_RAMP_IRQ__RAMP1_IRQ_RATE__GET() gets RAMP_IRQ.RAMP1_IRQ_RATE's current value.
 *
 * When reading from RAMP_IRQ.RAMP1_IRQ_RATE, this is recommended to use.
 *
 * @return current value of RAMP_IRQ.RAMP1_IRQ_RATE
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_IRQ_RATE__GET(void)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_IRQ__RAMP1_IRQ_RATE__MODIFY() modifies RAMP_IRQ.RAMP1_IRQ_RATE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_IRQ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @param bf_value new value for RAMP_IRQ.RAMP1_IRQ_RATE
 * @return new value of PWM.RAMP_IRQ
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_IRQ_RATE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_IRQ__RAMP1_IRQ_RATE__EXTRACT() extracts RAMP_IRQ.RAMP1_IRQ_RATE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_IRQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @return current value of RAMP_IRQ.RAMP1_IRQ_RATE
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_IRQ_RATE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP1_IRQ_RATE__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.RAMP_IRQ.RAMP1_IRQ_PHASE ---------------------- */

/**
<pre>
  PWM.RAMP_IRQ.RAMP1_IRQ_PHASE:

    Defines interrupt phase with respect to the internal PWM ramp phase when ramp1_t1__irq_sel=4.
    <start table>
    "IRQ Phase = (ramp1_irq_phase[3:0] / 16) * 360 degrees"
    <end table>
    LSB = 22.5 degrees, Range = 0.0 to 337.5 degrees

</pre> */

#define PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Pos                      19                                                                     /*!< Right-most bit position of ramp1_irq_phase in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Msk                      (0x0000000FUL << PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Pos)                   /*!< Mask for ramp1_irq_phase in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Shift(v)                 (((v) << PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Pos) & PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Msk) /*!< Shift value 'v' into ramp1_irq_phase and mask 'v' to fit it into ramp1_irq_phase field */

/** PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__SET() sets RAMP_IRQ.RAMP1_IRQ_PHASE to given value.
 *
 * When writing to RAMP_IRQ.RAMP1_IRQ_PHASE, this is recommended to use.
 *
 * @param bf_value new value for RAMP_IRQ.RAMP1_IRQ_PHASE
 */
__PWM_INLINE void PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & ~PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Shift((uint32_t)bf_value)));
    PWM_RAMP_IRQ__SET(reg);
}

/** PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__GET() gets RAMP_IRQ.RAMP1_IRQ_PHASE's current value.
 *
 * When reading from RAMP_IRQ.RAMP1_IRQ_PHASE, this is recommended to use.
 *
 * @return current value of RAMP_IRQ.RAMP1_IRQ_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__GET(void)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__MODIFY() modifies RAMP_IRQ.RAMP1_IRQ_PHASE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_IRQ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @param bf_value new value for RAMP_IRQ.RAMP1_IRQ_PHASE
 * @return new value of PWM.RAMP_IRQ
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__EXTRACT() extracts RAMP_IRQ.RAMP1_IRQ_PHASE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_IRQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @return current value of RAMP_IRQ.RAMP1_IRQ_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP1_IRQ_PHASE__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.RAMP_IRQ.RAMP1_T2_IRQ_SEL --------------------- */

/**
<pre>
  PWM.RAMP_IRQ.RAMP1_T2_IRQ_SEL:

    PWM Ramp 1 T2 Interrupt (IRQ) select.
    <start table_with_header>
    [2:0] "IRQ Trigger"
    0 "disabled"
    1 "T2"
    2 "T2 even"
    3 "T2 odd"
    4-7 "Vrect falling edge"
    <end table>

</pre> */

#define PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Pos                     16                                                                     /*!< Right-most bit position of ramp1_t2_irq_sel in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Msk                     (0x00000007UL << PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Pos)                  /*!< Mask for ramp1_t2_irq_sel in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Shift(v)                (((v) << PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Pos) & PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Msk) /*!< Shift value 'v' into ramp1_t2_irq_sel and mask 'v' to fit it into ramp1_t2_irq_sel field */

/** PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__SET() sets RAMP_IRQ.RAMP1_T2_IRQ_SEL to given value.
 *
 * When writing to RAMP_IRQ.RAMP1_T2_IRQ_SEL, this is recommended to use.
 *
 * @param bf_value new value for RAMP_IRQ.RAMP1_T2_IRQ_SEL
 */
__PWM_INLINE void PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & ~PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Shift((uint32_t)bf_value)));
    PWM_RAMP_IRQ__SET(reg);
}

/** PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__GET() gets RAMP_IRQ.RAMP1_T2_IRQ_SEL's current value.
 *
 * When reading from RAMP_IRQ.RAMP1_T2_IRQ_SEL, this is recommended to use.
 *
 * @return current value of RAMP_IRQ.RAMP1_T2_IRQ_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__GET(void)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__MODIFY() modifies RAMP_IRQ.RAMP1_T2_IRQ_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_IRQ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @param bf_value new value for RAMP_IRQ.RAMP1_T2_IRQ_SEL
 * @return new value of PWM.RAMP_IRQ
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__EXTRACT() extracts RAMP_IRQ.RAMP1_T2_IRQ_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_IRQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @return current value of RAMP_IRQ.RAMP1_T2_IRQ_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP1_T2_IRQ_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.RAMP_IRQ.RAMP1_T1_IRQ_SEL --------------------- */

/**
<pre>
  PWM.RAMP_IRQ.RAMP1_T1_IRQ_SEL:

    PWM Ramp 1 T1 Interrupt (IRQ) select.
    <start table_with_header>
    [2:0] "IRQ Trigger"
    0 "disabled"
    1 "T1"
    2 "T1 even"
    3 "T1 odd"
    4-7 "Phase set by ramp0_irq_phase[3:0]"
    <end table>

</pre> */

#define PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Pos                     13                                                                     /*!< Right-most bit position of ramp1_t1_irq_sel in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Msk                     (0x00000007UL << PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Pos)                  /*!< Mask for ramp1_t1_irq_sel in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Shift(v)                (((v) << PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Pos) & PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Msk) /*!< Shift value 'v' into ramp1_t1_irq_sel and mask 'v' to fit it into ramp1_t1_irq_sel field */

/** PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__SET() sets RAMP_IRQ.RAMP1_T1_IRQ_SEL to given value.
 *
 * When writing to RAMP_IRQ.RAMP1_T1_IRQ_SEL, this is recommended to use.
 *
 * @param bf_value new value for RAMP_IRQ.RAMP1_T1_IRQ_SEL
 */
__PWM_INLINE void PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & ~PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Shift((uint32_t)bf_value)));
    PWM_RAMP_IRQ__SET(reg);
}

/** PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__GET() gets RAMP_IRQ.RAMP1_T1_IRQ_SEL's current value.
 *
 * When reading from RAMP_IRQ.RAMP1_T1_IRQ_SEL, this is recommended to use.
 *
 * @return current value of RAMP_IRQ.RAMP1_T1_IRQ_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__GET(void)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__MODIFY() modifies RAMP_IRQ.RAMP1_T1_IRQ_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_IRQ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @param bf_value new value for RAMP_IRQ.RAMP1_T1_IRQ_SEL
 * @return new value of PWM.RAMP_IRQ
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__EXTRACT() extracts RAMP_IRQ.RAMP1_T1_IRQ_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_IRQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @return current value of RAMP_IRQ.RAMP1_T1_IRQ_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP1_T1_IRQ_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.RAMP_IRQ.RAMP0_IRQ_RATE ---------------------- */

/**
<pre>
  PWM.RAMP_IRQ.RAMP0_IRQ_RATE:

    Defines frequency of interrupts selected by ramp0_t1(2)_irq_sel.
    <start table>
    0 "every Tswitch" 4 "every 16 Tswitch"
    1 "every 2 Tswitch" 5 "every 32 Tswitch"
    2 "every 4 Tswitch" 6 "every 64 Tswitch"
    3 "every 8 Tswitch" 7 "every 64 Tswitch"
    <end table>

</pre> */

#define PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Pos                       10                                                                     /*!< Right-most bit position of ramp0_irq_rate in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Msk                       (0x00000007UL << PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Pos)                    /*!< Mask for ramp0_irq_rate in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Shift(v)                  (((v) << PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Pos) & PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Msk) /*!< Shift value 'v' into ramp0_irq_rate and mask 'v' to fit it into ramp0_irq_rate field */

/** PWM_RAMP_IRQ__RAMP0_IRQ_RATE__SET() sets RAMP_IRQ.RAMP0_IRQ_RATE to given value.
 *
 * When writing to RAMP_IRQ.RAMP0_IRQ_RATE, this is recommended to use.
 *
 * @param bf_value new value for RAMP_IRQ.RAMP0_IRQ_RATE
 */
__PWM_INLINE void PWM_RAMP_IRQ__RAMP0_IRQ_RATE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & ~PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Shift((uint32_t)bf_value)));
    PWM_RAMP_IRQ__SET(reg);
}

/** PWM_RAMP_IRQ__RAMP0_IRQ_RATE__GET() gets RAMP_IRQ.RAMP0_IRQ_RATE's current value.
 *
 * When reading from RAMP_IRQ.RAMP0_IRQ_RATE, this is recommended to use.
 *
 * @return current value of RAMP_IRQ.RAMP0_IRQ_RATE
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_IRQ_RATE__GET(void)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_IRQ__RAMP0_IRQ_RATE__MODIFY() modifies RAMP_IRQ.RAMP0_IRQ_RATE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_IRQ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @param bf_value new value for RAMP_IRQ.RAMP0_IRQ_RATE
 * @return new value of PWM.RAMP_IRQ
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_IRQ_RATE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_IRQ__RAMP0_IRQ_RATE__EXTRACT() extracts RAMP_IRQ.RAMP0_IRQ_RATE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_IRQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @return current value of RAMP_IRQ.RAMP0_IRQ_RATE
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_IRQ_RATE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP0_IRQ_RATE__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PWM.RAMP_IRQ.RAMP0_IRQ_PHASE ---------------------- */

/**
<pre>
  PWM.RAMP_IRQ.RAMP0_IRQ_PHASE:

    Defines interrupt phase with respect to the internal PWM ramp phase when ramp0_t1__irq_sel=4.
    <start table>
    "IRQ Phase = (ramp0_irq_phase[3:0] / 16) * 360 degrees"
    <end table>
    LSB = 22.5 degrees, Range = 0.0 to 337.5 degrees

</pre> */

#define PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Pos                      6                                                                      /*!< Right-most bit position of ramp0_irq_phase in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Msk                      (0x0000000FUL << PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Pos)                   /*!< Mask for ramp0_irq_phase in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Shift(v)                 (((v) << PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Pos) & PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Msk) /*!< Shift value 'v' into ramp0_irq_phase and mask 'v' to fit it into ramp0_irq_phase field */

/** PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__SET() sets RAMP_IRQ.RAMP0_IRQ_PHASE to given value.
 *
 * When writing to RAMP_IRQ.RAMP0_IRQ_PHASE, this is recommended to use.
 *
 * @param bf_value new value for RAMP_IRQ.RAMP0_IRQ_PHASE
 */
__PWM_INLINE void PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & ~PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Shift((uint32_t)bf_value)));
    PWM_RAMP_IRQ__SET(reg);
}

/** PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__GET() gets RAMP_IRQ.RAMP0_IRQ_PHASE's current value.
 *
 * When reading from RAMP_IRQ.RAMP0_IRQ_PHASE, this is recommended to use.
 *
 * @return current value of RAMP_IRQ.RAMP0_IRQ_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__GET(void)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__MODIFY() modifies RAMP_IRQ.RAMP0_IRQ_PHASE.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_IRQ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @param bf_value new value for RAMP_IRQ.RAMP0_IRQ_PHASE
 * @return new value of PWM.RAMP_IRQ
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__EXTRACT() extracts RAMP_IRQ.RAMP0_IRQ_PHASE.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_IRQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @return current value of RAMP_IRQ.RAMP0_IRQ_PHASE
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP0_IRQ_PHASE__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.RAMP_IRQ.RAMP0_T2_IRQ_SEL --------------------- */

/**
<pre>
  PWM.RAMP_IRQ.RAMP0_T2_IRQ_SEL:

    PWM Ramp 0 T2 Interrupt (IRQ) select.
    <start table_with_header>
    [2:0] "IRQ Trigger"
    0 "disabled"
    1 "T2"
    2 "T2 even"
    3 "T2 odd"
    4-7 "Vrect falling edge"
    <end table>

</pre> */

#define PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Pos                     3                                                                      /*!< Right-most bit position of ramp0_t2_irq_sel in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Msk                     (0x00000007UL << PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Pos)                  /*!< Mask for ramp0_t2_irq_sel in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Shift(v)                (((v) << PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Pos) & PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Msk) /*!< Shift value 'v' into ramp0_t2_irq_sel and mask 'v' to fit it into ramp0_t2_irq_sel field */

/** PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__SET() sets RAMP_IRQ.RAMP0_T2_IRQ_SEL to given value.
 *
 * When writing to RAMP_IRQ.RAMP0_T2_IRQ_SEL, this is recommended to use.
 *
 * @param bf_value new value for RAMP_IRQ.RAMP0_T2_IRQ_SEL
 */
__PWM_INLINE void PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & ~PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Shift((uint32_t)bf_value)));
    PWM_RAMP_IRQ__SET(reg);
}

/** PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__GET() gets RAMP_IRQ.RAMP0_T2_IRQ_SEL's current value.
 *
 * When reading from RAMP_IRQ.RAMP0_T2_IRQ_SEL, this is recommended to use.
 *
 * @return current value of RAMP_IRQ.RAMP0_T2_IRQ_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__GET(void)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__MODIFY() modifies RAMP_IRQ.RAMP0_T2_IRQ_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_IRQ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @param bf_value new value for RAMP_IRQ.RAMP0_T2_IRQ_SEL
 * @return new value of PWM.RAMP_IRQ
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__EXTRACT() extracts RAMP_IRQ.RAMP0_T2_IRQ_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_IRQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @return current value of RAMP_IRQ.RAMP0_T2_IRQ_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP0_T2_IRQ_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- PWM.RAMP_IRQ.RAMP0_T1_IRQ_SEL --------------------- */

/**
<pre>
  PWM.RAMP_IRQ.RAMP0_T1_IRQ_SEL:

    PWM Ramp 0 T1 Interrupt (IRQ) select.
    <start table_with_header>
    [2:0] "IRQ Trigger"
    0 "disabled"
    1 "T1"
    2 "T1 even"
    3 "T1 odd"
    4-7 "Phase set by ramp0_irq_phase[3:0]"
    <end table>

</pre> */

#define PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Pos                     0                                                                      /*!< Right-most bit position of ramp0_t1_irq_sel in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Msk                     (0x00000007UL << PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Pos)                  /*!< Mask for ramp0_t1_irq_sel in PWM.RAMP_IRQ */
#define PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Shift(v)                (((v) << PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Pos) & PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Msk) /*!< Shift value 'v' into ramp0_t1_irq_sel and mask 'v' to fit it into ramp0_t1_irq_sel field */

/** PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__SET() sets RAMP_IRQ.RAMP0_T1_IRQ_SEL to given value.
 *
 * When writing to RAMP_IRQ.RAMP0_T1_IRQ_SEL, this is recommended to use.
 *
 * @param bf_value new value for RAMP_IRQ.RAMP0_T1_IRQ_SEL
 */
__PWM_INLINE void PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & ~PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Shift((uint32_t)bf_value)));
    PWM_RAMP_IRQ__SET(reg);
}

/** PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__GET() gets RAMP_IRQ.RAMP0_T1_IRQ_SEL's current value.
 *
 * When reading from RAMP_IRQ.RAMP0_T1_IRQ_SEL, this is recommended to use.
 *
 * @return current value of RAMP_IRQ.RAMP0_T1_IRQ_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__GET(void)
{
    uint32_t reg = PWM_RAMP_IRQ__GET();
    reg = (reg & PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Pos);
    return (uint32_t)reg;
}

/** PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__MODIFY() modifies RAMP_IRQ.RAMP0_T1_IRQ_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PWM.RAMP_IRQ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @param bf_value new value for RAMP_IRQ.RAMP0_T1_IRQ_SEL
 * @return new value of PWM.RAMP_IRQ
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Msk);
    reg = (reg | (PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__EXTRACT() extracts RAMP_IRQ.RAMP0_T1_IRQ_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.RAMP_IRQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.RAMP_IRQ
 * @return current value of RAMP_IRQ.RAMP0_T1_IRQ_SEL
 */
__PWM_INLINE uint32_t PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Msk);
    reg = (reg >> PWM_RAMP_IRQ__RAMP0_T1_IRQ_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        PWM_IN_MASK member of PWM_t                        */
/* -------------------------------------------------------------------------- */

/** __PWM_PWM_IN_MASK__ADDRESS returns the address of member PWM_IN_MASK.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PWM_IN_MASK
 */
__PWM_INLINE uint32_t* __PWM_PWM_IN_MASK__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PWM_BASE_PTR() + (uint32_t)(offsetof(PWM_t, PWM_IN_MASK)));
}

/** PWM_PWM_IN_MASK__SET() sets PWM_IN_MASK to given value.
 *
 * When writing to PWM_IN_MASK, this is mandatory to use.
 *
 * @param value new value for PWM_IN_MASK
 */
__PWM_INLINE void PWM_PWM_IN_MASK__SET(uint32_t value)
{
    HAL_SET32(__PWM_PWM_IN_MASK__ADDRESS(), value);
}

/** PWM_PWM_IN_MASK__GET() gets PWM_IN_MASK's current value.
 *
 * When reading from PWM_IN_MASK, this is mandatory to use.
 *
 * @return current value of PWM_IN_MASK
 */
__PWM_INLINE uint32_t PWM_PWM_IN_MASK__GET(void)
{
    return HAL_GET32(__PWM_PWM_IN_MASK__ADDRESS());
}

/* --------------------- PWM.PWM_IN_MASK.PWM_IN_EN_MASK --------------------- */

/**
<pre>
  PWM.PWM_IN_MASK.PWM_IN_EN_MASK:

    When bit X is low, enables input buffer on PWM[X+1] input pin.  The input buffer can then be used for polling the state of the PWM output via the common.io_inputs status register.  Setting low also asserts interrupt PWM_IN_IRQ when the enabled PWM inputs are high.

</pre> */

#define PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Pos                    0                                                                      /*!< Right-most bit position of pwm_in_en_mask in PWM.PWM_IN_MASK */
#define PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Msk                    (0x00000FFFUL << PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Pos)                 /*!< Mask for pwm_in_en_mask in PWM.PWM_IN_MASK */
#define PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Shift(v)               (((v) << PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Pos) & PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Msk) /*!< Shift value 'v' into pwm_in_en_mask and mask 'v' to fit it into pwm_in_en_mask field */

/** PWM_PWM_IN_MASK__PWM_IN_EN_MASK__SET() sets PWM_IN_MASK.PWM_IN_EN_MASK to given value.
 *
 * When writing to PWM_IN_MASK.PWM_IN_EN_MASK, this is recommended to use.
 *
 * @param bf_value new value for PWM_IN_MASK.PWM_IN_EN_MASK
 */
__PWM_INLINE void PWM_PWM_IN_MASK__PWM_IN_EN_MASK__SET(uint32_t bf_value)
{
    uint32_t reg = PWM_PWM_IN_MASK__GET();
    reg = (reg & ~PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Msk);
    reg = (reg | (PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Shift((uint32_t)bf_value)));
    PWM_PWM_IN_MASK__SET(reg);
}

/** PWM_PWM_IN_MASK__PWM_IN_EN_MASK__GET() gets PWM_IN_MASK.PWM_IN_EN_MASK's current value.
 *
 * When reading from PWM_IN_MASK.PWM_IN_EN_MASK, this is recommended to use.
 *
 * @return current value of PWM_IN_MASK.PWM_IN_EN_MASK
 */
__PWM_INLINE uint32_t PWM_PWM_IN_MASK__PWM_IN_EN_MASK__GET(void)
{
    uint32_t reg = PWM_PWM_IN_MASK__GET();
    reg = (reg & PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Msk);
    reg = (reg >> PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Pos);
    return (uint32_t)reg;
}

/** PWM_PWM_IN_MASK__PWM_IN_EN_MASK__MODIFY() modifies PWM_IN_MASK.PWM_IN_EN_MASK.
 *
 * This is recommended to use when setting more than one bitfield of PWM.PWM_IN_MASK.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PWM.PWM_IN_MASK
 * @param bf_value new value for PWM_IN_MASK.PWM_IN_EN_MASK
 * @return new value of PWM.PWM_IN_MASK
 */
__PWM_INLINE uint32_t PWM_PWM_IN_MASK__PWM_IN_EN_MASK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Msk);
    reg = (reg | (PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Shift((uint32_t)bf_value)));
    return reg;
}

/** PWM_PWM_IN_MASK__PWM_IN_EN_MASK__EXTRACT() extracts PWM_IN_MASK.PWM_IN_EN_MASK.
 *
 * This is recommended to use when extracting more than one bitfield from PWM.PWM_IN_MASK.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PWM.PWM_IN_MASK
 * @return current value of PWM_IN_MASK.PWM_IN_EN_MASK
 */
__PWM_INLINE uint32_t PWM_PWM_IN_MASK__PWM_IN_EN_MASK__EXTRACT(uint32_t reg)
{
    reg = (reg & PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Msk);
    reg = (reg >> PWM_PWM_IN_MASK__PWM_IN_EN_MASK__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group pwm block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_PWM_H_ */
