/**
 * @file     shasta_hal_tsen.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_TSEN_H_
#define _SHASTA_HAL_TSEN_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup tsen
 * @{
 */

#if defined ( __CC_ARM )
#define __TSEN_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __TSEN_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __TSEN_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __TSEN_INLINE  static inline
#endif

/** register file of the tsen block.
 */
typedef struct _TSEN_s
{
    volatile        uint32_t        TSEN_EN                     ; /*!< (@0x00000000) Telemetry Sense (TS) ADC PRISEN measurement enable.  When enabled, the TS ADC will measure the PRISEN input when selected by ts_muxmode and tx_muxctrl2.  Wh...(more) */
    volatile        uint32_t        TSEN_PTAT1                  ; /*!< (@0x00000004) Not used */
    volatile        uint32_t        TSEN_PTAT2                  ; /*!< (@0x00000008) Internal temperature sense (ITSEN) 0C code.  Internal temperature computed as: <start table> "Int. Temp. = (ADC - 0C_code) * pwl_slope + temp_trim" <end tab...(more) */
    volatile        uint32_t        TSEN_VIN                    ; /*!< (@0x0000000C) Telemetry sense ADC PRISEN input voltage (Vin) piecewise linear slope term.  Vin computed as: <start table> "Vin = ADC * vin_pwl_slope + vin_trim" <end tabl...(more) */
    volatile        uint32_t        TSEN_XV_DONE                ; /*!< (@0x00000010) Telemetry sense ADC XADDR1,2 resistor pinset measurement complete status. <start table> 0 "measurement not started or in progress" 1 "measurement complete" ...(more) */
    volatile        uint32_t        TSEN_PRIADC                 ; /*!< (@0x00000014) Gain and offset corrected PRISEN Telemetry Sense (TS) ADC output. */
    volatile        uint32_t        TSEN_IMNADC                 ; /*!< (@0x00000018) Gain and offset corrected IMON Telemetry Sense (TS) ADC output. */
    volatile        uint32_t        TSEN_ATSADC                 ; /*!< (@0x0000001C) Gain and offset corrected ATSEN Telemetry Sense (TS) ADC output. */
    volatile        uint32_t        TSEN_BTSADC                 ; /*!< (@0x00000020) Gain and offset corrected BTSEN Telemetry Sense (TS) ADC output. */
    volatile        uint32_t        TSEN_ITSADC                 ; /*!< (@0x00000024) Gain and offset corrected ITSEN (internal temp) Telemetry Sense (TS) ADC output. */
    volatile        uint32_t        TSEN_VRFADC                 ; /*!< (@0x00000028) Gain and offset corrected VREF (0.6V reference)Telemetry Sense (TS) ADC output. */
    volatile        uint32_t        TSEN_XV1ADC                 ; /*!< (@0x0000002C) Gain and offset corrected XADDR1 Telemetry Sense (TS) ADC output. */
    volatile        uint32_t        TSEN_XV2ADC                 ; /*!< (@0x00000030) Gain and offset corrected XADDR2 Telemetry Sense (TS) ADC output. */
    volatile        uint32_t        TSEN_ITEMP                  ; /*!< (@0x00000034) Low pass filtered internal temperature (ITSEN) measurement.  Filter BW fixed at approximately 950Hz when the ITSEN measurement is enabled via ts_muxmode and...(more) */
} TSEN_t;


#define TSEN_BASE (0x70004C00u)                                                          /*!< tsen base address */

/** __TSEN_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__TSEN_INLINE uint32_t* __TSEN_BASE_PTR(void)
{
    return (uint32_t*)(TSEN_BASE);
}


/* -------------------------------------------------------------------------- */
/*                          TSEN_EN member of TSEN_t                          */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_EN__ADDRESS returns the address of member TSEN_EN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_EN
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_EN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_EN)));
}

/** TSEN_TSEN_EN__SET() sets TSEN_EN to given value.
 *
 * When writing to TSEN_EN, this is mandatory to use.
 *
 * @param value new value for TSEN_EN
 */
__TSEN_INLINE void TSEN_TSEN_EN__SET(uint32_t value)
{
    HAL_SET32(__TSEN_TSEN_EN__ADDRESS(), value);
}

/** TSEN_TSEN_EN__GET() gets TSEN_EN's current value.
 *
 * When reading from TSEN_EN, this is mandatory to use.
 *
 * @return current value of TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_EN__ADDRESS());
}

/* ------------------------ TSEN.TSEN_EN.TS_MUXMODE ------------------------ */

/**
<pre>
  TSEN.TSEN_EN.TS_MUXMODE:

    Telemetry Sense (TS) ADC input sequence control.  When bit [2] is 0, the TS ADC input is entirely determined by the settings of ts_muxctrl1 and ts_muxctrl2.  When bit [2] is 1, MUX2 auto-sequences its input using the pattern in the table below.  If the sequence includes MUX2 input 7 (MUX1), the source in this timeslot is determined by the setting of ts_muxctrl1.
    <start table_with_header>
    [2:0] "MUX2 Input Sequencing"
    0-3 "Defined by ts_muxctrl1,2"
    4 "Auto Sequence: 1, 2, 1, 3, 1, 2, 1, 4"
    5 "Auto Sequence: 1, 5, 1, 3, 1, 7, 1, 4"
    6 "Auto Sequence: 1, 5, 2, 3, 1, 7, 2, 4"
    7 "Auto Sequence: 1, 5, 2, 3, 1, 7, 6, 4"
    <end table>

</pre> */

#define TSEN_TSEN_EN__TS_MUXMODE__Pos                           20                                                                     /*!< Right-most bit position of ts_muxmode in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_MUXMODE__Msk                           (0x00000007UL << TSEN_TSEN_EN__TS_MUXMODE__Pos)                        /*!< Mask for ts_muxmode in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_MUXMODE__Shift(v)                      (((v) << TSEN_TSEN_EN__TS_MUXMODE__Pos) & TSEN_TSEN_EN__TS_MUXMODE__Msk) /*!< Shift value 'v' into ts_muxmode and mask 'v' to fit it into ts_muxmode field */

/** TSEN_TSEN_EN__TS_MUXMODE__SET() sets TSEN_EN.TS_MUXMODE to given value.
 *
 * When writing to TSEN_EN.TS_MUXMODE, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.TS_MUXMODE
 */
__TSEN_INLINE void TSEN_TSEN_EN__TS_MUXMODE__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__TS_MUXMODE__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_MUXMODE__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__TS_MUXMODE__GET() gets TSEN_EN.TS_MUXMODE's current value.
 *
 * When reading from TSEN_EN.TS_MUXMODE, this is recommended to use.
 *
 * @return current value of TSEN_EN.TS_MUXMODE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_MUXMODE__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__TS_MUXMODE__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_MUXMODE__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__TS_MUXMODE__MODIFY() modifies TSEN_EN.TS_MUXMODE.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.TS_MUXMODE
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_MUXMODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__TS_MUXMODE__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_MUXMODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__TS_MUXMODE__EXTRACT() extracts TSEN_EN.TS_MUXMODE.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.TS_MUXMODE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_MUXMODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__TS_MUXMODE__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_MUXMODE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSEN.TSEN_EN.TS_MUXCTRL2 ------------------------ */

/**
<pre>
  TSEN.TSEN_EN.TS_MUXCTRL2:

    Telemetry Sense (TS) ADC MUX2 input source select.  The output of MUX2 is connected to the TS ADC input.  Generally this mux is auto sequenced by the TS ADC but may be overridden by setting parameter ts_tsmuxmode=0.
    <start table_with_header>
    [2:0] "Source" "[2:0]" "Source"
    0 "0.6V Reference (test only)" "4" "BTSEN"
    1 "PRISEN" "5" "XADDR1 unfiltered"
    2 "IMON" "6" "XADDR2 unfiltered"
    3 "ATSEN" "7" "MUX1 (see ts_tsmuxctrl1)"
    <end table>

</pre> */

#define TSEN_TSEN_EN__TS_MUXCTRL2__Pos                          17                                                                     /*!< Right-most bit position of ts_muxctrl2 in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_MUXCTRL2__Msk                          (0x00000007UL << TSEN_TSEN_EN__TS_MUXCTRL2__Pos)                       /*!< Mask for ts_muxctrl2 in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_MUXCTRL2__Shift(v)                     (((v) << TSEN_TSEN_EN__TS_MUXCTRL2__Pos) & TSEN_TSEN_EN__TS_MUXCTRL2__Msk) /*!< Shift value 'v' into ts_muxctrl2 and mask 'v' to fit it into ts_muxctrl2 field */

/** TSEN_TSEN_EN__TS_MUXCTRL2__SET() sets TSEN_EN.TS_MUXCTRL2 to given value.
 *
 * When writing to TSEN_EN.TS_MUXCTRL2, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.TS_MUXCTRL2
 */
__TSEN_INLINE void TSEN_TSEN_EN__TS_MUXCTRL2__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__TS_MUXCTRL2__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_MUXCTRL2__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__TS_MUXCTRL2__GET() gets TSEN_EN.TS_MUXCTRL2's current value.
 *
 * When reading from TSEN_EN.TS_MUXCTRL2, this is recommended to use.
 *
 * @return current value of TSEN_EN.TS_MUXCTRL2
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_MUXCTRL2__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__TS_MUXCTRL2__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_MUXCTRL2__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__TS_MUXCTRL2__MODIFY() modifies TSEN_EN.TS_MUXCTRL2.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.TS_MUXCTRL2
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_MUXCTRL2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__TS_MUXCTRL2__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_MUXCTRL2__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__TS_MUXCTRL2__EXTRACT() extracts TSEN_EN.TS_MUXCTRL2.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.TS_MUXCTRL2
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_MUXCTRL2__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__TS_MUXCTRL2__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_MUXCTRL2__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSEN.TSEN_EN.TS_MUXCTRL1 ------------------------ */

/**
<pre>
  TSEN.TSEN_EN.TS_MUXCTRL1:

    Telemetry Sense (TS) ADC MUX1 input source select.  The output of MUX1 is connected to MUX2 input 7.  The most common setting of this register is 0 to measure the internal temperature of the controller.
    <start table_with_header>
    [1:0] Source
    0 "Internal Temperature (ITSEN)"
    1 "60K Resistor (test only)"
    2 "XADDR1 filtered"
    3 "XADDR2 filtered"
    <end table>

</pre> */

#define TSEN_TSEN_EN__TS_MUXCTRL1__Pos                          15                                                                     /*!< Right-most bit position of ts_muxctrl1 in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_MUXCTRL1__Msk                          (0x00000003UL << TSEN_TSEN_EN__TS_MUXCTRL1__Pos)                       /*!< Mask for ts_muxctrl1 in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_MUXCTRL1__Shift(v)                     (((v) << TSEN_TSEN_EN__TS_MUXCTRL1__Pos) & TSEN_TSEN_EN__TS_MUXCTRL1__Msk) /*!< Shift value 'v' into ts_muxctrl1 and mask 'v' to fit it into ts_muxctrl1 field */

/** TSEN_TSEN_EN__TS_MUXCTRL1__SET() sets TSEN_EN.TS_MUXCTRL1 to given value.
 *
 * When writing to TSEN_EN.TS_MUXCTRL1, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.TS_MUXCTRL1
 */
__TSEN_INLINE void TSEN_TSEN_EN__TS_MUXCTRL1__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__TS_MUXCTRL1__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_MUXCTRL1__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__TS_MUXCTRL1__GET() gets TSEN_EN.TS_MUXCTRL1's current value.
 *
 * When reading from TSEN_EN.TS_MUXCTRL1, this is recommended to use.
 *
 * @return current value of TSEN_EN.TS_MUXCTRL1
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_MUXCTRL1__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__TS_MUXCTRL1__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_MUXCTRL1__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__TS_MUXCTRL1__MODIFY() modifies TSEN_EN.TS_MUXCTRL1.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.TS_MUXCTRL1
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_MUXCTRL1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__TS_MUXCTRL1__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_MUXCTRL1__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__TS_MUXCTRL1__EXTRACT() extracts TSEN_EN.TS_MUXCTRL1.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.TS_MUXCTRL1
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_MUXCTRL1__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__TS_MUXCTRL1__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_MUXCTRL1__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TSEN.TSEN_EN.XV_PINSET2_MEAS ---------------------- */

/**
<pre>
  TSEN.TSEN_EN.XV_PINSET2_MEAS:

    XADDR2 pinset measure control.  Enable when using the XADDR2 with an 8- or 16-value resistor set lookup table.
    <start table>
    0 "XADDR2 measurement disabled"
    1 "XADDR2 measurement enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__XV_PINSET2_MEAS__Pos                      14                                                                     /*!< Right-most bit position of xv_pinset2_meas in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__XV_PINSET2_MEAS__Msk                      (0x00000001UL << TSEN_TSEN_EN__XV_PINSET2_MEAS__Pos)                   /*!< Mask for xv_pinset2_meas in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__XV_PINSET2_MEAS__Shift(v)                 (((v) << TSEN_TSEN_EN__XV_PINSET2_MEAS__Pos) & TSEN_TSEN_EN__XV_PINSET2_MEAS__Msk) /*!< Shift value 'v' into xv_pinset2_meas and mask 'v' to fit it into xv_pinset2_meas field */

/** TSEN_TSEN_EN__XV_PINSET2_MEAS__SET() sets TSEN_EN.XV_PINSET2_MEAS to given value.
 *
 * When writing to TSEN_EN.XV_PINSET2_MEAS, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.XV_PINSET2_MEAS
 */
__TSEN_INLINE void TSEN_TSEN_EN__XV_PINSET2_MEAS__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__XV_PINSET2_MEAS__Msk);
    reg = (reg | (TSEN_TSEN_EN__XV_PINSET2_MEAS__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__XV_PINSET2_MEAS__GET() gets TSEN_EN.XV_PINSET2_MEAS's current value.
 *
 * When reading from TSEN_EN.XV_PINSET2_MEAS, this is recommended to use.
 *
 * @return current value of TSEN_EN.XV_PINSET2_MEAS
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__XV_PINSET2_MEAS__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__XV_PINSET2_MEAS__Msk);
    reg = (reg >> TSEN_TSEN_EN__XV_PINSET2_MEAS__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__XV_PINSET2_MEAS__MODIFY() modifies TSEN_EN.XV_PINSET2_MEAS.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.XV_PINSET2_MEAS
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__XV_PINSET2_MEAS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__XV_PINSET2_MEAS__Msk);
    reg = (reg | (TSEN_TSEN_EN__XV_PINSET2_MEAS__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__XV_PINSET2_MEAS__EXTRACT() extracts TSEN_EN.XV_PINSET2_MEAS.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.XV_PINSET2_MEAS
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__XV_PINSET2_MEAS__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__XV_PINSET2_MEAS__Msk);
    reg = (reg >> TSEN_TSEN_EN__XV_PINSET2_MEAS__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TSEN.TSEN_EN.XV_PINSET1_MEAS ---------------------- */

/**
<pre>
  TSEN.TSEN_EN.XV_PINSET1_MEAS:

    XADDR1 pinset measure control.  Enable when using the XADDR1 with an 8- or 16-value resistor set lookup table.
    <start table>
    0 "XADDR1 measurement disabled"
    1 "XADDR1 measurement enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__XV_PINSET1_MEAS__Pos                      13                                                                     /*!< Right-most bit position of xv_pinset1_meas in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__XV_PINSET1_MEAS__Msk                      (0x00000001UL << TSEN_TSEN_EN__XV_PINSET1_MEAS__Pos)                   /*!< Mask for xv_pinset1_meas in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__XV_PINSET1_MEAS__Shift(v)                 (((v) << TSEN_TSEN_EN__XV_PINSET1_MEAS__Pos) & TSEN_TSEN_EN__XV_PINSET1_MEAS__Msk) /*!< Shift value 'v' into xv_pinset1_meas and mask 'v' to fit it into xv_pinset1_meas field */

/** TSEN_TSEN_EN__XV_PINSET1_MEAS__SET() sets TSEN_EN.XV_PINSET1_MEAS to given value.
 *
 * When writing to TSEN_EN.XV_PINSET1_MEAS, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.XV_PINSET1_MEAS
 */
__TSEN_INLINE void TSEN_TSEN_EN__XV_PINSET1_MEAS__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__XV_PINSET1_MEAS__Msk);
    reg = (reg | (TSEN_TSEN_EN__XV_PINSET1_MEAS__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__XV_PINSET1_MEAS__GET() gets TSEN_EN.XV_PINSET1_MEAS's current value.
 *
 * When reading from TSEN_EN.XV_PINSET1_MEAS, this is recommended to use.
 *
 * @return current value of TSEN_EN.XV_PINSET1_MEAS
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__XV_PINSET1_MEAS__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__XV_PINSET1_MEAS__Msk);
    reg = (reg >> TSEN_TSEN_EN__XV_PINSET1_MEAS__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__XV_PINSET1_MEAS__MODIFY() modifies TSEN_EN.XV_PINSET1_MEAS.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.XV_PINSET1_MEAS
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__XV_PINSET1_MEAS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__XV_PINSET1_MEAS__Msk);
    reg = (reg | (TSEN_TSEN_EN__XV_PINSET1_MEAS__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__XV_PINSET1_MEAS__EXTRACT() extracts TSEN_EN.XV_PINSET1_MEAS.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.XV_PINSET1_MEAS
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__XV_PINSET1_MEAS__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__XV_PINSET1_MEAS__Msk);
    reg = (reg >> TSEN_TSEN_EN__XV_PINSET1_MEAS__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TSEN.TSEN_EN.XV_DECODE_SEL ----------------------- */

/**
<pre>
  TSEN.TSEN_EN.XV_DECODE_SEL:

    XValent Address Table Select.  Defines the size of the look up table used to decode the XADDR1 and XADDR2 resistor pinset values.
    <start table>
    0 "8-value table"
    1 "16-value table"
    <end table>

</pre> */

#define TSEN_TSEN_EN__XV_DECODE_SEL__Pos                        12                                                                     /*!< Right-most bit position of xv_decode_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__XV_DECODE_SEL__Msk                        (0x00000001UL << TSEN_TSEN_EN__XV_DECODE_SEL__Pos)                     /*!< Mask for xv_decode_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__XV_DECODE_SEL__Shift(v)                   (((v) << TSEN_TSEN_EN__XV_DECODE_SEL__Pos) & TSEN_TSEN_EN__XV_DECODE_SEL__Msk) /*!< Shift value 'v' into xv_decode_sel and mask 'v' to fit it into xv_decode_sel field */

/** TSEN_TSEN_EN__XV_DECODE_SEL__SET() sets TSEN_EN.XV_DECODE_SEL to given value.
 *
 * When writing to TSEN_EN.XV_DECODE_SEL, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.XV_DECODE_SEL
 */
__TSEN_INLINE void TSEN_TSEN_EN__XV_DECODE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__XV_DECODE_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__XV_DECODE_SEL__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__XV_DECODE_SEL__GET() gets TSEN_EN.XV_DECODE_SEL's current value.
 *
 * When reading from TSEN_EN.XV_DECODE_SEL, this is recommended to use.
 *
 * @return current value of TSEN_EN.XV_DECODE_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__XV_DECODE_SEL__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__XV_DECODE_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__XV_DECODE_SEL__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__XV_DECODE_SEL__MODIFY() modifies TSEN_EN.XV_DECODE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.XV_DECODE_SEL
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__XV_DECODE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__XV_DECODE_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__XV_DECODE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__XV_DECODE_SEL__EXTRACT() extracts TSEN_EN.XV_DECODE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.XV_DECODE_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__XV_DECODE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__XV_DECODE_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__XV_DECODE_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- TSEN.TSEN_EN.TS_TSIDAC_XV2_SEL --------------------- */

/**
<pre>
  TSEN.TSEN_EN.TS_TSIDAC_XV2_SEL:

    XADDR2 output current DAC enable.  This current DAC is enabled by FW during the XADDR2 resistor pinset measurement.  The current DAC should be disabled otherwise.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Pos                    11                                                                     /*!< Right-most bit position of ts_tsidac_xv2_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Msk                    (0x00000001UL << TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Pos)                 /*!< Mask for ts_tsidac_xv2_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Shift(v)               (((v) << TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Pos) & TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Msk) /*!< Shift value 'v' into ts_tsidac_xv2_sel and mask 'v' to fit it into ts_tsidac_xv2_sel field */

/** TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__SET() sets TSEN_EN.TS_TSIDAC_XV2_SEL to given value.
 *
 * When writing to TSEN_EN.TS_TSIDAC_XV2_SEL, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_XV2_SEL
 */
__TSEN_INLINE void TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__GET() gets TSEN_EN.TS_TSIDAC_XV2_SEL's current value.
 *
 * When reading from TSEN_EN.TS_TSIDAC_XV2_SEL, this is recommended to use.
 *
 * @return current value of TSEN_EN.TS_TSIDAC_XV2_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__MODIFY() modifies TSEN_EN.TS_TSIDAC_XV2_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_XV2_SEL
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__EXTRACT() extracts TSEN_EN.TS_TSIDAC_XV2_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.TS_TSIDAC_XV2_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_XV2_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- TSEN.TSEN_EN.TS_TSIDAC_XV1_SEL --------------------- */

/**
<pre>
  TSEN.TSEN_EN.TS_TSIDAC_XV1_SEL:

    XADDR1 output current DAC enable.  This current DAC is enabled by FW during the XADDR1 resistor pinset measurement.  The current DAC should be disabled otherwise.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Pos                    10                                                                     /*!< Right-most bit position of ts_tsidac_xv1_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Msk                    (0x00000001UL << TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Pos)                 /*!< Mask for ts_tsidac_xv1_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Shift(v)               (((v) << TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Pos) & TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Msk) /*!< Shift value 'v' into ts_tsidac_xv1_sel and mask 'v' to fit it into ts_tsidac_xv1_sel field */

/** TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__SET() sets TSEN_EN.TS_TSIDAC_XV1_SEL to given value.
 *
 * When writing to TSEN_EN.TS_TSIDAC_XV1_SEL, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_XV1_SEL
 */
__TSEN_INLINE void TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__GET() gets TSEN_EN.TS_TSIDAC_XV1_SEL's current value.
 *
 * When reading from TSEN_EN.TS_TSIDAC_XV1_SEL, this is recommended to use.
 *
 * @return current value of TSEN_EN.TS_TSIDAC_XV1_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__MODIFY() modifies TSEN_EN.TS_TSIDAC_XV1_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_XV1_SEL
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__EXTRACT() extracts TSEN_EN.TS_TSIDAC_XV1_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.TS_TSIDAC_XV1_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_XV1_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- TSEN.TSEN_EN.TS_TSIDAC_RES_SEL --------------------- */

/**
<pre>
  TSEN.TSEN_EN.TS_TSIDAC_RES_SEL:

    60K resistor current source enable.  This current source should be enabled during test only.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Pos                    9                                                                      /*!< Right-most bit position of ts_tsidac_res_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Msk                    (0x00000001UL << TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Pos)                 /*!< Mask for ts_tsidac_res_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Shift(v)               (((v) << TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Pos) & TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Msk) /*!< Shift value 'v' into ts_tsidac_res_sel and mask 'v' to fit it into ts_tsidac_res_sel field */

/** TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__SET() sets TSEN_EN.TS_TSIDAC_RES_SEL to given value.
 *
 * When writing to TSEN_EN.TS_TSIDAC_RES_SEL, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_RES_SEL
 */
__TSEN_INLINE void TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__GET() gets TSEN_EN.TS_TSIDAC_RES_SEL's current value.
 *
 * When reading from TSEN_EN.TS_TSIDAC_RES_SEL, this is recommended to use.
 *
 * @return current value of TSEN_EN.TS_TSIDAC_RES_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__MODIFY() modifies TSEN_EN.TS_TSIDAC_RES_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_RES_SEL
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__EXTRACT() extracts TSEN_EN.TS_TSIDAC_RES_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.TS_TSIDAC_RES_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_RES_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------- TSEN.TSEN_EN.TS_TSIDAC_IMON_SEL -------------------- */

/**
<pre>
  TSEN.TSEN_EN.TS_TSIDAC_IMON_SEL:

    IMON output current DAC enable.  This current DAC should be enabled when using the IMON pin for current sharing.  The current DAC should be disabled otherwise.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Pos                   8                                                                      /*!< Right-most bit position of ts_tsidac_imon_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Msk                   (0x00000001UL << TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Pos)                /*!< Mask for ts_tsidac_imon_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Shift(v)              (((v) << TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Pos) & TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Msk) /*!< Shift value 'v' into ts_tsidac_imon_sel and mask 'v' to fit it into ts_tsidac_imon_sel field */

/** TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__SET() sets TSEN_EN.TS_TSIDAC_IMON_SEL to given value.
 *
 * When writing to TSEN_EN.TS_TSIDAC_IMON_SEL, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_IMON_SEL
 */
__TSEN_INLINE void TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__GET() gets TSEN_EN.TS_TSIDAC_IMON_SEL's current value.
 *
 * When reading from TSEN_EN.TS_TSIDAC_IMON_SEL, this is recommended to use.
 *
 * @return current value of TSEN_EN.TS_TSIDAC_IMON_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__MODIFY() modifies TSEN_EN.TS_TSIDAC_IMON_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_IMON_SEL
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__EXTRACT() extracts TSEN_EN.TS_TSIDAC_IMON_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.TS_TSIDAC_IMON_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_IMON_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------- TSEN.TSEN_EN.TS_TSIDAC_BNTC_SEL -------------------- */

/**
<pre>
  TSEN.TSEN_EN.TS_TSIDAC_BNTC_SEL:

    BTSEN output current source enable.  This current source should be enabled when using the BTSEN input to measure an NTC or PTC temperature sense element.  The current source may be disabled to use the BTSEN input as a general purpose ADC input.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Pos                   7                                                                      /*!< Right-most bit position of ts_tsidac_bntc_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Msk                   (0x00000001UL << TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Pos)                /*!< Mask for ts_tsidac_bntc_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Shift(v)              (((v) << TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Pos) & TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Msk) /*!< Shift value 'v' into ts_tsidac_bntc_sel and mask 'v' to fit it into ts_tsidac_bntc_sel field */

/** TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__SET() sets TSEN_EN.TS_TSIDAC_BNTC_SEL to given value.
 *
 * When writing to TSEN_EN.TS_TSIDAC_BNTC_SEL, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_BNTC_SEL
 */
__TSEN_INLINE void TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__GET() gets TSEN_EN.TS_TSIDAC_BNTC_SEL's current value.
 *
 * When reading from TSEN_EN.TS_TSIDAC_BNTC_SEL, this is recommended to use.
 *
 * @return current value of TSEN_EN.TS_TSIDAC_BNTC_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__MODIFY() modifies TSEN_EN.TS_TSIDAC_BNTC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_BNTC_SEL
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__EXTRACT() extracts TSEN_EN.TS_TSIDAC_BNTC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.TS_TSIDAC_BNTC_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_BNTC_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------- TSEN.TSEN_EN.TS_TSIDAC_ANTC_SEL -------------------- */

/**
<pre>
  TSEN.TSEN_EN.TS_TSIDAC_ANTC_SEL:

    ATSEN output current source enable.  This current source should be enabled when using the ATSEN input to measure an NTC or PTC temperature sense element.  The current source may be disabled to use the ATSEN input as a general purpose ADC input.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Pos                   6                                                                      /*!< Right-most bit position of ts_tsidac_antc_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Msk                   (0x00000001UL << TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Pos)                /*!< Mask for ts_tsidac_antc_sel in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Shift(v)              (((v) << TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Pos) & TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Msk) /*!< Shift value 'v' into ts_tsidac_antc_sel and mask 'v' to fit it into ts_tsidac_antc_sel field */

/** TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__SET() sets TSEN_EN.TS_TSIDAC_ANTC_SEL to given value.
 *
 * When writing to TSEN_EN.TS_TSIDAC_ANTC_SEL, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_ANTC_SEL
 */
__TSEN_INLINE void TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__GET() gets TSEN_EN.TS_TSIDAC_ANTC_SEL's current value.
 *
 * When reading from TSEN_EN.TS_TSIDAC_ANTC_SEL, this is recommended to use.
 *
 * @return current value of TSEN_EN.TS_TSIDAC_ANTC_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__MODIFY() modifies TSEN_EN.TS_TSIDAC_ANTC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.TS_TSIDAC_ANTC_SEL
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Msk);
    reg = (reg | (TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__EXTRACT() extracts TSEN_EN.TS_TSIDAC_ANTC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.TS_TSIDAC_ANTC_SEL
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Msk);
    reg = (reg >> TSEN_TSEN_EN__TS_TSIDAC_ANTC_SEL__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TSEN.TSEN_EN.VREF_MEAS_EN ----------------------- */

/**
<pre>
  TSEN.TSEN_EN.VREF_MEAS_EN:

    Telemetry Sense (TS) ADC 0.6V Reference (VREF) measurement enable.  When enabled, the TS ADC will measure VREF when selected by ts_muxmode and tx_muxctrl2.  When disabled, no VREF measurement will occur, even if selected by ts_muxmode and ts_muxctrl2.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__VREF_MEAS_EN__Pos                         5                                                                      /*!< Right-most bit position of vref_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__VREF_MEAS_EN__Msk                         (0x00000001UL << TSEN_TSEN_EN__VREF_MEAS_EN__Pos)                      /*!< Mask for vref_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__VREF_MEAS_EN__Shift(v)                    (((v) << TSEN_TSEN_EN__VREF_MEAS_EN__Pos) & TSEN_TSEN_EN__VREF_MEAS_EN__Msk) /*!< Shift value 'v' into vref_meas_en and mask 'v' to fit it into vref_meas_en field */

/** TSEN_TSEN_EN__VREF_MEAS_EN__SET() sets TSEN_EN.VREF_MEAS_EN to given value.
 *
 * When writing to TSEN_EN.VREF_MEAS_EN, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.VREF_MEAS_EN
 */
__TSEN_INLINE void TSEN_TSEN_EN__VREF_MEAS_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__VREF_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__VREF_MEAS_EN__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__VREF_MEAS_EN__GET() gets TSEN_EN.VREF_MEAS_EN's current value.
 *
 * When reading from TSEN_EN.VREF_MEAS_EN, this is recommended to use.
 *
 * @return current value of TSEN_EN.VREF_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__VREF_MEAS_EN__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__VREF_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__VREF_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__VREF_MEAS_EN__MODIFY() modifies TSEN_EN.VREF_MEAS_EN.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.VREF_MEAS_EN
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__VREF_MEAS_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__VREF_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__VREF_MEAS_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__VREF_MEAS_EN__EXTRACT() extracts TSEN_EN.VREF_MEAS_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.VREF_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__VREF_MEAS_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__VREF_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__VREF_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TSEN.TSEN_EN.ITSEN_MEAS_EN ----------------------- */

/**
<pre>
  TSEN.TSEN_EN.ITSEN_MEAS_EN:

    Telemetry Sense (TS) ADC Internal Temperature (ITSEN) measurement enable.  When enabled, the TS ADC will measure  ITSEN when selected by ts_muxmode and tx_muxctrl2.  When disabled, no ITSEN measurement will occur, even if selected by ts_muxmode, ts_muxctrl1 and ts_muxctrl2.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__ITSEN_MEAS_EN__Pos                        4                                                                      /*!< Right-most bit position of itsen_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__ITSEN_MEAS_EN__Msk                        (0x00000001UL << TSEN_TSEN_EN__ITSEN_MEAS_EN__Pos)                     /*!< Mask for itsen_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__ITSEN_MEAS_EN__Shift(v)                   (((v) << TSEN_TSEN_EN__ITSEN_MEAS_EN__Pos) & TSEN_TSEN_EN__ITSEN_MEAS_EN__Msk) /*!< Shift value 'v' into itsen_meas_en and mask 'v' to fit it into itsen_meas_en field */

/** TSEN_TSEN_EN__ITSEN_MEAS_EN__SET() sets TSEN_EN.ITSEN_MEAS_EN to given value.
 *
 * When writing to TSEN_EN.ITSEN_MEAS_EN, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.ITSEN_MEAS_EN
 */
__TSEN_INLINE void TSEN_TSEN_EN__ITSEN_MEAS_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__ITSEN_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__ITSEN_MEAS_EN__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__ITSEN_MEAS_EN__GET() gets TSEN_EN.ITSEN_MEAS_EN's current value.
 *
 * When reading from TSEN_EN.ITSEN_MEAS_EN, this is recommended to use.
 *
 * @return current value of TSEN_EN.ITSEN_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__ITSEN_MEAS_EN__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__ITSEN_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__ITSEN_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__ITSEN_MEAS_EN__MODIFY() modifies TSEN_EN.ITSEN_MEAS_EN.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.ITSEN_MEAS_EN
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__ITSEN_MEAS_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__ITSEN_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__ITSEN_MEAS_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__ITSEN_MEAS_EN__EXTRACT() extracts TSEN_EN.ITSEN_MEAS_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.ITSEN_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__ITSEN_MEAS_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__ITSEN_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__ITSEN_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TSEN.TSEN_EN.BTSEN_MEAS_EN ----------------------- */

/**
<pre>
  TSEN.TSEN_EN.BTSEN_MEAS_EN:

    Telemetry Sense (TS) ADC BTSEN measurement enable.  When enabled, the TS ADC will measure the BTSEN input when selected by ts_muxmode and tx_muxctrl2.  When disabled, no BTSEN measurement will occur, even if selected by ts_muxmode and ts_muxctrl2.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__BTSEN_MEAS_EN__Pos                        3                                                                      /*!< Right-most bit position of btsen_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__BTSEN_MEAS_EN__Msk                        (0x00000001UL << TSEN_TSEN_EN__BTSEN_MEAS_EN__Pos)                     /*!< Mask for btsen_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__BTSEN_MEAS_EN__Shift(v)                   (((v) << TSEN_TSEN_EN__BTSEN_MEAS_EN__Pos) & TSEN_TSEN_EN__BTSEN_MEAS_EN__Msk) /*!< Shift value 'v' into btsen_meas_en and mask 'v' to fit it into btsen_meas_en field */

/** TSEN_TSEN_EN__BTSEN_MEAS_EN__SET() sets TSEN_EN.BTSEN_MEAS_EN to given value.
 *
 * When writing to TSEN_EN.BTSEN_MEAS_EN, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.BTSEN_MEAS_EN
 */
__TSEN_INLINE void TSEN_TSEN_EN__BTSEN_MEAS_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__BTSEN_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__BTSEN_MEAS_EN__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__BTSEN_MEAS_EN__GET() gets TSEN_EN.BTSEN_MEAS_EN's current value.
 *
 * When reading from TSEN_EN.BTSEN_MEAS_EN, this is recommended to use.
 *
 * @return current value of TSEN_EN.BTSEN_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__BTSEN_MEAS_EN__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__BTSEN_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__BTSEN_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__BTSEN_MEAS_EN__MODIFY() modifies TSEN_EN.BTSEN_MEAS_EN.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.BTSEN_MEAS_EN
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__BTSEN_MEAS_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__BTSEN_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__BTSEN_MEAS_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__BTSEN_MEAS_EN__EXTRACT() extracts TSEN_EN.BTSEN_MEAS_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.BTSEN_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__BTSEN_MEAS_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__BTSEN_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__BTSEN_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TSEN.TSEN_EN.ATSEN_MEAS_EN ----------------------- */

/**
<pre>
  TSEN.TSEN_EN.ATSEN_MEAS_EN:

    Telemetry Sense (TS) ADC ATSEN measurement enable.  When enabled, the TS ADC will measure the ATSEN input when selected by ts_muxmode and tx_muxctrl2.  When disabled, no ATSEN measurement will occur, even if selected by ts_muxmode and ts_muxctrl2.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__ATSEN_MEAS_EN__Pos                        2                                                                      /*!< Right-most bit position of atsen_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__ATSEN_MEAS_EN__Msk                        (0x00000001UL << TSEN_TSEN_EN__ATSEN_MEAS_EN__Pos)                     /*!< Mask for atsen_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__ATSEN_MEAS_EN__Shift(v)                   (((v) << TSEN_TSEN_EN__ATSEN_MEAS_EN__Pos) & TSEN_TSEN_EN__ATSEN_MEAS_EN__Msk) /*!< Shift value 'v' into atsen_meas_en and mask 'v' to fit it into atsen_meas_en field */

/** TSEN_TSEN_EN__ATSEN_MEAS_EN__SET() sets TSEN_EN.ATSEN_MEAS_EN to given value.
 *
 * When writing to TSEN_EN.ATSEN_MEAS_EN, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.ATSEN_MEAS_EN
 */
__TSEN_INLINE void TSEN_TSEN_EN__ATSEN_MEAS_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__ATSEN_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__ATSEN_MEAS_EN__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__ATSEN_MEAS_EN__GET() gets TSEN_EN.ATSEN_MEAS_EN's current value.
 *
 * When reading from TSEN_EN.ATSEN_MEAS_EN, this is recommended to use.
 *
 * @return current value of TSEN_EN.ATSEN_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__ATSEN_MEAS_EN__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__ATSEN_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__ATSEN_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__ATSEN_MEAS_EN__MODIFY() modifies TSEN_EN.ATSEN_MEAS_EN.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.ATSEN_MEAS_EN
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__ATSEN_MEAS_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__ATSEN_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__ATSEN_MEAS_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__ATSEN_MEAS_EN__EXTRACT() extracts TSEN_EN.ATSEN_MEAS_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.ATSEN_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__ATSEN_MEAS_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__ATSEN_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__ATSEN_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TSEN.TSEN_EN.IMON_MEAS_EN ----------------------- */

/**
<pre>
  TSEN.TSEN_EN.IMON_MEAS_EN:

    Telemetry Sense (TS) ADC IMON measurement enable.  When enabled, the TS ADC will measure the IMON input when selected by ts_muxmode and tx_muxctrl2.  When disabled, no IMON measurement will occur, even if selected by ts_muxmode and ts_muxctrl2.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__IMON_MEAS_EN__Pos                         1                                                                      /*!< Right-most bit position of imon_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__IMON_MEAS_EN__Msk                         (0x00000001UL << TSEN_TSEN_EN__IMON_MEAS_EN__Pos)                      /*!< Mask for imon_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__IMON_MEAS_EN__Shift(v)                    (((v) << TSEN_TSEN_EN__IMON_MEAS_EN__Pos) & TSEN_TSEN_EN__IMON_MEAS_EN__Msk) /*!< Shift value 'v' into imon_meas_en and mask 'v' to fit it into imon_meas_en field */

/** TSEN_TSEN_EN__IMON_MEAS_EN__SET() sets TSEN_EN.IMON_MEAS_EN to given value.
 *
 * When writing to TSEN_EN.IMON_MEAS_EN, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.IMON_MEAS_EN
 */
__TSEN_INLINE void TSEN_TSEN_EN__IMON_MEAS_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__IMON_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__IMON_MEAS_EN__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__IMON_MEAS_EN__GET() gets TSEN_EN.IMON_MEAS_EN's current value.
 *
 * When reading from TSEN_EN.IMON_MEAS_EN, this is recommended to use.
 *
 * @return current value of TSEN_EN.IMON_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__IMON_MEAS_EN__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__IMON_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__IMON_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__IMON_MEAS_EN__MODIFY() modifies TSEN_EN.IMON_MEAS_EN.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.IMON_MEAS_EN
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__IMON_MEAS_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__IMON_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__IMON_MEAS_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__IMON_MEAS_EN__EXTRACT() extracts TSEN_EN.IMON_MEAS_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.IMON_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__IMON_MEAS_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__IMON_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__IMON_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TSEN.TSEN_EN.PRISEN_MEAS_EN ---------------------- */

/**
<pre>
  TSEN.TSEN_EN.PRISEN_MEAS_EN:

    Telemetry Sense (TS) ADC PRISEN measurement enable.  When enabled, the TS ADC will measure the PRISEN input when selected by ts_muxmode and tx_muxctrl2.  When disabled, no PRISEN measurement will occur, even if selected by ts_muxmode and ts_muxctrl2.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TSEN_TSEN_EN__PRISEN_MEAS_EN__Pos                       0                                                                      /*!< Right-most bit position of prisen_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__PRISEN_MEAS_EN__Msk                       (0x00000001UL << TSEN_TSEN_EN__PRISEN_MEAS_EN__Pos)                    /*!< Mask for prisen_meas_en in TSEN.TSEN_EN */
#define TSEN_TSEN_EN__PRISEN_MEAS_EN__Shift(v)                  (((v) << TSEN_TSEN_EN__PRISEN_MEAS_EN__Pos) & TSEN_TSEN_EN__PRISEN_MEAS_EN__Msk) /*!< Shift value 'v' into prisen_meas_en and mask 'v' to fit it into prisen_meas_en field */

/** TSEN_TSEN_EN__PRISEN_MEAS_EN__SET() sets TSEN_EN.PRISEN_MEAS_EN to given value.
 *
 * When writing to TSEN_EN.PRISEN_MEAS_EN, this is recommended to use.
 *
 * @param bf_value new value for TSEN_EN.PRISEN_MEAS_EN
 */
__TSEN_INLINE void TSEN_TSEN_EN__PRISEN_MEAS_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & ~TSEN_TSEN_EN__PRISEN_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__PRISEN_MEAS_EN__Shift((uint32_t)bf_value)));
    TSEN_TSEN_EN__SET(reg);
}

/** TSEN_TSEN_EN__PRISEN_MEAS_EN__GET() gets TSEN_EN.PRISEN_MEAS_EN's current value.
 *
 * When reading from TSEN_EN.PRISEN_MEAS_EN, this is recommended to use.
 *
 * @return current value of TSEN_EN.PRISEN_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__PRISEN_MEAS_EN__GET(void)
{
    uint32_t reg = TSEN_TSEN_EN__GET();
    reg = (reg & TSEN_TSEN_EN__PRISEN_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__PRISEN_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_EN__PRISEN_MEAS_EN__MODIFY() modifies TSEN_EN.PRISEN_MEAS_EN.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @param bf_value new value for TSEN_EN.PRISEN_MEAS_EN
 * @return new value of TSEN.TSEN_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__PRISEN_MEAS_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_EN__PRISEN_MEAS_EN__Msk);
    reg = (reg | (TSEN_TSEN_EN__PRISEN_MEAS_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_EN__PRISEN_MEAS_EN__EXTRACT() extracts TSEN_EN.PRISEN_MEAS_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_EN
 * @return current value of TSEN_EN.PRISEN_MEAS_EN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_EN__PRISEN_MEAS_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_EN__PRISEN_MEAS_EN__Msk);
    reg = (reg >> TSEN_TSEN_EN__PRISEN_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_PTAT1 member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_PTAT1__ADDRESS returns the address of member TSEN_PTAT1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_PTAT1
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_PTAT1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_PTAT1)));
}

/** TSEN_TSEN_PTAT1__SET() sets TSEN_PTAT1 to given value.
 *
 * When writing to TSEN_PTAT1, this is mandatory to use.
 *
 * @param value new value for TSEN_PTAT1
 */
__TSEN_INLINE void TSEN_TSEN_PTAT1__SET(uint32_t value)
{
    HAL_SET32(__TSEN_TSEN_PTAT1__ADDRESS(), value);
}

/** TSEN_TSEN_PTAT1__GET() gets TSEN_PTAT1's current value.
 *
 * When reading from TSEN_PTAT1, this is mandatory to use.
 *
 * @return current value of TSEN_PTAT1
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT1__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_PTAT1__ADDRESS());
}

/* --------------------- TSEN.TSEN_PTAT1.PTAT_PWL_SLOPE --------------------- */

/**
<pre>
  TSEN.TSEN_PTAT1.PTAT_PWL_SLOPE:

    Internal temperature sense (ITSEN) piecewise linear slope term.  Internal temperature computed as:
    <start table>
    "Int. Temp. = (ADC - 0C_code) * pwl_slope + temp_trim"
    <end table>
    LSB = 2^-10 C/code, Range = 0 to 3.9990 C/code

</pre> */

#define TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Pos                    16                                                                     /*!< Right-most bit position of ptat_pwl_slope in TSEN.TSEN_PTAT1 */
#define TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Msk                    (0x00000FFFUL << TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Pos)                 /*!< Mask for ptat_pwl_slope in TSEN.TSEN_PTAT1 */
#define TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Shift(v)               (((v) << TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Pos) & TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Msk) /*!< Shift value 'v' into ptat_pwl_slope and mask 'v' to fit it into ptat_pwl_slope field */

/** TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__SET() sets TSEN_PTAT1.PTAT_PWL_SLOPE to given value.
 *
 * When writing to TSEN_PTAT1.PTAT_PWL_SLOPE, this is recommended to use.
 *
 * @param bf_value new value for TSEN_PTAT1.PTAT_PWL_SLOPE
 */
__TSEN_INLINE void TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_PTAT1__GET();
    reg = (reg & ~TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Msk);
    reg = (reg | (TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Shift((uint32_t)bf_value)));
    TSEN_TSEN_PTAT1__SET(reg);
}

/** TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__GET() gets TSEN_PTAT1.PTAT_PWL_SLOPE's current value.
 *
 * When reading from TSEN_PTAT1.PTAT_PWL_SLOPE, this is recommended to use.
 *
 * @return current value of TSEN_PTAT1.PTAT_PWL_SLOPE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__GET(void)
{
    uint32_t reg = TSEN_TSEN_PTAT1__GET();
    reg = (reg & TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Msk);
    reg = (reg >> TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__MODIFY() modifies TSEN_PTAT1.PTAT_PWL_SLOPE.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_PTAT1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_PTAT1
 * @param bf_value new value for TSEN_PTAT1.PTAT_PWL_SLOPE
 * @return new value of TSEN.TSEN_PTAT1
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Msk);
    reg = (reg | (TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__EXTRACT() extracts TSEN_PTAT1.PTAT_PWL_SLOPE.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_PTAT1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_PTAT1
 * @return current value of TSEN_PTAT1.PTAT_PWL_SLOPE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Msk);
    reg = (reg >> TSEN_TSEN_PTAT1__PTAT_PWL_SLOPE__Pos);
    return (uint32_t)reg;
}

/* --------------------- TSEN.TSEN_PTAT1.PTAT_TEMP_TRIM --------------------- */

/**
<pre>
  TSEN.TSEN_PTAT1.PTAT_TEMP_TRIM:

    Internal temperature sense (ITSEN) offset term. Internal temperature is computed as:
    <start table>
    "Int. Temp. = (ADC - 0C_code) * pwl_slope + temp_trim"
    <end table>
    LSB = 0.25C, Range = -32 to 31.72C

</pre> */

#define TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Pos                    8                                                                      /*!< Right-most bit position of ptat_temp_trim in TSEN.TSEN_PTAT1 */
#define TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Msk                    (0x000000FFUL << TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Pos)                 /*!< Mask for ptat_temp_trim in TSEN.TSEN_PTAT1 */
#define TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Shift(v)               (((v) << TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Pos) & TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Msk) /*!< Shift value 'v' into ptat_temp_trim and mask 'v' to fit it into ptat_temp_trim field */

/** TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__SET() sets TSEN_PTAT1.PTAT_TEMP_TRIM to given value.
 *
 * When writing to TSEN_PTAT1.PTAT_TEMP_TRIM, this is recommended to use.
 *
 * @param bf_value new value for TSEN_PTAT1.PTAT_TEMP_TRIM
 */
__TSEN_INLINE void TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_PTAT1__GET();
    reg = (reg & ~TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Msk);
    reg = (reg | (TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Shift((uint32_t)bf_value)));
    TSEN_TSEN_PTAT1__SET(reg);
}

/** TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__GET() gets TSEN_PTAT1.PTAT_TEMP_TRIM's current value.
 *
 * When reading from TSEN_PTAT1.PTAT_TEMP_TRIM, this is recommended to use.
 *
 * @return current value of TSEN_PTAT1.PTAT_TEMP_TRIM
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__GET(void)
{
    uint32_t reg = TSEN_TSEN_PTAT1__GET();
    reg = (reg & TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Msk);
    reg = (reg >> TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__MODIFY() modifies TSEN_PTAT1.PTAT_TEMP_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_PTAT1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_PTAT1
 * @param bf_value new value for TSEN_PTAT1.PTAT_TEMP_TRIM
 * @return new value of TSEN.TSEN_PTAT1
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Msk);
    reg = (reg | (TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__EXTRACT() extracts TSEN_PTAT1.PTAT_TEMP_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_PTAT1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_PTAT1
 * @return current value of TSEN_PTAT1.PTAT_TEMP_TRIM
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Msk);
    reg = (reg >> TSEN_TSEN_PTAT1__PTAT_TEMP_TRIM__Pos);
    return (uint32_t)reg;
}

/* --------------------- TSEN.TSEN_PTAT1.PTAT_MIN_CODE --------------------- */

/**
<pre>
  TSEN.TSEN_PTAT1.PTAT_MIN_CODE:

    Not used

</pre> */

#define TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Pos                     0                                                                      /*!< Right-most bit position of ptat_min_code in TSEN.TSEN_PTAT1 */
#define TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Msk                     (0x000000FFUL << TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Pos)                  /*!< Mask for ptat_min_code in TSEN.TSEN_PTAT1 */
#define TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Shift(v)                (((v) << TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Pos) & TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Msk) /*!< Shift value 'v' into ptat_min_code and mask 'v' to fit it into ptat_min_code field */

/** TSEN_TSEN_PTAT1__PTAT_MIN_CODE__SET() sets TSEN_PTAT1.PTAT_MIN_CODE to given value.
 *
 * When writing to TSEN_PTAT1.PTAT_MIN_CODE, this is recommended to use.
 *
 * @param bf_value new value for TSEN_PTAT1.PTAT_MIN_CODE
 */
__TSEN_INLINE void TSEN_TSEN_PTAT1__PTAT_MIN_CODE__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_PTAT1__GET();
    reg = (reg & ~TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Msk);
    reg = (reg | (TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Shift((uint32_t)bf_value)));
    TSEN_TSEN_PTAT1__SET(reg);
}

/** TSEN_TSEN_PTAT1__PTAT_MIN_CODE__GET() gets TSEN_PTAT1.PTAT_MIN_CODE's current value.
 *
 * When reading from TSEN_PTAT1.PTAT_MIN_CODE, this is recommended to use.
 *
 * @return current value of TSEN_PTAT1.PTAT_MIN_CODE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT1__PTAT_MIN_CODE__GET(void)
{
    uint32_t reg = TSEN_TSEN_PTAT1__GET();
    reg = (reg & TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Msk);
    reg = (reg >> TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_PTAT1__PTAT_MIN_CODE__MODIFY() modifies TSEN_PTAT1.PTAT_MIN_CODE.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_PTAT1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_PTAT1
 * @param bf_value new value for TSEN_PTAT1.PTAT_MIN_CODE
 * @return new value of TSEN.TSEN_PTAT1
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT1__PTAT_MIN_CODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Msk);
    reg = (reg | (TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_PTAT1__PTAT_MIN_CODE__EXTRACT() extracts TSEN_PTAT1.PTAT_MIN_CODE.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_PTAT1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_PTAT1
 * @return current value of TSEN_PTAT1.PTAT_MIN_CODE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT1__PTAT_MIN_CODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Msk);
    reg = (reg >> TSEN_TSEN_PTAT1__PTAT_MIN_CODE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_PTAT2 member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_PTAT2__ADDRESS returns the address of member TSEN_PTAT2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_PTAT2
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_PTAT2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_PTAT2)));
}

/** TSEN_TSEN_PTAT2__SET() sets TSEN_PTAT2 to given value.
 *
 * When writing to TSEN_PTAT2, this is mandatory to use.
 *
 * @param value new value for TSEN_PTAT2
 */
__TSEN_INLINE void TSEN_TSEN_PTAT2__SET(uint32_t value)
{
    HAL_SET32(__TSEN_TSEN_PTAT2__ADDRESS(), value);
}

/** TSEN_TSEN_PTAT2__GET() gets TSEN_PTAT2's current value.
 *
 * When reading from TSEN_PTAT2, this is mandatory to use.
 *
 * @return current value of TSEN_PTAT2
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT2__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_PTAT2__ADDRESS());
}

/* --------------------- TSEN.TSEN_PTAT2.XV_GAIN_SCALE --------------------- */

/**
<pre>
  TSEN.TSEN_PTAT2.XV_GAIN_SCALE:

    XADDR1,2 computation gain scale.  The TS ADC result is scaled by (1.0 + xv_gain_scale) during the XADDR computations.
    LSB = 1/256 V/V, Range = -0.25 to +0.24805 V/V

</pre> */

#define TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Pos                     19                                                                     /*!< Right-most bit position of xv_gain_scale in TSEN.TSEN_PTAT2 */
#define TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Msk                     (0x000000FFUL << TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Pos)                  /*!< Mask for xv_gain_scale in TSEN.TSEN_PTAT2 */
#define TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Shift(v)                (((v) << TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Pos) & TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Msk) /*!< Shift value 'v' into xv_gain_scale and mask 'v' to fit it into xv_gain_scale field */

/** TSEN_TSEN_PTAT2__XV_GAIN_SCALE__SET() sets TSEN_PTAT2.XV_GAIN_SCALE to given value.
 *
 * When writing to TSEN_PTAT2.XV_GAIN_SCALE, this is recommended to use.
 *
 * @param bf_value new value for TSEN_PTAT2.XV_GAIN_SCALE
 */
__TSEN_INLINE void TSEN_TSEN_PTAT2__XV_GAIN_SCALE__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_PTAT2__GET();
    reg = (reg & ~TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Msk);
    reg = (reg | (TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Shift((uint32_t)bf_value)));
    TSEN_TSEN_PTAT2__SET(reg);
}

/** TSEN_TSEN_PTAT2__XV_GAIN_SCALE__GET() gets TSEN_PTAT2.XV_GAIN_SCALE's current value.
 *
 * When reading from TSEN_PTAT2.XV_GAIN_SCALE, this is recommended to use.
 *
 * @return current value of TSEN_PTAT2.XV_GAIN_SCALE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT2__XV_GAIN_SCALE__GET(void)
{
    uint32_t reg = TSEN_TSEN_PTAT2__GET();
    reg = (reg & TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Msk);
    reg = (reg >> TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_PTAT2__XV_GAIN_SCALE__MODIFY() modifies TSEN_PTAT2.XV_GAIN_SCALE.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_PTAT2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_PTAT2
 * @param bf_value new value for TSEN_PTAT2.XV_GAIN_SCALE
 * @return new value of TSEN.TSEN_PTAT2
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT2__XV_GAIN_SCALE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Msk);
    reg = (reg | (TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_PTAT2__XV_GAIN_SCALE__EXTRACT() extracts TSEN_PTAT2.XV_GAIN_SCALE.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_PTAT2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_PTAT2
 * @return current value of TSEN_PTAT2.XV_GAIN_SCALE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT2__XV_GAIN_SCALE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Msk);
    reg = (reg >> TSEN_TSEN_PTAT2__XV_GAIN_SCALE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TSEN.TSEN_PTAT2.TEMP_MIN ------------------------ */

/**
<pre>
  TSEN.TSEN_PTAT2.TEMP_MIN:

    Defines the lower limit for the internal temperature computation.  Computed results less than this value are clamped to this value.
    LSB = 1 C, Range = -128 to +127 C

</pre> */

#define TSEN_TSEN_PTAT2__TEMP_MIN__Pos                          11                                                                     /*!< Right-most bit position of temp_min in TSEN.TSEN_PTAT2 */
#define TSEN_TSEN_PTAT2__TEMP_MIN__Msk                          (0x000000FFUL << TSEN_TSEN_PTAT2__TEMP_MIN__Pos)                       /*!< Mask for temp_min in TSEN.TSEN_PTAT2 */
#define TSEN_TSEN_PTAT2__TEMP_MIN__Shift(v)                     (((v) << TSEN_TSEN_PTAT2__TEMP_MIN__Pos) & TSEN_TSEN_PTAT2__TEMP_MIN__Msk) /*!< Shift value 'v' into temp_min and mask 'v' to fit it into temp_min field */

/** TSEN_TSEN_PTAT2__TEMP_MIN__SET() sets TSEN_PTAT2.TEMP_MIN to given value.
 *
 * When writing to TSEN_PTAT2.TEMP_MIN, this is recommended to use.
 *
 * @param bf_value new value for TSEN_PTAT2.TEMP_MIN
 */
__TSEN_INLINE void TSEN_TSEN_PTAT2__TEMP_MIN__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_PTAT2__GET();
    reg = (reg & ~TSEN_TSEN_PTAT2__TEMP_MIN__Msk);
    reg = (reg | (TSEN_TSEN_PTAT2__TEMP_MIN__Shift((uint32_t)bf_value)));
    TSEN_TSEN_PTAT2__SET(reg);
}

/** TSEN_TSEN_PTAT2__TEMP_MIN__GET() gets TSEN_PTAT2.TEMP_MIN's current value.
 *
 * When reading from TSEN_PTAT2.TEMP_MIN, this is recommended to use.
 *
 * @return current value of TSEN_PTAT2.TEMP_MIN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT2__TEMP_MIN__GET(void)
{
    uint32_t reg = TSEN_TSEN_PTAT2__GET();
    reg = (reg & TSEN_TSEN_PTAT2__TEMP_MIN__Msk);
    reg = (reg >> TSEN_TSEN_PTAT2__TEMP_MIN__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_PTAT2__TEMP_MIN__MODIFY() modifies TSEN_PTAT2.TEMP_MIN.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_PTAT2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_PTAT2
 * @param bf_value new value for TSEN_PTAT2.TEMP_MIN
 * @return new value of TSEN.TSEN_PTAT2
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT2__TEMP_MIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_PTAT2__TEMP_MIN__Msk);
    reg = (reg | (TSEN_TSEN_PTAT2__TEMP_MIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_PTAT2__TEMP_MIN__EXTRACT() extracts TSEN_PTAT2.TEMP_MIN.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_PTAT2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_PTAT2
 * @return current value of TSEN_PTAT2.TEMP_MIN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT2__TEMP_MIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_PTAT2__TEMP_MIN__Msk);
    reg = (reg >> TSEN_TSEN_PTAT2__TEMP_MIN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TSEN.TSEN_PTAT2.PTAT_0C_CODE ---------------------- */

/**
<pre>
  TSEN.TSEN_PTAT2.PTAT_0C_CODE:

    Internal temperature sense (ITSEN) 0C code.  Internal temperature computed as:
    <start table>
    "Int. Temp. = (ADC - 0C_code) * pwl_slope + temp_trim"
    <end table>
    LSB = 0.25 ADC Codes, Range = 0.0 to 511.75 ADC Codes

</pre> */

#define TSEN_TSEN_PTAT2__PTAT_0C_CODE__Pos                      0                                                                      /*!< Right-most bit position of ptat_0c_code in TSEN.TSEN_PTAT2 */
#define TSEN_TSEN_PTAT2__PTAT_0C_CODE__Msk                      (0x000007FFUL << TSEN_TSEN_PTAT2__PTAT_0C_CODE__Pos)                   /*!< Mask for ptat_0c_code in TSEN.TSEN_PTAT2 */
#define TSEN_TSEN_PTAT2__PTAT_0C_CODE__Shift(v)                 (((v) << TSEN_TSEN_PTAT2__PTAT_0C_CODE__Pos) & TSEN_TSEN_PTAT2__PTAT_0C_CODE__Msk) /*!< Shift value 'v' into ptat_0c_code and mask 'v' to fit it into ptat_0c_code field */

/** TSEN_TSEN_PTAT2__PTAT_0C_CODE__SET() sets TSEN_PTAT2.PTAT_0C_CODE to given value.
 *
 * When writing to TSEN_PTAT2.PTAT_0C_CODE, this is recommended to use.
 *
 * @param bf_value new value for TSEN_PTAT2.PTAT_0C_CODE
 */
__TSEN_INLINE void TSEN_TSEN_PTAT2__PTAT_0C_CODE__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_PTAT2__GET();
    reg = (reg & ~TSEN_TSEN_PTAT2__PTAT_0C_CODE__Msk);
    reg = (reg | (TSEN_TSEN_PTAT2__PTAT_0C_CODE__Shift((uint32_t)bf_value)));
    TSEN_TSEN_PTAT2__SET(reg);
}

/** TSEN_TSEN_PTAT2__PTAT_0C_CODE__GET() gets TSEN_PTAT2.PTAT_0C_CODE's current value.
 *
 * When reading from TSEN_PTAT2.PTAT_0C_CODE, this is recommended to use.
 *
 * @return current value of TSEN_PTAT2.PTAT_0C_CODE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT2__PTAT_0C_CODE__GET(void)
{
    uint32_t reg = TSEN_TSEN_PTAT2__GET();
    reg = (reg & TSEN_TSEN_PTAT2__PTAT_0C_CODE__Msk);
    reg = (reg >> TSEN_TSEN_PTAT2__PTAT_0C_CODE__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_PTAT2__PTAT_0C_CODE__MODIFY() modifies TSEN_PTAT2.PTAT_0C_CODE.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_PTAT2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_PTAT2
 * @param bf_value new value for TSEN_PTAT2.PTAT_0C_CODE
 * @return new value of TSEN.TSEN_PTAT2
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT2__PTAT_0C_CODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_PTAT2__PTAT_0C_CODE__Msk);
    reg = (reg | (TSEN_TSEN_PTAT2__PTAT_0C_CODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_PTAT2__PTAT_0C_CODE__EXTRACT() extracts TSEN_PTAT2.PTAT_0C_CODE.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_PTAT2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_PTAT2
 * @return current value of TSEN_PTAT2.PTAT_0C_CODE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PTAT2__PTAT_0C_CODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_PTAT2__PTAT_0C_CODE__Msk);
    reg = (reg >> TSEN_TSEN_PTAT2__PTAT_0C_CODE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TSEN_VIN member of TSEN_t                         */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_VIN__ADDRESS returns the address of member TSEN_VIN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_VIN
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_VIN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_VIN)));
}

/** TSEN_TSEN_VIN__SET() sets TSEN_VIN to given value.
 *
 * When writing to TSEN_VIN, this is mandatory to use.
 *
 * @param value new value for TSEN_VIN
 */
__TSEN_INLINE void TSEN_TSEN_VIN__SET(uint32_t value)
{
    HAL_SET32(__TSEN_TSEN_VIN__ADDRESS(), value);
}

/** TSEN_TSEN_VIN__GET() gets TSEN_VIN's current value.
 *
 * When reading from TSEN_VIN, this is mandatory to use.
 *
 * @return current value of TSEN_VIN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_VIN__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_VIN__ADDRESS());
}

/* ------------------------- TSEN.TSEN_VIN.VIN_TRIM ------------------------- */

/**
<pre>
  TSEN.TSEN_VIN.VIN_TRIM:

    Telemetry sense ADC PRISEN input voltage (Vin) offset term.  Vin computed as:
    <start table>
    "Vin = ADC * vin_pwl_slope + vin_trim"
    <end table>
    LSB = 62.5mV, Range = -32 to +31.9375 V

</pre> */

#define TSEN_TSEN_VIN__VIN_TRIM__Pos                            12                                                                     /*!< Right-most bit position of vin_trim in TSEN.TSEN_VIN */
#define TSEN_TSEN_VIN__VIN_TRIM__Msk                            (0x000003FFUL << TSEN_TSEN_VIN__VIN_TRIM__Pos)                         /*!< Mask for vin_trim in TSEN.TSEN_VIN */
#define TSEN_TSEN_VIN__VIN_TRIM__Shift(v)                       (((v) << TSEN_TSEN_VIN__VIN_TRIM__Pos) & TSEN_TSEN_VIN__VIN_TRIM__Msk) /*!< Shift value 'v' into vin_trim and mask 'v' to fit it into vin_trim field */

/** TSEN_TSEN_VIN__VIN_TRIM__SET() sets TSEN_VIN.VIN_TRIM to given value.
 *
 * When writing to TSEN_VIN.VIN_TRIM, this is recommended to use.
 *
 * @param bf_value new value for TSEN_VIN.VIN_TRIM
 */
__TSEN_INLINE void TSEN_TSEN_VIN__VIN_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_VIN__GET();
    reg = (reg & ~TSEN_TSEN_VIN__VIN_TRIM__Msk);
    reg = (reg | (TSEN_TSEN_VIN__VIN_TRIM__Shift((uint32_t)bf_value)));
    TSEN_TSEN_VIN__SET(reg);
}

/** TSEN_TSEN_VIN__VIN_TRIM__GET() gets TSEN_VIN.VIN_TRIM's current value.
 *
 * When reading from TSEN_VIN.VIN_TRIM, this is recommended to use.
 *
 * @return current value of TSEN_VIN.VIN_TRIM
 */
__TSEN_INLINE uint32_t TSEN_TSEN_VIN__VIN_TRIM__GET(void)
{
    uint32_t reg = TSEN_TSEN_VIN__GET();
    reg = (reg & TSEN_TSEN_VIN__VIN_TRIM__Msk);
    reg = (reg >> TSEN_TSEN_VIN__VIN_TRIM__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_VIN__VIN_TRIM__MODIFY() modifies TSEN_VIN.VIN_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_VIN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_VIN
 * @param bf_value new value for TSEN_VIN.VIN_TRIM
 * @return new value of TSEN.TSEN_VIN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_VIN__VIN_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_VIN__VIN_TRIM__Msk);
    reg = (reg | (TSEN_TSEN_VIN__VIN_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_VIN__VIN_TRIM__EXTRACT() extracts TSEN_VIN.VIN_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_VIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_VIN
 * @return current value of TSEN_VIN.VIN_TRIM
 */
__TSEN_INLINE uint32_t TSEN_TSEN_VIN__VIN_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_VIN__VIN_TRIM__Msk);
    reg = (reg >> TSEN_TSEN_VIN__VIN_TRIM__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TSEN.TSEN_VIN.VIN_PWL_SLOPE ---------------------- */

/**
<pre>
  TSEN.TSEN_VIN.VIN_PWL_SLOPE:

    Telemetry sense ADC PRISEN input voltage (Vin) piecewise linear slope term.  Vin computed as:
    <start table>
    "Vin = ADC * vin_pwl_slope + vin_trim"
    <end table>
    LSB = 2^-14 V/V, Range = 0 to 0.24994 V/V

</pre> */

#define TSEN_TSEN_VIN__VIN_PWL_SLOPE__Pos                       0                                                                      /*!< Right-most bit position of vin_pwl_slope in TSEN.TSEN_VIN */
#define TSEN_TSEN_VIN__VIN_PWL_SLOPE__Msk                       (0x00000FFFUL << TSEN_TSEN_VIN__VIN_PWL_SLOPE__Pos)                    /*!< Mask for vin_pwl_slope in TSEN.TSEN_VIN */
#define TSEN_TSEN_VIN__VIN_PWL_SLOPE__Shift(v)                  (((v) << TSEN_TSEN_VIN__VIN_PWL_SLOPE__Pos) & TSEN_TSEN_VIN__VIN_PWL_SLOPE__Msk) /*!< Shift value 'v' into vin_pwl_slope and mask 'v' to fit it into vin_pwl_slope field */

/** TSEN_TSEN_VIN__VIN_PWL_SLOPE__SET() sets TSEN_VIN.VIN_PWL_SLOPE to given value.
 *
 * When writing to TSEN_VIN.VIN_PWL_SLOPE, this is recommended to use.
 *
 * @param bf_value new value for TSEN_VIN.VIN_PWL_SLOPE
 */
__TSEN_INLINE void TSEN_TSEN_VIN__VIN_PWL_SLOPE__SET(uint32_t bf_value)
{
    uint32_t reg = TSEN_TSEN_VIN__GET();
    reg = (reg & ~TSEN_TSEN_VIN__VIN_PWL_SLOPE__Msk);
    reg = (reg | (TSEN_TSEN_VIN__VIN_PWL_SLOPE__Shift((uint32_t)bf_value)));
    TSEN_TSEN_VIN__SET(reg);
}

/** TSEN_TSEN_VIN__VIN_PWL_SLOPE__GET() gets TSEN_VIN.VIN_PWL_SLOPE's current value.
 *
 * When reading from TSEN_VIN.VIN_PWL_SLOPE, this is recommended to use.
 *
 * @return current value of TSEN_VIN.VIN_PWL_SLOPE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_VIN__VIN_PWL_SLOPE__GET(void)
{
    uint32_t reg = TSEN_TSEN_VIN__GET();
    reg = (reg & TSEN_TSEN_VIN__VIN_PWL_SLOPE__Msk);
    reg = (reg >> TSEN_TSEN_VIN__VIN_PWL_SLOPE__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_VIN__VIN_PWL_SLOPE__MODIFY() modifies TSEN_VIN.VIN_PWL_SLOPE.
 *
 * This is recommended to use when setting more than one bitfield of TSEN.TSEN_VIN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TSEN.TSEN_VIN
 * @param bf_value new value for TSEN_VIN.VIN_PWL_SLOPE
 * @return new value of TSEN.TSEN_VIN
 */
__TSEN_INLINE uint32_t TSEN_TSEN_VIN__VIN_PWL_SLOPE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TSEN_TSEN_VIN__VIN_PWL_SLOPE__Msk);
    reg = (reg | (TSEN_TSEN_VIN__VIN_PWL_SLOPE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TSEN_TSEN_VIN__VIN_PWL_SLOPE__EXTRACT() extracts TSEN_VIN.VIN_PWL_SLOPE.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_VIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_VIN
 * @return current value of TSEN_VIN.VIN_PWL_SLOPE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_VIN__VIN_PWL_SLOPE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_VIN__VIN_PWL_SLOPE__Msk);
    reg = (reg >> TSEN_TSEN_VIN__VIN_PWL_SLOPE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TSEN_XV_DONE member of TSEN_t                       */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_XV_DONE__ADDRESS returns the address of member TSEN_XV_DONE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_XV_DONE
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_XV_DONE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_XV_DONE)));
}

/** TSEN_TSEN_XV_DONE__GET() gets TSEN_XV_DONE's current value.
 *
 * When reading from TSEN_XV_DONE, this is mandatory to use.
 *
 * @return current value of TSEN_XV_DONE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_XV_DONE__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_XV_DONE__ADDRESS());
}

/* -------------------- TSEN.TSEN_XV_DONE.TS_XV_COMPLETE -------------------- */

/**
<pre>
  TSEN.TSEN_XV_DONE.TS_XV_COMPLETE:

    Telemetry sense ADC XADDR1,2 resistor pinset measurement complete status.
    <start table>
    0 "measurement not started or in progress"
    1 "measurement complete"
    <end table>

</pre> */

#define TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__Pos                  0                                                                      /*!< Right-most bit position of ts_xv_complete in TSEN.TSEN_XV_DONE */
#define TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__Msk                  (0x00000001UL << TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__Pos)               /*!< Mask for ts_xv_complete in TSEN.TSEN_XV_DONE */
#define TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__Shift(v)             (((v) << TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__Pos) & TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__Msk) /*!< Shift value 'v' into ts_xv_complete and mask 'v' to fit it into ts_xv_complete field */

/** TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__GET() gets TSEN_XV_DONE.TS_XV_COMPLETE's current value.
 *
 * When reading from TSEN_XV_DONE.TS_XV_COMPLETE, this is recommended to use.
 *
 * @return current value of TSEN_XV_DONE.TS_XV_COMPLETE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__GET(void)
{
    uint32_t reg = TSEN_TSEN_XV_DONE__GET();
    reg = (reg & TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__Msk);
    reg = (reg >> TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__EXTRACT() extracts TSEN_XV_DONE.TS_XV_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_XV_DONE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_XV_DONE
 * @return current value of TSEN_XV_DONE.TS_XV_COMPLETE
 */
__TSEN_INLINE uint32_t TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__Msk);
    reg = (reg >> TSEN_TSEN_XV_DONE__TS_XV_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_PRIADC member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_PRIADC__ADDRESS returns the address of member TSEN_PRIADC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_PRIADC
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_PRIADC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_PRIADC)));
}

/** TSEN_TSEN_PRIADC__GET() gets TSEN_PRIADC's current value.
 *
 * When reading from TSEN_PRIADC, this is mandatory to use.
 *
 * @return current value of TSEN_PRIADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PRIADC__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_PRIADC__ADDRESS());
}

/* --------------------- TSEN.TSEN_PRIADC.TS_PRISEN_ADC --------------------- */

/**
<pre>
  TSEN.TSEN_PRIADC.TS_PRISEN_ADC:

    Gain and offset corrected PRISEN Telemetry Sense (TS) ADC output.

</pre> */

#define TSEN_TSEN_PRIADC__TS_PRISEN_ADC__Pos                    0                                                                      /*!< Right-most bit position of ts_prisen_adc in TSEN.TSEN_PRIADC */
#define TSEN_TSEN_PRIADC__TS_PRISEN_ADC__Msk                    (0x00003FFFUL << TSEN_TSEN_PRIADC__TS_PRISEN_ADC__Pos)                 /*!< Mask for ts_prisen_adc in TSEN.TSEN_PRIADC */
#define TSEN_TSEN_PRIADC__TS_PRISEN_ADC__Shift(v)               (((v) << TSEN_TSEN_PRIADC__TS_PRISEN_ADC__Pos) & TSEN_TSEN_PRIADC__TS_PRISEN_ADC__Msk) /*!< Shift value 'v' into ts_prisen_adc and mask 'v' to fit it into ts_prisen_adc field */

/** TSEN_TSEN_PRIADC__TS_PRISEN_ADC__GET() gets TSEN_PRIADC.TS_PRISEN_ADC's current value.
 *
 * When reading from TSEN_PRIADC.TS_PRISEN_ADC, this is recommended to use.
 *
 * @return current value of TSEN_PRIADC.TS_PRISEN_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PRIADC__TS_PRISEN_ADC__GET(void)
{
    uint32_t reg = TSEN_TSEN_PRIADC__GET();
    reg = (reg & TSEN_TSEN_PRIADC__TS_PRISEN_ADC__Msk);
    reg = (reg >> TSEN_TSEN_PRIADC__TS_PRISEN_ADC__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_PRIADC__TS_PRISEN_ADC__EXTRACT() extracts TSEN_PRIADC.TS_PRISEN_ADC.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_PRIADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_PRIADC
 * @return current value of TSEN_PRIADC.TS_PRISEN_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_PRIADC__TS_PRISEN_ADC__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_PRIADC__TS_PRISEN_ADC__Msk);
    reg = (reg >> TSEN_TSEN_PRIADC__TS_PRISEN_ADC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_IMNADC member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_IMNADC__ADDRESS returns the address of member TSEN_IMNADC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_IMNADC
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_IMNADC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_IMNADC)));
}

/** TSEN_TSEN_IMNADC__GET() gets TSEN_IMNADC's current value.
 *
 * When reading from TSEN_IMNADC, this is mandatory to use.
 *
 * @return current value of TSEN_IMNADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_IMNADC__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_IMNADC__ADDRESS());
}

/* ---------------------- TSEN.TSEN_IMNADC.TS_IMON_ADC ---------------------- */

/**
<pre>
  TSEN.TSEN_IMNADC.TS_IMON_ADC:

    Gain and offset corrected IMON Telemetry Sense (TS) ADC output.

</pre> */

#define TSEN_TSEN_IMNADC__TS_IMON_ADC__Pos                      0                                                                      /*!< Right-most bit position of ts_imon_adc in TSEN.TSEN_IMNADC */
#define TSEN_TSEN_IMNADC__TS_IMON_ADC__Msk                      (0x00003FFFUL << TSEN_TSEN_IMNADC__TS_IMON_ADC__Pos)                   /*!< Mask for ts_imon_adc in TSEN.TSEN_IMNADC */
#define TSEN_TSEN_IMNADC__TS_IMON_ADC__Shift(v)                 (((v) << TSEN_TSEN_IMNADC__TS_IMON_ADC__Pos) & TSEN_TSEN_IMNADC__TS_IMON_ADC__Msk) /*!< Shift value 'v' into ts_imon_adc and mask 'v' to fit it into ts_imon_adc field */

/** TSEN_TSEN_IMNADC__TS_IMON_ADC__GET() gets TSEN_IMNADC.TS_IMON_ADC's current value.
 *
 * When reading from TSEN_IMNADC.TS_IMON_ADC, this is recommended to use.
 *
 * @return current value of TSEN_IMNADC.TS_IMON_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_IMNADC__TS_IMON_ADC__GET(void)
{
    uint32_t reg = TSEN_TSEN_IMNADC__GET();
    reg = (reg & TSEN_TSEN_IMNADC__TS_IMON_ADC__Msk);
    reg = (reg >> TSEN_TSEN_IMNADC__TS_IMON_ADC__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_IMNADC__TS_IMON_ADC__EXTRACT() extracts TSEN_IMNADC.TS_IMON_ADC.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_IMNADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_IMNADC
 * @return current value of TSEN_IMNADC.TS_IMON_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_IMNADC__TS_IMON_ADC__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_IMNADC__TS_IMON_ADC__Msk);
    reg = (reg >> TSEN_TSEN_IMNADC__TS_IMON_ADC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_ATSADC member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_ATSADC__ADDRESS returns the address of member TSEN_ATSADC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_ATSADC
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_ATSADC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_ATSADC)));
}

/** TSEN_TSEN_ATSADC__GET() gets TSEN_ATSADC's current value.
 *
 * When reading from TSEN_ATSADC, this is mandatory to use.
 *
 * @return current value of TSEN_ATSADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_ATSADC__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_ATSADC__ADDRESS());
}

/* --------------------- TSEN.TSEN_ATSADC.TS_ATSEN_ADC --------------------- */

/**
<pre>
  TSEN.TSEN_ATSADC.TS_ATSEN_ADC:

    Gain and offset corrected ATSEN Telemetry Sense (TS) ADC output.

</pre> */

#define TSEN_TSEN_ATSADC__TS_ATSEN_ADC__Pos                     0                                                                      /*!< Right-most bit position of ts_atsen_adc in TSEN.TSEN_ATSADC */
#define TSEN_TSEN_ATSADC__TS_ATSEN_ADC__Msk                     (0x00003FFFUL << TSEN_TSEN_ATSADC__TS_ATSEN_ADC__Pos)                  /*!< Mask for ts_atsen_adc in TSEN.TSEN_ATSADC */
#define TSEN_TSEN_ATSADC__TS_ATSEN_ADC__Shift(v)                (((v) << TSEN_TSEN_ATSADC__TS_ATSEN_ADC__Pos) & TSEN_TSEN_ATSADC__TS_ATSEN_ADC__Msk) /*!< Shift value 'v' into ts_atsen_adc and mask 'v' to fit it into ts_atsen_adc field */

/** TSEN_TSEN_ATSADC__TS_ATSEN_ADC__GET() gets TSEN_ATSADC.TS_ATSEN_ADC's current value.
 *
 * When reading from TSEN_ATSADC.TS_ATSEN_ADC, this is recommended to use.
 *
 * @return current value of TSEN_ATSADC.TS_ATSEN_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_ATSADC__TS_ATSEN_ADC__GET(void)
{
    uint32_t reg = TSEN_TSEN_ATSADC__GET();
    reg = (reg & TSEN_TSEN_ATSADC__TS_ATSEN_ADC__Msk);
    reg = (reg >> TSEN_TSEN_ATSADC__TS_ATSEN_ADC__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_ATSADC__TS_ATSEN_ADC__EXTRACT() extracts TSEN_ATSADC.TS_ATSEN_ADC.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_ATSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_ATSADC
 * @return current value of TSEN_ATSADC.TS_ATSEN_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_ATSADC__TS_ATSEN_ADC__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_ATSADC__TS_ATSEN_ADC__Msk);
    reg = (reg >> TSEN_TSEN_ATSADC__TS_ATSEN_ADC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_BTSADC member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_BTSADC__ADDRESS returns the address of member TSEN_BTSADC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_BTSADC
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_BTSADC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_BTSADC)));
}

/** TSEN_TSEN_BTSADC__GET() gets TSEN_BTSADC's current value.
 *
 * When reading from TSEN_BTSADC, this is mandatory to use.
 *
 * @return current value of TSEN_BTSADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_BTSADC__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_BTSADC__ADDRESS());
}

/* --------------------- TSEN.TSEN_BTSADC.TS_BTSEN_ADC --------------------- */

/**
<pre>
  TSEN.TSEN_BTSADC.TS_BTSEN_ADC:

    Gain and offset corrected BTSEN Telemetry Sense (TS) ADC output.

</pre> */

#define TSEN_TSEN_BTSADC__TS_BTSEN_ADC__Pos                     0                                                                      /*!< Right-most bit position of ts_btsen_adc in TSEN.TSEN_BTSADC */
#define TSEN_TSEN_BTSADC__TS_BTSEN_ADC__Msk                     (0x00003FFFUL << TSEN_TSEN_BTSADC__TS_BTSEN_ADC__Pos)                  /*!< Mask for ts_btsen_adc in TSEN.TSEN_BTSADC */
#define TSEN_TSEN_BTSADC__TS_BTSEN_ADC__Shift(v)                (((v) << TSEN_TSEN_BTSADC__TS_BTSEN_ADC__Pos) & TSEN_TSEN_BTSADC__TS_BTSEN_ADC__Msk) /*!< Shift value 'v' into ts_btsen_adc and mask 'v' to fit it into ts_btsen_adc field */

/** TSEN_TSEN_BTSADC__TS_BTSEN_ADC__GET() gets TSEN_BTSADC.TS_BTSEN_ADC's current value.
 *
 * When reading from TSEN_BTSADC.TS_BTSEN_ADC, this is recommended to use.
 *
 * @return current value of TSEN_BTSADC.TS_BTSEN_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_BTSADC__TS_BTSEN_ADC__GET(void)
{
    uint32_t reg = TSEN_TSEN_BTSADC__GET();
    reg = (reg & TSEN_TSEN_BTSADC__TS_BTSEN_ADC__Msk);
    reg = (reg >> TSEN_TSEN_BTSADC__TS_BTSEN_ADC__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_BTSADC__TS_BTSEN_ADC__EXTRACT() extracts TSEN_BTSADC.TS_BTSEN_ADC.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_BTSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_BTSADC
 * @return current value of TSEN_BTSADC.TS_BTSEN_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_BTSADC__TS_BTSEN_ADC__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_BTSADC__TS_BTSEN_ADC__Msk);
    reg = (reg >> TSEN_TSEN_BTSADC__TS_BTSEN_ADC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_ITSADC member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_ITSADC__ADDRESS returns the address of member TSEN_ITSADC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_ITSADC
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_ITSADC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_ITSADC)));
}

/** TSEN_TSEN_ITSADC__GET() gets TSEN_ITSADC's current value.
 *
 * When reading from TSEN_ITSADC, this is mandatory to use.
 *
 * @return current value of TSEN_ITSADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_ITSADC__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_ITSADC__ADDRESS());
}

/* --------------------- TSEN.TSEN_ITSADC.TS_ITSEN_ADC --------------------- */

/**
<pre>
  TSEN.TSEN_ITSADC.TS_ITSEN_ADC:

    Gain and offset corrected ITSEN (internal temp) Telemetry Sense (TS) ADC output.

</pre> */

#define TSEN_TSEN_ITSADC__TS_ITSEN_ADC__Pos                     0                                                                      /*!< Right-most bit position of ts_itsen_adc in TSEN.TSEN_ITSADC */
#define TSEN_TSEN_ITSADC__TS_ITSEN_ADC__Msk                     (0x00003FFFUL << TSEN_TSEN_ITSADC__TS_ITSEN_ADC__Pos)                  /*!< Mask for ts_itsen_adc in TSEN.TSEN_ITSADC */
#define TSEN_TSEN_ITSADC__TS_ITSEN_ADC__Shift(v)                (((v) << TSEN_TSEN_ITSADC__TS_ITSEN_ADC__Pos) & TSEN_TSEN_ITSADC__TS_ITSEN_ADC__Msk) /*!< Shift value 'v' into ts_itsen_adc and mask 'v' to fit it into ts_itsen_adc field */

/** TSEN_TSEN_ITSADC__TS_ITSEN_ADC__GET() gets TSEN_ITSADC.TS_ITSEN_ADC's current value.
 *
 * When reading from TSEN_ITSADC.TS_ITSEN_ADC, this is recommended to use.
 *
 * @return current value of TSEN_ITSADC.TS_ITSEN_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_ITSADC__TS_ITSEN_ADC__GET(void)
{
    uint32_t reg = TSEN_TSEN_ITSADC__GET();
    reg = (reg & TSEN_TSEN_ITSADC__TS_ITSEN_ADC__Msk);
    reg = (reg >> TSEN_TSEN_ITSADC__TS_ITSEN_ADC__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_ITSADC__TS_ITSEN_ADC__EXTRACT() extracts TSEN_ITSADC.TS_ITSEN_ADC.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_ITSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_ITSADC
 * @return current value of TSEN_ITSADC.TS_ITSEN_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_ITSADC__TS_ITSEN_ADC__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_ITSADC__TS_ITSEN_ADC__Msk);
    reg = (reg >> TSEN_TSEN_ITSADC__TS_ITSEN_ADC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_VRFADC member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_VRFADC__ADDRESS returns the address of member TSEN_VRFADC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_VRFADC
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_VRFADC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_VRFADC)));
}

/** TSEN_TSEN_VRFADC__GET() gets TSEN_VRFADC's current value.
 *
 * When reading from TSEN_VRFADC, this is mandatory to use.
 *
 * @return current value of TSEN_VRFADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_VRFADC__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_VRFADC__ADDRESS());
}

/* ----------------------- TSEN.TSEN_VRFADC.VREF_ADC ----------------------- */

/**
<pre>
  TSEN.TSEN_VRFADC.VREF_ADC:

    Gain and offset corrected VREF (0.6V reference)Telemetry Sense (TS) ADC output.

</pre> */

#define TSEN_TSEN_VRFADC__VREF_ADC__Pos                         0                                                                      /*!< Right-most bit position of vref_adc in TSEN.TSEN_VRFADC */
#define TSEN_TSEN_VRFADC__VREF_ADC__Msk                         (0x00003FFFUL << TSEN_TSEN_VRFADC__VREF_ADC__Pos)                      /*!< Mask for vref_adc in TSEN.TSEN_VRFADC */
#define TSEN_TSEN_VRFADC__VREF_ADC__Shift(v)                    (((v) << TSEN_TSEN_VRFADC__VREF_ADC__Pos) & TSEN_TSEN_VRFADC__VREF_ADC__Msk) /*!< Shift value 'v' into vref_adc and mask 'v' to fit it into vref_adc field */

/** TSEN_TSEN_VRFADC__VREF_ADC__GET() gets TSEN_VRFADC.VREF_ADC's current value.
 *
 * When reading from TSEN_VRFADC.VREF_ADC, this is recommended to use.
 *
 * @return current value of TSEN_VRFADC.VREF_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_VRFADC__VREF_ADC__GET(void)
{
    uint32_t reg = TSEN_TSEN_VRFADC__GET();
    reg = (reg & TSEN_TSEN_VRFADC__VREF_ADC__Msk);
    reg = (reg >> TSEN_TSEN_VRFADC__VREF_ADC__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_VRFADC__VREF_ADC__EXTRACT() extracts TSEN_VRFADC.VREF_ADC.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_VRFADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_VRFADC
 * @return current value of TSEN_VRFADC.VREF_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_VRFADC__VREF_ADC__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_VRFADC__VREF_ADC__Msk);
    reg = (reg >> TSEN_TSEN_VRFADC__VREF_ADC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_XV1ADC member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_XV1ADC__ADDRESS returns the address of member TSEN_XV1ADC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_XV1ADC
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_XV1ADC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_XV1ADC)));
}

/** TSEN_TSEN_XV1ADC__GET() gets TSEN_XV1ADC's current value.
 *
 * When reading from TSEN_XV1ADC, this is mandatory to use.
 *
 * @return current value of TSEN_XV1ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_XV1ADC__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_XV1ADC__ADDRESS());
}

/* ------------------------ TSEN.TSEN_XV1ADC.XV1_ADC ------------------------ */

/**
<pre>
  TSEN.TSEN_XV1ADC.XV1_ADC:

    Gain and offset corrected XADDR1 Telemetry Sense (TS) ADC output.

</pre> */

#define TSEN_TSEN_XV1ADC__XV1_ADC__Pos                          0                                                                      /*!< Right-most bit position of xv1_adc in TSEN.TSEN_XV1ADC */
#define TSEN_TSEN_XV1ADC__XV1_ADC__Msk                          (0x00003FFFUL << TSEN_TSEN_XV1ADC__XV1_ADC__Pos)                       /*!< Mask for xv1_adc in TSEN.TSEN_XV1ADC */
#define TSEN_TSEN_XV1ADC__XV1_ADC__Shift(v)                     (((v) << TSEN_TSEN_XV1ADC__XV1_ADC__Pos) & TSEN_TSEN_XV1ADC__XV1_ADC__Msk) /*!< Shift value 'v' into xv1_adc and mask 'v' to fit it into xv1_adc field */

/** TSEN_TSEN_XV1ADC__XV1_ADC__GET() gets TSEN_XV1ADC.XV1_ADC's current value.
 *
 * When reading from TSEN_XV1ADC.XV1_ADC, this is recommended to use.
 *
 * @return current value of TSEN_XV1ADC.XV1_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_XV1ADC__XV1_ADC__GET(void)
{
    uint32_t reg = TSEN_TSEN_XV1ADC__GET();
    reg = (reg & TSEN_TSEN_XV1ADC__XV1_ADC__Msk);
    reg = (reg >> TSEN_TSEN_XV1ADC__XV1_ADC__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_XV1ADC__XV1_ADC__EXTRACT() extracts TSEN_XV1ADC.XV1_ADC.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_XV1ADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_XV1ADC
 * @return current value of TSEN_XV1ADC.XV1_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_XV1ADC__XV1_ADC__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_XV1ADC__XV1_ADC__Msk);
    reg = (reg >> TSEN_TSEN_XV1ADC__XV1_ADC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_XV2ADC member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_XV2ADC__ADDRESS returns the address of member TSEN_XV2ADC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_XV2ADC
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_XV2ADC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_XV2ADC)));
}

/** TSEN_TSEN_XV2ADC__GET() gets TSEN_XV2ADC's current value.
 *
 * When reading from TSEN_XV2ADC, this is mandatory to use.
 *
 * @return current value of TSEN_XV2ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_XV2ADC__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_XV2ADC__ADDRESS());
}

/* ------------------------ TSEN.TSEN_XV2ADC.XV2_ADC ------------------------ */

/**
<pre>
  TSEN.TSEN_XV2ADC.XV2_ADC:

    Gain and offset corrected XADDR2 Telemetry Sense (TS) ADC output.

</pre> */

#define TSEN_TSEN_XV2ADC__XV2_ADC__Pos                          0                                                                      /*!< Right-most bit position of xv2_adc in TSEN.TSEN_XV2ADC */
#define TSEN_TSEN_XV2ADC__XV2_ADC__Msk                          (0x00003FFFUL << TSEN_TSEN_XV2ADC__XV2_ADC__Pos)                       /*!< Mask for xv2_adc in TSEN.TSEN_XV2ADC */
#define TSEN_TSEN_XV2ADC__XV2_ADC__Shift(v)                     (((v) << TSEN_TSEN_XV2ADC__XV2_ADC__Pos) & TSEN_TSEN_XV2ADC__XV2_ADC__Msk) /*!< Shift value 'v' into xv2_adc and mask 'v' to fit it into xv2_adc field */

/** TSEN_TSEN_XV2ADC__XV2_ADC__GET() gets TSEN_XV2ADC.XV2_ADC's current value.
 *
 * When reading from TSEN_XV2ADC.XV2_ADC, this is recommended to use.
 *
 * @return current value of TSEN_XV2ADC.XV2_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_XV2ADC__XV2_ADC__GET(void)
{
    uint32_t reg = TSEN_TSEN_XV2ADC__GET();
    reg = (reg & TSEN_TSEN_XV2ADC__XV2_ADC__Msk);
    reg = (reg >> TSEN_TSEN_XV2ADC__XV2_ADC__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_XV2ADC__XV2_ADC__EXTRACT() extracts TSEN_XV2ADC.XV2_ADC.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_XV2ADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_XV2ADC
 * @return current value of TSEN_XV2ADC.XV2_ADC
 */
__TSEN_INLINE uint32_t TSEN_TSEN_XV2ADC__XV2_ADC__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_XV2ADC__XV2_ADC__Msk);
    reg = (reg >> TSEN_TSEN_XV2ADC__XV2_ADC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TSEN_ITEMP member of TSEN_t                        */
/* -------------------------------------------------------------------------- */

/** __TSEN_TSEN_ITEMP__ADDRESS returns the address of member TSEN_ITEMP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_ITEMP
 */
__TSEN_INLINE uint32_t* __TSEN_TSEN_ITEMP__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TSEN_BASE_PTR() + (uint32_t)(offsetof(TSEN_t, TSEN_ITEMP)));
}

/** TSEN_TSEN_ITEMP__GET() gets TSEN_ITEMP's current value.
 *
 * When reading from TSEN_ITEMP, this is mandatory to use.
 *
 * @return current value of TSEN_ITEMP
 */
__TSEN_INLINE uint32_t TSEN_TSEN_ITEMP__GET(void)
{
    return HAL_GET32(__TSEN_TSEN_ITEMP__ADDRESS());
}

/* ------------------------ TSEN.TSEN_ITEMP.INT_TEMP ------------------------ */

/**
<pre>
  TSEN.TSEN_ITEMP.INT_TEMP:

    Low pass filtered internal temperature (ITSEN) measurement.  Filter BW fixed at approximately 950Hz when the ITSEN measurement is enabled via ts_muxmode and ts_muxctrl1.

</pre> */

#define TSEN_TSEN_ITEMP__INT_TEMP__Pos                          0                                                                      /*!< Right-most bit position of int_temp in TSEN.TSEN_ITEMP */
#define TSEN_TSEN_ITEMP__INT_TEMP__Msk                          (0x00000FFFUL << TSEN_TSEN_ITEMP__INT_TEMP__Pos)                       /*!< Mask for int_temp in TSEN.TSEN_ITEMP */
#define TSEN_TSEN_ITEMP__INT_TEMP__Shift(v)                     (((v) << TSEN_TSEN_ITEMP__INT_TEMP__Pos) & TSEN_TSEN_ITEMP__INT_TEMP__Msk) /*!< Shift value 'v' into int_temp and mask 'v' to fit it into int_temp field */

/** TSEN_TSEN_ITEMP__INT_TEMP__GET() gets TSEN_ITEMP.INT_TEMP's current value.
 *
 * When reading from TSEN_ITEMP.INT_TEMP, this is recommended to use.
 *
 * @return current value of TSEN_ITEMP.INT_TEMP
 */
__TSEN_INLINE uint32_t TSEN_TSEN_ITEMP__INT_TEMP__GET(void)
{
    uint32_t reg = TSEN_TSEN_ITEMP__GET();
    reg = (reg & TSEN_TSEN_ITEMP__INT_TEMP__Msk);
    reg = (reg >> TSEN_TSEN_ITEMP__INT_TEMP__Pos);
    return (uint32_t)reg;
}

/** TSEN_TSEN_ITEMP__INT_TEMP__EXTRACT() extracts TSEN_ITEMP.INT_TEMP.
 *
 * This is recommended to use when extracting more than one bitfield from TSEN.TSEN_ITEMP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TSEN.TSEN_ITEMP
 * @return current value of TSEN_ITEMP.INT_TEMP
 */
__TSEN_INLINE uint32_t TSEN_TSEN_ITEMP__INT_TEMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TSEN_TSEN_ITEMP__INT_TEMP__Msk);
    reg = (reg >> TSEN_TSEN_ITEMP__INT_TEMP__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group tsen block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_TSEN_H_ */
