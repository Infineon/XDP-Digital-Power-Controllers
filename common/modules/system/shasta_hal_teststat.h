/**
 * @file     shasta_hal_teststat.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_TESTSTAT_H_
#define _SHASTA_HAL_TESTSTAT_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup teststat
 * @{
 */

#if defined ( __CC_ARM )
#define __TESTSTAT_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __TESTSTAT_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __TESTSTAT_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __TESTSTAT_INLINE  static inline
#endif

/** register file of the teststat block.
 */
typedef struct _TESTSTAT_s
{
    volatile        uint32_t        BIST_AVG1                   ; /*!< (@0x00000000) TBD */
    volatile        uint32_t        BIST_AVG2                   ; /*!< (@0x00000004) TBD */
    volatile        uint32_t        BIST_AVG3                   ; /*!< (@0x00000008) TBD */
    volatile        uint32_t        BIST_AVG4                   ; /*!< (@0x0000000C) TBD */
    volatile        uint32_t        BIST_AVG5                   ; /*!< (@0x00000010) TBD */
    volatile        uint32_t        BIST_LO1                    ; /*!< (@0x00000014) TBD */
    volatile        uint32_t        BIST_LO2                    ; /*!< (@0x00000018) TBD */
    volatile        uint32_t        BIST_IS_COMP                ; /*!< (@0x0000001C) TBD */
    volatile        uint32_t        BIST_IS_DNL                 ; /*!< (@0x00000020) TBD */
    volatile        uint32_t        BIST_IS_GAIN                ; /*!< (@0x00000024) TBD */
    volatile        uint32_t        BIST_IS_OFF1                ; /*!< (@0x00000028) TBD */
    volatile        uint32_t        BIST_IS_OFF2                ; /*!< (@0x0000002C) TBD */
    volatile        uint32_t        BIST_TSADC                  ; /*!< (@0x00000030) TBD */
    volatile        uint32_t        BIST_TSIDAC                 ; /*!< (@0x00000034) TBD */
    volatile        uint32_t        BIST_VS_DNL                 ; /*!< (@0x00000038) TBD */
    volatile        uint32_t        BIST_VS_GAIN                ; /*!< (@0x0000003C) TBD */
    volatile        uint32_t        BIST_VS_OFFS                ; /*!< (@0x00000040) TBD */
    volatile        uint32_t        TSADC_COMP1                 ; /*!< (@0x00000044) TBD */
    volatile        uint32_t        TSADC_COMP2                 ; /*!< (@0x00000048) TBD */
    volatile        uint32_t        TSADC_COMP3                 ; /*!< (@0x0000004C) TBD */
    volatile        uint32_t        TSADC_COMP4                 ; /*!< (@0x00000050) TBD */
    volatile        uint32_t        BIST_VS0_FE0                ; /*!< (@0x00000054) voltage sense 0 - test mode vsadc measurement @ 00h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS0_FE12               ; /*!< (@0x00000058) voltage sense 0 - test mode vsadc measurement @ 01h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS0_FE34               ; /*!< (@0x0000005C) voltage sense 0 - test mode vsadc measurement @ 04h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS0_FE56               ; /*!< (@0x00000060) voltage sense 0 - test mode vsadc measurement @ 10h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS1_FE0                ; /*!< (@0x00000064) voltage sense 1 - test mode vsadc measurement @ 00h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS1_FE12               ; /*!< (@0x00000068) voltage sense 1 - test mode vsadc measurement @ 01h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS1_FE34               ; /*!< (@0x0000006C) voltage sense 1 - test mode vsadc measurement @ 04h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS1_FE56               ; /*!< (@0x00000070) voltage sense 1 - test mode vsadc measurement @ 10h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS2_FE0                ; /*!< (@0x00000074) voltage sense 2 - test mode vsadc measurement @ 00h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS2_FE12               ; /*!< (@0x00000078) voltage sense 2 - test mode vsadc measurement @ 01h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS2_FE34               ; /*!< (@0x0000007C) voltage sense 2 - test mode vsadc measurement @ 04h vs_fe_dac  code */
    volatile        uint32_t        BIST_VS2_FE56               ; /*!< (@0x00000080) voltage sense 2 - test mode vsadc measurement @ 10h vs_fe_dac  code */
    volatile        uint32_t        BIST_CMPLT                  ; /*!< (@0x00000084) Analog BIST complete when bit high <start table> [0] lo_clk_20mhz_trim_complete [1] lo_clk_trim_complete [2] is_test_comp_complete [3] is_test_dnl_complete ...(more) */
} TESTSTAT_t;


#define TESTSTAT_BASE (0x70005C00u)                                                          /*!< teststat base address */

/** __TESTSTAT_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BASE_PTR(void)
{
    return (uint32_t*)(TESTSTAT_BASE);
}


/* -------------------------------------------------------------------------- */
/*                       BIST_AVG1 member of TESTSTAT_t                       */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_AVG1__ADDRESS returns the address of member BIST_AVG1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_AVG1
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_AVG1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_AVG1)));
}

/** TESTSTAT_BIST_AVG1__GET() gets BIST_AVG1's current value.
 *
 * When reading from BIST_AVG1, this is mandatory to use.
 *
 * @return current value of BIST_AVG1
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG1__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_AVG1__ADDRESS());
}

/* ----------------- TESTSTAT.BIST_AVG1.IADC_CH2_AVG_VALID ----------------- */

/**
<pre>
  TESTSTAT.BIST_AVG1.IADC_CH2_AVG_VALID:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__Pos             29                                                                     /*!< Right-most bit position of iadc_ch2_avg_valid in TESTSTAT.BIST_AVG1 */
#define TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__Msk             (0x00000001UL << TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__Pos)          /*!< Mask for iadc_ch2_avg_valid in TESTSTAT.BIST_AVG1 */
#define TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__Shift(v)        (((v) << TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__Pos) & TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__Msk) /*!< Shift value 'v' into iadc_ch2_avg_valid and mask 'v' to fit it into iadc_ch2_avg_valid field */

/** TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__GET() gets BIST_AVG1.IADC_CH2_AVG_VALID's current value.
 *
 * When reading from BIST_AVG1.IADC_CH2_AVG_VALID, this is recommended to use.
 *
 * @return current value of BIST_AVG1.IADC_CH2_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG1__GET();
    reg = (reg & TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__EXTRACT() extracts BIST_AVG1.IADC_CH2_AVG_VALID.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG1
 * @return current value of BIST_AVG1.IADC_CH2_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG1__IADC_CH2_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/* -------------------- TESTSTAT.BIST_AVG1.IADC_CH2_AVG -------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG1.IADC_CH2_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG1__IADC_CH2_AVG__Pos                   15                                                                     /*!< Right-most bit position of iadc_ch2_avg in TESTSTAT.BIST_AVG1 */
#define TESTSTAT_BIST_AVG1__IADC_CH2_AVG__Msk                   (0x00003FFFUL << TESTSTAT_BIST_AVG1__IADC_CH2_AVG__Pos)                /*!< Mask for iadc_ch2_avg in TESTSTAT.BIST_AVG1 */
#define TESTSTAT_BIST_AVG1__IADC_CH2_AVG__Shift(v)              (((v) << TESTSTAT_BIST_AVG1__IADC_CH2_AVG__Pos) & TESTSTAT_BIST_AVG1__IADC_CH2_AVG__Msk) /*!< Shift value 'v' into iadc_ch2_avg and mask 'v' to fit it into iadc_ch2_avg field */

/** TESTSTAT_BIST_AVG1__IADC_CH2_AVG__GET() gets BIST_AVG1.IADC_CH2_AVG's current value.
 *
 * When reading from BIST_AVG1.IADC_CH2_AVG, this is recommended to use.
 *
 * @return current value of BIST_AVG1.IADC_CH2_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG1__IADC_CH2_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG1__GET();
    reg = (reg & TESTSTAT_BIST_AVG1__IADC_CH2_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG1__IADC_CH2_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG1__IADC_CH2_AVG__EXTRACT() extracts BIST_AVG1.IADC_CH2_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG1
 * @return current value of BIST_AVG1.IADC_CH2_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG1__IADC_CH2_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG1__IADC_CH2_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG1__IADC_CH2_AVG__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_AVG1.IADC_CH1_AVG_VALID ----------------- */

/**
<pre>
  TESTSTAT.BIST_AVG1.IADC_CH1_AVG_VALID:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__Pos             14                                                                     /*!< Right-most bit position of iadc_ch1_avg_valid in TESTSTAT.BIST_AVG1 */
#define TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__Msk             (0x00000001UL << TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__Pos)          /*!< Mask for iadc_ch1_avg_valid in TESTSTAT.BIST_AVG1 */
#define TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__Shift(v)        (((v) << TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__Pos) & TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__Msk) /*!< Shift value 'v' into iadc_ch1_avg_valid and mask 'v' to fit it into iadc_ch1_avg_valid field */

/** TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__GET() gets BIST_AVG1.IADC_CH1_AVG_VALID's current value.
 *
 * When reading from BIST_AVG1.IADC_CH1_AVG_VALID, this is recommended to use.
 *
 * @return current value of BIST_AVG1.IADC_CH1_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG1__GET();
    reg = (reg & TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__EXTRACT() extracts BIST_AVG1.IADC_CH1_AVG_VALID.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG1
 * @return current value of BIST_AVG1.IADC_CH1_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG1__IADC_CH1_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/* -------------------- TESTSTAT.BIST_AVG1.IADC_CH1_AVG -------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG1.IADC_CH1_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG1__IADC_CH1_AVG__Pos                   0                                                                      /*!< Right-most bit position of iadc_ch1_avg in TESTSTAT.BIST_AVG1 */
#define TESTSTAT_BIST_AVG1__IADC_CH1_AVG__Msk                   (0x00003FFFUL << TESTSTAT_BIST_AVG1__IADC_CH1_AVG__Pos)                /*!< Mask for iadc_ch1_avg in TESTSTAT.BIST_AVG1 */
#define TESTSTAT_BIST_AVG1__IADC_CH1_AVG__Shift(v)              (((v) << TESTSTAT_BIST_AVG1__IADC_CH1_AVG__Pos) & TESTSTAT_BIST_AVG1__IADC_CH1_AVG__Msk) /*!< Shift value 'v' into iadc_ch1_avg and mask 'v' to fit it into iadc_ch1_avg field */

/** TESTSTAT_BIST_AVG1__IADC_CH1_AVG__GET() gets BIST_AVG1.IADC_CH1_AVG's current value.
 *
 * When reading from BIST_AVG1.IADC_CH1_AVG, this is recommended to use.
 *
 * @return current value of BIST_AVG1.IADC_CH1_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG1__IADC_CH1_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG1__GET();
    reg = (reg & TESTSTAT_BIST_AVG1__IADC_CH1_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG1__IADC_CH1_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG1__IADC_CH1_AVG__EXTRACT() extracts BIST_AVG1.IADC_CH1_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG1
 * @return current value of BIST_AVG1.IADC_CH1_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG1__IADC_CH1_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG1__IADC_CH1_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG1__IADC_CH1_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       BIST_AVG2 member of TESTSTAT_t                       */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_AVG2__ADDRESS returns the address of member BIST_AVG2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_AVG2
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_AVG2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_AVG2)));
}

/** TESTSTAT_BIST_AVG2__GET() gets BIST_AVG2's current value.
 *
 * When reading from BIST_AVG2, this is mandatory to use.
 *
 * @return current value of BIST_AVG2
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG2__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_AVG2__ADDRESS());
}

/* ------------------- TESTSTAT.BIST_AVG2.TADC_AVG_VALID ------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG2.TADC_AVG_VALID:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG2__TADC_AVG_VALID__Pos                 30                                                                     /*!< Right-most bit position of tadc_avg_valid in TESTSTAT.BIST_AVG2 */
#define TESTSTAT_BIST_AVG2__TADC_AVG_VALID__Msk                 (0x00000001UL << TESTSTAT_BIST_AVG2__TADC_AVG_VALID__Pos)              /*!< Mask for tadc_avg_valid in TESTSTAT.BIST_AVG2 */
#define TESTSTAT_BIST_AVG2__TADC_AVG_VALID__Shift(v)            (((v) << TESTSTAT_BIST_AVG2__TADC_AVG_VALID__Pos) & TESTSTAT_BIST_AVG2__TADC_AVG_VALID__Msk) /*!< Shift value 'v' into tadc_avg_valid and mask 'v' to fit it into tadc_avg_valid field */

/** TESTSTAT_BIST_AVG2__TADC_AVG_VALID__GET() gets BIST_AVG2.TADC_AVG_VALID's current value.
 *
 * When reading from BIST_AVG2.TADC_AVG_VALID, this is recommended to use.
 *
 * @return current value of BIST_AVG2.TADC_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG2__TADC_AVG_VALID__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG2__GET();
    reg = (reg & TESTSTAT_BIST_AVG2__TADC_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG2__TADC_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG2__TADC_AVG_VALID__EXTRACT() extracts BIST_AVG2.TADC_AVG_VALID.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG2
 * @return current value of BIST_AVG2.TADC_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG2__TADC_AVG_VALID__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG2__TADC_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG2__TADC_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TESTSTAT.BIST_AVG2.TADC_AVG ---------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG2.TADC_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG2__TADC_AVG__Pos                       15                                                                     /*!< Right-most bit position of tadc_avg in TESTSTAT.BIST_AVG2 */
#define TESTSTAT_BIST_AVG2__TADC_AVG__Msk                       (0x00007FFFUL << TESTSTAT_BIST_AVG2__TADC_AVG__Pos)                    /*!< Mask for tadc_avg in TESTSTAT.BIST_AVG2 */
#define TESTSTAT_BIST_AVG2__TADC_AVG__Shift(v)                  (((v) << TESTSTAT_BIST_AVG2__TADC_AVG__Pos) & TESTSTAT_BIST_AVG2__TADC_AVG__Msk) /*!< Shift value 'v' into tadc_avg and mask 'v' to fit it into tadc_avg field */

/** TESTSTAT_BIST_AVG2__TADC_AVG__GET() gets BIST_AVG2.TADC_AVG's current value.
 *
 * When reading from BIST_AVG2.TADC_AVG, this is recommended to use.
 *
 * @return current value of BIST_AVG2.TADC_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG2__TADC_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG2__GET();
    reg = (reg & TESTSTAT_BIST_AVG2__TADC_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG2__TADC_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG2__TADC_AVG__EXTRACT() extracts BIST_AVG2.TADC_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG2
 * @return current value of BIST_AVG2.TADC_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG2__TADC_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG2__TADC_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG2__TADC_AVG__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_AVG2.IADC_CH3_AVG_VALID ----------------- */

/**
<pre>
  TESTSTAT.BIST_AVG2.IADC_CH3_AVG_VALID:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__Pos             14                                                                     /*!< Right-most bit position of iadc_ch3_avg_valid in TESTSTAT.BIST_AVG2 */
#define TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__Msk             (0x00000001UL << TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__Pos)          /*!< Mask for iadc_ch3_avg_valid in TESTSTAT.BIST_AVG2 */
#define TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__Shift(v)        (((v) << TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__Pos) & TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__Msk) /*!< Shift value 'v' into iadc_ch3_avg_valid and mask 'v' to fit it into iadc_ch3_avg_valid field */

/** TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__GET() gets BIST_AVG2.IADC_CH3_AVG_VALID's current value.
 *
 * When reading from BIST_AVG2.IADC_CH3_AVG_VALID, this is recommended to use.
 *
 * @return current value of BIST_AVG2.IADC_CH3_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG2__GET();
    reg = (reg & TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__EXTRACT() extracts BIST_AVG2.IADC_CH3_AVG_VALID.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG2
 * @return current value of BIST_AVG2.IADC_CH3_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG2__IADC_CH3_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/* -------------------- TESTSTAT.BIST_AVG2.IADC_CH3_AVG -------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG2.IADC_CH3_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG2__IADC_CH3_AVG__Pos                   0                                                                      /*!< Right-most bit position of iadc_ch3_avg in TESTSTAT.BIST_AVG2 */
#define TESTSTAT_BIST_AVG2__IADC_CH3_AVG__Msk                   (0x00003FFFUL << TESTSTAT_BIST_AVG2__IADC_CH3_AVG__Pos)                /*!< Mask for iadc_ch3_avg in TESTSTAT.BIST_AVG2 */
#define TESTSTAT_BIST_AVG2__IADC_CH3_AVG__Shift(v)              (((v) << TESTSTAT_BIST_AVG2__IADC_CH3_AVG__Pos) & TESTSTAT_BIST_AVG2__IADC_CH3_AVG__Msk) /*!< Shift value 'v' into iadc_ch3_avg and mask 'v' to fit it into iadc_ch3_avg field */

/** TESTSTAT_BIST_AVG2__IADC_CH3_AVG__GET() gets BIST_AVG2.IADC_CH3_AVG's current value.
 *
 * When reading from BIST_AVG2.IADC_CH3_AVG, this is recommended to use.
 *
 * @return current value of BIST_AVG2.IADC_CH3_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG2__IADC_CH3_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG2__GET();
    reg = (reg & TESTSTAT_BIST_AVG2__IADC_CH3_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG2__IADC_CH3_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG2__IADC_CH3_AVG__EXTRACT() extracts BIST_AVG2.IADC_CH3_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG2
 * @return current value of BIST_AVG2.IADC_CH3_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG2__IADC_CH3_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG2__IADC_CH3_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG2__IADC_CH3_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       BIST_AVG3 member of TESTSTAT_t                       */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_AVG3__ADDRESS returns the address of member BIST_AVG3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_AVG3
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_AVG3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_AVG3)));
}

/** TESTSTAT_BIST_AVG3__GET() gets BIST_AVG3's current value.
 *
 * When reading from BIST_AVG3, this is mandatory to use.
 *
 * @return current value of BIST_AVG3
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG3__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_AVG3__ADDRESS());
}

/* ----------------- TESTSTAT.BIST_AVG3.VADC_CH0_AVG_VALID ----------------- */

/**
<pre>
  TESTSTAT.BIST_AVG3.VADC_CH0_AVG_VALID:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__Pos             31                                                                     /*!< Right-most bit position of vadc_ch0_avg_valid in TESTSTAT.BIST_AVG3 */
#define TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__Msk             (0x00000001UL << TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__Pos)          /*!< Mask for vadc_ch0_avg_valid in TESTSTAT.BIST_AVG3 */
#define TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__Shift(v)        (((v) << TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__Pos) & TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__Msk) /*!< Shift value 'v' into vadc_ch0_avg_valid and mask 'v' to fit it into vadc_ch0_avg_valid field */

/** TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__GET() gets BIST_AVG3.VADC_CH0_AVG_VALID's current value.
 *
 * When reading from BIST_AVG3.VADC_CH0_AVG_VALID, this is recommended to use.
 *
 * @return current value of BIST_AVG3.VADC_CH0_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG3__GET();
    reg = (reg & TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__EXTRACT() extracts BIST_AVG3.VADC_CH0_AVG_VALID.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG3
 * @return current value of BIST_AVG3.VADC_CH0_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG3__VADC_CH0_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_AVG3.VS0_OS_TRIM_TM ------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG3.VS0_OS_TRIM_TM:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__Pos                 24                                                                     /*!< Right-most bit position of vs0_os_trim_tm in TESTSTAT.BIST_AVG3 */
#define TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__Msk                 (0x0000007FUL << TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__Pos)              /*!< Mask for vs0_os_trim_tm in TESTSTAT.BIST_AVG3 */
#define TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__Shift(v)            (((v) << TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__Pos) & TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__Msk) /*!< Shift value 'v' into vs0_os_trim_tm and mask 'v' to fit it into vs0_os_trim_tm field */

/** TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__GET() gets BIST_AVG3.VS0_OS_TRIM_TM's current value.
 *
 * When reading from BIST_AVG3.VS0_OS_TRIM_TM, this is recommended to use.
 *
 * @return current value of BIST_AVG3.VS0_OS_TRIM_TM
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG3__GET();
    reg = (reg & TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__EXTRACT() extracts BIST_AVG3.VS0_OS_TRIM_TM.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG3
 * @return current value of BIST_AVG3.VS0_OS_TRIM_TM
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG3__VS0_OS_TRIM_TM__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_AVG3.VS0_OS_TRIM_AVG ------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG3.VS0_OS_TRIM_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__Pos                16                                                                     /*!< Right-most bit position of vs0_os_trim_avg in TESTSTAT.BIST_AVG3 */
#define TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__Msk                (0x000000FFUL << TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__Pos)             /*!< Mask for vs0_os_trim_avg in TESTSTAT.BIST_AVG3 */
#define TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__Shift(v)           (((v) << TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__Pos) & TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__Msk) /*!< Shift value 'v' into vs0_os_trim_avg and mask 'v' to fit it into vs0_os_trim_avg field */

/** TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__GET() gets BIST_AVG3.VS0_OS_TRIM_AVG's current value.
 *
 * When reading from BIST_AVG3.VS0_OS_TRIM_AVG, this is recommended to use.
 *
 * @return current value of BIST_AVG3.VS0_OS_TRIM_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG3__GET();
    reg = (reg & TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__EXTRACT() extracts BIST_AVG3.VS0_OS_TRIM_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG3
 * @return current value of BIST_AVG3.VS0_OS_TRIM_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG3__VS0_OS_TRIM_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------- TESTSTAT.BIST_AVG3.VADC_CH0_AVG -------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG3.VADC_CH0_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG3__VADC_CH0_AVG__Pos                   0                                                                      /*!< Right-most bit position of vadc_ch0_avg in TESTSTAT.BIST_AVG3 */
#define TESTSTAT_BIST_AVG3__VADC_CH0_AVG__Msk                   (0x0000FFFFUL << TESTSTAT_BIST_AVG3__VADC_CH0_AVG__Pos)                /*!< Mask for vadc_ch0_avg in TESTSTAT.BIST_AVG3 */
#define TESTSTAT_BIST_AVG3__VADC_CH0_AVG__Shift(v)              (((v) << TESTSTAT_BIST_AVG3__VADC_CH0_AVG__Pos) & TESTSTAT_BIST_AVG3__VADC_CH0_AVG__Msk) /*!< Shift value 'v' into vadc_ch0_avg and mask 'v' to fit it into vadc_ch0_avg field */

/** TESTSTAT_BIST_AVG3__VADC_CH0_AVG__GET() gets BIST_AVG3.VADC_CH0_AVG's current value.
 *
 * When reading from BIST_AVG3.VADC_CH0_AVG, this is recommended to use.
 *
 * @return current value of BIST_AVG3.VADC_CH0_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG3__VADC_CH0_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG3__GET();
    reg = (reg & TESTSTAT_BIST_AVG3__VADC_CH0_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG3__VADC_CH0_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG3__VADC_CH0_AVG__EXTRACT() extracts BIST_AVG3.VADC_CH0_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG3
 * @return current value of BIST_AVG3.VADC_CH0_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG3__VADC_CH0_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG3__VADC_CH0_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG3__VADC_CH0_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       BIST_AVG4 member of TESTSTAT_t                       */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_AVG4__ADDRESS returns the address of member BIST_AVG4.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_AVG4
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_AVG4__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_AVG4)));
}

/** TESTSTAT_BIST_AVG4__GET() gets BIST_AVG4's current value.
 *
 * When reading from BIST_AVG4, this is mandatory to use.
 *
 * @return current value of BIST_AVG4
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG4__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_AVG4__ADDRESS());
}

/* ----------------- TESTSTAT.BIST_AVG4.VADC_CH1_AVG_VALID ----------------- */

/**
<pre>
  TESTSTAT.BIST_AVG4.VADC_CH1_AVG_VALID:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__Pos             31                                                                     /*!< Right-most bit position of vadc_ch1_avg_valid in TESTSTAT.BIST_AVG4 */
#define TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__Msk             (0x00000001UL << TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__Pos)          /*!< Mask for vadc_ch1_avg_valid in TESTSTAT.BIST_AVG4 */
#define TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__Shift(v)        (((v) << TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__Pos) & TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__Msk) /*!< Shift value 'v' into vadc_ch1_avg_valid and mask 'v' to fit it into vadc_ch1_avg_valid field */

/** TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__GET() gets BIST_AVG4.VADC_CH1_AVG_VALID's current value.
 *
 * When reading from BIST_AVG4.VADC_CH1_AVG_VALID, this is recommended to use.
 *
 * @return current value of BIST_AVG4.VADC_CH1_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG4__GET();
    reg = (reg & TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__EXTRACT() extracts BIST_AVG4.VADC_CH1_AVG_VALID.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG4
 * @return current value of BIST_AVG4.VADC_CH1_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG4__VADC_CH1_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_AVG4.VS1_OS_TRIM_TM ------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG4.VS1_OS_TRIM_TM:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__Pos                 24                                                                     /*!< Right-most bit position of vs1_os_trim_tm in TESTSTAT.BIST_AVG4 */
#define TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__Msk                 (0x0000007FUL << TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__Pos)              /*!< Mask for vs1_os_trim_tm in TESTSTAT.BIST_AVG4 */
#define TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__Shift(v)            (((v) << TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__Pos) & TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__Msk) /*!< Shift value 'v' into vs1_os_trim_tm and mask 'v' to fit it into vs1_os_trim_tm field */

/** TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__GET() gets BIST_AVG4.VS1_OS_TRIM_TM's current value.
 *
 * When reading from BIST_AVG4.VS1_OS_TRIM_TM, this is recommended to use.
 *
 * @return current value of BIST_AVG4.VS1_OS_TRIM_TM
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG4__GET();
    reg = (reg & TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__EXTRACT() extracts BIST_AVG4.VS1_OS_TRIM_TM.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG4
 * @return current value of BIST_AVG4.VS1_OS_TRIM_TM
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG4__VS1_OS_TRIM_TM__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_AVG4.VS1_OS_TRIM_AVG ------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG4.VS1_OS_TRIM_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__Pos                16                                                                     /*!< Right-most bit position of vs1_os_trim_avg in TESTSTAT.BIST_AVG4 */
#define TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__Msk                (0x000000FFUL << TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__Pos)             /*!< Mask for vs1_os_trim_avg in TESTSTAT.BIST_AVG4 */
#define TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__Shift(v)           (((v) << TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__Pos) & TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__Msk) /*!< Shift value 'v' into vs1_os_trim_avg and mask 'v' to fit it into vs1_os_trim_avg field */

/** TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__GET() gets BIST_AVG4.VS1_OS_TRIM_AVG's current value.
 *
 * When reading from BIST_AVG4.VS1_OS_TRIM_AVG, this is recommended to use.
 *
 * @return current value of BIST_AVG4.VS1_OS_TRIM_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG4__GET();
    reg = (reg & TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__EXTRACT() extracts BIST_AVG4.VS1_OS_TRIM_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG4
 * @return current value of BIST_AVG4.VS1_OS_TRIM_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG4__VS1_OS_TRIM_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------- TESTSTAT.BIST_AVG4.VADC_CH1_AVG -------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG4.VADC_CH1_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG4__VADC_CH1_AVG__Pos                   0                                                                      /*!< Right-most bit position of vadc_ch1_avg in TESTSTAT.BIST_AVG4 */
#define TESTSTAT_BIST_AVG4__VADC_CH1_AVG__Msk                   (0x0000FFFFUL << TESTSTAT_BIST_AVG4__VADC_CH1_AVG__Pos)                /*!< Mask for vadc_ch1_avg in TESTSTAT.BIST_AVG4 */
#define TESTSTAT_BIST_AVG4__VADC_CH1_AVG__Shift(v)              (((v) << TESTSTAT_BIST_AVG4__VADC_CH1_AVG__Pos) & TESTSTAT_BIST_AVG4__VADC_CH1_AVG__Msk) /*!< Shift value 'v' into vadc_ch1_avg and mask 'v' to fit it into vadc_ch1_avg field */

/** TESTSTAT_BIST_AVG4__VADC_CH1_AVG__GET() gets BIST_AVG4.VADC_CH1_AVG's current value.
 *
 * When reading from BIST_AVG4.VADC_CH1_AVG, this is recommended to use.
 *
 * @return current value of BIST_AVG4.VADC_CH1_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG4__VADC_CH1_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG4__GET();
    reg = (reg & TESTSTAT_BIST_AVG4__VADC_CH1_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG4__VADC_CH1_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG4__VADC_CH1_AVG__EXTRACT() extracts BIST_AVG4.VADC_CH1_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG4
 * @return current value of BIST_AVG4.VADC_CH1_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG4__VADC_CH1_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG4__VADC_CH1_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG4__VADC_CH1_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       BIST_AVG5 member of TESTSTAT_t                       */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_AVG5__ADDRESS returns the address of member BIST_AVG5.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_AVG5
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_AVG5__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_AVG5)));
}

/** TESTSTAT_BIST_AVG5__GET() gets BIST_AVG5's current value.
 *
 * When reading from BIST_AVG5, this is mandatory to use.
 *
 * @return current value of BIST_AVG5
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG5__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_AVG5__ADDRESS());
}

/* ----------------- TESTSTAT.BIST_AVG5.VADC_CH2_AVG_VALID ----------------- */

/**
<pre>
  TESTSTAT.BIST_AVG5.VADC_CH2_AVG_VALID:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__Pos             31                                                                     /*!< Right-most bit position of vadc_ch2_avg_valid in TESTSTAT.BIST_AVG5 */
#define TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__Msk             (0x00000001UL << TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__Pos)          /*!< Mask for vadc_ch2_avg_valid in TESTSTAT.BIST_AVG5 */
#define TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__Shift(v)        (((v) << TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__Pos) & TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__Msk) /*!< Shift value 'v' into vadc_ch2_avg_valid and mask 'v' to fit it into vadc_ch2_avg_valid field */

/** TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__GET() gets BIST_AVG5.VADC_CH2_AVG_VALID's current value.
 *
 * When reading from BIST_AVG5.VADC_CH2_AVG_VALID, this is recommended to use.
 *
 * @return current value of BIST_AVG5.VADC_CH2_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG5__GET();
    reg = (reg & TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__EXTRACT() extracts BIST_AVG5.VADC_CH2_AVG_VALID.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG5
 * @return current value of BIST_AVG5.VADC_CH2_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG5__VADC_CH2_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_AVG5.VS2_OS_TRIM_TM ------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG5.VS2_OS_TRIM_TM:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__Pos                 24                                                                     /*!< Right-most bit position of vs2_os_trim_tm in TESTSTAT.BIST_AVG5 */
#define TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__Msk                 (0x0000007FUL << TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__Pos)              /*!< Mask for vs2_os_trim_tm in TESTSTAT.BIST_AVG5 */
#define TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__Shift(v)            (((v) << TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__Pos) & TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__Msk) /*!< Shift value 'v' into vs2_os_trim_tm and mask 'v' to fit it into vs2_os_trim_tm field */

/** TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__GET() gets BIST_AVG5.VS2_OS_TRIM_TM's current value.
 *
 * When reading from BIST_AVG5.VS2_OS_TRIM_TM, this is recommended to use.
 *
 * @return current value of BIST_AVG5.VS2_OS_TRIM_TM
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG5__GET();
    reg = (reg & TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__EXTRACT() extracts BIST_AVG5.VS2_OS_TRIM_TM.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG5
 * @return current value of BIST_AVG5.VS2_OS_TRIM_TM
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG5__VS2_OS_TRIM_TM__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_AVG5.VS2_OS_TRIM_AVG ------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG5.VS2_OS_TRIM_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__Pos                16                                                                     /*!< Right-most bit position of vs2_os_trim_avg in TESTSTAT.BIST_AVG5 */
#define TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__Msk                (0x000000FFUL << TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__Pos)             /*!< Mask for vs2_os_trim_avg in TESTSTAT.BIST_AVG5 */
#define TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__Shift(v)           (((v) << TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__Pos) & TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__Msk) /*!< Shift value 'v' into vs2_os_trim_avg and mask 'v' to fit it into vs2_os_trim_avg field */

/** TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__GET() gets BIST_AVG5.VS2_OS_TRIM_AVG's current value.
 *
 * When reading from BIST_AVG5.VS2_OS_TRIM_AVG, this is recommended to use.
 *
 * @return current value of BIST_AVG5.VS2_OS_TRIM_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG5__GET();
    reg = (reg & TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__EXTRACT() extracts BIST_AVG5.VS2_OS_TRIM_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG5
 * @return current value of BIST_AVG5.VS2_OS_TRIM_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG5__VS2_OS_TRIM_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------- TESTSTAT.BIST_AVG5.VADC_CH2_AVG -------------------- */

/**
<pre>
  TESTSTAT.BIST_AVG5.VADC_CH2_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_AVG5__VADC_CH2_AVG__Pos                   0                                                                      /*!< Right-most bit position of vadc_ch2_avg in TESTSTAT.BIST_AVG5 */
#define TESTSTAT_BIST_AVG5__VADC_CH2_AVG__Msk                   (0x0000FFFFUL << TESTSTAT_BIST_AVG5__VADC_CH2_AVG__Pos)                /*!< Mask for vadc_ch2_avg in TESTSTAT.BIST_AVG5 */
#define TESTSTAT_BIST_AVG5__VADC_CH2_AVG__Shift(v)              (((v) << TESTSTAT_BIST_AVG5__VADC_CH2_AVG__Pos) & TESTSTAT_BIST_AVG5__VADC_CH2_AVG__Msk) /*!< Shift value 'v' into vadc_ch2_avg and mask 'v' to fit it into vadc_ch2_avg field */

/** TESTSTAT_BIST_AVG5__VADC_CH2_AVG__GET() gets BIST_AVG5.VADC_CH2_AVG's current value.
 *
 * When reading from BIST_AVG5.VADC_CH2_AVG, this is recommended to use.
 *
 * @return current value of BIST_AVG5.VADC_CH2_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG5__VADC_CH2_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_AVG5__GET();
    reg = (reg & TESTSTAT_BIST_AVG5__VADC_CH2_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG5__VADC_CH2_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_AVG5__VADC_CH2_AVG__EXTRACT() extracts BIST_AVG5.VADC_CH2_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_AVG5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_AVG5
 * @return current value of BIST_AVG5.VADC_CH2_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_AVG5__VADC_CH2_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_AVG5__VADC_CH2_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_AVG5__VADC_CH2_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       BIST_LO1 member of TESTSTAT_t                       */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_LO1__ADDRESS returns the address of member BIST_LO1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_LO1
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_LO1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_LO1)));
}

/** TESTSTAT_BIST_LO1__GET() gets BIST_LO1's current value.
 *
 * When reading from BIST_LO1, this is mandatory to use.
 *
 * @return current value of BIST_LO1
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_LO1__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_LO1.LO_CLK_20MHZ_TRIM_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_LO1.LO_CLK_20MHZ_TRIM_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__Pos           18                                                                     /*!< Right-most bit position of lo_clk_20mhz_trim_err in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__Pos)        /*!< Mask for lo_clk_20mhz_trim_err in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__Shift(v)      (((v) << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__Pos) & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__Msk) /*!< Shift value 'v' into lo_clk_20mhz_trim_err and mask 'v' to fit it into lo_clk_20mhz_trim_err field */

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__GET() gets BIST_LO1.LO_CLK_20MHZ_TRIM_ERR's current value.
 *
 * When reading from BIST_LO1.LO_CLK_20MHZ_TRIM_ERR, this is recommended to use.
 *
 * @return current value of BIST_LO1.LO_CLK_20MHZ_TRIM_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO1__GET();
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__EXTRACT() extracts BIST_LO1.LO_CLK_20MHZ_TRIM_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO1
 * @return current value of BIST_LO1.LO_CLK_20MHZ_TRIM_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_ERR__Pos);
    return (uint32_t)reg;
}

/* -------------- TESTSTAT.BIST_LO1.LO_CLK_20MHZ_TRIM_COMPLETE -------------- */

/**
<pre>
  TESTSTAT.BIST_LO1.LO_CLK_20MHZ_TRIM_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__Pos      17                                                                     /*!< Right-most bit position of lo_clk_20mhz_trim_complete in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__Msk      (0x00000001UL << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__Pos)   /*!< Mask for lo_clk_20mhz_trim_complete in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__Shift(v) (((v) << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__Pos) & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__Msk) /*!< Shift value 'v' into lo_clk_20mhz_trim_complete and mask 'v' to fit it into lo_clk_20mhz_trim_complete field */

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__GET() gets BIST_LO1.LO_CLK_20MHZ_TRIM_COMPLETE's current value.
 *
 * When reading from BIST_LO1.LO_CLK_20MHZ_TRIM_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_LO1.LO_CLK_20MHZ_TRIM_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO1__GET();
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__EXTRACT() extracts BIST_LO1.LO_CLK_20MHZ_TRIM_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO1
 * @return current value of BIST_LO1.LO_CLK_20MHZ_TRIM_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* ------------- TESTSTAT.BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_OVR ------------- */

/**
<pre>
  TESTSTAT.BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_OVR:

    TBD

</pre> */

#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__Pos    16                                                                     /*!< Right-most bit position of lo_clk_20mhz_trim_coarse_ovr in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__Msk    (0x00000001UL << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__Pos) /*!< Mask for lo_clk_20mhz_trim_coarse_ovr in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__Shift(v) (((v) << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__Pos) & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__Msk) /*!< Shift value 'v' into lo_clk_20mhz_trim_coarse_ovr and mask 'v' to fit it into lo_clk_20mhz_trim_coarse_ovr field */

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__GET() gets BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_OVR's current value.
 *
 * When reading from BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_OVR, this is recommended to use.
 *
 * @return current value of BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_OVR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO1__GET();
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__EXTRACT() extracts BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_OVR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO1
 * @return current value of BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_OVR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_OVR__Pos);
    return (uint32_t)reg;
}

/* ------------ TESTSTAT.BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_BIST ------------ */

/**
<pre>
  TESTSTAT.BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_BIST:

    TBD

</pre> */

#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__Pos   9                                                                      /*!< Right-most bit position of lo_clk_20mhz_trim_coarse_bist in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__Msk   (0x0000007FUL << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__Pos) /*!< Mask for lo_clk_20mhz_trim_coarse_bist in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__Shift(v) (((v) << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__Pos) & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__Msk) /*!< Shift value 'v' into lo_clk_20mhz_trim_coarse_bist and mask 'v' to fit it into lo_clk_20mhz_trim_coarse_bist field */

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__GET() gets BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_BIST's current value.
 *
 * When reading from BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_BIST, this is recommended to use.
 *
 * @return current value of BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_BIST
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO1__GET();
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__EXTRACT() extracts BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_BIST.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO1
 * @return current value of BIST_LO1.LO_CLK_20MHZ_TRIM_COARSE_BIST
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_TRIM_COARSE_BIST__Pos);
    return (uint32_t)reg;
}

/* -------------- TESTSTAT.BIST_LO1.LO_CLK_20MHZ_ERR_AVG_VALID -------------- */

/**
<pre>
  TESTSTAT.BIST_LO1.LO_CLK_20MHZ_ERR_AVG_VALID:

    TBD

</pre> */

#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__Pos      8                                                                      /*!< Right-most bit position of lo_clk_20mhz_err_avg_valid in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__Msk      (0x00000001UL << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__Pos)   /*!< Mask for lo_clk_20mhz_err_avg_valid in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__Shift(v) (((v) << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__Pos) & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__Msk) /*!< Shift value 'v' into lo_clk_20mhz_err_avg_valid and mask 'v' to fit it into lo_clk_20mhz_err_avg_valid field */

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__GET() gets BIST_LO1.LO_CLK_20MHZ_ERR_AVG_VALID's current value.
 *
 * When reading from BIST_LO1.LO_CLK_20MHZ_ERR_AVG_VALID, this is recommended to use.
 *
 * @return current value of BIST_LO1.LO_CLK_20MHZ_ERR_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO1__GET();
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__EXTRACT() extracts BIST_LO1.LO_CLK_20MHZ_ERR_AVG_VALID.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO1
 * @return current value of BIST_LO1.LO_CLK_20MHZ_ERR_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_LO1.LO_CLK_20MHZ_ERR_AVG ----------------- */

/**
<pre>
  TESTSTAT.BIST_LO1.LO_CLK_20MHZ_ERR_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__Pos            0                                                                      /*!< Right-most bit position of lo_clk_20mhz_err_avg in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__Msk            (0x000000FFUL << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__Pos)         /*!< Mask for lo_clk_20mhz_err_avg in TESTSTAT.BIST_LO1 */
#define TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__Shift(v)       (((v) << TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__Pos) & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__Msk) /*!< Shift value 'v' into lo_clk_20mhz_err_avg and mask 'v' to fit it into lo_clk_20mhz_err_avg field */

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__GET() gets BIST_LO1.LO_CLK_20MHZ_ERR_AVG's current value.
 *
 * When reading from BIST_LO1.LO_CLK_20MHZ_ERR_AVG, this is recommended to use.
 *
 * @return current value of BIST_LO1.LO_CLK_20MHZ_ERR_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO1__GET();
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__EXTRACT() extracts BIST_LO1.LO_CLK_20MHZ_ERR_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO1
 * @return current value of BIST_LO1.LO_CLK_20MHZ_ERR_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_LO1__LO_CLK_20MHZ_ERR_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       BIST_LO2 member of TESTSTAT_t                       */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_LO2__ADDRESS returns the address of member BIST_LO2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_LO2
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_LO2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_LO2)));
}

/** TESTSTAT_BIST_LO2__GET() gets BIST_LO2's current value.
 *
 * When reading from BIST_LO2, this is mandatory to use.
 *
 * @return current value of BIST_LO2
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_LO2__ADDRESS());
}

/* ----------------- TESTSTAT.BIST_LO2.LO_CLK_TRIM_FINE_OVR ----------------- */

/**
<pre>
  TESTSTAT.BIST_LO2.LO_CLK_TRIM_FINE_OVR:

    TBD

</pre> */

#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__Pos            24                                                                     /*!< Right-most bit position of lo_clk_trim_fine_ovr in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__Msk            (0x00000001UL << TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__Pos)         /*!< Mask for lo_clk_trim_fine_ovr in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__Shift(v)       (((v) << TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__Pos) & TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__Msk) /*!< Shift value 'v' into lo_clk_trim_fine_ovr and mask 'v' to fit it into lo_clk_trim_fine_ovr field */

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__GET() gets BIST_LO2.LO_CLK_TRIM_FINE_OVR's current value.
 *
 * When reading from BIST_LO2.LO_CLK_TRIM_FINE_OVR, this is recommended to use.
 *
 * @return current value of BIST_LO2.LO_CLK_TRIM_FINE_OVR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO2__GET();
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__EXTRACT() extracts BIST_LO2.LO_CLK_TRIM_FINE_OVR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO2
 * @return current value of BIST_LO2.LO_CLK_TRIM_FINE_OVR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_OVR__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_LO2.LO_CLK_TRIM_FINE_BIST ---------------- */

/**
<pre>
  TESTSTAT.BIST_LO2.LO_CLK_TRIM_FINE_BIST:

    TBD

</pre> */

#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__Pos           19                                                                     /*!< Right-most bit position of lo_clk_trim_fine_bist in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__Msk           (0x0000001FUL << TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__Pos)        /*!< Mask for lo_clk_trim_fine_bist in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__Shift(v)      (((v) << TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__Pos) & TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__Msk) /*!< Shift value 'v' into lo_clk_trim_fine_bist and mask 'v' to fit it into lo_clk_trim_fine_bist field */

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__GET() gets BIST_LO2.LO_CLK_TRIM_FINE_BIST's current value.
 *
 * When reading from BIST_LO2.LO_CLK_TRIM_FINE_BIST, this is recommended to use.
 *
 * @return current value of BIST_LO2.LO_CLK_TRIM_FINE_BIST
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO2__GET();
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__EXTRACT() extracts BIST_LO2.LO_CLK_TRIM_FINE_BIST.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO2
 * @return current value of BIST_LO2.LO_CLK_TRIM_FINE_BIST
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_FINE_BIST__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_LO2.LO_CLK_TRIM_ERR ------------------- */

/**
<pre>
  TESTSTAT.BIST_LO2.LO_CLK_TRIM_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__Pos                 18                                                                     /*!< Right-most bit position of lo_clk_trim_err in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__Msk                 (0x00000001UL << TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__Pos)              /*!< Mask for lo_clk_trim_err in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__Shift(v)            (((v) << TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__Pos) & TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__Msk) /*!< Shift value 'v' into lo_clk_trim_err and mask 'v' to fit it into lo_clk_trim_err field */

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__GET() gets BIST_LO2.LO_CLK_TRIM_ERR's current value.
 *
 * When reading from BIST_LO2.LO_CLK_TRIM_ERR, this is recommended to use.
 *
 * @return current value of BIST_LO2.LO_CLK_TRIM_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO2__GET();
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__EXTRACT() extracts BIST_LO2.LO_CLK_TRIM_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO2
 * @return current value of BIST_LO2.LO_CLK_TRIM_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_ERR__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_LO2.LO_CLK_TRIM_COMPLETE ----------------- */

/**
<pre>
  TESTSTAT.BIST_LO2.LO_CLK_TRIM_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__Pos            17                                                                     /*!< Right-most bit position of lo_clk_trim_complete in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__Msk            (0x00000001UL << TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__Pos)         /*!< Mask for lo_clk_trim_complete in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__Shift(v)       (((v) << TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__Pos) & TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__Msk) /*!< Shift value 'v' into lo_clk_trim_complete and mask 'v' to fit it into lo_clk_trim_complete field */

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__GET() gets BIST_LO2.LO_CLK_TRIM_COMPLETE's current value.
 *
 * When reading from BIST_LO2.LO_CLK_TRIM_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_LO2.LO_CLK_TRIM_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO2__GET();
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__EXTRACT() extracts BIST_LO2.LO_CLK_TRIM_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO2
 * @return current value of BIST_LO2.LO_CLK_TRIM_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_LO2.LO_CLK_TRIM_COARSE_OVR ---------------- */

/**
<pre>
  TESTSTAT.BIST_LO2.LO_CLK_TRIM_COARSE_OVR:

    TBD

</pre> */

#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__Pos          16                                                                     /*!< Right-most bit position of lo_clk_trim_coarse_ovr in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__Msk          (0x00000001UL << TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__Pos)       /*!< Mask for lo_clk_trim_coarse_ovr in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__Shift(v)     (((v) << TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__Pos) & TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__Msk) /*!< Shift value 'v' into lo_clk_trim_coarse_ovr and mask 'v' to fit it into lo_clk_trim_coarse_ovr field */

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__GET() gets BIST_LO2.LO_CLK_TRIM_COARSE_OVR's current value.
 *
 * When reading from BIST_LO2.LO_CLK_TRIM_COARSE_OVR, this is recommended to use.
 *
 * @return current value of BIST_LO2.LO_CLK_TRIM_COARSE_OVR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO2__GET();
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__EXTRACT() extracts BIST_LO2.LO_CLK_TRIM_COARSE_OVR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO2
 * @return current value of BIST_LO2.LO_CLK_TRIM_COARSE_OVR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_OVR__Pos);
    return (uint32_t)reg;
}

/* --------------- TESTSTAT.BIST_LO2.LO_CLK_TRIM_COARSE_BIST --------------- */

/**
<pre>
  TESTSTAT.BIST_LO2.LO_CLK_TRIM_COARSE_BIST:

    TBD

</pre> */

#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__Pos         9                                                                      /*!< Right-most bit position of lo_clk_trim_coarse_bist in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__Msk         (0x0000007FUL << TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__Pos)      /*!< Mask for lo_clk_trim_coarse_bist in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__Shift(v)    (((v) << TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__Pos) & TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__Msk) /*!< Shift value 'v' into lo_clk_trim_coarse_bist and mask 'v' to fit it into lo_clk_trim_coarse_bist field */

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__GET() gets BIST_LO2.LO_CLK_TRIM_COARSE_BIST's current value.
 *
 * When reading from BIST_LO2.LO_CLK_TRIM_COARSE_BIST, this is recommended to use.
 *
 * @return current value of BIST_LO2.LO_CLK_TRIM_COARSE_BIST
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO2__GET();
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__EXTRACT() extracts BIST_LO2.LO_CLK_TRIM_COARSE_BIST.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO2
 * @return current value of BIST_LO2.LO_CLK_TRIM_COARSE_BIST
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_TRIM_COARSE_BIST__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_LO2.LO_CLK_ERR_AVG_VALID ----------------- */

/**
<pre>
  TESTSTAT.BIST_LO2.LO_CLK_ERR_AVG_VALID:

    TBD

</pre> */

#define TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__Pos            8                                                                      /*!< Right-most bit position of lo_clk_err_avg_valid in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__Msk            (0x00000001UL << TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__Pos)         /*!< Mask for lo_clk_err_avg_valid in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__Shift(v)       (((v) << TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__Pos) & TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__Msk) /*!< Shift value 'v' into lo_clk_err_avg_valid and mask 'v' to fit it into lo_clk_err_avg_valid field */

/** TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__GET() gets BIST_LO2.LO_CLK_ERR_AVG_VALID's current value.
 *
 * When reading from BIST_LO2.LO_CLK_ERR_AVG_VALID, this is recommended to use.
 *
 * @return current value of BIST_LO2.LO_CLK_ERR_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO2__GET();
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__EXTRACT() extracts BIST_LO2.LO_CLK_ERR_AVG_VALID.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO2
 * @return current value of BIST_LO2.LO_CLK_ERR_AVG_VALID
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG_VALID__Pos);
    return (uint32_t)reg;
}

/* -------------------- TESTSTAT.BIST_LO2.LO_CLK_ERR_AVG -------------------- */

/**
<pre>
  TESTSTAT.BIST_LO2.LO_CLK_ERR_AVG:

    TBD

</pre> */

#define TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__Pos                  0                                                                      /*!< Right-most bit position of lo_clk_err_avg in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__Msk                  (0x000000FFUL << TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__Pos)               /*!< Mask for lo_clk_err_avg in TESTSTAT.BIST_LO2 */
#define TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__Shift(v)             (((v) << TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__Pos) & TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__Msk) /*!< Shift value 'v' into lo_clk_err_avg and mask 'v' to fit it into lo_clk_err_avg field */

/** TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__GET() gets BIST_LO2.LO_CLK_ERR_AVG's current value.
 *
 * When reading from BIST_LO2.LO_CLK_ERR_AVG, this is recommended to use.
 *
 * @return current value of BIST_LO2.LO_CLK_ERR_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_LO2__GET();
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__EXTRACT() extracts BIST_LO2.LO_CLK_ERR_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_LO2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_LO2
 * @return current value of BIST_LO2.LO_CLK_ERR_AVG
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__Msk);
    reg = (reg >> TESTSTAT_BIST_LO2__LO_CLK_ERR_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_IS_COMP member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_IS_COMP__ADDRESS returns the address of member BIST_IS_COMP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_IS_COMP
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_IS_COMP__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_IS_COMP)));
}

/** TESTSTAT_BIST_IS_COMP__GET() gets BIST_IS_COMP's current value.
 *
 * When reading from BIST_IS_COMP, this is mandatory to use.
 *
 * @return current value of BIST_IS_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_IS_COMP__ADDRESS());
}

/* -------------- TESTSTAT.BIST_IS_COMP.IS_TEST_COMP_COMPLETE -------------- */

/**
<pre>
  TESTSTAT.BIST_IS_COMP.IS_TEST_COMP_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__Pos       30                                                                     /*!< Right-most bit position of is_test_comp_complete in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__Msk       (0x00000001UL << TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__Pos)    /*!< Mask for is_test_comp_complete in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__Shift(v)  (((v) << TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__Pos) & TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__Msk) /*!< Shift value 'v' into is_test_comp_complete and mask 'v' to fit it into is_test_comp_complete field */

/** TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__GET() gets BIST_IS_COMP.IS_TEST_COMP_COMPLETE's current value.
 *
 * When reading from BIST_IS_COMP.IS_TEST_COMP_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_IS_COMP.IS_TEST_COMP_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_COMP__GET();
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__EXTRACT() extracts BIST_IS_COMP.IS_TEST_COMP_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_COMP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_COMP
 * @return current value of BIST_IS_COMP.IS_TEST_COMP_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS_TEST_COMP_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_COMP.IS3_TEST_COMP_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_COMP.IS3_TEST_COMP_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__Pos           29                                                                     /*!< Right-most bit position of is3_test_comp_err in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__Pos)        /*!< Mask for is3_test_comp_err in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__Shift(v)      (((v) << TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__Pos) & TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__Msk) /*!< Shift value 'v' into is3_test_comp_err and mask 'v' to fit it into is3_test_comp_err field */

/** TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__GET() gets BIST_IS_COMP.IS3_TEST_COMP_ERR's current value.
 *
 * When reading from BIST_IS_COMP.IS3_TEST_COMP_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_COMP.IS3_TEST_COMP_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_COMP__GET();
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__EXTRACT() extracts BIST_IS_COMP.IS3_TEST_COMP_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_COMP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_COMP
 * @return current value of BIST_IS_COMP.IS3_TEST_COMP_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------ TESTSTAT.BIST_IS_COMP.IS3_TEST_COMP ------------------ */

/**
<pre>
  TESTSTAT.BIST_IS_COMP.IS3_TEST_COMP:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__Pos               20                                                                     /*!< Right-most bit position of is3_test_comp in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__Msk               (0x000001FFUL << TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__Pos)            /*!< Mask for is3_test_comp in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__Shift(v)          (((v) << TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__Pos) & TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__Msk) /*!< Shift value 'v' into is3_test_comp and mask 'v' to fit it into is3_test_comp field */

/** TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__GET() gets BIST_IS_COMP.IS3_TEST_COMP's current value.
 *
 * When reading from BIST_IS_COMP.IS3_TEST_COMP, this is recommended to use.
 *
 * @return current value of BIST_IS_COMP.IS3_TEST_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_COMP__GET();
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__EXTRACT() extracts BIST_IS_COMP.IS3_TEST_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_COMP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_COMP
 * @return current value of BIST_IS_COMP.IS3_TEST_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS3_TEST_COMP__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_COMP.IS2_TEST_COMP_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_COMP.IS2_TEST_COMP_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__Pos           19                                                                     /*!< Right-most bit position of is2_test_comp_err in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__Pos)        /*!< Mask for is2_test_comp_err in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__Shift(v)      (((v) << TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__Pos) & TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__Msk) /*!< Shift value 'v' into is2_test_comp_err and mask 'v' to fit it into is2_test_comp_err field */

/** TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__GET() gets BIST_IS_COMP.IS2_TEST_COMP_ERR's current value.
 *
 * When reading from BIST_IS_COMP.IS2_TEST_COMP_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_COMP.IS2_TEST_COMP_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_COMP__GET();
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__EXTRACT() extracts BIST_IS_COMP.IS2_TEST_COMP_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_COMP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_COMP
 * @return current value of BIST_IS_COMP.IS2_TEST_COMP_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------ TESTSTAT.BIST_IS_COMP.IS2_TEST_COMP ------------------ */

/**
<pre>
  TESTSTAT.BIST_IS_COMP.IS2_TEST_COMP:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__Pos               10                                                                     /*!< Right-most bit position of is2_test_comp in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__Msk               (0x000001FFUL << TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__Pos)            /*!< Mask for is2_test_comp in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__Shift(v)          (((v) << TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__Pos) & TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__Msk) /*!< Shift value 'v' into is2_test_comp and mask 'v' to fit it into is2_test_comp field */

/** TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__GET() gets BIST_IS_COMP.IS2_TEST_COMP's current value.
 *
 * When reading from BIST_IS_COMP.IS2_TEST_COMP, this is recommended to use.
 *
 * @return current value of BIST_IS_COMP.IS2_TEST_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_COMP__GET();
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__EXTRACT() extracts BIST_IS_COMP.IS2_TEST_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_COMP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_COMP
 * @return current value of BIST_IS_COMP.IS2_TEST_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS2_TEST_COMP__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_COMP.IS1_TEST_COMP_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_COMP.IS1_TEST_COMP_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__Pos           9                                                                      /*!< Right-most bit position of is1_test_comp_err in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__Pos)        /*!< Mask for is1_test_comp_err in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__Shift(v)      (((v) << TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__Pos) & TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__Msk) /*!< Shift value 'v' into is1_test_comp_err and mask 'v' to fit it into is1_test_comp_err field */

/** TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__GET() gets BIST_IS_COMP.IS1_TEST_COMP_ERR's current value.
 *
 * When reading from BIST_IS_COMP.IS1_TEST_COMP_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_COMP.IS1_TEST_COMP_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_COMP__GET();
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__EXTRACT() extracts BIST_IS_COMP.IS1_TEST_COMP_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_COMP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_COMP
 * @return current value of BIST_IS_COMP.IS1_TEST_COMP_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------ TESTSTAT.BIST_IS_COMP.IS1_TEST_COMP ------------------ */

/**
<pre>
  TESTSTAT.BIST_IS_COMP.IS1_TEST_COMP:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__Pos               0                                                                      /*!< Right-most bit position of is1_test_comp in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__Msk               (0x000001FFUL << TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__Pos)            /*!< Mask for is1_test_comp in TESTSTAT.BIST_IS_COMP */
#define TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__Shift(v)          (((v) << TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__Pos) & TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__Msk) /*!< Shift value 'v' into is1_test_comp and mask 'v' to fit it into is1_test_comp field */

/** TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__GET() gets BIST_IS_COMP.IS1_TEST_COMP's current value.
 *
 * When reading from BIST_IS_COMP.IS1_TEST_COMP, this is recommended to use.
 *
 * @return current value of BIST_IS_COMP.IS1_TEST_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_COMP__GET();
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__EXTRACT() extracts BIST_IS_COMP.IS1_TEST_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_COMP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_COMP
 * @return current value of BIST_IS_COMP.IS1_TEST_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_COMP__IS1_TEST_COMP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      BIST_IS_DNL member of TESTSTAT_t                      */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_IS_DNL__ADDRESS returns the address of member BIST_IS_DNL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_IS_DNL
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_IS_DNL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_IS_DNL)));
}

/** TESTSTAT_BIST_IS_DNL__GET() gets BIST_IS_DNL's current value.
 *
 * When reading from BIST_IS_DNL, this is mandatory to use.
 *
 * @return current value of BIST_IS_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_IS_DNL__ADDRESS());
}

/* --------------- TESTSTAT.BIST_IS_DNL.IS_TEST_DNL_COMPLETE --------------- */

/**
<pre>
  TESTSTAT.BIST_IS_DNL.IS_TEST_DNL_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__Pos         27                                                                     /*!< Right-most bit position of is_test_dnl_complete in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__Msk         (0x00000001UL << TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__Pos)      /*!< Mask for is_test_dnl_complete in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__Shift(v)    (((v) << TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__Pos) & TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__Msk) /*!< Shift value 'v' into is_test_dnl_complete and mask 'v' to fit it into is_test_dnl_complete field */

/** TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__GET() gets BIST_IS_DNL.IS_TEST_DNL_COMPLETE's current value.
 *
 * When reading from BIST_IS_DNL.IS_TEST_DNL_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_IS_DNL.IS_TEST_DNL_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__EXTRACT() extracts BIST_IS_DNL.IS_TEST_DNL_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_DNL
 * @return current value of BIST_IS_DNL.IS_TEST_DNL_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS_TEST_DNL_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_IS_DNL.IS3_TEST_DNL_ERR ----------------- */

/**
<pre>
  TESTSTAT.BIST_IS_DNL.IS3_TEST_DNL_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__Pos             26                                                                     /*!< Right-most bit position of is3_test_dnl_err in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__Msk             (0x00000001UL << TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__Pos)          /*!< Mask for is3_test_dnl_err in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__Shift(v)        (((v) << TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__Pos) & TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__Msk) /*!< Shift value 'v' into is3_test_dnl_err and mask 'v' to fit it into is3_test_dnl_err field */

/** TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__GET() gets BIST_IS_DNL.IS3_TEST_DNL_ERR's current value.
 *
 * When reading from BIST_IS_DNL.IS3_TEST_DNL_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_DNL.IS3_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__EXTRACT() extracts BIST_IS_DNL.IS3_TEST_DNL_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_DNL
 * @return current value of BIST_IS_DNL.IS3_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_IS_DNL.IS3_TEST_DNL ------------------- */

/**
<pre>
  TESTSTAT.BIST_IS_DNL.IS3_TEST_DNL:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__Pos                 18                                                                     /*!< Right-most bit position of is3_test_dnl in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__Msk                 (0x000000FFUL << TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__Pos)              /*!< Mask for is3_test_dnl in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__Shift(v)            (((v) << TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__Pos) & TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__Msk) /*!< Shift value 'v' into is3_test_dnl and mask 'v' to fit it into is3_test_dnl field */

/** TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__GET() gets BIST_IS_DNL.IS3_TEST_DNL's current value.
 *
 * When reading from BIST_IS_DNL.IS3_TEST_DNL, this is recommended to use.
 *
 * @return current value of BIST_IS_DNL.IS3_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__EXTRACT() extracts BIST_IS_DNL.IS3_TEST_DNL.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_DNL
 * @return current value of BIST_IS_DNL.IS3_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS3_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_IS_DNL.IS2_TEST_DNL_ERR ----------------- */

/**
<pre>
  TESTSTAT.BIST_IS_DNL.IS2_TEST_DNL_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__Pos             17                                                                     /*!< Right-most bit position of is2_test_dnl_err in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__Msk             (0x00000001UL << TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__Pos)          /*!< Mask for is2_test_dnl_err in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__Shift(v)        (((v) << TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__Pos) & TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__Msk) /*!< Shift value 'v' into is2_test_dnl_err and mask 'v' to fit it into is2_test_dnl_err field */

/** TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__GET() gets BIST_IS_DNL.IS2_TEST_DNL_ERR's current value.
 *
 * When reading from BIST_IS_DNL.IS2_TEST_DNL_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_DNL.IS2_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__EXTRACT() extracts BIST_IS_DNL.IS2_TEST_DNL_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_DNL
 * @return current value of BIST_IS_DNL.IS2_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_IS_DNL.IS2_TEST_DNL ------------------- */

/**
<pre>
  TESTSTAT.BIST_IS_DNL.IS2_TEST_DNL:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__Pos                 9                                                                      /*!< Right-most bit position of is2_test_dnl in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__Msk                 (0x000000FFUL << TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__Pos)              /*!< Mask for is2_test_dnl in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__Shift(v)            (((v) << TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__Pos) & TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__Msk) /*!< Shift value 'v' into is2_test_dnl and mask 'v' to fit it into is2_test_dnl field */

/** TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__GET() gets BIST_IS_DNL.IS2_TEST_DNL's current value.
 *
 * When reading from BIST_IS_DNL.IS2_TEST_DNL, this is recommended to use.
 *
 * @return current value of BIST_IS_DNL.IS2_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__EXTRACT() extracts BIST_IS_DNL.IS2_TEST_DNL.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_DNL
 * @return current value of BIST_IS_DNL.IS2_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS2_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_IS_DNL.IS1_TEST_DNL_ERR ----------------- */

/**
<pre>
  TESTSTAT.BIST_IS_DNL.IS1_TEST_DNL_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__Pos             8                                                                      /*!< Right-most bit position of is1_test_dnl_err in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__Msk             (0x00000001UL << TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__Pos)          /*!< Mask for is1_test_dnl_err in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__Shift(v)        (((v) << TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__Pos) & TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__Msk) /*!< Shift value 'v' into is1_test_dnl_err and mask 'v' to fit it into is1_test_dnl_err field */

/** TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__GET() gets BIST_IS_DNL.IS1_TEST_DNL_ERR's current value.
 *
 * When reading from BIST_IS_DNL.IS1_TEST_DNL_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_DNL.IS1_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__EXTRACT() extracts BIST_IS_DNL.IS1_TEST_DNL_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_DNL
 * @return current value of BIST_IS_DNL.IS1_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_IS_DNL.IS1_TEST_DNL ------------------- */

/**
<pre>
  TESTSTAT.BIST_IS_DNL.IS1_TEST_DNL:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__Pos                 0                                                                      /*!< Right-most bit position of is1_test_dnl in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__Msk                 (0x000000FFUL << TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__Pos)              /*!< Mask for is1_test_dnl in TESTSTAT.BIST_IS_DNL */
#define TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__Shift(v)            (((v) << TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__Pos) & TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__Msk) /*!< Shift value 'v' into is1_test_dnl and mask 'v' to fit it into is1_test_dnl field */

/** TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__GET() gets BIST_IS_DNL.IS1_TEST_DNL's current value.
 *
 * When reading from BIST_IS_DNL.IS1_TEST_DNL, this is recommended to use.
 *
 * @return current value of BIST_IS_DNL.IS1_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__EXTRACT() extracts BIST_IS_DNL.IS1_TEST_DNL.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_DNL
 * @return current value of BIST_IS_DNL.IS1_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_DNL__IS1_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_IS_GAIN member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_IS_GAIN__ADDRESS returns the address of member BIST_IS_GAIN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_IS_GAIN
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_IS_GAIN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_IS_GAIN)));
}

/** TESTSTAT_BIST_IS_GAIN__GET() gets BIST_IS_GAIN's current value.
 *
 * When reading from BIST_IS_GAIN, this is mandatory to use.
 *
 * @return current value of BIST_IS_GAIN
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_IS_GAIN__ADDRESS());
}

/* -------------- TESTSTAT.BIST_IS_GAIN.IS_TEST_GAIN_COMPLETE -------------- */

/**
<pre>
  TESTSTAT.BIST_IS_GAIN.IS_TEST_GAIN_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__Pos       27                                                                     /*!< Right-most bit position of is_test_gain_complete in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__Msk       (0x00000001UL << TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__Pos)    /*!< Mask for is_test_gain_complete in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__Shift(v)  (((v) << TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__Pos) & TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__Msk) /*!< Shift value 'v' into is_test_gain_complete and mask 'v' to fit it into is_test_gain_complete field */

/** TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__GET() gets BIST_IS_GAIN.IS_TEST_GAIN_COMPLETE's current value.
 *
 * When reading from BIST_IS_GAIN.IS_TEST_GAIN_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_IS_GAIN.IS_TEST_GAIN_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__EXTRACT() extracts BIST_IS_GAIN.IS_TEST_GAIN_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_GAIN
 * @return current value of BIST_IS_GAIN.IS_TEST_GAIN_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS_TEST_GAIN_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_GAIN.IS3_TEST_GAIN_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_GAIN.IS3_TEST_GAIN_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__Pos           26                                                                     /*!< Right-most bit position of is3_test_gain_err in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__Pos)        /*!< Mask for is3_test_gain_err in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__Shift(v)      (((v) << TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__Pos) & TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__Msk) /*!< Shift value 'v' into is3_test_gain_err and mask 'v' to fit it into is3_test_gain_err field */

/** TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__GET() gets BIST_IS_GAIN.IS3_TEST_GAIN_ERR's current value.
 *
 * When reading from BIST_IS_GAIN.IS3_TEST_GAIN_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_GAIN.IS3_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__EXTRACT() extracts BIST_IS_GAIN.IS3_TEST_GAIN_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_GAIN
 * @return current value of BIST_IS_GAIN.IS3_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_GAIN.IS3_TEST_GAIN_COMP ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_GAIN.IS3_TEST_GAIN_COMP:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__Pos          18                                                                     /*!< Right-most bit position of is3_test_gain_comp in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__Msk          (0x000000FFUL << TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__Pos)       /*!< Mask for is3_test_gain_comp in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__Shift(v)     (((v) << TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__Pos) & TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__Msk) /*!< Shift value 'v' into is3_test_gain_comp and mask 'v' to fit it into is3_test_gain_comp field */

/** TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__GET() gets BIST_IS_GAIN.IS3_TEST_GAIN_COMP's current value.
 *
 * When reading from BIST_IS_GAIN.IS3_TEST_GAIN_COMP, this is recommended to use.
 *
 * @return current value of BIST_IS_GAIN.IS3_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__EXTRACT() extracts BIST_IS_GAIN.IS3_TEST_GAIN_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_GAIN
 * @return current value of BIST_IS_GAIN.IS3_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS3_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_GAIN.IS2_TEST_GAIN_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_GAIN.IS2_TEST_GAIN_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__Pos           17                                                                     /*!< Right-most bit position of is2_test_gain_err in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__Pos)        /*!< Mask for is2_test_gain_err in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__Shift(v)      (((v) << TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__Pos) & TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__Msk) /*!< Shift value 'v' into is2_test_gain_err and mask 'v' to fit it into is2_test_gain_err field */

/** TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__GET() gets BIST_IS_GAIN.IS2_TEST_GAIN_ERR's current value.
 *
 * When reading from BIST_IS_GAIN.IS2_TEST_GAIN_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_GAIN.IS2_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__EXTRACT() extracts BIST_IS_GAIN.IS2_TEST_GAIN_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_GAIN
 * @return current value of BIST_IS_GAIN.IS2_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_GAIN.IS2_TEST_GAIN_COMP ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_GAIN.IS2_TEST_GAIN_COMP:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__Pos          9                                                                      /*!< Right-most bit position of is2_test_gain_comp in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__Msk          (0x000000FFUL << TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__Pos)       /*!< Mask for is2_test_gain_comp in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__Shift(v)     (((v) << TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__Pos) & TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__Msk) /*!< Shift value 'v' into is2_test_gain_comp and mask 'v' to fit it into is2_test_gain_comp field */

/** TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__GET() gets BIST_IS_GAIN.IS2_TEST_GAIN_COMP's current value.
 *
 * When reading from BIST_IS_GAIN.IS2_TEST_GAIN_COMP, this is recommended to use.
 *
 * @return current value of BIST_IS_GAIN.IS2_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__EXTRACT() extracts BIST_IS_GAIN.IS2_TEST_GAIN_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_GAIN
 * @return current value of BIST_IS_GAIN.IS2_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS2_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_GAIN.IS1_TEST_GAIN_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_GAIN.IS1_TEST_GAIN_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__Pos           8                                                                      /*!< Right-most bit position of is1_test_gain_err in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__Pos)        /*!< Mask for is1_test_gain_err in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__Shift(v)      (((v) << TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__Pos) & TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__Msk) /*!< Shift value 'v' into is1_test_gain_err and mask 'v' to fit it into is1_test_gain_err field */

/** TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__GET() gets BIST_IS_GAIN.IS1_TEST_GAIN_ERR's current value.
 *
 * When reading from BIST_IS_GAIN.IS1_TEST_GAIN_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_GAIN.IS1_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__EXTRACT() extracts BIST_IS_GAIN.IS1_TEST_GAIN_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_GAIN
 * @return current value of BIST_IS_GAIN.IS1_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_GAIN.IS1_TEST_GAIN_COMP ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_GAIN.IS1_TEST_GAIN_COMP:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__Pos          0                                                                      /*!< Right-most bit position of is1_test_gain_comp in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__Msk          (0x000000FFUL << TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__Pos)       /*!< Mask for is1_test_gain_comp in TESTSTAT.BIST_IS_GAIN */
#define TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__Shift(v)     (((v) << TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__Pos) & TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__Msk) /*!< Shift value 'v' into is1_test_gain_comp and mask 'v' to fit it into is1_test_gain_comp field */

/** TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__GET() gets BIST_IS_GAIN.IS1_TEST_GAIN_COMP's current value.
 *
 * When reading from BIST_IS_GAIN.IS1_TEST_GAIN_COMP, this is recommended to use.
 *
 * @return current value of BIST_IS_GAIN.IS1_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__EXTRACT() extracts BIST_IS_GAIN.IS1_TEST_GAIN_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_GAIN
 * @return current value of BIST_IS_GAIN.IS1_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_GAIN__IS1_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_IS_OFF1 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_IS_OFF1__ADDRESS returns the address of member BIST_IS_OFF1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_IS_OFF1
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_IS_OFF1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_IS_OFF1)));
}

/** TESTSTAT_BIST_IS_OFF1__GET() gets BIST_IS_OFF1's current value.
 *
 * When reading from BIST_IS_OFF1, this is mandatory to use.
 *
 * @return current value of BIST_IS_OFF1
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_IS_OFF1__ADDRESS());
}

/* -------------- TESTSTAT.BIST_IS_OFF1.IS_TEST_OFFS_COMPLETE -------------- */

/**
<pre>
  TESTSTAT.BIST_IS_OFF1.IS_TEST_OFFS_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__Pos       22                                                                     /*!< Right-most bit position of is_test_offs_complete in TESTSTAT.BIST_IS_OFF1 */
#define TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__Msk       (0x00000001UL << TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__Pos)    /*!< Mask for is_test_offs_complete in TESTSTAT.BIST_IS_OFF1 */
#define TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__Shift(v)  (((v) << TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__Pos) & TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__Msk) /*!< Shift value 'v' into is_test_offs_complete and mask 'v' to fit it into is_test_offs_complete field */

/** TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__GET() gets BIST_IS_OFF1.IS_TEST_OFFS_COMPLETE's current value.
 *
 * When reading from BIST_IS_OFF1.IS_TEST_OFFS_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_IS_OFF1.IS_TEST_OFFS_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_OFF1__GET();
    reg = (reg & TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__EXTRACT() extracts BIST_IS_OFF1.IS_TEST_OFFS_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_OFF1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_OFF1
 * @return current value of BIST_IS_OFF1.IS_TEST_OFFS_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF1__IS_TEST_OFFS_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_OFF1.IS2_TEST_OFFS_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_OFF1.IS2_TEST_OFFS_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__Pos           21                                                                     /*!< Right-most bit position of is2_test_offs_err in TESTSTAT.BIST_IS_OFF1 */
#define TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__Pos)        /*!< Mask for is2_test_offs_err in TESTSTAT.BIST_IS_OFF1 */
#define TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__Shift(v)      (((v) << TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__Pos) & TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__Msk) /*!< Shift value 'v' into is2_test_offs_err and mask 'v' to fit it into is2_test_offs_err field */

/** TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__GET() gets BIST_IS_OFF1.IS2_TEST_OFFS_ERR's current value.
 *
 * When reading from BIST_IS_OFF1.IS2_TEST_OFFS_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_OFF1.IS2_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_OFF1__GET();
    reg = (reg & TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__EXTRACT() extracts BIST_IS_OFF1.IS2_TEST_OFFS_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_OFF1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_OFF1
 * @return current value of BIST_IS_OFF1.IS2_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------ TESTSTAT.BIST_IS_OFF1.IS2_TEST_OFFS ------------------ */

/**
<pre>
  TESTSTAT.BIST_IS_OFF1.IS2_TEST_OFFS:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__Pos               11                                                                     /*!< Right-most bit position of is2_test_offs in TESTSTAT.BIST_IS_OFF1 */
#define TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__Msk               (0x000003FFUL << TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__Pos)            /*!< Mask for is2_test_offs in TESTSTAT.BIST_IS_OFF1 */
#define TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__Shift(v)          (((v) << TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__Pos) & TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__Msk) /*!< Shift value 'v' into is2_test_offs and mask 'v' to fit it into is2_test_offs field */

/** TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__GET() gets BIST_IS_OFF1.IS2_TEST_OFFS's current value.
 *
 * When reading from BIST_IS_OFF1.IS2_TEST_OFFS, this is recommended to use.
 *
 * @return current value of BIST_IS_OFF1.IS2_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_OFF1__GET();
    reg = (reg & TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__EXTRACT() extracts BIST_IS_OFF1.IS2_TEST_OFFS.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_OFF1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_OFF1
 * @return current value of BIST_IS_OFF1.IS2_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF1__IS2_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_IS_OFF1.IS1_TEST_OFFS_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_OFF1.IS1_TEST_OFFS_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__Pos           10                                                                     /*!< Right-most bit position of is1_test_offs_err in TESTSTAT.BIST_IS_OFF1 */
#define TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__Pos)        /*!< Mask for is1_test_offs_err in TESTSTAT.BIST_IS_OFF1 */
#define TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__Shift(v)      (((v) << TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__Pos) & TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__Msk) /*!< Shift value 'v' into is1_test_offs_err and mask 'v' to fit it into is1_test_offs_err field */

/** TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__GET() gets BIST_IS_OFF1.IS1_TEST_OFFS_ERR's current value.
 *
 * When reading from BIST_IS_OFF1.IS1_TEST_OFFS_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_OFF1.IS1_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_OFF1__GET();
    reg = (reg & TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__EXTRACT() extracts BIST_IS_OFF1.IS1_TEST_OFFS_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_OFF1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_OFF1
 * @return current value of BIST_IS_OFF1.IS1_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------ TESTSTAT.BIST_IS_OFF1.IS1_TEST_OFFS ------------------ */

/**
<pre>
  TESTSTAT.BIST_IS_OFF1.IS1_TEST_OFFS:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__Pos               0                                                                      /*!< Right-most bit position of is1_test_offs in TESTSTAT.BIST_IS_OFF1 */
#define TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__Msk               (0x000003FFUL << TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__Pos)            /*!< Mask for is1_test_offs in TESTSTAT.BIST_IS_OFF1 */
#define TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__Shift(v)          (((v) << TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__Pos) & TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__Msk) /*!< Shift value 'v' into is1_test_offs and mask 'v' to fit it into is1_test_offs field */

/** TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__GET() gets BIST_IS_OFF1.IS1_TEST_OFFS's current value.
 *
 * When reading from BIST_IS_OFF1.IS1_TEST_OFFS, this is recommended to use.
 *
 * @return current value of BIST_IS_OFF1.IS1_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_OFF1__GET();
    reg = (reg & TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__EXTRACT() extracts BIST_IS_OFF1.IS1_TEST_OFFS.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_OFF1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_OFF1
 * @return current value of BIST_IS_OFF1.IS1_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF1__IS1_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_IS_OFF2 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_IS_OFF2__ADDRESS returns the address of member BIST_IS_OFF2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_IS_OFF2
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_IS_OFF2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_IS_OFF2)));
}

/** TESTSTAT_BIST_IS_OFF2__GET() gets BIST_IS_OFF2's current value.
 *
 * When reading from BIST_IS_OFF2, this is mandatory to use.
 *
 * @return current value of BIST_IS_OFF2
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF2__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_IS_OFF2__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_IS_OFF2.IS3_TEST_OFFS_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_IS_OFF2.IS3_TEST_OFFS_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__Pos           10                                                                     /*!< Right-most bit position of is3_test_offs_err in TESTSTAT.BIST_IS_OFF2 */
#define TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__Pos)        /*!< Mask for is3_test_offs_err in TESTSTAT.BIST_IS_OFF2 */
#define TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__Shift(v)      (((v) << TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__Pos) & TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__Msk) /*!< Shift value 'v' into is3_test_offs_err and mask 'v' to fit it into is3_test_offs_err field */

/** TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__GET() gets BIST_IS_OFF2.IS3_TEST_OFFS_ERR's current value.
 *
 * When reading from BIST_IS_OFF2.IS3_TEST_OFFS_ERR, this is recommended to use.
 *
 * @return current value of BIST_IS_OFF2.IS3_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_OFF2__GET();
    reg = (reg & TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__EXTRACT() extracts BIST_IS_OFF2.IS3_TEST_OFFS_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_OFF2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_OFF2
 * @return current value of BIST_IS_OFF2.IS3_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------ TESTSTAT.BIST_IS_OFF2.IS3_TEST_OFFS ------------------ */

/**
<pre>
  TESTSTAT.BIST_IS_OFF2.IS3_TEST_OFFS:

    TBD

</pre> */

#define TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__Pos               0                                                                      /*!< Right-most bit position of is3_test_offs in TESTSTAT.BIST_IS_OFF2 */
#define TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__Msk               (0x000003FFUL << TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__Pos)            /*!< Mask for is3_test_offs in TESTSTAT.BIST_IS_OFF2 */
#define TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__Shift(v)          (((v) << TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__Pos) & TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__Msk) /*!< Shift value 'v' into is3_test_offs and mask 'v' to fit it into is3_test_offs field */

/** TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__GET() gets BIST_IS_OFF2.IS3_TEST_OFFS's current value.
 *
 * When reading from BIST_IS_OFF2.IS3_TEST_OFFS, this is recommended to use.
 *
 * @return current value of BIST_IS_OFF2.IS3_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_IS_OFF2__GET();
    reg = (reg & TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__EXTRACT() extracts BIST_IS_OFF2.IS3_TEST_OFFS.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_IS_OFF2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_IS_OFF2
 * @return current value of BIST_IS_OFF2.IS3_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_IS_OFF2__IS3_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      BIST_TSADC member of TESTSTAT_t                      */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_TSADC__ADDRESS returns the address of member BIST_TSADC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_TSADC
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_TSADC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_TSADC)));
}

/** TESTSTAT_BIST_TSADC__GET() gets BIST_TSADC's current value.
 *
 * When reading from BIST_TSADC, this is mandatory to use.
 *
 * @return current value of BIST_TSADC
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_TSADC__ADDRESS());
}

/* ------------ TESTSTAT.BIST_TSADC.TS_TEST_TSADC_OFFS_COMPLETE ------------ */

/**
<pre>
  TESTSTAT.BIST_TSADC.TS_TEST_TSADC_OFFS_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__Pos   29                                                                     /*!< Right-most bit position of ts_test_tsadc_offs_complete in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__Msk   (0x00000001UL << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__Pos) /*!< Mask for ts_test_tsadc_offs_complete in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__Shift(v) (((v) << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__Pos) & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__Msk) /*!< Shift value 'v' into ts_test_tsadc_offs_complete and mask 'v' to fit it into ts_test_tsadc_offs_complete field */

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__GET() gets BIST_TSADC.TS_TEST_TSADC_OFFS_COMPLETE's current value.
 *
 * When reading from BIST_TSADC.TS_TEST_TSADC_OFFS_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_TSADC.TS_TEST_TSADC_OFFS_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSADC__GET();
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__EXTRACT() extracts BIST_TSADC.TS_TEST_TSADC_OFFS_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSADC
 * @return current value of BIST_TSADC.TS_TEST_TSADC_OFFS_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* --------------- TESTSTAT.BIST_TSADC.TS_TEST_TSADC_OFFS_ERR --------------- */

/**
<pre>
  TESTSTAT.BIST_TSADC.TS_TEST_TSADC_OFFS_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__Pos        28                                                                     /*!< Right-most bit position of ts_test_tsadc_offs_err in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__Msk        (0x00000001UL << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__Pos)     /*!< Mask for ts_test_tsadc_offs_err in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__Shift(v)   (((v) << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__Pos) & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__Msk) /*!< Shift value 'v' into ts_test_tsadc_offs_err and mask 'v' to fit it into ts_test_tsadc_offs_err field */

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__GET() gets BIST_TSADC.TS_TEST_TSADC_OFFS_ERR's current value.
 *
 * When reading from BIST_TSADC.TS_TEST_TSADC_OFFS_ERR, this is recommended to use.
 *
 * @return current value of BIST_TSADC.TS_TEST_TSADC_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSADC__GET();
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__EXTRACT() extracts BIST_TSADC.TS_TEST_TSADC_OFFS_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSADC
 * @return current value of BIST_TSADC.TS_TEST_TSADC_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_TSADC.TS_TEST_TSADC_OFFS ----------------- */

/**
<pre>
  TESTSTAT.BIST_TSADC.TS_TEST_TSADC_OFFS:

    TBD

</pre> */

#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__Pos            20                                                                     /*!< Right-most bit position of ts_test_tsadc_offs in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__Msk            (0x000000FFUL << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__Pos)         /*!< Mask for ts_test_tsadc_offs in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__Shift(v)       (((v) << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__Pos) & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__Msk) /*!< Shift value 'v' into ts_test_tsadc_offs and mask 'v' to fit it into ts_test_tsadc_offs field */

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__GET() gets BIST_TSADC.TS_TEST_TSADC_OFFS's current value.
 *
 * When reading from BIST_TSADC.TS_TEST_TSADC_OFFS, this is recommended to use.
 *
 * @return current value of BIST_TSADC.TS_TEST_TSADC_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSADC__GET();
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__EXTRACT() extracts BIST_TSADC.TS_TEST_TSADC_OFFS.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSADC
 * @return current value of BIST_TSADC.TS_TEST_TSADC_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_OFFS__Pos);
    return (uint32_t)reg;
}

/* ------------ TESTSTAT.BIST_TSADC.TS_TEST_TSADC_GAIN_COMPLETE ------------ */

/**
<pre>
  TESTSTAT.BIST_TSADC.TS_TEST_TSADC_GAIN_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__Pos   19                                                                     /*!< Right-most bit position of ts_test_tsadc_gain_complete in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__Msk   (0x00000001UL << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__Pos) /*!< Mask for ts_test_tsadc_gain_complete in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__Shift(v) (((v) << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__Pos) & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__Msk) /*!< Shift value 'v' into ts_test_tsadc_gain_complete and mask 'v' to fit it into ts_test_tsadc_gain_complete field */

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__GET() gets BIST_TSADC.TS_TEST_TSADC_GAIN_COMPLETE's current value.
 *
 * When reading from BIST_TSADC.TS_TEST_TSADC_GAIN_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_TSADC.TS_TEST_TSADC_GAIN_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSADC__GET();
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__EXTRACT() extracts BIST_TSADC.TS_TEST_TSADC_GAIN_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSADC
 * @return current value of BIST_TSADC.TS_TEST_TSADC_GAIN_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* --------------- TESTSTAT.BIST_TSADC.TS_TEST_TSADC_GAIN_ERR --------------- */

/**
<pre>
  TESTSTAT.BIST_TSADC.TS_TEST_TSADC_GAIN_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__Pos        18                                                                     /*!< Right-most bit position of ts_test_tsadc_gain_err in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__Msk        (0x00000001UL << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__Pos)     /*!< Mask for ts_test_tsadc_gain_err in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__Shift(v)   (((v) << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__Pos) & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__Msk) /*!< Shift value 'v' into ts_test_tsadc_gain_err and mask 'v' to fit it into ts_test_tsadc_gain_err field */

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__GET() gets BIST_TSADC.TS_TEST_TSADC_GAIN_ERR's current value.
 *
 * When reading from BIST_TSADC.TS_TEST_TSADC_GAIN_ERR, this is recommended to use.
 *
 * @return current value of BIST_TSADC.TS_TEST_TSADC_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSADC__GET();
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__EXTRACT() extracts BIST_TSADC.TS_TEST_TSADC_GAIN_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSADC
 * @return current value of BIST_TSADC.TS_TEST_TSADC_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/* -------------- TESTSTAT.BIST_TSADC.TS_TEST_TSADC_GAIN_COMP -------------- */

/**
<pre>
  TESTSTAT.BIST_TSADC.TS_TEST_TSADC_GAIN_COMP:

    TBD

</pre> */

#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__Pos       10                                                                     /*!< Right-most bit position of ts_test_tsadc_gain_comp in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__Msk       (0x000000FFUL << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__Pos)    /*!< Mask for ts_test_tsadc_gain_comp in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__Shift(v)  (((v) << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__Pos) & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__Msk) /*!< Shift value 'v' into ts_test_tsadc_gain_comp and mask 'v' to fit it into ts_test_tsadc_gain_comp field */

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__GET() gets BIST_TSADC.TS_TEST_TSADC_GAIN_COMP's current value.
 *
 * When reading from BIST_TSADC.TS_TEST_TSADC_GAIN_COMP, this is recommended to use.
 *
 * @return current value of BIST_TSADC.TS_TEST_TSADC_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSADC__GET();
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__EXTRACT() extracts BIST_TSADC.TS_TEST_TSADC_GAIN_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSADC
 * @return current value of BIST_TSADC.TS_TEST_TSADC_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/* ------------- TESTSTAT.BIST_TSADC.TS_TEST_TSADC_DNL_COMPLETE ------------- */

/**
<pre>
  TESTSTAT.BIST_TSADC.TS_TEST_TSADC_DNL_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__Pos    9                                                                      /*!< Right-most bit position of ts_test_tsadc_dnl_complete in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__Msk    (0x00000001UL << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__Pos) /*!< Mask for ts_test_tsadc_dnl_complete in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__Shift(v) (((v) << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__Pos) & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__Msk) /*!< Shift value 'v' into ts_test_tsadc_dnl_complete and mask 'v' to fit it into ts_test_tsadc_dnl_complete field */

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__GET() gets BIST_TSADC.TS_TEST_TSADC_DNL_COMPLETE's current value.
 *
 * When reading from BIST_TSADC.TS_TEST_TSADC_DNL_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_TSADC.TS_TEST_TSADC_DNL_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSADC__GET();
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__EXTRACT() extracts BIST_TSADC.TS_TEST_TSADC_DNL_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSADC
 * @return current value of BIST_TSADC.TS_TEST_TSADC_DNL_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* --------------- TESTSTAT.BIST_TSADC.TS_TEST_TSADC_DNL_ERR --------------- */

/**
<pre>
  TESTSTAT.BIST_TSADC.TS_TEST_TSADC_DNL_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__Pos         8                                                                      /*!< Right-most bit position of ts_test_tsadc_dnl_err in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__Msk         (0x00000001UL << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__Pos)      /*!< Mask for ts_test_tsadc_dnl_err in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__Shift(v)    (((v) << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__Pos) & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__Msk) /*!< Shift value 'v' into ts_test_tsadc_dnl_err and mask 'v' to fit it into ts_test_tsadc_dnl_err field */

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__GET() gets BIST_TSADC.TS_TEST_TSADC_DNL_ERR's current value.
 *
 * When reading from BIST_TSADC.TS_TEST_TSADC_DNL_ERR, this is recommended to use.
 *
 * @return current value of BIST_TSADC.TS_TEST_TSADC_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSADC__GET();
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__EXTRACT() extracts BIST_TSADC.TS_TEST_TSADC_DNL_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSADC
 * @return current value of BIST_TSADC.TS_TEST_TSADC_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_TSADC.TS_TEST_TSADC_DNL ----------------- */

/**
<pre>
  TESTSTAT.BIST_TSADC.TS_TEST_TSADC_DNL:

    TBD

</pre> */

#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__Pos             0                                                                      /*!< Right-most bit position of ts_test_tsadc_dnl in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__Msk             (0x000000FFUL << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__Pos)          /*!< Mask for ts_test_tsadc_dnl in TESTSTAT.BIST_TSADC */
#define TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__Shift(v)        (((v) << TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__Pos) & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__Msk) /*!< Shift value 'v' into ts_test_tsadc_dnl and mask 'v' to fit it into ts_test_tsadc_dnl field */

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__GET() gets BIST_TSADC.TS_TEST_TSADC_DNL's current value.
 *
 * When reading from BIST_TSADC.TS_TEST_TSADC_DNL, this is recommended to use.
 *
 * @return current value of BIST_TSADC.TS_TEST_TSADC_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSADC__GET();
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__EXTRACT() extracts BIST_TSADC.TS_TEST_TSADC_DNL.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSADC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSADC
 * @return current value of BIST_TSADC.TS_TEST_TSADC_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_TSADC__TS_TEST_TSADC_DNL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      BIST_TSIDAC member of TESTSTAT_t                      */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_TSIDAC__ADDRESS returns the address of member BIST_TSIDAC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_TSIDAC
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_TSIDAC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_TSIDAC)));
}

/** TESTSTAT_BIST_TSIDAC__GET() gets BIST_TSIDAC's current value.
 *
 * When reading from BIST_TSIDAC, this is mandatory to use.
 *
 * @return current value of BIST_TSIDAC
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSIDAC__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_TSIDAC__ADDRESS());
}

/* ------------ TESTSTAT.BIST_TSIDAC.TS_TEST_TSIDAC_DNL_COMPLETE ------------ */

/**
<pre>
  TESTSTAT.BIST_TSIDAC.TS_TEST_TSIDAC_DNL_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__Pos  9                                                                      /*!< Right-most bit position of ts_test_tsidac_dnl_complete in TESTSTAT.BIST_TSIDAC */
#define TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__Msk  (0x00000001UL << TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__Pos) /*!< Mask for ts_test_tsidac_dnl_complete in TESTSTAT.BIST_TSIDAC */
#define TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__Shift(v) (((v) << TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__Pos) & TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__Msk) /*!< Shift value 'v' into ts_test_tsidac_dnl_complete and mask 'v' to fit it into ts_test_tsidac_dnl_complete field */

/** TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__GET() gets BIST_TSIDAC.TS_TEST_TSIDAC_DNL_COMPLETE's current value.
 *
 * When reading from BIST_TSIDAC.TS_TEST_TSIDAC_DNL_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_TSIDAC.TS_TEST_TSIDAC_DNL_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSIDAC__GET();
    reg = (reg & TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__EXTRACT() extracts BIST_TSIDAC.TS_TEST_TSIDAC_DNL_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSIDAC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSIDAC
 * @return current value of BIST_TSIDAC.TS_TEST_TSIDAC_DNL_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* -------------- TESTSTAT.BIST_TSIDAC.TS_TEST_TSIDAC_DNL_ERR -------------- */

/**
<pre>
  TESTSTAT.BIST_TSIDAC.TS_TEST_TSIDAC_DNL_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__Pos       8                                                                      /*!< Right-most bit position of ts_test_tsidac_dnl_err in TESTSTAT.BIST_TSIDAC */
#define TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__Msk       (0x00000001UL << TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__Pos)    /*!< Mask for ts_test_tsidac_dnl_err in TESTSTAT.BIST_TSIDAC */
#define TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__Shift(v)  (((v) << TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__Pos) & TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__Msk) /*!< Shift value 'v' into ts_test_tsidac_dnl_err and mask 'v' to fit it into ts_test_tsidac_dnl_err field */

/** TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__GET() gets BIST_TSIDAC.TS_TEST_TSIDAC_DNL_ERR's current value.
 *
 * When reading from BIST_TSIDAC.TS_TEST_TSIDAC_DNL_ERR, this is recommended to use.
 *
 * @return current value of BIST_TSIDAC.TS_TEST_TSIDAC_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSIDAC__GET();
    reg = (reg & TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__EXTRACT() extracts BIST_TSIDAC.TS_TEST_TSIDAC_DNL_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSIDAC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSIDAC
 * @return current value of BIST_TSIDAC.TS_TEST_TSIDAC_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_TSIDAC.TS_TEST_TSIDAC_DNL ---------------- */

/**
<pre>
  TESTSTAT.BIST_TSIDAC.TS_TEST_TSIDAC_DNL:

    TBD

</pre> */

#define TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__Pos           0                                                                      /*!< Right-most bit position of ts_test_tsidac_dnl in TESTSTAT.BIST_TSIDAC */
#define TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__Msk           (0x000000FFUL << TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__Pos)        /*!< Mask for ts_test_tsidac_dnl in TESTSTAT.BIST_TSIDAC */
#define TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__Shift(v)      (((v) << TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__Pos) & TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__Msk) /*!< Shift value 'v' into ts_test_tsidac_dnl and mask 'v' to fit it into ts_test_tsidac_dnl field */

/** TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__GET() gets BIST_TSIDAC.TS_TEST_TSIDAC_DNL's current value.
 *
 * When reading from BIST_TSIDAC.TS_TEST_TSIDAC_DNL, this is recommended to use.
 *
 * @return current value of BIST_TSIDAC.TS_TEST_TSIDAC_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_TSIDAC__GET();
    reg = (reg & TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__EXTRACT() extracts BIST_TSIDAC.TS_TEST_TSIDAC_DNL.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_TSIDAC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_TSIDAC
 * @return current value of BIST_TSIDAC.TS_TEST_TSIDAC_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_TSIDAC__TS_TEST_TSIDAC_DNL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      BIST_VS_DNL member of TESTSTAT_t                      */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS_DNL__ADDRESS returns the address of member BIST_VS_DNL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS_DNL
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS_DNL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS_DNL)));
}

/** TESTSTAT_BIST_VS_DNL__GET() gets BIST_VS_DNL's current value.
 *
 * When reading from BIST_VS_DNL, this is mandatory to use.
 *
 * @return current value of BIST_VS_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS_DNL__ADDRESS());
}

/* --------------- TESTSTAT.BIST_VS_DNL.VS_TEST_DNL_COMPLETE --------------- */

/**
<pre>
  TESTSTAT.BIST_VS_DNL.VS_TEST_DNL_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__Pos         27                                                                     /*!< Right-most bit position of vs_test_dnl_complete in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__Msk         (0x00000001UL << TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__Pos)      /*!< Mask for vs_test_dnl_complete in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__Shift(v)    (((v) << TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__Pos) & TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__Msk) /*!< Shift value 'v' into vs_test_dnl_complete and mask 'v' to fit it into vs_test_dnl_complete field */

/** TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__GET() gets BIST_VS_DNL.VS_TEST_DNL_COMPLETE's current value.
 *
 * When reading from BIST_VS_DNL.VS_TEST_DNL_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_VS_DNL.VS_TEST_DNL_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__EXTRACT() extracts BIST_VS_DNL.VS_TEST_DNL_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_DNL
 * @return current value of BIST_VS_DNL.VS_TEST_DNL_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS_TEST_DNL_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_VS_DNL.VS2_TEST_DNL_ERR ----------------- */

/**
<pre>
  TESTSTAT.BIST_VS_DNL.VS2_TEST_DNL_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__Pos             26                                                                     /*!< Right-most bit position of vs2_test_dnl_err in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__Msk             (0x00000001UL << TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__Pos)          /*!< Mask for vs2_test_dnl_err in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__Shift(v)        (((v) << TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__Pos) & TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__Msk) /*!< Shift value 'v' into vs2_test_dnl_err and mask 'v' to fit it into vs2_test_dnl_err field */

/** TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__GET() gets BIST_VS_DNL.VS2_TEST_DNL_ERR's current value.
 *
 * When reading from BIST_VS_DNL.VS2_TEST_DNL_ERR, this is recommended to use.
 *
 * @return current value of BIST_VS_DNL.VS2_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__EXTRACT() extracts BIST_VS_DNL.VS2_TEST_DNL_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_DNL
 * @return current value of BIST_VS_DNL.VS2_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_VS_DNL.VS2_TEST_DNL ------------------- */

/**
<pre>
  TESTSTAT.BIST_VS_DNL.VS2_TEST_DNL:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__Pos                 18                                                                     /*!< Right-most bit position of vs2_test_dnl in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__Msk                 (0x000000FFUL << TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__Pos)              /*!< Mask for vs2_test_dnl in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__Shift(v)            (((v) << TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__Pos) & TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__Msk) /*!< Shift value 'v' into vs2_test_dnl and mask 'v' to fit it into vs2_test_dnl field */

/** TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__GET() gets BIST_VS_DNL.VS2_TEST_DNL's current value.
 *
 * When reading from BIST_VS_DNL.VS2_TEST_DNL, this is recommended to use.
 *
 * @return current value of BIST_VS_DNL.VS2_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__EXTRACT() extracts BIST_VS_DNL.VS2_TEST_DNL.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_DNL
 * @return current value of BIST_VS_DNL.VS2_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS2_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_VS_DNL.VS1_TEST_DNL_ERR ----------------- */

/**
<pre>
  TESTSTAT.BIST_VS_DNL.VS1_TEST_DNL_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__Pos             17                                                                     /*!< Right-most bit position of vs1_test_dnl_err in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__Msk             (0x00000001UL << TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__Pos)          /*!< Mask for vs1_test_dnl_err in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__Shift(v)        (((v) << TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__Pos) & TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__Msk) /*!< Shift value 'v' into vs1_test_dnl_err and mask 'v' to fit it into vs1_test_dnl_err field */

/** TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__GET() gets BIST_VS_DNL.VS1_TEST_DNL_ERR's current value.
 *
 * When reading from BIST_VS_DNL.VS1_TEST_DNL_ERR, this is recommended to use.
 *
 * @return current value of BIST_VS_DNL.VS1_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__EXTRACT() extracts BIST_VS_DNL.VS1_TEST_DNL_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_DNL
 * @return current value of BIST_VS_DNL.VS1_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_VS_DNL.VS1_TEST_DNL ------------------- */

/**
<pre>
  TESTSTAT.BIST_VS_DNL.VS1_TEST_DNL:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__Pos                 9                                                                      /*!< Right-most bit position of vs1_test_dnl in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__Msk                 (0x000000FFUL << TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__Pos)              /*!< Mask for vs1_test_dnl in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__Shift(v)            (((v) << TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__Pos) & TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__Msk) /*!< Shift value 'v' into vs1_test_dnl and mask 'v' to fit it into vs1_test_dnl field */

/** TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__GET() gets BIST_VS_DNL.VS1_TEST_DNL's current value.
 *
 * When reading from BIST_VS_DNL.VS1_TEST_DNL, this is recommended to use.
 *
 * @return current value of BIST_VS_DNL.VS1_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__EXTRACT() extracts BIST_VS_DNL.VS1_TEST_DNL.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_DNL
 * @return current value of BIST_VS_DNL.VS1_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS1_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_VS_DNL.VS0_TEST_DNL_ERR ----------------- */

/**
<pre>
  TESTSTAT.BIST_VS_DNL.VS0_TEST_DNL_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__Pos             8                                                                      /*!< Right-most bit position of vs0_test_dnl_err in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__Msk             (0x00000001UL << TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__Pos)          /*!< Mask for vs0_test_dnl_err in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__Shift(v)        (((v) << TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__Pos) & TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__Msk) /*!< Shift value 'v' into vs0_test_dnl_err and mask 'v' to fit it into vs0_test_dnl_err field */

/** TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__GET() gets BIST_VS_DNL.VS0_TEST_DNL_ERR's current value.
 *
 * When reading from BIST_VS_DNL.VS0_TEST_DNL_ERR, this is recommended to use.
 *
 * @return current value of BIST_VS_DNL.VS0_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__EXTRACT() extracts BIST_VS_DNL.VS0_TEST_DNL_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_DNL
 * @return current value of BIST_VS_DNL.VS0_TEST_DNL_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------- TESTSTAT.BIST_VS_DNL.VS0_TEST_DNL ------------------- */

/**
<pre>
  TESTSTAT.BIST_VS_DNL.VS0_TEST_DNL:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__Pos                 0                                                                      /*!< Right-most bit position of vs0_test_dnl in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__Msk                 (0x000000FFUL << TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__Pos)              /*!< Mask for vs0_test_dnl in TESTSTAT.BIST_VS_DNL */
#define TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__Shift(v)            (((v) << TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__Pos) & TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__Msk) /*!< Shift value 'v' into vs0_test_dnl and mask 'v' to fit it into vs0_test_dnl field */

/** TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__GET() gets BIST_VS_DNL.VS0_TEST_DNL's current value.
 *
 * When reading from BIST_VS_DNL.VS0_TEST_DNL, this is recommended to use.
 *
 * @return current value of BIST_VS_DNL.VS0_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_DNL__GET();
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__EXTRACT() extracts BIST_VS_DNL.VS0_TEST_DNL.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_DNL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_DNL
 * @return current value of BIST_VS_DNL.VS0_TEST_DNL
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_DNL__VS0_TEST_DNL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS_GAIN member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS_GAIN__ADDRESS returns the address of member BIST_VS_GAIN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS_GAIN
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS_GAIN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS_GAIN)));
}

/** TESTSTAT_BIST_VS_GAIN__GET() gets BIST_VS_GAIN's current value.
 *
 * When reading from BIST_VS_GAIN, this is mandatory to use.
 *
 * @return current value of BIST_VS_GAIN
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS_GAIN__ADDRESS());
}

/* -------------- TESTSTAT.BIST_VS_GAIN.VS_TEST_GAIN_COMPLETE -------------- */

/**
<pre>
  TESTSTAT.BIST_VS_GAIN.VS_TEST_GAIN_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__Pos       27                                                                     /*!< Right-most bit position of vs_test_gain_complete in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__Msk       (0x00000001UL << TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__Pos)    /*!< Mask for vs_test_gain_complete in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__Shift(v)  (((v) << TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__Pos) & TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__Msk) /*!< Shift value 'v' into vs_test_gain_complete and mask 'v' to fit it into vs_test_gain_complete field */

/** TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__GET() gets BIST_VS_GAIN.VS_TEST_GAIN_COMPLETE's current value.
 *
 * When reading from BIST_VS_GAIN.VS_TEST_GAIN_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_VS_GAIN.VS_TEST_GAIN_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__EXTRACT() extracts BIST_VS_GAIN.VS_TEST_GAIN_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_GAIN
 * @return current value of BIST_VS_GAIN.VS_TEST_GAIN_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS_TEST_GAIN_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS_GAIN.VS2_TEST_GAIN_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS_GAIN.VS2_TEST_GAIN_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__Pos           26                                                                     /*!< Right-most bit position of vs2_test_gain_err in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__Pos)        /*!< Mask for vs2_test_gain_err in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__Shift(v)      (((v) << TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__Pos) & TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__Msk) /*!< Shift value 'v' into vs2_test_gain_err and mask 'v' to fit it into vs2_test_gain_err field */

/** TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__GET() gets BIST_VS_GAIN.VS2_TEST_GAIN_ERR's current value.
 *
 * When reading from BIST_VS_GAIN.VS2_TEST_GAIN_ERR, this is recommended to use.
 *
 * @return current value of BIST_VS_GAIN.VS2_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__EXTRACT() extracts BIST_VS_GAIN.VS2_TEST_GAIN_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_GAIN
 * @return current value of BIST_VS_GAIN.VS2_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS_GAIN.VS2_TEST_GAIN_COMP ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS_GAIN.VS2_TEST_GAIN_COMP:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__Pos          18                                                                     /*!< Right-most bit position of vs2_test_gain_comp in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__Msk          (0x000000FFUL << TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__Pos)       /*!< Mask for vs2_test_gain_comp in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__Shift(v)     (((v) << TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__Pos) & TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__Msk) /*!< Shift value 'v' into vs2_test_gain_comp and mask 'v' to fit it into vs2_test_gain_comp field */

/** TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__GET() gets BIST_VS_GAIN.VS2_TEST_GAIN_COMP's current value.
 *
 * When reading from BIST_VS_GAIN.VS2_TEST_GAIN_COMP, this is recommended to use.
 *
 * @return current value of BIST_VS_GAIN.VS2_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__EXTRACT() extracts BIST_VS_GAIN.VS2_TEST_GAIN_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_GAIN
 * @return current value of BIST_VS_GAIN.VS2_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS2_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS_GAIN.VS1_TEST_GAIN_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS_GAIN.VS1_TEST_GAIN_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__Pos           17                                                                     /*!< Right-most bit position of vs1_test_gain_err in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__Pos)        /*!< Mask for vs1_test_gain_err in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__Shift(v)      (((v) << TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__Pos) & TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__Msk) /*!< Shift value 'v' into vs1_test_gain_err and mask 'v' to fit it into vs1_test_gain_err field */

/** TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__GET() gets BIST_VS_GAIN.VS1_TEST_GAIN_ERR's current value.
 *
 * When reading from BIST_VS_GAIN.VS1_TEST_GAIN_ERR, this is recommended to use.
 *
 * @return current value of BIST_VS_GAIN.VS1_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__EXTRACT() extracts BIST_VS_GAIN.VS1_TEST_GAIN_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_GAIN
 * @return current value of BIST_VS_GAIN.VS1_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS_GAIN.VS1_TEST_GAIN_COMP ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS_GAIN.VS1_TEST_GAIN_COMP:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__Pos          9                                                                      /*!< Right-most bit position of vs1_test_gain_comp in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__Msk          (0x000000FFUL << TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__Pos)       /*!< Mask for vs1_test_gain_comp in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__Shift(v)     (((v) << TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__Pos) & TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__Msk) /*!< Shift value 'v' into vs1_test_gain_comp and mask 'v' to fit it into vs1_test_gain_comp field */

/** TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__GET() gets BIST_VS_GAIN.VS1_TEST_GAIN_COMP's current value.
 *
 * When reading from BIST_VS_GAIN.VS1_TEST_GAIN_COMP, this is recommended to use.
 *
 * @return current value of BIST_VS_GAIN.VS1_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__EXTRACT() extracts BIST_VS_GAIN.VS1_TEST_GAIN_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_GAIN
 * @return current value of BIST_VS_GAIN.VS1_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS1_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS_GAIN.VS0_TEST_GAIN_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS_GAIN.VS0_TEST_GAIN_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__Pos           8                                                                      /*!< Right-most bit position of vs0_test_gain_err in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__Pos)        /*!< Mask for vs0_test_gain_err in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__Shift(v)      (((v) << TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__Pos) & TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__Msk) /*!< Shift value 'v' into vs0_test_gain_err and mask 'v' to fit it into vs0_test_gain_err field */

/** TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__GET() gets BIST_VS_GAIN.VS0_TEST_GAIN_ERR's current value.
 *
 * When reading from BIST_VS_GAIN.VS0_TEST_GAIN_ERR, this is recommended to use.
 *
 * @return current value of BIST_VS_GAIN.VS0_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__EXTRACT() extracts BIST_VS_GAIN.VS0_TEST_GAIN_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_GAIN
 * @return current value of BIST_VS_GAIN.VS0_TEST_GAIN_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_ERR__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS_GAIN.VS0_TEST_GAIN_COMP ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS_GAIN.VS0_TEST_GAIN_COMP:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__Pos          0                                                                      /*!< Right-most bit position of vs0_test_gain_comp in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__Msk          (0x000000FFUL << TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__Pos)       /*!< Mask for vs0_test_gain_comp in TESTSTAT.BIST_VS_GAIN */
#define TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__Shift(v)     (((v) << TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__Pos) & TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__Msk) /*!< Shift value 'v' into vs0_test_gain_comp and mask 'v' to fit it into vs0_test_gain_comp field */

/** TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__GET() gets BIST_VS_GAIN.VS0_TEST_GAIN_COMP's current value.
 *
 * When reading from BIST_VS_GAIN.VS0_TEST_GAIN_COMP, this is recommended to use.
 *
 * @return current value of BIST_VS_GAIN.VS0_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_GAIN__GET();
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__EXTRACT() extracts BIST_VS_GAIN.VS0_TEST_GAIN_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_GAIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_GAIN
 * @return current value of BIST_VS_GAIN.VS0_TEST_GAIN_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_GAIN__VS0_TEST_GAIN_COMP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS_OFFS member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS_OFFS__ADDRESS returns the address of member BIST_VS_OFFS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS_OFFS
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS_OFFS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS_OFFS)));
}

/** TESTSTAT_BIST_VS_OFFS__GET() gets BIST_VS_OFFS's current value.
 *
 * When reading from BIST_VS_OFFS, this is mandatory to use.
 *
 * @return current value of BIST_VS_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS_OFFS__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_VS_OFFS.VS_OFF_0V_COMPLETE ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS_OFFS.VS_OFF_0V_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__Pos          28                                                                     /*!< Right-most bit position of vs_off_0v_complete in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__Msk          (0x00000001UL << TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__Pos)       /*!< Mask for vs_off_0v_complete in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__Shift(v)     (((v) << TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__Pos) & TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__Msk) /*!< Shift value 'v' into vs_off_0v_complete and mask 'v' to fit it into vs_off_0v_complete field */

/** TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__GET() gets BIST_VS_OFFS.VS_OFF_0V_COMPLETE's current value.
 *
 * When reading from BIST_VS_OFFS.VS_OFF_0V_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_VS_OFFS.VS_OFF_0V_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_OFFS__GET();
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__EXTRACT() extracts BIST_VS_OFFS.VS_OFF_0V_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_OFFS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_OFFS
 * @return current value of BIST_VS_OFFS.VS_OFF_0V_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS_OFF_0V_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* -------------- TESTSTAT.BIST_VS_OFFS.VS_TEST_OFFS_COMPLETE -------------- */

/**
<pre>
  TESTSTAT.BIST_VS_OFFS.VS_TEST_OFFS_COMPLETE:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__Pos       27                                                                     /*!< Right-most bit position of vs_test_offs_complete in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__Msk       (0x00000001UL << TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__Pos)    /*!< Mask for vs_test_offs_complete in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__Shift(v)  (((v) << TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__Pos) & TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__Msk) /*!< Shift value 'v' into vs_test_offs_complete and mask 'v' to fit it into vs_test_offs_complete field */

/** TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__GET() gets BIST_VS_OFFS.VS_TEST_OFFS_COMPLETE's current value.
 *
 * When reading from BIST_VS_OFFS.VS_TEST_OFFS_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_VS_OFFS.VS_TEST_OFFS_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_OFFS__GET();
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__EXTRACT() extracts BIST_VS_OFFS.VS_TEST_OFFS_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_OFFS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_OFFS
 * @return current value of BIST_VS_OFFS.VS_TEST_OFFS_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS_TEST_OFFS_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS_OFFS.VS2_TEST_OFFS_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS_OFFS.VS2_TEST_OFFS_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__Pos           26                                                                     /*!< Right-most bit position of vs2_test_offs_err in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__Pos)        /*!< Mask for vs2_test_offs_err in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__Shift(v)      (((v) << TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__Pos) & TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__Msk) /*!< Shift value 'v' into vs2_test_offs_err and mask 'v' to fit it into vs2_test_offs_err field */

/** TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__GET() gets BIST_VS_OFFS.VS2_TEST_OFFS_ERR's current value.
 *
 * When reading from BIST_VS_OFFS.VS2_TEST_OFFS_ERR, this is recommended to use.
 *
 * @return current value of BIST_VS_OFFS.VS2_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_OFFS__GET();
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__EXTRACT() extracts BIST_VS_OFFS.VS2_TEST_OFFS_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_OFFS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_OFFS
 * @return current value of BIST_VS_OFFS.VS2_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------ TESTSTAT.BIST_VS_OFFS.VS2_TEST_OFFS ------------------ */

/**
<pre>
  TESTSTAT.BIST_VS_OFFS.VS2_TEST_OFFS:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__Pos               18                                                                     /*!< Right-most bit position of vs2_test_offs in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__Msk               (0x000000FFUL << TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__Pos)            /*!< Mask for vs2_test_offs in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__Shift(v)          (((v) << TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__Pos) & TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__Msk) /*!< Shift value 'v' into vs2_test_offs and mask 'v' to fit it into vs2_test_offs field */

/** TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__GET() gets BIST_VS_OFFS.VS2_TEST_OFFS's current value.
 *
 * When reading from BIST_VS_OFFS.VS2_TEST_OFFS, this is recommended to use.
 *
 * @return current value of BIST_VS_OFFS.VS2_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_OFFS__GET();
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__EXTRACT() extracts BIST_VS_OFFS.VS2_TEST_OFFS.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_OFFS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_OFFS
 * @return current value of BIST_VS_OFFS.VS2_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS2_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS_OFFS.VS1_TEST_OFFS_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS_OFFS.VS1_TEST_OFFS_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__Pos           17                                                                     /*!< Right-most bit position of vs1_test_offs_err in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__Pos)        /*!< Mask for vs1_test_offs_err in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__Shift(v)      (((v) << TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__Pos) & TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__Msk) /*!< Shift value 'v' into vs1_test_offs_err and mask 'v' to fit it into vs1_test_offs_err field */

/** TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__GET() gets BIST_VS_OFFS.VS1_TEST_OFFS_ERR's current value.
 *
 * When reading from BIST_VS_OFFS.VS1_TEST_OFFS_ERR, this is recommended to use.
 *
 * @return current value of BIST_VS_OFFS.VS1_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_OFFS__GET();
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__EXTRACT() extracts BIST_VS_OFFS.VS1_TEST_OFFS_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_OFFS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_OFFS
 * @return current value of BIST_VS_OFFS.VS1_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------ TESTSTAT.BIST_VS_OFFS.VS1_TEST_OFFS ------------------ */

/**
<pre>
  TESTSTAT.BIST_VS_OFFS.VS1_TEST_OFFS:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__Pos               9                                                                      /*!< Right-most bit position of vs1_test_offs in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__Msk               (0x000000FFUL << TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__Pos)            /*!< Mask for vs1_test_offs in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__Shift(v)          (((v) << TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__Pos) & TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__Msk) /*!< Shift value 'v' into vs1_test_offs and mask 'v' to fit it into vs1_test_offs field */

/** TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__GET() gets BIST_VS_OFFS.VS1_TEST_OFFS's current value.
 *
 * When reading from BIST_VS_OFFS.VS1_TEST_OFFS, this is recommended to use.
 *
 * @return current value of BIST_VS_OFFS.VS1_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_OFFS__GET();
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__EXTRACT() extracts BIST_VS_OFFS.VS1_TEST_OFFS.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_OFFS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_OFFS
 * @return current value of BIST_VS_OFFS.VS1_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS1_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS_OFFS.VS0_TEST_OFFS_ERR ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS_OFFS.VS0_TEST_OFFS_ERR:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__Pos           8                                                                      /*!< Right-most bit position of vs0_test_offs_err in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__Msk           (0x00000001UL << TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__Pos)        /*!< Mask for vs0_test_offs_err in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__Shift(v)      (((v) << TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__Pos) & TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__Msk) /*!< Shift value 'v' into vs0_test_offs_err and mask 'v' to fit it into vs0_test_offs_err field */

/** TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__GET() gets BIST_VS_OFFS.VS0_TEST_OFFS_ERR's current value.
 *
 * When reading from BIST_VS_OFFS.VS0_TEST_OFFS_ERR, this is recommended to use.
 *
 * @return current value of BIST_VS_OFFS.VS0_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_OFFS__GET();
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__EXTRACT() extracts BIST_VS_OFFS.VS0_TEST_OFFS_ERR.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_OFFS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_OFFS
 * @return current value of BIST_VS_OFFS.VS0_TEST_OFFS_ERR
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS_ERR__Pos);
    return (uint32_t)reg;
}

/* ------------------ TESTSTAT.BIST_VS_OFFS.VS0_TEST_OFFS ------------------ */

/**
<pre>
  TESTSTAT.BIST_VS_OFFS.VS0_TEST_OFFS:

    TBD

</pre> */

#define TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__Pos               0                                                                      /*!< Right-most bit position of vs0_test_offs in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__Msk               (0x000000FFUL << TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__Pos)            /*!< Mask for vs0_test_offs in TESTSTAT.BIST_VS_OFFS */
#define TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__Shift(v)          (((v) << TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__Pos) & TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__Msk) /*!< Shift value 'v' into vs0_test_offs and mask 'v' to fit it into vs0_test_offs field */

/** TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__GET() gets BIST_VS_OFFS.VS0_TEST_OFFS's current value.
 *
 * When reading from BIST_VS_OFFS.VS0_TEST_OFFS, this is recommended to use.
 *
 * @return current value of BIST_VS_OFFS.VS0_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS_OFFS__GET();
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__EXTRACT() extracts BIST_VS_OFFS.VS0_TEST_OFFS.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS_OFFS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS_OFFS
 * @return current value of BIST_VS_OFFS.VS0_TEST_OFFS
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__Msk);
    reg = (reg >> TESTSTAT_BIST_VS_OFFS__VS0_TEST_OFFS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TSADC_COMP1 member of TESTSTAT_t                      */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_TSADC_COMP1__ADDRESS returns the address of member TSADC_COMP1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSADC_COMP1
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_TSADC_COMP1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, TSADC_COMP1)));
}

/** TESTSTAT_TSADC_COMP1__GET() gets TSADC_COMP1's current value.
 *
 * When reading from TSADC_COMP1, this is mandatory to use.
 *
 * @return current value of TSADC_COMP1
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP1__GET(void)
{
    return HAL_GET32(__TESTSTAT_TSADC_COMP1__ADDRESS());
}

/* ----------------- TESTSTAT.TSADC_COMP1.TS_BTSEN_ADC_COMP ----------------- */

/**
<pre>
  TESTSTAT.TSADC_COMP1.TS_BTSEN_ADC_COMP:

    TBD

</pre> */

#define TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__Pos            15                                                                     /*!< Right-most bit position of ts_btsen_adc_comp in TESTSTAT.TSADC_COMP1 */
#define TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__Msk            (0x00007FFFUL << TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__Pos)         /*!< Mask for ts_btsen_adc_comp in TESTSTAT.TSADC_COMP1 */
#define TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__Shift(v)       (((v) << TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__Pos) & TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__Msk) /*!< Shift value 'v' into ts_btsen_adc_comp and mask 'v' to fit it into ts_btsen_adc_comp field */

/** TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__GET() gets TSADC_COMP1.TS_BTSEN_ADC_COMP's current value.
 *
 * When reading from TSADC_COMP1.TS_BTSEN_ADC_COMP, this is recommended to use.
 *
 * @return current value of TSADC_COMP1.TS_BTSEN_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_TSADC_COMP1__GET();
    reg = (reg & TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__EXTRACT() extracts TSADC_COMP1.TS_BTSEN_ADC_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.TSADC_COMP1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.TSADC_COMP1
 * @return current value of TSADC_COMP1.TS_BTSEN_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP1__TS_BTSEN_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.TSADC_COMP1.TS_ATSEN_ADC_COMP ----------------- */

/**
<pre>
  TESTSTAT.TSADC_COMP1.TS_ATSEN_ADC_COMP:

    TBD

</pre> */

#define TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__Pos            0                                                                      /*!< Right-most bit position of ts_atsen_adc_comp in TESTSTAT.TSADC_COMP1 */
#define TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__Msk            (0x00007FFFUL << TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__Pos)         /*!< Mask for ts_atsen_adc_comp in TESTSTAT.TSADC_COMP1 */
#define TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__Shift(v)       (((v) << TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__Pos) & TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__Msk) /*!< Shift value 'v' into ts_atsen_adc_comp and mask 'v' to fit it into ts_atsen_adc_comp field */

/** TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__GET() gets TSADC_COMP1.TS_ATSEN_ADC_COMP's current value.
 *
 * When reading from TSADC_COMP1.TS_ATSEN_ADC_COMP, this is recommended to use.
 *
 * @return current value of TSADC_COMP1.TS_ATSEN_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_TSADC_COMP1__GET();
    reg = (reg & TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__EXTRACT() extracts TSADC_COMP1.TS_ATSEN_ADC_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.TSADC_COMP1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.TSADC_COMP1
 * @return current value of TSADC_COMP1.TS_ATSEN_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP1__TS_ATSEN_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TSADC_COMP2 member of TESTSTAT_t                      */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_TSADC_COMP2__ADDRESS returns the address of member TSADC_COMP2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSADC_COMP2
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_TSADC_COMP2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, TSADC_COMP2)));
}

/** TESTSTAT_TSADC_COMP2__GET() gets TSADC_COMP2's current value.
 *
 * When reading from TSADC_COMP2, this is mandatory to use.
 *
 * @return current value of TSADC_COMP2
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP2__GET(void)
{
    return HAL_GET32(__TESTSTAT_TSADC_COMP2__ADDRESS());
}

/* ----------------- TESTSTAT.TSADC_COMP2.TS_IMON_ADC_COMP ----------------- */

/**
<pre>
  TESTSTAT.TSADC_COMP2.TS_IMON_ADC_COMP:

    TBD

</pre> */

#define TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__Pos             15                                                                     /*!< Right-most bit position of ts_imon_adc_comp in TESTSTAT.TSADC_COMP2 */
#define TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__Msk             (0x00007FFFUL << TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__Pos)          /*!< Mask for ts_imon_adc_comp in TESTSTAT.TSADC_COMP2 */
#define TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__Shift(v)        (((v) << TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__Pos) & TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__Msk) /*!< Shift value 'v' into ts_imon_adc_comp and mask 'v' to fit it into ts_imon_adc_comp field */

/** TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__GET() gets TSADC_COMP2.TS_IMON_ADC_COMP's current value.
 *
 * When reading from TSADC_COMP2.TS_IMON_ADC_COMP, this is recommended to use.
 *
 * @return current value of TSADC_COMP2.TS_IMON_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_TSADC_COMP2__GET();
    reg = (reg & TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__EXTRACT() extracts TSADC_COMP2.TS_IMON_ADC_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.TSADC_COMP2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.TSADC_COMP2
 * @return current value of TSADC_COMP2.TS_IMON_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP2__TS_IMON_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.TSADC_COMP2.TS_ITSEN_ADC_COMP ----------------- */

/**
<pre>
  TESTSTAT.TSADC_COMP2.TS_ITSEN_ADC_COMP:

    TBD

</pre> */

#define TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__Pos            0                                                                      /*!< Right-most bit position of ts_itsen_adc_comp in TESTSTAT.TSADC_COMP2 */
#define TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__Msk            (0x00007FFFUL << TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__Pos)         /*!< Mask for ts_itsen_adc_comp in TESTSTAT.TSADC_COMP2 */
#define TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__Shift(v)       (((v) << TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__Pos) & TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__Msk) /*!< Shift value 'v' into ts_itsen_adc_comp and mask 'v' to fit it into ts_itsen_adc_comp field */

/** TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__GET() gets TSADC_COMP2.TS_ITSEN_ADC_COMP's current value.
 *
 * When reading from TSADC_COMP2.TS_ITSEN_ADC_COMP, this is recommended to use.
 *
 * @return current value of TSADC_COMP2.TS_ITSEN_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_TSADC_COMP2__GET();
    reg = (reg & TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__EXTRACT() extracts TSADC_COMP2.TS_ITSEN_ADC_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.TSADC_COMP2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.TSADC_COMP2
 * @return current value of TSADC_COMP2.TS_ITSEN_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP2__TS_ITSEN_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TSADC_COMP3 member of TESTSTAT_t                      */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_TSADC_COMP3__ADDRESS returns the address of member TSADC_COMP3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSADC_COMP3
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_TSADC_COMP3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, TSADC_COMP3)));
}

/** TESTSTAT_TSADC_COMP3__GET() gets TSADC_COMP3's current value.
 *
 * When reading from TSADC_COMP3, this is mandatory to use.
 *
 * @return current value of TSADC_COMP3
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP3__GET(void)
{
    return HAL_GET32(__TESTSTAT_TSADC_COMP3__ADDRESS());
}

/* ------------------ TESTSTAT.TSADC_COMP3.TS_XV1_ADC_COMP ------------------ */

/**
<pre>
  TESTSTAT.TSADC_COMP3.TS_XV1_ADC_COMP:

    TBD

</pre> */

#define TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__Pos              15                                                                     /*!< Right-most bit position of ts_xv1_adc_comp in TESTSTAT.TSADC_COMP3 */
#define TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__Msk              (0x00007FFFUL << TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__Pos)           /*!< Mask for ts_xv1_adc_comp in TESTSTAT.TSADC_COMP3 */
#define TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__Shift(v)         (((v) << TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__Pos) & TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__Msk) /*!< Shift value 'v' into ts_xv1_adc_comp and mask 'v' to fit it into ts_xv1_adc_comp field */

/** TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__GET() gets TSADC_COMP3.TS_XV1_ADC_COMP's current value.
 *
 * When reading from TSADC_COMP3.TS_XV1_ADC_COMP, this is recommended to use.
 *
 * @return current value of TSADC_COMP3.TS_XV1_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_TSADC_COMP3__GET();
    reg = (reg & TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__EXTRACT() extracts TSADC_COMP3.TS_XV1_ADC_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.TSADC_COMP3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.TSADC_COMP3
 * @return current value of TSADC_COMP3.TS_XV1_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP3__TS_XV1_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.TSADC_COMP3.TS_PRISEN_ADC_COMP ---------------- */

/**
<pre>
  TESTSTAT.TSADC_COMP3.TS_PRISEN_ADC_COMP:

    TBD

</pre> */

#define TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__Pos           0                                                                      /*!< Right-most bit position of ts_prisen_adc_comp in TESTSTAT.TSADC_COMP3 */
#define TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__Msk           (0x00007FFFUL << TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__Pos)        /*!< Mask for ts_prisen_adc_comp in TESTSTAT.TSADC_COMP3 */
#define TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__Shift(v)      (((v) << TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__Pos) & TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__Msk) /*!< Shift value 'v' into ts_prisen_adc_comp and mask 'v' to fit it into ts_prisen_adc_comp field */

/** TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__GET() gets TSADC_COMP3.TS_PRISEN_ADC_COMP's current value.
 *
 * When reading from TSADC_COMP3.TS_PRISEN_ADC_COMP, this is recommended to use.
 *
 * @return current value of TSADC_COMP3.TS_PRISEN_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_TSADC_COMP3__GET();
    reg = (reg & TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__EXTRACT() extracts TSADC_COMP3.TS_PRISEN_ADC_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.TSADC_COMP3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.TSADC_COMP3
 * @return current value of TSADC_COMP3.TS_PRISEN_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP3__TS_PRISEN_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TSADC_COMP4 member of TESTSTAT_t                      */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_TSADC_COMP4__ADDRESS returns the address of member TSADC_COMP4.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSADC_COMP4
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_TSADC_COMP4__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, TSADC_COMP4)));
}

/** TESTSTAT_TSADC_COMP4__GET() gets TSADC_COMP4's current value.
 *
 * When reading from TSADC_COMP4, this is mandatory to use.
 *
 * @return current value of TSADC_COMP4
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP4__GET(void)
{
    return HAL_GET32(__TESTSTAT_TSADC_COMP4__ADDRESS());
}

/* ------------------ TESTSTAT.TSADC_COMP4.TS_XV2_ADC_COMP ------------------ */

/**
<pre>
  TESTSTAT.TSADC_COMP4.TS_XV2_ADC_COMP:

    TBD

</pre> */

#define TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__Pos              0                                                                      /*!< Right-most bit position of ts_xv2_adc_comp in TESTSTAT.TSADC_COMP4 */
#define TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__Msk              (0x00007FFFUL << TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__Pos)           /*!< Mask for ts_xv2_adc_comp in TESTSTAT.TSADC_COMP4 */
#define TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__Shift(v)         (((v) << TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__Pos) & TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__Msk) /*!< Shift value 'v' into ts_xv2_adc_comp and mask 'v' to fit it into ts_xv2_adc_comp field */

/** TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__GET() gets TSADC_COMP4.TS_XV2_ADC_COMP's current value.
 *
 * When reading from TSADC_COMP4.TS_XV2_ADC_COMP, this is recommended to use.
 *
 * @return current value of TSADC_COMP4.TS_XV2_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__GET(void)
{
    uint32_t reg = TESTSTAT_TSADC_COMP4__GET();
    reg = (reg & TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__EXTRACT() extracts TSADC_COMP4.TS_XV2_ADC_COMP.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.TSADC_COMP4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.TSADC_COMP4
 * @return current value of TSADC_COMP4.TS_XV2_ADC_COMP
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__Msk);
    reg = (reg >> TESTSTAT_TSADC_COMP4__TS_XV2_ADC_COMP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS0_FE0 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS0_FE0__ADDRESS returns the address of member BIST_VS0_FE0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS0_FE0
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS0_FE0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS0_FE0)));
}

/** TESTSTAT_BIST_VS0_FE0__GET() gets BIST_VS0_FE0's current value.
 *
 * When reading from BIST_VS0_FE0, this is mandatory to use.
 *
 * @return current value of BIST_VS0_FE0
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE0__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS0_FE0__ADDRESS());
}

/* ------------- TESTSTAT.BIST_VS0_FE0.VS_TEST_STRESS_COMPLETE ------------- */

/**
<pre>
  TESTSTAT.BIST_VS0_FE0.VS_TEST_STRESS_COMPLETE:

    voltage sense0,1,2 - test mode vsadc measurement of all three voltage senses are complete

</pre> */

#define TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__Pos     16                                                                     /*!< Right-most bit position of vs_test_stress_complete in TESTSTAT.BIST_VS0_FE0 */
#define TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__Msk     (0x00000001UL << TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__Pos)  /*!< Mask for vs_test_stress_complete in TESTSTAT.BIST_VS0_FE0 */
#define TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__Shift(v) (((v) << TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__Pos) & TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__Msk) /*!< Shift value 'v' into vs_test_stress_complete and mask 'v' to fit it into vs_test_stress_complete field */

/** TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__GET() gets BIST_VS0_FE0.VS_TEST_STRESS_COMPLETE's current value.
 *
 * When reading from BIST_VS0_FE0.VS_TEST_STRESS_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_VS0_FE0.VS_TEST_STRESS_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS0_FE0__GET();
    reg = (reg & TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__EXTRACT() extracts BIST_VS0_FE0.VS_TEST_STRESS_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS0_FE0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS0_FE0
 * @return current value of BIST_VS0_FE0.VS_TEST_STRESS_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE0__VS_TEST_STRESS_COMPLETE__Pos);
    return (uint32_t)reg;
}

/* ----------------- TESTSTAT.BIST_VS0_FE0.VS0_TEST_STRESS0 ----------------- */

/**
<pre>
  TESTSTAT.BIST_VS0_FE0.VS0_TEST_STRESS0:

    voltage sense 0 - test mode vsadc measurement @ 00h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__Pos            0                                                                      /*!< Right-most bit position of vs0_test_stress0 in TESTSTAT.BIST_VS0_FE0 */
#define TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__Msk            (0x0000FFFFUL << TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__Pos)         /*!< Mask for vs0_test_stress0 in TESTSTAT.BIST_VS0_FE0 */
#define TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__Shift(v)       (((v) << TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__Pos) & TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__Msk) /*!< Shift value 'v' into vs0_test_stress0 and mask 'v' to fit it into vs0_test_stress0 field */

/** TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__GET() gets BIST_VS0_FE0.VS0_TEST_STRESS0's current value.
 *
 * When reading from BIST_VS0_FE0.VS0_TEST_STRESS0, this is recommended to use.
 *
 * @return current value of BIST_VS0_FE0.VS0_TEST_STRESS0
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS0_FE0__GET();
    reg = (reg & TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__EXTRACT() extracts BIST_VS0_FE0.VS0_TEST_STRESS0.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS0_FE0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS0_FE0
 * @return current value of BIST_VS0_FE0.VS0_TEST_STRESS0
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE0__VS0_TEST_STRESS0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS0_FE12 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS0_FE12__ADDRESS returns the address of member BIST_VS0_FE12.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS0_FE12
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS0_FE12__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS0_FE12)));
}

/** TESTSTAT_BIST_VS0_FE12__GET() gets BIST_VS0_FE12's current value.
 *
 * When reading from BIST_VS0_FE12, this is mandatory to use.
 *
 * @return current value of BIST_VS0_FE12
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE12__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS0_FE12__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_VS0_FE12.VS0_TEST_STRESS2 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS0_FE12.VS0_TEST_STRESS2:

    voltage sense 0 - test mode vsadc measurement @ 02h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__Pos           16                                                                     /*!< Right-most bit position of vs0_test_stress2 in TESTSTAT.BIST_VS0_FE12 */
#define TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__Pos)        /*!< Mask for vs0_test_stress2 in TESTSTAT.BIST_VS0_FE12 */
#define TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__Shift(v)      (((v) << TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__Pos) & TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__Msk) /*!< Shift value 'v' into vs0_test_stress2 and mask 'v' to fit it into vs0_test_stress2 field */

/** TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__GET() gets BIST_VS0_FE12.VS0_TEST_STRESS2's current value.
 *
 * When reading from BIST_VS0_FE12.VS0_TEST_STRESS2, this is recommended to use.
 *
 * @return current value of BIST_VS0_FE12.VS0_TEST_STRESS2
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS0_FE12__GET();
    reg = (reg & TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__EXTRACT() extracts BIST_VS0_FE12.VS0_TEST_STRESS2.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS0_FE12.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS0_FE12
 * @return current value of BIST_VS0_FE12.VS0_TEST_STRESS2
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS2__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS0_FE12.VS0_TEST_STRESS1 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS0_FE12.VS0_TEST_STRESS1:

    voltage sense 0 - test mode vsadc measurement @ 01h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__Pos           0                                                                      /*!< Right-most bit position of vs0_test_stress1 in TESTSTAT.BIST_VS0_FE12 */
#define TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__Pos)        /*!< Mask for vs0_test_stress1 in TESTSTAT.BIST_VS0_FE12 */
#define TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__Shift(v)      (((v) << TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__Pos) & TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__Msk) /*!< Shift value 'v' into vs0_test_stress1 and mask 'v' to fit it into vs0_test_stress1 field */

/** TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__GET() gets BIST_VS0_FE12.VS0_TEST_STRESS1's current value.
 *
 * When reading from BIST_VS0_FE12.VS0_TEST_STRESS1, this is recommended to use.
 *
 * @return current value of BIST_VS0_FE12.VS0_TEST_STRESS1
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS0_FE12__GET();
    reg = (reg & TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__EXTRACT() extracts BIST_VS0_FE12.VS0_TEST_STRESS1.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS0_FE12.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS0_FE12
 * @return current value of BIST_VS0_FE12.VS0_TEST_STRESS1
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE12__VS0_TEST_STRESS1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS0_FE34 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS0_FE34__ADDRESS returns the address of member BIST_VS0_FE34.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS0_FE34
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS0_FE34__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS0_FE34)));
}

/** TESTSTAT_BIST_VS0_FE34__GET() gets BIST_VS0_FE34's current value.
 *
 * When reading from BIST_VS0_FE34, this is mandatory to use.
 *
 * @return current value of BIST_VS0_FE34
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE34__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS0_FE34__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_VS0_FE34.VS0_TEST_STRESS4 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS0_FE34.VS0_TEST_STRESS4:

    voltage sense 0 - test mode vsadc measurement @ 08h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__Pos           16                                                                     /*!< Right-most bit position of vs0_test_stress4 in TESTSTAT.BIST_VS0_FE34 */
#define TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__Pos)        /*!< Mask for vs0_test_stress4 in TESTSTAT.BIST_VS0_FE34 */
#define TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__Shift(v)      (((v) << TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__Pos) & TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__Msk) /*!< Shift value 'v' into vs0_test_stress4 and mask 'v' to fit it into vs0_test_stress4 field */

/** TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__GET() gets BIST_VS0_FE34.VS0_TEST_STRESS4's current value.
 *
 * When reading from BIST_VS0_FE34.VS0_TEST_STRESS4, this is recommended to use.
 *
 * @return current value of BIST_VS0_FE34.VS0_TEST_STRESS4
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS0_FE34__GET();
    reg = (reg & TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__EXTRACT() extracts BIST_VS0_FE34.VS0_TEST_STRESS4.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS0_FE34.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS0_FE34
 * @return current value of BIST_VS0_FE34.VS0_TEST_STRESS4
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS4__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS0_FE34.VS0_TEST_STRESS3 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS0_FE34.VS0_TEST_STRESS3:

    voltage sense 0 - test mode vsadc measurement @ 04h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__Pos           0                                                                      /*!< Right-most bit position of vs0_test_stress3 in TESTSTAT.BIST_VS0_FE34 */
#define TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__Pos)        /*!< Mask for vs0_test_stress3 in TESTSTAT.BIST_VS0_FE34 */
#define TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__Shift(v)      (((v) << TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__Pos) & TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__Msk) /*!< Shift value 'v' into vs0_test_stress3 and mask 'v' to fit it into vs0_test_stress3 field */

/** TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__GET() gets BIST_VS0_FE34.VS0_TEST_STRESS3's current value.
 *
 * When reading from BIST_VS0_FE34.VS0_TEST_STRESS3, this is recommended to use.
 *
 * @return current value of BIST_VS0_FE34.VS0_TEST_STRESS3
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS0_FE34__GET();
    reg = (reg & TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__EXTRACT() extracts BIST_VS0_FE34.VS0_TEST_STRESS3.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS0_FE34.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS0_FE34
 * @return current value of BIST_VS0_FE34.VS0_TEST_STRESS3
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE34__VS0_TEST_STRESS3__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS0_FE56 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS0_FE56__ADDRESS returns the address of member BIST_VS0_FE56.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS0_FE56
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS0_FE56__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS0_FE56)));
}

/** TESTSTAT_BIST_VS0_FE56__GET() gets BIST_VS0_FE56's current value.
 *
 * When reading from BIST_VS0_FE56, this is mandatory to use.
 *
 * @return current value of BIST_VS0_FE56
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE56__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS0_FE56__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_VS0_FE56.VS0_TEST_STRESS6 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS0_FE56.VS0_TEST_STRESS6:

    voltage sense 0 - test mode vsadc measurement @ 20h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__Pos           16                                                                     /*!< Right-most bit position of vs0_test_stress6 in TESTSTAT.BIST_VS0_FE56 */
#define TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__Pos)        /*!< Mask for vs0_test_stress6 in TESTSTAT.BIST_VS0_FE56 */
#define TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__Shift(v)      (((v) << TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__Pos) & TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__Msk) /*!< Shift value 'v' into vs0_test_stress6 and mask 'v' to fit it into vs0_test_stress6 field */

/** TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__GET() gets BIST_VS0_FE56.VS0_TEST_STRESS6's current value.
 *
 * When reading from BIST_VS0_FE56.VS0_TEST_STRESS6, this is recommended to use.
 *
 * @return current value of BIST_VS0_FE56.VS0_TEST_STRESS6
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS0_FE56__GET();
    reg = (reg & TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__EXTRACT() extracts BIST_VS0_FE56.VS0_TEST_STRESS6.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS0_FE56.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS0_FE56
 * @return current value of BIST_VS0_FE56.VS0_TEST_STRESS6
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS6__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS0_FE56.VS0_TEST_STRESS5 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS0_FE56.VS0_TEST_STRESS5:

    voltage sense 0 - test mode vsadc measurement @ 10h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__Pos           0                                                                      /*!< Right-most bit position of vs0_test_stress5 in TESTSTAT.BIST_VS0_FE56 */
#define TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__Pos)        /*!< Mask for vs0_test_stress5 in TESTSTAT.BIST_VS0_FE56 */
#define TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__Shift(v)      (((v) << TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__Pos) & TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__Msk) /*!< Shift value 'v' into vs0_test_stress5 and mask 'v' to fit it into vs0_test_stress5 field */

/** TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__GET() gets BIST_VS0_FE56.VS0_TEST_STRESS5's current value.
 *
 * When reading from BIST_VS0_FE56.VS0_TEST_STRESS5, this is recommended to use.
 *
 * @return current value of BIST_VS0_FE56.VS0_TEST_STRESS5
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS0_FE56__GET();
    reg = (reg & TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__EXTRACT() extracts BIST_VS0_FE56.VS0_TEST_STRESS5.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS0_FE56.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS0_FE56
 * @return current value of BIST_VS0_FE56.VS0_TEST_STRESS5
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__Msk);
    reg = (reg >> TESTSTAT_BIST_VS0_FE56__VS0_TEST_STRESS5__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS1_FE0 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS1_FE0__ADDRESS returns the address of member BIST_VS1_FE0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS1_FE0
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS1_FE0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS1_FE0)));
}

/** TESTSTAT_BIST_VS1_FE0__GET() gets BIST_VS1_FE0's current value.
 *
 * When reading from BIST_VS1_FE0, this is mandatory to use.
 *
 * @return current value of BIST_VS1_FE0
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE0__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS1_FE0__ADDRESS());
}

/* ----------------- TESTSTAT.BIST_VS1_FE0.VS1_TEST_STRESS0 ----------------- */

/**
<pre>
  TESTSTAT.BIST_VS1_FE0.VS1_TEST_STRESS0:

    voltage sense 1 - test mode vsadc measurement @ 00h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__Pos            0                                                                      /*!< Right-most bit position of vs1_test_stress0 in TESTSTAT.BIST_VS1_FE0 */
#define TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__Msk            (0x0000FFFFUL << TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__Pos)         /*!< Mask for vs1_test_stress0 in TESTSTAT.BIST_VS1_FE0 */
#define TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__Shift(v)       (((v) << TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__Pos) & TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__Msk) /*!< Shift value 'v' into vs1_test_stress0 and mask 'v' to fit it into vs1_test_stress0 field */

/** TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__GET() gets BIST_VS1_FE0.VS1_TEST_STRESS0's current value.
 *
 * When reading from BIST_VS1_FE0.VS1_TEST_STRESS0, this is recommended to use.
 *
 * @return current value of BIST_VS1_FE0.VS1_TEST_STRESS0
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS1_FE0__GET();
    reg = (reg & TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__EXTRACT() extracts BIST_VS1_FE0.VS1_TEST_STRESS0.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS1_FE0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS1_FE0
 * @return current value of BIST_VS1_FE0.VS1_TEST_STRESS0
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE0__VS1_TEST_STRESS0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS1_FE12 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS1_FE12__ADDRESS returns the address of member BIST_VS1_FE12.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS1_FE12
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS1_FE12__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS1_FE12)));
}

/** TESTSTAT_BIST_VS1_FE12__GET() gets BIST_VS1_FE12's current value.
 *
 * When reading from BIST_VS1_FE12, this is mandatory to use.
 *
 * @return current value of BIST_VS1_FE12
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE12__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS1_FE12__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_VS1_FE12.VS1_TEST_STRESS2 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS1_FE12.VS1_TEST_STRESS2:

    voltage sense 1 - test mode vsadc measurement @ 02h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__Pos           16                                                                     /*!< Right-most bit position of vs1_test_stress2 in TESTSTAT.BIST_VS1_FE12 */
#define TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__Pos)        /*!< Mask for vs1_test_stress2 in TESTSTAT.BIST_VS1_FE12 */
#define TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__Shift(v)      (((v) << TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__Pos) & TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__Msk) /*!< Shift value 'v' into vs1_test_stress2 and mask 'v' to fit it into vs1_test_stress2 field */

/** TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__GET() gets BIST_VS1_FE12.VS1_TEST_STRESS2's current value.
 *
 * When reading from BIST_VS1_FE12.VS1_TEST_STRESS2, this is recommended to use.
 *
 * @return current value of BIST_VS1_FE12.VS1_TEST_STRESS2
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS1_FE12__GET();
    reg = (reg & TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__EXTRACT() extracts BIST_VS1_FE12.VS1_TEST_STRESS2.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS1_FE12.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS1_FE12
 * @return current value of BIST_VS1_FE12.VS1_TEST_STRESS2
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS2__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS1_FE12.VS1_TEST_STRESS1 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS1_FE12.VS1_TEST_STRESS1:

    voltage sense 1 - test mode vsadc measurement @ 01h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__Pos           0                                                                      /*!< Right-most bit position of vs1_test_stress1 in TESTSTAT.BIST_VS1_FE12 */
#define TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__Pos)        /*!< Mask for vs1_test_stress1 in TESTSTAT.BIST_VS1_FE12 */
#define TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__Shift(v)      (((v) << TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__Pos) & TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__Msk) /*!< Shift value 'v' into vs1_test_stress1 and mask 'v' to fit it into vs1_test_stress1 field */

/** TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__GET() gets BIST_VS1_FE12.VS1_TEST_STRESS1's current value.
 *
 * When reading from BIST_VS1_FE12.VS1_TEST_STRESS1, this is recommended to use.
 *
 * @return current value of BIST_VS1_FE12.VS1_TEST_STRESS1
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS1_FE12__GET();
    reg = (reg & TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__EXTRACT() extracts BIST_VS1_FE12.VS1_TEST_STRESS1.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS1_FE12.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS1_FE12
 * @return current value of BIST_VS1_FE12.VS1_TEST_STRESS1
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE12__VS1_TEST_STRESS1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS1_FE34 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS1_FE34__ADDRESS returns the address of member BIST_VS1_FE34.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS1_FE34
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS1_FE34__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS1_FE34)));
}

/** TESTSTAT_BIST_VS1_FE34__GET() gets BIST_VS1_FE34's current value.
 *
 * When reading from BIST_VS1_FE34, this is mandatory to use.
 *
 * @return current value of BIST_VS1_FE34
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE34__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS1_FE34__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_VS1_FE34.VS1_TEST_STRESS4 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS1_FE34.VS1_TEST_STRESS4:

    voltage sense 1 - test mode vsadc measurement @ 08h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__Pos           16                                                                     /*!< Right-most bit position of vs1_test_stress4 in TESTSTAT.BIST_VS1_FE34 */
#define TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__Pos)        /*!< Mask for vs1_test_stress4 in TESTSTAT.BIST_VS1_FE34 */
#define TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__Shift(v)      (((v) << TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__Pos) & TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__Msk) /*!< Shift value 'v' into vs1_test_stress4 and mask 'v' to fit it into vs1_test_stress4 field */

/** TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__GET() gets BIST_VS1_FE34.VS1_TEST_STRESS4's current value.
 *
 * When reading from BIST_VS1_FE34.VS1_TEST_STRESS4, this is recommended to use.
 *
 * @return current value of BIST_VS1_FE34.VS1_TEST_STRESS4
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS1_FE34__GET();
    reg = (reg & TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__EXTRACT() extracts BIST_VS1_FE34.VS1_TEST_STRESS4.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS1_FE34.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS1_FE34
 * @return current value of BIST_VS1_FE34.VS1_TEST_STRESS4
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS4__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS1_FE34.VS1_TEST_STRESS3 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS1_FE34.VS1_TEST_STRESS3:

    voltage sense 1 - test mode vsadc measurement @ 04h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__Pos           0                                                                      /*!< Right-most bit position of vs1_test_stress3 in TESTSTAT.BIST_VS1_FE34 */
#define TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__Pos)        /*!< Mask for vs1_test_stress3 in TESTSTAT.BIST_VS1_FE34 */
#define TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__Shift(v)      (((v) << TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__Pos) & TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__Msk) /*!< Shift value 'v' into vs1_test_stress3 and mask 'v' to fit it into vs1_test_stress3 field */

/** TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__GET() gets BIST_VS1_FE34.VS1_TEST_STRESS3's current value.
 *
 * When reading from BIST_VS1_FE34.VS1_TEST_STRESS3, this is recommended to use.
 *
 * @return current value of BIST_VS1_FE34.VS1_TEST_STRESS3
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS1_FE34__GET();
    reg = (reg & TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__EXTRACT() extracts BIST_VS1_FE34.VS1_TEST_STRESS3.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS1_FE34.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS1_FE34
 * @return current value of BIST_VS1_FE34.VS1_TEST_STRESS3
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE34__VS1_TEST_STRESS3__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS1_FE56 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS1_FE56__ADDRESS returns the address of member BIST_VS1_FE56.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS1_FE56
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS1_FE56__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS1_FE56)));
}

/** TESTSTAT_BIST_VS1_FE56__GET() gets BIST_VS1_FE56's current value.
 *
 * When reading from BIST_VS1_FE56, this is mandatory to use.
 *
 * @return current value of BIST_VS1_FE56
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE56__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS1_FE56__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_VS1_FE56.VS1_TEST_STRESS6 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS1_FE56.VS1_TEST_STRESS6:

    voltage sense 1 - test mode vsadc measurement @ 20h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__Pos           16                                                                     /*!< Right-most bit position of vs1_test_stress6 in TESTSTAT.BIST_VS1_FE56 */
#define TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__Pos)        /*!< Mask for vs1_test_stress6 in TESTSTAT.BIST_VS1_FE56 */
#define TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__Shift(v)      (((v) << TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__Pos) & TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__Msk) /*!< Shift value 'v' into vs1_test_stress6 and mask 'v' to fit it into vs1_test_stress6 field */

/** TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__GET() gets BIST_VS1_FE56.VS1_TEST_STRESS6's current value.
 *
 * When reading from BIST_VS1_FE56.VS1_TEST_STRESS6, this is recommended to use.
 *
 * @return current value of BIST_VS1_FE56.VS1_TEST_STRESS6
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS1_FE56__GET();
    reg = (reg & TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__EXTRACT() extracts BIST_VS1_FE56.VS1_TEST_STRESS6.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS1_FE56.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS1_FE56
 * @return current value of BIST_VS1_FE56.VS1_TEST_STRESS6
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS6__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS1_FE56.VS1_TEST_STRESS5 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS1_FE56.VS1_TEST_STRESS5:

    voltage sense 1 - test mode vsadc measurement @ 10h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__Pos           0                                                                      /*!< Right-most bit position of vs1_test_stress5 in TESTSTAT.BIST_VS1_FE56 */
#define TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__Pos)        /*!< Mask for vs1_test_stress5 in TESTSTAT.BIST_VS1_FE56 */
#define TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__Shift(v)      (((v) << TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__Pos) & TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__Msk) /*!< Shift value 'v' into vs1_test_stress5 and mask 'v' to fit it into vs1_test_stress5 field */

/** TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__GET() gets BIST_VS1_FE56.VS1_TEST_STRESS5's current value.
 *
 * When reading from BIST_VS1_FE56.VS1_TEST_STRESS5, this is recommended to use.
 *
 * @return current value of BIST_VS1_FE56.VS1_TEST_STRESS5
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS1_FE56__GET();
    reg = (reg & TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__EXTRACT() extracts BIST_VS1_FE56.VS1_TEST_STRESS5.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS1_FE56.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS1_FE56
 * @return current value of BIST_VS1_FE56.VS1_TEST_STRESS5
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__Msk);
    reg = (reg >> TESTSTAT_BIST_VS1_FE56__VS1_TEST_STRESS5__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS2_FE0 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS2_FE0__ADDRESS returns the address of member BIST_VS2_FE0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS2_FE0
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS2_FE0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS2_FE0)));
}

/** TESTSTAT_BIST_VS2_FE0__GET() gets BIST_VS2_FE0's current value.
 *
 * When reading from BIST_VS2_FE0, this is mandatory to use.
 *
 * @return current value of BIST_VS2_FE0
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE0__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS2_FE0__ADDRESS());
}

/* ----------------- TESTSTAT.BIST_VS2_FE0.VS2_TEST_STRESS0 ----------------- */

/**
<pre>
  TESTSTAT.BIST_VS2_FE0.VS2_TEST_STRESS0:

    voltage sense 2 - test mode vsadc measurement @ 00h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__Pos            0                                                                      /*!< Right-most bit position of vs2_test_stress0 in TESTSTAT.BIST_VS2_FE0 */
#define TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__Msk            (0x0000FFFFUL << TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__Pos)         /*!< Mask for vs2_test_stress0 in TESTSTAT.BIST_VS2_FE0 */
#define TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__Shift(v)       (((v) << TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__Pos) & TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__Msk) /*!< Shift value 'v' into vs2_test_stress0 and mask 'v' to fit it into vs2_test_stress0 field */

/** TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__GET() gets BIST_VS2_FE0.VS2_TEST_STRESS0's current value.
 *
 * When reading from BIST_VS2_FE0.VS2_TEST_STRESS0, this is recommended to use.
 *
 * @return current value of BIST_VS2_FE0.VS2_TEST_STRESS0
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS2_FE0__GET();
    reg = (reg & TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__EXTRACT() extracts BIST_VS2_FE0.VS2_TEST_STRESS0.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS2_FE0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS2_FE0
 * @return current value of BIST_VS2_FE0.VS2_TEST_STRESS0
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE0__VS2_TEST_STRESS0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS2_FE12 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS2_FE12__ADDRESS returns the address of member BIST_VS2_FE12.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS2_FE12
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS2_FE12__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS2_FE12)));
}

/** TESTSTAT_BIST_VS2_FE12__GET() gets BIST_VS2_FE12's current value.
 *
 * When reading from BIST_VS2_FE12, this is mandatory to use.
 *
 * @return current value of BIST_VS2_FE12
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE12__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS2_FE12__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_VS2_FE12.VS2_TEST_STRESS2 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS2_FE12.VS2_TEST_STRESS2:

    voltage sense 2 - test mode vsadc measurement @ 02h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__Pos           16                                                                     /*!< Right-most bit position of vs2_test_stress2 in TESTSTAT.BIST_VS2_FE12 */
#define TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__Pos)        /*!< Mask for vs2_test_stress2 in TESTSTAT.BIST_VS2_FE12 */
#define TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__Shift(v)      (((v) << TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__Pos) & TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__Msk) /*!< Shift value 'v' into vs2_test_stress2 and mask 'v' to fit it into vs2_test_stress2 field */

/** TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__GET() gets BIST_VS2_FE12.VS2_TEST_STRESS2's current value.
 *
 * When reading from BIST_VS2_FE12.VS2_TEST_STRESS2, this is recommended to use.
 *
 * @return current value of BIST_VS2_FE12.VS2_TEST_STRESS2
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS2_FE12__GET();
    reg = (reg & TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__EXTRACT() extracts BIST_VS2_FE12.VS2_TEST_STRESS2.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS2_FE12.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS2_FE12
 * @return current value of BIST_VS2_FE12.VS2_TEST_STRESS2
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS2__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS2_FE12.VS2_TEST_STRESS1 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS2_FE12.VS2_TEST_STRESS1:

    voltage sense 2 - test mode vsadc measurement @ 01h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__Pos           0                                                                      /*!< Right-most bit position of vs2_test_stress1 in TESTSTAT.BIST_VS2_FE12 */
#define TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__Pos)        /*!< Mask for vs2_test_stress1 in TESTSTAT.BIST_VS2_FE12 */
#define TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__Shift(v)      (((v) << TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__Pos) & TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__Msk) /*!< Shift value 'v' into vs2_test_stress1 and mask 'v' to fit it into vs2_test_stress1 field */

/** TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__GET() gets BIST_VS2_FE12.VS2_TEST_STRESS1's current value.
 *
 * When reading from BIST_VS2_FE12.VS2_TEST_STRESS1, this is recommended to use.
 *
 * @return current value of BIST_VS2_FE12.VS2_TEST_STRESS1
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS2_FE12__GET();
    reg = (reg & TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__EXTRACT() extracts BIST_VS2_FE12.VS2_TEST_STRESS1.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS2_FE12.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS2_FE12
 * @return current value of BIST_VS2_FE12.VS2_TEST_STRESS1
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE12__VS2_TEST_STRESS1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS2_FE34 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS2_FE34__ADDRESS returns the address of member BIST_VS2_FE34.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS2_FE34
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS2_FE34__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS2_FE34)));
}

/** TESTSTAT_BIST_VS2_FE34__GET() gets BIST_VS2_FE34's current value.
 *
 * When reading from BIST_VS2_FE34, this is mandatory to use.
 *
 * @return current value of BIST_VS2_FE34
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE34__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS2_FE34__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_VS2_FE34.VS2_TEST_STRESS4 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS2_FE34.VS2_TEST_STRESS4:

    voltage sense 2 - test mode vsadc measurement @ 08h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__Pos           16                                                                     /*!< Right-most bit position of vs2_test_stress4 in TESTSTAT.BIST_VS2_FE34 */
#define TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__Pos)        /*!< Mask for vs2_test_stress4 in TESTSTAT.BIST_VS2_FE34 */
#define TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__Shift(v)      (((v) << TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__Pos) & TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__Msk) /*!< Shift value 'v' into vs2_test_stress4 and mask 'v' to fit it into vs2_test_stress4 field */

/** TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__GET() gets BIST_VS2_FE34.VS2_TEST_STRESS4's current value.
 *
 * When reading from BIST_VS2_FE34.VS2_TEST_STRESS4, this is recommended to use.
 *
 * @return current value of BIST_VS2_FE34.VS2_TEST_STRESS4
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS2_FE34__GET();
    reg = (reg & TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__EXTRACT() extracts BIST_VS2_FE34.VS2_TEST_STRESS4.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS2_FE34.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS2_FE34
 * @return current value of BIST_VS2_FE34.VS2_TEST_STRESS4
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS4__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS2_FE34.VS2_TEST_STRESS3 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS2_FE34.VS2_TEST_STRESS3:

    voltage sense 2 - test mode vsadc measurement @ 04h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__Pos           0                                                                      /*!< Right-most bit position of vs2_test_stress3 in TESTSTAT.BIST_VS2_FE34 */
#define TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__Pos)        /*!< Mask for vs2_test_stress3 in TESTSTAT.BIST_VS2_FE34 */
#define TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__Shift(v)      (((v) << TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__Pos) & TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__Msk) /*!< Shift value 'v' into vs2_test_stress3 and mask 'v' to fit it into vs2_test_stress3 field */

/** TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__GET() gets BIST_VS2_FE34.VS2_TEST_STRESS3's current value.
 *
 * When reading from BIST_VS2_FE34.VS2_TEST_STRESS3, this is recommended to use.
 *
 * @return current value of BIST_VS2_FE34.VS2_TEST_STRESS3
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS2_FE34__GET();
    reg = (reg & TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__EXTRACT() extracts BIST_VS2_FE34.VS2_TEST_STRESS3.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS2_FE34.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS2_FE34
 * @return current value of BIST_VS2_FE34.VS2_TEST_STRESS3
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE34__VS2_TEST_STRESS3__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     BIST_VS2_FE56 member of TESTSTAT_t                     */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_VS2_FE56__ADDRESS returns the address of member BIST_VS2_FE56.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_VS2_FE56
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_VS2_FE56__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_VS2_FE56)));
}

/** TESTSTAT_BIST_VS2_FE56__GET() gets BIST_VS2_FE56's current value.
 *
 * When reading from BIST_VS2_FE56, this is mandatory to use.
 *
 * @return current value of BIST_VS2_FE56
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE56__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_VS2_FE56__ADDRESS());
}

/* ---------------- TESTSTAT.BIST_VS2_FE56.VS2_TEST_STRESS6 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS2_FE56.VS2_TEST_STRESS6:

    voltage sense 2 - test mode vsadc measurement @ 20h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__Pos           16                                                                     /*!< Right-most bit position of vs2_test_stress6 in TESTSTAT.BIST_VS2_FE56 */
#define TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__Pos)        /*!< Mask for vs2_test_stress6 in TESTSTAT.BIST_VS2_FE56 */
#define TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__Shift(v)      (((v) << TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__Pos) & TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__Msk) /*!< Shift value 'v' into vs2_test_stress6 and mask 'v' to fit it into vs2_test_stress6 field */

/** TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__GET() gets BIST_VS2_FE56.VS2_TEST_STRESS6's current value.
 *
 * When reading from BIST_VS2_FE56.VS2_TEST_STRESS6, this is recommended to use.
 *
 * @return current value of BIST_VS2_FE56.VS2_TEST_STRESS6
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS2_FE56__GET();
    reg = (reg & TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__EXTRACT() extracts BIST_VS2_FE56.VS2_TEST_STRESS6.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS2_FE56.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS2_FE56
 * @return current value of BIST_VS2_FE56.VS2_TEST_STRESS6
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS6__Pos);
    return (uint32_t)reg;
}

/* ---------------- TESTSTAT.BIST_VS2_FE56.VS2_TEST_STRESS5 ---------------- */

/**
<pre>
  TESTSTAT.BIST_VS2_FE56.VS2_TEST_STRESS5:

    voltage sense 2 - test mode vsadc measurement @ 10h vs_fe_dac  code

</pre> */

#define TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__Pos           0                                                                      /*!< Right-most bit position of vs2_test_stress5 in TESTSTAT.BIST_VS2_FE56 */
#define TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__Msk           (0x0000FFFFUL << TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__Pos)        /*!< Mask for vs2_test_stress5 in TESTSTAT.BIST_VS2_FE56 */
#define TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__Shift(v)      (((v) << TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__Pos) & TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__Msk) /*!< Shift value 'v' into vs2_test_stress5 and mask 'v' to fit it into vs2_test_stress5 field */

/** TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__GET() gets BIST_VS2_FE56.VS2_TEST_STRESS5's current value.
 *
 * When reading from BIST_VS2_FE56.VS2_TEST_STRESS5, this is recommended to use.
 *
 * @return current value of BIST_VS2_FE56.VS2_TEST_STRESS5
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_VS2_FE56__GET();
    reg = (reg & TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__EXTRACT() extracts BIST_VS2_FE56.VS2_TEST_STRESS5.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_VS2_FE56.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_VS2_FE56
 * @return current value of BIST_VS2_FE56.VS2_TEST_STRESS5
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__Msk);
    reg = (reg >> TESTSTAT_BIST_VS2_FE56__VS2_TEST_STRESS5__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      BIST_CMPLT member of TESTSTAT_t                      */
/* -------------------------------------------------------------------------- */

/** __TESTSTAT_BIST_CMPLT__ADDRESS returns the address of member BIST_CMPLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BIST_CMPLT
 */
__TESTSTAT_INLINE uint32_t* __TESTSTAT_BIST_CMPLT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TESTSTAT_BASE_PTR() + (uint32_t)(offsetof(TESTSTAT_t, BIST_CMPLT)));
}

/** TESTSTAT_BIST_CMPLT__GET() gets BIST_CMPLT's current value.
 *
 * When reading from BIST_CMPLT, this is mandatory to use.
 *
 * @return current value of BIST_CMPLT
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_CMPLT__GET(void)
{
    return HAL_GET32(__TESTSTAT_BIST_CMPLT__ADDRESS());
}

/* ------------------- TESTSTAT.BIST_CMPLT.BIST_COMPLETE ------------------- */

/**
<pre>
  TESTSTAT.BIST_CMPLT.BIST_COMPLETE:

    Analog BIST complete when bit high
    <start table>
    [0] lo_clk_20mhz_trim_complete
    [1] lo_clk_trim_complete
    [2] is_test_comp_complete
    [3] is_test_dnl_complete
    [4] is_test_gain_complete
    [5] is_test_offs_complete
    [6] ts_test_tsadc_dnl_complete
    [7] ts_test_tsadc_gain_complete
    [8] ts_test_tsadc_offs_complete
    [9] ts_test_tsidac_dnl_complete
    [10] vs_test_dnl_complete
    [11] vs_test_gain_complete
    [12] vs_test_offs_complete
    [13] vs_test_stress_complete
    <end table>

</pre> */

#define TESTSTAT_BIST_CMPLT__BIST_COMPLETE__Pos                 0                                                                      /*!< Right-most bit position of bist_complete in TESTSTAT.BIST_CMPLT */
#define TESTSTAT_BIST_CMPLT__BIST_COMPLETE__Msk                 (0x00003FFFUL << TESTSTAT_BIST_CMPLT__BIST_COMPLETE__Pos)              /*!< Mask for bist_complete in TESTSTAT.BIST_CMPLT */
#define TESTSTAT_BIST_CMPLT__BIST_COMPLETE__Shift(v)            (((v) << TESTSTAT_BIST_CMPLT__BIST_COMPLETE__Pos) & TESTSTAT_BIST_CMPLT__BIST_COMPLETE__Msk) /*!< Shift value 'v' into bist_complete and mask 'v' to fit it into bist_complete field */

/** TESTSTAT_BIST_CMPLT__BIST_COMPLETE__GET() gets BIST_CMPLT.BIST_COMPLETE's current value.
 *
 * When reading from BIST_CMPLT.BIST_COMPLETE, this is recommended to use.
 *
 * @return current value of BIST_CMPLT.BIST_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_CMPLT__BIST_COMPLETE__GET(void)
{
    uint32_t reg = TESTSTAT_BIST_CMPLT__GET();
    reg = (reg & TESTSTAT_BIST_CMPLT__BIST_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_CMPLT__BIST_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** TESTSTAT_BIST_CMPLT__BIST_COMPLETE__EXTRACT() extracts BIST_CMPLT.BIST_COMPLETE.
 *
 * This is recommended to use when extracting more than one bitfield from TESTSTAT.BIST_CMPLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TESTSTAT.BIST_CMPLT
 * @return current value of BIST_CMPLT.BIST_COMPLETE
 */
__TESTSTAT_INLINE uint32_t TESTSTAT_BIST_CMPLT__BIST_COMPLETE__EXTRACT(uint32_t reg)
{
    reg = (reg & TESTSTAT_BIST_CMPLT__BIST_COMPLETE__Msk);
    reg = (reg >> TESTSTAT_BIST_CMPLT__BIST_COMPLETE__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group teststat block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_TESTSTAT_H_ */
