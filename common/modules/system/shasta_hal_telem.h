/**
 * @file     shasta_hal_telem.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_TELEM_H_
#define _SHASTA_HAL_TELEM_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup telem
 * @{
 */

#if defined ( __CC_ARM )
#define __TELEM_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __TELEM_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __TELEM_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __TELEM_INLINE  static inline
#endif

/** register file of the telem block.
 */
typedef struct _TELEM_s
{
    volatile        uint32_t        TLM_CFG1                    ; /*!< (@0x00000000) Duty cycle telemetry low pass filter coefficient index.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter. <start table> ...(more) */
    volatile        uint32_t        TLM_CFG2                    ; /*!< (@0x00000004) Input voltage telemetry low pass filter coefficient index.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter. <start tabl...(more) */
    volatile        uint32_t        TLM_DUTY_FSW                ; /*!< (@0x00000008) Low pass filtered duty cycle telemetry updated at Fswitch rate PMBus command computed as follows: <start table> "READ_DUTY_CYCLE(U8.2) = 400 * tlm_duty_fsw[...(more) */
    volatile        uint32_t        TLM_FREQ                    ; /*!< (@0x0000000C) Switching frequency telemetry inlcuding possible adjustment due to synchronization with external SYNC signal. PMBus command computed as follows: <start tabl...(more) */
    volatile        uint32_t        TLM_IIN_LPF                 ; /*!< (@0x00000010) Low pass filtered input current telemetry updated at Fswitch rate. PMBus command computed as follows: <start table> "if ( tlm_iin_lpf[12] )" "    READ_IIN(U...(more) */
    volatile        uint32_t        TLM_IIN_EST                 ; /*!< (@0x00000014) Unfiltered result of estimated input current computation based on Iout, Vout, Vin and Duty Cycle values. LSB = 7.8125mA, Range = 0.0 to 63.9922A */
    volatile        uint32_t        TLM_VOUT_DIV_VIN            ; /*!< (@0x00000018) Unfiltered result of equation (Vout / Vin) computed during input current estimation. LSB = 2^-12 V/V, Range = 0.0 to 0.9998 V/V */
    volatile        uint32_t        TLM_IOUT_FS                 ; /*!< (@0x0000001C) Unfiltered, cycle averged output current updated at Fswitch rate. LSB = 62.5mA, Range = -256 to +255.9375A */
    volatile        uint32_t        TLM_IOUT_FSW                ; /*!< (@0x00000020) Low pas filtered output current telemetry updated at Fswitch rate PMBus command computed as follows: <start table> "READ_IOUT(S9.2) = tlm_iout_fsw[12:2]" <e...(more) */
    volatile        uint32_t        TLM_VIN_FORCE               ; /*!< (@0x00000024) Forced Vin input value.  Selected as source for Vin by tlm_vin_src_sel.  Can be used by FW to bypass the HW based Vin computation. LSB = 62.5mV, Range = 0.0...(more) */
    volatile        uint32_t        TLM_VI_CNVRT_FACT           ; /*!< (@0x00000028) Conversion factor for computing Vin from the measured VS ADC output.  It consists of 3 components: scaling for the Vrect resistor divider, scaling for the t...(more) */
    volatile        uint32_t        TLM_VIN_LPF                 ; /*!< (@0x0000002C) Low pass filtered input voltage telemetry. PMBus command computed as follows: <start table> "READ_VIN(U7.2) = tlm_vin_lpf[10:2]" <end table> LSB = 62.5mV, R...(more) */
    volatile        uint32_t        TLM_VO_CNVRT_FACT           ; /*!< (@0x00000030) Conversion factor for computing Vout from the measured VS ADC output.  It consists of 2 components: scaling for the Vout resistor divider and shifting the b...(more) */
    volatile        uint32_t        TLM_VOUT_FS                 ; /*!< (@0x00000034) Output voltage (Vout) telemetry at the sample clock rate (50MHz). Note: This field is in VS ADC code format (i.e., the voltage at the VSEN pin after the sen...(more) */
    volatile        uint32_t        TLM_VOUT_FSW                ; /*!< (@0x00000038) Low pass filtered output voltage (Vout) telemetry updated at the Fswitch clock rate. Note: This field is in VS ADC code format (i.e., the voltage at the VSE...(more) */
    volatile        uint32_t        TLM_TRNS_SCALE_LP           ; /*!< (@0x0000003C) Ratio of Vrect to Vin.  For Half-Bridge equal to Nturn_sec / (2 * Nturn_pri), otherwise equal to Nturn_sec / Nturn_pri. Computed from PMBus as follows: <sta...(more) */
    volatile        uint32_t        TLM_VRECT_SCALE_LOOP        ; /*!< (@0x00000040) Vrect sense resitor scale value. Computed from PMBus as follows: <start table> "exp = $signed(MFR_VRECT_SCALE[15:11]), exp=-10, -11, -12 supported" "tlm_vre...(more) */
    volatile        uint32_t        TLM_VOUT_SCALE_LOOP         ; /*!< (@0x00000044) Vout sense resitor scale value Computed from PMBus as follows: <start table> "tlm_vout_scale_loop(U0.16) = VOUT_SCALE_LOOP(U0.16)" <end table> LSB = 2^-16, ...(more) */
    volatile        uint32_t        TLM_HILO_SEL                ; /*!< (@0x00000048) Input select for Hi/Lo watermark detector A <start table_with_header> [1:0] "Input" "[1:0]" "Input" 0 "Vin" "2" "Iin" 1 "Vout" "3" "Iout" <end table> */
    volatile        uint32_t        TLM_HILO_CLRA               ; /*!< (@0x0000004C) Clear for Hi/Lo watermark detector A. Write first to 1 then to 0 to clear detector. */
    volatile        uint32_t        TLM_HILO_CLRB               ; /*!< (@0x00000050) Clear for Hi/Lo watermark detector B.  Write first to 1 then to 0 to clear detector. */
    volatile        uint32_t        TLM_HILO_OUTA               ; /*!< (@0x00000054) High watermark detector A output.  Format depends on input selected by tlm_hilo_mark_A_sel. <start table_with_header> Input Format Vin "Unsigned, LSB = 62.5...(more) */
    volatile        uint32_t        TLM_HILO_OUTB               ; /*!< (@0x00000058) High watermark detector B output.  Format depends on input selected by tlm_hilo_mark_B_sel. <start table_with_header> Input Format Vin "Unsigned, LSB = 62.5...(more) */
} TELEM_t;


/** enumeration of implemented telem blocks
 */
typedef enum _telem_idx_e
{
    TELEM0 = 0u,    //!< TELEM0
    TELEM1 = 1u     //!< TELEM1
} telem_idx_t;

#define TELEM_BASE (0x70003400u)                                                          /*!< telem base address */
#define TELEM_STRIDE (0x00000400u)                                                         

/** __TELEM_BASE_PTR returns the base address of the peripheral.
 *
 * @param idp index of peripheral
 * @return base address of peripheral's instance
 */
__TELEM_INLINE uint32_t* __TELEM_BASE_PTR(telem_idx_t idp)
{
    return (uint32_t*)(TELEM_BASE + (uint32_t)((uint32_t)idp * TELEM_STRIDE));
}


/* -------------------------------------------------------------------------- */
/*                         TLM_CFG1 member of TELEM_t                         */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_CFG1__ADDRESS returns the address of member TLM_CFG1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_CFG1
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_CFG1__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_CFG1)));
}

/** TELEM_TLM_CFG1__SET() sets TLM_CFG1 to given value.
 *
 * When writing to TLM_CFG1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_CFG1
 */
__TELEM_INLINE void TELEM_TLM_CFG1__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_CFG1__ADDRESS(idp), value);
}

/** TELEM_TLM_CFG1__GET() gets TLM_CFG1's current value.
 *
 * When reading from TLM_CFG1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG1
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_CFG1__ADDRESS(idp));
}

/* --------------------- TELEM.TLM_CFG1.TLM_VIN_SRC_SEL --------------------- */

/**
<pre>
  TELEM.TLM_CFG1.TLM_VIN_SRC_SEL:

    Input voltage telemetry source select.
    <start table_with_header>
    [2:0] Source Description
    0 "VRSEN" "Secondary Vrect sense, <b>vrs_init</b> prior to startup."
    1 "BVSEN_BVRSEN" "Secondary Vrect sense, <b>vrs_init</b> prior to startup."
    2 "Loop 0 Vout" "Select on Loop 1 when Loop 1 Vin provided by Loop 0 Vout (e.g., post-Buck)."
    3 "TS ADC Vin" "Non-pulsed/primary Vin sense via telemetry ADC."
    4 "tlm_vin_force" "Forced Vin via FW (e.g., FW override of HW computation)."
    5 "VRSEN" "Secondary Vrect sense, <b>0V</b> prior to startup. Select on Loop 1 when sharing Loop 0 Vrect sense."
    6 "VRSEN" "Non-pulsed/primary Vin sense"
    7 "BVSEN_BVRSEN" "Non-pulsed/primary Vin sense"
    <end table>

</pre> */

#define TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Pos                    28                                                                     /*!< Right-most bit position of tlm_vin_src_sel in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Msk                    (0x00000007UL << TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Pos)                 /*!< Mask for tlm_vin_src_sel in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Shift(v)               (((v) << TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Pos) & TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Msk) /*!< Shift value 'v' into tlm_vin_src_sel and mask 'v' to fit it into tlm_vin_src_sel field */

/** TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__SET() sets TLM_CFG1.TLM_VIN_SRC_SEL to given value.
 *
 * When writing to TLM_CFG1.TLM_VIN_SRC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG1.TLM_VIN_SRC_SEL
 */
__TELEM_INLINE void TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG1__SET(idp, reg);
}

/** TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__GET() gets TLM_CFG1.TLM_VIN_SRC_SEL's current value.
 *
 * When reading from TLM_CFG1.TLM_VIN_SRC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG1.TLM_VIN_SRC_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__MODIFY() modifies TLM_CFG1.TLM_VIN_SRC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @param bf_value new value for TLM_CFG1.TLM_VIN_SRC_SEL
 * @return new value of TELEM.TLM_CFG1
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__EXTRACT() extracts TLM_CFG1.TLM_VIN_SRC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @return current value of TLM_CFG1.TLM_VIN_SRC_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_VIN_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TELEM.TLM_CFG1.TLM_KFP_IOUT ---------------------- */

/**
<pre>
  TELEM.TLM_CFG1.TLM_KFP_IOUT:

    Output current telemetry low pass filter coefficient index.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter.
    <start table>
    "kfp_exp = tlm_kfp_iout[5:2]"
    "kfp_man = 4 + tlm_kfp_iout[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(KHz) = [kfp / (1 - kfp)] * Fswitch(KHz) / 2*pi;"
    <end table>

</pre> */

#define TELEM_TLM_CFG1__TLM_KFP_IOUT__Pos                       22                                                                     /*!< Right-most bit position of tlm_kfp_iout in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_KFP_IOUT__Msk                       (0x0000003FUL << TELEM_TLM_CFG1__TLM_KFP_IOUT__Pos)                    /*!< Mask for tlm_kfp_iout in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_KFP_IOUT__Shift(v)                  (((v) << TELEM_TLM_CFG1__TLM_KFP_IOUT__Pos) & TELEM_TLM_CFG1__TLM_KFP_IOUT__Msk) /*!< Shift value 'v' into tlm_kfp_iout and mask 'v' to fit it into tlm_kfp_iout field */

/** TELEM_TLM_CFG1__TLM_KFP_IOUT__SET() sets TLM_CFG1.TLM_KFP_IOUT to given value.
 *
 * When writing to TLM_CFG1.TLM_KFP_IOUT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG1.TLM_KFP_IOUT
 */
__TELEM_INLINE void TELEM_TLM_CFG1__TLM_KFP_IOUT__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG1__TLM_KFP_IOUT__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_KFP_IOUT__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG1__SET(idp, reg);
}

/** TELEM_TLM_CFG1__TLM_KFP_IOUT__GET() gets TLM_CFG1.TLM_KFP_IOUT's current value.
 *
 * When reading from TLM_CFG1.TLM_KFP_IOUT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG1.TLM_KFP_IOUT
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_KFP_IOUT__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & TELEM_TLM_CFG1__TLM_KFP_IOUT__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_KFP_IOUT__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG1__TLM_KFP_IOUT__MODIFY() modifies TLM_CFG1.TLM_KFP_IOUT.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @param bf_value new value for TLM_CFG1.TLM_KFP_IOUT
 * @return new value of TELEM.TLM_CFG1
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_KFP_IOUT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG1__TLM_KFP_IOUT__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_KFP_IOUT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG1__TLM_KFP_IOUT__EXTRACT() extracts TLM_CFG1.TLM_KFP_IOUT.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @return current value of TLM_CFG1.TLM_KFP_IOUT
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_KFP_IOUT__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG1__TLM_KFP_IOUT__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_KFP_IOUT__Pos);
    return (uint32_t)reg;
}

/* -------------------- TELEM.TLM_CFG1.TLM_IOUT_SRC_SEL -------------------- */

/**
<pre>
  TELEM.TLM_CFG1.TLM_IOUT_SRC_SEL:

    Output current telemetry source select.
    <start table>
    0 "measured on ISEN input"
    1 "measured on BISEN input"
    2-3 "sum of ISEN and BISEN inputs (dual phase)"
    <end table>

</pre> */

#define TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Pos                   20                                                                     /*!< Right-most bit position of tlm_iout_src_sel in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Msk                   (0x00000003UL << TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Pos)                /*!< Mask for tlm_iout_src_sel in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Shift(v)              (((v) << TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Pos) & TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Msk) /*!< Shift value 'v' into tlm_iout_src_sel and mask 'v' to fit it into tlm_iout_src_sel field */

/** TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__SET() sets TLM_CFG1.TLM_IOUT_SRC_SEL to given value.
 *
 * When writing to TLM_CFG1.TLM_IOUT_SRC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG1.TLM_IOUT_SRC_SEL
 */
__TELEM_INLINE void TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG1__SET(idp, reg);
}

/** TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__GET() gets TLM_CFG1.TLM_IOUT_SRC_SEL's current value.
 *
 * When reading from TLM_CFG1.TLM_IOUT_SRC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG1.TLM_IOUT_SRC_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__MODIFY() modifies TLM_CFG1.TLM_IOUT_SRC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @param bf_value new value for TLM_CFG1.TLM_IOUT_SRC_SEL
 * @return new value of TELEM.TLM_CFG1
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__EXTRACT() extracts TLM_CFG1.TLM_IOUT_SRC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @return current value of TLM_CFG1.TLM_IOUT_SRC_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_IOUT_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TELEM.TLM_CFG1.TLM_KFP_IIN ----------------------- */

/**
<pre>
  TELEM.TLM_CFG1.TLM_KFP_IIN:

    Input current telemetry low pass filter coefficient index.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter.
    <start table>
    "kfp_exp = tlm_kfp_iin[5:2]"
    "kfp_man = 4 + tlm_kfp_iin[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(KHz) = [kfp / (1 - kfp)] * Fswitch(KHz) / 2*pi;"
    <end table>

</pre> */

#define TELEM_TLM_CFG1__TLM_KFP_IIN__Pos                        14                                                                     /*!< Right-most bit position of tlm_kfp_iin in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_KFP_IIN__Msk                        (0x0000003FUL << TELEM_TLM_CFG1__TLM_KFP_IIN__Pos)                     /*!< Mask for tlm_kfp_iin in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_KFP_IIN__Shift(v)                   (((v) << TELEM_TLM_CFG1__TLM_KFP_IIN__Pos) & TELEM_TLM_CFG1__TLM_KFP_IIN__Msk) /*!< Shift value 'v' into tlm_kfp_iin and mask 'v' to fit it into tlm_kfp_iin field */

/** TELEM_TLM_CFG1__TLM_KFP_IIN__SET() sets TLM_CFG1.TLM_KFP_IIN to given value.
 *
 * When writing to TLM_CFG1.TLM_KFP_IIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG1.TLM_KFP_IIN
 */
__TELEM_INLINE void TELEM_TLM_CFG1__TLM_KFP_IIN__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG1__TLM_KFP_IIN__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_KFP_IIN__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG1__SET(idp, reg);
}

/** TELEM_TLM_CFG1__TLM_KFP_IIN__GET() gets TLM_CFG1.TLM_KFP_IIN's current value.
 *
 * When reading from TLM_CFG1.TLM_KFP_IIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG1.TLM_KFP_IIN
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_KFP_IIN__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & TELEM_TLM_CFG1__TLM_KFP_IIN__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_KFP_IIN__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG1__TLM_KFP_IIN__MODIFY() modifies TLM_CFG1.TLM_KFP_IIN.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @param bf_value new value for TLM_CFG1.TLM_KFP_IIN
 * @return new value of TELEM.TLM_CFG1
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_KFP_IIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG1__TLM_KFP_IIN__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_KFP_IIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG1__TLM_KFP_IIN__EXTRACT() extracts TLM_CFG1.TLM_KFP_IIN.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @return current value of TLM_CFG1.TLM_KFP_IIN
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_KFP_IIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG1__TLM_KFP_IIN__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_KFP_IIN__Pos);
    return (uint32_t)reg;
}

/* --------------------- TELEM.TLM_CFG1.TLM_IIN_SRC_SEL --------------------- */

/**
<pre>
  TELEM.TLM_CFG1.TLM_IIN_SRC_SEL:

    Input current telemetry source select.
    <start table>
    00 "measured on ISEN input"
    01 "measured on BISEN input"
    1x "estimated input curent"
    <end table>

</pre> */

#define TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Pos                    12                                                                     /*!< Right-most bit position of tlm_iin_src_sel in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Msk                    (0x00000003UL << TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Pos)                 /*!< Mask for tlm_iin_src_sel in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Shift(v)               (((v) << TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Pos) & TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Msk) /*!< Shift value 'v' into tlm_iin_src_sel and mask 'v' to fit it into tlm_iin_src_sel field */

/** TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__SET() sets TLM_CFG1.TLM_IIN_SRC_SEL to given value.
 *
 * When writing to TLM_CFG1.TLM_IIN_SRC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG1.TLM_IIN_SRC_SEL
 */
__TELEM_INLINE void TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG1__SET(idp, reg);
}

/** TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__GET() gets TLM_CFG1.TLM_IIN_SRC_SEL's current value.
 *
 * When reading from TLM_CFG1.TLM_IIN_SRC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG1.TLM_IIN_SRC_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__MODIFY() modifies TLM_CFG1.TLM_IIN_SRC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @param bf_value new value for TLM_CFG1.TLM_IIN_SRC_SEL
 * @return new value of TELEM.TLM_CFG1
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__EXTRACT() extracts TLM_CFG1.TLM_IIN_SRC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @return current value of TLM_CFG1.TLM_IIN_SRC_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_IIN_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------- TELEM.TLM_CFG1.TLM_IIN_EST_ALPHA -------------------- */

/**
<pre>
  TELEM.TLM_CFG1.TLM_IIN_EST_ALPHA:

    Input current estimate alpha coefficient.  Defines the relative contributions of Vout/Vin and Duty Cycle in the computation of the input current estimate.
    <start table>
    "Iin_est = Iout * [(1-alpha)*Vout/Vin + alpha*Duty*tlm_transformer_scale_loop]"
    "where, tlm_transformer_scale_loop represents the Vrect/Vin ratio and is defined below"
    <end table>
    LSB = 0.015625, Range = 0.0 to 0.984375

</pre> */

#define TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Pos                  6                                                                      /*!< Right-most bit position of tlm_iin_est_alpha in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Msk                  (0x0000003FUL << TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Pos)               /*!< Mask for tlm_iin_est_alpha in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Shift(v)             (((v) << TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Pos) & TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Msk) /*!< Shift value 'v' into tlm_iin_est_alpha and mask 'v' to fit it into tlm_iin_est_alpha field */

/** TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__SET() sets TLM_CFG1.TLM_IIN_EST_ALPHA to given value.
 *
 * When writing to TLM_CFG1.TLM_IIN_EST_ALPHA, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG1.TLM_IIN_EST_ALPHA
 */
__TELEM_INLINE void TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG1__SET(idp, reg);
}

/** TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__GET() gets TLM_CFG1.TLM_IIN_EST_ALPHA's current value.
 *
 * When reading from TLM_CFG1.TLM_IIN_EST_ALPHA, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG1.TLM_IIN_EST_ALPHA
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__MODIFY() modifies TLM_CFG1.TLM_IIN_EST_ALPHA.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @param bf_value new value for TLM_CFG1.TLM_IIN_EST_ALPHA
 * @return new value of TELEM.TLM_CFG1
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__EXTRACT() extracts TLM_CFG1.TLM_IIN_EST_ALPHA.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @return current value of TLM_CFG1.TLM_IIN_EST_ALPHA
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_IIN_EST_ALPHA__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TELEM.TLM_CFG1.TLM_KFP_DUTY ---------------------- */

/**
<pre>
  TELEM.TLM_CFG1.TLM_KFP_DUTY:

    Duty cycle telemetry low pass filter coefficient index.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter.
    <start table>
    "kfp_exp = tlm_kfp_duty[5:2]"
    "kfp_man = 4 + +M2:M29tlm_kfp_duty[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(KHz) = [kfp / (1 - kfp)] * Fswitch(KHz) / 2*pi;"
    <end table>

</pre> */

#define TELEM_TLM_CFG1__TLM_KFP_DUTY__Pos                       0                                                                      /*!< Right-most bit position of tlm_kfp_duty in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_KFP_DUTY__Msk                       (0x0000003FUL << TELEM_TLM_CFG1__TLM_KFP_DUTY__Pos)                    /*!< Mask for tlm_kfp_duty in TELEM.TLM_CFG1 */
#define TELEM_TLM_CFG1__TLM_KFP_DUTY__Shift(v)                  (((v) << TELEM_TLM_CFG1__TLM_KFP_DUTY__Pos) & TELEM_TLM_CFG1__TLM_KFP_DUTY__Msk) /*!< Shift value 'v' into tlm_kfp_duty and mask 'v' to fit it into tlm_kfp_duty field */

/** TELEM_TLM_CFG1__TLM_KFP_DUTY__SET() sets TLM_CFG1.TLM_KFP_DUTY to given value.
 *
 * When writing to TLM_CFG1.TLM_KFP_DUTY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG1.TLM_KFP_DUTY
 */
__TELEM_INLINE void TELEM_TLM_CFG1__TLM_KFP_DUTY__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG1__TLM_KFP_DUTY__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_KFP_DUTY__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG1__SET(idp, reg);
}

/** TELEM_TLM_CFG1__TLM_KFP_DUTY__GET() gets TLM_CFG1.TLM_KFP_DUTY's current value.
 *
 * When reading from TLM_CFG1.TLM_KFP_DUTY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG1.TLM_KFP_DUTY
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_KFP_DUTY__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG1__GET(idp);
    reg = (reg & TELEM_TLM_CFG1__TLM_KFP_DUTY__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_KFP_DUTY__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG1__TLM_KFP_DUTY__MODIFY() modifies TLM_CFG1.TLM_KFP_DUTY.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @param bf_value new value for TLM_CFG1.TLM_KFP_DUTY
 * @return new value of TELEM.TLM_CFG1
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_KFP_DUTY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG1__TLM_KFP_DUTY__Msk);
    reg = (reg | (TELEM_TLM_CFG1__TLM_KFP_DUTY__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG1__TLM_KFP_DUTY__EXTRACT() extracts TLM_CFG1.TLM_KFP_DUTY.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG1
 * @return current value of TLM_CFG1.TLM_KFP_DUTY
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG1__TLM_KFP_DUTY__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG1__TLM_KFP_DUTY__Msk);
    reg = (reg >> TELEM_TLM_CFG1__TLM_KFP_DUTY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TLM_CFG2 member of TELEM_t                         */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_CFG2__ADDRESS returns the address of member TLM_CFG2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_CFG2
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_CFG2__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_CFG2)));
}

/** TELEM_TLM_CFG2__SET() sets TLM_CFG2 to given value.
 *
 * When writing to TLM_CFG2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_CFG2
 */
__TELEM_INLINE void TELEM_TLM_CFG2__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_CFG2__ADDRESS(idp), value);
}

/** TELEM_TLM_CFG2__GET() gets TLM_CFG2's current value.
 *
 * When reading from TLM_CFG2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG2
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_CFG2__ADDRESS(idp));
}

/* ------------------- TELEM.TLM_CFG2.TLM_VRECT_SR_DIODE ------------------- */

/**
<pre>
  TELEM.TLM_CFG2.TLM_VRECT_SR_DIODE:

    Voltage correction term on Vrect computation when SR FETs are off.  Intended to compensate for 1 or 2 series body diodes.  The user should enter the diode drop as seen at the rectification voltage <b>prior to</b> the sense resistor divider.
    <start table_with_header>
    [2:0] "diode Voltage" [2:0] "diode Voltage"
    0 "480 mV" 4 "0 mV"
    1 "640 mV" 5 "1280 mV"
    2 "800 mV" 6 "1600 mV"
    3 "960 mV" 7 "1920 mV"
    <end table>

</pre> */

#define TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Pos                 25                                                                     /*!< Right-most bit position of tlm_vrect_sr_diode in TELEM.TLM_CFG2 */
#define TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Msk                 (0x00000007UL << TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Pos)              /*!< Mask for tlm_vrect_sr_diode in TELEM.TLM_CFG2 */
#define TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Shift(v)            (((v) << TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Pos) & TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Msk) /*!< Shift value 'v' into tlm_vrect_sr_diode and mask 'v' to fit it into tlm_vrect_sr_diode field */

/** TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__SET() sets TLM_CFG2.TLM_VRECT_SR_DIODE to given value.
 *
 * When writing to TLM_CFG2.TLM_VRECT_SR_DIODE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG2.TLM_VRECT_SR_DIODE
 */
__TELEM_INLINE void TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG2__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Msk);
    reg = (reg | (TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG2__SET(idp, reg);
}

/** TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__GET() gets TLM_CFG2.TLM_VRECT_SR_DIODE's current value.
 *
 * When reading from TLM_CFG2.TLM_VRECT_SR_DIODE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG2.TLM_VRECT_SR_DIODE
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG2__GET(idp);
    reg = (reg & TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Msk);
    reg = (reg >> TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__MODIFY() modifies TLM_CFG2.TLM_VRECT_SR_DIODE.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG2
 * @param bf_value new value for TLM_CFG2.TLM_VRECT_SR_DIODE
 * @return new value of TELEM.TLM_CFG2
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Msk);
    reg = (reg | (TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__EXTRACT() extracts TLM_CFG2.TLM_VRECT_SR_DIODE.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG2
 * @return current value of TLM_CFG2.TLM_VRECT_SR_DIODE
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Msk);
    reg = (reg >> TELEM_TLM_CFG2__TLM_VRECT_SR_DIODE__Pos);
    return (uint32_t)reg;
}

/* -------------------- TELEM.TLM_CFG2.TLM_VRECT_VOFFSET -------------------- */

/**
<pre>
  TELEM.TLM_CFG2.TLM_VRECT_VOFFSET:

    Voltage offset correction term applied to the rectification voltage (Vrect) computation.  This term is added to the Vrect value from the ADC.  The user should enter the effective offset as seen at the VRSEN input <b>after</b> the Vrect sense resistor divider.
    LSB = 1.25mV, -80 to +78.75mV

</pre> */

#define TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Pos                  18                                                                     /*!< Right-most bit position of tlm_vrect_voffset in TELEM.TLM_CFG2 */
#define TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Msk                  (0x0000007FUL << TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Pos)               /*!< Mask for tlm_vrect_voffset in TELEM.TLM_CFG2 */
#define TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Shift(v)             (((v) << TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Pos) & TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Msk) /*!< Shift value 'v' into tlm_vrect_voffset and mask 'v' to fit it into tlm_vrect_voffset field */

/** TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__SET() sets TLM_CFG2.TLM_VRECT_VOFFSET to given value.
 *
 * When writing to TLM_CFG2.TLM_VRECT_VOFFSET, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG2.TLM_VRECT_VOFFSET
 */
__TELEM_INLINE void TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG2__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Msk);
    reg = (reg | (TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG2__SET(idp, reg);
}

/** TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__GET() gets TLM_CFG2.TLM_VRECT_VOFFSET's current value.
 *
 * When reading from TLM_CFG2.TLM_VRECT_VOFFSET, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG2.TLM_VRECT_VOFFSET
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG2__GET(idp);
    reg = (reg & TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Msk);
    reg = (reg >> TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__MODIFY() modifies TLM_CFG2.TLM_VRECT_VOFFSET.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG2
 * @param bf_value new value for TLM_CFG2.TLM_VRECT_VOFFSET
 * @return new value of TELEM.TLM_CFG2
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Msk);
    reg = (reg | (TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__EXTRACT() extracts TLM_CFG2.TLM_VRECT_VOFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG2
 * @return current value of TLM_CFG2.TLM_VRECT_VOFFSET
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Msk);
    reg = (reg >> TELEM_TLM_CFG2__TLM_VRECT_VOFFSET__Pos);
    return (uint32_t)reg;
}

/* --------------------- TELEM.TLM_CFG2.TLM_VRECT_RCORR --------------------- */

/**
<pre>
  TELEM.TLM_CFG2.TLM_VRECT_RCORR:

    Resistive correction term applied to rectification voltage (Vrect) computation.  This term is multipled by the output current and added to the Vrect value from the ADC.  The user should enter the effective resistance as seen at the VRSEN input <b>after</b> the Vrect sense resistor divider.
    LSB = 3.90625mOhm, Range = 0.0 to 246.09375mOhm

</pre> */

#define TELEM_TLM_CFG2__TLM_VRECT_RCORR__Pos                    12                                                                     /*!< Right-most bit position of tlm_vrect_rcorr in TELEM.TLM_CFG2 */
#define TELEM_TLM_CFG2__TLM_VRECT_RCORR__Msk                    (0x0000003FUL << TELEM_TLM_CFG2__TLM_VRECT_RCORR__Pos)                 /*!< Mask for tlm_vrect_rcorr in TELEM.TLM_CFG2 */
#define TELEM_TLM_CFG2__TLM_VRECT_RCORR__Shift(v)               (((v) << TELEM_TLM_CFG2__TLM_VRECT_RCORR__Pos) & TELEM_TLM_CFG2__TLM_VRECT_RCORR__Msk) /*!< Shift value 'v' into tlm_vrect_rcorr and mask 'v' to fit it into tlm_vrect_rcorr field */

/** TELEM_TLM_CFG2__TLM_VRECT_RCORR__SET() sets TLM_CFG2.TLM_VRECT_RCORR to given value.
 *
 * When writing to TLM_CFG2.TLM_VRECT_RCORR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG2.TLM_VRECT_RCORR
 */
__TELEM_INLINE void TELEM_TLM_CFG2__TLM_VRECT_RCORR__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG2__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG2__TLM_VRECT_RCORR__Msk);
    reg = (reg | (TELEM_TLM_CFG2__TLM_VRECT_RCORR__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG2__SET(idp, reg);
}

/** TELEM_TLM_CFG2__TLM_VRECT_RCORR__GET() gets TLM_CFG2.TLM_VRECT_RCORR's current value.
 *
 * When reading from TLM_CFG2.TLM_VRECT_RCORR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG2.TLM_VRECT_RCORR
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_VRECT_RCORR__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG2__GET(idp);
    reg = (reg & TELEM_TLM_CFG2__TLM_VRECT_RCORR__Msk);
    reg = (reg >> TELEM_TLM_CFG2__TLM_VRECT_RCORR__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG2__TLM_VRECT_RCORR__MODIFY() modifies TLM_CFG2.TLM_VRECT_RCORR.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG2
 * @param bf_value new value for TLM_CFG2.TLM_VRECT_RCORR
 * @return new value of TELEM.TLM_CFG2
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_VRECT_RCORR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG2__TLM_VRECT_RCORR__Msk);
    reg = (reg | (TELEM_TLM_CFG2__TLM_VRECT_RCORR__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG2__TLM_VRECT_RCORR__EXTRACT() extracts TLM_CFG2.TLM_VRECT_RCORR.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG2
 * @return current value of TLM_CFG2.TLM_VRECT_RCORR
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_VRECT_RCORR__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG2__TLM_VRECT_RCORR__Msk);
    reg = (reg >> TELEM_TLM_CFG2__TLM_VRECT_RCORR__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TELEM.TLM_CFG2.TLM_KFP_VOUT ---------------------- */

/**
<pre>
  TELEM.TLM_CFG2.TLM_KFP_VOUT:

    Output voltage telemetry low pass filter coefficient index.  Note that exp settings greater than 7 are clamped to 7.  Set to 63 to bypass filter.
    <start table>
    "kfp_exp = tlm_kfp_vout[5:2]"
    "kfp_man = 4 + tlm_kfp_vout[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(KHz) = [kfp / (1 - kfp)] * Fswitch(KHz) / 2*pi;"
    <end table>

</pre> */

#define TELEM_TLM_CFG2__TLM_KFP_VOUT__Pos                       6                                                                      /*!< Right-most bit position of tlm_kfp_vout in TELEM.TLM_CFG2 */
#define TELEM_TLM_CFG2__TLM_KFP_VOUT__Msk                       (0x0000003FUL << TELEM_TLM_CFG2__TLM_KFP_VOUT__Pos)                    /*!< Mask for tlm_kfp_vout in TELEM.TLM_CFG2 */
#define TELEM_TLM_CFG2__TLM_KFP_VOUT__Shift(v)                  (((v) << TELEM_TLM_CFG2__TLM_KFP_VOUT__Pos) & TELEM_TLM_CFG2__TLM_KFP_VOUT__Msk) /*!< Shift value 'v' into tlm_kfp_vout and mask 'v' to fit it into tlm_kfp_vout field */

/** TELEM_TLM_CFG2__TLM_KFP_VOUT__SET() sets TLM_CFG2.TLM_KFP_VOUT to given value.
 *
 * When writing to TLM_CFG2.TLM_KFP_VOUT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG2.TLM_KFP_VOUT
 */
__TELEM_INLINE void TELEM_TLM_CFG2__TLM_KFP_VOUT__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG2__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG2__TLM_KFP_VOUT__Msk);
    reg = (reg | (TELEM_TLM_CFG2__TLM_KFP_VOUT__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG2__SET(idp, reg);
}

/** TELEM_TLM_CFG2__TLM_KFP_VOUT__GET() gets TLM_CFG2.TLM_KFP_VOUT's current value.
 *
 * When reading from TLM_CFG2.TLM_KFP_VOUT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG2.TLM_KFP_VOUT
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_KFP_VOUT__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG2__GET(idp);
    reg = (reg & TELEM_TLM_CFG2__TLM_KFP_VOUT__Msk);
    reg = (reg >> TELEM_TLM_CFG2__TLM_KFP_VOUT__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG2__TLM_KFP_VOUT__MODIFY() modifies TLM_CFG2.TLM_KFP_VOUT.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG2
 * @param bf_value new value for TLM_CFG2.TLM_KFP_VOUT
 * @return new value of TELEM.TLM_CFG2
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_KFP_VOUT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG2__TLM_KFP_VOUT__Msk);
    reg = (reg | (TELEM_TLM_CFG2__TLM_KFP_VOUT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG2__TLM_KFP_VOUT__EXTRACT() extracts TLM_CFG2.TLM_KFP_VOUT.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG2
 * @return current value of TLM_CFG2.TLM_KFP_VOUT
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_KFP_VOUT__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG2__TLM_KFP_VOUT__Msk);
    reg = (reg >> TELEM_TLM_CFG2__TLM_KFP_VOUT__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TELEM.TLM_CFG2.TLM_KFP_VIN ----------------------- */

/**
<pre>
  TELEM.TLM_CFG2.TLM_KFP_VIN:

    Input voltage telemetry low pass filter coefficient index.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter.
    <start table>
    "kfp_exp = tlm_kfp_vin[5:2]"
    "kfp_man = 4 + tlm_kfp_vin[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(KHz) = [kfp / (1 - kfp)] * Fswitch(KHz) / 2*pi;"
    <end table>

</pre> */

#define TELEM_TLM_CFG2__TLM_KFP_VIN__Pos                        0                                                                      /*!< Right-most bit position of tlm_kfp_vin in TELEM.TLM_CFG2 */
#define TELEM_TLM_CFG2__TLM_KFP_VIN__Msk                        (0x0000003FUL << TELEM_TLM_CFG2__TLM_KFP_VIN__Pos)                     /*!< Mask for tlm_kfp_vin in TELEM.TLM_CFG2 */
#define TELEM_TLM_CFG2__TLM_KFP_VIN__Shift(v)                   (((v) << TELEM_TLM_CFG2__TLM_KFP_VIN__Pos) & TELEM_TLM_CFG2__TLM_KFP_VIN__Msk) /*!< Shift value 'v' into tlm_kfp_vin and mask 'v' to fit it into tlm_kfp_vin field */

/** TELEM_TLM_CFG2__TLM_KFP_VIN__SET() sets TLM_CFG2.TLM_KFP_VIN to given value.
 *
 * When writing to TLM_CFG2.TLM_KFP_VIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_CFG2.TLM_KFP_VIN
 */
__TELEM_INLINE void TELEM_TLM_CFG2__TLM_KFP_VIN__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_CFG2__GET(idp);
    reg = (reg & ~TELEM_TLM_CFG2__TLM_KFP_VIN__Msk);
    reg = (reg | (TELEM_TLM_CFG2__TLM_KFP_VIN__Shift((uint32_t)bf_value)));
    TELEM_TLM_CFG2__SET(idp, reg);
}

/** TELEM_TLM_CFG2__TLM_KFP_VIN__GET() gets TLM_CFG2.TLM_KFP_VIN's current value.
 *
 * When reading from TLM_CFG2.TLM_KFP_VIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_CFG2.TLM_KFP_VIN
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_KFP_VIN__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_CFG2__GET(idp);
    reg = (reg & TELEM_TLM_CFG2__TLM_KFP_VIN__Msk);
    reg = (reg >> TELEM_TLM_CFG2__TLM_KFP_VIN__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_CFG2__TLM_KFP_VIN__MODIFY() modifies TLM_CFG2.TLM_KFP_VIN.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_CFG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_CFG2
 * @param bf_value new value for TLM_CFG2.TLM_KFP_VIN
 * @return new value of TELEM.TLM_CFG2
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_KFP_VIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_CFG2__TLM_KFP_VIN__Msk);
    reg = (reg | (TELEM_TLM_CFG2__TLM_KFP_VIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_CFG2__TLM_KFP_VIN__EXTRACT() extracts TLM_CFG2.TLM_KFP_VIN.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_CFG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_CFG2
 * @return current value of TLM_CFG2.TLM_KFP_VIN
 */
__TELEM_INLINE uint32_t TELEM_TLM_CFG2__TLM_KFP_VIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_CFG2__TLM_KFP_VIN__Msk);
    reg = (reg >> TELEM_TLM_CFG2__TLM_KFP_VIN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TLM_DUTY_FSW member of TELEM_t                       */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_DUTY_FSW__ADDRESS returns the address of member TLM_DUTY_FSW.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_DUTY_FSW
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_DUTY_FSW__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_DUTY_FSW)));
}

/** TELEM_TLM_DUTY_FSW__GET() gets TLM_DUTY_FSW's current value.
 *
 * When reading from TLM_DUTY_FSW, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_DUTY_FSW
 */
__TELEM_INLINE uint32_t TELEM_TLM_DUTY_FSW__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_DUTY_FSW__ADDRESS(idp));
}

/* -------------------- TELEM.TLM_DUTY_FSW.TLM_DUTY_FSW -------------------- */

/**
<pre>
  TELEM.TLM_DUTY_FSW.TLM_DUTY_FSW:

    Low pass filtered duty cycle telemetry updated at Fswitch rate
    PMBus command computed as follows:
    <start table>
    "READ_DUTY_CYCLE(U8.2) = 400 * tlm_duty_fsw[15:0] / 2^16"
    <end table>
    LSB = 2^-16, Range = 0.0 to 0.99998

</pre> */

#define TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__Pos                   0                                                                      /*!< Right-most bit position of tlm_duty_fsw in TELEM.TLM_DUTY_FSW */
#define TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__Msk                   (0x0000FFFFUL << TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__Pos)                /*!< Mask for tlm_duty_fsw in TELEM.TLM_DUTY_FSW */
#define TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__Shift(v)              (((v) << TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__Pos) & TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__Msk) /*!< Shift value 'v' into tlm_duty_fsw and mask 'v' to fit it into tlm_duty_fsw field */

/** TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__GET() gets TLM_DUTY_FSW.TLM_DUTY_FSW's current value.
 *
 * When reading from TLM_DUTY_FSW.TLM_DUTY_FSW, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_DUTY_FSW.TLM_DUTY_FSW
 */
__TELEM_INLINE uint32_t TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_DUTY_FSW__GET(idp);
    reg = (reg & TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__Msk);
    reg = (reg >> TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__EXTRACT() extracts TLM_DUTY_FSW.TLM_DUTY_FSW.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_DUTY_FSW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_DUTY_FSW
 * @return current value of TLM_DUTY_FSW.TLM_DUTY_FSW
 */
__TELEM_INLINE uint32_t TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__Msk);
    reg = (reg >> TELEM_TLM_DUTY_FSW__TLM_DUTY_FSW__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TLM_FREQ member of TELEM_t                         */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_FREQ__ADDRESS returns the address of member TLM_FREQ.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_FREQ
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_FREQ__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_FREQ)));
}

/** TELEM_TLM_FREQ__GET() gets TLM_FREQ's current value.
 *
 * When reading from TLM_FREQ, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_FREQ
 */
__TELEM_INLINE uint32_t TELEM_TLM_FREQ__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_FREQ__ADDRESS(idp));
}

/* ------------------------ TELEM.TLM_FREQ.TLM_FREQ ------------------------ */

/**
<pre>
  TELEM.TLM_FREQ.TLM_FREQ:

    Switching frequency telemetry inlcuding possible adjustment due to synchronization with external SYNC signal.
    PMBus command computed as follows:
    <start table>
    "if (tlm_freq[10])"
    "    READ_FREQUENCY[15:0] = {5'd1, 1'd0, tlm_freq[10:1]}"
    "else"
    "    READ_FREQUENCY[15:0] = {5'd0, 1'd0, tlm_freq[9:0]}"
    <end table>
    LSB = 1kHz, Range = 0 to 2047kHz

</pre> */

#define TELEM_TLM_FREQ__TLM_FREQ__Pos                           0                                                                      /*!< Right-most bit position of tlm_freq in TELEM.TLM_FREQ */
#define TELEM_TLM_FREQ__TLM_FREQ__Msk                           (0x000007FFUL << TELEM_TLM_FREQ__TLM_FREQ__Pos)                        /*!< Mask for tlm_freq in TELEM.TLM_FREQ */
#define TELEM_TLM_FREQ__TLM_FREQ__Shift(v)                      (((v) << TELEM_TLM_FREQ__TLM_FREQ__Pos) & TELEM_TLM_FREQ__TLM_FREQ__Msk) /*!< Shift value 'v' into tlm_freq and mask 'v' to fit it into tlm_freq field */

/** TELEM_TLM_FREQ__TLM_FREQ__GET() gets TLM_FREQ.TLM_FREQ's current value.
 *
 * When reading from TLM_FREQ.TLM_FREQ, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_FREQ.TLM_FREQ
 */
__TELEM_INLINE uint32_t TELEM_TLM_FREQ__TLM_FREQ__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_FREQ__GET(idp);
    reg = (reg & TELEM_TLM_FREQ__TLM_FREQ__Msk);
    reg = (reg >> TELEM_TLM_FREQ__TLM_FREQ__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_FREQ__TLM_FREQ__EXTRACT() extracts TLM_FREQ.TLM_FREQ.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_FREQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_FREQ
 * @return current value of TLM_FREQ.TLM_FREQ
 */
__TELEM_INLINE uint32_t TELEM_TLM_FREQ__TLM_FREQ__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_FREQ__TLM_FREQ__Msk);
    reg = (reg >> TELEM_TLM_FREQ__TLM_FREQ__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TLM_IIN_LPF member of TELEM_t                       */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_IIN_LPF__ADDRESS returns the address of member TLM_IIN_LPF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_IIN_LPF
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_IIN_LPF__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_IIN_LPF)));
}

/** TELEM_TLM_IIN_LPF__GET() gets TLM_IIN_LPF's current value.
 *
 * When reading from TLM_IIN_LPF, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_IIN_LPF
 */
__TELEM_INLINE uint32_t TELEM_TLM_IIN_LPF__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_IIN_LPF__ADDRESS(idp));
}

/* --------------------- TELEM.TLM_IIN_LPF.TLM_IIN_LPF --------------------- */

/**
<pre>
  TELEM.TLM_IIN_LPF.TLM_IIN_LPF:

    Low pass filtered input current telemetry updated at Fswitch rate.
    PMBus command computed as follows:
    <start table>
    "if ( tlm_iin_lpf[12] )"
    "    READ_IIN(U6.4) = {5'b11100, 1'b0, tlm_iin_lpd[12:3]}"
    "else if ( tlm_iin_lpf[11] )"
    "    READ_IIN(U5.5) = {5'b11011, 1'b0, tlm_iin_lpd[11:2]}"
    "else if  (tlm_iin_lpf[10] )"
    "    READ_IIN(U4.6) = {5'b11010, 1'b0, tlm_iin_lpd[10:1]}"
    "else"
    "    READ_IIN(U3.7) = {5'b11001, 1'b0, tlm_iin_lpd[9:0]}"
    <end table>
    LSB = 7.8125mA, Range = 0.0 to 63.9922A

</pre> */

#define TELEM_TLM_IIN_LPF__TLM_IIN_LPF__Pos                     0                                                                      /*!< Right-most bit position of tlm_iin_lpf in TELEM.TLM_IIN_LPF */
#define TELEM_TLM_IIN_LPF__TLM_IIN_LPF__Msk                     (0x00001FFFUL << TELEM_TLM_IIN_LPF__TLM_IIN_LPF__Pos)                  /*!< Mask for tlm_iin_lpf in TELEM.TLM_IIN_LPF */
#define TELEM_TLM_IIN_LPF__TLM_IIN_LPF__Shift(v)                (((v) << TELEM_TLM_IIN_LPF__TLM_IIN_LPF__Pos) & TELEM_TLM_IIN_LPF__TLM_IIN_LPF__Msk) /*!< Shift value 'v' into tlm_iin_lpf and mask 'v' to fit it into tlm_iin_lpf field */

/** TELEM_TLM_IIN_LPF__TLM_IIN_LPF__GET() gets TLM_IIN_LPF.TLM_IIN_LPF's current value.
 *
 * When reading from TLM_IIN_LPF.TLM_IIN_LPF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_IIN_LPF.TLM_IIN_LPF
 */
__TELEM_INLINE uint32_t TELEM_TLM_IIN_LPF__TLM_IIN_LPF__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_IIN_LPF__GET(idp);
    reg = (reg & TELEM_TLM_IIN_LPF__TLM_IIN_LPF__Msk);
    reg = (reg >> TELEM_TLM_IIN_LPF__TLM_IIN_LPF__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_IIN_LPF__TLM_IIN_LPF__EXTRACT() extracts TLM_IIN_LPF.TLM_IIN_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_IIN_LPF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_IIN_LPF
 * @return current value of TLM_IIN_LPF.TLM_IIN_LPF
 */
__TELEM_INLINE uint32_t TELEM_TLM_IIN_LPF__TLM_IIN_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_IIN_LPF__TLM_IIN_LPF__Msk);
    reg = (reg >> TELEM_TLM_IIN_LPF__TLM_IIN_LPF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TLM_IIN_EST member of TELEM_t                       */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_IIN_EST__ADDRESS returns the address of member TLM_IIN_EST.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_IIN_EST
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_IIN_EST__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_IIN_EST)));
}

/** TELEM_TLM_IIN_EST__GET() gets TLM_IIN_EST's current value.
 *
 * When reading from TLM_IIN_EST, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_IIN_EST
 */
__TELEM_INLINE uint32_t TELEM_TLM_IIN_EST__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_IIN_EST__ADDRESS(idp));
}

/* --------------------- TELEM.TLM_IIN_EST.TLM_IIN_EST --------------------- */

/**
<pre>
  TELEM.TLM_IIN_EST.TLM_IIN_EST:

    Unfiltered result of estimated input current computation based on Iout, Vout, Vin and Duty Cycle values.
    LSB = 7.8125mA, Range = 0.0 to 63.9922A

</pre> */

#define TELEM_TLM_IIN_EST__TLM_IIN_EST__Pos                     0                                                                      /*!< Right-most bit position of tlm_iin_est in TELEM.TLM_IIN_EST */
#define TELEM_TLM_IIN_EST__TLM_IIN_EST__Msk                     (0x00001FFFUL << TELEM_TLM_IIN_EST__TLM_IIN_EST__Pos)                  /*!< Mask for tlm_iin_est in TELEM.TLM_IIN_EST */
#define TELEM_TLM_IIN_EST__TLM_IIN_EST__Shift(v)                (((v) << TELEM_TLM_IIN_EST__TLM_IIN_EST__Pos) & TELEM_TLM_IIN_EST__TLM_IIN_EST__Msk) /*!< Shift value 'v' into tlm_iin_est and mask 'v' to fit it into tlm_iin_est field */

/** TELEM_TLM_IIN_EST__TLM_IIN_EST__GET() gets TLM_IIN_EST.TLM_IIN_EST's current value.
 *
 * When reading from TLM_IIN_EST.TLM_IIN_EST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_IIN_EST.TLM_IIN_EST
 */
__TELEM_INLINE uint32_t TELEM_TLM_IIN_EST__TLM_IIN_EST__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_IIN_EST__GET(idp);
    reg = (reg & TELEM_TLM_IIN_EST__TLM_IIN_EST__Msk);
    reg = (reg >> TELEM_TLM_IIN_EST__TLM_IIN_EST__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_IIN_EST__TLM_IIN_EST__EXTRACT() extracts TLM_IIN_EST.TLM_IIN_EST.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_IIN_EST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_IIN_EST
 * @return current value of TLM_IIN_EST.TLM_IIN_EST
 */
__TELEM_INLINE uint32_t TELEM_TLM_IIN_EST__TLM_IIN_EST__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_IIN_EST__TLM_IIN_EST__Msk);
    reg = (reg >> TELEM_TLM_IIN_EST__TLM_IIN_EST__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     TLM_VOUT_DIV_VIN member of TELEM_t                     */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_VOUT_DIV_VIN__ADDRESS returns the address of member TLM_VOUT_DIV_VIN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_VOUT_DIV_VIN
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_VOUT_DIV_VIN__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_VOUT_DIV_VIN)));
}

/** TELEM_TLM_VOUT_DIV_VIN__GET() gets TLM_VOUT_DIV_VIN's current value.
 *
 * When reading from TLM_VOUT_DIV_VIN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VOUT_DIV_VIN
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_DIV_VIN__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_VOUT_DIV_VIN__ADDRESS(idp));
}

/* ---------------- TELEM.TLM_VOUT_DIV_VIN.TLM_VOUT_DIV_VIN ---------------- */

/**
<pre>
  TELEM.TLM_VOUT_DIV_VIN.TLM_VOUT_DIV_VIN:

    Unfiltered result of equation (Vout / Vin) computed during input current estimation.
    LSB = 2^-12 V/V, Range = 0.0 to 0.9998 V/V

</pre> */

#define TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__Pos           0                                                                      /*!< Right-most bit position of tlm_vout_div_vin in TELEM.TLM_VOUT_DIV_VIN */
#define TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__Msk           (0x00000FFFUL << TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__Pos)        /*!< Mask for tlm_vout_div_vin in TELEM.TLM_VOUT_DIV_VIN */
#define TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__Shift(v)      (((v) << TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__Pos) & TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__Msk) /*!< Shift value 'v' into tlm_vout_div_vin and mask 'v' to fit it into tlm_vout_div_vin field */

/** TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__GET() gets TLM_VOUT_DIV_VIN.TLM_VOUT_DIV_VIN's current value.
 *
 * When reading from TLM_VOUT_DIV_VIN.TLM_VOUT_DIV_VIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VOUT_DIV_VIN.TLM_VOUT_DIV_VIN
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_VOUT_DIV_VIN__GET(idp);
    reg = (reg & TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__Msk);
    reg = (reg >> TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__EXTRACT() extracts TLM_VOUT_DIV_VIN.TLM_VOUT_DIV_VIN.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_VOUT_DIV_VIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_VOUT_DIV_VIN
 * @return current value of TLM_VOUT_DIV_VIN.TLM_VOUT_DIV_VIN
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__Msk);
    reg = (reg >> TELEM_TLM_VOUT_DIV_VIN__TLM_VOUT_DIV_VIN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TLM_IOUT_FS member of TELEM_t                       */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_IOUT_FS__ADDRESS returns the address of member TLM_IOUT_FS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_IOUT_FS
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_IOUT_FS__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_IOUT_FS)));
}

/** TELEM_TLM_IOUT_FS__GET() gets TLM_IOUT_FS's current value.
 *
 * When reading from TLM_IOUT_FS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_IOUT_FS
 */
__TELEM_INLINE uint32_t TELEM_TLM_IOUT_FS__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_IOUT_FS__ADDRESS(idp));
}

/* --------------------- TELEM.TLM_IOUT_FS.TLM_IOUT_FS --------------------- */

/**
<pre>
  TELEM.TLM_IOUT_FS.TLM_IOUT_FS:

    Unfiltered, cycle averged output current updated at Fswitch rate.
    LSB = 62.5mA, Range = -256 to +255.9375A

</pre> */

#define TELEM_TLM_IOUT_FS__TLM_IOUT_FS__Pos                     0                                                                      /*!< Right-most bit position of tlm_iout_fs in TELEM.TLM_IOUT_FS */
#define TELEM_TLM_IOUT_FS__TLM_IOUT_FS__Msk                     (0x00001FFFUL << TELEM_TLM_IOUT_FS__TLM_IOUT_FS__Pos)                  /*!< Mask for tlm_iout_fs in TELEM.TLM_IOUT_FS */
#define TELEM_TLM_IOUT_FS__TLM_IOUT_FS__Shift(v)                (((v) << TELEM_TLM_IOUT_FS__TLM_IOUT_FS__Pos) & TELEM_TLM_IOUT_FS__TLM_IOUT_FS__Msk) /*!< Shift value 'v' into tlm_iout_fs and mask 'v' to fit it into tlm_iout_fs field */

/** TELEM_TLM_IOUT_FS__TLM_IOUT_FS__GET() gets TLM_IOUT_FS.TLM_IOUT_FS's current value.
 *
 * When reading from TLM_IOUT_FS.TLM_IOUT_FS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_IOUT_FS.TLM_IOUT_FS
 */
__TELEM_INLINE uint32_t TELEM_TLM_IOUT_FS__TLM_IOUT_FS__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_IOUT_FS__GET(idp);
    reg = (reg & TELEM_TLM_IOUT_FS__TLM_IOUT_FS__Msk);
    reg = (reg >> TELEM_TLM_IOUT_FS__TLM_IOUT_FS__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_IOUT_FS__TLM_IOUT_FS__EXTRACT() extracts TLM_IOUT_FS.TLM_IOUT_FS.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_IOUT_FS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_IOUT_FS
 * @return current value of TLM_IOUT_FS.TLM_IOUT_FS
 */
__TELEM_INLINE uint32_t TELEM_TLM_IOUT_FS__TLM_IOUT_FS__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_IOUT_FS__TLM_IOUT_FS__Msk);
    reg = (reg >> TELEM_TLM_IOUT_FS__TLM_IOUT_FS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TLM_IOUT_FSW member of TELEM_t                       */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_IOUT_FSW__ADDRESS returns the address of member TLM_IOUT_FSW.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_IOUT_FSW
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_IOUT_FSW__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_IOUT_FSW)));
}

/** TELEM_TLM_IOUT_FSW__GET() gets TLM_IOUT_FSW's current value.
 *
 * When reading from TLM_IOUT_FSW, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_IOUT_FSW
 */
__TELEM_INLINE uint32_t TELEM_TLM_IOUT_FSW__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_IOUT_FSW__ADDRESS(idp));
}

/* -------------------- TELEM.TLM_IOUT_FSW.TLM_IOUT_FSW -------------------- */

/**
<pre>
  TELEM.TLM_IOUT_FSW.TLM_IOUT_FSW:

    Low pas filtered output current telemetry updated at Fswitch rate
    PMBus command computed as follows:
    <start table>
    "READ_IOUT(S9.2) = tlm_iout_fsw[12:2]"
    <end table>
    LSB = 62.5mA, Range = -256 to +255.9375A

</pre> */

#define TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__Pos                   0                                                                      /*!< Right-most bit position of tlm_iout_fsw in TELEM.TLM_IOUT_FSW */
#define TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__Msk                   (0x00001FFFUL << TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__Pos)                /*!< Mask for tlm_iout_fsw in TELEM.TLM_IOUT_FSW */
#define TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__Shift(v)              (((v) << TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__Pos) & TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__Msk) /*!< Shift value 'v' into tlm_iout_fsw and mask 'v' to fit it into tlm_iout_fsw field */

/** TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__GET() gets TLM_IOUT_FSW.TLM_IOUT_FSW's current value.
 *
 * When reading from TLM_IOUT_FSW.TLM_IOUT_FSW, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_IOUT_FSW.TLM_IOUT_FSW
 */
__TELEM_INLINE uint32_t TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_IOUT_FSW__GET(idp);
    reg = (reg & TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__Msk);
    reg = (reg >> TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__EXTRACT() extracts TLM_IOUT_FSW.TLM_IOUT_FSW.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_IOUT_FSW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_IOUT_FSW
 * @return current value of TLM_IOUT_FSW.TLM_IOUT_FSW
 */
__TELEM_INLINE uint32_t TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__Msk);
    reg = (reg >> TELEM_TLM_IOUT_FSW__TLM_IOUT_FSW__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_VIN_FORCE member of TELEM_t                      */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_VIN_FORCE__ADDRESS returns the address of member TLM_VIN_FORCE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_VIN_FORCE
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_VIN_FORCE__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_VIN_FORCE)));
}

/** TELEM_TLM_VIN_FORCE__SET() sets TLM_VIN_FORCE to given value.
 *
 * When writing to TLM_VIN_FORCE, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_VIN_FORCE
 */
__TELEM_INLINE void TELEM_TLM_VIN_FORCE__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_VIN_FORCE__ADDRESS(idp), value);
}

/** TELEM_TLM_VIN_FORCE__GET() gets TLM_VIN_FORCE's current value.
 *
 * When reading from TLM_VIN_FORCE, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VIN_FORCE
 */
__TELEM_INLINE uint32_t TELEM_TLM_VIN_FORCE__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_VIN_FORCE__ADDRESS(idp));
}

/* ------------------- TELEM.TLM_VIN_FORCE.TLM_VIN_FORCE ------------------- */

/**
<pre>
  TELEM.TLM_VIN_FORCE.TLM_VIN_FORCE:

    Forced Vin input value.  Selected as source for Vin by tlm_vin_src_sel.  Can be used by FW to bypass the HW based Vin computation.
    LSB = 62.5mV, Range = 0.0 to 127.9375V

</pre> */

#define TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Pos                 0                                                                      /*!< Right-most bit position of tlm_vin_force in TELEM.TLM_VIN_FORCE */
#define TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Msk                 (0x000007FFUL << TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Pos)              /*!< Mask for tlm_vin_force in TELEM.TLM_VIN_FORCE */
#define TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Shift(v)            (((v) << TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Pos) & TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Msk) /*!< Shift value 'v' into tlm_vin_force and mask 'v' to fit it into tlm_vin_force field */

/** TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__SET() sets TLM_VIN_FORCE.TLM_VIN_FORCE to given value.
 *
 * When writing to TLM_VIN_FORCE.TLM_VIN_FORCE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_VIN_FORCE.TLM_VIN_FORCE
 */
__TELEM_INLINE void TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_VIN_FORCE__GET(idp);
    reg = (reg & ~TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Msk);
    reg = (reg | (TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Shift((uint32_t)bf_value)));
    TELEM_TLM_VIN_FORCE__SET(idp, reg);
}

/** TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__GET() gets TLM_VIN_FORCE.TLM_VIN_FORCE's current value.
 *
 * When reading from TLM_VIN_FORCE.TLM_VIN_FORCE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VIN_FORCE.TLM_VIN_FORCE
 */
__TELEM_INLINE uint32_t TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_VIN_FORCE__GET(idp);
    reg = (reg & TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Msk);
    reg = (reg >> TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__MODIFY() modifies TLM_VIN_FORCE.TLM_VIN_FORCE.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_VIN_FORCE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_VIN_FORCE
 * @param bf_value new value for TLM_VIN_FORCE.TLM_VIN_FORCE
 * @return new value of TELEM.TLM_VIN_FORCE
 */
__TELEM_INLINE uint32_t TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Msk);
    reg = (reg | (TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__EXTRACT() extracts TLM_VIN_FORCE.TLM_VIN_FORCE.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_VIN_FORCE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_VIN_FORCE
 * @return current value of TLM_VIN_FORCE.TLM_VIN_FORCE
 */
__TELEM_INLINE uint32_t TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Msk);
    reg = (reg >> TELEM_TLM_VIN_FORCE__TLM_VIN_FORCE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    TLM_VI_CNVRT_FACT member of TELEM_t                    */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_VI_CNVRT_FACT__ADDRESS returns the address of member TLM_VI_CNVRT_FACT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_VI_CNVRT_FACT
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_VI_CNVRT_FACT__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_VI_CNVRT_FACT)));
}

/** TELEM_TLM_VI_CNVRT_FACT__SET() sets TLM_VI_CNVRT_FACT to given value.
 *
 * When writing to TLM_VI_CNVRT_FACT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_VI_CNVRT_FACT
 */
__TELEM_INLINE void TELEM_TLM_VI_CNVRT_FACT__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_VI_CNVRT_FACT__ADDRESS(idp), value);
}

/** TELEM_TLM_VI_CNVRT_FACT__GET() gets TLM_VI_CNVRT_FACT's current value.
 *
 * When reading from TLM_VI_CNVRT_FACT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VI_CNVRT_FACT
 */
__TELEM_INLINE uint32_t TELEM_TLM_VI_CNVRT_FACT__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_VI_CNVRT_FACT__ADDRESS(idp));
}

/* ------------- TELEM.TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR ------------- */

/**
<pre>
  TELEM.TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR:

    Conversion factor for computing Vin from the measured VS ADC output.  It consists of 3 components: scaling for the Vrect resistor divider, scaling for the tranformer / topology and shifting the binary point from the ADC representation (1.25mV) to 1V.
    Computed from PMBus commands as follows:
    <start table>
    "exp1 = $signed(MFR_VRECT_SCALE[15:11]), exp=-10, -11, -12 supported"
    "exp2 = $signed(MFR_TRANSFORMER_SCALE[15:11]), exp=-10, -11, -12 supported"
    "prod1(U0.14) = MFR_VRECT_SCALE[9:0] * MFR_TRANSFORMER_SCALE[9:0] / 2^(-14-exp1-exp2)"
    "quot1(U7.8) = 2^22 / prod1(U0.14), clamp to 2^15-1"
    "tlm_vin_convert_factor(U-2.24) = quot1(U7.8) * 82(U-9.16)"
    <end table>
    LSB = 2^-24, Range = 0.0 to 0.2500

</pre> */

#define TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Pos    0                                                                      /*!< Right-most bit position of tlm_vin_convert_factor in TELEM.TLM_VI_CNVRT_FACT */
#define TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Msk    (0x003FFFFFUL << TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Pos) /*!< Mask for tlm_vin_convert_factor in TELEM.TLM_VI_CNVRT_FACT */
#define TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Shift(v) (((v) << TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Pos) & TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Msk) /*!< Shift value 'v' into tlm_vin_convert_factor and mask 'v' to fit it into tlm_vin_convert_factor field */

/** TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__SET() sets TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR to given value.
 *
 * When writing to TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR
 */
__TELEM_INLINE void TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_VI_CNVRT_FACT__GET(idp);
    reg = (reg & ~TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Msk);
    reg = (reg | (TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Shift((uint32_t)bf_value)));
    TELEM_TLM_VI_CNVRT_FACT__SET(idp, reg);
}

/** TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__GET() gets TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR's current value.
 *
 * When reading from TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR
 */
__TELEM_INLINE uint32_t TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_VI_CNVRT_FACT__GET(idp);
    reg = (reg & TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Msk);
    reg = (reg >> TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__MODIFY() modifies TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_VI_CNVRT_FACT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_VI_CNVRT_FACT
 * @param bf_value new value for TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR
 * @return new value of TELEM.TLM_VI_CNVRT_FACT
 */
__TELEM_INLINE uint32_t TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Msk);
    reg = (reg | (TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__EXTRACT() extracts TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_VI_CNVRT_FACT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_VI_CNVRT_FACT
 * @return current value of TLM_VI_CNVRT_FACT.TLM_VIN_CONVERT_FACTOR
 */
__TELEM_INLINE uint32_t TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Msk);
    reg = (reg >> TELEM_TLM_VI_CNVRT_FACT__TLM_VIN_CONVERT_FACTOR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TLM_VIN_LPF member of TELEM_t                       */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_VIN_LPF__ADDRESS returns the address of member TLM_VIN_LPF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_VIN_LPF
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_VIN_LPF__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_VIN_LPF)));
}

/** TELEM_TLM_VIN_LPF__GET() gets TLM_VIN_LPF's current value.
 *
 * When reading from TLM_VIN_LPF, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VIN_LPF
 */
__TELEM_INLINE uint32_t TELEM_TLM_VIN_LPF__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_VIN_LPF__ADDRESS(idp));
}

/* --------------------- TELEM.TLM_VIN_LPF.TLM_VIN_LPF --------------------- */

/**
<pre>
  TELEM.TLM_VIN_LPF.TLM_VIN_LPF:

    Low pass filtered input voltage telemetry.
    PMBus command computed as follows:
    <start table>
    "READ_VIN(U7.2) = tlm_vin_lpf[10:2]"
    <end table>
    LSB = 62.5mV, Range = 0.0 to 127.9375V

</pre> */

#define TELEM_TLM_VIN_LPF__TLM_VIN_LPF__Pos                     0                                                                      /*!< Right-most bit position of tlm_vin_lpf in TELEM.TLM_VIN_LPF */
#define TELEM_TLM_VIN_LPF__TLM_VIN_LPF__Msk                     (0x000007FFUL << TELEM_TLM_VIN_LPF__TLM_VIN_LPF__Pos)                  /*!< Mask for tlm_vin_lpf in TELEM.TLM_VIN_LPF */
#define TELEM_TLM_VIN_LPF__TLM_VIN_LPF__Shift(v)                (((v) << TELEM_TLM_VIN_LPF__TLM_VIN_LPF__Pos) & TELEM_TLM_VIN_LPF__TLM_VIN_LPF__Msk) /*!< Shift value 'v' into tlm_vin_lpf and mask 'v' to fit it into tlm_vin_lpf field */

/** TELEM_TLM_VIN_LPF__TLM_VIN_LPF__GET() gets TLM_VIN_LPF.TLM_VIN_LPF's current value.
 *
 * When reading from TLM_VIN_LPF.TLM_VIN_LPF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VIN_LPF.TLM_VIN_LPF
 */
__TELEM_INLINE uint32_t TELEM_TLM_VIN_LPF__TLM_VIN_LPF__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_VIN_LPF__GET(idp);
    reg = (reg & TELEM_TLM_VIN_LPF__TLM_VIN_LPF__Msk);
    reg = (reg >> TELEM_TLM_VIN_LPF__TLM_VIN_LPF__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_VIN_LPF__TLM_VIN_LPF__EXTRACT() extracts TLM_VIN_LPF.TLM_VIN_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_VIN_LPF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_VIN_LPF
 * @return current value of TLM_VIN_LPF.TLM_VIN_LPF
 */
__TELEM_INLINE uint32_t TELEM_TLM_VIN_LPF__TLM_VIN_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_VIN_LPF__TLM_VIN_LPF__Msk);
    reg = (reg >> TELEM_TLM_VIN_LPF__TLM_VIN_LPF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    TLM_VO_CNVRT_FACT member of TELEM_t                    */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_VO_CNVRT_FACT__ADDRESS returns the address of member TLM_VO_CNVRT_FACT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_VO_CNVRT_FACT
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_VO_CNVRT_FACT__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_VO_CNVRT_FACT)));
}

/** TELEM_TLM_VO_CNVRT_FACT__SET() sets TLM_VO_CNVRT_FACT to given value.
 *
 * When writing to TLM_VO_CNVRT_FACT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_VO_CNVRT_FACT
 */
__TELEM_INLINE void TELEM_TLM_VO_CNVRT_FACT__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_VO_CNVRT_FACT__ADDRESS(idp), value);
}

/** TELEM_TLM_VO_CNVRT_FACT__GET() gets TLM_VO_CNVRT_FACT's current value.
 *
 * When reading from TLM_VO_CNVRT_FACT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VO_CNVRT_FACT
 */
__TELEM_INLINE uint32_t TELEM_TLM_VO_CNVRT_FACT__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_VO_CNVRT_FACT__ADDRESS(idp));
}

/* ------------ TELEM.TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR ------------ */

/**
<pre>
  TELEM.TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR:

    Conversion factor for computing Vout from the measured VS ADC output.  It consists of 2 components: scaling for the Vout resistor divider and shifting the binary point from the ADC representation (1.25mV) to 1V.
    Computed from PMBus commands as follows:
    <start table>
    "Quot1(U6.8) = 2^24 / VOUT_SCALE_LOOP(U0.16), clamp to 2^14-1"
    "tlm_vout_convert_factor(U-3.24) = Quot1(U6.8) * 82(U-9.16)"
    <end table>
    LSB = 2^-24, Range = 0.0 to 0.1250

</pre> */

#define TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Pos   0                                                                      /*!< Right-most bit position of tlm_vout_convert_factor in TELEM.TLM_VO_CNVRT_FACT */
#define TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Msk   (0x001FFFFFUL << TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Pos) /*!< Mask for tlm_vout_convert_factor in TELEM.TLM_VO_CNVRT_FACT */
#define TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Shift(v) (((v) << TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Pos) & TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Msk) /*!< Shift value 'v' into tlm_vout_convert_factor and mask 'v' to fit it into tlm_vout_convert_factor field */

/** TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__SET() sets TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR to given value.
 *
 * When writing to TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR
 */
__TELEM_INLINE void TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_VO_CNVRT_FACT__GET(idp);
    reg = (reg & ~TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Msk);
    reg = (reg | (TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Shift((uint32_t)bf_value)));
    TELEM_TLM_VO_CNVRT_FACT__SET(idp, reg);
}

/** TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__GET() gets TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR's current value.
 *
 * When reading from TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR
 */
__TELEM_INLINE uint32_t TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_VO_CNVRT_FACT__GET(idp);
    reg = (reg & TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Msk);
    reg = (reg >> TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__MODIFY() modifies TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_VO_CNVRT_FACT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_VO_CNVRT_FACT
 * @param bf_value new value for TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR
 * @return new value of TELEM.TLM_VO_CNVRT_FACT
 */
__TELEM_INLINE uint32_t TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Msk);
    reg = (reg | (TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__EXTRACT() extracts TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_VO_CNVRT_FACT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_VO_CNVRT_FACT
 * @return current value of TLM_VO_CNVRT_FACT.TLM_VOUT_CONVERT_FACTOR
 */
__TELEM_INLINE uint32_t TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Msk);
    reg = (reg >> TELEM_TLM_VO_CNVRT_FACT__TLM_VOUT_CONVERT_FACTOR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TLM_VOUT_FS member of TELEM_t                       */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_VOUT_FS__ADDRESS returns the address of member TLM_VOUT_FS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_VOUT_FS
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_VOUT_FS__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_VOUT_FS)));
}

/** TELEM_TLM_VOUT_FS__GET() gets TLM_VOUT_FS's current value.
 *
 * When reading from TLM_VOUT_FS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VOUT_FS
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_FS__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_VOUT_FS__ADDRESS(idp));
}

/* --------------------- TELEM.TLM_VOUT_FS.TLM_VOUT_FS --------------------- */

/**
<pre>
  TELEM.TLM_VOUT_FS.TLM_VOUT_FS:

    Output voltage (Vout) telemetry at the sample clock rate (50MHz).
    Note:
    This field is in VS ADC code format (i.e., the voltage at the VSEN pin after the sense resistor divider) and must be scaled by VOUT_SCALE_LOOP for output referenced voltage.  See tlm_vout_fsw description for scale equation.
    LSB = 1.25mV, Range = 0.0 to 5.11875V

</pre> */

#define TELEM_TLM_VOUT_FS__TLM_VOUT_FS__Pos                     0                                                                      /*!< Right-most bit position of tlm_vout_fs in TELEM.TLM_VOUT_FS */
#define TELEM_TLM_VOUT_FS__TLM_VOUT_FS__Msk                     (0x00000FFFUL << TELEM_TLM_VOUT_FS__TLM_VOUT_FS__Pos)                  /*!< Mask for tlm_vout_fs in TELEM.TLM_VOUT_FS */
#define TELEM_TLM_VOUT_FS__TLM_VOUT_FS__Shift(v)                (((v) << TELEM_TLM_VOUT_FS__TLM_VOUT_FS__Pos) & TELEM_TLM_VOUT_FS__TLM_VOUT_FS__Msk) /*!< Shift value 'v' into tlm_vout_fs and mask 'v' to fit it into tlm_vout_fs field */

/** TELEM_TLM_VOUT_FS__TLM_VOUT_FS__GET() gets TLM_VOUT_FS.TLM_VOUT_FS's current value.
 *
 * When reading from TLM_VOUT_FS.TLM_VOUT_FS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VOUT_FS.TLM_VOUT_FS
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_FS__TLM_VOUT_FS__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_VOUT_FS__GET(idp);
    reg = (reg & TELEM_TLM_VOUT_FS__TLM_VOUT_FS__Msk);
    reg = (reg >> TELEM_TLM_VOUT_FS__TLM_VOUT_FS__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_VOUT_FS__TLM_VOUT_FS__EXTRACT() extracts TLM_VOUT_FS.TLM_VOUT_FS.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_VOUT_FS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_VOUT_FS
 * @return current value of TLM_VOUT_FS.TLM_VOUT_FS
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_FS__TLM_VOUT_FS__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_VOUT_FS__TLM_VOUT_FS__Msk);
    reg = (reg >> TELEM_TLM_VOUT_FS__TLM_VOUT_FS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TLM_VOUT_FSW member of TELEM_t                       */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_VOUT_FSW__ADDRESS returns the address of member TLM_VOUT_FSW.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_VOUT_FSW
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_VOUT_FSW__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_VOUT_FSW)));
}

/** TELEM_TLM_VOUT_FSW__GET() gets TLM_VOUT_FSW's current value.
 *
 * When reading from TLM_VOUT_FSW, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VOUT_FSW
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_FSW__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_VOUT_FSW__ADDRESS(idp));
}

/* -------------------- TELEM.TLM_VOUT_FSW.TLM_VOUT_FSW -------------------- */

/**
<pre>
  TELEM.TLM_VOUT_FSW.TLM_VOUT_FSW:

    Low pass filtered output voltage (Vout) telemetry updated at the Fswitch clock rate.
    Note:
    This field is in VS ADC code format (i.e., the voltage at the VSEN pin after the sense resistor divider) and must be scaled by VOUT_SCALE_LOOP for output referenced voltage.
    PMBus command computed as follows:
    <start table>
    "READ_VOUT(U16-X.X) = (tlm_vout_fsw(U12.3) / 800) * (2^16 / VOUT_SCALE_LOOP(U0.16)) * 2^(X-3)"
    "where, X = negative of VOUT_MODE exponent"
    <end table>
    LSB = 1.25mV, Range = 0.0 to 5.11875V

</pre> */

#define TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__Pos                   0                                                                      /*!< Right-most bit position of tlm_vout_fsw in TELEM.TLM_VOUT_FSW */
#define TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__Msk                   (0x00007FFFUL << TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__Pos)                /*!< Mask for tlm_vout_fsw in TELEM.TLM_VOUT_FSW */
#define TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__Shift(v)              (((v) << TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__Pos) & TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__Msk) /*!< Shift value 'v' into tlm_vout_fsw and mask 'v' to fit it into tlm_vout_fsw field */

/** TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__GET() gets TLM_VOUT_FSW.TLM_VOUT_FSW's current value.
 *
 * When reading from TLM_VOUT_FSW.TLM_VOUT_FSW, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VOUT_FSW.TLM_VOUT_FSW
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_VOUT_FSW__GET(idp);
    reg = (reg & TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__Msk);
    reg = (reg >> TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__EXTRACT() extracts TLM_VOUT_FSW.TLM_VOUT_FSW.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_VOUT_FSW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_VOUT_FSW
 * @return current value of TLM_VOUT_FSW.TLM_VOUT_FSW
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__Msk);
    reg = (reg >> TELEM_TLM_VOUT_FSW__TLM_VOUT_FSW__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    TLM_TRNS_SCALE_LP member of TELEM_t                    */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_TRNS_SCALE_LP__ADDRESS returns the address of member TLM_TRNS_SCALE_LP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_TRNS_SCALE_LP
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_TRNS_SCALE_LP__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_TRNS_SCALE_LP)));
}

/** TELEM_TLM_TRNS_SCALE_LP__SET() sets TLM_TRNS_SCALE_LP to given value.
 *
 * When writing to TLM_TRNS_SCALE_LP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_TRNS_SCALE_LP
 */
__TELEM_INLINE void TELEM_TLM_TRNS_SCALE_LP__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_TRNS_SCALE_LP__ADDRESS(idp), value);
}

/** TELEM_TLM_TRNS_SCALE_LP__GET() gets TLM_TRNS_SCALE_LP's current value.
 *
 * When reading from TLM_TRNS_SCALE_LP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_TRNS_SCALE_LP
 */
__TELEM_INLINE uint32_t TELEM_TLM_TRNS_SCALE_LP__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_TRNS_SCALE_LP__ADDRESS(idp));
}

/* ----------- TELEM.TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP ----------- */

/**
<pre>
  TELEM.TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP:

    Ratio of Vrect to Vin.  For Half-Bridge equal to Nturn_sec / (2 * Nturn_pri), otherwise equal to Nturn_sec / Nturn_pri.
    Computed from PMBus as follows:
    <start table>
    "exp = $signed(MFR_TRANSFORMER_SCALE[15:11]), exp=-10, -11, -12 supported"
    "hb = 1 if half-bridge topology and 0 otherwise"
    "if (hb==0 && exp==-10)"
    "    tlm_vrect_scale_loop[11:0] = {MFR_TRANSFORMER_SCALE[9:0], 00}"
    "else if (hb==0 && exp==-11)"
    "    tlm_vrect_scale_loop[11:0] = {0, MFR_TRANSFORMER_SCALE[9:0], 0}"
    "else if (hb==0 && exp==-12)"
    "    tlm_vrect_scale_loop[11:0] = {00, MFR_TRANSFORMER_SCALE[9:0]}"
    "else if (hb==1 && exp==-10)"
    "    tlm_vrect_scale_loop[11:0] = {0, MFR_TRANSFORMER_SCALE[9:0], 0}"
    "else if (hb==1 && exp==-11)"
    "    tlm_vrect_scale_loop[11:0] = {00, MFR_TRANSFORMER_SCALE[9:0]}"
    "else if (hb==1 && exp==-12)"
    "    tlm_vrect_scale_loop[11:0] = {000, MFR_TRANSFORMER_SCALE[9:1]}"
    <end table>
    LSB = 2^-12, Range = 0.0 to 0.99976

</pre> */

#define TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Pos 0                                                                      /*!< Right-most bit position of tlm_transformer_scale_loop in TELEM.TLM_TRNS_SCALE_LP */
#define TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Msk (0x00000FFFUL << TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Pos) /*!< Mask for tlm_transformer_scale_loop in TELEM.TLM_TRNS_SCALE_LP */
#define TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Shift(v) (((v) << TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Pos) & TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Msk) /*!< Shift value 'v' into tlm_transformer_scale_loop and mask 'v' to fit it into tlm_transformer_scale_loop field */

/** TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__SET() sets TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP to given value.
 *
 * When writing to TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP
 */
__TELEM_INLINE void TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_TRNS_SCALE_LP__GET(idp);
    reg = (reg & ~TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Msk);
    reg = (reg | (TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Shift((uint32_t)bf_value)));
    TELEM_TLM_TRNS_SCALE_LP__SET(idp, reg);
}

/** TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__GET() gets TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP's current value.
 *
 * When reading from TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP
 */
__TELEM_INLINE uint32_t TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_TRNS_SCALE_LP__GET(idp);
    reg = (reg & TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Msk);
    reg = (reg >> TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__MODIFY() modifies TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_TRNS_SCALE_LP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_TRNS_SCALE_LP
 * @param bf_value new value for TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP
 * @return new value of TELEM.TLM_TRNS_SCALE_LP
 */
__TELEM_INLINE uint32_t TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Msk);
    reg = (reg | (TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__EXTRACT() extracts TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_TRNS_SCALE_LP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_TRNS_SCALE_LP
 * @return current value of TLM_TRNS_SCALE_LP.TLM_TRANSFORMER_SCALE_LOOP
 */
__TELEM_INLINE uint32_t TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Msk);
    reg = (reg >> TELEM_TLM_TRNS_SCALE_LP__TLM_TRANSFORMER_SCALE_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   TLM_VRECT_SCALE_LOOP member of TELEM_t                   */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_VRECT_SCALE_LOOP__ADDRESS returns the address of member TLM_VRECT_SCALE_LOOP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_VRECT_SCALE_LOOP
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_VRECT_SCALE_LOOP__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_VRECT_SCALE_LOOP)));
}

/** TELEM_TLM_VRECT_SCALE_LOOP__SET() sets TLM_VRECT_SCALE_LOOP to given value.
 *
 * When writing to TLM_VRECT_SCALE_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_VRECT_SCALE_LOOP
 */
__TELEM_INLINE void TELEM_TLM_VRECT_SCALE_LOOP__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_VRECT_SCALE_LOOP__ADDRESS(idp), value);
}

/** TELEM_TLM_VRECT_SCALE_LOOP__GET() gets TLM_VRECT_SCALE_LOOP's current value.
 *
 * When reading from TLM_VRECT_SCALE_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VRECT_SCALE_LOOP
 */
__TELEM_INLINE uint32_t TELEM_TLM_VRECT_SCALE_LOOP__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_VRECT_SCALE_LOOP__ADDRESS(idp));
}

/* ------------ TELEM.TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP ------------ */

/**
<pre>
  TELEM.TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP:

    Vrect sense resitor scale value.
    Computed from PMBus as follows:
    <start table>
    "exp = $signed(MFR_VRECT_SCALE[15:11]), exp=-10, -11, -12 supported"
    "tlm_vrect_scale_loop[11:0] = MFR_VRECT_SCALE[9:0] << (exp + 12)"
    <end table>
    LSB = 2^-12, Range = 0.0 to 0.99976

</pre> */

#define TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Pos   0                                                                      /*!< Right-most bit position of tlm_vrect_scale_loop in TELEM.TLM_VRECT_SCALE_LOOP */
#define TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Msk   (0x00000FFFUL << TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Pos) /*!< Mask for tlm_vrect_scale_loop in TELEM.TLM_VRECT_SCALE_LOOP */
#define TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Shift(v) (((v) << TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Pos) & TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Msk) /*!< Shift value 'v' into tlm_vrect_scale_loop and mask 'v' to fit it into tlm_vrect_scale_loop field */

/** TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__SET() sets TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP to given value.
 *
 * When writing to TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP
 */
__TELEM_INLINE void TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_VRECT_SCALE_LOOP__GET(idp);
    reg = (reg & ~TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Msk);
    reg = (reg | (TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Shift((uint32_t)bf_value)));
    TELEM_TLM_VRECT_SCALE_LOOP__SET(idp, reg);
}

/** TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__GET() gets TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP's current value.
 *
 * When reading from TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP
 */
__TELEM_INLINE uint32_t TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_VRECT_SCALE_LOOP__GET(idp);
    reg = (reg & TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Msk);
    reg = (reg >> TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__MODIFY() modifies TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_VRECT_SCALE_LOOP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_VRECT_SCALE_LOOP
 * @param bf_value new value for TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP
 * @return new value of TELEM.TLM_VRECT_SCALE_LOOP
 */
__TELEM_INLINE uint32_t TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Msk);
    reg = (reg | (TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__EXTRACT() extracts TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_VRECT_SCALE_LOOP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_VRECT_SCALE_LOOP
 * @return current value of TLM_VRECT_SCALE_LOOP.TLM_VRECT_SCALE_LOOP
 */
__TELEM_INLINE uint32_t TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Msk);
    reg = (reg >> TELEM_TLM_VRECT_SCALE_LOOP__TLM_VRECT_SCALE_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   TLM_VOUT_SCALE_LOOP member of TELEM_t                   */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_VOUT_SCALE_LOOP__ADDRESS returns the address of member TLM_VOUT_SCALE_LOOP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_VOUT_SCALE_LOOP
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_VOUT_SCALE_LOOP__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_VOUT_SCALE_LOOP)));
}

/** TELEM_TLM_VOUT_SCALE_LOOP__SET() sets TLM_VOUT_SCALE_LOOP to given value.
 *
 * When writing to TLM_VOUT_SCALE_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_VOUT_SCALE_LOOP
 */
__TELEM_INLINE void TELEM_TLM_VOUT_SCALE_LOOP__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_VOUT_SCALE_LOOP__ADDRESS(idp), value);
}

/** TELEM_TLM_VOUT_SCALE_LOOP__GET() gets TLM_VOUT_SCALE_LOOP's current value.
 *
 * When reading from TLM_VOUT_SCALE_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VOUT_SCALE_LOOP
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_SCALE_LOOP__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_VOUT_SCALE_LOOP__ADDRESS(idp));
}

/* ------------- TELEM.TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP ------------- */

/**
<pre>
  TELEM.TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP:

    Vout sense resitor scale value
    Computed from PMBus as follows:
    <start table>
    "tlm_vout_scale_loop(U0.16) = VOUT_SCALE_LOOP(U0.16)"
    <end table>
    LSB = 2^-16, Range = 0.0 to 0.9998

</pre> */

#define TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Pos     0                                                                      /*!< Right-most bit position of tlm_vout_scale_loop in TELEM.TLM_VOUT_SCALE_LOOP */
#define TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Msk     (0x0000FFFFUL << TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Pos)  /*!< Mask for tlm_vout_scale_loop in TELEM.TLM_VOUT_SCALE_LOOP */
#define TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Shift(v) (((v) << TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Pos) & TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Msk) /*!< Shift value 'v' into tlm_vout_scale_loop and mask 'v' to fit it into tlm_vout_scale_loop field */

/** TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__SET() sets TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP to given value.
 *
 * When writing to TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP
 */
__TELEM_INLINE void TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_VOUT_SCALE_LOOP__GET(idp);
    reg = (reg & ~TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Msk);
    reg = (reg | (TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Shift((uint32_t)bf_value)));
    TELEM_TLM_VOUT_SCALE_LOOP__SET(idp, reg);
}

/** TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__GET() gets TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP's current value.
 *
 * When reading from TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_VOUT_SCALE_LOOP__GET(idp);
    reg = (reg & TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Msk);
    reg = (reg >> TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__MODIFY() modifies TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_VOUT_SCALE_LOOP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_VOUT_SCALE_LOOP
 * @param bf_value new value for TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP
 * @return new value of TELEM.TLM_VOUT_SCALE_LOOP
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Msk);
    reg = (reg | (TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__EXTRACT() extracts TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_VOUT_SCALE_LOOP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_VOUT_SCALE_LOOP
 * @return current value of TLM_VOUT_SCALE_LOOP.TLM_VOUT_SCALE_LOOP
 */
__TELEM_INLINE uint32_t TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Msk);
    reg = (reg >> TELEM_TLM_VOUT_SCALE_LOOP__TLM_VOUT_SCALE_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TLM_HILO_SEL member of TELEM_t                       */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_HILO_SEL__ADDRESS returns the address of member TLM_HILO_SEL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_HILO_SEL
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_HILO_SEL__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_HILO_SEL)));
}

/** TELEM_TLM_HILO_SEL__SET() sets TLM_HILO_SEL to given value.
 *
 * When writing to TLM_HILO_SEL, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_HILO_SEL
 */
__TELEM_INLINE void TELEM_TLM_HILO_SEL__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_HILO_SEL__ADDRESS(idp), value);
}

/** TELEM_TLM_HILO_SEL__GET() gets TLM_HILO_SEL's current value.
 *
 * When reading from TLM_HILO_SEL, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_HILO_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_SEL__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_HILO_SEL__ADDRESS(idp));
}

/* ----------------- TELEM.TLM_HILO_SEL.TLM_HILO_MARK_B_SEL ----------------- */

/**
<pre>
  TELEM.TLM_HILO_SEL.TLM_HILO_MARK_B_SEL:

    Input select for Hi/Lo watermark detector B
    <start table_with_header>
    [1:0] "Input" "[1:0]" "Input"
    0 "Vin" "2" "Iin"
    1 "Vout" "3" "Iout"
    <end table>

</pre> */

#define TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Pos            2                                                                      /*!< Right-most bit position of tlm_hilo_mark_B_sel in TELEM.TLM_HILO_SEL */
#define TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Msk            (0x00000003UL << TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Pos)         /*!< Mask for tlm_hilo_mark_B_sel in TELEM.TLM_HILO_SEL */
#define TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Shift(v)       (((v) << TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Pos) & TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Msk) /*!< Shift value 'v' into tlm_hilo_mark_B_sel and mask 'v' to fit it into tlm_hilo_mark_B_sel field */

/** TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__SET() sets TLM_HILO_SEL.TLM_HILO_MARK_B_SEL to given value.
 *
 * When writing to TLM_HILO_SEL.TLM_HILO_MARK_B_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_HILO_SEL.TLM_HILO_MARK_B_SEL
 */
__TELEM_INLINE void TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_HILO_SEL__GET(idp);
    reg = (reg & ~TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Msk);
    reg = (reg | (TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Shift((uint32_t)bf_value)));
    TELEM_TLM_HILO_SEL__SET(idp, reg);
}

/** TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__GET() gets TLM_HILO_SEL.TLM_HILO_MARK_B_SEL's current value.
 *
 * When reading from TLM_HILO_SEL.TLM_HILO_MARK_B_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_HILO_SEL.TLM_HILO_MARK_B_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_HILO_SEL__GET(idp);
    reg = (reg & TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Msk);
    reg = (reg >> TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__MODIFY() modifies TLM_HILO_SEL.TLM_HILO_MARK_B_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_HILO_SEL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_HILO_SEL
 * @param bf_value new value for TLM_HILO_SEL.TLM_HILO_MARK_B_SEL
 * @return new value of TELEM.TLM_HILO_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Msk);
    reg = (reg | (TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__EXTRACT() extracts TLM_HILO_SEL.TLM_HILO_MARK_B_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_HILO_SEL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_HILO_SEL
 * @return current value of TLM_HILO_SEL.TLM_HILO_MARK_B_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Msk);
    reg = (reg >> TELEM_TLM_HILO_SEL__TLM_HILO_MARK_B_SEL__Pos);
    return (uint32_t)reg;
}

/* ----------------- TELEM.TLM_HILO_SEL.TLM_HILO_MARK_A_SEL ----------------- */

/**
<pre>
  TELEM.TLM_HILO_SEL.TLM_HILO_MARK_A_SEL:

    Input select for Hi/Lo watermark detector A
    <start table_with_header>
    [1:0] "Input" "[1:0]" "Input"
    0 "Vin" "2" "Iin"
    1 "Vout" "3" "Iout"
    <end table>

</pre> */

#define TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Pos            0                                                                      /*!< Right-most bit position of tlm_hilo_mark_A_sel in TELEM.TLM_HILO_SEL */
#define TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Msk            (0x00000003UL << TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Pos)         /*!< Mask for tlm_hilo_mark_A_sel in TELEM.TLM_HILO_SEL */
#define TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Shift(v)       (((v) << TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Pos) & TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Msk) /*!< Shift value 'v' into tlm_hilo_mark_A_sel and mask 'v' to fit it into tlm_hilo_mark_A_sel field */

/** TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__SET() sets TLM_HILO_SEL.TLM_HILO_MARK_A_SEL to given value.
 *
 * When writing to TLM_HILO_SEL.TLM_HILO_MARK_A_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_HILO_SEL.TLM_HILO_MARK_A_SEL
 */
__TELEM_INLINE void TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_HILO_SEL__GET(idp);
    reg = (reg & ~TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Msk);
    reg = (reg | (TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Shift((uint32_t)bf_value)));
    TELEM_TLM_HILO_SEL__SET(idp, reg);
}

/** TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__GET() gets TLM_HILO_SEL.TLM_HILO_MARK_A_SEL's current value.
 *
 * When reading from TLM_HILO_SEL.TLM_HILO_MARK_A_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_HILO_SEL.TLM_HILO_MARK_A_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_HILO_SEL__GET(idp);
    reg = (reg & TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Msk);
    reg = (reg >> TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__MODIFY() modifies TLM_HILO_SEL.TLM_HILO_MARK_A_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_HILO_SEL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_HILO_SEL
 * @param bf_value new value for TLM_HILO_SEL.TLM_HILO_MARK_A_SEL
 * @return new value of TELEM.TLM_HILO_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Msk);
    reg = (reg | (TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__EXTRACT() extracts TLM_HILO_SEL.TLM_HILO_MARK_A_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_HILO_SEL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_HILO_SEL
 * @return current value of TLM_HILO_SEL.TLM_HILO_MARK_A_SEL
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Msk);
    reg = (reg >> TELEM_TLM_HILO_SEL__TLM_HILO_MARK_A_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_HILO_CLRA member of TELEM_t                      */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_HILO_CLRA__ADDRESS returns the address of member TLM_HILO_CLRA.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_HILO_CLRA
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_HILO_CLRA__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_HILO_CLRA)));
}

/** TELEM_TLM_HILO_CLRA__SET() sets TLM_HILO_CLRA to given value.
 *
 * When writing to TLM_HILO_CLRA, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_HILO_CLRA
 */
__TELEM_INLINE void TELEM_TLM_HILO_CLRA__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_HILO_CLRA__ADDRESS(idp), value);
}


/* ---------------- TELEM.TLM_HILO_CLRA.TLM_HILO_MARK_A_CLR ---------------- */

/**
<pre>
  TELEM.TLM_HILO_CLRA.TLM_HILO_MARK_A_CLR:

    Clear for Hi/Lo watermark detector A. Write first to 1 then to 0 to clear detector.

</pre> */

#define TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Pos           0                                                                      /*!< Right-most bit position of tlm_hilo_mark_A_clr in TELEM.TLM_HILO_CLRA */
#define TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Msk           (0x00000001UL << TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Pos)        /*!< Mask for tlm_hilo_mark_A_clr in TELEM.TLM_HILO_CLRA */
#define TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Shift(v)      (((v) << TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Pos) & TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Msk) /*!< Shift value 'v' into tlm_hilo_mark_A_clr and mask 'v' to fit it into tlm_hilo_mark_A_clr field */

/** TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__SET() sets TLM_HILO_CLRA.TLM_HILO_MARK_A_CLR to given value.
 *
 * When writing to TLM_HILO_CLRA.TLM_HILO_MARK_A_CLR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_HILO_CLRA.TLM_HILO_MARK_A_CLR
 */
__TELEM_INLINE void TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Shift((uint32_t)bf_value);
    TELEM_TLM_HILO_CLRA__SET(idp, reg);
}


/** TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__MODIFY() modifies TLM_HILO_CLRA.TLM_HILO_MARK_A_CLR.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_HILO_CLRA.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_HILO_CLRA
 * @param bf_value new value for TLM_HILO_CLRA.TLM_HILO_MARK_A_CLR
 * @return new value of TELEM.TLM_HILO_CLRA
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Msk);
    reg = (reg | (TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__EXTRACT() extracts TLM_HILO_CLRA.TLM_HILO_MARK_A_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_HILO_CLRA.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_HILO_CLRA
 * @return current value of TLM_HILO_CLRA.TLM_HILO_MARK_A_CLR
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Msk);
    reg = (reg >> TELEM_TLM_HILO_CLRA__TLM_HILO_MARK_A_CLR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_HILO_CLRB member of TELEM_t                      */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_HILO_CLRB__ADDRESS returns the address of member TLM_HILO_CLRB.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_HILO_CLRB
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_HILO_CLRB__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_HILO_CLRB)));
}

/** TELEM_TLM_HILO_CLRB__SET() sets TLM_HILO_CLRB to given value.
 *
 * When writing to TLM_HILO_CLRB, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for TLM_HILO_CLRB
 */
__TELEM_INLINE void TELEM_TLM_HILO_CLRB__SET(telem_idx_t idp, uint32_t value)
{
    HAL_SET32(__TELEM_TLM_HILO_CLRB__ADDRESS(idp), value);
}


/* ---------------- TELEM.TLM_HILO_CLRB.TLM_HILO_MARK_B_CLR ---------------- */

/**
<pre>
  TELEM.TLM_HILO_CLRB.TLM_HILO_MARK_B_CLR:

    Clear for Hi/Lo watermark detector B.  Write first to 1 then to 0 to clear detector.

</pre> */

#define TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Pos           0                                                                      /*!< Right-most bit position of tlm_hilo_mark_B_clr in TELEM.TLM_HILO_CLRB */
#define TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Msk           (0x00000001UL << TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Pos)        /*!< Mask for tlm_hilo_mark_B_clr in TELEM.TLM_HILO_CLRB */
#define TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Shift(v)      (((v) << TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Pos) & TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Msk) /*!< Shift value 'v' into tlm_hilo_mark_B_clr and mask 'v' to fit it into tlm_hilo_mark_B_clr field */

/** TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__SET() sets TLM_HILO_CLRB.TLM_HILO_MARK_B_CLR to given value.
 *
 * When writing to TLM_HILO_CLRB.TLM_HILO_MARK_B_CLR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for TLM_HILO_CLRB.TLM_HILO_MARK_B_CLR
 */
__TELEM_INLINE void TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__SET(telem_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Shift((uint32_t)bf_value);
    TELEM_TLM_HILO_CLRB__SET(idp, reg);
}


/** TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__MODIFY() modifies TLM_HILO_CLRB.TLM_HILO_MARK_B_CLR.
 *
 * This is recommended to use when setting more than one bitfield of TELEM.TLM_HILO_CLRB.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TELEM.TLM_HILO_CLRB
 * @param bf_value new value for TLM_HILO_CLRB.TLM_HILO_MARK_B_CLR
 * @return new value of TELEM.TLM_HILO_CLRB
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Msk);
    reg = (reg | (TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__EXTRACT() extracts TLM_HILO_CLRB.TLM_HILO_MARK_B_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_HILO_CLRB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_HILO_CLRB
 * @return current value of TLM_HILO_CLRB.TLM_HILO_MARK_B_CLR
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Msk);
    reg = (reg >> TELEM_TLM_HILO_CLRB__TLM_HILO_MARK_B_CLR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_HILO_OUTA member of TELEM_t                      */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_HILO_OUTA__ADDRESS returns the address of member TLM_HILO_OUTA.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_HILO_OUTA
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_HILO_OUTA__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_HILO_OUTA)));
}

/** TELEM_TLM_HILO_OUTA__GET() gets TLM_HILO_OUTA's current value.
 *
 * When reading from TLM_HILO_OUTA, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_HILO_OUTA
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_OUTA__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_HILO_OUTA__ADDRESS(idp));
}

/* -------------------- TELEM.TLM_HILO_OUTA.TLM_OUT_LO_A -------------------- */

/**
<pre>
  TELEM.TLM_HILO_OUTA.TLM_OUT_LO_A:

    Low watermark detector A output.  Format depends on input selected by tlm_hilo_mark_A_sel.
    <start table_with_header>
    Input Format
    Vin "Unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    Vout "Unsigned, LSB = 1.25mV, Range = 0.0 to 5.11875V"
    Iin "Unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    Iout "Signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    <end table>

</pre> */

#define TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__Pos                  13                                                                     /*!< Right-most bit position of tlm_out_lo_A in TELEM.TLM_HILO_OUTA */
#define TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__Msk                  (0x00001FFFUL << TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__Pos)               /*!< Mask for tlm_out_lo_A in TELEM.TLM_HILO_OUTA */
#define TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__Shift(v)             (((v) << TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__Pos) & TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__Msk) /*!< Shift value 'v' into tlm_out_lo_A and mask 'v' to fit it into tlm_out_lo_A field */

/** TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__GET() gets TLM_HILO_OUTA.TLM_OUT_LO_A's current value.
 *
 * When reading from TLM_HILO_OUTA.TLM_OUT_LO_A, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_HILO_OUTA.TLM_OUT_LO_A
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_HILO_OUTA__GET(idp);
    reg = (reg & TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__Msk);
    reg = (reg >> TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__EXTRACT() extracts TLM_HILO_OUTA.TLM_OUT_LO_A.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_HILO_OUTA.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_HILO_OUTA
 * @return current value of TLM_HILO_OUTA.TLM_OUT_LO_A
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__Msk);
    reg = (reg >> TELEM_TLM_HILO_OUTA__TLM_OUT_LO_A__Pos);
    return (uint32_t)reg;
}

/* -------------------- TELEM.TLM_HILO_OUTA.TLM_OUT_HI_A -------------------- */

/**
<pre>
  TELEM.TLM_HILO_OUTA.TLM_OUT_HI_A:

    High watermark detector A output.  Format depends on input selected by tlm_hilo_mark_A_sel.
    <start table_with_header>
    Input Format
    Vin "Unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    Vout "Unsigned, LSB = 1.25mV, Range = 0.0 to 5.11875V"
    Iin "Unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    Iout "Signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    <end table>

</pre> */

#define TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__Pos                  0                                                                      /*!< Right-most bit position of tlm_out_hi_A in TELEM.TLM_HILO_OUTA */
#define TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__Msk                  (0x00001FFFUL << TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__Pos)               /*!< Mask for tlm_out_hi_A in TELEM.TLM_HILO_OUTA */
#define TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__Shift(v)             (((v) << TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__Pos) & TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__Msk) /*!< Shift value 'v' into tlm_out_hi_A and mask 'v' to fit it into tlm_out_hi_A field */

/** TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__GET() gets TLM_HILO_OUTA.TLM_OUT_HI_A's current value.
 *
 * When reading from TLM_HILO_OUTA.TLM_OUT_HI_A, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_HILO_OUTA.TLM_OUT_HI_A
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_HILO_OUTA__GET(idp);
    reg = (reg & TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__Msk);
    reg = (reg >> TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__EXTRACT() extracts TLM_HILO_OUTA.TLM_OUT_HI_A.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_HILO_OUTA.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_HILO_OUTA
 * @return current value of TLM_HILO_OUTA.TLM_OUT_HI_A
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__Msk);
    reg = (reg >> TELEM_TLM_HILO_OUTA__TLM_OUT_HI_A__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_HILO_OUTB member of TELEM_t                      */
/* -------------------------------------------------------------------------- */

/** __TELEM_TLM_HILO_OUTB__ADDRESS returns the address of member TLM_HILO_OUTB.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of TLM_HILO_OUTB
 */
__TELEM_INLINE uint32_t* __TELEM_TLM_HILO_OUTB__ADDRESS(telem_idx_t idp)
{
    return (uint32_t*)((uint32_t)__TELEM_BASE_PTR(idp) + (uint32_t)(offsetof(TELEM_t, TLM_HILO_OUTB)));
}

/** TELEM_TLM_HILO_OUTB__GET() gets TLM_HILO_OUTB's current value.
 *
 * When reading from TLM_HILO_OUTB, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_HILO_OUTB
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_OUTB__GET(telem_idx_t idp)
{
    return HAL_GET32(__TELEM_TLM_HILO_OUTB__ADDRESS(idp));
}

/* -------------------- TELEM.TLM_HILO_OUTB.TLM_OUT_LO_B -------------------- */

/**
<pre>
  TELEM.TLM_HILO_OUTB.TLM_OUT_LO_B:

    Low watermark detector B output.  Format depends on input selected by tlm_hilo_mark_B_sel.
    <start table_with_header>
    Input Format
    Vin "Unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    Vout "Unsigned, LSB = 1.25mV, Range = 0.0 to 5.11875V"
    Iin "Unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    Iout "Signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    <end table>

</pre> */

#define TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__Pos                  13                                                                     /*!< Right-most bit position of tlm_out_lo_B in TELEM.TLM_HILO_OUTB */
#define TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__Msk                  (0x00001FFFUL << TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__Pos)               /*!< Mask for tlm_out_lo_B in TELEM.TLM_HILO_OUTB */
#define TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__Shift(v)             (((v) << TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__Pos) & TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__Msk) /*!< Shift value 'v' into tlm_out_lo_B and mask 'v' to fit it into tlm_out_lo_B field */

/** TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__GET() gets TLM_HILO_OUTB.TLM_OUT_LO_B's current value.
 *
 * When reading from TLM_HILO_OUTB.TLM_OUT_LO_B, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_HILO_OUTB.TLM_OUT_LO_B
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_HILO_OUTB__GET(idp);
    reg = (reg & TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__Msk);
    reg = (reg >> TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__EXTRACT() extracts TLM_HILO_OUTB.TLM_OUT_LO_B.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_HILO_OUTB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_HILO_OUTB
 * @return current value of TLM_HILO_OUTB.TLM_OUT_LO_B
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__Msk);
    reg = (reg >> TELEM_TLM_HILO_OUTB__TLM_OUT_LO_B__Pos);
    return (uint32_t)reg;
}

/* -------------------- TELEM.TLM_HILO_OUTB.TLM_OUT_HI_B -------------------- */

/**
<pre>
  TELEM.TLM_HILO_OUTB.TLM_OUT_HI_B:

    High watermark detector B output.  Format depends on input selected by tlm_hilo_mark_B_sel.
    <start table_with_header>
    Input Format
    Vin "Unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    Vout "Unsigned, LSB = 1.25mV, Range = 0.0 to 5.11875V"
    Iin "Unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    Iout "Signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    <end table>

</pre> */

#define TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__Pos                  0                                                                      /*!< Right-most bit position of tlm_out_hi_B in TELEM.TLM_HILO_OUTB */
#define TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__Msk                  (0x00001FFFUL << TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__Pos)               /*!< Mask for tlm_out_hi_B in TELEM.TLM_HILO_OUTB */
#define TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__Shift(v)             (((v) << TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__Pos) & TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__Msk) /*!< Shift value 'v' into tlm_out_hi_B and mask 'v' to fit it into tlm_out_hi_B field */

/** TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__GET() gets TLM_HILO_OUTB.TLM_OUT_HI_B's current value.
 *
 * When reading from TLM_HILO_OUTB.TLM_OUT_HI_B, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of TLM_HILO_OUTB.TLM_OUT_HI_B
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__GET(telem_idx_t idp)
{
    uint32_t reg = TELEM_TLM_HILO_OUTB__GET(idp);
    reg = (reg & TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__Msk);
    reg = (reg >> TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__Pos);
    return (uint32_t)reg;
}

/** TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__EXTRACT() extracts TLM_HILO_OUTB.TLM_OUT_HI_B.
 *
 * This is recommended to use when extracting more than one bitfield from TELEM.TLM_HILO_OUTB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TELEM.TLM_HILO_OUTB
 * @return current value of TLM_HILO_OUTB.TLM_OUT_HI_B
 */
__TELEM_INLINE uint32_t TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__EXTRACT(uint32_t reg)
{
    reg = (reg & TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__Msk);
    reg = (reg >> TELEM_TLM_HILO_OUTB__TLM_OUT_HI_B__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group telem block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_TELEM_H_ */
