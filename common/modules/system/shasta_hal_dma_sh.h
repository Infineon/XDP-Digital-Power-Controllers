/**
 * @file     shasta_hal_dma_sh.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_DMA_SH_H_
#define _SHASTA_HAL_DMA_SH_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup dma_sh
 * @{
 */

#if defined ( __CC_ARM )
#define __DMA_SH_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __DMA_SH_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __DMA_SH_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __DMA_SH_INLINE  static inline
#endif

/** register file of the dma_sh block.
 */
typedef struct _DMA_SH_s
{
    volatile        uint32_t        DMA_STATUS                  ; /*!< (@0x00000000) DMA Status */
    volatile        uint32_t        DMA_CFG                     ; /*!< (@0x00000004) DMA Configuration */
    volatile        uint32_t        DMA_CTRL_BASE_PTR           ; /*!< (@0x00000008) Channel Control Data Base Pointer */
    volatile        uint32_t        DMA_ALT_CTRL_BASE_PTR       ; /*!< (@0x0000000C) Channel Alternate Control Data Base Pointer */
    volatile        uint32_t        CHNL_WAITONREQ_STATUS       ; /*!< (@0x00000010) Channel Wait on Request Status */
    volatile        uint32_t        DMA_CHNL_SW_REQUEST         ; /*!< (@0x00000014) Channel Software Request */
    volatile        uint32_t        DMA_CHNL_USEBURST_SET       ; /*!< (@0x00000018) Channel Useburst Set */
    volatile        uint32_t        DMA_CHNL_USEBURST_CLR       ; /*!< (@0x0000001C) Channel Useburst Clear */
    volatile        uint32_t        DMA_CHNL_REQ_MASK_SET       ; /*!< (@0x00000020) Channel Request Mask Set  */
    volatile        uint32_t        DMA_CHNL_REQ_MASK_CLR       ; /*!< (@0x00000024) Channel Request Mask Clear  */
    volatile        uint32_t        DMA_CHNL_ENABLE_SET         ; /*!< (@0x00000028) Channel Enable Set */
    volatile        uint32_t        DMA_CHNL_ENABLE_CLR         ; /*!< (@0x0000002C) Channel Enable Clear */
    volatile        uint32_t        DMA_CHNL_PRI_ALT_SET        ; /*!< (@0x00000030) Channel Primary-Alternate Set */
    volatile        uint32_t        DMA_CHNL_PRI_ALT_CLR        ; /*!< (@0x00000034) Channel Primary-Alternate Clear */
    volatile        uint32_t        DMA_CHNL_PRIORITY_SET       ; /*!< (@0x00000038) Channel Priority Set */
    volatile        uint32_t        DMA_CHNL_PRIORITY_CLR       ; /*!< (@0x0000003C) Channel Priority Clear */
    volatile        uint32_t        REGMEMGAP0[3]               ; /*!< (@0x00000040) gap in address space */
    volatile        uint32_t        DMA_ERR_CLR                 ; /*!< (@0x0000004C) Bus Error Clear */
    volatile        uint32_t        REGMEMGAP1[1004]            ; /*!< (@0x00000050) gap in address space */
    volatile        uint32_t        RIS                         ; /*!< (@0x00001000) Raw Interrupt Status Register */
    volatile        uint32_t        IMSC                        ; /*!< (@0x00001004) Interrupt Mask Control Register */
    volatile        uint32_t        MIS                         ; /*!< (@0x00001008) Masked Interrupt Status Register */
    volatile        uint32_t        ICR                         ; /*!< (@0x0000100C) Interrupt Clear Register */
    volatile        uint32_t        ISR                         ; /*!< (@0x00001010) Interrupt Set Register */
} DMA_SH_t;


#define DMA_SH_BASE (0x50000000u)                                                          /*!< dma_sh base address */

/** __DMA_SH_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_BASE_PTR(void)
{
    return (uint32_t*)(DMA_SH_BASE);
}


/* -------------------------------------------------------------------------- */
/*                       DMA_STATUS member of DMA_SH_t                       */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_STATUS__ADDRESS returns the address of member DMA_STATUS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_STATUS
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_STATUS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_STATUS)));
}

/** DMA_SH_DMA_STATUS__GET() gets DMA_STATUS's current value.
 *
 * When reading from DMA_STATUS, this is mandatory to use.
 *
 * @return current value of DMA_STATUS
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_STATUS__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_STATUS__ADDRESS());
}

/* --------------------- DMA_SH.DMA_STATUS.CHNLS_MINUS1 --------------------- */

/**
<pre>
  DMA_SH.DMA_STATUS.CHNLS_MINUS1:

    Available Channels minus 1

</pre> */

#define DMA_SH_DMA_STATUS__CHNLS_MINUS1__Pos                    16                                                                     /*!< Right-most bit position of CHNLS_MINUS1 in DMA_SH.DMA_STATUS */
#define DMA_SH_DMA_STATUS__CHNLS_MINUS1__Msk                    (0x0000001FUL << DMA_SH_DMA_STATUS__CHNLS_MINUS1__Pos)                 /*!< Mask for CHNLS_MINUS1 in DMA_SH.DMA_STATUS */
#define DMA_SH_DMA_STATUS__CHNLS_MINUS1__Shift(v)               (((v) << DMA_SH_DMA_STATUS__CHNLS_MINUS1__Pos) & DMA_SH_DMA_STATUS__CHNLS_MINUS1__Msk) /*!< Shift value 'v' into CHNLS_MINUS1 and mask 'v' to fit it into CHNLS_MINUS1 field */

/** DMA_SH_DMA_STATUS__CHNLS_MINUS1__GET() gets DMA_STATUS.CHNLS_MINUS1's current value.
 *
 * When reading from DMA_STATUS.CHNLS_MINUS1, this is recommended to use.
 *
 * @return current value of DMA_STATUS.CHNLS_MINUS1
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_STATUS__CHNLS_MINUS1__GET(void)
{
    uint32_t reg = DMA_SH_DMA_STATUS__GET();
    reg = (reg & DMA_SH_DMA_STATUS__CHNLS_MINUS1__Msk);
    reg = (reg >> DMA_SH_DMA_STATUS__CHNLS_MINUS1__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_DMA_STATUS__CHNLS_MINUS1__EXTRACT() extracts DMA_STATUS.CHNLS_MINUS1.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_STATUS
 * @return current value of DMA_STATUS.CHNLS_MINUS1
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_STATUS__CHNLS_MINUS1__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_STATUS__CHNLS_MINUS1__Msk);
    reg = (reg >> DMA_SH_DMA_STATUS__CHNLS_MINUS1__Pos);
    return (uint32_t)reg;
}

/* ------------------------ DMA_SH.DMA_STATUS.STATE ------------------------ */

/**
<pre>
  DMA_SH.DMA_STATUS.STATE:

    Current State of the Control State Machine

</pre> */

/*lint -parent(uint32_t, dma_sh_dma_status__state_t) -strong(AJX)*/
typedef enum dma_sh_dma_status__state_e                                                                                                /*!< Current State of the Control State Machine */
{
    dma_sh_dma_status__state_idle = 0x0u,                                                                                              /*!<  */
    dma_sh_dma_status__state_reading_ch_controller_data = 0x1u,                                                                        /*!<  */
    dma_sh_dma_status__state_reading_ch_src_data_ep = 0x2u,                                                                            /*!<  */
    dma_sh_dma_status__state_reading_ch_dest_data_ep = 0x3u,                                                                           /*!<  */
    dma_sh_dma_status__state_reading_src_data = 0x4u,                                                                                  /*!<  */
    dma_sh_dma_status__state_writing_dest_data = 0x5u,                                                                                 /*!<  */
    dma_sh_dma_status__state_writing_for_dma_req_to_clr = 0x6u,                                                                        /*!<  */
    dma_sh_dma_status__state_writing_channel_controller_data = 0x7u,                                                                   /*!<  */
    dma_sh_dma_status__state_stalled = 0x8u,                                                                                           /*!<  */
    dma_sh_dma_status__state_done = 0x9u,                                                                                              /*!<  */
    dma_sh_dma_status__state_peripheral_scatter_gather_transition = 0xau                                                               /*!<  */
} dma_sh_dma_status__state_t;

#define DMA_SH_DMA_STATUS__STATE__Pos                           4                                                                      /*!< Right-most bit position of STATE in DMA_SH.DMA_STATUS */
#define DMA_SH_DMA_STATUS__STATE__Msk                           (0x0000000FUL << DMA_SH_DMA_STATUS__STATE__Pos)                        /*!< Mask for STATE in DMA_SH.DMA_STATUS */
#define DMA_SH_DMA_STATUS__STATE__Shift(v)                      (((v) << DMA_SH_DMA_STATUS__STATE__Pos) & DMA_SH_DMA_STATUS__STATE__Msk) /*!< Shift value 'v' into STATE and mask 'v' to fit it into STATE field */

/** DMA_SH_DMA_STATUS__STATE__GET() gets DMA_STATUS.STATE's current value.
 *
 * When reading from DMA_STATUS.STATE, this is recommended to use.
 *
 * @return current value of DMA_STATUS.STATE
 */
__DMA_SH_INLINE dma_sh_dma_status__state_t DMA_SH_DMA_STATUS__STATE__GET(void)
{
    uint32_t reg = DMA_SH_DMA_STATUS__GET();
    reg = (reg & DMA_SH_DMA_STATUS__STATE__Msk);
    reg = (reg >> DMA_SH_DMA_STATUS__STATE__Pos);
    return (dma_sh_dma_status__state_t)reg;
}

/** DMA_SH_DMA_STATUS__STATE__EXTRACT() extracts DMA_STATUS.STATE.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_STATUS
 * @return current value of DMA_STATUS.STATE
 */
__DMA_SH_INLINE dma_sh_dma_status__state_t DMA_SH_DMA_STATUS__STATE__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_STATUS__STATE__Msk);
    reg = (reg >> DMA_SH_DMA_STATUS__STATE__Pos);
    return (dma_sh_dma_status__state_t)reg;
}

/* -------------------- DMA_SH.DMA_STATUS.MASTER_ENABLE -------------------- */

/**
<pre>
  DMA_SH.DMA_STATUS.MASTER_ENABLE:

    Enable Status of the Controller

</pre> */

#define DMA_SH_DMA_STATUS__MASTER_ENABLE__Pos                   0                                                                      /*!< Right-most bit position of MASTER_ENABLE in DMA_SH.DMA_STATUS */
#define DMA_SH_DMA_STATUS__MASTER_ENABLE__Msk                   (0x00000001UL << DMA_SH_DMA_STATUS__MASTER_ENABLE__Pos)                /*!< Mask for MASTER_ENABLE in DMA_SH.DMA_STATUS */
#define DMA_SH_DMA_STATUS__MASTER_ENABLE__Shift(v)              (((v) << DMA_SH_DMA_STATUS__MASTER_ENABLE__Pos) & DMA_SH_DMA_STATUS__MASTER_ENABLE__Msk) /*!< Shift value 'v' into MASTER_ENABLE and mask 'v' to fit it into MASTER_ENABLE field */

/** DMA_SH_DMA_STATUS__MASTER_ENABLE__GET() gets DMA_STATUS.MASTER_ENABLE's current value.
 *
 * When reading from DMA_STATUS.MASTER_ENABLE, this is recommended to use.
 *
 * @return current value of DMA_STATUS.MASTER_ENABLE
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_STATUS__MASTER_ENABLE__GET(void)
{
    uint32_t reg = DMA_SH_DMA_STATUS__GET();
    reg = (reg & DMA_SH_DMA_STATUS__MASTER_ENABLE__Msk);
    reg = (reg >> DMA_SH_DMA_STATUS__MASTER_ENABLE__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_DMA_STATUS__MASTER_ENABLE__EXTRACT() extracts DMA_STATUS.MASTER_ENABLE.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_STATUS
 * @return current value of DMA_STATUS.MASTER_ENABLE
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_STATUS__MASTER_ENABLE__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_STATUS__MASTER_ENABLE__Msk);
    reg = (reg >> DMA_SH_DMA_STATUS__MASTER_ENABLE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         DMA_CFG member of DMA_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CFG__ADDRESS returns the address of member DMA_CFG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CFG
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CFG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CFG)));
}

/** DMA_SH_DMA_CFG__SET() sets DMA_CFG to given value.
 *
 * When writing to DMA_CFG, this is mandatory to use.
 *
 * @param value new value for DMA_CFG
 */
__DMA_SH_INLINE void DMA_SH_DMA_CFG__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CFG__ADDRESS(), value);
}


/* --------------------- DMA_SH.DMA_CFG.CHN1_PROT_CTRL --------------------- */

/**
<pre>
  DMA_SH.DMA_CFG.CHN1_PROT_CTRL:

    CHN1_PROT_CTRL

</pre> */

#define DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Pos                     5                                                                      /*!< Right-most bit position of CHN1_PROT_CTRL in DMA_SH.DMA_CFG */
#define DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Msk                     (0x00000007UL << DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Pos)                  /*!< Mask for CHN1_PROT_CTRL in DMA_SH.DMA_CFG */
#define DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Shift(v)                (((v) << DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Pos) & DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Msk) /*!< Shift value 'v' into CHN1_PROT_CTRL and mask 'v' to fit it into CHN1_PROT_CTRL field */

/** DMA_SH_DMA_CFG__CHN1_PROT_CTRL__SET() sets DMA_CFG.CHN1_PROT_CTRL to given value.
 *
 * When writing to DMA_CFG.CHN1_PROT_CTRL, this is recommended to use.
 *
 * @param bf_value new value for DMA_CFG.CHN1_PROT_CTRL
 */
__DMA_SH_INLINE void DMA_SH_DMA_CFG__CHN1_PROT_CTRL__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Shift((uint32_t)bf_value);
    DMA_SH_DMA_CFG__SET(reg);
}


/** DMA_SH_DMA_CFG__CHN1_PROT_CTRL__MODIFY() modifies DMA_CFG.CHN1_PROT_CTRL.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CFG
 * @param bf_value new value for DMA_CFG.CHN1_PROT_CTRL
 * @return new value of DMA_SH.DMA_CFG
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CFG__CHN1_PROT_CTRL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Msk);
    reg = (reg | (DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CFG__CHN1_PROT_CTRL__EXTRACT() extracts DMA_CFG.CHN1_PROT_CTRL.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CFG
 * @return current value of DMA_CFG.CHN1_PROT_CTRL
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CFG__CHN1_PROT_CTRL__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Msk);
    reg = (reg >> DMA_SH_DMA_CFG__CHN1_PROT_CTRL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- DMA_SH.DMA_CFG.MASTER_ENABLE ---------------------- */

/**
<pre>
  DMA_SH.DMA_CFG.MASTER_ENABLE:

    Enable for the Controller

</pre> */

/*lint -parent(uint32_t, dma_sh_dma_cfg__master_enable_t) -strong(AJX)*/
typedef enum dma_sh_dma_cfg__master_enable_e                                                                                           /*!< Enable for the Controller */
{
    dma_sh_dma_cfg__master_enable_ds = 0u,                                                                                             /*!<          disables the controller */
    dma_sh_dma_cfg__master_enable_en = 1u                                                                                              /*!<          enables the controller */
} dma_sh_dma_cfg__master_enable_t;

#define DMA_SH_DMA_CFG__MASTER_ENABLE__Pos                      0                                                                      /*!< Right-most bit position of MASTER_ENABLE in DMA_SH.DMA_CFG */
#define DMA_SH_DMA_CFG__MASTER_ENABLE__Msk                      (0x00000001UL << DMA_SH_DMA_CFG__MASTER_ENABLE__Pos)                   /*!< Mask for MASTER_ENABLE in DMA_SH.DMA_CFG */
#define DMA_SH_DMA_CFG__MASTER_ENABLE__Shift(v)                 (((v) << DMA_SH_DMA_CFG__MASTER_ENABLE__Pos) & DMA_SH_DMA_CFG__MASTER_ENABLE__Msk) /*!< Shift value 'v' into MASTER_ENABLE and mask 'v' to fit it into MASTER_ENABLE field */

/** DMA_SH_DMA_CFG__MASTER_ENABLE__SET() sets DMA_CFG.MASTER_ENABLE to given value.
 *
 * When writing to DMA_CFG.MASTER_ENABLE, this is recommended to use.
 *
 * @param bf_value new value for DMA_CFG.MASTER_ENABLE
 */
__DMA_SH_INLINE void DMA_SH_DMA_CFG__MASTER_ENABLE__SET(dma_sh_dma_cfg__master_enable_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CFG__MASTER_ENABLE__Shift((uint32_t)bf_value);
    DMA_SH_DMA_CFG__SET(reg);
}


/** DMA_SH_DMA_CFG__MASTER_ENABLE__MODIFY() modifies DMA_CFG.MASTER_ENABLE.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CFG
 * @param bf_value new value for DMA_CFG.MASTER_ENABLE
 * @return new value of DMA_SH.DMA_CFG
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CFG__MASTER_ENABLE__MODIFY(uint32_t reg, dma_sh_dma_cfg__master_enable_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CFG__MASTER_ENABLE__Msk);
    reg = (reg | (DMA_SH_DMA_CFG__MASTER_ENABLE__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CFG__MASTER_ENABLE__EXTRACT() extracts DMA_CFG.MASTER_ENABLE.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CFG
 * @return current value of DMA_CFG.MASTER_ENABLE
 */
__DMA_SH_INLINE dma_sh_dma_cfg__master_enable_t DMA_SH_DMA_CFG__MASTER_ENABLE__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CFG__MASTER_ENABLE__Msk);
    reg = (reg >> DMA_SH_DMA_CFG__MASTER_ENABLE__Pos);
    return (dma_sh_dma_cfg__master_enable_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    DMA_CTRL_BASE_PTR member of DMA_SH_t                    */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CTRL_BASE_PTR__ADDRESS returns the address of member DMA_CTRL_BASE_PTR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CTRL_BASE_PTR
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CTRL_BASE_PTR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CTRL_BASE_PTR)));
}

/** DMA_SH_DMA_CTRL_BASE_PTR__SET() sets DMA_CTRL_BASE_PTR to given value.
 *
 * When writing to DMA_CTRL_BASE_PTR, this is mandatory to use.
 *
 * @param value new value for DMA_CTRL_BASE_PTR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CTRL_BASE_PTR__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CTRL_BASE_PTR__ADDRESS(), value);
}

/** DMA_SH_DMA_CTRL_BASE_PTR__GET() gets DMA_CTRL_BASE_PTR's current value.
 *
 * When reading from DMA_CTRL_BASE_PTR, this is mandatory to use.
 *
 * @return current value of DMA_CTRL_BASE_PTR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CTRL_BASE_PTR__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CTRL_BASE_PTR__ADDRESS());
}

/* ----------------- DMA_SH.DMA_CTRL_BASE_PTR.CTRL_BASE_PTR ----------------- */

/**
<pre>
  DMA_SH.DMA_CTRL_BASE_PTR.CTRL_BASE_PTR:

    CTRL_BASE_PTR

</pre> */

#define DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Pos            9                                                                      /*!< Right-most bit position of CTRL_BASE_PTR in DMA_SH.DMA_CTRL_BASE_PTR */
#define DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Msk            (0x007FFFFFUL << DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Pos)         /*!< Mask for CTRL_BASE_PTR in DMA_SH.DMA_CTRL_BASE_PTR */
#define DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Shift(v)       (((v) << DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Pos) & DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Msk) /*!< Shift value 'v' into CTRL_BASE_PTR and mask 'v' to fit it into CTRL_BASE_PTR field */

/** DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__SET() sets DMA_CTRL_BASE_PTR.CTRL_BASE_PTR to given value.
 *
 * When writing to DMA_CTRL_BASE_PTR.CTRL_BASE_PTR, this is recommended to use.
 *
 * @param bf_value new value for DMA_CTRL_BASE_PTR.CTRL_BASE_PTR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CTRL_BASE_PTR__GET();
    reg = (reg & ~DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Msk);
    reg = (reg | (DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Shift((uint32_t)bf_value)));
    DMA_SH_DMA_CTRL_BASE_PTR__SET(reg);
}

/** DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__GET() gets DMA_CTRL_BASE_PTR.CTRL_BASE_PTR's current value.
 *
 * When reading from DMA_CTRL_BASE_PTR.CTRL_BASE_PTR, this is recommended to use.
 *
 * @return current value of DMA_CTRL_BASE_PTR.CTRL_BASE_PTR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__GET(void)
{
    uint32_t reg = DMA_SH_DMA_CTRL_BASE_PTR__GET();
    reg = (reg & DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Msk);
    reg = (reg >> DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__MODIFY() modifies DMA_CTRL_BASE_PTR.CTRL_BASE_PTR.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CTRL_BASE_PTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CTRL_BASE_PTR
 * @param bf_value new value for DMA_CTRL_BASE_PTR.CTRL_BASE_PTR
 * @return new value of DMA_SH.DMA_CTRL_BASE_PTR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Msk);
    reg = (reg | (DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__EXTRACT() extracts DMA_CTRL_BASE_PTR.CTRL_BASE_PTR.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CTRL_BASE_PTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CTRL_BASE_PTR
 * @return current value of DMA_CTRL_BASE_PTR.CTRL_BASE_PTR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Msk);
    reg = (reg >> DMA_SH_DMA_CTRL_BASE_PTR__CTRL_BASE_PTR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  DMA_ALT_CTRL_BASE_PTR member of DMA_SH_t                  */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_ALT_CTRL_BASE_PTR__ADDRESS returns the address of member DMA_ALT_CTRL_BASE_PTR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_ALT_CTRL_BASE_PTR
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_ALT_CTRL_BASE_PTR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_ALT_CTRL_BASE_PTR)));
}

/** DMA_SH_DMA_ALT_CTRL_BASE_PTR__GET() gets DMA_ALT_CTRL_BASE_PTR's current value.
 *
 * When reading from DMA_ALT_CTRL_BASE_PTR, this is mandatory to use.
 *
 * @return current value of DMA_ALT_CTRL_BASE_PTR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_ALT_CTRL_BASE_PTR__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_ALT_CTRL_BASE_PTR__ADDRESS());
}

/* ------------- DMA_SH.DMA_ALT_CTRL_BASE_PTR.ALT_CTRL_BASE_PTR ------------- */

/**
<pre>
  DMA_SH.DMA_ALT_CTRL_BASE_PTR.ALT_CTRL_BASE_PTR:

    Base Address of the Alternate Data Structure

</pre> */

#define DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__Pos    0                                                                      /*!< Right-most bit position of ALT_CTRL_BASE_PTR in DMA_SH.DMA_ALT_CTRL_BASE_PTR */
#define DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__Msk    (0xFFFFFFFFUL << DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__Pos) /*!< Mask for ALT_CTRL_BASE_PTR in DMA_SH.DMA_ALT_CTRL_BASE_PTR */
#define DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__Shift(v) (((v) << DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__Pos) & DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__Msk) /*!< Shift value 'v' into ALT_CTRL_BASE_PTR and mask 'v' to fit it into ALT_CTRL_BASE_PTR field */

/** DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__GET() gets DMA_ALT_CTRL_BASE_PTR.ALT_CTRL_BASE_PTR's current value.
 *
 * When reading from DMA_ALT_CTRL_BASE_PTR.ALT_CTRL_BASE_PTR, this is recommended to use.
 *
 * @return current value of DMA_ALT_CTRL_BASE_PTR.ALT_CTRL_BASE_PTR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__GET(void)
{
    uint32_t reg = DMA_SH_DMA_ALT_CTRL_BASE_PTR__GET();
    reg = (reg & DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__Msk);
    reg = (reg >> DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__EXTRACT() extracts DMA_ALT_CTRL_BASE_PTR.ALT_CTRL_BASE_PTR.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_ALT_CTRL_BASE_PTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_ALT_CTRL_BASE_PTR
 * @return current value of DMA_ALT_CTRL_BASE_PTR.ALT_CTRL_BASE_PTR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__Msk);
    reg = (reg >> DMA_SH_DMA_ALT_CTRL_BASE_PTR__ALT_CTRL_BASE_PTR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  CHNL_WAITONREQ_STATUS member of DMA_SH_t                  */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_CHNL_WAITONREQ_STATUS__ADDRESS returns the address of member CHNL_WAITONREQ_STATUS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CHNL_WAITONREQ_STATUS
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_CHNL_WAITONREQ_STATUS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, CHNL_WAITONREQ_STATUS)));
}

/** DMA_SH_CHNL_WAITONREQ_STATUS__GET() gets CHNL_WAITONREQ_STATUS's current value.
 *
 * When reading from CHNL_WAITONREQ_STATUS, this is mandatory to use.
 *
 * @return current value of CHNL_WAITONREQ_STATUS
 */
__DMA_SH_INLINE uint32_t DMA_SH_CHNL_WAITONREQ_STATUS__GET(void)
{
    return HAL_GET32(__DMA_SH_CHNL_WAITONREQ_STATUS__ADDRESS());
}

/* ----------- DMA_SH.CHNL_WAITONREQ_STATUS.DMA_WAITONREQ_STATUS ----------- */

/**
<pre>
  DMA_SH.CHNL_WAITONREQ_STATUS.DMA_WAITONREQ_STATUS:

    Channel Wait on Request Status

</pre> */

/*lint -parent(uint32_t, dma_sh_chnl_waitonreq_status__dma_waitonreq_status_t) -strong(AJX)*/
typedef enum dma_sh_chnl_waitonreq_status__dma_waitonreq_status_e                                                                      /*!< Channel Wait on Request Status */
{
    dma_sh_chnl_waitonreq_status__dma_waitonreq_status_low = 0u,                                                                       /*!<           dma_waitonreq[C] is LOW. */
    dma_sh_chnl_waitonreq_status__dma_waitonreq_status_high = 1u                                                                       /*!<           dma_waitonreq[C] is HIGH. */
} dma_sh_chnl_waitonreq_status__dma_waitonreq_status_t;

#define DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__Pos 0                                                                      /*!< Right-most bit position of DMA_WAITONREQ_STATUS in DMA_SH.CHNL_WAITONREQ_STATUS */
#define DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__Msk (0x0000FFFFUL << DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__Pos) /*!< Mask for DMA_WAITONREQ_STATUS in DMA_SH.CHNL_WAITONREQ_STATUS */
#define DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__Shift(v) (((v) << DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__Pos) & DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__Msk) /*!< Shift value 'v' into DMA_WAITONREQ_STATUS and mask 'v' to fit it into DMA_WAITONREQ_STATUS field */

/** DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__GET() gets CHNL_WAITONREQ_STATUS.DMA_WAITONREQ_STATUS's current value.
 *
 * When reading from CHNL_WAITONREQ_STATUS.DMA_WAITONREQ_STATUS, this is recommended to use.
 *
 * @return current value of CHNL_WAITONREQ_STATUS.DMA_WAITONREQ_STATUS
 */
__DMA_SH_INLINE dma_sh_chnl_waitonreq_status__dma_waitonreq_status_t DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__GET(void)
{
    uint32_t reg = DMA_SH_CHNL_WAITONREQ_STATUS__GET();
    reg = (reg & DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__Msk);
    reg = (reg >> DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__Pos);
    return (dma_sh_chnl_waitonreq_status__dma_waitonreq_status_t)reg;
}

/** DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__EXTRACT() extracts CHNL_WAITONREQ_STATUS.DMA_WAITONREQ_STATUS.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.CHNL_WAITONREQ_STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.CHNL_WAITONREQ_STATUS
 * @return current value of CHNL_WAITONREQ_STATUS.DMA_WAITONREQ_STATUS
 */
__DMA_SH_INLINE dma_sh_chnl_waitonreq_status__dma_waitonreq_status_t DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__Msk);
    reg = (reg >> DMA_SH_CHNL_WAITONREQ_STATUS__DMA_WAITONREQ_STATUS__Pos);
    return (dma_sh_chnl_waitonreq_status__dma_waitonreq_status_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   DMA_CHNL_SW_REQUEST member of DMA_SH_t                   */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_SW_REQUEST__ADDRESS returns the address of member DMA_CHNL_SW_REQUEST.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_SW_REQUEST
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_SW_REQUEST__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_SW_REQUEST)));
}

/** DMA_SH_DMA_CHNL_SW_REQUEST__SET() sets DMA_CHNL_SW_REQUEST to given value.
 *
 * When writing to DMA_CHNL_SW_REQUEST, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_SW_REQUEST
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_SW_REQUEST__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_SW_REQUEST__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_SW_REQUEST__GET() gets DMA_CHNL_SW_REQUEST's current value.
 *
 * When reading from DMA_CHNL_SW_REQUEST, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_SW_REQUEST
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_SW_REQUEST__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_SW_REQUEST__ADDRESS());
}

/* --------------- DMA_SH.DMA_CHNL_SW_REQUEST.CHNL_SW_REQUEST --------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_SW_REQUEST.CHNL_SW_REQUEST:

    CHNL_SW_REQUEST

</pre> */

/*lint -parent(uint32_t, dma_sh_dma_chnl_sw_request__chnl_sw_request_t) -strong(AJX)*/
typedef enum dma_sh_dma_chnl_sw_request__chnl_sw_request_e                                                                             /*!< CHNL_SW_REQUEST */
{
    dma_sh_dma_chnl_sw_request__chnl_sw_request_dont_care = 0u,                                                                        /*!<          does not create a DMA request for channel C. */
    dma_sh_dma_chnl_sw_request__chnl_sw_request_req = 1u                                                                               /*!<          creates a DMA request for channel C. */
} dma_sh_dma_chnl_sw_request__chnl_sw_request_t;

#define DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Pos        0                                                                      /*!< Right-most bit position of CHNL_SW_REQUEST in DMA_SH.DMA_CHNL_SW_REQUEST */
#define DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Msk        (0x0000FFFFUL << DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Pos)     /*!< Mask for CHNL_SW_REQUEST in DMA_SH.DMA_CHNL_SW_REQUEST */
#define DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Shift(v)   (((v) << DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Pos) & DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Msk) /*!< Shift value 'v' into CHNL_SW_REQUEST and mask 'v' to fit it into CHNL_SW_REQUEST field */

/** DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__SET() sets DMA_CHNL_SW_REQUEST.CHNL_SW_REQUEST to given value.
 *
 * When writing to DMA_CHNL_SW_REQUEST.CHNL_SW_REQUEST, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_SW_REQUEST.CHNL_SW_REQUEST
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__SET(dma_sh_dma_chnl_sw_request__chnl_sw_request_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Shift((uint32_t)bf_value);
    DMA_SH_DMA_CHNL_SW_REQUEST__SET(reg);
}


/** DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__MODIFY() modifies DMA_CHNL_SW_REQUEST.CHNL_SW_REQUEST.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_SW_REQUEST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_SW_REQUEST
 * @param bf_value new value for DMA_CHNL_SW_REQUEST.CHNL_SW_REQUEST
 * @return new value of DMA_SH.DMA_CHNL_SW_REQUEST
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__MODIFY(uint32_t reg, dma_sh_dma_chnl_sw_request__chnl_sw_request_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__EXTRACT() extracts DMA_CHNL_SW_REQUEST.CHNL_SW_REQUEST.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_SW_REQUEST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_SW_REQUEST
 * @return current value of DMA_CHNL_SW_REQUEST.CHNL_SW_REQUEST
 */
__DMA_SH_INLINE dma_sh_dma_chnl_sw_request__chnl_sw_request_t DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_SW_REQUEST__CHNL_SW_REQUEST__Pos);
    return (dma_sh_dma_chnl_sw_request__chnl_sw_request_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  DMA_CHNL_USEBURST_SET member of DMA_SH_t                  */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_USEBURST_SET__ADDRESS returns the address of member DMA_CHNL_USEBURST_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_USEBURST_SET
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_USEBURST_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_USEBURST_SET)));
}

/** DMA_SH_DMA_CHNL_USEBURST_SET__SET() sets DMA_CHNL_USEBURST_SET to given value.
 *
 * When writing to DMA_CHNL_USEBURST_SET, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_USEBURST_SET
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_USEBURST_SET__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_USEBURST_SET__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_USEBURST_SET__GET() gets DMA_CHNL_USEBURST_SET's current value.
 *
 * When reading from DMA_CHNL_USEBURST_SET, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_USEBURST_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_USEBURST_SET__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_USEBURST_SET__ADDRESS());
}

/* ------------- DMA_SH.DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET ------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET:

    CHNL_USEBURST_SET

</pre> */

/*lint -parent(uint32_t, dma_sh_dma_chnl_useburst_set__chnl_useburst_set_t) -strong(AJX)*/
typedef enum dma_sh_dma_chnl_useburst_set__chnl_useburst_set_e                                                                         /*!< CHNL_USEBURST_SET */
{
    dma_sh_dma_chnl_useburst_set__chnl_useburst_set_no_change = 0u,                                                                    /*!<          on read: DMA channel n responds to requests that it rece...(more) */
    dma_sh_dma_chnl_useburst_set__chnl_useburst_set_set = 1u                                                                           /*!<          on read: DMA channel n does not respond to requests that...(more) */
} dma_sh_dma_chnl_useburst_set__chnl_useburst_set_t;

#define DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Pos    0                                                                      /*!< Right-most bit position of CHNL_USEBURST_SET in DMA_SH.DMA_CHNL_USEBURST_SET */
#define DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Msk    (0x0000FFFFUL << DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Pos) /*!< Mask for CHNL_USEBURST_SET in DMA_SH.DMA_CHNL_USEBURST_SET */
#define DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Shift(v) (((v) << DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Pos) & DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Msk) /*!< Shift value 'v' into CHNL_USEBURST_SET and mask 'v' to fit it into CHNL_USEBURST_SET field */

/** DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__SET() sets DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET to given value.
 *
 * When writing to DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__SET(dma_sh_dma_chnl_useburst_set__chnl_useburst_set_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_USEBURST_SET__GET();
    reg = (reg & ~DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Shift((uint32_t)bf_value)));
    DMA_SH_DMA_CHNL_USEBURST_SET__SET(reg);
}

/** DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__GET() gets DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET's current value.
 *
 * When reading from DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET, this is recommended to use.
 *
 * @return current value of DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET
 */
__DMA_SH_INLINE dma_sh_dma_chnl_useburst_set__chnl_useburst_set_t DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__GET(void)
{
    uint32_t reg = DMA_SH_DMA_CHNL_USEBURST_SET__GET();
    reg = (reg & DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Pos);
    return (dma_sh_dma_chnl_useburst_set__chnl_useburst_set_t)reg;
}

/** DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__MODIFY() modifies DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_USEBURST_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_USEBURST_SET
 * @param bf_value new value for DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET
 * @return new value of DMA_SH.DMA_CHNL_USEBURST_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__MODIFY(uint32_t reg, dma_sh_dma_chnl_useburst_set__chnl_useburst_set_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__EXTRACT() extracts DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_USEBURST_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_USEBURST_SET
 * @return current value of DMA_CHNL_USEBURST_SET.CHNL_USEBURST_SET
 */
__DMA_SH_INLINE dma_sh_dma_chnl_useburst_set__chnl_useburst_set_t DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_USEBURST_SET__CHNL_USEBURST_SET__Pos);
    return (dma_sh_dma_chnl_useburst_set__chnl_useburst_set_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  DMA_CHNL_USEBURST_CLR member of DMA_SH_t                  */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_USEBURST_CLR__ADDRESS returns the address of member DMA_CHNL_USEBURST_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_USEBURST_CLR
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_USEBURST_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_USEBURST_CLR)));
}

/** DMA_SH_DMA_CHNL_USEBURST_CLR__SET() sets DMA_CHNL_USEBURST_CLR to given value.
 *
 * When writing to DMA_CHNL_USEBURST_CLR, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_USEBURST_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_USEBURST_CLR__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_USEBURST_CLR__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_USEBURST_CLR__GET() gets DMA_CHNL_USEBURST_CLR's current value.
 *
 * When reading from DMA_CHNL_USEBURST_CLR, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_USEBURST_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_USEBURST_CLR__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_USEBURST_CLR__ADDRESS());
}

/* ------------- DMA_SH.DMA_CHNL_USEBURST_CLR.CHNL_USEBURST_CLR ------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_USEBURST_CLR.CHNL_USEBURST_CLR:

    CHNL_USEBURST_CLR

</pre> */

/*lint -parent(uint32_t, dma_sh_dma_chnl_useburst_clr__chnl_useburst_clr_t) -strong(AJX)*/
typedef enum dma_sh_dma_chnl_useburst_clr__chnl_useburst_clr_e                                                                         /*!< CHNL_USEBURST_CLR */
{
    dma_sh_dma_chnl_useburst_clr__chnl_useburst_clr_no_clr = 0u,                                                                       /*!<          No effect. Use the CHNL_USEBURST_SET Register to disable...(more) */
    dma_sh_dma_chnl_useburst_clr__chnl_useburst_clr_clr = 1u                                                                           /*!<          Enables dma_sreq[C] to generate DMA requests. */
} dma_sh_dma_chnl_useburst_clr__chnl_useburst_clr_t;

#define DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Pos    0                                                                      /*!< Right-most bit position of CHNL_USEBURST_CLR in DMA_SH.DMA_CHNL_USEBURST_CLR */
#define DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Msk    (0x0000FFFFUL << DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Pos) /*!< Mask for CHNL_USEBURST_CLR in DMA_SH.DMA_CHNL_USEBURST_CLR */
#define DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Shift(v) (((v) << DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Pos) & DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Msk) /*!< Shift value 'v' into CHNL_USEBURST_CLR and mask 'v' to fit it into CHNL_USEBURST_CLR field */

/** DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__SET() sets DMA_CHNL_USEBURST_CLR.CHNL_USEBURST_CLR to given value.
 *
 * When writing to DMA_CHNL_USEBURST_CLR.CHNL_USEBURST_CLR, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_USEBURST_CLR.CHNL_USEBURST_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__SET(dma_sh_dma_chnl_useburst_clr__chnl_useburst_clr_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Shift((uint32_t)bf_value);
    DMA_SH_DMA_CHNL_USEBURST_CLR__SET(reg);
}


/** DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__MODIFY() modifies DMA_CHNL_USEBURST_CLR.CHNL_USEBURST_CLR.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_USEBURST_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_USEBURST_CLR
 * @param bf_value new value for DMA_CHNL_USEBURST_CLR.CHNL_USEBURST_CLR
 * @return new value of DMA_SH.DMA_CHNL_USEBURST_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__MODIFY(uint32_t reg, dma_sh_dma_chnl_useburst_clr__chnl_useburst_clr_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__EXTRACT() extracts DMA_CHNL_USEBURST_CLR.CHNL_USEBURST_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_USEBURST_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_USEBURST_CLR
 * @return current value of DMA_CHNL_USEBURST_CLR.CHNL_USEBURST_CLR
 */
__DMA_SH_INLINE dma_sh_dma_chnl_useburst_clr__chnl_useburst_clr_t DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_USEBURST_CLR__CHNL_USEBURST_CLR__Pos);
    return (dma_sh_dma_chnl_useburst_clr__chnl_useburst_clr_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  DMA_CHNL_REQ_MASK_SET member of DMA_SH_t                  */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_REQ_MASK_SET__ADDRESS returns the address of member DMA_CHNL_REQ_MASK_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_REQ_MASK_SET
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_REQ_MASK_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_REQ_MASK_SET)));
}

/** DMA_SH_DMA_CHNL_REQ_MASK_SET__SET() sets DMA_CHNL_REQ_MASK_SET to given value.
 *
 * When writing to DMA_CHNL_REQ_MASK_SET, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_REQ_MASK_SET
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_REQ_MASK_SET__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_REQ_MASK_SET__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_REQ_MASK_SET__GET() gets DMA_CHNL_REQ_MASK_SET's current value.
 *
 * When reading from DMA_CHNL_REQ_MASK_SET, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_REQ_MASK_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_REQ_MASK_SET__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_REQ_MASK_SET__ADDRESS());
}

/* ------------- DMA_SH.DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET ------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET:

    CHNL_REQ_MASK_SET

</pre> */

/*lint -parent(uint32_t, dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_t) -strong(AJX)*/
typedef enum dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_e                                                                         /*!< CHNL_REQ_MASK_SET */
{
    dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_no_change = 0u,                                                                    /*!<          on read: External requests are enabled for channel C. */
    dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_set = 1u                                                                           /*!<  */
} dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_t;

#define DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Pos    0                                                                      /*!< Right-most bit position of CHNL_REQ_MASK_SET in DMA_SH.DMA_CHNL_REQ_MASK_SET */
#define DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Msk    (0x0000FFFFUL << DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Pos) /*!< Mask for CHNL_REQ_MASK_SET in DMA_SH.DMA_CHNL_REQ_MASK_SET */
#define DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Shift(v) (((v) << DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Pos) & DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Msk) /*!< Shift value 'v' into CHNL_REQ_MASK_SET and mask 'v' to fit it into CHNL_REQ_MASK_SET field */

/** DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__SET() sets DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET to given value.
 *
 * When writing to DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__SET(dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_REQ_MASK_SET__GET();
    reg = (reg & ~DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Shift((uint32_t)bf_value)));
    DMA_SH_DMA_CHNL_REQ_MASK_SET__SET(reg);
}

/** DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__GET() gets DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET's current value.
 *
 * When reading from DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET, this is recommended to use.
 *
 * @return current value of DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET
 */
__DMA_SH_INLINE dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_t DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__GET(void)
{
    uint32_t reg = DMA_SH_DMA_CHNL_REQ_MASK_SET__GET();
    reg = (reg & DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Pos);
    return (dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_t)reg;
}

/** DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__MODIFY() modifies DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_REQ_MASK_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_REQ_MASK_SET
 * @param bf_value new value for DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET
 * @return new value of DMA_SH.DMA_CHNL_REQ_MASK_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__MODIFY(uint32_t reg, dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__EXTRACT() extracts DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_REQ_MASK_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_REQ_MASK_SET
 * @return current value of DMA_CHNL_REQ_MASK_SET.CHNL_REQ_MASK_SET
 */
__DMA_SH_INLINE dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_t DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_REQ_MASK_SET__CHNL_REQ_MASK_SET__Pos);
    return (dma_sh_dma_chnl_req_mask_set__chnl_req_mask_set_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  DMA_CHNL_REQ_MASK_CLR member of DMA_SH_t                  */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_REQ_MASK_CLR__ADDRESS returns the address of member DMA_CHNL_REQ_MASK_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_REQ_MASK_CLR
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_REQ_MASK_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_REQ_MASK_CLR)));
}

/** DMA_SH_DMA_CHNL_REQ_MASK_CLR__SET() sets DMA_CHNL_REQ_MASK_CLR to given value.
 *
 * When writing to DMA_CHNL_REQ_MASK_CLR, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_REQ_MASK_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_REQ_MASK_CLR__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_REQ_MASK_CLR__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_REQ_MASK_CLR__GET() gets DMA_CHNL_REQ_MASK_CLR's current value.
 *
 * When reading from DMA_CHNL_REQ_MASK_CLR, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_REQ_MASK_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_REQ_MASK_CLR__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_REQ_MASK_CLR__ADDRESS());
}

/* ------------- DMA_SH.DMA_CHNL_REQ_MASK_CLR.CHNL_REQ_MASK_CLR ------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_REQ_MASK_CLR.CHNL_REQ_MASK_CLR:

    CHNL_REQ_MASK_CLR

</pre> */

/*lint -parent(uint32_t, dma_sh_dma_chnl_req_mask_clr__chnl_req_mask_clr_t) -strong(AJX)*/
typedef enum dma_sh_dma_chnl_req_mask_clr__chnl_req_mask_clr_e                                                                         /*!< CHNL_REQ_MASK_CLR */
{
    dma_sh_dma_chnl_req_mask_clr__chnl_req_mask_clr_no_clr = 0u,                                                                       /*!<          No effect. Use the CHNL_REQ_MASK_SET Register to disable...(more) */
    dma_sh_dma_chnl_req_mask_clr__chnl_req_mask_clr_clr = 1u                                                                           /*!<          Enables dma_req[C] or dma_sreq[C] to generate DMA reques...(more) */
} dma_sh_dma_chnl_req_mask_clr__chnl_req_mask_clr_t;

#define DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Pos    0                                                                      /*!< Right-most bit position of CHNL_REQ_MASK_CLR in DMA_SH.DMA_CHNL_REQ_MASK_CLR */
#define DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Msk    (0x0000FFFFUL << DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Pos) /*!< Mask for CHNL_REQ_MASK_CLR in DMA_SH.DMA_CHNL_REQ_MASK_CLR */
#define DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Shift(v) (((v) << DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Pos) & DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Msk) /*!< Shift value 'v' into CHNL_REQ_MASK_CLR and mask 'v' to fit it into CHNL_REQ_MASK_CLR field */

/** DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__SET() sets DMA_CHNL_REQ_MASK_CLR.CHNL_REQ_MASK_CLR to given value.
 *
 * When writing to DMA_CHNL_REQ_MASK_CLR.CHNL_REQ_MASK_CLR, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_REQ_MASK_CLR.CHNL_REQ_MASK_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__SET(dma_sh_dma_chnl_req_mask_clr__chnl_req_mask_clr_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Shift((uint32_t)bf_value);
    DMA_SH_DMA_CHNL_REQ_MASK_CLR__SET(reg);
}


/** DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__MODIFY() modifies DMA_CHNL_REQ_MASK_CLR.CHNL_REQ_MASK_CLR.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_REQ_MASK_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_REQ_MASK_CLR
 * @param bf_value new value for DMA_CHNL_REQ_MASK_CLR.CHNL_REQ_MASK_CLR
 * @return new value of DMA_SH.DMA_CHNL_REQ_MASK_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__MODIFY(uint32_t reg, dma_sh_dma_chnl_req_mask_clr__chnl_req_mask_clr_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__EXTRACT() extracts DMA_CHNL_REQ_MASK_CLR.CHNL_REQ_MASK_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_REQ_MASK_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_REQ_MASK_CLR
 * @return current value of DMA_CHNL_REQ_MASK_CLR.CHNL_REQ_MASK_CLR
 */
__DMA_SH_INLINE dma_sh_dma_chnl_req_mask_clr__chnl_req_mask_clr_t DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_REQ_MASK_CLR__CHNL_REQ_MASK_CLR__Pos);
    return (dma_sh_dma_chnl_req_mask_clr__chnl_req_mask_clr_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   DMA_CHNL_ENABLE_SET member of DMA_SH_t                   */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_ENABLE_SET__ADDRESS returns the address of member DMA_CHNL_ENABLE_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_ENABLE_SET
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_ENABLE_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_ENABLE_SET)));
}

/** DMA_SH_DMA_CHNL_ENABLE_SET__SET() sets DMA_CHNL_ENABLE_SET to given value.
 *
 * When writing to DMA_CHNL_ENABLE_SET, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_ENABLE_SET
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_ENABLE_SET__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_ENABLE_SET__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_ENABLE_SET__GET() gets DMA_CHNL_ENABLE_SET's current value.
 *
 * When reading from DMA_CHNL_ENABLE_SET, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_ENABLE_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_ENABLE_SET__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_ENABLE_SET__ADDRESS());
}

/* --------------- DMA_SH.DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET --------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET:

    CHNL_ENABLE_SET

</pre> */

/*lint -parent(uint32_t, dma_sh_dma_chnl_enable_set__chnl_enable_set_t) -strong(AJX)*/
typedef enum dma_sh_dma_chnl_enable_set__chnl_enable_set_e                                                                             /*!< CHNL_ENABLE_SET */
{
    dma_sh_dma_chnl_enable_set__chnl_enable_set_no_change = 0u,                                                                        /*!<  */
    dma_sh_dma_chnl_enable_set__chnl_enable_set_set = 1u                                                                               /*!<  */
} dma_sh_dma_chnl_enable_set__chnl_enable_set_t;

#define DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Pos        0                                                                      /*!< Right-most bit position of CHNL_ENABLE_SET in DMA_SH.DMA_CHNL_ENABLE_SET */
#define DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Msk        (0x0000FFFFUL << DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Pos)     /*!< Mask for CHNL_ENABLE_SET in DMA_SH.DMA_CHNL_ENABLE_SET */
#define DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Shift(v)   (((v) << DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Pos) & DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Msk) /*!< Shift value 'v' into CHNL_ENABLE_SET and mask 'v' to fit it into CHNL_ENABLE_SET field */

/** DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__SET() sets DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET to given value.
 *
 * When writing to DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__SET(dma_sh_dma_chnl_enable_set__chnl_enable_set_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_ENABLE_SET__GET();
    reg = (reg & ~DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Shift((uint32_t)bf_value)));
    DMA_SH_DMA_CHNL_ENABLE_SET__SET(reg);
}

/** DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__GET() gets DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET's current value.
 *
 * When reading from DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET, this is recommended to use.
 *
 * @return current value of DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET
 */
__DMA_SH_INLINE dma_sh_dma_chnl_enable_set__chnl_enable_set_t DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__GET(void)
{
    uint32_t reg = DMA_SH_DMA_CHNL_ENABLE_SET__GET();
    reg = (reg & DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Pos);
    return (dma_sh_dma_chnl_enable_set__chnl_enable_set_t)reg;
}

/** DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__MODIFY() modifies DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_ENABLE_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_ENABLE_SET
 * @param bf_value new value for DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET
 * @return new value of DMA_SH.DMA_CHNL_ENABLE_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__MODIFY(uint32_t reg, dma_sh_dma_chnl_enable_set__chnl_enable_set_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__EXTRACT() extracts DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_ENABLE_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_ENABLE_SET
 * @return current value of DMA_CHNL_ENABLE_SET.CHNL_ENABLE_SET
 */
__DMA_SH_INLINE dma_sh_dma_chnl_enable_set__chnl_enable_set_t DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_ENABLE_SET__CHNL_ENABLE_SET__Pos);
    return (dma_sh_dma_chnl_enable_set__chnl_enable_set_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   DMA_CHNL_ENABLE_CLR member of DMA_SH_t                   */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_ENABLE_CLR__ADDRESS returns the address of member DMA_CHNL_ENABLE_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_ENABLE_CLR
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_ENABLE_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_ENABLE_CLR)));
}

/** DMA_SH_DMA_CHNL_ENABLE_CLR__SET() sets DMA_CHNL_ENABLE_CLR to given value.
 *
 * When writing to DMA_CHNL_ENABLE_CLR, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_ENABLE_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_ENABLE_CLR__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_ENABLE_CLR__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_ENABLE_CLR__GET() gets DMA_CHNL_ENABLE_CLR's current value.
 *
 * When reading from DMA_CHNL_ENABLE_CLR, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_ENABLE_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_ENABLE_CLR__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_ENABLE_CLR__ADDRESS());
}

/* --------------- DMA_SH.DMA_CHNL_ENABLE_CLR.CHNL_ENABLE_CLR --------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_ENABLE_CLR.CHNL_ENABLE_CLR:

    CHNL_ENABLE_CLR

</pre> */

/*lint -parent(uint32_t, dma_sh_dma_chnl_enable_clr__chnl_enable_clr_t) -strong(AJX)*/
typedef enum dma_sh_dma_chnl_enable_clr__chnl_enable_clr_e                                                                             /*!< CHNL_ENABLE_CLR */
{
    dma_sh_dma_chnl_enable_clr__chnl_enable_clr_no_clr = 0u,                                                                           /*!<          No effect. Use the CHNL_ENABLE_SET Register to enable DM...(more) */
    dma_sh_dma_chnl_enable_clr__chnl_enable_clr_clr = 1u                                                                               /*!<          Disables channel C. */
} dma_sh_dma_chnl_enable_clr__chnl_enable_clr_t;

#define DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Pos        0                                                                      /*!< Right-most bit position of CHNL_ENABLE_CLR in DMA_SH.DMA_CHNL_ENABLE_CLR */
#define DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Msk        (0x0000FFFFUL << DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Pos)     /*!< Mask for CHNL_ENABLE_CLR in DMA_SH.DMA_CHNL_ENABLE_CLR */
#define DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Shift(v)   (((v) << DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Pos) & DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Msk) /*!< Shift value 'v' into CHNL_ENABLE_CLR and mask 'v' to fit it into CHNL_ENABLE_CLR field */

/** DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__SET() sets DMA_CHNL_ENABLE_CLR.CHNL_ENABLE_CLR to given value.
 *
 * When writing to DMA_CHNL_ENABLE_CLR.CHNL_ENABLE_CLR, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_ENABLE_CLR.CHNL_ENABLE_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__SET(dma_sh_dma_chnl_enable_clr__chnl_enable_clr_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Shift((uint32_t)bf_value);
    DMA_SH_DMA_CHNL_ENABLE_CLR__SET(reg);
}


/** DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__MODIFY() modifies DMA_CHNL_ENABLE_CLR.CHNL_ENABLE_CLR.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_ENABLE_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_ENABLE_CLR
 * @param bf_value new value for DMA_CHNL_ENABLE_CLR.CHNL_ENABLE_CLR
 * @return new value of DMA_SH.DMA_CHNL_ENABLE_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__MODIFY(uint32_t reg, dma_sh_dma_chnl_enable_clr__chnl_enable_clr_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__EXTRACT() extracts DMA_CHNL_ENABLE_CLR.CHNL_ENABLE_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_ENABLE_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_ENABLE_CLR
 * @return current value of DMA_CHNL_ENABLE_CLR.CHNL_ENABLE_CLR
 */
__DMA_SH_INLINE dma_sh_dma_chnl_enable_clr__chnl_enable_clr_t DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_ENABLE_CLR__CHNL_ENABLE_CLR__Pos);
    return (dma_sh_dma_chnl_enable_clr__chnl_enable_clr_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  DMA_CHNL_PRI_ALT_SET member of DMA_SH_t                  */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_PRI_ALT_SET__ADDRESS returns the address of member DMA_CHNL_PRI_ALT_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_PRI_ALT_SET
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_PRI_ALT_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_PRI_ALT_SET)));
}

/** DMA_SH_DMA_CHNL_PRI_ALT_SET__SET() sets DMA_CHNL_PRI_ALT_SET to given value.
 *
 * When writing to DMA_CHNL_PRI_ALT_SET, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_PRI_ALT_SET
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_PRI_ALT_SET__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_PRI_ALT_SET__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_PRI_ALT_SET__GET() gets DMA_CHNL_PRI_ALT_SET's current value.
 *
 * When reading from DMA_CHNL_PRI_ALT_SET, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_PRI_ALT_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRI_ALT_SET__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_PRI_ALT_SET__ADDRESS());
}

/* -------------- DMA_SH.DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET -------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET:

    CHNL_PRI_ALT_SET

</pre> */

#define DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Pos      0                                                                      /*!< Right-most bit position of CHNL_PRI_ALT_SET in DMA_SH.DMA_CHNL_PRI_ALT_SET */
#define DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Msk      (0x0000FFFFUL << DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Pos)   /*!< Mask for CHNL_PRI_ALT_SET in DMA_SH.DMA_CHNL_PRI_ALT_SET */
#define DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Shift(v) (((v) << DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Pos) & DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Msk) /*!< Shift value 'v' into CHNL_PRI_ALT_SET and mask 'v' to fit it into CHNL_PRI_ALT_SET field */

/** DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__SET() sets DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET to given value.
 *
 * When writing to DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_PRI_ALT_SET__GET();
    reg = (reg & ~DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Shift((uint32_t)bf_value)));
    DMA_SH_DMA_CHNL_PRI_ALT_SET__SET(reg);
}

/** DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__GET() gets DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET's current value.
 *
 * When reading from DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET, this is recommended to use.
 *
 * @return current value of DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__GET(void)
{
    uint32_t reg = DMA_SH_DMA_CHNL_PRI_ALT_SET__GET();
    reg = (reg & DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__MODIFY() modifies DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_PRI_ALT_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_PRI_ALT_SET
 * @param bf_value new value for DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET
 * @return new value of DMA_SH.DMA_CHNL_PRI_ALT_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__EXTRACT() extracts DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_PRI_ALT_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_PRI_ALT_SET
 * @return current value of DMA_CHNL_PRI_ALT_SET.CHNL_PRI_ALT_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_PRI_ALT_SET__CHNL_PRI_ALT_SET__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  DMA_CHNL_PRI_ALT_CLR member of DMA_SH_t                  */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_PRI_ALT_CLR__ADDRESS returns the address of member DMA_CHNL_PRI_ALT_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_PRI_ALT_CLR
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_PRI_ALT_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_PRI_ALT_CLR)));
}

/** DMA_SH_DMA_CHNL_PRI_ALT_CLR__SET() sets DMA_CHNL_PRI_ALT_CLR to given value.
 *
 * When writing to DMA_CHNL_PRI_ALT_CLR, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_PRI_ALT_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_PRI_ALT_CLR__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_PRI_ALT_CLR__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_PRI_ALT_CLR__GET() gets DMA_CHNL_PRI_ALT_CLR's current value.
 *
 * When reading from DMA_CHNL_PRI_ALT_CLR, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_PRI_ALT_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRI_ALT_CLR__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_PRI_ALT_CLR__ADDRESS());
}

/* -------------- DMA_SH.DMA_CHNL_PRI_ALT_CLR.CHNL_PRI_ALT_CLR -------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_PRI_ALT_CLR.CHNL_PRI_ALT_CLR:

    CHNL_PRI_ALT_CLR

</pre> */

#define DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Pos      0                                                                      /*!< Right-most bit position of CHNL_PRI_ALT_CLR in DMA_SH.DMA_CHNL_PRI_ALT_CLR */
#define DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Msk      (0x0000FFFFUL << DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Pos)   /*!< Mask for CHNL_PRI_ALT_CLR in DMA_SH.DMA_CHNL_PRI_ALT_CLR */
#define DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Shift(v) (((v) << DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Pos) & DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Msk) /*!< Shift value 'v' into CHNL_PRI_ALT_CLR and mask 'v' to fit it into CHNL_PRI_ALT_CLR field */

/** DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__SET() sets DMA_CHNL_PRI_ALT_CLR.CHNL_PRI_ALT_CLR to given value.
 *
 * When writing to DMA_CHNL_PRI_ALT_CLR.CHNL_PRI_ALT_CLR, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_PRI_ALT_CLR.CHNL_PRI_ALT_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Shift((uint32_t)bf_value);
    DMA_SH_DMA_CHNL_PRI_ALT_CLR__SET(reg);
}


/** DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__MODIFY() modifies DMA_CHNL_PRI_ALT_CLR.CHNL_PRI_ALT_CLR.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_PRI_ALT_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_PRI_ALT_CLR
 * @param bf_value new value for DMA_CHNL_PRI_ALT_CLR.CHNL_PRI_ALT_CLR
 * @return new value of DMA_SH.DMA_CHNL_PRI_ALT_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__EXTRACT() extracts DMA_CHNL_PRI_ALT_CLR.CHNL_PRI_ALT_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_PRI_ALT_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_PRI_ALT_CLR
 * @return current value of DMA_CHNL_PRI_ALT_CLR.CHNL_PRI_ALT_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_PRI_ALT_CLR__CHNL_PRI_ALT_CLR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  DMA_CHNL_PRIORITY_SET member of DMA_SH_t                  */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_PRIORITY_SET__ADDRESS returns the address of member DMA_CHNL_PRIORITY_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_PRIORITY_SET
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_PRIORITY_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_PRIORITY_SET)));
}

/** DMA_SH_DMA_CHNL_PRIORITY_SET__SET() sets DMA_CHNL_PRIORITY_SET to given value.
 *
 * When writing to DMA_CHNL_PRIORITY_SET, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_PRIORITY_SET
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_PRIORITY_SET__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_PRIORITY_SET__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_PRIORITY_SET__GET() gets DMA_CHNL_PRIORITY_SET's current value.
 *
 * When reading from DMA_CHNL_PRIORITY_SET, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_PRIORITY_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRIORITY_SET__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_PRIORITY_SET__ADDRESS());
}

/* ------------- DMA_SH.DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET ------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET:

    CHNL_PRIORITY_SET

</pre> */

#define DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Pos    0                                                                      /*!< Right-most bit position of CHNL_PRIORITY_SET in DMA_SH.DMA_CHNL_PRIORITY_SET */
#define DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Msk    (0x0000FFFFUL << DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Pos) /*!< Mask for CHNL_PRIORITY_SET in DMA_SH.DMA_CHNL_PRIORITY_SET */
#define DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Shift(v) (((v) << DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Pos) & DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Msk) /*!< Shift value 'v' into CHNL_PRIORITY_SET and mask 'v' to fit it into CHNL_PRIORITY_SET field */

/** DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__SET() sets DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET to given value.
 *
 * When writing to DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_PRIORITY_SET__GET();
    reg = (reg & ~DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Shift((uint32_t)bf_value)));
    DMA_SH_DMA_CHNL_PRIORITY_SET__SET(reg);
}

/** DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__GET() gets DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET's current value.
 *
 * When reading from DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET, this is recommended to use.
 *
 * @return current value of DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__GET(void)
{
    uint32_t reg = DMA_SH_DMA_CHNL_PRIORITY_SET__GET();
    reg = (reg & DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__MODIFY() modifies DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_PRIORITY_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_PRIORITY_SET
 * @param bf_value new value for DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET
 * @return new value of DMA_SH.DMA_CHNL_PRIORITY_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__EXTRACT() extracts DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_PRIORITY_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_PRIORITY_SET
 * @return current value of DMA_CHNL_PRIORITY_SET.CHNL_PRIORITY_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_PRIORITY_SET__CHNL_PRIORITY_SET__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  DMA_CHNL_PRIORITY_CLR member of DMA_SH_t                  */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_CHNL_PRIORITY_CLR__ADDRESS returns the address of member DMA_CHNL_PRIORITY_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CHNL_PRIORITY_CLR
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_CHNL_PRIORITY_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_CHNL_PRIORITY_CLR)));
}

/** DMA_SH_DMA_CHNL_PRIORITY_CLR__SET() sets DMA_CHNL_PRIORITY_CLR to given value.
 *
 * When writing to DMA_CHNL_PRIORITY_CLR, this is mandatory to use.
 *
 * @param value new value for DMA_CHNL_PRIORITY_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_PRIORITY_CLR__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_CHNL_PRIORITY_CLR__ADDRESS(), value);
}

/** DMA_SH_DMA_CHNL_PRIORITY_CLR__GET() gets DMA_CHNL_PRIORITY_CLR's current value.
 *
 * When reading from DMA_CHNL_PRIORITY_CLR, this is mandatory to use.
 *
 * @return current value of DMA_CHNL_PRIORITY_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRIORITY_CLR__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_CHNL_PRIORITY_CLR__ADDRESS());
}

/* ------------- DMA_SH.DMA_CHNL_PRIORITY_CLR.CHNL_PRIORITY_CLR ------------- */

/**
<pre>
  DMA_SH.DMA_CHNL_PRIORITY_CLR.CHNL_PRIORITY_CLR:

    CHNL_PRIORITY_CLR

</pre> */

#define DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Pos    0                                                                      /*!< Right-most bit position of CHNL_PRIORITY_CLR in DMA_SH.DMA_CHNL_PRIORITY_CLR */
#define DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Msk    (0x0000FFFFUL << DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Pos) /*!< Mask for CHNL_PRIORITY_CLR in DMA_SH.DMA_CHNL_PRIORITY_CLR */
#define DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Shift(v) (((v) << DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Pos) & DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Msk) /*!< Shift value 'v' into CHNL_PRIORITY_CLR and mask 'v' to fit it into CHNL_PRIORITY_CLR field */

/** DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__SET() sets DMA_CHNL_PRIORITY_CLR.CHNL_PRIORITY_CLR to given value.
 *
 * When writing to DMA_CHNL_PRIORITY_CLR.CHNL_PRIORITY_CLR, this is recommended to use.
 *
 * @param bf_value new value for DMA_CHNL_PRIORITY_CLR.CHNL_PRIORITY_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Shift((uint32_t)bf_value);
    DMA_SH_DMA_CHNL_PRIORITY_CLR__SET(reg);
}


/** DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__MODIFY() modifies DMA_CHNL_PRIORITY_CLR.CHNL_PRIORITY_CLR.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_CHNL_PRIORITY_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_PRIORITY_CLR
 * @param bf_value new value for DMA_CHNL_PRIORITY_CLR.CHNL_PRIORITY_CLR
 * @return new value of DMA_SH.DMA_CHNL_PRIORITY_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Msk);
    reg = (reg | (DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__EXTRACT() extracts DMA_CHNL_PRIORITY_CLR.CHNL_PRIORITY_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_CHNL_PRIORITY_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_CHNL_PRIORITY_CLR
 * @return current value of DMA_CHNL_PRIORITY_CLR.CHNL_PRIORITY_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Msk);
    reg = (reg >> DMA_SH_DMA_CHNL_PRIORITY_CLR__CHNL_PRIORITY_CLR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       DMA_ERR_CLR member of DMA_SH_t                       */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_DMA_ERR_CLR__ADDRESS returns the address of member DMA_ERR_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_ERR_CLR
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_DMA_ERR_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, DMA_ERR_CLR)));
}

/** DMA_SH_DMA_ERR_CLR__SET() sets DMA_ERR_CLR to given value.
 *
 * When writing to DMA_ERR_CLR, this is mandatory to use.
 *
 * @param value new value for DMA_ERR_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_ERR_CLR__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_DMA_ERR_CLR__ADDRESS(), value);
}

/** DMA_SH_DMA_ERR_CLR__GET() gets DMA_ERR_CLR's current value.
 *
 * When reading from DMA_ERR_CLR, this is mandatory to use.
 *
 * @return current value of DMA_ERR_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_ERR_CLR__GET(void)
{
    return HAL_GET32(__DMA_SH_DMA_ERR_CLR__ADDRESS());
}

/* ----------------------- DMA_SH.DMA_ERR_CLR.ERR_CLR ----------------------- */

/**
<pre>
  DMA_SH.DMA_ERR_CLR.ERR_CLR:

    ERR_CLR

</pre> */

#define DMA_SH_DMA_ERR_CLR__ERR_CLR__Pos                        0                                                                      /*!< Right-most bit position of ERR_CLR in DMA_SH.DMA_ERR_CLR */
#define DMA_SH_DMA_ERR_CLR__ERR_CLR__Msk                        (0x00000001UL << DMA_SH_DMA_ERR_CLR__ERR_CLR__Pos)                     /*!< Mask for ERR_CLR in DMA_SH.DMA_ERR_CLR */
#define DMA_SH_DMA_ERR_CLR__ERR_CLR__Shift(v)                   (((v) << DMA_SH_DMA_ERR_CLR__ERR_CLR__Pos) & DMA_SH_DMA_ERR_CLR__ERR_CLR__Msk) /*!< Shift value 'v' into ERR_CLR and mask 'v' to fit it into ERR_CLR field */

/** DMA_SH_DMA_ERR_CLR__ERR_CLR__SET() sets DMA_ERR_CLR.ERR_CLR to given value.
 *
 * When writing to DMA_ERR_CLR.ERR_CLR, this is recommended to use.
 *
 * @param bf_value new value for DMA_ERR_CLR.ERR_CLR
 */
__DMA_SH_INLINE void DMA_SH_DMA_ERR_CLR__ERR_CLR__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_DMA_ERR_CLR__GET();
    reg = (reg & ~DMA_SH_DMA_ERR_CLR__ERR_CLR__Msk);
    reg = (reg | (DMA_SH_DMA_ERR_CLR__ERR_CLR__Shift((uint32_t)bf_value)));
    DMA_SH_DMA_ERR_CLR__SET(reg);
}

/** DMA_SH_DMA_ERR_CLR__ERR_CLR__GET() gets DMA_ERR_CLR.ERR_CLR's current value.
 *
 * When reading from DMA_ERR_CLR.ERR_CLR, this is recommended to use.
 *
 * @return current value of DMA_ERR_CLR.ERR_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_ERR_CLR__ERR_CLR__GET(void)
{
    uint32_t reg = DMA_SH_DMA_ERR_CLR__GET();
    reg = (reg & DMA_SH_DMA_ERR_CLR__ERR_CLR__Msk);
    reg = (reg >> DMA_SH_DMA_ERR_CLR__ERR_CLR__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_DMA_ERR_CLR__ERR_CLR__MODIFY() modifies DMA_ERR_CLR.ERR_CLR.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.DMA_ERR_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.DMA_ERR_CLR
 * @param bf_value new value for DMA_ERR_CLR.ERR_CLR
 * @return new value of DMA_SH.DMA_ERR_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_ERR_CLR__ERR_CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_DMA_ERR_CLR__ERR_CLR__Msk);
    reg = (reg | (DMA_SH_DMA_ERR_CLR__ERR_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_DMA_ERR_CLR__ERR_CLR__EXTRACT() extracts DMA_ERR_CLR.ERR_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.DMA_ERR_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.DMA_ERR_CLR
 * @return current value of DMA_ERR_CLR.ERR_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_DMA_ERR_CLR__ERR_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_DMA_ERR_CLR__ERR_CLR__Msk);
    reg = (reg >> DMA_SH_DMA_ERR_CLR__ERR_CLR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           RIS member of DMA_SH_t                           */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_RIS__ADDRESS returns the address of member RIS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RIS
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_RIS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, RIS)));
}

/** DMA_SH_RIS__GET() gets RIS's current value.
 *
 * When reading from RIS, this is mandatory to use.
 *
 * @return current value of RIS
 */
__DMA_SH_INLINE uint32_t DMA_SH_RIS__GET(void)
{
    return HAL_GET32(__DMA_SH_RIS__ADDRESS());
}

/* --------------------- DMA_SH.RIS.DMA_ERR_INT_STATUS --------------------- */

/**
<pre>
  DMA_SH.RIS.DMA_ERR_INT_STATUS:

    DMA Error Interrupt.

</pre> */

#define DMA_SH_RIS__DMA_ERR_INT_STATUS__Pos                     31                                                                     /*!< Right-most bit position of DMA_ERR_INT_STATUS in DMA_SH.RIS */
#define DMA_SH_RIS__DMA_ERR_INT_STATUS__Msk                     (0x00000001UL << DMA_SH_RIS__DMA_ERR_INT_STATUS__Pos)                  /*!< Mask for DMA_ERR_INT_STATUS in DMA_SH.RIS */
#define DMA_SH_RIS__DMA_ERR_INT_STATUS__Shift(v)                (((v) << DMA_SH_RIS__DMA_ERR_INT_STATUS__Pos) & DMA_SH_RIS__DMA_ERR_INT_STATUS__Msk) /*!< Shift value 'v' into DMA_ERR_INT_STATUS and mask 'v' to fit it into DMA_ERR_INT_STATUS field */

/** DMA_SH_RIS__DMA_ERR_INT_STATUS__GET() gets RIS.DMA_ERR_INT_STATUS's current value.
 *
 * When reading from RIS.DMA_ERR_INT_STATUS, this is recommended to use.
 *
 * @return current value of RIS.DMA_ERR_INT_STATUS
 */
__DMA_SH_INLINE uint32_t DMA_SH_RIS__DMA_ERR_INT_STATUS__GET(void)
{
    uint32_t reg = DMA_SH_RIS__GET();
    reg = (reg & DMA_SH_RIS__DMA_ERR_INT_STATUS__Msk);
    reg = (reg >> DMA_SH_RIS__DMA_ERR_INT_STATUS__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_RIS__DMA_ERR_INT_STATUS__EXTRACT() extracts RIS.DMA_ERR_INT_STATUS.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.RIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.RIS
 * @return current value of RIS.DMA_ERR_INT_STATUS
 */
__DMA_SH_INLINE uint32_t DMA_SH_RIS__DMA_ERR_INT_STATUS__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_RIS__DMA_ERR_INT_STATUS__Msk);
    reg = (reg >> DMA_SH_RIS__DMA_ERR_INT_STATUS__Pos);
    return (uint32_t)reg;
}

/* ---------------------- DMA_SH.RIS.DMA_CH_INT_STATUS ---------------------- */

/**
<pre>
  DMA_SH.RIS.DMA_CH_INT_STATUS:

    DMA Channel_15 Interrupt.

</pre> */

#define DMA_SH_RIS__DMA_CH_INT_STATUS__Pos                      0                                                                      /*!< Right-most bit position of DMA_CH_INT_STATUS in DMA_SH.RIS */
#define DMA_SH_RIS__DMA_CH_INT_STATUS__Msk                      (0x0000FFFFUL << DMA_SH_RIS__DMA_CH_INT_STATUS__Pos)                   /*!< Mask for DMA_CH_INT_STATUS in DMA_SH.RIS */
#define DMA_SH_RIS__DMA_CH_INT_STATUS__Shift(v)                 (((v) << DMA_SH_RIS__DMA_CH_INT_STATUS__Pos) & DMA_SH_RIS__DMA_CH_INT_STATUS__Msk) /*!< Shift value 'v' into DMA_CH_INT_STATUS and mask 'v' to fit it into DMA_CH_INT_STATUS field */

/** DMA_SH_RIS__DMA_CH_INT_STATUS__GET() gets RIS.DMA_CH_INT_STATUS's current value.
 *
 * When reading from RIS.DMA_CH_INT_STATUS, this is recommended to use.
 *
 * @return current value of RIS.DMA_CH_INT_STATUS
 */
__DMA_SH_INLINE uint32_t DMA_SH_RIS__DMA_CH_INT_STATUS__GET(void)
{
    uint32_t reg = DMA_SH_RIS__GET();
    reg = (reg & DMA_SH_RIS__DMA_CH_INT_STATUS__Msk);
    reg = (reg >> DMA_SH_RIS__DMA_CH_INT_STATUS__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_RIS__DMA_CH_INT_STATUS__EXTRACT() extracts RIS.DMA_CH_INT_STATUS.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.RIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.RIS
 * @return current value of RIS.DMA_CH_INT_STATUS
 */
__DMA_SH_INLINE uint32_t DMA_SH_RIS__DMA_CH_INT_STATUS__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_RIS__DMA_CH_INT_STATUS__Msk);
    reg = (reg >> DMA_SH_RIS__DMA_CH_INT_STATUS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          IMSC member of DMA_SH_t                          */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_IMSC__ADDRESS returns the address of member IMSC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IMSC
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_IMSC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, IMSC)));
}

/** DMA_SH_IMSC__SET() sets IMSC to given value.
 *
 * When writing to IMSC, this is mandatory to use.
 *
 * @param value new value for IMSC
 */
__DMA_SH_INLINE void DMA_SH_IMSC__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_IMSC__ADDRESS(), value);
}

/** DMA_SH_IMSC__GET() gets IMSC's current value.
 *
 * When reading from IMSC, this is mandatory to use.
 *
 * @return current value of IMSC
 */
__DMA_SH_INLINE uint32_t DMA_SH_IMSC__GET(void)
{
    return HAL_GET32(__DMA_SH_IMSC__ADDRESS());
}

/* ------------------------ DMA_SH.IMSC.DMA_ERR_MSK ------------------------ */

/**
<pre>
  DMA_SH.IMSC.DMA_ERR_MSK:

    Mask bit for DMA Error Interrupt.

</pre> */

#define DMA_SH_IMSC__DMA_ERR_MSK__Pos                           31                                                                     /*!< Right-most bit position of DMA_ERR_MSK in DMA_SH.IMSC */
#define DMA_SH_IMSC__DMA_ERR_MSK__Msk                           (0x00000001UL << DMA_SH_IMSC__DMA_ERR_MSK__Pos)                        /*!< Mask for DMA_ERR_MSK in DMA_SH.IMSC */
#define DMA_SH_IMSC__DMA_ERR_MSK__Shift(v)                      (((v) << DMA_SH_IMSC__DMA_ERR_MSK__Pos) & DMA_SH_IMSC__DMA_ERR_MSK__Msk) /*!< Shift value 'v' into DMA_ERR_MSK and mask 'v' to fit it into DMA_ERR_MSK field */

/** DMA_SH_IMSC__DMA_ERR_MSK__SET() sets IMSC.DMA_ERR_MSK to given value.
 *
 * When writing to IMSC.DMA_ERR_MSK, this is recommended to use.
 *
 * @param bf_value new value for IMSC.DMA_ERR_MSK
 */
__DMA_SH_INLINE void DMA_SH_IMSC__DMA_ERR_MSK__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_IMSC__GET();
    reg = (reg & ~DMA_SH_IMSC__DMA_ERR_MSK__Msk);
    reg = (reg | (DMA_SH_IMSC__DMA_ERR_MSK__Shift((uint32_t)bf_value)));
    DMA_SH_IMSC__SET(reg);
}

/** DMA_SH_IMSC__DMA_ERR_MSK__GET() gets IMSC.DMA_ERR_MSK's current value.
 *
 * When reading from IMSC.DMA_ERR_MSK, this is recommended to use.
 *
 * @return current value of IMSC.DMA_ERR_MSK
 */
__DMA_SH_INLINE uint32_t DMA_SH_IMSC__DMA_ERR_MSK__GET(void)
{
    uint32_t reg = DMA_SH_IMSC__GET();
    reg = (reg & DMA_SH_IMSC__DMA_ERR_MSK__Msk);
    reg = (reg >> DMA_SH_IMSC__DMA_ERR_MSK__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_IMSC__DMA_ERR_MSK__MODIFY() modifies IMSC.DMA_ERR_MSK.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.IMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.IMSC
 * @param bf_value new value for IMSC.DMA_ERR_MSK
 * @return new value of DMA_SH.IMSC
 */
__DMA_SH_INLINE uint32_t DMA_SH_IMSC__DMA_ERR_MSK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_IMSC__DMA_ERR_MSK__Msk);
    reg = (reg | (DMA_SH_IMSC__DMA_ERR_MSK__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_IMSC__DMA_ERR_MSK__EXTRACT() extracts IMSC.DMA_ERR_MSK.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.IMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.IMSC
 * @return current value of IMSC.DMA_ERR_MSK
 */
__DMA_SH_INLINE uint32_t DMA_SH_IMSC__DMA_ERR_MSK__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_IMSC__DMA_ERR_MSK__Msk);
    reg = (reg >> DMA_SH_IMSC__DMA_ERR_MSK__Pos);
    return (uint32_t)reg;
}

/* ------------------------- DMA_SH.IMSC.DMA_CH_MSK ------------------------- */

/**
<pre>
  DMA_SH.IMSC.DMA_CH_MSK:

    Mask bit for DMA Channel_15 Interrupt.

</pre> */

#define DMA_SH_IMSC__DMA_CH_MSK__Pos                            0                                                                      /*!< Right-most bit position of DMA_CH_MSK in DMA_SH.IMSC */
#define DMA_SH_IMSC__DMA_CH_MSK__Msk                            (0x0000FFFFUL << DMA_SH_IMSC__DMA_CH_MSK__Pos)                         /*!< Mask for DMA_CH_MSK in DMA_SH.IMSC */
#define DMA_SH_IMSC__DMA_CH_MSK__Shift(v)                       (((v) << DMA_SH_IMSC__DMA_CH_MSK__Pos) & DMA_SH_IMSC__DMA_CH_MSK__Msk) /*!< Shift value 'v' into DMA_CH_MSK and mask 'v' to fit it into DMA_CH_MSK field */

/** DMA_SH_IMSC__DMA_CH_MSK__SET() sets IMSC.DMA_CH_MSK to given value.
 *
 * When writing to IMSC.DMA_CH_MSK, this is recommended to use.
 *
 * @param bf_value new value for IMSC.DMA_CH_MSK
 */
__DMA_SH_INLINE void DMA_SH_IMSC__DMA_CH_MSK__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_IMSC__GET();
    reg = (reg & ~DMA_SH_IMSC__DMA_CH_MSK__Msk);
    reg = (reg | (DMA_SH_IMSC__DMA_CH_MSK__Shift((uint32_t)bf_value)));
    DMA_SH_IMSC__SET(reg);
}

/** DMA_SH_IMSC__DMA_CH_MSK__GET() gets IMSC.DMA_CH_MSK's current value.
 *
 * When reading from IMSC.DMA_CH_MSK, this is recommended to use.
 *
 * @return current value of IMSC.DMA_CH_MSK
 */
__DMA_SH_INLINE uint32_t DMA_SH_IMSC__DMA_CH_MSK__GET(void)
{
    uint32_t reg = DMA_SH_IMSC__GET();
    reg = (reg & DMA_SH_IMSC__DMA_CH_MSK__Msk);
    reg = (reg >> DMA_SH_IMSC__DMA_CH_MSK__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_IMSC__DMA_CH_MSK__MODIFY() modifies IMSC.DMA_CH_MSK.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.IMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.IMSC
 * @param bf_value new value for IMSC.DMA_CH_MSK
 * @return new value of DMA_SH.IMSC
 */
__DMA_SH_INLINE uint32_t DMA_SH_IMSC__DMA_CH_MSK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_IMSC__DMA_CH_MSK__Msk);
    reg = (reg | (DMA_SH_IMSC__DMA_CH_MSK__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_IMSC__DMA_CH_MSK__EXTRACT() extracts IMSC.DMA_CH_MSK.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.IMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.IMSC
 * @return current value of IMSC.DMA_CH_MSK
 */
__DMA_SH_INLINE uint32_t DMA_SH_IMSC__DMA_CH_MSK__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_IMSC__DMA_CH_MSK__Msk);
    reg = (reg >> DMA_SH_IMSC__DMA_CH_MSK__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           MIS member of DMA_SH_t                           */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_MIS__ADDRESS returns the address of member MIS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MIS
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_MIS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, MIS)));
}

/** DMA_SH_MIS__GET() gets MIS's current value.
 *
 * When reading from MIS, this is mandatory to use.
 *
 * @return current value of MIS
 */
__DMA_SH_INLINE uint32_t DMA_SH_MIS__GET(void)
{
    return HAL_GET32(__DMA_SH_MIS__ADDRESS());
}

/* ------------------------- DMA_SH.MIS.DMA_ERR_INT ------------------------- */

/**
<pre>
  DMA_SH.MIS.DMA_ERR_INT:

    DMA Error Interrupt.

</pre> */

#define DMA_SH_MIS__DMA_ERR_INT__Pos                            31                                                                     /*!< Right-most bit position of DMA_ERR_INT in DMA_SH.MIS */
#define DMA_SH_MIS__DMA_ERR_INT__Msk                            (0x00000001UL << DMA_SH_MIS__DMA_ERR_INT__Pos)                         /*!< Mask for DMA_ERR_INT in DMA_SH.MIS */
#define DMA_SH_MIS__DMA_ERR_INT__Shift(v)                       (((v) << DMA_SH_MIS__DMA_ERR_INT__Pos) & DMA_SH_MIS__DMA_ERR_INT__Msk) /*!< Shift value 'v' into DMA_ERR_INT and mask 'v' to fit it into DMA_ERR_INT field */

/** DMA_SH_MIS__DMA_ERR_INT__GET() gets MIS.DMA_ERR_INT's current value.
 *
 * When reading from MIS.DMA_ERR_INT, this is recommended to use.
 *
 * @return current value of MIS.DMA_ERR_INT
 */
__DMA_SH_INLINE uint32_t DMA_SH_MIS__DMA_ERR_INT__GET(void)
{
    uint32_t reg = DMA_SH_MIS__GET();
    reg = (reg & DMA_SH_MIS__DMA_ERR_INT__Msk);
    reg = (reg >> DMA_SH_MIS__DMA_ERR_INT__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_MIS__DMA_ERR_INT__EXTRACT() extracts MIS.DMA_ERR_INT.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.MIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.MIS
 * @return current value of MIS.DMA_ERR_INT
 */
__DMA_SH_INLINE uint32_t DMA_SH_MIS__DMA_ERR_INT__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_MIS__DMA_ERR_INT__Msk);
    reg = (reg >> DMA_SH_MIS__DMA_ERR_INT__Pos);
    return (uint32_t)reg;
}

/* ------------------------- DMA_SH.MIS.DMA_CH_INT ------------------------- */

/**
<pre>
  DMA_SH.MIS.DMA_CH_INT:

    DMA Channel_15 Interrupt.

</pre> */

#define DMA_SH_MIS__DMA_CH_INT__Pos                             0                                                                      /*!< Right-most bit position of DMA_CH_INT in DMA_SH.MIS */
#define DMA_SH_MIS__DMA_CH_INT__Msk                             (0x0000FFFFUL << DMA_SH_MIS__DMA_CH_INT__Pos)                          /*!< Mask for DMA_CH_INT in DMA_SH.MIS */
#define DMA_SH_MIS__DMA_CH_INT__Shift(v)                        (((v) << DMA_SH_MIS__DMA_CH_INT__Pos) & DMA_SH_MIS__DMA_CH_INT__Msk)   /*!< Shift value 'v' into DMA_CH_INT and mask 'v' to fit it into DMA_CH_INT field */

/** DMA_SH_MIS__DMA_CH_INT__GET() gets MIS.DMA_CH_INT's current value.
 *
 * When reading from MIS.DMA_CH_INT, this is recommended to use.
 *
 * @return current value of MIS.DMA_CH_INT
 */
__DMA_SH_INLINE uint32_t DMA_SH_MIS__DMA_CH_INT__GET(void)
{
    uint32_t reg = DMA_SH_MIS__GET();
    reg = (reg & DMA_SH_MIS__DMA_CH_INT__Msk);
    reg = (reg >> DMA_SH_MIS__DMA_CH_INT__Pos);
    return (uint32_t)reg;
}

/** DMA_SH_MIS__DMA_CH_INT__EXTRACT() extracts MIS.DMA_CH_INT.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.MIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.MIS
 * @return current value of MIS.DMA_CH_INT
 */
__DMA_SH_INLINE uint32_t DMA_SH_MIS__DMA_CH_INT__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_MIS__DMA_CH_INT__Msk);
    reg = (reg >> DMA_SH_MIS__DMA_CH_INT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           ICR member of DMA_SH_t                           */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_ICR__ADDRESS returns the address of member ICR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ICR
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_ICR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, ICR)));
}

/** DMA_SH_ICR__SET() sets ICR to given value.
 *
 * When writing to ICR, this is mandatory to use.
 *
 * @param value new value for ICR
 */
__DMA_SH_INLINE void DMA_SH_ICR__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_ICR__ADDRESS(), value);
}


/* ----------------------- DMA_SH.ICR.DMA_ERR_INT_CLR ----------------------- */

/**
<pre>
  DMA_SH.ICR.DMA_ERR_INT_CLR:

    Clear bit for DMA Error Interrupt.

</pre> */

#define DMA_SH_ICR__DMA_ERR_INT_CLR__Pos                        31                                                                     /*!< Right-most bit position of DMA_ERR_INT_CLR in DMA_SH.ICR */
#define DMA_SH_ICR__DMA_ERR_INT_CLR__Msk                        (0x00000001UL << DMA_SH_ICR__DMA_ERR_INT_CLR__Pos)                     /*!< Mask for DMA_ERR_INT_CLR in DMA_SH.ICR */
#define DMA_SH_ICR__DMA_ERR_INT_CLR__Shift(v)                   (((v) << DMA_SH_ICR__DMA_ERR_INT_CLR__Pos) & DMA_SH_ICR__DMA_ERR_INT_CLR__Msk) /*!< Shift value 'v' into DMA_ERR_INT_CLR and mask 'v' to fit it into DMA_ERR_INT_CLR field */

/** DMA_SH_ICR__DMA_ERR_INT_CLR__SET() sets ICR.DMA_ERR_INT_CLR to given value.
 *
 * When writing to ICR.DMA_ERR_INT_CLR, this is recommended to use.
 *
 * @param bf_value new value for ICR.DMA_ERR_INT_CLR
 */
__DMA_SH_INLINE void DMA_SH_ICR__DMA_ERR_INT_CLR__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_ICR__DMA_ERR_INT_CLR__Shift((uint32_t)bf_value);
    DMA_SH_ICR__SET(reg);
}


/** DMA_SH_ICR__DMA_ERR_INT_CLR__MODIFY() modifies ICR.DMA_ERR_INT_CLR.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.ICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.ICR
 * @param bf_value new value for ICR.DMA_ERR_INT_CLR
 * @return new value of DMA_SH.ICR
 */
__DMA_SH_INLINE uint32_t DMA_SH_ICR__DMA_ERR_INT_CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_ICR__DMA_ERR_INT_CLR__Msk);
    reg = (reg | (DMA_SH_ICR__DMA_ERR_INT_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_ICR__DMA_ERR_INT_CLR__EXTRACT() extracts ICR.DMA_ERR_INT_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.ICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.ICR
 * @return current value of ICR.DMA_ERR_INT_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_ICR__DMA_ERR_INT_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_ICR__DMA_ERR_INT_CLR__Msk);
    reg = (reg >> DMA_SH_ICR__DMA_ERR_INT_CLR__Pos);
    return (uint32_t)reg;
}

/* ----------------------- DMA_SH.ICR.DMA_CH_INT_CLR ----------------------- */

/**
<pre>
  DMA_SH.ICR.DMA_CH_INT_CLR:

    Clear bit for DMA Channel_15 Interrupt.

</pre> */

#define DMA_SH_ICR__DMA_CH_INT_CLR__Pos                         0                                                                      /*!< Right-most bit position of DMA_CH_INT_CLR in DMA_SH.ICR */
#define DMA_SH_ICR__DMA_CH_INT_CLR__Msk                         (0x0000FFFFUL << DMA_SH_ICR__DMA_CH_INT_CLR__Pos)                      /*!< Mask for DMA_CH_INT_CLR in DMA_SH.ICR */
#define DMA_SH_ICR__DMA_CH_INT_CLR__Shift(v)                    (((v) << DMA_SH_ICR__DMA_CH_INT_CLR__Pos) & DMA_SH_ICR__DMA_CH_INT_CLR__Msk) /*!< Shift value 'v' into DMA_CH_INT_CLR and mask 'v' to fit it into DMA_CH_INT_CLR field */

/** DMA_SH_ICR__DMA_CH_INT_CLR__SET() sets ICR.DMA_CH_INT_CLR to given value.
 *
 * When writing to ICR.DMA_CH_INT_CLR, this is recommended to use.
 *
 * @param bf_value new value for ICR.DMA_CH_INT_CLR
 */
__DMA_SH_INLINE void DMA_SH_ICR__DMA_CH_INT_CLR__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_ICR__DMA_CH_INT_CLR__Shift((uint32_t)bf_value);
    DMA_SH_ICR__SET(reg);
}


/** DMA_SH_ICR__DMA_CH_INT_CLR__MODIFY() modifies ICR.DMA_CH_INT_CLR.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.ICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.ICR
 * @param bf_value new value for ICR.DMA_CH_INT_CLR
 * @return new value of DMA_SH.ICR
 */
__DMA_SH_INLINE uint32_t DMA_SH_ICR__DMA_CH_INT_CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_ICR__DMA_CH_INT_CLR__Msk);
    reg = (reg | (DMA_SH_ICR__DMA_CH_INT_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_ICR__DMA_CH_INT_CLR__EXTRACT() extracts ICR.DMA_CH_INT_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.ICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.ICR
 * @return current value of ICR.DMA_CH_INT_CLR
 */
__DMA_SH_INLINE uint32_t DMA_SH_ICR__DMA_CH_INT_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_ICR__DMA_CH_INT_CLR__Msk);
    reg = (reg >> DMA_SH_ICR__DMA_CH_INT_CLR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           ISR member of DMA_SH_t                           */
/* -------------------------------------------------------------------------- */

/** __DMA_SH_ISR__ADDRESS returns the address of member ISR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ISR
 */
__DMA_SH_INLINE uint32_t* __DMA_SH_ISR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__DMA_SH_BASE_PTR() + (uint32_t)(offsetof(DMA_SH_t, ISR)));
}

/** DMA_SH_ISR__SET() sets ISR to given value.
 *
 * When writing to ISR, this is mandatory to use.
 *
 * @param value new value for ISR
 */
__DMA_SH_INLINE void DMA_SH_ISR__SET(uint32_t value)
{
    HAL_SET32(__DMA_SH_ISR__ADDRESS(), value);
}


/* ----------------------- DMA_SH.ISR.DMA_ERR_INT_SET ----------------------- */

/**
<pre>
  DMA_SH.ISR.DMA_ERR_INT_SET:

    Set bit for DMA Error Interrupt.

</pre> */

#define DMA_SH_ISR__DMA_ERR_INT_SET__Pos                        31                                                                     /*!< Right-most bit position of DMA_ERR_INT_SET in DMA_SH.ISR */
#define DMA_SH_ISR__DMA_ERR_INT_SET__Msk                        (0x00000001UL << DMA_SH_ISR__DMA_ERR_INT_SET__Pos)                     /*!< Mask for DMA_ERR_INT_SET in DMA_SH.ISR */
#define DMA_SH_ISR__DMA_ERR_INT_SET__Shift(v)                   (((v) << DMA_SH_ISR__DMA_ERR_INT_SET__Pos) & DMA_SH_ISR__DMA_ERR_INT_SET__Msk) /*!< Shift value 'v' into DMA_ERR_INT_SET and mask 'v' to fit it into DMA_ERR_INT_SET field */

/** DMA_SH_ISR__DMA_ERR_INT_SET__SET() sets ISR.DMA_ERR_INT_SET to given value.
 *
 * When writing to ISR.DMA_ERR_INT_SET, this is recommended to use.
 *
 * @param bf_value new value for ISR.DMA_ERR_INT_SET
 */
__DMA_SH_INLINE void DMA_SH_ISR__DMA_ERR_INT_SET__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_ISR__DMA_ERR_INT_SET__Shift((uint32_t)bf_value);
    DMA_SH_ISR__SET(reg);
}


/** DMA_SH_ISR__DMA_ERR_INT_SET__MODIFY() modifies ISR.DMA_ERR_INT_SET.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.ISR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.ISR
 * @param bf_value new value for ISR.DMA_ERR_INT_SET
 * @return new value of DMA_SH.ISR
 */
__DMA_SH_INLINE uint32_t DMA_SH_ISR__DMA_ERR_INT_SET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_ISR__DMA_ERR_INT_SET__Msk);
    reg = (reg | (DMA_SH_ISR__DMA_ERR_INT_SET__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_ISR__DMA_ERR_INT_SET__EXTRACT() extracts ISR.DMA_ERR_INT_SET.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.ISR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.ISR
 * @return current value of ISR.DMA_ERR_INT_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_ISR__DMA_ERR_INT_SET__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_ISR__DMA_ERR_INT_SET__Msk);
    reg = (reg >> DMA_SH_ISR__DMA_ERR_INT_SET__Pos);
    return (uint32_t)reg;
}

/* ----------------------- DMA_SH.ISR.DMA_CH_INT_SET ----------------------- */

/**
<pre>
  DMA_SH.ISR.DMA_CH_INT_SET:

    Set bit for DMA Channel_15 Interrupt.

</pre> */

#define DMA_SH_ISR__DMA_CH_INT_SET__Pos                         0                                                                      /*!< Right-most bit position of DMA_CH_INT_SET in DMA_SH.ISR */
#define DMA_SH_ISR__DMA_CH_INT_SET__Msk                         (0x0000FFFFUL << DMA_SH_ISR__DMA_CH_INT_SET__Pos)                      /*!< Mask for DMA_CH_INT_SET in DMA_SH.ISR */
#define DMA_SH_ISR__DMA_CH_INT_SET__Shift(v)                    (((v) << DMA_SH_ISR__DMA_CH_INT_SET__Pos) & DMA_SH_ISR__DMA_CH_INT_SET__Msk) /*!< Shift value 'v' into DMA_CH_INT_SET and mask 'v' to fit it into DMA_CH_INT_SET field */

/** DMA_SH_ISR__DMA_CH_INT_SET__SET() sets ISR.DMA_CH_INT_SET to given value.
 *
 * When writing to ISR.DMA_CH_INT_SET, this is recommended to use.
 *
 * @param bf_value new value for ISR.DMA_CH_INT_SET
 */
__DMA_SH_INLINE void DMA_SH_ISR__DMA_CH_INT_SET__SET(uint32_t bf_value)
{
    uint32_t reg = DMA_SH_ISR__DMA_CH_INT_SET__Shift((uint32_t)bf_value);
    DMA_SH_ISR__SET(reg);
}


/** DMA_SH_ISR__DMA_CH_INT_SET__MODIFY() modifies ISR.DMA_CH_INT_SET.
 *
 * This is recommended to use when setting more than one bitfield of DMA_SH.ISR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DMA_SH.ISR
 * @param bf_value new value for ISR.DMA_CH_INT_SET
 * @return new value of DMA_SH.ISR
 */
__DMA_SH_INLINE uint32_t DMA_SH_ISR__DMA_CH_INT_SET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DMA_SH_ISR__DMA_CH_INT_SET__Msk);
    reg = (reg | (DMA_SH_ISR__DMA_CH_INT_SET__Shift((uint32_t)bf_value)));
    return reg;
}

/** DMA_SH_ISR__DMA_CH_INT_SET__EXTRACT() extracts ISR.DMA_CH_INT_SET.
 *
 * This is recommended to use when extracting more than one bitfield from DMA_SH.ISR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DMA_SH.ISR
 * @return current value of ISR.DMA_CH_INT_SET
 */
__DMA_SH_INLINE uint32_t DMA_SH_ISR__DMA_CH_INT_SET__EXTRACT(uint32_t reg)
{
    reg = (reg & DMA_SH_ISR__DMA_CH_INT_SET__Msk);
    reg = (reg >> DMA_SH_ISR__DMA_CH_INT_SET__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group dma_sh block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_DMA_SH_H_ */
