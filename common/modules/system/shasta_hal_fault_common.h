/**
 * @file     shasta_hal_fault_common.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_FAULT_COMMON_H_
#define _SHASTA_HAL_FAULT_COMMON_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup faultcom
 * @{
 */

#if defined ( __CC_ARM )
#define __FAULTCOM_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __FAULTCOM_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __FAULTCOM_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __FAULTCOM_INLINE  static inline
#endif

/** register file of the faultcom block.
 */
typedef struct _FAULTCOM_s
{
    volatile        uint32_t        FAULT_SHUT_MASK_COM         ; /*!< (@0x00000000) Shutdown mask for "Common" faults.  Individual faults are enabled for shutdown when their corresponding bit is high.  Enabled faults disable both loop outpu...(more) */
    volatile        uint32_t        FAULT_BLOCK_ON_SHUT         ; /*!< (@0x00000004) Defines whether faults continued to be reported after an initial shutdown fault has occurred and triggered shutdown. <start table> 0 "Fault reporting contin...(more) */
    volatile        uint32_t        FAULT_ENABLE_COM            ; /*!< (@0x00000008) Fault enable for "Common" faults.  Individual faults are enabled for fault interrupt generation when their corresponding bit is high.  This register is cont...(more) */
    volatile        uint32_t        FAULT_SHUT_CLR_ALL          ; /*!< (@0x0000000C) Clears shutdown faults in fault_reg_com and both fault_reg_loop registers when high.  This field should not be written until after FW has completed shutdown...(more) */
    volatile        uint32_t        FAULT_SHUT_CLR_COM          ; /*!< (@0x00000010) Clears shutdown faults in fault_reg_com when set high. This field should not be written until after FW has completed shutdown related cleanup (e.g., Vcontro...(more) */
    volatile        uint32_t        FAULT_SHUT_IRQ_BUS          ; /*!< (@0x00000014) Shutdown interrupt (IRQ) status <start table_with_header> Bit IRQ 0 "Loop 0 fault" 1 "Loop 1 fault" 2 "Common fault" <end table> */
    volatile        uint32_t        FAULT_FORCE_COM             ; /*!< (@0x00000018) Fault force set register.  When the bit corresponding to a fault or warning is set to 1, that fault or warning is asserted as if it had exceeded its thresho...(more) */
    volatile        uint32_t        FAULT_CLEAR_COM             ; /*!< (@0x0000001C) Fault force clear register.  When the bit corresponding to a fault or warning is set to 1, that fault or warning is cleared in the fault_status_loop and fau...(more) */
    volatile        uint32_t        FAULT_STATUS_COM            ; /*!< (@0x00000020) Fault status register generated by sub-sampling fault_reg_com at 2MHz.  Fault interrupts are generated from this register.  Once a fault bit is set it is la...(more) */
    volatile        uint32_t        FAULT_ENCODE                ; /*!< (@0x00000024) Priority encoding of the word {fault_status_com[31:0],fault1_status_loop[31:0],fault0_status_loop[31:0]} with fault_encode indicating the position of the fi...(more) */
    volatile        uint32_t        FAULT_REG_COM               ; /*!< (@0x00000028) Fault status register updated at 50MHz.  Once a fault bit is set it is latched in this register and can only be cleared via fault_clear_com. <start table_wi...(more) */
} FAULTCOM_t;


#define FAULTCOM_BASE (0x70005400u)                                                          /*!< faultcom base address */

/** __FAULTCOM_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_BASE_PTR(void)
{
    return (uint32_t*)(FAULTCOM_BASE);
}


/* -------------------------------------------------------------------------- */
/*                  FAULT_SHUT_MASK_COM member of FAULTCOM_t                  */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_SHUT_MASK_COM__ADDRESS returns the address of member FAULT_SHUT_MASK_COM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_SHUT_MASK_COM
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_SHUT_MASK_COM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_SHUT_MASK_COM)));
}

/** FAULTCOM_FAULT_SHUT_MASK_COM__SET() sets FAULT_SHUT_MASK_COM to given value.
 *
 * When writing to FAULT_SHUT_MASK_COM, this is mandatory to use.
 *
 * @param value new value for FAULT_SHUT_MASK_COM
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_SHUT_MASK_COM__SET(uint32_t value)
{
    HAL_SET32(__FAULTCOM_FAULT_SHUT_MASK_COM__ADDRESS(), value);
}

/** FAULTCOM_FAULT_SHUT_MASK_COM__GET() gets FAULT_SHUT_MASK_COM's current value.
 *
 * When reading from FAULT_SHUT_MASK_COM, this is mandatory to use.
 *
 * @return current value of FAULT_SHUT_MASK_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_MASK_COM__GET(void)
{
    return HAL_GET32(__FAULTCOM_FAULT_SHUT_MASK_COM__ADDRESS());
}

/* ------------ FAULTCOM.FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM ------------ */

/**
<pre>
  FAULTCOM.FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM:

    Shutdown mask for "Common" faults.  Individual faults are enabled for shutdown when their corresponding bit is high.  Enabled faults disable both loop outputs and assert the shutdown interrupt.
    <start table_with_header>
    Bit Fault Bit Fault
    0 unused 1 unused
    2 "IS1 (ISEN) tracking fault" 3 "IS2 (BISEN) tracking fault"
    4 "Fbal1 fault" 5 "IS1 (ISEN) PCL fault"
    6 "IS1 (ISEN) SCP fault" 7 "Fbal2 fault"
    8 "IS2 (BISEN) PCL fault" 9 "IS2 (BISEN) SCP fault"
    10 unused 11 "VREF open fault"
    12 "VSEN open fault" 13 unused
    14 "VRREF open fault" 15 "VRSEN open fault"
    16 unused 17 "BVREF_BVRREF open fault"
    18 "BVSEN_BVRSEN open fault" 19-31 unused
    <end table>

</pre> */

#define FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Pos  0                                                                      /*!< Right-most bit position of fault_shut_mask_com in FAULTCOM.FAULT_SHUT_MASK_COM */
#define FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Msk  (0xFFFFFFFFUL << FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Pos) /*!< Mask for fault_shut_mask_com in FAULTCOM.FAULT_SHUT_MASK_COM */
#define FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Shift(v) (((v) << FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Pos) & FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Msk) /*!< Shift value 'v' into fault_shut_mask_com and mask 'v' to fit it into fault_shut_mask_com field */

/** FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__SET() sets FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM to given value.
 *
 * When writing to FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM, this is recommended to use.
 *
 * @param bf_value new value for FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__SET(uint32_t bf_value)
{
    uint32_t reg = FAULTCOM_FAULT_SHUT_MASK_COM__GET();
    reg = (reg & ~FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Msk);
    reg = (reg | (FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Shift((uint32_t)bf_value)));
    FAULTCOM_FAULT_SHUT_MASK_COM__SET(reg);
}

/** FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__GET() gets FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM's current value.
 *
 * When reading from FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM, this is recommended to use.
 *
 * @return current value of FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__GET(void)
{
    uint32_t reg = FAULTCOM_FAULT_SHUT_MASK_COM__GET();
    reg = (reg & FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Pos);
    return (uint32_t)reg;
}

/** FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__MODIFY() modifies FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM.
 *
 * This is recommended to use when setting more than one bitfield of FAULTCOM.FAULT_SHUT_MASK_COM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULTCOM.FAULT_SHUT_MASK_COM
 * @param bf_value new value for FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM
 * @return new value of FAULTCOM.FAULT_SHUT_MASK_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Msk);
    reg = (reg | (FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__EXTRACT() extracts FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_SHUT_MASK_COM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_SHUT_MASK_COM
 * @return current value of FAULT_SHUT_MASK_COM.FAULT_SHUT_MASK_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_SHUT_MASK_COM__FAULT_SHUT_MASK_COM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  FAULT_BLOCK_ON_SHUT member of FAULTCOM_t                  */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_BLOCK_ON_SHUT__ADDRESS returns the address of member FAULT_BLOCK_ON_SHUT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_BLOCK_ON_SHUT
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_BLOCK_ON_SHUT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_BLOCK_ON_SHUT)));
}

/** FAULTCOM_FAULT_BLOCK_ON_SHUT__SET() sets FAULT_BLOCK_ON_SHUT to given value.
 *
 * When writing to FAULT_BLOCK_ON_SHUT, this is mandatory to use.
 *
 * @param value new value for FAULT_BLOCK_ON_SHUT
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_BLOCK_ON_SHUT__SET(uint32_t value)
{
    HAL_SET32(__FAULTCOM_FAULT_BLOCK_ON_SHUT__ADDRESS(), value);
}

/** FAULTCOM_FAULT_BLOCK_ON_SHUT__GET() gets FAULT_BLOCK_ON_SHUT's current value.
 *
 * When reading from FAULT_BLOCK_ON_SHUT, this is mandatory to use.
 *
 * @return current value of FAULT_BLOCK_ON_SHUT
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_BLOCK_ON_SHUT__GET(void)
{
    return HAL_GET32(__FAULTCOM_FAULT_BLOCK_ON_SHUT__ADDRESS());
}

/* ------------ FAULTCOM.FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT ------------ */

/**
<pre>
  FAULTCOM.FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT:

    Defines whether faults continued to be reported after an initial shutdown fault has occurred and triggered shutdown.
    <start table>
    0 "Fault reporting continues after shutdown fault."
    1 "Fault reporting blocked on new faults after initial shutdown fault occurs.  Fault will continue to be blocked until the shutdown fault is cleared via fault_shut_clr_loop, fault_shut_clr_com or fault_shut_clr_all."
    <end table>

</pre> */

#define FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Pos  0                                                                      /*!< Right-most bit position of fault_block_on_shut in FAULTCOM.FAULT_BLOCK_ON_SHUT */
#define FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Msk  (0x00000001UL << FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Pos) /*!< Mask for fault_block_on_shut in FAULTCOM.FAULT_BLOCK_ON_SHUT */
#define FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Shift(v) (((v) << FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Pos) & FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Msk) /*!< Shift value 'v' into fault_block_on_shut and mask 'v' to fit it into fault_block_on_shut field */

/** FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__SET() sets FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT to given value.
 *
 * When writing to FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT, this is recommended to use.
 *
 * @param bf_value new value for FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__SET(uint32_t bf_value)
{
    uint32_t reg = FAULTCOM_FAULT_BLOCK_ON_SHUT__GET();
    reg = (reg & ~FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Msk);
    reg = (reg | (FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Shift((uint32_t)bf_value)));
    FAULTCOM_FAULT_BLOCK_ON_SHUT__SET(reg);
}

/** FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__GET() gets FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT's current value.
 *
 * When reading from FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT, this is recommended to use.
 *
 * @return current value of FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__GET(void)
{
    uint32_t reg = FAULTCOM_FAULT_BLOCK_ON_SHUT__GET();
    reg = (reg & FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Msk);
    reg = (reg >> FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Pos);
    return (uint32_t)reg;
}

/** FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__MODIFY() modifies FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT.
 *
 * This is recommended to use when setting more than one bitfield of FAULTCOM.FAULT_BLOCK_ON_SHUT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULTCOM.FAULT_BLOCK_ON_SHUT
 * @param bf_value new value for FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT
 * @return new value of FAULTCOM.FAULT_BLOCK_ON_SHUT
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Msk);
    reg = (reg | (FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__EXTRACT() extracts FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_BLOCK_ON_SHUT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_BLOCK_ON_SHUT
 * @return current value of FAULT_BLOCK_ON_SHUT.FAULT_BLOCK_ON_SHUT
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Msk);
    reg = (reg >> FAULTCOM_FAULT_BLOCK_ON_SHUT__FAULT_BLOCK_ON_SHUT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   FAULT_ENABLE_COM member of FAULTCOM_t                   */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_ENABLE_COM__ADDRESS returns the address of member FAULT_ENABLE_COM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_ENABLE_COM
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_ENABLE_COM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_ENABLE_COM)));
}

/** FAULTCOM_FAULT_ENABLE_COM__SET() sets FAULT_ENABLE_COM to given value.
 *
 * When writing to FAULT_ENABLE_COM, this is mandatory to use.
 *
 * @param value new value for FAULT_ENABLE_COM
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_ENABLE_COM__SET(uint32_t value)
{
    HAL_SET32(__FAULTCOM_FAULT_ENABLE_COM__ADDRESS(), value);
}

/** FAULTCOM_FAULT_ENABLE_COM__GET() gets FAULT_ENABLE_COM's current value.
 *
 * When reading from FAULT_ENABLE_COM, this is mandatory to use.
 *
 * @return current value of FAULT_ENABLE_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_ENABLE_COM__GET(void)
{
    return HAL_GET32(__FAULTCOM_FAULT_ENABLE_COM__ADDRESS());
}

/* --------------- FAULTCOM.FAULT_ENABLE_COM.FAULT_ENABLE_COM --------------- */

/**
<pre>
  FAULTCOM.FAULT_ENABLE_COM.FAULT_ENABLE_COM:

    Fault enable for "Common" faults.  Individual faults are enabled for fault interrupt generation when their corresponding bit is high.  This register is controlled by FW based on the PMBus command FW_CONFIG_FAULTS bits [167:136] which have a 1 to 1 mapping with bits [31:0] of this register.
    <start table_with_header>
    Bit Fault Bit Fault
    0 unused 1 unused
    2 "IS1 (ISEN) tracking fault" 3 "IS2 (BISEN) tracking fault"
    4 "Fbal1 fault" 5 "IS1 (ISEN) PCL fault"
    6 "IS1 (ISEN) SCP fault" 7 "Fbal2 fault"
    8 "IS2 (BISEN) PCL fault" 9 "IS2 (BISEN) SCP fault"
    10 unused 11 "VREF open fault"
    12 "VSEN open fault" 13 unused
    14 "VRREF open fault" 15 "VRSEN open fault"
    16 unused 17 "BVREF_BVRREF open fault"
    18 "BVSEN_BVRSEN open fault" 19-31 unused
    <end table>

</pre> */

#define FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Pos        0                                                                      /*!< Right-most bit position of fault_enable_com in FAULTCOM.FAULT_ENABLE_COM */
#define FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Msk        (0xFFFFFFFFUL << FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Pos)     /*!< Mask for fault_enable_com in FAULTCOM.FAULT_ENABLE_COM */
#define FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Shift(v)   (((v) << FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Pos) & FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Msk) /*!< Shift value 'v' into fault_enable_com and mask 'v' to fit it into fault_enable_com field */

/** FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__SET() sets FAULT_ENABLE_COM.FAULT_ENABLE_COM to given value.
 *
 * When writing to FAULT_ENABLE_COM.FAULT_ENABLE_COM, this is recommended to use.
 *
 * @param bf_value new value for FAULT_ENABLE_COM.FAULT_ENABLE_COM
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__SET(uint32_t bf_value)
{
    uint32_t reg = FAULTCOM_FAULT_ENABLE_COM__GET();
    reg = (reg & ~FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Msk);
    reg = (reg | (FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Shift((uint32_t)bf_value)));
    FAULTCOM_FAULT_ENABLE_COM__SET(reg);
}

/** FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__GET() gets FAULT_ENABLE_COM.FAULT_ENABLE_COM's current value.
 *
 * When reading from FAULT_ENABLE_COM.FAULT_ENABLE_COM, this is recommended to use.
 *
 * @return current value of FAULT_ENABLE_COM.FAULT_ENABLE_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__GET(void)
{
    uint32_t reg = FAULTCOM_FAULT_ENABLE_COM__GET();
    reg = (reg & FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Pos);
    return (uint32_t)reg;
}

/** FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__MODIFY() modifies FAULT_ENABLE_COM.FAULT_ENABLE_COM.
 *
 * This is recommended to use when setting more than one bitfield of FAULTCOM.FAULT_ENABLE_COM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULTCOM.FAULT_ENABLE_COM
 * @param bf_value new value for FAULT_ENABLE_COM.FAULT_ENABLE_COM
 * @return new value of FAULTCOM.FAULT_ENABLE_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Msk);
    reg = (reg | (FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__EXTRACT() extracts FAULT_ENABLE_COM.FAULT_ENABLE_COM.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_ENABLE_COM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_ENABLE_COM
 * @return current value of FAULT_ENABLE_COM.FAULT_ENABLE_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_ENABLE_COM__FAULT_ENABLE_COM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  FAULT_SHUT_CLR_ALL member of FAULTCOM_t                  */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_SHUT_CLR_ALL__ADDRESS returns the address of member FAULT_SHUT_CLR_ALL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_SHUT_CLR_ALL
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_SHUT_CLR_ALL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_SHUT_CLR_ALL)));
}

/** FAULTCOM_FAULT_SHUT_CLR_ALL__SET() sets FAULT_SHUT_CLR_ALL to given value.
 *
 * When writing to FAULT_SHUT_CLR_ALL, this is mandatory to use.
 *
 * @param value new value for FAULT_SHUT_CLR_ALL
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_SHUT_CLR_ALL__SET(uint32_t value)
{
    HAL_SET32(__FAULTCOM_FAULT_SHUT_CLR_ALL__ADDRESS(), value);
}


/* ------------- FAULTCOM.FAULT_SHUT_CLR_ALL.FAULT_SHUT_CLR_ALL ------------- */

/**
<pre>
  FAULTCOM.FAULT_SHUT_CLR_ALL.FAULT_SHUT_CLR_ALL:

    Clears shutdown faults in fault_reg_com and both fault_reg_loop registers when high.  This field should not be written until after FW has completed shutdown related cleanup (e.g., Vcontrol target returned to 0, appropriate blocks disabled).

</pre> */

#define FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Pos    0                                                                      /*!< Right-most bit position of fault_shut_clr_all in FAULTCOM.FAULT_SHUT_CLR_ALL */
#define FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Msk    (0x00000001UL << FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Pos) /*!< Mask for fault_shut_clr_all in FAULTCOM.FAULT_SHUT_CLR_ALL */
#define FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Shift(v) (((v) << FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Pos) & FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Msk) /*!< Shift value 'v' into fault_shut_clr_all and mask 'v' to fit it into fault_shut_clr_all field */

/** FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__SET() sets FAULT_SHUT_CLR_ALL.FAULT_SHUT_CLR_ALL to given value.
 *
 * When writing to FAULT_SHUT_CLR_ALL.FAULT_SHUT_CLR_ALL, this is recommended to use.
 *
 * @param bf_value new value for FAULT_SHUT_CLR_ALL.FAULT_SHUT_CLR_ALL
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__SET(uint32_t bf_value)
{
    uint32_t reg = FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Shift((uint32_t)bf_value);
    FAULTCOM_FAULT_SHUT_CLR_ALL__SET(reg);
}


/** FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__MODIFY() modifies FAULT_SHUT_CLR_ALL.FAULT_SHUT_CLR_ALL.
 *
 * This is recommended to use when setting more than one bitfield of FAULTCOM.FAULT_SHUT_CLR_ALL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULTCOM.FAULT_SHUT_CLR_ALL
 * @param bf_value new value for FAULT_SHUT_CLR_ALL.FAULT_SHUT_CLR_ALL
 * @return new value of FAULTCOM.FAULT_SHUT_CLR_ALL
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Msk);
    reg = (reg | (FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__EXTRACT() extracts FAULT_SHUT_CLR_ALL.FAULT_SHUT_CLR_ALL.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_SHUT_CLR_ALL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_SHUT_CLR_ALL
 * @return current value of FAULT_SHUT_CLR_ALL.FAULT_SHUT_CLR_ALL
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Msk);
    reg = (reg >> FAULTCOM_FAULT_SHUT_CLR_ALL__FAULT_SHUT_CLR_ALL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  FAULT_SHUT_CLR_COM member of FAULTCOM_t                  */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_SHUT_CLR_COM__ADDRESS returns the address of member FAULT_SHUT_CLR_COM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_SHUT_CLR_COM
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_SHUT_CLR_COM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_SHUT_CLR_COM)));
}

/** FAULTCOM_FAULT_SHUT_CLR_COM__SET() sets FAULT_SHUT_CLR_COM to given value.
 *
 * When writing to FAULT_SHUT_CLR_COM, this is mandatory to use.
 *
 * @param value new value for FAULT_SHUT_CLR_COM
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_SHUT_CLR_COM__SET(uint32_t value)
{
    HAL_SET32(__FAULTCOM_FAULT_SHUT_CLR_COM__ADDRESS(), value);
}


/* ------------- FAULTCOM.FAULT_SHUT_CLR_COM.FAULT_SHUT_CLR_COM ------------- */

/**
<pre>
  FAULTCOM.FAULT_SHUT_CLR_COM.FAULT_SHUT_CLR_COM:

    Clears shutdown faults in fault_reg_com when set high. This field should not be written until after FW has completed shutdown related cleanup (e.g., Vcontrol target returned to 0, appropriate blocks disabled).

</pre> */

#define FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Pos    0                                                                      /*!< Right-most bit position of fault_shut_clr_com in FAULTCOM.FAULT_SHUT_CLR_COM */
#define FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Msk    (0x00000001UL << FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Pos) /*!< Mask for fault_shut_clr_com in FAULTCOM.FAULT_SHUT_CLR_COM */
#define FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Shift(v) (((v) << FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Pos) & FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Msk) /*!< Shift value 'v' into fault_shut_clr_com and mask 'v' to fit it into fault_shut_clr_com field */

/** FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__SET() sets FAULT_SHUT_CLR_COM.FAULT_SHUT_CLR_COM to given value.
 *
 * When writing to FAULT_SHUT_CLR_COM.FAULT_SHUT_CLR_COM, this is recommended to use.
 *
 * @param bf_value new value for FAULT_SHUT_CLR_COM.FAULT_SHUT_CLR_COM
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__SET(uint32_t bf_value)
{
    uint32_t reg = FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Shift((uint32_t)bf_value);
    FAULTCOM_FAULT_SHUT_CLR_COM__SET(reg);
}


/** FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__MODIFY() modifies FAULT_SHUT_CLR_COM.FAULT_SHUT_CLR_COM.
 *
 * This is recommended to use when setting more than one bitfield of FAULTCOM.FAULT_SHUT_CLR_COM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULTCOM.FAULT_SHUT_CLR_COM
 * @param bf_value new value for FAULT_SHUT_CLR_COM.FAULT_SHUT_CLR_COM
 * @return new value of FAULTCOM.FAULT_SHUT_CLR_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Msk);
    reg = (reg | (FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__EXTRACT() extracts FAULT_SHUT_CLR_COM.FAULT_SHUT_CLR_COM.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_SHUT_CLR_COM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_SHUT_CLR_COM
 * @return current value of FAULT_SHUT_CLR_COM.FAULT_SHUT_CLR_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_SHUT_CLR_COM__FAULT_SHUT_CLR_COM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  FAULT_SHUT_IRQ_BUS member of FAULTCOM_t                  */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_SHUT_IRQ_BUS__ADDRESS returns the address of member FAULT_SHUT_IRQ_BUS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_SHUT_IRQ_BUS
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_SHUT_IRQ_BUS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_SHUT_IRQ_BUS)));
}

/** FAULTCOM_FAULT_SHUT_IRQ_BUS__GET() gets FAULT_SHUT_IRQ_BUS's current value.
 *
 * When reading from FAULT_SHUT_IRQ_BUS, this is mandatory to use.
 *
 * @return current value of FAULT_SHUT_IRQ_BUS
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_IRQ_BUS__GET(void)
{
    return HAL_GET32(__FAULTCOM_FAULT_SHUT_IRQ_BUS__ADDRESS());
}

/* --------------- FAULTCOM.FAULT_SHUT_IRQ_BUS.FAULT_IRQ_BUS --------------- */

/**
<pre>
  FAULTCOM.FAULT_SHUT_IRQ_BUS.FAULT_IRQ_BUS:

    Fault interrupt (IRQ) status
    <start table_with_header>
    Bit IRQ
    0 "Loop 0 fault"
    1 "Loop 1 fault"
    2 "Common fault"
    <end table>

</pre> */

#define FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__Pos         3                                                                      /*!< Right-most bit position of fault_irq_bus in FAULTCOM.FAULT_SHUT_IRQ_BUS */
#define FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__Msk         (0x00000007UL << FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__Pos)      /*!< Mask for fault_irq_bus in FAULTCOM.FAULT_SHUT_IRQ_BUS */
#define FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__Shift(v)    (((v) << FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__Pos) & FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__Msk) /*!< Shift value 'v' into fault_irq_bus and mask 'v' to fit it into fault_irq_bus field */

/** FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__GET() gets FAULT_SHUT_IRQ_BUS.FAULT_IRQ_BUS's current value.
 *
 * When reading from FAULT_SHUT_IRQ_BUS.FAULT_IRQ_BUS, this is recommended to use.
 *
 * @return current value of FAULT_SHUT_IRQ_BUS.FAULT_IRQ_BUS
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__GET(void)
{
    uint32_t reg = FAULTCOM_FAULT_SHUT_IRQ_BUS__GET();
    reg = (reg & FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__Msk);
    reg = (reg >> FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__Pos);
    return (uint32_t)reg;
}

/** FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__EXTRACT() extracts FAULT_SHUT_IRQ_BUS.FAULT_IRQ_BUS.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_SHUT_IRQ_BUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_SHUT_IRQ_BUS
 * @return current value of FAULT_SHUT_IRQ_BUS.FAULT_IRQ_BUS
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__Msk);
    reg = (reg >> FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_IRQ_BUS__Pos);
    return (uint32_t)reg;
}

/* --------------- FAULTCOM.FAULT_SHUT_IRQ_BUS.FAULT_SHUT_BUS --------------- */

/**
<pre>
  FAULTCOM.FAULT_SHUT_IRQ_BUS.FAULT_SHUT_BUS:

    Shutdown interrupt (IRQ) status
    <start table_with_header>
    Bit IRQ
    0 "Loop 0 fault"
    1 "Loop 1 fault"
    2 "Common fault"
    <end table>

</pre> */

#define FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__Pos        0                                                                      /*!< Right-most bit position of fault_shut_bus in FAULTCOM.FAULT_SHUT_IRQ_BUS */
#define FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__Msk        (0x00000007UL << FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__Pos)     /*!< Mask for fault_shut_bus in FAULTCOM.FAULT_SHUT_IRQ_BUS */
#define FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__Shift(v)   (((v) << FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__Pos) & FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__Msk) /*!< Shift value 'v' into fault_shut_bus and mask 'v' to fit it into fault_shut_bus field */

/** FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__GET() gets FAULT_SHUT_IRQ_BUS.FAULT_SHUT_BUS's current value.
 *
 * When reading from FAULT_SHUT_IRQ_BUS.FAULT_SHUT_BUS, this is recommended to use.
 *
 * @return current value of FAULT_SHUT_IRQ_BUS.FAULT_SHUT_BUS
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__GET(void)
{
    uint32_t reg = FAULTCOM_FAULT_SHUT_IRQ_BUS__GET();
    reg = (reg & FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__Msk);
    reg = (reg >> FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__Pos);
    return (uint32_t)reg;
}

/** FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__EXTRACT() extracts FAULT_SHUT_IRQ_BUS.FAULT_SHUT_BUS.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_SHUT_IRQ_BUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_SHUT_IRQ_BUS
 * @return current value of FAULT_SHUT_IRQ_BUS.FAULT_SHUT_BUS
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__Msk);
    reg = (reg >> FAULTCOM_FAULT_SHUT_IRQ_BUS__FAULT_SHUT_BUS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_FORCE_COM member of FAULTCOM_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_FORCE_COM__ADDRESS returns the address of member FAULT_FORCE_COM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_FORCE_COM
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_FORCE_COM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_FORCE_COM)));
}

/** FAULTCOM_FAULT_FORCE_COM__SET() sets FAULT_FORCE_COM to given value.
 *
 * When writing to FAULT_FORCE_COM, this is mandatory to use.
 *
 * @param value new value for FAULT_FORCE_COM
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_FORCE_COM__SET(uint32_t value)
{
    HAL_SET32(__FAULTCOM_FAULT_FORCE_COM__ADDRESS(), value);
}

/** FAULTCOM_FAULT_FORCE_COM__GET() gets FAULT_FORCE_COM's current value.
 *
 * When reading from FAULT_FORCE_COM, this is mandatory to use.
 *
 * @return current value of FAULT_FORCE_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_FORCE_COM__GET(void)
{
    return HAL_GET32(__FAULTCOM_FAULT_FORCE_COM__ADDRESS());
}

/* ---------------- FAULTCOM.FAULT_FORCE_COM.FAULT_FORCE_COM ---------------- */

/**
<pre>
  FAULTCOM.FAULT_FORCE_COM.FAULT_FORCE_COM:

    Fault force set register.  When the bit corresponding to a fault or warning is set to 1, that fault or warning is asserted as if it had exceeded its threshold.
    <start table_with_header>
    Bit Fault Bit Fault
    0 unused 1 unused
    2 "IS1 (ISEN) tracking fault" 3 "IS2 (BISEN) tracking fault"
    4 "Fbal1 fault" 5 "IS1 (ISEN) PCL fault"
    6 "IS1 (ISEN) SCP fault" 7 "Fbal2 fault"
    8 "IS2 (BISEN) PCL fault" 9 "IS2 (BISEN) SCP fault"
    10 unused 11 "VREF open fault"
    12 "VSEN open fault" 13 unused
    14 "VRREF open fault" 15 "VRSEN open fault"
    16 unused 17 "BVREF_BVRREF open fault"
    18 "BVSEN_BVRSEN open fault" 19-31 unused
    <end table>

</pre> */

#define FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Pos          0                                                                      /*!< Right-most bit position of fault_force_com in FAULTCOM.FAULT_FORCE_COM */
#define FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Msk          (0xFFFFFFFFUL << FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Pos)       /*!< Mask for fault_force_com in FAULTCOM.FAULT_FORCE_COM */
#define FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Shift(v)     (((v) << FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Pos) & FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Msk) /*!< Shift value 'v' into fault_force_com and mask 'v' to fit it into fault_force_com field */

/** FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__SET() sets FAULT_FORCE_COM.FAULT_FORCE_COM to given value.
 *
 * When writing to FAULT_FORCE_COM.FAULT_FORCE_COM, this is recommended to use.
 *
 * @param bf_value new value for FAULT_FORCE_COM.FAULT_FORCE_COM
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__SET(uint32_t bf_value)
{
    uint32_t reg = FAULTCOM_FAULT_FORCE_COM__GET();
    reg = (reg & ~FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Msk);
    reg = (reg | (FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Shift((uint32_t)bf_value)));
    FAULTCOM_FAULT_FORCE_COM__SET(reg);
}

/** FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__GET() gets FAULT_FORCE_COM.FAULT_FORCE_COM's current value.
 *
 * When reading from FAULT_FORCE_COM.FAULT_FORCE_COM, this is recommended to use.
 *
 * @return current value of FAULT_FORCE_COM.FAULT_FORCE_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__GET(void)
{
    uint32_t reg = FAULTCOM_FAULT_FORCE_COM__GET();
    reg = (reg & FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Pos);
    return (uint32_t)reg;
}

/** FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__MODIFY() modifies FAULT_FORCE_COM.FAULT_FORCE_COM.
 *
 * This is recommended to use when setting more than one bitfield of FAULTCOM.FAULT_FORCE_COM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULTCOM.FAULT_FORCE_COM
 * @param bf_value new value for FAULT_FORCE_COM.FAULT_FORCE_COM
 * @return new value of FAULTCOM.FAULT_FORCE_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Msk);
    reg = (reg | (FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__EXTRACT() extracts FAULT_FORCE_COM.FAULT_FORCE_COM.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_FORCE_COM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_FORCE_COM
 * @return current value of FAULT_FORCE_COM.FAULT_FORCE_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_FORCE_COM__FAULT_FORCE_COM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_CLEAR_COM member of FAULTCOM_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_CLEAR_COM__ADDRESS returns the address of member FAULT_CLEAR_COM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_CLEAR_COM
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_CLEAR_COM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_CLEAR_COM)));
}

/** FAULTCOM_FAULT_CLEAR_COM__SET() sets FAULT_CLEAR_COM to given value.
 *
 * When writing to FAULT_CLEAR_COM, this is mandatory to use.
 *
 * @param value new value for FAULT_CLEAR_COM
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_CLEAR_COM__SET(uint32_t value)
{
    HAL_SET32(__FAULTCOM_FAULT_CLEAR_COM__ADDRESS(), value);
}


/* ---------------- FAULTCOM.FAULT_CLEAR_COM.FAULT_CLEAR_COM ---------------- */

/**
<pre>
  FAULTCOM.FAULT_CLEAR_COM.FAULT_CLEAR_COM:

    Fault force clear register.  When the bit corresponding to a fault or warning is set to 1, that fault or warning is cleared in the fault_status_loop and fault_ref_loop registers.
    <start table_with_header>
    Bit Fault Bit Fault
    0 unused 1 unused
    2 "IS1 (ISEN) tracking fault" 3 "IS2 (BISEN) tracking fault"
    4 "Fbal1 fault" 5 "IS1 (ISEN) PCL fault"
    6 "IS1 (ISEN) SCP fault" 7 "Fbal2 fault"
    8 "IS2 (BISEN) PCL fault" 9 "IS2 (BISEN) SCP fault"
    10 unused 11 "VREF open fault"
    12 "VSEN open fault" 13 unused
    14 "VRREF open fault" 15 "VRSEN open fault"
    16 unused 17 "BVREF_BVRREF open fault"
    18 "BVSEN_BVRSEN open fault" 19-31 unused
    <end table>

</pre> */

#define FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Pos          0                                                                      /*!< Right-most bit position of fault_clear_com in FAULTCOM.FAULT_CLEAR_COM */
#define FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Msk          (0xFFFFFFFFUL << FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Pos)       /*!< Mask for fault_clear_com in FAULTCOM.FAULT_CLEAR_COM */
#define FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Shift(v)     (((v) << FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Pos) & FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Msk) /*!< Shift value 'v' into fault_clear_com and mask 'v' to fit it into fault_clear_com field */

/** FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__SET() sets FAULT_CLEAR_COM.FAULT_CLEAR_COM to given value.
 *
 * When writing to FAULT_CLEAR_COM.FAULT_CLEAR_COM, this is recommended to use.
 *
 * @param bf_value new value for FAULT_CLEAR_COM.FAULT_CLEAR_COM
 */
__FAULTCOM_INLINE void FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__SET(uint32_t bf_value)
{
    uint32_t reg = FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Shift((uint32_t)bf_value);
    FAULTCOM_FAULT_CLEAR_COM__SET(reg);
}


/** FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__MODIFY() modifies FAULT_CLEAR_COM.FAULT_CLEAR_COM.
 *
 * This is recommended to use when setting more than one bitfield of FAULTCOM.FAULT_CLEAR_COM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULTCOM.FAULT_CLEAR_COM
 * @param bf_value new value for FAULT_CLEAR_COM.FAULT_CLEAR_COM
 * @return new value of FAULTCOM.FAULT_CLEAR_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Msk);
    reg = (reg | (FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__EXTRACT() extracts FAULT_CLEAR_COM.FAULT_CLEAR_COM.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_CLEAR_COM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_CLEAR_COM
 * @return current value of FAULT_CLEAR_COM.FAULT_CLEAR_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_CLEAR_COM__FAULT_CLEAR_COM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   FAULT_STATUS_COM member of FAULTCOM_t                   */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_STATUS_COM__ADDRESS returns the address of member FAULT_STATUS_COM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_STATUS_COM
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_STATUS_COM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_STATUS_COM)));
}

/** FAULTCOM_FAULT_STATUS_COM__GET() gets FAULT_STATUS_COM's current value.
 *
 * When reading from FAULT_STATUS_COM, this is mandatory to use.
 *
 * @return current value of FAULT_STATUS_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_STATUS_COM__GET(void)
{
    return HAL_GET32(__FAULTCOM_FAULT_STATUS_COM__ADDRESS());
}

/* --------------- FAULTCOM.FAULT_STATUS_COM.FAULT_STATUS_COM --------------- */

/**
<pre>
  FAULTCOM.FAULT_STATUS_COM.FAULT_STATUS_COM:

    Fault status register generated by sub-sampling fault_reg_com at 2MHz.  Fault interrupts are generated from this register.  Once a fault bit is set it is latched in this register and can only be cleared via fault_clear_com.
    <start table_with_header>
    Bit Fault Bit Fault
    0 unused 1 unused
    2 "IS1 (ISEN) tracking fault" 3 "IS2 (BISEN) tracking fault"
    4 "Fbal1 fault" 5 "IS1 (ISEN) PCL fault"
    6 "IS1 (ISEN) SCP fault" 7 "Fbal2 fault"
    8 "IS2 (BISEN) PCL fault" 9 "IS2 (BISEN) SCP fault"
    10 unused 11 "VREF open fault"
    12 "VSEN open fault" 13 unused
    14 "VRREF open fault" 15 "VRSEN open fault"
    16 unused 17 "BVREF_BVRREF open fault"
    18 "BVSEN_BVRSEN open fault" 19-31 unused
    <end table>

</pre> */

#define FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__Pos        0                                                                      /*!< Right-most bit position of fault_status_com in FAULTCOM.FAULT_STATUS_COM */
#define FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__Msk        (0xFFFFFFFFUL << FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__Pos)     /*!< Mask for fault_status_com in FAULTCOM.FAULT_STATUS_COM */
#define FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__Shift(v)   (((v) << FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__Pos) & FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__Msk) /*!< Shift value 'v' into fault_status_com and mask 'v' to fit it into fault_status_com field */

/** FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__GET() gets FAULT_STATUS_COM.FAULT_STATUS_COM's current value.
 *
 * When reading from FAULT_STATUS_COM.FAULT_STATUS_COM, this is recommended to use.
 *
 * @return current value of FAULT_STATUS_COM.FAULT_STATUS_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__GET(void)
{
    uint32_t reg = FAULTCOM_FAULT_STATUS_COM__GET();
    reg = (reg & FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__Pos);
    return (uint32_t)reg;
}

/** FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__EXTRACT() extracts FAULT_STATUS_COM.FAULT_STATUS_COM.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_STATUS_COM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_STATUS_COM
 * @return current value of FAULT_STATUS_COM.FAULT_STATUS_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_STATUS_COM__FAULT_STATUS_COM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_ENCODE member of FAULTCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_ENCODE__ADDRESS returns the address of member FAULT_ENCODE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_ENCODE
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_ENCODE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_ENCODE)));
}

/** FAULTCOM_FAULT_ENCODE__GET() gets FAULT_ENCODE's current value.
 *
 * When reading from FAULT_ENCODE, this is mandatory to use.
 *
 * @return current value of FAULT_ENCODE
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_ENCODE__GET(void)
{
    return HAL_GET32(__FAULTCOM_FAULT_ENCODE__ADDRESS());
}

/* ------------------- FAULTCOM.FAULT_ENCODE.FAULT_ENCODE ------------------- */

/**
<pre>
  FAULTCOM.FAULT_ENCODE.FAULT_ENCODE:

    Priority encoding of the word {fault_status_com[31:0],fault1_status_loop[31:0],fault0_status_loop[31:0]} with fault_encode indicating the position of the first '1' searching from the LSB.  Fault0_status_loop[31:0] reports in the range 0-31, fault1_status_loop[31:0] reports ins the range 32-63 and fault_status_com[31:0] reports in the range 224-255.
    Note:
    Both the no fault case and fault0_status_loop[0]=1 will return fault_encode=0.  fault_irq_bus can be used along with fault_encode to distinguish between the 2 cases.

</pre> */

#define FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__Pos                0                                                                      /*!< Right-most bit position of fault_encode in FAULTCOM.FAULT_ENCODE */
#define FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__Msk                (0x000000FFUL << FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__Pos)             /*!< Mask for fault_encode in FAULTCOM.FAULT_ENCODE */
#define FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__Shift(v)           (((v) << FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__Pos) & FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__Msk) /*!< Shift value 'v' into fault_encode and mask 'v' to fit it into fault_encode field */

/** FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__GET() gets FAULT_ENCODE.FAULT_ENCODE's current value.
 *
 * When reading from FAULT_ENCODE.FAULT_ENCODE, this is recommended to use.
 *
 * @return current value of FAULT_ENCODE.FAULT_ENCODE
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__GET(void)
{
    uint32_t reg = FAULTCOM_FAULT_ENCODE__GET();
    reg = (reg & FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__Msk);
    reg = (reg >> FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__Pos);
    return (uint32_t)reg;
}

/** FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__EXTRACT() extracts FAULT_ENCODE.FAULT_ENCODE.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_ENCODE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_ENCODE
 * @return current value of FAULT_ENCODE.FAULT_ENCODE
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__Msk);
    reg = (reg >> FAULTCOM_FAULT_ENCODE__FAULT_ENCODE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_REG_COM member of FAULTCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULTCOM_FAULT_REG_COM__ADDRESS returns the address of member FAULT_REG_COM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FAULT_REG_COM
 */
__FAULTCOM_INLINE uint32_t* __FAULTCOM_FAULT_REG_COM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__FAULTCOM_BASE_PTR() + (uint32_t)(offsetof(FAULTCOM_t, FAULT_REG_COM)));
}

/** FAULTCOM_FAULT_REG_COM__GET() gets FAULT_REG_COM's current value.
 *
 * When reading from FAULT_REG_COM, this is mandatory to use.
 *
 * @return current value of FAULT_REG_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_REG_COM__GET(void)
{
    return HAL_GET32(__FAULTCOM_FAULT_REG_COM__ADDRESS());
}

/* ------------------ FAULTCOM.FAULT_REG_COM.FAULT_REG_COM ------------------ */

/**
<pre>
  FAULTCOM.FAULT_REG_COM.FAULT_REG_COM:

    Fault status register updated at 50MHz.  Once a fault bit is set it is latched in this register and can only be cleared via fault_clear_com.
    <start table_with_header>
    Bit Fault Bit Fault
    0 unused 1 unused
    2 "IS1 (ISEN) tracking fault" 3 "IS2 (BISEN) tracking fault"
    4 "Fbal1 fault" 5 "IS1 (ISEN) PCL fault"
    6 "IS1 (ISEN) SCP fault" 7 "Fbal2 fault"
    8 "IS2 (BISEN) PCL fault" 9 "IS2 (BISEN) SCP fault"
    10 unused 11 "VREF open fault"
    12 "VSEN open fault" 13 unused
    14 "VRREF open fault" 15 "VRSEN open fault"
    16 unused 17 "BVREF_BVRREF open fault"
    18 "BVSEN_BVRSEN open fault" 19-31 unused
    <end table>

</pre> */

#define FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__Pos              0                                                                      /*!< Right-most bit position of fault_reg_com in FAULTCOM.FAULT_REG_COM */
#define FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__Msk              (0xFFFFFFFFUL << FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__Pos)           /*!< Mask for fault_reg_com in FAULTCOM.FAULT_REG_COM */
#define FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__Shift(v)         (((v) << FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__Pos) & FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__Msk) /*!< Shift value 'v' into fault_reg_com and mask 'v' to fit it into fault_reg_com field */

/** FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__GET() gets FAULT_REG_COM.FAULT_REG_COM's current value.
 *
 * When reading from FAULT_REG_COM.FAULT_REG_COM, this is recommended to use.
 *
 * @return current value of FAULT_REG_COM.FAULT_REG_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__GET(void)
{
    uint32_t reg = FAULTCOM_FAULT_REG_COM__GET();
    reg = (reg & FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__Pos);
    return (uint32_t)reg;
}

/** FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__EXTRACT() extracts FAULT_REG_COM.FAULT_REG_COM.
 *
 * This is recommended to use when extracting more than one bitfield from FAULTCOM.FAULT_REG_COM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULTCOM.FAULT_REG_COM
 * @return current value of FAULT_REG_COM.FAULT_REG_COM
 */
__FAULTCOM_INLINE uint32_t FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__Msk);
    reg = (reg >> FAULTCOM_FAULT_REG_COM__FAULT_REG_COM__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group faultcom block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_FAULT_COMMON_H_ */
