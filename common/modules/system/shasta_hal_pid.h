/**
 * @file     shasta_hal_pid.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_PID_H_
#define _SHASTA_HAL_PID_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup pid
 * @{
 */

#if defined ( __CC_ARM )
#define __PID_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __PID_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __PID_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __PID_INLINE  static inline
#endif

/** register file of the pid block.
 */
typedef struct _PID_s
{
    volatile        uint32_t        PID_FF_CFG1                 ; /*!< (@0x00000000) PID feed forward (FF) adjustment for dead time.  Note adjustment always positive because dead time always reduces duty cycle.  Computed as, Bridge topology:...(more) */
    volatile        uint32_t        PID_COEFF                   ; /*!< (@0x00000004) PID pre-filter coefficient index.  Note that index settings greater than 55 are clamped to 55. <start table> "kfp_exp = pid_kfp1_index_1ph[5:3]" "kfp_man = ...(more) */
    volatile        uint32_t        PID_FORCE                   ; /*!< (@0x00000008) Forced duty cycle value overrides the PID output when selected by pid_force_duty_en.  Since this force is applied at the PID output, downstream adjustments ...(more) */
    volatile        uint32_t        PID_TRANS                   ; /*!< (@0x0000000C) Fast transient (FTR) mode error voltage exit threshold where the error voltage is defined as (target voltage - sense voltage).  When (error voltage < pid_ve...(more) */
    volatile        uint32_t        PID_OVS                     ; /*!< (@0x00000010) Overshoot transient mode error voltage exit threshold where the error voltage is defined as (target voltage - where the error voltage is defined as (target ...(more) */
    volatile        uint32_t        PID_BURST                   ; /*!< (@0x00000014) Burst mode error voltage threshold where the error voltage is defined as (target voltage - sense voltage).  When the controller is in burst mode, (error vol...(more) */
    volatile        uint32_t        PID_OSP_CFG1                ; /*!< (@0x00000018) Defines the minimum PID feed forward value, above which to begin checking for an open sense fault during soft start.  This fault will indicate a larger than...(more) */
    volatile        uint32_t        PID_FF_CFG2                 ; /*!< (@0x0000001C) Vrect override for PID feed forward computation in internal VS ADC format.  Used only when selected by pid_ff_vrect_sel.  If computing from Vin, pid_ff_vrec...(more) */
    volatile        uint32_t        PID_FF_CFG4                 ; /*!< (@0x00000020) PID feed forward override value.  Used when selected by pid_ff_override_sel.  This parameter along with pid_ff_override_sel may be used to override the HW c...(more) */
    volatile        uint32_t        PID_FF_CFG3                 ; /*!< (@0x00000024) Conversion factor for computing Vout from the measured VS ADC output.  This parameter is computed automatically by the default FW and requires no action by ...(more) */
    volatile        uint32_t        PID_COEFF2                  ; /*!< (@0x00000028) PID Kp coefficient value after Vin scaling.  See pid_kp_index_1ph description for definition. */
    volatile        uint32_t        PID_RESET_ACCUM             ; /*!< (@0x0000002C) PID integral term accumulator reset.  Allows FW to reset the accumulator by first writing a 1 to reset the accumulator followed by writing a 0 to release th...(more) */
    volatile        uint32_t        PID_FREEZE_ACCUM            ; /*!< (@0x00000030) PID integral term accumulator freeze control.  Allows FW to hold the accumulator at its current value by writing a 1 until it is released by writing a 0. <s...(more) */
    volatile        uint32_t        PID_OSP_CFG2                ; /*!< (@0x00000034) Not used */
    volatile        uint32_t        PID_OSP_CFG3                ; /*!< (@0x00000038) Not used */
    volatile        uint32_t        PID_OSP_CFG4                ; /*!< (@0x0000003C) Not used */
    volatile        uint32_t        PID_DUTY                    ; /*!< (@0x00000040) Unfiltered PID duty cycle output */
    volatile        uint32_t        PID_FF                      ; /*!< (@0x00000044) PID feed forward computation after gain/offset adjust and LPF */
} PID_t;


/** enumeration of implemented pid blocks
 */
typedef enum _pid_idx_e
{
    PID0 = 0u,    //!< PID0
    PID1 = 1u     //!< PID1
} pid_idx_t;

#define PID_BASE (0x70001C00u)                                                          /*!< pid base address */
#define PID_STRIDE (0x00000400u)                                                         

/** __PID_BASE_PTR returns the base address of the peripheral.
 *
 * @param idp index of peripheral
 * @return base address of peripheral's instance
 */
__PID_INLINE uint32_t* __PID_BASE_PTR(pid_idx_t idp)
{
    return (uint32_t*)(PID_BASE + (uint32_t)((uint32_t)idp * PID_STRIDE));
}


/* -------------------------------------------------------------------------- */
/*                        PID_FF_CFG1 member of PID_t                        */
/* -------------------------------------------------------------------------- */

/** __PID_PID_FF_CFG1__ADDRESS returns the address of member PID_FF_CFG1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_FF_CFG1
 */
__PID_INLINE uint32_t* __PID_PID_FF_CFG1__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_FF_CFG1)));
}

/** PID_PID_FF_CFG1__SET() sets PID_FF_CFG1 to given value.
 *
 * When writing to PID_FF_CFG1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_FF_CFG1
 */
__PID_INLINE void PID_PID_FF_CFG1__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_FF_CFG1__ADDRESS(idp), value);
}

/** PID_PID_FF_CFG1__GET() gets PID_FF_CFG1's current value.
 *
 * When reading from PID_FF_CFG1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG1
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_FF_CFG1__ADDRESS(idp));
}

/* --------------------- PID.PID_FF_CFG1.PID_VRECT_REF --------------------- */

/**
<pre>
  PID.PID_FF_CFG1.PID_VRECT_REF:

    PID coefficient scaling reference voltage.  PID coefficients are scaled with Vrect to maintain a constant loop gain.  This parameter defines the reference Vrect voltage at which the gain scale is 1.0.  This parameter should be set to the expected nominal Vrect voltage and it should be set before optimization of PID coefficients Kp, Ki and Kd.
    Example:
    Vin_nom = 48V, FB topology, Nturn=3
    pid_vrect_ref = Vrect_nom = 48V / 3 = 16V
    LSB = 0.32V, Range = 0.0 to 81.6V

</pre> */

#define PID_PID_FF_CFG1__PID_VRECT_REF__Pos                     20                                                                     /*!< Right-most bit position of pid_vrect_ref in PID.PID_FF_CFG1 */
#define PID_PID_FF_CFG1__PID_VRECT_REF__Msk                     (0x000000FFUL << PID_PID_FF_CFG1__PID_VRECT_REF__Pos)                  /*!< Mask for pid_vrect_ref in PID.PID_FF_CFG1 */
#define PID_PID_FF_CFG1__PID_VRECT_REF__Shift(v)                (((v) << PID_PID_FF_CFG1__PID_VRECT_REF__Pos) & PID_PID_FF_CFG1__PID_VRECT_REF__Msk) /*!< Shift value 'v' into pid_vrect_ref and mask 'v' to fit it into pid_vrect_ref field */

/** PID_PID_FF_CFG1__PID_VRECT_REF__SET() sets PID_FF_CFG1.PID_VRECT_REF to given value.
 *
 * When writing to PID_FF_CFG1.PID_VRECT_REF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FF_CFG1.PID_VRECT_REF
 */
__PID_INLINE void PID_PID_FF_CFG1__PID_VRECT_REF__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FF_CFG1__GET(idp);
    reg = (reg & ~PID_PID_FF_CFG1__PID_VRECT_REF__Msk);
    reg = (reg | (PID_PID_FF_CFG1__PID_VRECT_REF__Shift((uint32_t)bf_value)));
    PID_PID_FF_CFG1__SET(idp, reg);
}

/** PID_PID_FF_CFG1__PID_VRECT_REF__GET() gets PID_FF_CFG1.PID_VRECT_REF's current value.
 *
 * When reading from PID_FF_CFG1.PID_VRECT_REF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG1.PID_VRECT_REF
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_VRECT_REF__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF_CFG1__GET(idp);
    reg = (reg & PID_PID_FF_CFG1__PID_VRECT_REF__Msk);
    reg = (reg >> PID_PID_FF_CFG1__PID_VRECT_REF__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF_CFG1__PID_VRECT_REF__MODIFY() modifies PID_FF_CFG1.PID_VRECT_REF.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FF_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FF_CFG1
 * @param bf_value new value for PID_FF_CFG1.PID_VRECT_REF
 * @return new value of PID.PID_FF_CFG1
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_VRECT_REF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FF_CFG1__PID_VRECT_REF__Msk);
    reg = (reg | (PID_PID_FF_CFG1__PID_VRECT_REF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FF_CFG1__PID_VRECT_REF__EXTRACT() extracts PID_FF_CFG1.PID_VRECT_REF.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF_CFG1
 * @return current value of PID_FF_CFG1.PID_VRECT_REF
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_VRECT_REF__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF_CFG1__PID_VRECT_REF__Msk);
    reg = (reg >> PID_PID_FF_CFG1__PID_VRECT_REF__Pos);
    return (uint32_t)reg;
}

/* -------------------- PID.PID_FF_CFG1.PID_FF_VRECT_SEL -------------------- */

/**
<pre>
  PID.PID_FF_CFG1.PID_FF_VRECT_SEL:

    Feed forward (FF) Vrect source select. Feed forward is computed as (Vout / Vrect) for isolated and as (Vout / Vin) for non-isolated Buck derived topologies.  Note that the feed forward computation may be overriden entirely using parameters pid_ff_override_sel and pid_ff_override (e.g., to override the HW computed FF with a FW computation appropriate for Boost or Buck-Boost derived topologies).
    <start table>
    0 "VS1 (VRSEN) Vrect"
    1 "VS2 (BVSEN_BVRSEN) Vrect"
    2 "Telemetry Sense Vin"
    3 "pid_ff_vrect_override"
    <end table>

</pre> */

#define PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Pos                  18                                                                     /*!< Right-most bit position of pid_ff_vrect_sel in PID.PID_FF_CFG1 */
#define PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Msk                  (0x00000003UL << PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Pos)               /*!< Mask for pid_ff_vrect_sel in PID.PID_FF_CFG1 */
#define PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Shift(v)             (((v) << PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Pos) & PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Msk) /*!< Shift value 'v' into pid_ff_vrect_sel and mask 'v' to fit it into pid_ff_vrect_sel field */

/** PID_PID_FF_CFG1__PID_FF_VRECT_SEL__SET() sets PID_FF_CFG1.PID_FF_VRECT_SEL to given value.
 *
 * When writing to PID_FF_CFG1.PID_FF_VRECT_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FF_CFG1.PID_FF_VRECT_SEL
 */
__PID_INLINE void PID_PID_FF_CFG1__PID_FF_VRECT_SEL__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FF_CFG1__GET(idp);
    reg = (reg & ~PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Msk);
    reg = (reg | (PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Shift((uint32_t)bf_value)));
    PID_PID_FF_CFG1__SET(idp, reg);
}

/** PID_PID_FF_CFG1__PID_FF_VRECT_SEL__GET() gets PID_FF_CFG1.PID_FF_VRECT_SEL's current value.
 *
 * When reading from PID_FF_CFG1.PID_FF_VRECT_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG1.PID_FF_VRECT_SEL
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_FF_VRECT_SEL__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF_CFG1__GET(idp);
    reg = (reg & PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Msk);
    reg = (reg >> PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF_CFG1__PID_FF_VRECT_SEL__MODIFY() modifies PID_FF_CFG1.PID_FF_VRECT_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FF_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FF_CFG1
 * @param bf_value new value for PID_FF_CFG1.PID_FF_VRECT_SEL
 * @return new value of PID.PID_FF_CFG1
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_FF_VRECT_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Msk);
    reg = (reg | (PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FF_CFG1__PID_FF_VRECT_SEL__EXTRACT() extracts PID_FF_CFG1.PID_FF_VRECT_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF_CFG1
 * @return current value of PID_FF_CFG1.PID_FF_VRECT_SEL
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_FF_VRECT_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Msk);
    reg = (reg >> PID_PID_FF_CFG1__PID_FF_VRECT_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------- PID.PID_FF_CFG1.PID_FF_GAIN_SCALE ------------------- */

/**
<pre>
  PID.PID_FF_CFG1.PID_FF_GAIN_SCALE:

    Feed forward (FF) gain scale.  This parameter may be used to apply a gain to the computed FF term.  The typical setting is 16 which corresponds to a gain of 1.0.

</pre> */

#define PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Pos                 13                                                                     /*!< Right-most bit position of pid_ff_gain_scale in PID.PID_FF_CFG1 */
#define PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Msk                 (0x0000001FUL << PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Pos)              /*!< Mask for pid_ff_gain_scale in PID.PID_FF_CFG1 */
#define PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Shift(v)            (((v) << PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Pos) & PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Msk) /*!< Shift value 'v' into pid_ff_gain_scale and mask 'v' to fit it into pid_ff_gain_scale field */

/** PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__SET() sets PID_FF_CFG1.PID_FF_GAIN_SCALE to given value.
 *
 * When writing to PID_FF_CFG1.PID_FF_GAIN_SCALE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FF_CFG1.PID_FF_GAIN_SCALE
 */
__PID_INLINE void PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FF_CFG1__GET(idp);
    reg = (reg & ~PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Msk);
    reg = (reg | (PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Shift((uint32_t)bf_value)));
    PID_PID_FF_CFG1__SET(idp, reg);
}

/** PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__GET() gets PID_FF_CFG1.PID_FF_GAIN_SCALE's current value.
 *
 * When reading from PID_FF_CFG1.PID_FF_GAIN_SCALE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG1.PID_FF_GAIN_SCALE
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF_CFG1__GET(idp);
    reg = (reg & PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Msk);
    reg = (reg >> PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__MODIFY() modifies PID_FF_CFG1.PID_FF_GAIN_SCALE.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FF_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FF_CFG1
 * @param bf_value new value for PID_FF_CFG1.PID_FF_GAIN_SCALE
 * @return new value of PID.PID_FF_CFG1
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Msk);
    reg = (reg | (PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__EXTRACT() extracts PID_FF_CFG1.PID_FF_GAIN_SCALE.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF_CFG1
 * @return current value of PID_FF_CFG1.PID_FF_GAIN_SCALE
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Msk);
    reg = (reg >> PID_PID_FF_CFG1__PID_FF_GAIN_SCALE__Pos);
    return (uint32_t)reg;
}

/* --------------------- PID.PID_FF_CFG1.PID_KP_FF_LPF --------------------- */

/**
<pre>
  PID.PID_FF_CFG1.PID_KP_FF_LPF:

    PID feed forward (FF) low pass filter coefficient.  The computed FF term is passed through a low pass filter before being used by the PID as part of the duty cycle caculation.  This parameter sets the bandwidth of this filter.
    <start table>
    "kfp_exp = pid_kp_ff_kpf[4:2]"
    "kfp_man = 4 + pid_kp_ff_kpf[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-9"
    "F3db(MHz) = [kfp / (1 - kfp)] * 50MHz / 2*pi;"
    <end table>

</pre> */

#define PID_PID_FF_CFG1__PID_KP_FF_LPF__Pos                     8                                                                      /*!< Right-most bit position of pid_kp_ff_lpf in PID.PID_FF_CFG1 */
#define PID_PID_FF_CFG1__PID_KP_FF_LPF__Msk                     (0x0000001FUL << PID_PID_FF_CFG1__PID_KP_FF_LPF__Pos)                  /*!< Mask for pid_kp_ff_lpf in PID.PID_FF_CFG1 */
#define PID_PID_FF_CFG1__PID_KP_FF_LPF__Shift(v)                (((v) << PID_PID_FF_CFG1__PID_KP_FF_LPF__Pos) & PID_PID_FF_CFG1__PID_KP_FF_LPF__Msk) /*!< Shift value 'v' into pid_kp_ff_lpf and mask 'v' to fit it into pid_kp_ff_lpf field */

/** PID_PID_FF_CFG1__PID_KP_FF_LPF__SET() sets PID_FF_CFG1.PID_KP_FF_LPF to given value.
 *
 * When writing to PID_FF_CFG1.PID_KP_FF_LPF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FF_CFG1.PID_KP_FF_LPF
 */
__PID_INLINE void PID_PID_FF_CFG1__PID_KP_FF_LPF__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FF_CFG1__GET(idp);
    reg = (reg & ~PID_PID_FF_CFG1__PID_KP_FF_LPF__Msk);
    reg = (reg | (PID_PID_FF_CFG1__PID_KP_FF_LPF__Shift((uint32_t)bf_value)));
    PID_PID_FF_CFG1__SET(idp, reg);
}

/** PID_PID_FF_CFG1__PID_KP_FF_LPF__GET() gets PID_FF_CFG1.PID_KP_FF_LPF's current value.
 *
 * When reading from PID_FF_CFG1.PID_KP_FF_LPF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG1.PID_KP_FF_LPF
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_KP_FF_LPF__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF_CFG1__GET(idp);
    reg = (reg & PID_PID_FF_CFG1__PID_KP_FF_LPF__Msk);
    reg = (reg >> PID_PID_FF_CFG1__PID_KP_FF_LPF__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF_CFG1__PID_KP_FF_LPF__MODIFY() modifies PID_FF_CFG1.PID_KP_FF_LPF.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FF_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FF_CFG1
 * @param bf_value new value for PID_FF_CFG1.PID_KP_FF_LPF
 * @return new value of PID.PID_FF_CFG1
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_KP_FF_LPF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FF_CFG1__PID_KP_FF_LPF__Msk);
    reg = (reg | (PID_PID_FF_CFG1__PID_KP_FF_LPF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FF_CFG1__PID_KP_FF_LPF__EXTRACT() extracts PID_FF_CFG1.PID_KP_FF_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF_CFG1
 * @return current value of PID_FF_CFG1.PID_KP_FF_LPF
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_KP_FF_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF_CFG1__PID_KP_FF_LPF__Msk);
    reg = (reg >> PID_PID_FF_CFG1__PID_KP_FF_LPF__Pos);
    return (uint32_t)reg;
}

/* --------------------- PID.PID_FF_CFG1.PID_FF_DT_ADJ --------------------- */

/**
<pre>
  PID.PID_FF_CFG1.PID_FF_DT_ADJ:

    PID feed forward (FF) adjustment for dead time.  Note adjustment always positive because dead time always reduces duty cycle.  Computed as,
    Bridge topology:
    pid_ff_dt_adj = Tdead / (Tswitch/2)
    Non-bridge topology:
    pid_ff_dt_adj = Tdead / Tswitch
    Example:
    Bridge topology, Tdead=100ns, Tswitch=4us
    pid_ff_dt_adj = 100ns/2000ns = 0.05
    LSB = 2^-10, Range = 0 to 0.2490

</pre> */

#define PID_PID_FF_CFG1__PID_FF_DT_ADJ__Pos                     0                                                                      /*!< Right-most bit position of pid_ff_dt_adj in PID.PID_FF_CFG1 */
#define PID_PID_FF_CFG1__PID_FF_DT_ADJ__Msk                     (0x000000FFUL << PID_PID_FF_CFG1__PID_FF_DT_ADJ__Pos)                  /*!< Mask for pid_ff_dt_adj in PID.PID_FF_CFG1 */
#define PID_PID_FF_CFG1__PID_FF_DT_ADJ__Shift(v)                (((v) << PID_PID_FF_CFG1__PID_FF_DT_ADJ__Pos) & PID_PID_FF_CFG1__PID_FF_DT_ADJ__Msk) /*!< Shift value 'v' into pid_ff_dt_adj and mask 'v' to fit it into pid_ff_dt_adj field */

/** PID_PID_FF_CFG1__PID_FF_DT_ADJ__SET() sets PID_FF_CFG1.PID_FF_DT_ADJ to given value.
 *
 * When writing to PID_FF_CFG1.PID_FF_DT_ADJ, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FF_CFG1.PID_FF_DT_ADJ
 */
__PID_INLINE void PID_PID_FF_CFG1__PID_FF_DT_ADJ__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FF_CFG1__GET(idp);
    reg = (reg & ~PID_PID_FF_CFG1__PID_FF_DT_ADJ__Msk);
    reg = (reg | (PID_PID_FF_CFG1__PID_FF_DT_ADJ__Shift((uint32_t)bf_value)));
    PID_PID_FF_CFG1__SET(idp, reg);
}

/** PID_PID_FF_CFG1__PID_FF_DT_ADJ__GET() gets PID_FF_CFG1.PID_FF_DT_ADJ's current value.
 *
 * When reading from PID_FF_CFG1.PID_FF_DT_ADJ, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG1.PID_FF_DT_ADJ
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_FF_DT_ADJ__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF_CFG1__GET(idp);
    reg = (reg & PID_PID_FF_CFG1__PID_FF_DT_ADJ__Msk);
    reg = (reg >> PID_PID_FF_CFG1__PID_FF_DT_ADJ__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF_CFG1__PID_FF_DT_ADJ__MODIFY() modifies PID_FF_CFG1.PID_FF_DT_ADJ.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FF_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FF_CFG1
 * @param bf_value new value for PID_FF_CFG1.PID_FF_DT_ADJ
 * @return new value of PID.PID_FF_CFG1
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_FF_DT_ADJ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FF_CFG1__PID_FF_DT_ADJ__Msk);
    reg = (reg | (PID_PID_FF_CFG1__PID_FF_DT_ADJ__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FF_CFG1__PID_FF_DT_ADJ__EXTRACT() extracts PID_FF_CFG1.PID_FF_DT_ADJ.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF_CFG1
 * @return current value of PID_FF_CFG1.PID_FF_DT_ADJ
 */
__PID_INLINE uint32_t PID_PID_FF_CFG1__PID_FF_DT_ADJ__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF_CFG1__PID_FF_DT_ADJ__Msk);
    reg = (reg >> PID_PID_FF_CFG1__PID_FF_DT_ADJ__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         PID_COEFF member of PID_t                         */
/* -------------------------------------------------------------------------- */

/** __PID_PID_COEFF__ADDRESS returns the address of member PID_COEFF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_COEFF
 */
__PID_INLINE uint32_t* __PID_PID_COEFF__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_COEFF)));
}

/** PID_PID_COEFF__SET() sets PID_COEFF to given value.
 *
 * When writing to PID_COEFF, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_COEFF
 */
__PID_INLINE void PID_PID_COEFF__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_COEFF__ADDRESS(idp), value);
}

/** PID_PID_COEFF__GET() gets PID_COEFF's current value.
 *
 * When reading from PID_COEFF, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_COEFF
 */
__PID_INLINE uint32_t PID_PID_COEFF__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_COEFF__ADDRESS(idp));
}

/* --------------------- PID.PID_COEFF.PID_KD_INDEX_1PH --------------------- */

/**
<pre>
  PID.PID_COEFF.PID_KD_INDEX_1PH:

    PID derivative coefficient index.  Note that index settings greater than 119 are clamped to 119.
    <start table>
    "kd_exp = pid_kd_index_1ph[6:3]"
    "kd_man = 8 + pid_kd_index_1ph[2:0]"
    "kd = kd_man * 2^kd_exp * 2^-10"
    <end table>

</pre> */

#define PID_PID_COEFF__PID_KD_INDEX_1PH__Pos                    24                                                                     /*!< Right-most bit position of pid_kd_index_1ph in PID.PID_COEFF */
#define PID_PID_COEFF__PID_KD_INDEX_1PH__Msk                    (0x0000007FUL << PID_PID_COEFF__PID_KD_INDEX_1PH__Pos)                 /*!< Mask for pid_kd_index_1ph in PID.PID_COEFF */
#define PID_PID_COEFF__PID_KD_INDEX_1PH__Shift(v)               (((v) << PID_PID_COEFF__PID_KD_INDEX_1PH__Pos) & PID_PID_COEFF__PID_KD_INDEX_1PH__Msk) /*!< Shift value 'v' into pid_kd_index_1ph and mask 'v' to fit it into pid_kd_index_1ph field */

/** PID_PID_COEFF__PID_KD_INDEX_1PH__SET() sets PID_COEFF.PID_KD_INDEX_1PH to given value.
 *
 * When writing to PID_COEFF.PID_KD_INDEX_1PH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_COEFF.PID_KD_INDEX_1PH
 */
__PID_INLINE void PID_PID_COEFF__PID_KD_INDEX_1PH__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_COEFF__GET(idp);
    reg = (reg & ~PID_PID_COEFF__PID_KD_INDEX_1PH__Msk);
    reg = (reg | (PID_PID_COEFF__PID_KD_INDEX_1PH__Shift((uint32_t)bf_value)));
    PID_PID_COEFF__SET(idp, reg);
}

/** PID_PID_COEFF__PID_KD_INDEX_1PH__GET() gets PID_COEFF.PID_KD_INDEX_1PH's current value.
 *
 * When reading from PID_COEFF.PID_KD_INDEX_1PH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_COEFF.PID_KD_INDEX_1PH
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KD_INDEX_1PH__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_COEFF__GET(idp);
    reg = (reg & PID_PID_COEFF__PID_KD_INDEX_1PH__Msk);
    reg = (reg >> PID_PID_COEFF__PID_KD_INDEX_1PH__Pos);
    return (uint32_t)reg;
}

/** PID_PID_COEFF__PID_KD_INDEX_1PH__MODIFY() modifies PID_COEFF.PID_KD_INDEX_1PH.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_COEFF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_COEFF
 * @param bf_value new value for PID_COEFF.PID_KD_INDEX_1PH
 * @return new value of PID.PID_COEFF
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KD_INDEX_1PH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_COEFF__PID_KD_INDEX_1PH__Msk);
    reg = (reg | (PID_PID_COEFF__PID_KD_INDEX_1PH__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_COEFF__PID_KD_INDEX_1PH__EXTRACT() extracts PID_COEFF.PID_KD_INDEX_1PH.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_COEFF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_COEFF
 * @return current value of PID_COEFF.PID_KD_INDEX_1PH
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KD_INDEX_1PH__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_COEFF__PID_KD_INDEX_1PH__Msk);
    reg = (reg >> PID_PID_COEFF__PID_KD_INDEX_1PH__Pos);
    return (uint32_t)reg;
}

/* --------------------- PID.PID_COEFF.PID_KI_INDEX_1PH --------------------- */

/**
<pre>
  PID.PID_COEFF.PID_KI_INDEX_1PH:

    PID integral coefficient index.
    <start table>
    "ki_exp = pid_ki_index_1ph[5:3]"
    "ki_man = 8 + pid_ki_index_1ph[2:0]"
    "ki = ki_man * 2^ki_exp * 2^-25"
    <end table>

</pre> */

#define PID_PID_COEFF__PID_KI_INDEX_1PH__Pos                    18                                                                     /*!< Right-most bit position of pid_ki_index_1ph in PID.PID_COEFF */
#define PID_PID_COEFF__PID_KI_INDEX_1PH__Msk                    (0x0000003FUL << PID_PID_COEFF__PID_KI_INDEX_1PH__Pos)                 /*!< Mask for pid_ki_index_1ph in PID.PID_COEFF */
#define PID_PID_COEFF__PID_KI_INDEX_1PH__Shift(v)               (((v) << PID_PID_COEFF__PID_KI_INDEX_1PH__Pos) & PID_PID_COEFF__PID_KI_INDEX_1PH__Msk) /*!< Shift value 'v' into pid_ki_index_1ph and mask 'v' to fit it into pid_ki_index_1ph field */

/** PID_PID_COEFF__PID_KI_INDEX_1PH__SET() sets PID_COEFF.PID_KI_INDEX_1PH to given value.
 *
 * When writing to PID_COEFF.PID_KI_INDEX_1PH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_COEFF.PID_KI_INDEX_1PH
 */
__PID_INLINE void PID_PID_COEFF__PID_KI_INDEX_1PH__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_COEFF__GET(idp);
    reg = (reg & ~PID_PID_COEFF__PID_KI_INDEX_1PH__Msk);
    reg = (reg | (PID_PID_COEFF__PID_KI_INDEX_1PH__Shift((uint32_t)bf_value)));
    PID_PID_COEFF__SET(idp, reg);
}

/** PID_PID_COEFF__PID_KI_INDEX_1PH__GET() gets PID_COEFF.PID_KI_INDEX_1PH's current value.
 *
 * When reading from PID_COEFF.PID_KI_INDEX_1PH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_COEFF.PID_KI_INDEX_1PH
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KI_INDEX_1PH__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_COEFF__GET(idp);
    reg = (reg & PID_PID_COEFF__PID_KI_INDEX_1PH__Msk);
    reg = (reg >> PID_PID_COEFF__PID_KI_INDEX_1PH__Pos);
    return (uint32_t)reg;
}

/** PID_PID_COEFF__PID_KI_INDEX_1PH__MODIFY() modifies PID_COEFF.PID_KI_INDEX_1PH.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_COEFF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_COEFF
 * @param bf_value new value for PID_COEFF.PID_KI_INDEX_1PH
 * @return new value of PID.PID_COEFF
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KI_INDEX_1PH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_COEFF__PID_KI_INDEX_1PH__Msk);
    reg = (reg | (PID_PID_COEFF__PID_KI_INDEX_1PH__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_COEFF__PID_KI_INDEX_1PH__EXTRACT() extracts PID_COEFF.PID_KI_INDEX_1PH.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_COEFF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_COEFF
 * @return current value of PID_COEFF.PID_KI_INDEX_1PH
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KI_INDEX_1PH__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_COEFF__PID_KI_INDEX_1PH__Msk);
    reg = (reg >> PID_PID_COEFF__PID_KI_INDEX_1PH__Pos);
    return (uint32_t)reg;
}

/* --------------------- PID.PID_COEFF.PID_KP_INDEX_1PH --------------------- */

/**
<pre>
  PID.PID_COEFF.PID_KP_INDEX_1PH:

    PID proportional coefficient index.
    <start table>
    "kp_exp = pid_kp_index_1ph[5:3]"
    "kp_man = 8 + pid_kp_index_1ph[2:0]"
    "kp = kp_man * 2^kp_exp * 2^-15"
    <end table>

</pre> */

#define PID_PID_COEFF__PID_KP_INDEX_1PH__Pos                    12                                                                     /*!< Right-most bit position of pid_kp_index_1ph in PID.PID_COEFF */
#define PID_PID_COEFF__PID_KP_INDEX_1PH__Msk                    (0x0000003FUL << PID_PID_COEFF__PID_KP_INDEX_1PH__Pos)                 /*!< Mask for pid_kp_index_1ph in PID.PID_COEFF */
#define PID_PID_COEFF__PID_KP_INDEX_1PH__Shift(v)               (((v) << PID_PID_COEFF__PID_KP_INDEX_1PH__Pos) & PID_PID_COEFF__PID_KP_INDEX_1PH__Msk) /*!< Shift value 'v' into pid_kp_index_1ph and mask 'v' to fit it into pid_kp_index_1ph field */

/** PID_PID_COEFF__PID_KP_INDEX_1PH__SET() sets PID_COEFF.PID_KP_INDEX_1PH to given value.
 *
 * When writing to PID_COEFF.PID_KP_INDEX_1PH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_COEFF.PID_KP_INDEX_1PH
 */
__PID_INLINE void PID_PID_COEFF__PID_KP_INDEX_1PH__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_COEFF__GET(idp);
    reg = (reg & ~PID_PID_COEFF__PID_KP_INDEX_1PH__Msk);
    reg = (reg | (PID_PID_COEFF__PID_KP_INDEX_1PH__Shift((uint32_t)bf_value)));
    PID_PID_COEFF__SET(idp, reg);
}

/** PID_PID_COEFF__PID_KP_INDEX_1PH__GET() gets PID_COEFF.PID_KP_INDEX_1PH's current value.
 *
 * When reading from PID_COEFF.PID_KP_INDEX_1PH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_COEFF.PID_KP_INDEX_1PH
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KP_INDEX_1PH__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_COEFF__GET(idp);
    reg = (reg & PID_PID_COEFF__PID_KP_INDEX_1PH__Msk);
    reg = (reg >> PID_PID_COEFF__PID_KP_INDEX_1PH__Pos);
    return (uint32_t)reg;
}

/** PID_PID_COEFF__PID_KP_INDEX_1PH__MODIFY() modifies PID_COEFF.PID_KP_INDEX_1PH.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_COEFF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_COEFF
 * @param bf_value new value for PID_COEFF.PID_KP_INDEX_1PH
 * @return new value of PID.PID_COEFF
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KP_INDEX_1PH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_COEFF__PID_KP_INDEX_1PH__Msk);
    reg = (reg | (PID_PID_COEFF__PID_KP_INDEX_1PH__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_COEFF__PID_KP_INDEX_1PH__EXTRACT() extracts PID_COEFF.PID_KP_INDEX_1PH.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_COEFF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_COEFF
 * @return current value of PID_COEFF.PID_KP_INDEX_1PH
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KP_INDEX_1PH__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_COEFF__PID_KP_INDEX_1PH__Msk);
    reg = (reg >> PID_PID_COEFF__PID_KP_INDEX_1PH__Pos);
    return (uint32_t)reg;
}

/* -------------------- PID.PID_COEFF.PID_KFP2_INDEX_1PH -------------------- */

/**
<pre>
  PID.PID_COEFF.PID_KFP2_INDEX_1PH:

    PID post-filter coefficient index.  Note that index settings greater than 55 are clamped to 55.
    <start table>
    "kfp_exp = pid_kfp2_index_1ph[5:3]"
    "kfp_man = 8 + pid_kfp2_index_1ph[2:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(MHz) = [kfp / (1 - kfp)] * 50MHz / 2*pi;"
    <end table>

</pre> */

#define PID_PID_COEFF__PID_KFP2_INDEX_1PH__Pos                  6                                                                      /*!< Right-most bit position of pid_kfp2_index_1ph in PID.PID_COEFF */
#define PID_PID_COEFF__PID_KFP2_INDEX_1PH__Msk                  (0x0000003FUL << PID_PID_COEFF__PID_KFP2_INDEX_1PH__Pos)               /*!< Mask for pid_kfp2_index_1ph in PID.PID_COEFF */
#define PID_PID_COEFF__PID_KFP2_INDEX_1PH__Shift(v)             (((v) << PID_PID_COEFF__PID_KFP2_INDEX_1PH__Pos) & PID_PID_COEFF__PID_KFP2_INDEX_1PH__Msk) /*!< Shift value 'v' into pid_kfp2_index_1ph and mask 'v' to fit it into pid_kfp2_index_1ph field */

/** PID_PID_COEFF__PID_KFP2_INDEX_1PH__SET() sets PID_COEFF.PID_KFP2_INDEX_1PH to given value.
 *
 * When writing to PID_COEFF.PID_KFP2_INDEX_1PH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_COEFF.PID_KFP2_INDEX_1PH
 */
__PID_INLINE void PID_PID_COEFF__PID_KFP2_INDEX_1PH__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_COEFF__GET(idp);
    reg = (reg & ~PID_PID_COEFF__PID_KFP2_INDEX_1PH__Msk);
    reg = (reg | (PID_PID_COEFF__PID_KFP2_INDEX_1PH__Shift((uint32_t)bf_value)));
    PID_PID_COEFF__SET(idp, reg);
}

/** PID_PID_COEFF__PID_KFP2_INDEX_1PH__GET() gets PID_COEFF.PID_KFP2_INDEX_1PH's current value.
 *
 * When reading from PID_COEFF.PID_KFP2_INDEX_1PH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_COEFF.PID_KFP2_INDEX_1PH
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KFP2_INDEX_1PH__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_COEFF__GET(idp);
    reg = (reg & PID_PID_COEFF__PID_KFP2_INDEX_1PH__Msk);
    reg = (reg >> PID_PID_COEFF__PID_KFP2_INDEX_1PH__Pos);
    return (uint32_t)reg;
}

/** PID_PID_COEFF__PID_KFP2_INDEX_1PH__MODIFY() modifies PID_COEFF.PID_KFP2_INDEX_1PH.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_COEFF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_COEFF
 * @param bf_value new value for PID_COEFF.PID_KFP2_INDEX_1PH
 * @return new value of PID.PID_COEFF
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KFP2_INDEX_1PH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_COEFF__PID_KFP2_INDEX_1PH__Msk);
    reg = (reg | (PID_PID_COEFF__PID_KFP2_INDEX_1PH__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_COEFF__PID_KFP2_INDEX_1PH__EXTRACT() extracts PID_COEFF.PID_KFP2_INDEX_1PH.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_COEFF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_COEFF
 * @return current value of PID_COEFF.PID_KFP2_INDEX_1PH
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KFP2_INDEX_1PH__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_COEFF__PID_KFP2_INDEX_1PH__Msk);
    reg = (reg >> PID_PID_COEFF__PID_KFP2_INDEX_1PH__Pos);
    return (uint32_t)reg;
}

/* -------------------- PID.PID_COEFF.PID_KFP1_INDEX_1PH -------------------- */

/**
<pre>
  PID.PID_COEFF.PID_KFP1_INDEX_1PH:

    PID pre-filter coefficient index.  Note that index settings greater than 55 are clamped to 55.
    <start table>
    "kfp_exp = pid_kfp1_index_1ph[5:3]"
    "kfp_man = 8 + pid_kfp1_index_1ph[2:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(MHz) = [kfp / (1 - kfp)] * 50MHz / 2*pi;"
    <end table>

</pre> */

#define PID_PID_COEFF__PID_KFP1_INDEX_1PH__Pos                  0                                                                      /*!< Right-most bit position of pid_kfp1_index_1ph in PID.PID_COEFF */
#define PID_PID_COEFF__PID_KFP1_INDEX_1PH__Msk                  (0x0000003FUL << PID_PID_COEFF__PID_KFP1_INDEX_1PH__Pos)               /*!< Mask for pid_kfp1_index_1ph in PID.PID_COEFF */
#define PID_PID_COEFF__PID_KFP1_INDEX_1PH__Shift(v)             (((v) << PID_PID_COEFF__PID_KFP1_INDEX_1PH__Pos) & PID_PID_COEFF__PID_KFP1_INDEX_1PH__Msk) /*!< Shift value 'v' into pid_kfp1_index_1ph and mask 'v' to fit it into pid_kfp1_index_1ph field */

/** PID_PID_COEFF__PID_KFP1_INDEX_1PH__SET() sets PID_COEFF.PID_KFP1_INDEX_1PH to given value.
 *
 * When writing to PID_COEFF.PID_KFP1_INDEX_1PH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_COEFF.PID_KFP1_INDEX_1PH
 */
__PID_INLINE void PID_PID_COEFF__PID_KFP1_INDEX_1PH__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_COEFF__GET(idp);
    reg = (reg & ~PID_PID_COEFF__PID_KFP1_INDEX_1PH__Msk);
    reg = (reg | (PID_PID_COEFF__PID_KFP1_INDEX_1PH__Shift((uint32_t)bf_value)));
    PID_PID_COEFF__SET(idp, reg);
}

/** PID_PID_COEFF__PID_KFP1_INDEX_1PH__GET() gets PID_COEFF.PID_KFP1_INDEX_1PH's current value.
 *
 * When reading from PID_COEFF.PID_KFP1_INDEX_1PH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_COEFF.PID_KFP1_INDEX_1PH
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KFP1_INDEX_1PH__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_COEFF__GET(idp);
    reg = (reg & PID_PID_COEFF__PID_KFP1_INDEX_1PH__Msk);
    reg = (reg >> PID_PID_COEFF__PID_KFP1_INDEX_1PH__Pos);
    return (uint32_t)reg;
}

/** PID_PID_COEFF__PID_KFP1_INDEX_1PH__MODIFY() modifies PID_COEFF.PID_KFP1_INDEX_1PH.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_COEFF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_COEFF
 * @param bf_value new value for PID_COEFF.PID_KFP1_INDEX_1PH
 * @return new value of PID.PID_COEFF
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KFP1_INDEX_1PH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_COEFF__PID_KFP1_INDEX_1PH__Msk);
    reg = (reg | (PID_PID_COEFF__PID_KFP1_INDEX_1PH__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_COEFF__PID_KFP1_INDEX_1PH__EXTRACT() extracts PID_COEFF.PID_KFP1_INDEX_1PH.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_COEFF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_COEFF
 * @return current value of PID_COEFF.PID_KFP1_INDEX_1PH
 */
__PID_INLINE uint32_t PID_PID_COEFF__PID_KFP1_INDEX_1PH__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_COEFF__PID_KFP1_INDEX_1PH__Msk);
    reg = (reg >> PID_PID_COEFF__PID_KFP1_INDEX_1PH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         PID_FORCE member of PID_t                         */
/* -------------------------------------------------------------------------- */

/** __PID_PID_FORCE__ADDRESS returns the address of member PID_FORCE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_FORCE
 */
__PID_INLINE uint32_t* __PID_PID_FORCE__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_FORCE)));
}

/** PID_PID_FORCE__SET() sets PID_FORCE to given value.
 *
 * When writing to PID_FORCE, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_FORCE
 */
__PID_INLINE void PID_PID_FORCE__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_FORCE__ADDRESS(idp), value);
}

/** PID_PID_FORCE__GET() gets PID_FORCE's current value.
 *
 * When reading from PID_FORCE, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FORCE
 */
__PID_INLINE uint32_t PID_PID_FORCE__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_FORCE__ADDRESS(idp));
}

/* -------------------- PID.PID_FORCE.PID_FORCE_DUTY_EN -------------------- */

/**
<pre>
  PID.PID_FORCE.PID_FORCE_DUTY_EN:

    Forced duty cycle select.
    <start table>
    0 "use PID computed Duty Cycle"
    1 "use pid_force_duty"
    <end table>

</pre> */

#define PID_PID_FORCE__PID_FORCE_DUTY_EN__Pos                   8                                                                      /*!< Right-most bit position of pid_force_duty_en in PID.PID_FORCE */
#define PID_PID_FORCE__PID_FORCE_DUTY_EN__Msk                   (0x00000001UL << PID_PID_FORCE__PID_FORCE_DUTY_EN__Pos)                /*!< Mask for pid_force_duty_en in PID.PID_FORCE */
#define PID_PID_FORCE__PID_FORCE_DUTY_EN__Shift(v)              (((v) << PID_PID_FORCE__PID_FORCE_DUTY_EN__Pos) & PID_PID_FORCE__PID_FORCE_DUTY_EN__Msk) /*!< Shift value 'v' into pid_force_duty_en and mask 'v' to fit it into pid_force_duty_en field */

/** PID_PID_FORCE__PID_FORCE_DUTY_EN__SET() sets PID_FORCE.PID_FORCE_DUTY_EN to given value.
 *
 * When writing to PID_FORCE.PID_FORCE_DUTY_EN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FORCE.PID_FORCE_DUTY_EN
 */
__PID_INLINE void PID_PID_FORCE__PID_FORCE_DUTY_EN__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FORCE__GET(idp);
    reg = (reg & ~PID_PID_FORCE__PID_FORCE_DUTY_EN__Msk);
    reg = (reg | (PID_PID_FORCE__PID_FORCE_DUTY_EN__Shift((uint32_t)bf_value)));
    PID_PID_FORCE__SET(idp, reg);
}

/** PID_PID_FORCE__PID_FORCE_DUTY_EN__GET() gets PID_FORCE.PID_FORCE_DUTY_EN's current value.
 *
 * When reading from PID_FORCE.PID_FORCE_DUTY_EN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FORCE.PID_FORCE_DUTY_EN
 */
__PID_INLINE uint32_t PID_PID_FORCE__PID_FORCE_DUTY_EN__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FORCE__GET(idp);
    reg = (reg & PID_PID_FORCE__PID_FORCE_DUTY_EN__Msk);
    reg = (reg >> PID_PID_FORCE__PID_FORCE_DUTY_EN__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FORCE__PID_FORCE_DUTY_EN__MODIFY() modifies PID_FORCE.PID_FORCE_DUTY_EN.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FORCE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FORCE
 * @param bf_value new value for PID_FORCE.PID_FORCE_DUTY_EN
 * @return new value of PID.PID_FORCE
 */
__PID_INLINE uint32_t PID_PID_FORCE__PID_FORCE_DUTY_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FORCE__PID_FORCE_DUTY_EN__Msk);
    reg = (reg | (PID_PID_FORCE__PID_FORCE_DUTY_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FORCE__PID_FORCE_DUTY_EN__EXTRACT() extracts PID_FORCE.PID_FORCE_DUTY_EN.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FORCE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FORCE
 * @return current value of PID_FORCE.PID_FORCE_DUTY_EN
 */
__PID_INLINE uint32_t PID_PID_FORCE__PID_FORCE_DUTY_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FORCE__PID_FORCE_DUTY_EN__Msk);
    reg = (reg >> PID_PID_FORCE__PID_FORCE_DUTY_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PID.PID_FORCE.PID_FORCE_DUTY ---------------------- */

/**
<pre>
  PID.PID_FORCE.PID_FORCE_DUTY:

    Forced duty cycle value overrides the PID output when selected by pid_force_duty_en.  Since this force is applied at the PID output, downstream adjustments to the duty cycle such as current balance in an interleaved (multi-phase) design are still applied.  To also override the current balance adjust use pwm.ramp0_force_duty or pwm.ramp1_force_duty.
    LSB = 2^-8, Range = 0.0 to 0.9961

</pre> */

#define PID_PID_FORCE__PID_FORCE_DUTY__Pos                      0                                                                      /*!< Right-most bit position of pid_force_duty in PID.PID_FORCE */
#define PID_PID_FORCE__PID_FORCE_DUTY__Msk                      (0x000000FFUL << PID_PID_FORCE__PID_FORCE_DUTY__Pos)                   /*!< Mask for pid_force_duty in PID.PID_FORCE */
#define PID_PID_FORCE__PID_FORCE_DUTY__Shift(v)                 (((v) << PID_PID_FORCE__PID_FORCE_DUTY__Pos) & PID_PID_FORCE__PID_FORCE_DUTY__Msk) /*!< Shift value 'v' into pid_force_duty and mask 'v' to fit it into pid_force_duty field */

/** PID_PID_FORCE__PID_FORCE_DUTY__SET() sets PID_FORCE.PID_FORCE_DUTY to given value.
 *
 * When writing to PID_FORCE.PID_FORCE_DUTY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FORCE.PID_FORCE_DUTY
 */
__PID_INLINE void PID_PID_FORCE__PID_FORCE_DUTY__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FORCE__GET(idp);
    reg = (reg & ~PID_PID_FORCE__PID_FORCE_DUTY__Msk);
    reg = (reg | (PID_PID_FORCE__PID_FORCE_DUTY__Shift((uint32_t)bf_value)));
    PID_PID_FORCE__SET(idp, reg);
}

/** PID_PID_FORCE__PID_FORCE_DUTY__GET() gets PID_FORCE.PID_FORCE_DUTY's current value.
 *
 * When reading from PID_FORCE.PID_FORCE_DUTY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FORCE.PID_FORCE_DUTY
 */
__PID_INLINE uint32_t PID_PID_FORCE__PID_FORCE_DUTY__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FORCE__GET(idp);
    reg = (reg & PID_PID_FORCE__PID_FORCE_DUTY__Msk);
    reg = (reg >> PID_PID_FORCE__PID_FORCE_DUTY__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FORCE__PID_FORCE_DUTY__MODIFY() modifies PID_FORCE.PID_FORCE_DUTY.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FORCE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FORCE
 * @param bf_value new value for PID_FORCE.PID_FORCE_DUTY
 * @return new value of PID.PID_FORCE
 */
__PID_INLINE uint32_t PID_PID_FORCE__PID_FORCE_DUTY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FORCE__PID_FORCE_DUTY__Msk);
    reg = (reg | (PID_PID_FORCE__PID_FORCE_DUTY__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FORCE__PID_FORCE_DUTY__EXTRACT() extracts PID_FORCE.PID_FORCE_DUTY.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FORCE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FORCE
 * @return current value of PID_FORCE.PID_FORCE_DUTY
 */
__PID_INLINE uint32_t PID_PID_FORCE__PID_FORCE_DUTY__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FORCE__PID_FORCE_DUTY__Msk);
    reg = (reg >> PID_PID_FORCE__PID_FORCE_DUTY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         PID_TRANS member of PID_t                         */
/* -------------------------------------------------------------------------- */

/** __PID_PID_TRANS__ADDRESS returns the address of member PID_TRANS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_TRANS
 */
__PID_INLINE uint32_t* __PID_PID_TRANS__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_TRANS)));
}

/** PID_PID_TRANS__SET() sets PID_TRANS to given value.
 *
 * When writing to PID_TRANS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_TRANS
 */
__PID_INLINE void PID_PID_TRANS__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_TRANS__ADDRESS(idp), value);
}

/** PID_PID_TRANS__GET() gets PID_TRANS's current value.
 *
 * When reading from PID_TRANS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_TRANS
 */
__PID_INLINE uint32_t PID_PID_TRANS__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_TRANS__ADDRESS(idp));
}

/* ----------------------- PID.PID_TRANS.PID_FTR_LPF ----------------------- */

/**
<pre>
  PID.PID_TRANS.PID_FTR_LPF:

    Fast transient (FTR) mode filter bandwidth on error voltage input.
    <start table>
    0 1MHz
    1 2MHz
    2 4MHz
    3 8MHz
    4+ "Filter bypassed"
    <end table>

</pre> */

#define PID_PID_TRANS__PID_FTR_LPF__Pos                         28                                                                     /*!< Right-most bit position of pid_ftr_lpf in PID.PID_TRANS */
#define PID_PID_TRANS__PID_FTR_LPF__Msk                         (0x00000007UL << PID_PID_TRANS__PID_FTR_LPF__Pos)                      /*!< Mask for pid_ftr_lpf in PID.PID_TRANS */
#define PID_PID_TRANS__PID_FTR_LPF__Shift(v)                    (((v) << PID_PID_TRANS__PID_FTR_LPF__Pos) & PID_PID_TRANS__PID_FTR_LPF__Msk) /*!< Shift value 'v' into pid_ftr_lpf and mask 'v' to fit it into pid_ftr_lpf field */

/** PID_PID_TRANS__PID_FTR_LPF__SET() sets PID_TRANS.PID_FTR_LPF to given value.
 *
 * When writing to PID_TRANS.PID_FTR_LPF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_TRANS.PID_FTR_LPF
 */
__PID_INLINE void PID_PID_TRANS__PID_FTR_LPF__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_TRANS__GET(idp);
    reg = (reg & ~PID_PID_TRANS__PID_FTR_LPF__Msk);
    reg = (reg | (PID_PID_TRANS__PID_FTR_LPF__Shift((uint32_t)bf_value)));
    PID_PID_TRANS__SET(idp, reg);
}

/** PID_PID_TRANS__PID_FTR_LPF__GET() gets PID_TRANS.PID_FTR_LPF's current value.
 *
 * When reading from PID_TRANS.PID_FTR_LPF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_TRANS.PID_FTR_LPF
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_FTR_LPF__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_TRANS__GET(idp);
    reg = (reg & PID_PID_TRANS__PID_FTR_LPF__Msk);
    reg = (reg >> PID_PID_TRANS__PID_FTR_LPF__Pos);
    return (uint32_t)reg;
}

/** PID_PID_TRANS__PID_FTR_LPF__MODIFY() modifies PID_TRANS.PID_FTR_LPF.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_TRANS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_TRANS
 * @param bf_value new value for PID_TRANS.PID_FTR_LPF
 * @return new value of PID.PID_TRANS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_FTR_LPF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_TRANS__PID_FTR_LPF__Msk);
    reg = (reg | (PID_PID_TRANS__PID_FTR_LPF__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_TRANS__PID_FTR_LPF__EXTRACT() extracts PID_TRANS.PID_FTR_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_TRANS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_TRANS
 * @return current value of PID_TRANS.PID_FTR_LPF
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_FTR_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_TRANS__PID_FTR_LPF__Msk);
    reg = (reg >> PID_PID_TRANS__PID_FTR_LPF__Pos);
    return (uint32_t)reg;
}

/* ---------------- PID.PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS ---------------- */

/**
<pre>
  PID.PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS:

    Fast transient (FTR) mode error voltage slope entry threshold where the error voltage is defined as (target voltage - sense voltage).  When (error voltage > pid_verr_entry_thrs) AND (error voltage slope > pid_verr_slope_entry_thrs) the control loop enters fast transient mode.
    Note:
    This threshold is always positive indicating the controller enters fast transient mode as the sensed voltage is decreasing towards maximum undershoot.
    LSB = 1.25mV/clk, Range = 0.0 to 158.75mV/clk at VSEN

</pre> */

#define PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Pos           21                                                                     /*!< Right-most bit position of pid_verr_slope_entry_thrs in PID.PID_TRANS */
#define PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Msk           (0x0000007FUL << PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Pos)        /*!< Mask for pid_verr_slope_entry_thrs in PID.PID_TRANS */
#define PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Shift(v)      (((v) << PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Pos) & PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Msk) /*!< Shift value 'v' into pid_verr_slope_entry_thrs and mask 'v' to fit it into pid_verr_slope_entry_thrs field */

/** PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__SET() sets PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS to given value.
 *
 * When writing to PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS
 */
__PID_INLINE void PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_TRANS__GET(idp);
    reg = (reg & ~PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Msk);
    reg = (reg | (PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Shift((uint32_t)bf_value)));
    PID_PID_TRANS__SET(idp, reg);
}

/** PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__GET() gets PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS's current value.
 *
 * When reading from PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_TRANS__GET(idp);
    reg = (reg & PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Msk);
    reg = (reg >> PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Pos);
    return (uint32_t)reg;
}

/** PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__MODIFY() modifies PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_TRANS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_TRANS
 * @param bf_value new value for PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS
 * @return new value of PID.PID_TRANS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Msk);
    reg = (reg | (PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__EXTRACT() extracts PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_TRANS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_TRANS
 * @return current value of PID_TRANS.PID_VERR_SLOPE_ENTRY_THRS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Msk);
    reg = (reg >> PID_PID_TRANS__PID_VERR_SLOPE_ENTRY_THRS__Pos);
    return (uint32_t)reg;
}

/* ------------------- PID.PID_TRANS.PID_VERR_ENTRY_THRS ------------------- */

/**
<pre>
  PID.PID_TRANS.PID_VERR_ENTRY_THRS:

    Fast transient (FTR) mode error voltage entry threshold where the error voltage is defined as (target voltage - sense voltage).  When (error voltage > pid_verr_entry_thrs) AND (error voltage slope > pid_verr_slope_entry_thrs) the control loop enters fast transient mode.
    Notes:
    1. This threshold is always positive indicating the controller enters fast transient mode only when the sensed voltage is below the target.
    2. Setting pid_verr_entry_thrs=0 disables fast transient mode.
    LSB = 1.25mV, Range = 0.0 to 158.75mV at VSEN

</pre> */

#define PID_PID_TRANS__PID_VERR_ENTRY_THRS__Pos                 14                                                                     /*!< Right-most bit position of pid_verr_entry_thrs in PID.PID_TRANS */
#define PID_PID_TRANS__PID_VERR_ENTRY_THRS__Msk                 (0x0000007FUL << PID_PID_TRANS__PID_VERR_ENTRY_THRS__Pos)              /*!< Mask for pid_verr_entry_thrs in PID.PID_TRANS */
#define PID_PID_TRANS__PID_VERR_ENTRY_THRS__Shift(v)            (((v) << PID_PID_TRANS__PID_VERR_ENTRY_THRS__Pos) & PID_PID_TRANS__PID_VERR_ENTRY_THRS__Msk) /*!< Shift value 'v' into pid_verr_entry_thrs and mask 'v' to fit it into pid_verr_entry_thrs field */

/** PID_PID_TRANS__PID_VERR_ENTRY_THRS__SET() sets PID_TRANS.PID_VERR_ENTRY_THRS to given value.
 *
 * When writing to PID_TRANS.PID_VERR_ENTRY_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_TRANS.PID_VERR_ENTRY_THRS
 */
__PID_INLINE void PID_PID_TRANS__PID_VERR_ENTRY_THRS__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_TRANS__GET(idp);
    reg = (reg & ~PID_PID_TRANS__PID_VERR_ENTRY_THRS__Msk);
    reg = (reg | (PID_PID_TRANS__PID_VERR_ENTRY_THRS__Shift((uint32_t)bf_value)));
    PID_PID_TRANS__SET(idp, reg);
}

/** PID_PID_TRANS__PID_VERR_ENTRY_THRS__GET() gets PID_TRANS.PID_VERR_ENTRY_THRS's current value.
 *
 * When reading from PID_TRANS.PID_VERR_ENTRY_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_TRANS.PID_VERR_ENTRY_THRS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_ENTRY_THRS__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_TRANS__GET(idp);
    reg = (reg & PID_PID_TRANS__PID_VERR_ENTRY_THRS__Msk);
    reg = (reg >> PID_PID_TRANS__PID_VERR_ENTRY_THRS__Pos);
    return (uint32_t)reg;
}

/** PID_PID_TRANS__PID_VERR_ENTRY_THRS__MODIFY() modifies PID_TRANS.PID_VERR_ENTRY_THRS.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_TRANS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_TRANS
 * @param bf_value new value for PID_TRANS.PID_VERR_ENTRY_THRS
 * @return new value of PID.PID_TRANS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_ENTRY_THRS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_TRANS__PID_VERR_ENTRY_THRS__Msk);
    reg = (reg | (PID_PID_TRANS__PID_VERR_ENTRY_THRS__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_TRANS__PID_VERR_ENTRY_THRS__EXTRACT() extracts PID_TRANS.PID_VERR_ENTRY_THRS.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_TRANS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_TRANS
 * @return current value of PID_TRANS.PID_VERR_ENTRY_THRS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_ENTRY_THRS__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_TRANS__PID_VERR_ENTRY_THRS__Msk);
    reg = (reg >> PID_PID_TRANS__PID_VERR_ENTRY_THRS__Pos);
    return (uint32_t)reg;
}

/* ----------------- PID.PID_TRANS.PID_VERR_SLOPE_EXIT_THRS ----------------- */

/**
<pre>
  PID.PID_TRANS.PID_VERR_SLOPE_EXIT_THRS:

    Fast transient (FTR) mode error voltage slope exit threshold where the error voltage is defined as (target voltage - sense voltage).  When (error voltage < pid_verr_exit_thrs) AND (error voltage slope < pid_verr_slope_exit_thrs) the control loop exits fast transient mode.
    Notes:
    1. This threshold is always negative indicating the controller does not exit fast transient mode until the sensed voltage has hit its maximum undershoot and is approaching the target voltage.
    2. There is a -1.25mV offset (i.e., code 0 = -1.25mV, 1 = -2.5mV, ...)
    LSB = -1.25mV/clk, Range = -1.25 to -160mV/clk at VSEN

</pre> */

#define PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Pos            7                                                                      /*!< Right-most bit position of pid_verr_slope_exit_thrs in PID.PID_TRANS */
#define PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Msk            (0x0000007FUL << PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Pos)         /*!< Mask for pid_verr_slope_exit_thrs in PID.PID_TRANS */
#define PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Shift(v)       (((v) << PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Pos) & PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Msk) /*!< Shift value 'v' into pid_verr_slope_exit_thrs and mask 'v' to fit it into pid_verr_slope_exit_thrs field */

/** PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__SET() sets PID_TRANS.PID_VERR_SLOPE_EXIT_THRS to given value.
 *
 * When writing to PID_TRANS.PID_VERR_SLOPE_EXIT_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_TRANS.PID_VERR_SLOPE_EXIT_THRS
 */
__PID_INLINE void PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_TRANS__GET(idp);
    reg = (reg & ~PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Msk);
    reg = (reg | (PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Shift((uint32_t)bf_value)));
    PID_PID_TRANS__SET(idp, reg);
}

/** PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__GET() gets PID_TRANS.PID_VERR_SLOPE_EXIT_THRS's current value.
 *
 * When reading from PID_TRANS.PID_VERR_SLOPE_EXIT_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_TRANS.PID_VERR_SLOPE_EXIT_THRS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_TRANS__GET(idp);
    reg = (reg & PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Msk);
    reg = (reg >> PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Pos);
    return (uint32_t)reg;
}

/** PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__MODIFY() modifies PID_TRANS.PID_VERR_SLOPE_EXIT_THRS.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_TRANS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_TRANS
 * @param bf_value new value for PID_TRANS.PID_VERR_SLOPE_EXIT_THRS
 * @return new value of PID.PID_TRANS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Msk);
    reg = (reg | (PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__EXTRACT() extracts PID_TRANS.PID_VERR_SLOPE_EXIT_THRS.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_TRANS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_TRANS
 * @return current value of PID_TRANS.PID_VERR_SLOPE_EXIT_THRS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Msk);
    reg = (reg >> PID_PID_TRANS__PID_VERR_SLOPE_EXIT_THRS__Pos);
    return (uint32_t)reg;
}

/* -------------------- PID.PID_TRANS.PID_VERR_EXIT_THRS -------------------- */

/**
<pre>
  PID.PID_TRANS.PID_VERR_EXIT_THRS:

    Fast transient (FTR) mode error voltage exit threshold where the error voltage is defined as (target voltage - sense voltage).  When (error voltage < pid_verr_exit_thrs) AND (error voltage slope < pid_verr_slope_exit_thrs) the control loop exits fast transient mode.
    Note:
    This threshold is always positive indicating the controller exits fast transient mode prior to the sensed voltage overshooting the target.
    LSB = 1.25mV, Range = 0.0 to 158.75mV at VSEN

</pre> */

#define PID_PID_TRANS__PID_VERR_EXIT_THRS__Pos                  0                                                                      /*!< Right-most bit position of pid_verr_exit_thrs in PID.PID_TRANS */
#define PID_PID_TRANS__PID_VERR_EXIT_THRS__Msk                  (0x0000007FUL << PID_PID_TRANS__PID_VERR_EXIT_THRS__Pos)               /*!< Mask for pid_verr_exit_thrs in PID.PID_TRANS */
#define PID_PID_TRANS__PID_VERR_EXIT_THRS__Shift(v)             (((v) << PID_PID_TRANS__PID_VERR_EXIT_THRS__Pos) & PID_PID_TRANS__PID_VERR_EXIT_THRS__Msk) /*!< Shift value 'v' into pid_verr_exit_thrs and mask 'v' to fit it into pid_verr_exit_thrs field */

/** PID_PID_TRANS__PID_VERR_EXIT_THRS__SET() sets PID_TRANS.PID_VERR_EXIT_THRS to given value.
 *
 * When writing to PID_TRANS.PID_VERR_EXIT_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_TRANS.PID_VERR_EXIT_THRS
 */
__PID_INLINE void PID_PID_TRANS__PID_VERR_EXIT_THRS__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_TRANS__GET(idp);
    reg = (reg & ~PID_PID_TRANS__PID_VERR_EXIT_THRS__Msk);
    reg = (reg | (PID_PID_TRANS__PID_VERR_EXIT_THRS__Shift((uint32_t)bf_value)));
    PID_PID_TRANS__SET(idp, reg);
}

/** PID_PID_TRANS__PID_VERR_EXIT_THRS__GET() gets PID_TRANS.PID_VERR_EXIT_THRS's current value.
 *
 * When reading from PID_TRANS.PID_VERR_EXIT_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_TRANS.PID_VERR_EXIT_THRS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_EXIT_THRS__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_TRANS__GET(idp);
    reg = (reg & PID_PID_TRANS__PID_VERR_EXIT_THRS__Msk);
    reg = (reg >> PID_PID_TRANS__PID_VERR_EXIT_THRS__Pos);
    return (uint32_t)reg;
}

/** PID_PID_TRANS__PID_VERR_EXIT_THRS__MODIFY() modifies PID_TRANS.PID_VERR_EXIT_THRS.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_TRANS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_TRANS
 * @param bf_value new value for PID_TRANS.PID_VERR_EXIT_THRS
 * @return new value of PID.PID_TRANS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_EXIT_THRS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_TRANS__PID_VERR_EXIT_THRS__Msk);
    reg = (reg | (PID_PID_TRANS__PID_VERR_EXIT_THRS__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_TRANS__PID_VERR_EXIT_THRS__EXTRACT() extracts PID_TRANS.PID_VERR_EXIT_THRS.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_TRANS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_TRANS
 * @return current value of PID_TRANS.PID_VERR_EXIT_THRS
 */
__PID_INLINE uint32_t PID_PID_TRANS__PID_VERR_EXIT_THRS__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_TRANS__PID_VERR_EXIT_THRS__Msk);
    reg = (reg >> PID_PID_TRANS__PID_VERR_EXIT_THRS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          PID_OVS member of PID_t                          */
/* -------------------------------------------------------------------------- */

/** __PID_PID_OVS__ADDRESS returns the address of member PID_OVS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_OVS
 */
__PID_INLINE uint32_t* __PID_PID_OVS__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_OVS)));
}

/** PID_PID_OVS__SET() sets PID_OVS to given value.
 *
 * When writing to PID_OVS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_OVS
 */
__PID_INLINE void PID_PID_OVS__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_OVS__ADDRESS(idp), value);
}

/** PID_PID_OVS__GET() gets PID_OVS's current value.
 *
 * When reading from PID_OVS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OVS
 */
__PID_INLINE uint32_t PID_PID_OVS__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_OVS__ADDRESS(idp));
}

/* ------------------ PID.PID_OVS.PID_OVS_SLOPE_ENTRY_THRS ------------------ */

/**
<pre>
  PID.PID_OVS.PID_OVS_SLOPE_ENTRY_THRS:

    Overshoot transient mode error voltage slope entry threshold where the error voltage is defined as (target voltage - sense voltage).  When (error voltage < pid_ovs_entry_thrs) AND (error voltage slope < pid_ovs_slope_entry_thrs) the control loop enters overshoot transient mode.
    Notes:
    1. This threshold is always negative indicating the controller enters overshoot transient mode as the sensed voltage is increasing towards maximum overshoot.
    2. There is a -1.25mV offset (i.e., code 0 = -1.25mV, 1 = -2.5mV, ...)
    LSB = 1.25mV/clk, Range = 0.0 to 158.75mV/clk at VSEN

</pre> */

#define PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Pos              21                                                                     /*!< Right-most bit position of pid_ovs_slope_entry_thrs in PID.PID_OVS */
#define PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Msk              (0x0000007FUL << PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Pos)           /*!< Mask for pid_ovs_slope_entry_thrs in PID.PID_OVS */
#define PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Shift(v)         (((v) << PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Pos) & PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Msk) /*!< Shift value 'v' into pid_ovs_slope_entry_thrs and mask 'v' to fit it into pid_ovs_slope_entry_thrs field */

/** PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__SET() sets PID_OVS.PID_OVS_SLOPE_ENTRY_THRS to given value.
 *
 * When writing to PID_OVS.PID_OVS_SLOPE_ENTRY_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_OVS.PID_OVS_SLOPE_ENTRY_THRS
 */
__PID_INLINE void PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_OVS__GET(idp);
    reg = (reg & ~PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Msk);
    reg = (reg | (PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Shift((uint32_t)bf_value)));
    PID_PID_OVS__SET(idp, reg);
}

/** PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__GET() gets PID_OVS.PID_OVS_SLOPE_ENTRY_THRS's current value.
 *
 * When reading from PID_OVS.PID_OVS_SLOPE_ENTRY_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OVS.PID_OVS_SLOPE_ENTRY_THRS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_OVS__GET(idp);
    reg = (reg & PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Msk);
    reg = (reg >> PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Pos);
    return (uint32_t)reg;
}

/** PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__MODIFY() modifies PID_OVS.PID_OVS_SLOPE_ENTRY_THRS.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_OVS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_OVS
 * @param bf_value new value for PID_OVS.PID_OVS_SLOPE_ENTRY_THRS
 * @return new value of PID.PID_OVS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Msk);
    reg = (reg | (PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__EXTRACT() extracts PID_OVS.PID_OVS_SLOPE_ENTRY_THRS.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_OVS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_OVS
 * @return current value of PID_OVS.PID_OVS_SLOPE_ENTRY_THRS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Msk);
    reg = (reg >> PID_PID_OVS__PID_OVS_SLOPE_ENTRY_THRS__Pos);
    return (uint32_t)reg;
}

/* --------------------- PID.PID_OVS.PID_OVS_ENTRY_THRS --------------------- */

/**
<pre>
  PID.PID_OVS.PID_OVS_ENTRY_THRS:

    Overshoot transient mode error voltage entry threshold where the error voltage is defined as (target voltage - sense voltage).  When (error voltage < pid_ovs_entry_thrs) AND (error voltage slope < pid_ovs_slope_entry_thrs) the control loop enters overshoot transient mode.
    Notes:
    1. This threshold is always negative indicating the controller enters overshoot transient mode only when the sensed voltage is above the target.
    2. Setting pid_ovs_entry_thrs=0 disables overshoot transient mode.
    3. There is a -1.25mV offset (i.e., code 0 = -1.25mV, 1 = -2.5mV, ...)
    LSB = -1.25mV, Range = -1.25 to -160mV at VSEN

</pre> */

#define PID_PID_OVS__PID_OVS_ENTRY_THRS__Pos                    14                                                                     /*!< Right-most bit position of pid_ovs_entry_thrs in PID.PID_OVS */
#define PID_PID_OVS__PID_OVS_ENTRY_THRS__Msk                    (0x0000007FUL << PID_PID_OVS__PID_OVS_ENTRY_THRS__Pos)                 /*!< Mask for pid_ovs_entry_thrs in PID.PID_OVS */
#define PID_PID_OVS__PID_OVS_ENTRY_THRS__Shift(v)               (((v) << PID_PID_OVS__PID_OVS_ENTRY_THRS__Pos) & PID_PID_OVS__PID_OVS_ENTRY_THRS__Msk) /*!< Shift value 'v' into pid_ovs_entry_thrs and mask 'v' to fit it into pid_ovs_entry_thrs field */

/** PID_PID_OVS__PID_OVS_ENTRY_THRS__SET() sets PID_OVS.PID_OVS_ENTRY_THRS to given value.
 *
 * When writing to PID_OVS.PID_OVS_ENTRY_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_OVS.PID_OVS_ENTRY_THRS
 */
__PID_INLINE void PID_PID_OVS__PID_OVS_ENTRY_THRS__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_OVS__GET(idp);
    reg = (reg & ~PID_PID_OVS__PID_OVS_ENTRY_THRS__Msk);
    reg = (reg | (PID_PID_OVS__PID_OVS_ENTRY_THRS__Shift((uint32_t)bf_value)));
    PID_PID_OVS__SET(idp, reg);
}

/** PID_PID_OVS__PID_OVS_ENTRY_THRS__GET() gets PID_OVS.PID_OVS_ENTRY_THRS's current value.
 *
 * When reading from PID_OVS.PID_OVS_ENTRY_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OVS.PID_OVS_ENTRY_THRS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_ENTRY_THRS__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_OVS__GET(idp);
    reg = (reg & PID_PID_OVS__PID_OVS_ENTRY_THRS__Msk);
    reg = (reg >> PID_PID_OVS__PID_OVS_ENTRY_THRS__Pos);
    return (uint32_t)reg;
}

/** PID_PID_OVS__PID_OVS_ENTRY_THRS__MODIFY() modifies PID_OVS.PID_OVS_ENTRY_THRS.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_OVS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_OVS
 * @param bf_value new value for PID_OVS.PID_OVS_ENTRY_THRS
 * @return new value of PID.PID_OVS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_ENTRY_THRS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_OVS__PID_OVS_ENTRY_THRS__Msk);
    reg = (reg | (PID_PID_OVS__PID_OVS_ENTRY_THRS__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_OVS__PID_OVS_ENTRY_THRS__EXTRACT() extracts PID_OVS.PID_OVS_ENTRY_THRS.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_OVS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_OVS
 * @return current value of PID_OVS.PID_OVS_ENTRY_THRS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_ENTRY_THRS__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_OVS__PID_OVS_ENTRY_THRS__Msk);
    reg = (reg >> PID_PID_OVS__PID_OVS_ENTRY_THRS__Pos);
    return (uint32_t)reg;
}

/* ------------------ PID.PID_OVS.PID_OVS_SLOPE_EXIT_THRS ------------------ */

/**
<pre>
  PID.PID_OVS.PID_OVS_SLOPE_EXIT_THRS:

    Overshoot transient mode error voltage slope exit threshold where the error voltage is defined as (target voltage - sense voltage).  When (error voltage > pid_ovs_exit_thrs) AND (error voltage slope > pid_ovs_slope_exit_thrs) the control loop exits overshoot transient mode.
    Note:
    This threshold is always positive indicating the controller does not exit overshoot transient mode until the sensed voltage has hit its maximum overshoot and is approaching the target voltage.
    LSB = 1.25mV/clk, Range = 0.0 to 158.75mV/clk at VSEN

</pre> */

#define PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Pos               7                                                                      /*!< Right-most bit position of pid_ovs_slope_exit_thrs in PID.PID_OVS */
#define PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Msk               (0x0000007FUL << PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Pos)            /*!< Mask for pid_ovs_slope_exit_thrs in PID.PID_OVS */
#define PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Shift(v)          (((v) << PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Pos) & PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Msk) /*!< Shift value 'v' into pid_ovs_slope_exit_thrs and mask 'v' to fit it into pid_ovs_slope_exit_thrs field */

/** PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__SET() sets PID_OVS.PID_OVS_SLOPE_EXIT_THRS to given value.
 *
 * When writing to PID_OVS.PID_OVS_SLOPE_EXIT_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_OVS.PID_OVS_SLOPE_EXIT_THRS
 */
__PID_INLINE void PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_OVS__GET(idp);
    reg = (reg & ~PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Msk);
    reg = (reg | (PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Shift((uint32_t)bf_value)));
    PID_PID_OVS__SET(idp, reg);
}

/** PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__GET() gets PID_OVS.PID_OVS_SLOPE_EXIT_THRS's current value.
 *
 * When reading from PID_OVS.PID_OVS_SLOPE_EXIT_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OVS.PID_OVS_SLOPE_EXIT_THRS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_OVS__GET(idp);
    reg = (reg & PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Msk);
    reg = (reg >> PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Pos);
    return (uint32_t)reg;
}

/** PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__MODIFY() modifies PID_OVS.PID_OVS_SLOPE_EXIT_THRS.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_OVS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_OVS
 * @param bf_value new value for PID_OVS.PID_OVS_SLOPE_EXIT_THRS
 * @return new value of PID.PID_OVS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Msk);
    reg = (reg | (PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__EXTRACT() extracts PID_OVS.PID_OVS_SLOPE_EXIT_THRS.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_OVS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_OVS
 * @return current value of PID_OVS.PID_OVS_SLOPE_EXIT_THRS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Msk);
    reg = (reg >> PID_PID_OVS__PID_OVS_SLOPE_EXIT_THRS__Pos);
    return (uint32_t)reg;
}

/* --------------------- PID.PID_OVS.PID_OVS_EXIT_THRS --------------------- */

/**
<pre>
  PID.PID_OVS.PID_OVS_EXIT_THRS:

    Overshoot transient mode error voltage exit threshold where the error voltage is defined as (target voltage - where the error voltage is defined as (target voltage - sense voltage).  When (error voltage > pid_ovs_exit_thrs) AND (error voltage slope > pid_ovs_slope_exit_thrs) the control loop exits overshoot transient mode.
    Notes:
    1. This threshold is always negative indicating the controller exits overshoot transient mode prior to the sensed voltage undershooting the target.
    2. There is a -1.25mV offset (i.e., code 0 = -1.25mV, 1 = -2.5mV, ...)
    LSB = -1.25mV, Range = -1.25 to -160mV at VSEN

</pre> */

#define PID_PID_OVS__PID_OVS_EXIT_THRS__Pos                     0                                                                      /*!< Right-most bit position of pid_ovs_exit_thrs in PID.PID_OVS */
#define PID_PID_OVS__PID_OVS_EXIT_THRS__Msk                     (0x0000007FUL << PID_PID_OVS__PID_OVS_EXIT_THRS__Pos)                  /*!< Mask for pid_ovs_exit_thrs in PID.PID_OVS */
#define PID_PID_OVS__PID_OVS_EXIT_THRS__Shift(v)                (((v) << PID_PID_OVS__PID_OVS_EXIT_THRS__Pos) & PID_PID_OVS__PID_OVS_EXIT_THRS__Msk) /*!< Shift value 'v' into pid_ovs_exit_thrs and mask 'v' to fit it into pid_ovs_exit_thrs field */

/** PID_PID_OVS__PID_OVS_EXIT_THRS__SET() sets PID_OVS.PID_OVS_EXIT_THRS to given value.
 *
 * When writing to PID_OVS.PID_OVS_EXIT_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_OVS.PID_OVS_EXIT_THRS
 */
__PID_INLINE void PID_PID_OVS__PID_OVS_EXIT_THRS__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_OVS__GET(idp);
    reg = (reg & ~PID_PID_OVS__PID_OVS_EXIT_THRS__Msk);
    reg = (reg | (PID_PID_OVS__PID_OVS_EXIT_THRS__Shift((uint32_t)bf_value)));
    PID_PID_OVS__SET(idp, reg);
}

/** PID_PID_OVS__PID_OVS_EXIT_THRS__GET() gets PID_OVS.PID_OVS_EXIT_THRS's current value.
 *
 * When reading from PID_OVS.PID_OVS_EXIT_THRS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OVS.PID_OVS_EXIT_THRS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_EXIT_THRS__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_OVS__GET(idp);
    reg = (reg & PID_PID_OVS__PID_OVS_EXIT_THRS__Msk);
    reg = (reg >> PID_PID_OVS__PID_OVS_EXIT_THRS__Pos);
    return (uint32_t)reg;
}

/** PID_PID_OVS__PID_OVS_EXIT_THRS__MODIFY() modifies PID_OVS.PID_OVS_EXIT_THRS.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_OVS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_OVS
 * @param bf_value new value for PID_OVS.PID_OVS_EXIT_THRS
 * @return new value of PID.PID_OVS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_EXIT_THRS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_OVS__PID_OVS_EXIT_THRS__Msk);
    reg = (reg | (PID_PID_OVS__PID_OVS_EXIT_THRS__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_OVS__PID_OVS_EXIT_THRS__EXTRACT() extracts PID_OVS.PID_OVS_EXIT_THRS.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_OVS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_OVS
 * @return current value of PID_OVS.PID_OVS_EXIT_THRS
 */
__PID_INLINE uint32_t PID_PID_OVS__PID_OVS_EXIT_THRS__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_OVS__PID_OVS_EXIT_THRS__Msk);
    reg = (reg >> PID_PID_OVS__PID_OVS_EXIT_THRS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         PID_BURST member of PID_t                         */
/* -------------------------------------------------------------------------- */

/** __PID_PID_BURST__ADDRESS returns the address of member PID_BURST.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_BURST
 */
__PID_INLINE uint32_t* __PID_PID_BURST__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_BURST)));
}

/** PID_PID_BURST__SET() sets PID_BURST to given value.
 *
 * When writing to PID_BURST, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_BURST
 */
__PID_INLINE void PID_PID_BURST__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_BURST__ADDRESS(idp), value);
}

/** PID_PID_BURST__GET() gets PID_BURST's current value.
 *
 * When reading from PID_BURST, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_BURST
 */
__PID_INLINE uint32_t PID_PID_BURST__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_BURST__ADDRESS(idp));
}

/* ---------------------- PID.PID_BURST.PID_BURST_REPS ---------------------- */

/**
<pre>
  PID.PID_BURST.PID_BURST_REPS:

    Burst mode cycle count.  In Burst Mode, 1 cycle corresponds to 1 even half cycle pulse followed by 1 odd half cycle pulse.  This register defines the number of burst cycles in each burst event.  A higher cycle count can be used to increase the inductor peak current in a burst event which will increase the time between burst events at a given load current.
    <start table>
    0 "1 cycle" 2 "4 cycles"
    1 "2 cycles" 3 "8 cycles"
    <end table>

</pre> */

#define PID_PID_BURST__PID_BURST_REPS__Pos                      10                                                                     /*!< Right-most bit position of pid_burst_reps in PID.PID_BURST */
#define PID_PID_BURST__PID_BURST_REPS__Msk                      (0x00000003UL << PID_PID_BURST__PID_BURST_REPS__Pos)                   /*!< Mask for pid_burst_reps in PID.PID_BURST */
#define PID_PID_BURST__PID_BURST_REPS__Shift(v)                 (((v) << PID_PID_BURST__PID_BURST_REPS__Pos) & PID_PID_BURST__PID_BURST_REPS__Msk) /*!< Shift value 'v' into pid_burst_reps and mask 'v' to fit it into pid_burst_reps field */

/** PID_PID_BURST__PID_BURST_REPS__SET() sets PID_BURST.PID_BURST_REPS to given value.
 *
 * When writing to PID_BURST.PID_BURST_REPS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_BURST.PID_BURST_REPS
 */
__PID_INLINE void PID_PID_BURST__PID_BURST_REPS__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_BURST__GET(idp);
    reg = (reg & ~PID_PID_BURST__PID_BURST_REPS__Msk);
    reg = (reg | (PID_PID_BURST__PID_BURST_REPS__Shift((uint32_t)bf_value)));
    PID_PID_BURST__SET(idp, reg);
}

/** PID_PID_BURST__PID_BURST_REPS__GET() gets PID_BURST.PID_BURST_REPS's current value.
 *
 * When reading from PID_BURST.PID_BURST_REPS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_BURST.PID_BURST_REPS
 */
__PID_INLINE uint32_t PID_PID_BURST__PID_BURST_REPS__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_BURST__GET(idp);
    reg = (reg & PID_PID_BURST__PID_BURST_REPS__Msk);
    reg = (reg >> PID_PID_BURST__PID_BURST_REPS__Pos);
    return (uint32_t)reg;
}

/** PID_PID_BURST__PID_BURST_REPS__MODIFY() modifies PID_BURST.PID_BURST_REPS.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_BURST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_BURST
 * @param bf_value new value for PID_BURST.PID_BURST_REPS
 * @return new value of PID.PID_BURST
 */
__PID_INLINE uint32_t PID_PID_BURST__PID_BURST_REPS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_BURST__PID_BURST_REPS__Msk);
    reg = (reg | (PID_PID_BURST__PID_BURST_REPS__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_BURST__PID_BURST_REPS__EXTRACT() extracts PID_BURST.PID_BURST_REPS.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_BURST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_BURST
 * @return current value of PID_BURST.PID_BURST_REPS
 */
__PID_INLINE uint32_t PID_PID_BURST__PID_BURST_REPS__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_BURST__PID_BURST_REPS__Msk);
    reg = (reg >> PID_PID_BURST__PID_BURST_REPS__Pos);
    return (uint32_t)reg;
}

/* -------------------- PID.PID_BURST.PID_BURST_MODE_ITH -------------------- */

/**
<pre>
  PID.PID_BURST.PID_BURST_MODE_ITH:

    Burst mode entry current threshold.  When burst mode is enabled (POWER_MODE[7:0]=0x00), the controller will enter burst mode when the sensed current drops below pid_burst_mode_ith.
    LSB = (Qadc / 2) where Qadc is value of MFR_IOUT_APC in Amps, Range = 0.0 to 31.5 Qadc

</pre> */

#define PID_PID_BURST__PID_BURST_MODE_ITH__Pos                  4                                                                      /*!< Right-most bit position of pid_burst_mode_ith in PID.PID_BURST */
#define PID_PID_BURST__PID_BURST_MODE_ITH__Msk                  (0x0000003FUL << PID_PID_BURST__PID_BURST_MODE_ITH__Pos)               /*!< Mask for pid_burst_mode_ith in PID.PID_BURST */
#define PID_PID_BURST__PID_BURST_MODE_ITH__Shift(v)             (((v) << PID_PID_BURST__PID_BURST_MODE_ITH__Pos) & PID_PID_BURST__PID_BURST_MODE_ITH__Msk) /*!< Shift value 'v' into pid_burst_mode_ith and mask 'v' to fit it into pid_burst_mode_ith field */

/** PID_PID_BURST__PID_BURST_MODE_ITH__SET() sets PID_BURST.PID_BURST_MODE_ITH to given value.
 *
 * When writing to PID_BURST.PID_BURST_MODE_ITH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_BURST.PID_BURST_MODE_ITH
 */
__PID_INLINE void PID_PID_BURST__PID_BURST_MODE_ITH__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_BURST__GET(idp);
    reg = (reg & ~PID_PID_BURST__PID_BURST_MODE_ITH__Msk);
    reg = (reg | (PID_PID_BURST__PID_BURST_MODE_ITH__Shift((uint32_t)bf_value)));
    PID_PID_BURST__SET(idp, reg);
}

/** PID_PID_BURST__PID_BURST_MODE_ITH__GET() gets PID_BURST.PID_BURST_MODE_ITH's current value.
 *
 * When reading from PID_BURST.PID_BURST_MODE_ITH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_BURST.PID_BURST_MODE_ITH
 */
__PID_INLINE uint32_t PID_PID_BURST__PID_BURST_MODE_ITH__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_BURST__GET(idp);
    reg = (reg & PID_PID_BURST__PID_BURST_MODE_ITH__Msk);
    reg = (reg >> PID_PID_BURST__PID_BURST_MODE_ITH__Pos);
    return (uint32_t)reg;
}

/** PID_PID_BURST__PID_BURST_MODE_ITH__MODIFY() modifies PID_BURST.PID_BURST_MODE_ITH.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_BURST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_BURST
 * @param bf_value new value for PID_BURST.PID_BURST_MODE_ITH
 * @return new value of PID.PID_BURST
 */
__PID_INLINE uint32_t PID_PID_BURST__PID_BURST_MODE_ITH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_BURST__PID_BURST_MODE_ITH__Msk);
    reg = (reg | (PID_PID_BURST__PID_BURST_MODE_ITH__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_BURST__PID_BURST_MODE_ITH__EXTRACT() extracts PID_BURST.PID_BURST_MODE_ITH.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_BURST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_BURST
 * @return current value of PID_BURST.PID_BURST_MODE_ITH
 */
__PID_INLINE uint32_t PID_PID_BURST__PID_BURST_MODE_ITH__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_BURST__PID_BURST_MODE_ITH__Msk);
    reg = (reg >> PID_PID_BURST__PID_BURST_MODE_ITH__Pos);
    return (uint32_t)reg;
}

/* ------------------ PID.PID_BURST.PID_BURST_MODE_ERR_THR ------------------ */

/**
<pre>
  PID.PID_BURST.PID_BURST_MODE_ERR_THR:

    Burst mode error voltage threshold where the error voltage is defined as (target voltage - sense voltage).  When the controller is in burst mode, (error voltage > pid_burst_mode_err_thr) will trigger the start of a new burst sequence.
    Note:
    This threshold is always positive indicating the controller triggers the start of a new burst sequence at or below the target voltage.
    LSB = 1.25mV, Range = 0.0 to 18.75mV at VSEN

</pre> */

#define PID_PID_BURST__PID_BURST_MODE_ERR_THR__Pos              0                                                                      /*!< Right-most bit position of pid_burst_mode_err_thr in PID.PID_BURST */
#define PID_PID_BURST__PID_BURST_MODE_ERR_THR__Msk              (0x0000000FUL << PID_PID_BURST__PID_BURST_MODE_ERR_THR__Pos)           /*!< Mask for pid_burst_mode_err_thr in PID.PID_BURST */
#define PID_PID_BURST__PID_BURST_MODE_ERR_THR__Shift(v)         (((v) << PID_PID_BURST__PID_BURST_MODE_ERR_THR__Pos) & PID_PID_BURST__PID_BURST_MODE_ERR_THR__Msk) /*!< Shift value 'v' into pid_burst_mode_err_thr and mask 'v' to fit it into pid_burst_mode_err_thr field */

/** PID_PID_BURST__PID_BURST_MODE_ERR_THR__SET() sets PID_BURST.PID_BURST_MODE_ERR_THR to given value.
 *
 * When writing to PID_BURST.PID_BURST_MODE_ERR_THR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_BURST.PID_BURST_MODE_ERR_THR
 */
__PID_INLINE void PID_PID_BURST__PID_BURST_MODE_ERR_THR__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_BURST__GET(idp);
    reg = (reg & ~PID_PID_BURST__PID_BURST_MODE_ERR_THR__Msk);
    reg = (reg | (PID_PID_BURST__PID_BURST_MODE_ERR_THR__Shift((uint32_t)bf_value)));
    PID_PID_BURST__SET(idp, reg);
}

/** PID_PID_BURST__PID_BURST_MODE_ERR_THR__GET() gets PID_BURST.PID_BURST_MODE_ERR_THR's current value.
 *
 * When reading from PID_BURST.PID_BURST_MODE_ERR_THR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_BURST.PID_BURST_MODE_ERR_THR
 */
__PID_INLINE uint32_t PID_PID_BURST__PID_BURST_MODE_ERR_THR__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_BURST__GET(idp);
    reg = (reg & PID_PID_BURST__PID_BURST_MODE_ERR_THR__Msk);
    reg = (reg >> PID_PID_BURST__PID_BURST_MODE_ERR_THR__Pos);
    return (uint32_t)reg;
}

/** PID_PID_BURST__PID_BURST_MODE_ERR_THR__MODIFY() modifies PID_BURST.PID_BURST_MODE_ERR_THR.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_BURST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_BURST
 * @param bf_value new value for PID_BURST.PID_BURST_MODE_ERR_THR
 * @return new value of PID.PID_BURST
 */
__PID_INLINE uint32_t PID_PID_BURST__PID_BURST_MODE_ERR_THR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_BURST__PID_BURST_MODE_ERR_THR__Msk);
    reg = (reg | (PID_PID_BURST__PID_BURST_MODE_ERR_THR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_BURST__PID_BURST_MODE_ERR_THR__EXTRACT() extracts PID_BURST.PID_BURST_MODE_ERR_THR.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_BURST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_BURST
 * @return current value of PID_BURST.PID_BURST_MODE_ERR_THR
 */
__PID_INLINE uint32_t PID_PID_BURST__PID_BURST_MODE_ERR_THR__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_BURST__PID_BURST_MODE_ERR_THR__Msk);
    reg = (reg >> PID_PID_BURST__PID_BURST_MODE_ERR_THR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        PID_OSP_CFG1 member of PID_t                        */
/* -------------------------------------------------------------------------- */

/** __PID_PID_OSP_CFG1__ADDRESS returns the address of member PID_OSP_CFG1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_OSP_CFG1
 */
__PID_INLINE uint32_t* __PID_PID_OSP_CFG1__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_OSP_CFG1)));
}

/** PID_PID_OSP_CFG1__SET() sets PID_OSP_CFG1 to given value.
 *
 * When writing to PID_OSP_CFG1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_OSP_CFG1
 */
__PID_INLINE void PID_PID_OSP_CFG1__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_OSP_CFG1__ADDRESS(idp), value);
}

/** PID_PID_OSP_CFG1__GET() gets PID_OSP_CFG1's current value.
 *
 * When reading from PID_OSP_CFG1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OSP_CFG1
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG1__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_OSP_CFG1__ADDRESS(idp));
}

/* ------------------- PID.PID_OSP_CFG1.PID_OSP_FF_SCALE ------------------- */

/**
<pre>
  PID.PID_OSP_CFG1.PID_OSP_FF_SCALE:

    Scale factor applied to PID feed forward term to detect an open sense fault between Vout and Vout_sen during soft start.  A setting of 0 will disable this fault check.

</pre> */

#define PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Pos                 14                                                                     /*!< Right-most bit position of pid_osp_ff_scale in PID.PID_OSP_CFG1 */
#define PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Msk                 (0x0000000FUL << PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Pos)              /*!< Mask for pid_osp_ff_scale in PID.PID_OSP_CFG1 */
#define PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Shift(v)            (((v) << PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Pos) & PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Msk) /*!< Shift value 'v' into pid_osp_ff_scale and mask 'v' to fit it into pid_osp_ff_scale field */

/** PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__SET() sets PID_OSP_CFG1.PID_OSP_FF_SCALE to given value.
 *
 * When writing to PID_OSP_CFG1.PID_OSP_FF_SCALE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_OSP_CFG1.PID_OSP_FF_SCALE
 */
__PID_INLINE void PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_OSP_CFG1__GET(idp);
    reg = (reg & ~PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Msk);
    reg = (reg | (PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Shift((uint32_t)bf_value)));
    PID_PID_OSP_CFG1__SET(idp, reg);
}

/** PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__GET() gets PID_OSP_CFG1.PID_OSP_FF_SCALE's current value.
 *
 * When reading from PID_OSP_CFG1.PID_OSP_FF_SCALE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OSP_CFG1.PID_OSP_FF_SCALE
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_OSP_CFG1__GET(idp);
    reg = (reg & PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Msk);
    reg = (reg >> PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Pos);
    return (uint32_t)reg;
}

/** PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__MODIFY() modifies PID_OSP_CFG1.PID_OSP_FF_SCALE.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_OSP_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_OSP_CFG1
 * @param bf_value new value for PID_OSP_CFG1.PID_OSP_FF_SCALE
 * @return new value of PID.PID_OSP_CFG1
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Msk);
    reg = (reg | (PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__EXTRACT() extracts PID_OSP_CFG1.PID_OSP_FF_SCALE.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_OSP_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_OSP_CFG1
 * @return current value of PID_OSP_CFG1.PID_OSP_FF_SCALE
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Msk);
    reg = (reg >> PID_PID_OSP_CFG1__PID_OSP_FF_SCALE__Pos);
    return (uint32_t)reg;
}

/* ------------------- PID.PID_OSP_CFG1.PID_OSP_DUTY_THR ------------------- */

/**
<pre>
  PID.PID_OSP_CFG1.PID_OSP_DUTY_THR:

    Defines the minimum PID duty cycle value, above which to begin checking for an open sense fault during soft start.  This fault will indicate a larger than expected impedance between Vout and Vout_sen.

</pre> */

#define PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Pos                 7                                                                      /*!< Right-most bit position of pid_osp_duty_thr in PID.PID_OSP_CFG1 */
#define PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Msk                 (0x0000007FUL << PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Pos)              /*!< Mask for pid_osp_duty_thr in PID.PID_OSP_CFG1 */
#define PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Shift(v)            (((v) << PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Pos) & PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Msk) /*!< Shift value 'v' into pid_osp_duty_thr and mask 'v' to fit it into pid_osp_duty_thr field */

/** PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__SET() sets PID_OSP_CFG1.PID_OSP_DUTY_THR to given value.
 *
 * When writing to PID_OSP_CFG1.PID_OSP_DUTY_THR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_OSP_CFG1.PID_OSP_DUTY_THR
 */
__PID_INLINE void PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_OSP_CFG1__GET(idp);
    reg = (reg & ~PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Msk);
    reg = (reg | (PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Shift((uint32_t)bf_value)));
    PID_PID_OSP_CFG1__SET(idp, reg);
}

/** PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__GET() gets PID_OSP_CFG1.PID_OSP_DUTY_THR's current value.
 *
 * When reading from PID_OSP_CFG1.PID_OSP_DUTY_THR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OSP_CFG1.PID_OSP_DUTY_THR
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_OSP_CFG1__GET(idp);
    reg = (reg & PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Msk);
    reg = (reg >> PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Pos);
    return (uint32_t)reg;
}

/** PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__MODIFY() modifies PID_OSP_CFG1.PID_OSP_DUTY_THR.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_OSP_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_OSP_CFG1
 * @param bf_value new value for PID_OSP_CFG1.PID_OSP_DUTY_THR
 * @return new value of PID.PID_OSP_CFG1
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Msk);
    reg = (reg | (PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__EXTRACT() extracts PID_OSP_CFG1.PID_OSP_DUTY_THR.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_OSP_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_OSP_CFG1
 * @return current value of PID_OSP_CFG1.PID_OSP_DUTY_THR
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Msk);
    reg = (reg >> PID_PID_OSP_CFG1__PID_OSP_DUTY_THR__Pos);
    return (uint32_t)reg;
}

/* -------------------- PID.PID_OSP_CFG1.PID_OSP_FF_THR -------------------- */

/**
<pre>
  PID.PID_OSP_CFG1.PID_OSP_FF_THR:

    Defines the minimum PID feed forward value, above which to begin checking for an open sense fault during soft start.  This fault will indicate a larger than expected impedance between Vout and Vout_sen.

</pre> */

#define PID_PID_OSP_CFG1__PID_OSP_FF_THR__Pos                   0                                                                      /*!< Right-most bit position of pid_osp_ff_thr in PID.PID_OSP_CFG1 */
#define PID_PID_OSP_CFG1__PID_OSP_FF_THR__Msk                   (0x0000007FUL << PID_PID_OSP_CFG1__PID_OSP_FF_THR__Pos)                /*!< Mask for pid_osp_ff_thr in PID.PID_OSP_CFG1 */
#define PID_PID_OSP_CFG1__PID_OSP_FF_THR__Shift(v)              (((v) << PID_PID_OSP_CFG1__PID_OSP_FF_THR__Pos) & PID_PID_OSP_CFG1__PID_OSP_FF_THR__Msk) /*!< Shift value 'v' into pid_osp_ff_thr and mask 'v' to fit it into pid_osp_ff_thr field */

/** PID_PID_OSP_CFG1__PID_OSP_FF_THR__SET() sets PID_OSP_CFG1.PID_OSP_FF_THR to given value.
 *
 * When writing to PID_OSP_CFG1.PID_OSP_FF_THR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_OSP_CFG1.PID_OSP_FF_THR
 */
__PID_INLINE void PID_PID_OSP_CFG1__PID_OSP_FF_THR__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_OSP_CFG1__GET(idp);
    reg = (reg & ~PID_PID_OSP_CFG1__PID_OSP_FF_THR__Msk);
    reg = (reg | (PID_PID_OSP_CFG1__PID_OSP_FF_THR__Shift((uint32_t)bf_value)));
    PID_PID_OSP_CFG1__SET(idp, reg);
}

/** PID_PID_OSP_CFG1__PID_OSP_FF_THR__GET() gets PID_OSP_CFG1.PID_OSP_FF_THR's current value.
 *
 * When reading from PID_OSP_CFG1.PID_OSP_FF_THR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OSP_CFG1.PID_OSP_FF_THR
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG1__PID_OSP_FF_THR__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_OSP_CFG1__GET(idp);
    reg = (reg & PID_PID_OSP_CFG1__PID_OSP_FF_THR__Msk);
    reg = (reg >> PID_PID_OSP_CFG1__PID_OSP_FF_THR__Pos);
    return (uint32_t)reg;
}

/** PID_PID_OSP_CFG1__PID_OSP_FF_THR__MODIFY() modifies PID_OSP_CFG1.PID_OSP_FF_THR.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_OSP_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_OSP_CFG1
 * @param bf_value new value for PID_OSP_CFG1.PID_OSP_FF_THR
 * @return new value of PID.PID_OSP_CFG1
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG1__PID_OSP_FF_THR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_OSP_CFG1__PID_OSP_FF_THR__Msk);
    reg = (reg | (PID_PID_OSP_CFG1__PID_OSP_FF_THR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_OSP_CFG1__PID_OSP_FF_THR__EXTRACT() extracts PID_OSP_CFG1.PID_OSP_FF_THR.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_OSP_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_OSP_CFG1
 * @return current value of PID_OSP_CFG1.PID_OSP_FF_THR
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG1__PID_OSP_FF_THR__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_OSP_CFG1__PID_OSP_FF_THR__Msk);
    reg = (reg >> PID_PID_OSP_CFG1__PID_OSP_FF_THR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        PID_FF_CFG2 member of PID_t                        */
/* -------------------------------------------------------------------------- */

/** __PID_PID_FF_CFG2__ADDRESS returns the address of member PID_FF_CFG2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_FF_CFG2
 */
__PID_INLINE uint32_t* __PID_PID_FF_CFG2__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_FF_CFG2)));
}

/** PID_PID_FF_CFG2__SET() sets PID_FF_CFG2 to given value.
 *
 * When writing to PID_FF_CFG2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_FF_CFG2
 */
__PID_INLINE void PID_PID_FF_CFG2__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_FF_CFG2__ADDRESS(idp), value);
}

/** PID_PID_FF_CFG2__GET() gets PID_FF_CFG2's current value.
 *
 * When reading from PID_FF_CFG2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG2
 */
__PID_INLINE uint32_t PID_PID_FF_CFG2__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_FF_CFG2__ADDRESS(idp));
}

/* ----------------- PID.PID_FF_CFG2.PID_FF_VRECT_OVERRIDE ----------------- */

/**
<pre>
  PID.PID_FF_CFG2.PID_FF_VRECT_OVERRIDE:

    Vrect override for PID feed forward computation in internal VS ADC format.  Used only when selected by pid_ff_vrect_sel.  If computing from Vin,
    pid_ff_vrect_override(U12.0) =Vin(V) * 800 * MFR_VRECT_SCALE(U0.12) * MFR_TRANSFORMER_SCALE(U0.12) / (2^12 * 2^12)
    LSB = 1.25mV, Range = 0.0 to 5.11875V

</pre> */

#define PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Pos             0                                                                      /*!< Right-most bit position of pid_ff_vrect_override in PID.PID_FF_CFG2 */
#define PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Msk             (0x00000FFFUL << PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Pos)          /*!< Mask for pid_ff_vrect_override in PID.PID_FF_CFG2 */
#define PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Shift(v)        (((v) << PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Pos) & PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Msk) /*!< Shift value 'v' into pid_ff_vrect_override and mask 'v' to fit it into pid_ff_vrect_override field */

/** PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__SET() sets PID_FF_CFG2.PID_FF_VRECT_OVERRIDE to given value.
 *
 * When writing to PID_FF_CFG2.PID_FF_VRECT_OVERRIDE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FF_CFG2.PID_FF_VRECT_OVERRIDE
 */
__PID_INLINE void PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FF_CFG2__GET(idp);
    reg = (reg & ~PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Msk);
    reg = (reg | (PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Shift((uint32_t)bf_value)));
    PID_PID_FF_CFG2__SET(idp, reg);
}

/** PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__GET() gets PID_FF_CFG2.PID_FF_VRECT_OVERRIDE's current value.
 *
 * When reading from PID_FF_CFG2.PID_FF_VRECT_OVERRIDE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG2.PID_FF_VRECT_OVERRIDE
 */
__PID_INLINE uint32_t PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF_CFG2__GET(idp);
    reg = (reg & PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Msk);
    reg = (reg >> PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__MODIFY() modifies PID_FF_CFG2.PID_FF_VRECT_OVERRIDE.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FF_CFG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FF_CFG2
 * @param bf_value new value for PID_FF_CFG2.PID_FF_VRECT_OVERRIDE
 * @return new value of PID.PID_FF_CFG2
 */
__PID_INLINE uint32_t PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Msk);
    reg = (reg | (PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__EXTRACT() extracts PID_FF_CFG2.PID_FF_VRECT_OVERRIDE.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF_CFG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF_CFG2
 * @return current value of PID_FF_CFG2.PID_FF_VRECT_OVERRIDE
 */
__PID_INLINE uint32_t PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Msk);
    reg = (reg >> PID_PID_FF_CFG2__PID_FF_VRECT_OVERRIDE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        PID_FF_CFG4 member of PID_t                        */
/* -------------------------------------------------------------------------- */

/** __PID_PID_FF_CFG4__ADDRESS returns the address of member PID_FF_CFG4.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_FF_CFG4
 */
__PID_INLINE uint32_t* __PID_PID_FF_CFG4__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_FF_CFG4)));
}

/** PID_PID_FF_CFG4__SET() sets PID_FF_CFG4 to given value.
 *
 * When writing to PID_FF_CFG4, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_FF_CFG4
 */
__PID_INLINE void PID_PID_FF_CFG4__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_FF_CFG4__ADDRESS(idp), value);
}

/** PID_PID_FF_CFG4__GET() gets PID_FF_CFG4's current value.
 *
 * When reading from PID_FF_CFG4, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG4
 */
__PID_INLINE uint32_t PID_PID_FF_CFG4__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_FF_CFG4__ADDRESS(idp));
}

/* ------------------ PID.PID_FF_CFG4.PID_FF_OVERRIDE_SEL ------------------ */

/**
<pre>
  PID.PID_FF_CFG4.PID_FF_OVERRIDE_SEL:

    PID feed forward override select.
    <start table>
    0 "use computed feed forward with vrect selected by pid_ff_vrect_sel"
    1 "use pid_ff_override"
    <end table>

</pre> */

#define PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Pos               10                                                                     /*!< Right-most bit position of pid_ff_override_sel in PID.PID_FF_CFG4 */
#define PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Msk               (0x00000001UL << PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Pos)            /*!< Mask for pid_ff_override_sel in PID.PID_FF_CFG4 */
#define PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Shift(v)          (((v) << PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Pos) & PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Msk) /*!< Shift value 'v' into pid_ff_override_sel and mask 'v' to fit it into pid_ff_override_sel field */

/** PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__SET() sets PID_FF_CFG4.PID_FF_OVERRIDE_SEL to given value.
 *
 * When writing to PID_FF_CFG4.PID_FF_OVERRIDE_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FF_CFG4.PID_FF_OVERRIDE_SEL
 */
__PID_INLINE void PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FF_CFG4__GET(idp);
    reg = (reg & ~PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Msk);
    reg = (reg | (PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Shift((uint32_t)bf_value)));
    PID_PID_FF_CFG4__SET(idp, reg);
}

/** PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__GET() gets PID_FF_CFG4.PID_FF_OVERRIDE_SEL's current value.
 *
 * When reading from PID_FF_CFG4.PID_FF_OVERRIDE_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG4.PID_FF_OVERRIDE_SEL
 */
__PID_INLINE uint32_t PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF_CFG4__GET(idp);
    reg = (reg & PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Msk);
    reg = (reg >> PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__MODIFY() modifies PID_FF_CFG4.PID_FF_OVERRIDE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FF_CFG4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FF_CFG4
 * @param bf_value new value for PID_FF_CFG4.PID_FF_OVERRIDE_SEL
 * @return new value of PID.PID_FF_CFG4
 */
__PID_INLINE uint32_t PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Msk);
    reg = (reg | (PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__EXTRACT() extracts PID_FF_CFG4.PID_FF_OVERRIDE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF_CFG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF_CFG4
 * @return current value of PID_FF_CFG4.PID_FF_OVERRIDE_SEL
 */
__PID_INLINE uint32_t PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Msk);
    reg = (reg >> PID_PID_FF_CFG4__PID_FF_OVERRIDE_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------- PID.PID_FF_CFG4.PID_FF_OVERRIDE -------------------- */

/**
<pre>
  PID.PID_FF_CFG4.PID_FF_OVERRIDE:

    PID feed forward override value.  Used when selected by pid_ff_override_sel.  This parameter along with pid_ff_override_sel may be used to override the HW computed FF with a FW computation appropriate for Boost or Buck-Boost derived topologies.
    LSB = 2^-10, Range = 0.0 to 0.9990

</pre> */

#define PID_PID_FF_CFG4__PID_FF_OVERRIDE__Pos                   0                                                                      /*!< Right-most bit position of pid_ff_override in PID.PID_FF_CFG4 */
#define PID_PID_FF_CFG4__PID_FF_OVERRIDE__Msk                   (0x000003FFUL << PID_PID_FF_CFG4__PID_FF_OVERRIDE__Pos)                /*!< Mask for pid_ff_override in PID.PID_FF_CFG4 */
#define PID_PID_FF_CFG4__PID_FF_OVERRIDE__Shift(v)              (((v) << PID_PID_FF_CFG4__PID_FF_OVERRIDE__Pos) & PID_PID_FF_CFG4__PID_FF_OVERRIDE__Msk) /*!< Shift value 'v' into pid_ff_override and mask 'v' to fit it into pid_ff_override field */

/** PID_PID_FF_CFG4__PID_FF_OVERRIDE__SET() sets PID_FF_CFG4.PID_FF_OVERRIDE to given value.
 *
 * When writing to PID_FF_CFG4.PID_FF_OVERRIDE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FF_CFG4.PID_FF_OVERRIDE
 */
__PID_INLINE void PID_PID_FF_CFG4__PID_FF_OVERRIDE__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FF_CFG4__GET(idp);
    reg = (reg & ~PID_PID_FF_CFG4__PID_FF_OVERRIDE__Msk);
    reg = (reg | (PID_PID_FF_CFG4__PID_FF_OVERRIDE__Shift((uint32_t)bf_value)));
    PID_PID_FF_CFG4__SET(idp, reg);
}

/** PID_PID_FF_CFG4__PID_FF_OVERRIDE__GET() gets PID_FF_CFG4.PID_FF_OVERRIDE's current value.
 *
 * When reading from PID_FF_CFG4.PID_FF_OVERRIDE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG4.PID_FF_OVERRIDE
 */
__PID_INLINE uint32_t PID_PID_FF_CFG4__PID_FF_OVERRIDE__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF_CFG4__GET(idp);
    reg = (reg & PID_PID_FF_CFG4__PID_FF_OVERRIDE__Msk);
    reg = (reg >> PID_PID_FF_CFG4__PID_FF_OVERRIDE__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF_CFG4__PID_FF_OVERRIDE__MODIFY() modifies PID_FF_CFG4.PID_FF_OVERRIDE.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FF_CFG4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FF_CFG4
 * @param bf_value new value for PID_FF_CFG4.PID_FF_OVERRIDE
 * @return new value of PID.PID_FF_CFG4
 */
__PID_INLINE uint32_t PID_PID_FF_CFG4__PID_FF_OVERRIDE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FF_CFG4__PID_FF_OVERRIDE__Msk);
    reg = (reg | (PID_PID_FF_CFG4__PID_FF_OVERRIDE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FF_CFG4__PID_FF_OVERRIDE__EXTRACT() extracts PID_FF_CFG4.PID_FF_OVERRIDE.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF_CFG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF_CFG4
 * @return current value of PID_FF_CFG4.PID_FF_OVERRIDE
 */
__PID_INLINE uint32_t PID_PID_FF_CFG4__PID_FF_OVERRIDE__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF_CFG4__PID_FF_OVERRIDE__Msk);
    reg = (reg >> PID_PID_FF_CFG4__PID_FF_OVERRIDE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        PID_FF_CFG3 member of PID_t                        */
/* -------------------------------------------------------------------------- */

/** __PID_PID_FF_CFG3__ADDRESS returns the address of member PID_FF_CFG3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_FF_CFG3
 */
__PID_INLINE uint32_t* __PID_PID_FF_CFG3__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_FF_CFG3)));
}

/** PID_PID_FF_CFG3__SET() sets PID_FF_CFG3 to given value.
 *
 * When writing to PID_FF_CFG3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_FF_CFG3
 */
__PID_INLINE void PID_PID_FF_CFG3__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_FF_CFG3__ADDRESS(idp), value);
}

/** PID_PID_FF_CFG3__GET() gets PID_FF_CFG3's current value.
 *
 * When reading from PID_FF_CFG3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG3
 */
__PID_INLINE uint32_t PID_PID_FF_CFG3__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_FF_CFG3__ADDRESS(idp));
}

/* ------------ PID.PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP ------------ */

/**
<pre>
  PID.PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP:

    Conversion factor for computing 1/Vrect from the Telemtry Sense ADC Vin measurement.  This parameter is computed automatically by the default FW and requires no action by the user.
    Computed from PMBus commands as follows:
    <start table>
    "exp = $signed(MFR_TRANSFORMER_SCALE[15:11]), exp=-10, -11, -12 supported"
    "quot1(U5.7) = 2^(-3-exp) / MFR_TRANSFORMER_SCALE[9:0]"
    "pid_ff_i82_div_trans_scale_loop(U-4.23) = quot1(U5.7) * 82 (U-9.16)"
    <end table>

</pre> */

#define PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Pos   9                                                                      /*!< Right-most bit position of pid_ff_i82_div_trans_scale_loop in PID.PID_FF_CFG3 */
#define PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Msk   (0x0007FFFFUL << PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Pos) /*!< Mask for pid_ff_i82_div_trans_scale_loop in PID.PID_FF_CFG3 */
#define PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Shift(v) (((v) << PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Pos) & PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Msk) /*!< Shift value 'v' into pid_ff_i82_div_trans_scale_loop and mask 'v' to fit it into pid_ff_i82_div_trans_scale_loop field */

/** PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__SET() sets PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP to given value.
 *
 * When writing to PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP
 */
__PID_INLINE void PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FF_CFG3__GET(idp);
    reg = (reg & ~PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Msk);
    reg = (reg | (PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Shift((uint32_t)bf_value)));
    PID_PID_FF_CFG3__SET(idp, reg);
}

/** PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__GET() gets PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP's current value.
 *
 * When reading from PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP
 */
__PID_INLINE uint32_t PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF_CFG3__GET(idp);
    reg = (reg & PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Msk);
    reg = (reg >> PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__MODIFY() modifies PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FF_CFG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FF_CFG3
 * @param bf_value new value for PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP
 * @return new value of PID.PID_FF_CFG3
 */
__PID_INLINE uint32_t PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Msk);
    reg = (reg | (PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__EXTRACT() extracts PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF_CFG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF_CFG3
 * @return current value of PID_FF_CFG3.PID_FF_I82_DIV_TRANS_SCALE_LOOP
 */
__PID_INLINE uint32_t PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Msk);
    reg = (reg >> PID_PID_FF_CFG3__PID_FF_I82_DIV_TRANS_SCALE_LOOP__Pos);
    return (uint32_t)reg;
}

/* ------------- PID.PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP ------------- */

/**
<pre>
  PID.PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP:

    Conversion factor for computing Vout from the measured VS ADC output.  This parameter is computed automatically by the default FW and requires no action by the user.
    Computed from PMBus commands as follows:
    <start table>
    "pid_ff_one_div_vout_scale_loop(U6.3) = 2^19 / VOUT_SCALE_LOOP(U0.16), clamp to 2^9-1"
    <end table>

</pre> */

#define PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Pos    0                                                                      /*!< Right-most bit position of pid_ff_one_div_vout_scale_loop in PID.PID_FF_CFG3 */
#define PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Msk    (0x000001FFUL << PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Pos) /*!< Mask for pid_ff_one_div_vout_scale_loop in PID.PID_FF_CFG3 */
#define PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Shift(v) (((v) << PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Pos) & PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Msk) /*!< Shift value 'v' into pid_ff_one_div_vout_scale_loop and mask 'v' to fit it into pid_ff_one_div_vout_scale_loop field */

/** PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__SET() sets PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP to given value.
 *
 * When writing to PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP
 */
__PID_INLINE void PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FF_CFG3__GET(idp);
    reg = (reg & ~PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Msk);
    reg = (reg | (PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Shift((uint32_t)bf_value)));
    PID_PID_FF_CFG3__SET(idp, reg);
}

/** PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__GET() gets PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP's current value.
 *
 * When reading from PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP
 */
__PID_INLINE uint32_t PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF_CFG3__GET(idp);
    reg = (reg & PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Msk);
    reg = (reg >> PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__MODIFY() modifies PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FF_CFG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FF_CFG3
 * @param bf_value new value for PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP
 * @return new value of PID.PID_FF_CFG3
 */
__PID_INLINE uint32_t PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Msk);
    reg = (reg | (PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__EXTRACT() extracts PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF_CFG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF_CFG3
 * @return current value of PID_FF_CFG3.PID_FF_ONE_DIV_VOUT_SCALE_LOOP
 */
__PID_INLINE uint32_t PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Msk);
    reg = (reg >> PID_PID_FF_CFG3__PID_FF_ONE_DIV_VOUT_SCALE_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         PID_COEFF2 member of PID_t                         */
/* -------------------------------------------------------------------------- */

/** __PID_PID_COEFF2__ADDRESS returns the address of member PID_COEFF2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_COEFF2
 */
__PID_INLINE uint32_t* __PID_PID_COEFF2__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_COEFF2)));
}

/** PID_PID_COEFF2__GET() gets PID_COEFF2's current value.
 *
 * When reading from PID_COEFF2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_COEFF2
 */
__PID_INLINE uint32_t PID_PID_COEFF2__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_COEFF2__ADDRESS(idp));
}

/* ----------------------- PID.PID_COEFF2.PID_KD_EFF ----------------------- */

/**
<pre>
  PID.PID_COEFF2.PID_KD_EFF:

    PID Kd coefficient value after Vin scaling.  See pid_kd_index_1ph description for definition.

</pre> */

#define PID_PID_COEFF2__PID_KD_EFF__Pos                         12                                                                     /*!< Right-most bit position of pid_kd_eff in PID.PID_COEFF2 */
#define PID_PID_COEFF2__PID_KD_EFF__Msk                         (0x0000007FUL << PID_PID_COEFF2__PID_KD_EFF__Pos)                      /*!< Mask for pid_kd_eff in PID.PID_COEFF2 */
#define PID_PID_COEFF2__PID_KD_EFF__Shift(v)                    (((v) << PID_PID_COEFF2__PID_KD_EFF__Pos) & PID_PID_COEFF2__PID_KD_EFF__Msk) /*!< Shift value 'v' into pid_kd_eff and mask 'v' to fit it into pid_kd_eff field */

/** PID_PID_COEFF2__PID_KD_EFF__GET() gets PID_COEFF2.PID_KD_EFF's current value.
 *
 * When reading from PID_COEFF2.PID_KD_EFF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_COEFF2.PID_KD_EFF
 */
__PID_INLINE uint32_t PID_PID_COEFF2__PID_KD_EFF__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_COEFF2__GET(idp);
    reg = (reg & PID_PID_COEFF2__PID_KD_EFF__Msk);
    reg = (reg >> PID_PID_COEFF2__PID_KD_EFF__Pos);
    return (uint32_t)reg;
}

/** PID_PID_COEFF2__PID_KD_EFF__EXTRACT() extracts PID_COEFF2.PID_KD_EFF.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_COEFF2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_COEFF2
 * @return current value of PID_COEFF2.PID_KD_EFF
 */
__PID_INLINE uint32_t PID_PID_COEFF2__PID_KD_EFF__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_COEFF2__PID_KD_EFF__Msk);
    reg = (reg >> PID_PID_COEFF2__PID_KD_EFF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PID.PID_COEFF2.PID_KI_EFF ----------------------- */

/**
<pre>
  PID.PID_COEFF2.PID_KI_EFF:

    PID Ki coefficient value after Vin scaling.  See pid_ki_index_1ph description for definition.

</pre> */

#define PID_PID_COEFF2__PID_KI_EFF__Pos                         6                                                                      /*!< Right-most bit position of pid_ki_eff in PID.PID_COEFF2 */
#define PID_PID_COEFF2__PID_KI_EFF__Msk                         (0x0000003FUL << PID_PID_COEFF2__PID_KI_EFF__Pos)                      /*!< Mask for pid_ki_eff in PID.PID_COEFF2 */
#define PID_PID_COEFF2__PID_KI_EFF__Shift(v)                    (((v) << PID_PID_COEFF2__PID_KI_EFF__Pos) & PID_PID_COEFF2__PID_KI_EFF__Msk) /*!< Shift value 'v' into pid_ki_eff and mask 'v' to fit it into pid_ki_eff field */

/** PID_PID_COEFF2__PID_KI_EFF__GET() gets PID_COEFF2.PID_KI_EFF's current value.
 *
 * When reading from PID_COEFF2.PID_KI_EFF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_COEFF2.PID_KI_EFF
 */
__PID_INLINE uint32_t PID_PID_COEFF2__PID_KI_EFF__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_COEFF2__GET(idp);
    reg = (reg & PID_PID_COEFF2__PID_KI_EFF__Msk);
    reg = (reg >> PID_PID_COEFF2__PID_KI_EFF__Pos);
    return (uint32_t)reg;
}

/** PID_PID_COEFF2__PID_KI_EFF__EXTRACT() extracts PID_COEFF2.PID_KI_EFF.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_COEFF2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_COEFF2
 * @return current value of PID_COEFF2.PID_KI_EFF
 */
__PID_INLINE uint32_t PID_PID_COEFF2__PID_KI_EFF__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_COEFF2__PID_KI_EFF__Msk);
    reg = (reg >> PID_PID_COEFF2__PID_KI_EFF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PID.PID_COEFF2.PID_KP_EFF ----------------------- */

/**
<pre>
  PID.PID_COEFF2.PID_KP_EFF:

    PID Kp coefficient value after Vin scaling.  See pid_kp_index_1ph description for definition.

</pre> */

#define PID_PID_COEFF2__PID_KP_EFF__Pos                         0                                                                      /*!< Right-most bit position of pid_kp_eff in PID.PID_COEFF2 */
#define PID_PID_COEFF2__PID_KP_EFF__Msk                         (0x0000003FUL << PID_PID_COEFF2__PID_KP_EFF__Pos)                      /*!< Mask for pid_kp_eff in PID.PID_COEFF2 */
#define PID_PID_COEFF2__PID_KP_EFF__Shift(v)                    (((v) << PID_PID_COEFF2__PID_KP_EFF__Pos) & PID_PID_COEFF2__PID_KP_EFF__Msk) /*!< Shift value 'v' into pid_kp_eff and mask 'v' to fit it into pid_kp_eff field */

/** PID_PID_COEFF2__PID_KP_EFF__GET() gets PID_COEFF2.PID_KP_EFF's current value.
 *
 * When reading from PID_COEFF2.PID_KP_EFF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_COEFF2.PID_KP_EFF
 */
__PID_INLINE uint32_t PID_PID_COEFF2__PID_KP_EFF__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_COEFF2__GET(idp);
    reg = (reg & PID_PID_COEFF2__PID_KP_EFF__Msk);
    reg = (reg >> PID_PID_COEFF2__PID_KP_EFF__Pos);
    return (uint32_t)reg;
}

/** PID_PID_COEFF2__PID_KP_EFF__EXTRACT() extracts PID_COEFF2.PID_KP_EFF.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_COEFF2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_COEFF2
 * @return current value of PID_COEFF2.PID_KP_EFF
 */
__PID_INLINE uint32_t PID_PID_COEFF2__PID_KP_EFF__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_COEFF2__PID_KP_EFF__Msk);
    reg = (reg >> PID_PID_COEFF2__PID_KP_EFF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      PID_RESET_ACCUM member of PID_t                      */
/* -------------------------------------------------------------------------- */

/** __PID_PID_RESET_ACCUM__ADDRESS returns the address of member PID_RESET_ACCUM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_RESET_ACCUM
 */
__PID_INLINE uint32_t* __PID_PID_RESET_ACCUM__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_RESET_ACCUM)));
}

/** PID_PID_RESET_ACCUM__SET() sets PID_RESET_ACCUM to given value.
 *
 * When writing to PID_RESET_ACCUM, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_RESET_ACCUM
 */
__PID_INLINE void PID_PID_RESET_ACCUM__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_RESET_ACCUM__ADDRESS(idp), value);
}

/** PID_PID_RESET_ACCUM__GET() gets PID_RESET_ACCUM's current value.
 *
 * When reading from PID_RESET_ACCUM, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_RESET_ACCUM
 */
__PID_INLINE uint32_t PID_PID_RESET_ACCUM__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_RESET_ACCUM__ADDRESS(idp));
}

/* ------------------ PID.PID_RESET_ACCUM.PID_RESET_ACCUM ------------------ */

/**
<pre>
  PID.PID_RESET_ACCUM.PID_RESET_ACCUM:

    PID integral term accumulator reset.  Allows FW to reset the accumulator by first writing a 1 to reset the accumulator followed by writing a 0 to release the reset.
    <start table>
    0 "accumulator operating normally"
    1 "accumulator reset to 0"
    <end table>

</pre> */

#define PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Pos               0                                                                      /*!< Right-most bit position of pid_reset_accum in PID.PID_RESET_ACCUM */
#define PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Msk               (0x00000001UL << PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Pos)            /*!< Mask for pid_reset_accum in PID.PID_RESET_ACCUM */
#define PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Shift(v)          (((v) << PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Pos) & PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Msk) /*!< Shift value 'v' into pid_reset_accum and mask 'v' to fit it into pid_reset_accum field */

/** PID_PID_RESET_ACCUM__PID_RESET_ACCUM__SET() sets PID_RESET_ACCUM.PID_RESET_ACCUM to given value.
 *
 * When writing to PID_RESET_ACCUM.PID_RESET_ACCUM, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_RESET_ACCUM.PID_RESET_ACCUM
 */
__PID_INLINE void PID_PID_RESET_ACCUM__PID_RESET_ACCUM__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_RESET_ACCUM__GET(idp);
    reg = (reg & ~PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Msk);
    reg = (reg | (PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Shift((uint32_t)bf_value)));
    PID_PID_RESET_ACCUM__SET(idp, reg);
}

/** PID_PID_RESET_ACCUM__PID_RESET_ACCUM__GET() gets PID_RESET_ACCUM.PID_RESET_ACCUM's current value.
 *
 * When reading from PID_RESET_ACCUM.PID_RESET_ACCUM, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_RESET_ACCUM.PID_RESET_ACCUM
 */
__PID_INLINE uint32_t PID_PID_RESET_ACCUM__PID_RESET_ACCUM__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_RESET_ACCUM__GET(idp);
    reg = (reg & PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Msk);
    reg = (reg >> PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Pos);
    return (uint32_t)reg;
}

/** PID_PID_RESET_ACCUM__PID_RESET_ACCUM__MODIFY() modifies PID_RESET_ACCUM.PID_RESET_ACCUM.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_RESET_ACCUM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_RESET_ACCUM
 * @param bf_value new value for PID_RESET_ACCUM.PID_RESET_ACCUM
 * @return new value of PID.PID_RESET_ACCUM
 */
__PID_INLINE uint32_t PID_PID_RESET_ACCUM__PID_RESET_ACCUM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Msk);
    reg = (reg | (PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_RESET_ACCUM__PID_RESET_ACCUM__EXTRACT() extracts PID_RESET_ACCUM.PID_RESET_ACCUM.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_RESET_ACCUM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_RESET_ACCUM
 * @return current value of PID_RESET_ACCUM.PID_RESET_ACCUM
 */
__PID_INLINE uint32_t PID_PID_RESET_ACCUM__PID_RESET_ACCUM__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Msk);
    reg = (reg >> PID_PID_RESET_ACCUM__PID_RESET_ACCUM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      PID_FREEZE_ACCUM member of PID_t                      */
/* -------------------------------------------------------------------------- */

/** __PID_PID_FREEZE_ACCUM__ADDRESS returns the address of member PID_FREEZE_ACCUM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_FREEZE_ACCUM
 */
__PID_INLINE uint32_t* __PID_PID_FREEZE_ACCUM__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_FREEZE_ACCUM)));
}

/** PID_PID_FREEZE_ACCUM__SET() sets PID_FREEZE_ACCUM to given value.
 *
 * When writing to PID_FREEZE_ACCUM, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_FREEZE_ACCUM
 */
__PID_INLINE void PID_PID_FREEZE_ACCUM__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_FREEZE_ACCUM__ADDRESS(idp), value);
}

/** PID_PID_FREEZE_ACCUM__GET() gets PID_FREEZE_ACCUM's current value.
 *
 * When reading from PID_FREEZE_ACCUM, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FREEZE_ACCUM
 */
__PID_INLINE uint32_t PID_PID_FREEZE_ACCUM__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_FREEZE_ACCUM__ADDRESS(idp));
}

/* ----------------- PID.PID_FREEZE_ACCUM.PID_FREEZE_ACCUM ----------------- */

/**
<pre>
  PID.PID_FREEZE_ACCUM.PID_FREEZE_ACCUM:

    PID integral term accumulator freeze control.  Allows FW to hold the accumulator at its current value by writing a 1 until it is released by writing a 0.
    <start table>
    0 "accumulator operating normally"
    1 "accumulator value frozen"
    <end table>

</pre> */

#define PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Pos             0                                                                      /*!< Right-most bit position of pid_freeze_accum in PID.PID_FREEZE_ACCUM */
#define PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Msk             (0x00000001UL << PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Pos)          /*!< Mask for pid_freeze_accum in PID.PID_FREEZE_ACCUM */
#define PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Shift(v)        (((v) << PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Pos) & PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Msk) /*!< Shift value 'v' into pid_freeze_accum and mask 'v' to fit it into pid_freeze_accum field */

/** PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__SET() sets PID_FREEZE_ACCUM.PID_FREEZE_ACCUM to given value.
 *
 * When writing to PID_FREEZE_ACCUM.PID_FREEZE_ACCUM, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_FREEZE_ACCUM.PID_FREEZE_ACCUM
 */
__PID_INLINE void PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_FREEZE_ACCUM__GET(idp);
    reg = (reg & ~PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Msk);
    reg = (reg | (PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Shift((uint32_t)bf_value)));
    PID_PID_FREEZE_ACCUM__SET(idp, reg);
}

/** PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__GET() gets PID_FREEZE_ACCUM.PID_FREEZE_ACCUM's current value.
 *
 * When reading from PID_FREEZE_ACCUM.PID_FREEZE_ACCUM, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FREEZE_ACCUM.PID_FREEZE_ACCUM
 */
__PID_INLINE uint32_t PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FREEZE_ACCUM__GET(idp);
    reg = (reg & PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Msk);
    reg = (reg >> PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__MODIFY() modifies PID_FREEZE_ACCUM.PID_FREEZE_ACCUM.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_FREEZE_ACCUM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_FREEZE_ACCUM
 * @param bf_value new value for PID_FREEZE_ACCUM.PID_FREEZE_ACCUM
 * @return new value of PID.PID_FREEZE_ACCUM
 */
__PID_INLINE uint32_t PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Msk);
    reg = (reg | (PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__EXTRACT() extracts PID_FREEZE_ACCUM.PID_FREEZE_ACCUM.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FREEZE_ACCUM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FREEZE_ACCUM
 * @return current value of PID_FREEZE_ACCUM.PID_FREEZE_ACCUM
 */
__PID_INLINE uint32_t PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Msk);
    reg = (reg >> PID_PID_FREEZE_ACCUM__PID_FREEZE_ACCUM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        PID_OSP_CFG2 member of PID_t                        */
/* -------------------------------------------------------------------------- */

/** __PID_PID_OSP_CFG2__ADDRESS returns the address of member PID_OSP_CFG2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_OSP_CFG2
 */
__PID_INLINE uint32_t* __PID_PID_OSP_CFG2__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_OSP_CFG2)));
}

/** PID_PID_OSP_CFG2__SET() sets PID_OSP_CFG2 to given value.
 *
 * When writing to PID_OSP_CFG2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_OSP_CFG2
 */
__PID_INLINE void PID_PID_OSP_CFG2__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_OSP_CFG2__ADDRESS(idp), value);
}

/** PID_PID_OSP_CFG2__GET() gets PID_OSP_CFG2's current value.
 *
 * When reading from PID_OSP_CFG2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OSP_CFG2
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG2__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_OSP_CFG2__ADDRESS(idp));
}

/* ------------------- PID.PID_OSP_CFG2.PID_OSP_VOUT_THR ------------------- */

/**
<pre>
  PID.PID_OSP_CFG2.PID_OSP_VOUT_THR:

    Not used

</pre> */

#define PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Pos                 0                                                                      /*!< Right-most bit position of pid_osp_vout_thr in PID.PID_OSP_CFG2 */
#define PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Msk                 (0x0000007FUL << PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Pos)              /*!< Mask for pid_osp_vout_thr in PID.PID_OSP_CFG2 */
#define PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Shift(v)            (((v) << PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Pos) & PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Msk) /*!< Shift value 'v' into pid_osp_vout_thr and mask 'v' to fit it into pid_osp_vout_thr field */

/** PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__SET() sets PID_OSP_CFG2.PID_OSP_VOUT_THR to given value.
 *
 * When writing to PID_OSP_CFG2.PID_OSP_VOUT_THR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_OSP_CFG2.PID_OSP_VOUT_THR
 */
__PID_INLINE void PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_OSP_CFG2__GET(idp);
    reg = (reg & ~PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Msk);
    reg = (reg | (PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Shift((uint32_t)bf_value)));
    PID_PID_OSP_CFG2__SET(idp, reg);
}

/** PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__GET() gets PID_OSP_CFG2.PID_OSP_VOUT_THR's current value.
 *
 * When reading from PID_OSP_CFG2.PID_OSP_VOUT_THR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OSP_CFG2.PID_OSP_VOUT_THR
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_OSP_CFG2__GET(idp);
    reg = (reg & PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Msk);
    reg = (reg >> PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Pos);
    return (uint32_t)reg;
}

/** PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__MODIFY() modifies PID_OSP_CFG2.PID_OSP_VOUT_THR.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_OSP_CFG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_OSP_CFG2
 * @param bf_value new value for PID_OSP_CFG2.PID_OSP_VOUT_THR
 * @return new value of PID.PID_OSP_CFG2
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Msk);
    reg = (reg | (PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__EXTRACT() extracts PID_OSP_CFG2.PID_OSP_VOUT_THR.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_OSP_CFG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_OSP_CFG2
 * @return current value of PID_OSP_CFG2.PID_OSP_VOUT_THR
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Msk);
    reg = (reg >> PID_PID_OSP_CFG2__PID_OSP_VOUT_THR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        PID_OSP_CFG3 member of PID_t                        */
/* -------------------------------------------------------------------------- */

/** __PID_PID_OSP_CFG3__ADDRESS returns the address of member PID_OSP_CFG3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_OSP_CFG3
 */
__PID_INLINE uint32_t* __PID_PID_OSP_CFG3__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_OSP_CFG3)));
}

/** PID_PID_OSP_CFG3__SET() sets PID_OSP_CFG3 to given value.
 *
 * When writing to PID_OSP_CFG3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_OSP_CFG3
 */
__PID_INLINE void PID_PID_OSP_CFG3__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_OSP_CFG3__ADDRESS(idp), value);
}

/** PID_PID_OSP_CFG3__GET() gets PID_OSP_CFG3's current value.
 *
 * When reading from PID_OSP_CFG3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OSP_CFG3
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG3__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_OSP_CFG3__ADDRESS(idp));
}

/* ------------------- PID.PID_OSP_CFG3.PID_OSP_VRECT_THR ------------------- */

/**
<pre>
  PID.PID_OSP_CFG3.PID_OSP_VRECT_THR:

    Not used

</pre> */

#define PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Pos                0                                                                      /*!< Right-most bit position of pid_osp_vrect_thr in PID.PID_OSP_CFG3 */
#define PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Msk                (0x0000007FUL << PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Pos)             /*!< Mask for pid_osp_vrect_thr in PID.PID_OSP_CFG3 */
#define PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Shift(v)           (((v) << PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Pos) & PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Msk) /*!< Shift value 'v' into pid_osp_vrect_thr and mask 'v' to fit it into pid_osp_vrect_thr field */

/** PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__SET() sets PID_OSP_CFG3.PID_OSP_VRECT_THR to given value.
 *
 * When writing to PID_OSP_CFG3.PID_OSP_VRECT_THR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_OSP_CFG3.PID_OSP_VRECT_THR
 */
__PID_INLINE void PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_OSP_CFG3__GET(idp);
    reg = (reg & ~PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Msk);
    reg = (reg | (PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Shift((uint32_t)bf_value)));
    PID_PID_OSP_CFG3__SET(idp, reg);
}

/** PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__GET() gets PID_OSP_CFG3.PID_OSP_VRECT_THR's current value.
 *
 * When reading from PID_OSP_CFG3.PID_OSP_VRECT_THR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OSP_CFG3.PID_OSP_VRECT_THR
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_OSP_CFG3__GET(idp);
    reg = (reg & PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Msk);
    reg = (reg >> PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Pos);
    return (uint32_t)reg;
}

/** PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__MODIFY() modifies PID_OSP_CFG3.PID_OSP_VRECT_THR.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_OSP_CFG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_OSP_CFG3
 * @param bf_value new value for PID_OSP_CFG3.PID_OSP_VRECT_THR
 * @return new value of PID.PID_OSP_CFG3
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Msk);
    reg = (reg | (PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__EXTRACT() extracts PID_OSP_CFG3.PID_OSP_VRECT_THR.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_OSP_CFG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_OSP_CFG3
 * @return current value of PID_OSP_CFG3.PID_OSP_VRECT_THR
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Msk);
    reg = (reg >> PID_PID_OSP_CFG3__PID_OSP_VRECT_THR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        PID_OSP_CFG4 member of PID_t                        */
/* -------------------------------------------------------------------------- */

/** __PID_PID_OSP_CFG4__ADDRESS returns the address of member PID_OSP_CFG4.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_OSP_CFG4
 */
__PID_INLINE uint32_t* __PID_PID_OSP_CFG4__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_OSP_CFG4)));
}

/** PID_PID_OSP_CFG4__SET() sets PID_OSP_CFG4 to given value.
 *
 * When writing to PID_OSP_CFG4, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for PID_OSP_CFG4
 */
__PID_INLINE void PID_PID_OSP_CFG4__SET(pid_idx_t idp, uint32_t value)
{
    HAL_SET32(__PID_PID_OSP_CFG4__ADDRESS(idp), value);
}

/** PID_PID_OSP_CFG4__GET() gets PID_OSP_CFG4's current value.
 *
 * When reading from PID_OSP_CFG4, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OSP_CFG4
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG4__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_OSP_CFG4__ADDRESS(idp));
}

/* ------------------- PID.PID_OSP_CFG4.PID_OSP_CUR_WAIT ------------------- */

/**
<pre>
  PID.PID_OSP_CFG4.PID_OSP_CUR_WAIT:

    Not used

</pre> */

#define PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Pos                 0                                                                      /*!< Right-most bit position of pid_osp_cur_wait in PID.PID_OSP_CFG4 */
#define PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Msk                 (0x0000000FUL << PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Pos)              /*!< Mask for pid_osp_cur_wait in PID.PID_OSP_CFG4 */
#define PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Shift(v)            (((v) << PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Pos) & PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Msk) /*!< Shift value 'v' into pid_osp_cur_wait and mask 'v' to fit it into pid_osp_cur_wait field */

/** PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__SET() sets PID_OSP_CFG4.PID_OSP_CUR_WAIT to given value.
 *
 * When writing to PID_OSP_CFG4.PID_OSP_CUR_WAIT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for PID_OSP_CFG4.PID_OSP_CUR_WAIT
 */
__PID_INLINE void PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__SET(pid_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = PID_PID_OSP_CFG4__GET(idp);
    reg = (reg & ~PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Msk);
    reg = (reg | (PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Shift((uint32_t)bf_value)));
    PID_PID_OSP_CFG4__SET(idp, reg);
}

/** PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__GET() gets PID_OSP_CFG4.PID_OSP_CUR_WAIT's current value.
 *
 * When reading from PID_OSP_CFG4.PID_OSP_CUR_WAIT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_OSP_CFG4.PID_OSP_CUR_WAIT
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_OSP_CFG4__GET(idp);
    reg = (reg & PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Msk);
    reg = (reg >> PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Pos);
    return (uint32_t)reg;
}

/** PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__MODIFY() modifies PID_OSP_CFG4.PID_OSP_CUR_WAIT.
 *
 * This is recommended to use when setting more than one bitfield of PID.PID_OSP_CFG4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PID.PID_OSP_CFG4
 * @param bf_value new value for PID_OSP_CFG4.PID_OSP_CUR_WAIT
 * @return new value of PID.PID_OSP_CFG4
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Msk);
    reg = (reg | (PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__EXTRACT() extracts PID_OSP_CFG4.PID_OSP_CUR_WAIT.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_OSP_CFG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_OSP_CFG4
 * @return current value of PID_OSP_CFG4.PID_OSP_CUR_WAIT
 */
__PID_INLINE uint32_t PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Msk);
    reg = (reg >> PID_PID_OSP_CFG4__PID_OSP_CUR_WAIT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          PID_DUTY member of PID_t                          */
/* -------------------------------------------------------------------------- */

/** __PID_PID_DUTY__ADDRESS returns the address of member PID_DUTY.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_DUTY
 */
__PID_INLINE uint32_t* __PID_PID_DUTY__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_DUTY)));
}

/** PID_PID_DUTY__GET() gets PID_DUTY's current value.
 *
 * When reading from PID_DUTY, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_DUTY
 */
__PID_INLINE uint32_t PID_PID_DUTY__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_DUTY__ADDRESS(idp));
}

/* ------------------------- PID.PID_DUTY.PID_DUTY ------------------------- */

/**
<pre>
  PID.PID_DUTY.PID_DUTY:

    Unfiltered PID duty cycle output

</pre> */

#define PID_PID_DUTY__PID_DUTY__Pos                             0                                                                      /*!< Right-most bit position of pid_duty in PID.PID_DUTY */
#define PID_PID_DUTY__PID_DUTY__Msk                             (0x0000FFFFUL << PID_PID_DUTY__PID_DUTY__Pos)                          /*!< Mask for pid_duty in PID.PID_DUTY */
#define PID_PID_DUTY__PID_DUTY__Shift(v)                        (((v) << PID_PID_DUTY__PID_DUTY__Pos) & PID_PID_DUTY__PID_DUTY__Msk)   /*!< Shift value 'v' into pid_duty and mask 'v' to fit it into pid_duty field */

/** PID_PID_DUTY__PID_DUTY__GET() gets PID_DUTY.PID_DUTY's current value.
 *
 * When reading from PID_DUTY.PID_DUTY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_DUTY.PID_DUTY
 */
__PID_INLINE uint32_t PID_PID_DUTY__PID_DUTY__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_DUTY__GET(idp);
    reg = (reg & PID_PID_DUTY__PID_DUTY__Msk);
    reg = (reg >> PID_PID_DUTY__PID_DUTY__Pos);
    return (uint32_t)reg;
}

/** PID_PID_DUTY__PID_DUTY__EXTRACT() extracts PID_DUTY.PID_DUTY.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_DUTY.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_DUTY
 * @return current value of PID_DUTY.PID_DUTY
 */
__PID_INLINE uint32_t PID_PID_DUTY__PID_DUTY__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_DUTY__PID_DUTY__Msk);
    reg = (reg >> PID_PID_DUTY__PID_DUTY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           PID_FF member of PID_t                           */
/* -------------------------------------------------------------------------- */

/** __PID_PID_FF__ADDRESS returns the address of member PID_FF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of PID_FF
 */
__PID_INLINE uint32_t* __PID_PID_FF__ADDRESS(pid_idx_t idp)
{
    return (uint32_t*)((uint32_t)__PID_BASE_PTR(idp) + (uint32_t)(offsetof(PID_t, PID_FF)));
}

/** PID_PID_FF__GET() gets PID_FF's current value.
 *
 * When reading from PID_FF, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF
 */
__PID_INLINE uint32_t PID_PID_FF__GET(pid_idx_t idp)
{
    return HAL_GET32(__PID_PID_FF__ADDRESS(idp));
}

/* ----------------------- PID.PID_FF.PID_FF_DUTY_LPF ----------------------- */

/**
<pre>
  PID.PID_FF.PID_FF_DUTY_LPF:

    PID feed forward computation after gain/offset adjust and LPF

</pre> */

#define PID_PID_FF__PID_FF_DUTY_LPF__Pos                        0                                                                      /*!< Right-most bit position of pid_ff_duty_lpf in PID.PID_FF */
#define PID_PID_FF__PID_FF_DUTY_LPF__Msk                        (0x0000FFFFUL << PID_PID_FF__PID_FF_DUTY_LPF__Pos)                     /*!< Mask for pid_ff_duty_lpf in PID.PID_FF */
#define PID_PID_FF__PID_FF_DUTY_LPF__Shift(v)                   (((v) << PID_PID_FF__PID_FF_DUTY_LPF__Pos) & PID_PID_FF__PID_FF_DUTY_LPF__Msk) /*!< Shift value 'v' into pid_ff_duty_lpf and mask 'v' to fit it into pid_ff_duty_lpf field */

/** PID_PID_FF__PID_FF_DUTY_LPF__GET() gets PID_FF.PID_FF_DUTY_LPF's current value.
 *
 * When reading from PID_FF.PID_FF_DUTY_LPF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of PID_FF.PID_FF_DUTY_LPF
 */
__PID_INLINE uint32_t PID_PID_FF__PID_FF_DUTY_LPF__GET(pid_idx_t idp)
{
    uint32_t reg = PID_PID_FF__GET(idp);
    reg = (reg & PID_PID_FF__PID_FF_DUTY_LPF__Msk);
    reg = (reg >> PID_PID_FF__PID_FF_DUTY_LPF__Pos);
    return (uint32_t)reg;
}

/** PID_PID_FF__PID_FF_DUTY_LPF__EXTRACT() extracts PID_FF.PID_FF_DUTY_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from PID.PID_FF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PID.PID_FF
 * @return current value of PID_FF.PID_FF_DUTY_LPF
 */
__PID_INLINE uint32_t PID_PID_FF__PID_FF_DUTY_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & PID_PID_FF__PID_FF_DUTY_LPF__Msk);
    reg = (reg >> PID_PID_FF__PID_FF_DUTY_LPF__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group pid block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_PID_H_ */
