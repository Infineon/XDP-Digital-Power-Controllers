/**
 * @file     shasta_hal_dtimer.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_DTIMER_H_
#define _SHASTA_HAL_DTIMER_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup dtimer
 * @{
 */

#if defined ( __CC_ARM )
#define __DTIMER_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __DTIMER_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __DTIMER_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __DTIMER_INLINE  static inline
#endif


/** register file of TIM_SEQ_t, member of DTIMER_t.
 */
typedef struct _TIM_SEQ_s
{
    volatile        uint32_t        TIMERLOAD                   ; /*!< (@0x00000000) Load Register */
    volatile        uint32_t        TIMERVALUE                  ; /*!< (@0x00000004) Value Register */
    volatile        uint32_t        TIMERCONTROL                ; /*!< (@0x00000008) Timer Control Register */
    volatile        uint32_t        TIMERINTCLR                 ; /*!< (@0x0000000C) Interrupt Clear Register */
    volatile        uint32_t        TIMERRIS                    ; /*!< (@0x00000010) Raw Interrupt Status Register */
    volatile        uint32_t        TIMERMIS                    ; /*!< (@0x00000014) Masked Interrupt Status Register */
    volatile        uint32_t        TIMERBGLOAD                 ; /*!< (@0x00000018) Backgorund Load Register */
    volatile        uint8_t         GAP[4]                      ; /*!< (@0x0000001C) gap in address space */
} TIM_SEQ_t;

/** enumeration of DTIMER.TIM_SEQ member index
 */
/*lint -parent(uint32_t, dtimer_tim_seq_idx_t) -strong(AJX)*/
typedef enum _dtimer_tim_seq_idx_e
{
    dtimer_tim_seq_0 = 0u,    //!< Index 0
    dtimer_tim_seq_1 = 1u     //!< Index 1
} dtimer_tim_seq_idx_t;

/** register file of the dtimer block.
 */
typedef struct _DTIMER_s
{
    volatile        TIM_SEQ_t       TIM_SEQ[2]                  ; /*!< (@0x00000000)  */
} DTIMER_t;


/** enumeration of implemented dtimer blocks
 */
typedef enum _dtimer_idx_e
{
    TIMER_0 = 0u,    //!< TIMER_0
    TIMER_1 = 1u,    //!< TIMER_1
    TIMER_2 = 2u     //!< TIMER_2
} dtimer_idx_t;

#define DTIMER_BASE (0x60010000u)                                                          /*!< dtimer base address */
#define DTIMER_STRIDE (0x00010000u)                                                         

/** __DTIMER_BASE_PTR returns the base address of the peripheral.
 *
 * @param idp index of peripheral
 * @return base address of peripheral's instance
 */
__DTIMER_INLINE uint32_t* __DTIMER_BASE_PTR(dtimer_idx_t idp)
{
    return (uint32_t*)(DTIMER_BASE + (uint32_t)((uint32_t)idp * DTIMER_STRIDE));
}


/* -------------------------------------------------------------------------- */
/*                         TIM_SEQ member of DTIMER_t                         */
/* -------------------------------------------------------------------------- */

/** __DTIMER_TIM_SEQ_BASE_PTR returns the base address of member TIM_SEQ.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return base address of instance
 */
__DTIMER_INLINE uint32_t* __DTIMER_TIM_SEQ_BASE_PTR(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return (uint32_t*)((uint32_t)__DTIMER_BASE_PTR(idp) + (uint32_t)(offsetof(DTIMER_t, TIM_SEQ)) + (sizeof(TIM_SEQ_t) * (uint32_t)id0));
}

/* -------------------------------------------------------------------------- */
/*                       TIMERLOAD member of TIM_SEQ_t                       */
/* -------------------------------------------------------------------------- */

/** __DTIMER_TIM_SEQ_TIMERLOAD__ADDRESS returns the address of member TIMERLOAD.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return address of TIMERLOAD
 */
__DTIMER_INLINE uint32_t* __DTIMER_TIM_SEQ_TIMERLOAD__ADDRESS(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return (uint32_t*)((uint32_t)__DTIMER_TIM_SEQ_BASE_PTR(idp, id0) + (uint32_t)(offsetof(TIM_SEQ_t, TIMERLOAD)));
}

/** DTIMER_TIM_SEQ_TIMERLOAD__SET() sets TIMERLOAD to given value.
 *
 * When writing to TIMERLOAD, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param value new value for TIMERLOAD
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERLOAD__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, uint32_t value)
{
    HAL_SET32(__DTIMER_TIM_SEQ_TIMERLOAD__ADDRESS(idp, id0), value);
}

/** DTIMER_TIM_SEQ_TIMERLOAD__GET() gets TIMERLOAD's current value.
 *
 * When reading from TIMERLOAD, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERLOAD
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERLOAD__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return HAL_GET32(__DTIMER_TIM_SEQ_TIMERLOAD__ADDRESS(idp, id0));
}

/* --------------------- DTIMER.TIM_SEQ.TIMERLOAD.LOAD --------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERLOAD.LOAD:

    Load Counter Value

</pre> */

#define DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Pos                     0                                                                      /*!< Right-most bit position of LOAD in DTIMER.TIM_SEQ.TIMERLOAD */
#define DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Msk                     (0xFFFFFFFFUL << DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Pos)                  /*!< Mask for LOAD in DTIMER.TIM_SEQ.TIMERLOAD */
#define DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Shift(v)                (((v) << DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Pos) & DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Msk) /*!< Shift value 'v' into LOAD and mask 'v' to fit it into LOAD field */

/** DTIMER_TIM_SEQ_TIMERLOAD__LOAD__SET() sets TIMERLOAD.LOAD to given value.
 *
 * When writing to TIMERLOAD.LOAD, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param bf_value new value for TIMERLOAD.LOAD
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERLOAD__LOAD__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, uint32_t bf_value)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERLOAD__GET(idp, id0);
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Shift((uint32_t)bf_value)));
    DTIMER_TIM_SEQ_TIMERLOAD__SET(idp, id0, reg);
}

/** DTIMER_TIM_SEQ_TIMERLOAD__LOAD__GET() gets TIMERLOAD.LOAD's current value.
 *
 * When reading from TIMERLOAD.LOAD, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERLOAD.LOAD
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERLOAD__LOAD__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERLOAD__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Pos);
    return (uint32_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERLOAD__LOAD__MODIFY() modifies TIMERLOAD.LOAD.
 *
 * This is recommended to use when setting more than one bitfield of DTIMER.TIM_SEQ.TIMERLOAD.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERLOAD
 * @param bf_value new value for TIMERLOAD.LOAD
 * @return new value of DTIMER.TIM_SEQ.TIMERLOAD
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERLOAD__LOAD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Shift((uint32_t)bf_value)));
    return reg;
}

/** DTIMER_TIM_SEQ_TIMERLOAD__LOAD__EXTRACT() extracts TIMERLOAD.LOAD.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERLOAD.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERLOAD
 * @return current value of TIMERLOAD.LOAD
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERLOAD__LOAD__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERLOAD__LOAD__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TIMERVALUE member of TIM_SEQ_t                       */
/* -------------------------------------------------------------------------- */

/** __DTIMER_TIM_SEQ_TIMERVALUE__ADDRESS returns the address of member TIMERVALUE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return address of TIMERVALUE
 */
__DTIMER_INLINE uint32_t* __DTIMER_TIM_SEQ_TIMERVALUE__ADDRESS(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return (uint32_t*)((uint32_t)__DTIMER_TIM_SEQ_BASE_PTR(idp, id0) + (uint32_t)(offsetof(TIM_SEQ_t, TIMERVALUE)));
}

/** DTIMER_TIM_SEQ_TIMERVALUE__GET() gets TIMERVALUE's current value.
 *
 * When reading from TIMERVALUE, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERVALUE
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERVALUE__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return HAL_GET32(__DTIMER_TIM_SEQ_TIMERVALUE__ADDRESS(idp, id0));
}

/* -------------------- DTIMER.TIM_SEQ.TIMERVALUE.VALUE -------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERVALUE.VALUE:

    Current Counter Value

</pre> */

#define DTIMER_TIM_SEQ_TIMERVALUE__VALUE__Pos                   0                                                                      /*!< Right-most bit position of VALUE in DTIMER.TIM_SEQ.TIMERVALUE */
#define DTIMER_TIM_SEQ_TIMERVALUE__VALUE__Msk                   (0xFFFFFFFFUL << DTIMER_TIM_SEQ_TIMERVALUE__VALUE__Pos)                /*!< Mask for VALUE in DTIMER.TIM_SEQ.TIMERVALUE */
#define DTIMER_TIM_SEQ_TIMERVALUE__VALUE__Shift(v)              (((v) << DTIMER_TIM_SEQ_TIMERVALUE__VALUE__Pos) & DTIMER_TIM_SEQ_TIMERVALUE__VALUE__Msk) /*!< Shift value 'v' into VALUE and mask 'v' to fit it into VALUE field */

/** DTIMER_TIM_SEQ_TIMERVALUE__VALUE__GET() gets TIMERVALUE.VALUE's current value.
 *
 * When reading from TIMERVALUE.VALUE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERVALUE.VALUE
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERVALUE__VALUE__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERVALUE__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERVALUE__VALUE__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERVALUE__VALUE__Pos);
    return (uint32_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERVALUE__VALUE__EXTRACT() extracts TIMERVALUE.VALUE.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERVALUE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERVALUE
 * @return current value of TIMERVALUE.VALUE
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERVALUE__VALUE__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERVALUE__VALUE__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERVALUE__VALUE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TIMERCONTROL member of TIM_SEQ_t                      */
/* -------------------------------------------------------------------------- */

/** __DTIMER_TIM_SEQ_TIMERCONTROL__ADDRESS returns the address of member TIMERCONTROL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return address of TIMERCONTROL
 */
__DTIMER_INLINE uint32_t* __DTIMER_TIM_SEQ_TIMERCONTROL__ADDRESS(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return (uint32_t*)((uint32_t)__DTIMER_TIM_SEQ_BASE_PTR(idp, id0) + (uint32_t)(offsetof(TIM_SEQ_t, TIMERCONTROL)));
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__SET() sets TIMERCONTROL to given value.
 *
 * When writing to TIMERCONTROL, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param value new value for TIMERCONTROL
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERCONTROL__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, uint32_t value)
{
    HAL_SET32(__DTIMER_TIM_SEQ_TIMERCONTROL__ADDRESS(idp, id0), value);
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__GET() gets TIMERCONTROL's current value.
 *
 * When reading from TIMERCONTROL, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERCONTROL
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERCONTROL__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return HAL_GET32(__DTIMER_TIM_SEQ_TIMERCONTROL__ADDRESS(idp, id0));
}

/* -------------------- DTIMER.TIM_SEQ.TIMERCONTROL.TEN -------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERCONTROL.TEN:

    Timer Enable

</pre> */

/*lint -parent(uint32_t, dtimer_tim_seq_timercontrol__ten_t) -strong(AJX)*/
typedef enum dtimer_tim_seq_timercontrol__ten_e                                                                                        /*!< Timer Enable */
{
    dtimer_tim_seq_timercontrol__ten_s0 = 0u,                                                                                          /*!<      Timer is disabled */
    dtimer_tim_seq_timercontrol__ten_s1 = 1u                                                                                           /*!<      Timer is enabled */
} dtimer_tim_seq_timercontrol__ten_t;

#define DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Pos                   7                                                                      /*!< Right-most bit position of TEN in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Msk                   (0x00000001UL << DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Pos)                /*!< Mask for TEN in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Shift(v)              (((v) << DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Pos) & DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Msk) /*!< Shift value 'v' into TEN and mask 'v' to fit it into TEN field */

/** DTIMER_TIM_SEQ_TIMERCONTROL__TEN__SET() sets TIMERCONTROL.TEN to given value.
 *
 * When writing to TIMERCONTROL.TEN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param bf_value new value for TIMERCONTROL.TEN
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERCONTROL__TEN__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, dtimer_tim_seq_timercontrol__ten_t bf_value)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Shift((uint32_t)bf_value)));
    DTIMER_TIM_SEQ_TIMERCONTROL__SET(idp, id0, reg);
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TEN__GET() gets TIMERCONTROL.TEN's current value.
 *
 * When reading from TIMERCONTROL.TEN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERCONTROL.TEN
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__ten_t DTIMER_TIM_SEQ_TIMERCONTROL__TEN__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Pos);
    return (dtimer_tim_seq_timercontrol__ten_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TEN__MODIFY() modifies TIMERCONTROL.TEN.
 *
 * This is recommended to use when setting more than one bitfield of DTIMER.TIM_SEQ.TIMERCONTROL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @param bf_value new value for TIMERCONTROL.TEN
 * @return new value of DTIMER.TIM_SEQ.TIMERCONTROL
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERCONTROL__TEN__MODIFY(uint32_t reg, dtimer_tim_seq_timercontrol__ten_t bf_value)
{
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TEN__EXTRACT() extracts TIMERCONTROL.TEN.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERCONTROL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @return current value of TIMERCONTROL.TEN
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__ten_t DTIMER_TIM_SEQ_TIMERCONTROL__TEN__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__TEN__Pos);
    return (dtimer_tim_seq_timercontrol__ten_t)reg;
}

/* ------------------- DTIMER.TIM_SEQ.TIMERCONTROL.TMODE ------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERCONTROL.TMODE:

    Timer Mode

</pre> */

/*lint -parent(uint32_t, dtimer_tim_seq_timercontrol__tmode_t) -strong(AJX)*/
typedef enum dtimer_tim_seq_timercontrol__tmode_e                                                                                      /*!< Timer Mode */
{
    dtimer_tim_seq_timercontrol__tmode_s0 = 0u,                                                                                        /*!<      Timer is in free-running mode */
    dtimer_tim_seq_timercontrol__tmode_s1 = 1u                                                                                         /*!<      Timer is in periodic mode */
} dtimer_tim_seq_timercontrol__tmode_t;

#define DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Pos                 6                                                                      /*!< Right-most bit position of TMODE in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Msk                 (0x00000001UL << DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Pos)              /*!< Mask for TMODE in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Shift(v)            (((v) << DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Pos) & DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Msk) /*!< Shift value 'v' into TMODE and mask 'v' to fit it into TMODE field */

/** DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__SET() sets TIMERCONTROL.TMODE to given value.
 *
 * When writing to TIMERCONTROL.TMODE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param bf_value new value for TIMERCONTROL.TMODE
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, dtimer_tim_seq_timercontrol__tmode_t bf_value)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Shift((uint32_t)bf_value)));
    DTIMER_TIM_SEQ_TIMERCONTROL__SET(idp, id0, reg);
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__GET() gets TIMERCONTROL.TMODE's current value.
 *
 * When reading from TIMERCONTROL.TMODE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERCONTROL.TMODE
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__tmode_t DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Pos);
    return (dtimer_tim_seq_timercontrol__tmode_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__MODIFY() modifies TIMERCONTROL.TMODE.
 *
 * This is recommended to use when setting more than one bitfield of DTIMER.TIM_SEQ.TIMERCONTROL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @param bf_value new value for TIMERCONTROL.TMODE
 * @return new value of DTIMER.TIM_SEQ.TIMERCONTROL
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__MODIFY(uint32_t reg, dtimer_tim_seq_timercontrol__tmode_t bf_value)
{
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__EXTRACT() extracts TIMERCONTROL.TMODE.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERCONTROL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @return current value of TIMERCONTROL.TMODE
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__tmode_t DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__TMODE__Pos);
    return (dtimer_tim_seq_timercontrol__tmode_t)reg;
}

/* ------------------- DTIMER.TIM_SEQ.TIMERCONTROL.INTEN ------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERCONTROL.INTEN:

    Interrupt Enable

</pre> */

/*lint -parent(uint32_t, dtimer_tim_seq_timercontrol__inten_t) -strong(AJX)*/
typedef enum dtimer_tim_seq_timercontrol__inten_e                                                                                      /*!< Interrupt Enable */
{
    dtimer_tim_seq_timercontrol__inten_s0 = 0u,                                                                                        /*!<      Timer interrupt disabled */
    dtimer_tim_seq_timercontrol__inten_s1 = 1u                                                                                         /*!<      Timer interrupt enabled */
} dtimer_tim_seq_timercontrol__inten_t;

#define DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Pos                 5                                                                      /*!< Right-most bit position of INTEN in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Msk                 (0x00000001UL << DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Pos)              /*!< Mask for INTEN in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Shift(v)            (((v) << DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Pos) & DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Msk) /*!< Shift value 'v' into INTEN and mask 'v' to fit it into INTEN field */

/** DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__SET() sets TIMERCONTROL.INTEN to given value.
 *
 * When writing to TIMERCONTROL.INTEN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param bf_value new value for TIMERCONTROL.INTEN
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, dtimer_tim_seq_timercontrol__inten_t bf_value)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Shift((uint32_t)bf_value)));
    DTIMER_TIM_SEQ_TIMERCONTROL__SET(idp, id0, reg);
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__GET() gets TIMERCONTROL.INTEN's current value.
 *
 * When reading from TIMERCONTROL.INTEN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERCONTROL.INTEN
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__inten_t DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Pos);
    return (dtimer_tim_seq_timercontrol__inten_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__MODIFY() modifies TIMERCONTROL.INTEN.
 *
 * This is recommended to use when setting more than one bitfield of DTIMER.TIM_SEQ.TIMERCONTROL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @param bf_value new value for TIMERCONTROL.INTEN
 * @return new value of DTIMER.TIM_SEQ.TIMERCONTROL
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__MODIFY(uint32_t reg, dtimer_tim_seq_timercontrol__inten_t bf_value)
{
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__EXTRACT() extracts TIMERCONTROL.INTEN.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERCONTROL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @return current value of TIMERCONTROL.INTEN
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__inten_t DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__INTEN__Pos);
    return (dtimer_tim_seq_timercontrol__inten_t)reg;
}

/* -------------------- DTIMER.TIM_SEQ.TIMERCONTROL.TPRE -------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERCONTROL.TPRE:

    Timer Prescaler

</pre> */

/*lint -parent(uint32_t, dtimer_tim_seq_timercontrol__tpre_t) -strong(AJX)*/
typedef enum dtimer_tim_seq_timercontrol__tpre_e                                                                                       /*!< Timer Prescaler */
{
    dtimer_tim_seq_timercontrol__tpre_s0 = 0u,                                                                                         /*!<      Timer clock divided by1 (default) */
    dtimer_tim_seq_timercontrol__tpre_s1 = 1u,                                                                                         /*!<      Timer clock divided by 16 */
    dtimer_tim_seq_timercontrol__tpre_s2 = 2u,                                                                                         /*!<      Timer clock divided by 256 */
    dtimer_tim_seq_timercontrol__tpre_s3 = 3u                                                                                          /*!<      undefined, do not used */
} dtimer_tim_seq_timercontrol__tpre_t;

#define DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Pos                  2                                                                      /*!< Right-most bit position of TPRE in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Msk                  (0x00000003UL << DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Pos)               /*!< Mask for TPRE in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Shift(v)             (((v) << DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Pos) & DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Msk) /*!< Shift value 'v' into TPRE and mask 'v' to fit it into TPRE field */

/** DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__SET() sets TIMERCONTROL.TPRE to given value.
 *
 * When writing to TIMERCONTROL.TPRE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param bf_value new value for TIMERCONTROL.TPRE
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, dtimer_tim_seq_timercontrol__tpre_t bf_value)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Shift((uint32_t)bf_value)));
    DTIMER_TIM_SEQ_TIMERCONTROL__SET(idp, id0, reg);
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__GET() gets TIMERCONTROL.TPRE's current value.
 *
 * When reading from TIMERCONTROL.TPRE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERCONTROL.TPRE
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__tpre_t DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Pos);
    return (dtimer_tim_seq_timercontrol__tpre_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__MODIFY() modifies TIMERCONTROL.TPRE.
 *
 * This is recommended to use when setting more than one bitfield of DTIMER.TIM_SEQ.TIMERCONTROL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @param bf_value new value for TIMERCONTROL.TPRE
 * @return new value of DTIMER.TIM_SEQ.TIMERCONTROL
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__MODIFY(uint32_t reg, dtimer_tim_seq_timercontrol__tpre_t bf_value)
{
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Shift((uint32_t)bf_value)));
    return reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__EXTRACT() extracts TIMERCONTROL.TPRE.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERCONTROL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @return current value of TIMERCONTROL.TPRE
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__tpre_t DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__TPRE__Pos);
    return (dtimer_tim_seq_timercontrol__tpre_t)reg;
}

/* ------------------- DTIMER.TIM_SEQ.TIMERCONTROL.TSIZE ------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERCONTROL.TSIZE:

    Timer Size

</pre> */

/*lint -parent(uint32_t, dtimer_tim_seq_timercontrol__tsize_t) -strong(AJX)*/
typedef enum dtimer_tim_seq_timercontrol__tsize_e                                                                                      /*!< Timer Size */
{
    dtimer_tim_seq_timercontrol__tsize_s0 = 0u,                                                                                        /*!<      16-bit counder, default */
    dtimer_tim_seq_timercontrol__tsize_s1 = 1u                                                                                         /*!<      32-bit counter */
} dtimer_tim_seq_timercontrol__tsize_t;

#define DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Pos                 1                                                                      /*!< Right-most bit position of TSIZE in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Msk                 (0x00000001UL << DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Pos)              /*!< Mask for TSIZE in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Shift(v)            (((v) << DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Pos) & DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Msk) /*!< Shift value 'v' into TSIZE and mask 'v' to fit it into TSIZE field */

/** DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__SET() sets TIMERCONTROL.TSIZE to given value.
 *
 * When writing to TIMERCONTROL.TSIZE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param bf_value new value for TIMERCONTROL.TSIZE
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, dtimer_tim_seq_timercontrol__tsize_t bf_value)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Shift((uint32_t)bf_value)));
    DTIMER_TIM_SEQ_TIMERCONTROL__SET(idp, id0, reg);
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__GET() gets TIMERCONTROL.TSIZE's current value.
 *
 * When reading from TIMERCONTROL.TSIZE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERCONTROL.TSIZE
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__tsize_t DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Pos);
    return (dtimer_tim_seq_timercontrol__tsize_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__MODIFY() modifies TIMERCONTROL.TSIZE.
 *
 * This is recommended to use when setting more than one bitfield of DTIMER.TIM_SEQ.TIMERCONTROL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @param bf_value new value for TIMERCONTROL.TSIZE
 * @return new value of DTIMER.TIM_SEQ.TIMERCONTROL
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__MODIFY(uint32_t reg, dtimer_tim_seq_timercontrol__tsize_t bf_value)
{
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Shift((uint32_t)bf_value)));
    return reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__EXTRACT() extracts TIMERCONTROL.TSIZE.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERCONTROL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @return current value of TIMERCONTROL.TSIZE
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__tsize_t DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__TSIZE__Pos);
    return (dtimer_tim_seq_timercontrol__tsize_t)reg;
}

/* ------------------ DTIMER.TIM_SEQ.TIMERCONTROL.ONESHOT ------------------ */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERCONTROL.ONESHOT:

    One Shot Count

</pre> */

/*lint -parent(uint32_t, dtimer_tim_seq_timercontrol__oneshot_t) -strong(AJX)*/
typedef enum dtimer_tim_seq_timercontrol__oneshot_e                                                                                    /*!< One Shot Count */
{
    dtimer_tim_seq_timercontrol__oneshot_s0 = 0u,                                                                                      /*!<      wrapping mode, default */
    dtimer_tim_seq_timercontrol__oneshot_s1 = 1u                                                                                       /*!<      one-shot mode */
} dtimer_tim_seq_timercontrol__oneshot_t;

#define DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Pos               0                                                                      /*!< Right-most bit position of ONESHOT in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Msk               (0x00000001UL << DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Pos)            /*!< Mask for ONESHOT in DTIMER.TIM_SEQ.TIMERCONTROL */
#define DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Shift(v)          (((v) << DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Pos) & DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Msk) /*!< Shift value 'v' into ONESHOT and mask 'v' to fit it into ONESHOT field */

/** DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__SET() sets TIMERCONTROL.ONESHOT to given value.
 *
 * When writing to TIMERCONTROL.ONESHOT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param bf_value new value for TIMERCONTROL.ONESHOT
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, dtimer_tim_seq_timercontrol__oneshot_t bf_value)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Shift((uint32_t)bf_value)));
    DTIMER_TIM_SEQ_TIMERCONTROL__SET(idp, id0, reg);
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__GET() gets TIMERCONTROL.ONESHOT's current value.
 *
 * When reading from TIMERCONTROL.ONESHOT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERCONTROL.ONESHOT
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__oneshot_t DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERCONTROL__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Pos);
    return (dtimer_tim_seq_timercontrol__oneshot_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__MODIFY() modifies TIMERCONTROL.ONESHOT.
 *
 * This is recommended to use when setting more than one bitfield of DTIMER.TIM_SEQ.TIMERCONTROL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @param bf_value new value for TIMERCONTROL.ONESHOT
 * @return new value of DTIMER.TIM_SEQ.TIMERCONTROL
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__MODIFY(uint32_t reg, dtimer_tim_seq_timercontrol__oneshot_t bf_value)
{
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Shift((uint32_t)bf_value)));
    return reg;
}

/** DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__EXTRACT() extracts TIMERCONTROL.ONESHOT.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERCONTROL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERCONTROL
 * @return current value of TIMERCONTROL.ONESHOT
 */
__DTIMER_INLINE dtimer_tim_seq_timercontrol__oneshot_t DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERCONTROL__ONESHOT__Pos);
    return (dtimer_tim_seq_timercontrol__oneshot_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TIMERINTCLR member of TIM_SEQ_t                      */
/* -------------------------------------------------------------------------- */

/** __DTIMER_TIM_SEQ_TIMERINTCLR__ADDRESS returns the address of member TIMERINTCLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return address of TIMERINTCLR
 */
__DTIMER_INLINE uint32_t* __DTIMER_TIM_SEQ_TIMERINTCLR__ADDRESS(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return (uint32_t*)((uint32_t)__DTIMER_TIM_SEQ_BASE_PTR(idp, id0) + (uint32_t)(offsetof(TIM_SEQ_t, TIMERINTCLR)));
}

/** DTIMER_TIM_SEQ_TIMERINTCLR__SET() sets TIMERINTCLR to given value.
 *
 * When writing to TIMERINTCLR, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param value new value for TIMERINTCLR
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERINTCLR__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, uint32_t value)
{
    HAL_SET32(__DTIMER_TIM_SEQ_TIMERINTCLR__ADDRESS(idp, id0), value);
}


/* ------------------- DTIMER.TIM_SEQ.TIMERINTCLR.CLRINT ------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERINTCLR.CLRINT:

    Interrupt Clear

</pre> */

#define DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Pos                 0                                                                      /*!< Right-most bit position of CLRINT in DTIMER.TIM_SEQ.TIMERINTCLR */
#define DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Msk                 (0xFFFFFFFFUL << DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Pos)              /*!< Mask for CLRINT in DTIMER.TIM_SEQ.TIMERINTCLR */
#define DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Shift(v)            (((v) << DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Pos) & DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Msk) /*!< Shift value 'v' into CLRINT and mask 'v' to fit it into CLRINT field */

/** DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__SET() sets TIMERINTCLR.CLRINT to given value.
 *
 * When writing to TIMERINTCLR.CLRINT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param bf_value new value for TIMERINTCLR.CLRINT
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, uint32_t bf_value)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Shift((uint32_t)bf_value);
    DTIMER_TIM_SEQ_TIMERINTCLR__SET(idp, id0, reg);
}


/** DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__MODIFY() modifies TIMERINTCLR.CLRINT.
 *
 * This is recommended to use when setting more than one bitfield of DTIMER.TIM_SEQ.TIMERINTCLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERINTCLR
 * @param bf_value new value for TIMERINTCLR.CLRINT
 * @return new value of DTIMER.TIM_SEQ.TIMERINTCLR
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Shift((uint32_t)bf_value)));
    return reg;
}

/** DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__EXTRACT() extracts TIMERINTCLR.CLRINT.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERINTCLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERINTCLR
 * @return current value of TIMERINTCLR.CLRINT
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERINTCLR__CLRINT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TIMERRIS member of TIM_SEQ_t                        */
/* -------------------------------------------------------------------------- */

/** __DTIMER_TIM_SEQ_TIMERRIS__ADDRESS returns the address of member TIMERRIS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return address of TIMERRIS
 */
__DTIMER_INLINE uint32_t* __DTIMER_TIM_SEQ_TIMERRIS__ADDRESS(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return (uint32_t*)((uint32_t)__DTIMER_TIM_SEQ_BASE_PTR(idp, id0) + (uint32_t)(offsetof(TIM_SEQ_t, TIMERRIS)));
}

/** DTIMER_TIM_SEQ_TIMERRIS__GET() gets TIMERRIS's current value.
 *
 * When reading from TIMERRIS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERRIS
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERRIS__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return HAL_GET32(__DTIMER_TIM_SEQ_TIMERRIS__ADDRESS(idp, id0));
}

/* --------------------- DTIMER.TIM_SEQ.TIMERRIS.RAWINT --------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERRIS.RAWINT:

    Raw Interrupt Status

</pre> */

/*lint -parent(uint32_t, dtimer_tim_seq_timerris__rawint_t) -strong(AJX)*/
typedef enum dtimer_tim_seq_timerris__rawint_e                                                                                         /*!< Raw Interrupt Status */
{
    dtimer_tim_seq_timerris__rawint_s0 = 0u,                                                                                           /*!<      Raw Interrupt status from counter */
    dtimer_tim_seq_timerris__rawint_s1 = 1u                                                                                            /*!<      Raw Interrupt status from counter */
} dtimer_tim_seq_timerris__rawint_t;

#define DTIMER_TIM_SEQ_TIMERRIS__RAWINT__Pos                    0                                                                      /*!< Right-most bit position of RAWINT in DTIMER.TIM_SEQ.TIMERRIS */
#define DTIMER_TIM_SEQ_TIMERRIS__RAWINT__Msk                    (0x00000001UL << DTIMER_TIM_SEQ_TIMERRIS__RAWINT__Pos)                 /*!< Mask for RAWINT in DTIMER.TIM_SEQ.TIMERRIS */
#define DTIMER_TIM_SEQ_TIMERRIS__RAWINT__Shift(v)               (((v) << DTIMER_TIM_SEQ_TIMERRIS__RAWINT__Pos) & DTIMER_TIM_SEQ_TIMERRIS__RAWINT__Msk) /*!< Shift value 'v' into RAWINT and mask 'v' to fit it into RAWINT field */

/** DTIMER_TIM_SEQ_TIMERRIS__RAWINT__GET() gets TIMERRIS.RAWINT's current value.
 *
 * When reading from TIMERRIS.RAWINT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERRIS.RAWINT
 */
__DTIMER_INLINE dtimer_tim_seq_timerris__rawint_t DTIMER_TIM_SEQ_TIMERRIS__RAWINT__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERRIS__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERRIS__RAWINT__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERRIS__RAWINT__Pos);
    return (dtimer_tim_seq_timerris__rawint_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERRIS__RAWINT__EXTRACT() extracts TIMERRIS.RAWINT.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERRIS
 * @return current value of TIMERRIS.RAWINT
 */
__DTIMER_INLINE dtimer_tim_seq_timerris__rawint_t DTIMER_TIM_SEQ_TIMERRIS__RAWINT__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERRIS__RAWINT__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERRIS__RAWINT__Pos);
    return (dtimer_tim_seq_timerris__rawint_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TIMERMIS member of TIM_SEQ_t                        */
/* -------------------------------------------------------------------------- */

/** __DTIMER_TIM_SEQ_TIMERMIS__ADDRESS returns the address of member TIMERMIS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return address of TIMERMIS
 */
__DTIMER_INLINE uint32_t* __DTIMER_TIM_SEQ_TIMERMIS__ADDRESS(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return (uint32_t*)((uint32_t)__DTIMER_TIM_SEQ_BASE_PTR(idp, id0) + (uint32_t)(offsetof(TIM_SEQ_t, TIMERMIS)));
}

/** DTIMER_TIM_SEQ_TIMERMIS__GET() gets TIMERMIS's current value.
 *
 * When reading from TIMERMIS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERMIS
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERMIS__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return HAL_GET32(__DTIMER_TIM_SEQ_TIMERMIS__ADDRESS(idp, id0));
}

/* --------------------- DTIMER.TIM_SEQ.TIMERMIS.STINT --------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERMIS.STINT:

    Timer Interrupt Status

</pre> */

/*lint -parent(uint32_t, dtimer_tim_seq_timermis__stint_t) -strong(AJX)*/
typedef enum dtimer_tim_seq_timermis__stint_e                                                                                          /*!< Timer Interrupt Status */
{
    dtimer_tim_seq_timermis__stint_s0 = 0u,                                                                                            /*!<      Timer interrupt line status is not asserted. */
    dtimer_tim_seq_timermis__stint_s1 = 1u                                                                                             /*!<      Enable interrupt status from the counter */
} dtimer_tim_seq_timermis__stint_t;

#define DTIMER_TIM_SEQ_TIMERMIS__STINT__Pos                     0                                                                      /*!< Right-most bit position of STINT in DTIMER.TIM_SEQ.TIMERMIS */
#define DTIMER_TIM_SEQ_TIMERMIS__STINT__Msk                     (0x00000001UL << DTIMER_TIM_SEQ_TIMERMIS__STINT__Pos)                  /*!< Mask for STINT in DTIMER.TIM_SEQ.TIMERMIS */
#define DTIMER_TIM_SEQ_TIMERMIS__STINT__Shift(v)                (((v) << DTIMER_TIM_SEQ_TIMERMIS__STINT__Pos) & DTIMER_TIM_SEQ_TIMERMIS__STINT__Msk) /*!< Shift value 'v' into STINT and mask 'v' to fit it into STINT field */

/** DTIMER_TIM_SEQ_TIMERMIS__STINT__GET() gets TIMERMIS.STINT's current value.
 *
 * When reading from TIMERMIS.STINT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERMIS.STINT
 */
__DTIMER_INLINE dtimer_tim_seq_timermis__stint_t DTIMER_TIM_SEQ_TIMERMIS__STINT__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERMIS__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERMIS__STINT__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERMIS__STINT__Pos);
    return (dtimer_tim_seq_timermis__stint_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERMIS__STINT__EXTRACT() extracts TIMERMIS.STINT.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERMIS
 * @return current value of TIMERMIS.STINT
 */
__DTIMER_INLINE dtimer_tim_seq_timermis__stint_t DTIMER_TIM_SEQ_TIMERMIS__STINT__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERMIS__STINT__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERMIS__STINT__Pos);
    return (dtimer_tim_seq_timermis__stint_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TIMERBGLOAD member of TIM_SEQ_t                      */
/* -------------------------------------------------------------------------- */

/** __DTIMER_TIM_SEQ_TIMERBGLOAD__ADDRESS returns the address of member TIMERBGLOAD.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return address of TIMERBGLOAD
 */
__DTIMER_INLINE uint32_t* __DTIMER_TIM_SEQ_TIMERBGLOAD__ADDRESS(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return (uint32_t*)((uint32_t)__DTIMER_TIM_SEQ_BASE_PTR(idp, id0) + (uint32_t)(offsetof(TIM_SEQ_t, TIMERBGLOAD)));
}

/** DTIMER_TIM_SEQ_TIMERBGLOAD__SET() sets TIMERBGLOAD to given value.
 *
 * When writing to TIMERBGLOAD, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param value new value for TIMERBGLOAD
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERBGLOAD__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, uint32_t value)
{
    HAL_SET32(__DTIMER_TIM_SEQ_TIMERBGLOAD__ADDRESS(idp, id0), value);
}

/** DTIMER_TIM_SEQ_TIMERBGLOAD__GET() gets TIMERBGLOAD's current value.
 *
 * When reading from TIMERBGLOAD, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERBGLOAD
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERBGLOAD__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    return HAL_GET32(__DTIMER_TIM_SEQ_TIMERBGLOAD__ADDRESS(idp, id0));
}

/* ------------------- DTIMER.TIM_SEQ.TIMERBGLOAD.BVALUE ------------------- */

/**
<pre>
  DTIMER.TIM_SEQ.TIMERBGLOAD.BVALUE:

    Backgound Counter Value

</pre> */

#define DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Pos                 0                                                                      /*!< Right-most bit position of BVALUE in DTIMER.TIM_SEQ.TIMERBGLOAD */
#define DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Msk                 (0xFFFFFFFFUL << DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Pos)              /*!< Mask for BVALUE in DTIMER.TIM_SEQ.TIMERBGLOAD */
#define DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Shift(v)            (((v) << DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Pos) & DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Msk) /*!< Shift value 'v' into BVALUE and mask 'v' to fit it into BVALUE field */

/** DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__SET() sets TIMERBGLOAD.BVALUE to given value.
 *
 * When writing to TIMERBGLOAD.BVALUE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @param bf_value new value for TIMERBGLOAD.BVALUE
 */
__DTIMER_INLINE void DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__SET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0, uint32_t bf_value)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERBGLOAD__GET(idp, id0);
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Shift((uint32_t)bf_value)));
    DTIMER_TIM_SEQ_TIMERBGLOAD__SET(idp, id0, reg);
}

/** DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__GET() gets TIMERBGLOAD.BVALUE's current value.
 *
 * When reading from TIMERBGLOAD.BVALUE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param id0 index in DTIMER.TIM_SEQ struct
 * @return current value of TIMERBGLOAD.BVALUE
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__GET(dtimer_idx_t idp, dtimer_tim_seq_idx_t id0)
{
    uint32_t reg = DTIMER_TIM_SEQ_TIMERBGLOAD__GET(idp, id0);
    reg = (reg & DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Pos);
    return (uint32_t)reg;
}

/** DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__MODIFY() modifies TIMERBGLOAD.BVALUE.
 *
 * This is recommended to use when setting more than one bitfield of DTIMER.TIM_SEQ.TIMERBGLOAD.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERBGLOAD
 * @param bf_value new value for TIMERBGLOAD.BVALUE
 * @return new value of DTIMER.TIM_SEQ.TIMERBGLOAD
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Msk);
    reg = (reg | (DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Shift((uint32_t)bf_value)));
    return reg;
}

/** DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__EXTRACT() extracts TIMERBGLOAD.BVALUE.
 *
 * This is recommended to use when extracting more than one bitfield from DTIMER.TIM_SEQ.TIMERBGLOAD.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of DTIMER.TIM_SEQ.TIMERBGLOAD
 * @return current value of TIMERBGLOAD.BVALUE
 */
__DTIMER_INLINE uint32_t DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__EXTRACT(uint32_t reg)
{
    reg = (reg & DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Msk);
    reg = (reg >> DTIMER_TIM_SEQ_TIMERBGLOAD__BVALUE__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group dtimer block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_DTIMER_H_ */
