/**
 * @file     shasta_hal_i2c.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     2015-11-16
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2016 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_I2C_H_
#define _SHASTA_HAL_I2C_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup i2c
 * @{
 */

#if defined ( __CC_ARM )
#define __I2C_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __I2C_INLINE  static inline __attribute__((always_inline))
#else
#warning Unsupported Compiler
#define __I2C_INLINE  static inline
#endif

/** register file of the i2c block.
 */
typedef struct _I2C_s
{
    volatile        uint32_t        ADDR                        ; /*!< (@0x00000000)  */
    volatile        uint32_t        DATA                        ; /*!< (@0x00000004)  */
    volatile        uint32_t        CNTR                        ; /*!< (@0x00000008)  */
    volatile        uint32_t        STAT_CCR                    ; /*!< (@0x0000000C)  */
    volatile        uint32_t        XADDR                       ; /*!< (@0x00000010)  */
    volatile        uint8_t         REGMEMGAP0[8]               ; /*!< (@0x00000014) gap in address space */
    volatile        uint32_t        SRST                        ; /*!< (@0x0000001C)  */
} I2C_t;


#define I2C_BASE (0x700B0000u)                                                          /*!< i2c base address */

/** __I2C_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__I2C_INLINE uint32_t* __I2C_BASE_PTR(void)
{
    return (uint32_t*)(I2C_BASE);
}


/* -------------------------------------------------------------------------- */
/*                            ADDR member of I2C_t                            */
/* -------------------------------------------------------------------------- */

/** __I2C_ADDR__ADDRESS returns the address of member ADDR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ADDR
 */
__I2C_INLINE uint32_t* __I2C_ADDR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__I2C_BASE_PTR() + (uint32_t)(offsetof(I2C_t, ADDR)));
}

/** I2C_ADDR__SET() sets ADDR to given value.
 *
 * When writing to ADDR, this is mandatory to use.
 *
 * @param value new value for ADDR
 */
__I2C_INLINE void I2C_ADDR__SET(uint32_t value)
{
    HAL_SET32(__I2C_ADDR__ADDRESS(), value);
}

/** I2C_ADDR__GET() gets ADDR's current value.
 *
 * When reading from ADDR, this is mandatory to use.
 *
 * @return current value of ADDR
 */
__I2C_INLINE uint32_t I2C_ADDR__GET(void)
{
    return HAL_GET32(__I2C_ADDR__ADDRESS());
}

/* ------------------------------ I2C.ADDR.SLA ------------------------------ */


#define I2C_ADDR__SLA__Pos                                      3                                                                      /*!< Right-most bit position of SLA in I2C.ADDR */
#define I2C_ADDR__SLA__Msk                                      (0x0000001FUL << I2C_ADDR__SLA__Pos)                                   /*!< Mask for SLA in I2C.ADDR */
#define I2C_ADDR__SLA__Shift(v)                                 (((v) << I2C_ADDR__SLA__Pos) & I2C_ADDR__SLA__Msk)                     /*!< Shift value 'v' into SLA and mask 'v' to fit it into SLA field */

/** I2C_ADDR__SLA__SET() sets ADDR.SLA to given value.
 *
 * When writing to ADDR.SLA, this is recommended to use.
 *
 * @param bf_value new value for ADDR.SLA
 */
__I2C_INLINE void I2C_ADDR__SLA__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_ADDR__GET();
    reg = (reg & ~I2C_ADDR__SLA__Msk);
    reg = (reg | (I2C_ADDR__SLA__Shift((uint32_t)bf_value)));
    I2C_ADDR__SET(reg);
}

/** I2C_ADDR__SLA__GET() gets ADDR.SLA's current value.
 *
 * When reading from ADDR.SLA, this is recommended to use.
 *
 * @return current value of ADDR.SLA
 */
__I2C_INLINE uint32_t I2C_ADDR__SLA__GET(void)
{
    uint32_t reg = I2C_ADDR__GET();
    reg = (reg & I2C_ADDR__SLA__Msk);
    reg = (reg >> I2C_ADDR__SLA__Pos);
    return (uint32_t)reg;
}

/** I2C_ADDR__SLA__MODIFY() modifies ADDR.SLA.
 *
 * This is recommended to use when setting more than one bitfield of I2C.ADDR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.ADDR
 * @param bf_value new value for ADDR.SLA
 * @return new value of I2C.ADDR
 */
__I2C_INLINE uint32_t I2C_ADDR__SLA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_ADDR__SLA__Msk);
    reg = (reg | (I2C_ADDR__SLA__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_ADDR__SLA__EXTRACT() extracts ADDR.SLA.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.ADDR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.ADDR
 * @return current value of ADDR.SLA
 */
__I2C_INLINE uint32_t I2C_ADDR__SLA__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_ADDR__SLA__Msk);
    reg = (reg >> I2C_ADDR__SLA__Pos);
    return (uint32_t)reg;
}

/* ----------------------------- I2C.ADDR.SLAX ----------------------------- */


#define I2C_ADDR__SLAX__Pos                                     1                                                                      /*!< Right-most bit position of SLAX in I2C.ADDR */
#define I2C_ADDR__SLAX__Msk                                     (0x00000003UL << I2C_ADDR__SLAX__Pos)                                  /*!< Mask for SLAX in I2C.ADDR */
#define I2C_ADDR__SLAX__Shift(v)                                (((v) << I2C_ADDR__SLAX__Pos) & I2C_ADDR__SLAX__Msk)                   /*!< Shift value 'v' into SLAX and mask 'v' to fit it into SLAX field */

/** I2C_ADDR__SLAX__SET() sets ADDR.SLAX to given value.
 *
 * When writing to ADDR.SLAX, this is recommended to use.
 *
 * @param bf_value new value for ADDR.SLAX
 */
__I2C_INLINE void I2C_ADDR__SLAX__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_ADDR__GET();
    reg = (reg & ~I2C_ADDR__SLAX__Msk);
    reg = (reg | (I2C_ADDR__SLAX__Shift((uint32_t)bf_value)));
    I2C_ADDR__SET(reg);
}

/** I2C_ADDR__SLAX__GET() gets ADDR.SLAX's current value.
 *
 * When reading from ADDR.SLAX, this is recommended to use.
 *
 * @return current value of ADDR.SLAX
 */
__I2C_INLINE uint32_t I2C_ADDR__SLAX__GET(void)
{
    uint32_t reg = I2C_ADDR__GET();
    reg = (reg & I2C_ADDR__SLAX__Msk);
    reg = (reg >> I2C_ADDR__SLAX__Pos);
    return (uint32_t)reg;
}

/** I2C_ADDR__SLAX__MODIFY() modifies ADDR.SLAX.
 *
 * This is recommended to use when setting more than one bitfield of I2C.ADDR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.ADDR
 * @param bf_value new value for ADDR.SLAX
 * @return new value of I2C.ADDR
 */
__I2C_INLINE uint32_t I2C_ADDR__SLAX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_ADDR__SLAX__Msk);
    reg = (reg | (I2C_ADDR__SLAX__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_ADDR__SLAX__EXTRACT() extracts ADDR.SLAX.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.ADDR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.ADDR
 * @return current value of ADDR.SLAX
 */
__I2C_INLINE uint32_t I2C_ADDR__SLAX__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_ADDR__SLAX__Msk);
    reg = (reg >> I2C_ADDR__SLAX__Pos);
    return (uint32_t)reg;
}

/* ------------------------------ I2C.ADDR.GCE ------------------------------ */


#define I2C_ADDR__GCE__Pos                                      0                                                                      /*!< Right-most bit position of GCE in I2C.ADDR */
#define I2C_ADDR__GCE__Msk                                      (0x00000001UL << I2C_ADDR__GCE__Pos)                                   /*!< Mask for GCE in I2C.ADDR */
#define I2C_ADDR__GCE__Shift(v)                                 (((v) << I2C_ADDR__GCE__Pos) & I2C_ADDR__GCE__Msk)                     /*!< Shift value 'v' into GCE and mask 'v' to fit it into GCE field */

/** I2C_ADDR__GCE__SET() sets ADDR.GCE to given value.
 *
 * When writing to ADDR.GCE, this is recommended to use.
 *
 * @param bf_value new value for ADDR.GCE
 */
__I2C_INLINE void I2C_ADDR__GCE__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_ADDR__GET();
    reg = (reg & ~I2C_ADDR__GCE__Msk);
    reg = (reg | (I2C_ADDR__GCE__Shift((uint32_t)bf_value)));
    I2C_ADDR__SET(reg);
}

/** I2C_ADDR__GCE__GET() gets ADDR.GCE's current value.
 *
 * When reading from ADDR.GCE, this is recommended to use.
 *
 * @return current value of ADDR.GCE
 */
__I2C_INLINE uint32_t I2C_ADDR__GCE__GET(void)
{
    uint32_t reg = I2C_ADDR__GET();
    reg = (reg & I2C_ADDR__GCE__Msk);
    reg = (reg >> I2C_ADDR__GCE__Pos);
    return (uint32_t)reg;
}

/** I2C_ADDR__GCE__MODIFY() modifies ADDR.GCE.
 *
 * This is recommended to use when setting more than one bitfield of I2C.ADDR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.ADDR
 * @param bf_value new value for ADDR.GCE
 * @return new value of I2C.ADDR
 */
__I2C_INLINE uint32_t I2C_ADDR__GCE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_ADDR__GCE__Msk);
    reg = (reg | (I2C_ADDR__GCE__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_ADDR__GCE__EXTRACT() extracts ADDR.GCE.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.ADDR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.ADDR
 * @return current value of ADDR.GCE
 */
__I2C_INLINE uint32_t I2C_ADDR__GCE__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_ADDR__GCE__Msk);
    reg = (reg >> I2C_ADDR__GCE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                            DATA member of I2C_t                            */
/* -------------------------------------------------------------------------- */

/** __I2C_DATA__ADDRESS returns the address of member DATA.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DATA
 */
__I2C_INLINE uint32_t* __I2C_DATA__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__I2C_BASE_PTR() + (uint32_t)(offsetof(I2C_t, DATA)));
}

/** I2C_DATA__SET() sets DATA to given value.
 *
 * When writing to DATA, this is mandatory to use.
 *
 * @param value new value for DATA
 */
__I2C_INLINE void I2C_DATA__SET(uint32_t value)
{
    HAL_SET32(__I2C_DATA__ADDRESS(), value);
}

/** I2C_DATA__SETB0() sets byte 0 of DATA to given value.
 *
 * When writing to byte 0 of DATA, this is mandatory to use.
 *
 * @param value new value for byte 0 of DATA
 */
__I2C_INLINE void I2C_DATA__SETB0(uint8_t value)
{
    HAL_SET8(((uint8_t*)__I2C_DATA__ADDRESS()) + 0, value);
}

/** I2C_DATA__GET() gets DATA's current value.
 *
 * When reading from DATA, this is mandatory to use.
 *
 * @return current value of DATA
 */
__I2C_INLINE uint32_t I2C_DATA__GET(void)
{
    return HAL_GET32(__I2C_DATA__ADDRESS());
}

/** I2C_DATA__GETB0() gets byte 0 of DATA's current value.
 *
 * When reading from byte 0 of DATA, this is mandatory to use.
 *
 * @return current value of byte 0 of DATA
 */
__I2C_INLINE uint8_t I2C_DATA__GETB0(void)
{
    return HAL_GET8(((uint8_t*)__I2C_DATA__ADDRESS()) + 0);
}

/* ----------------------------- I2C.DATA.DATA ----------------------------- */

/**
<pre>
  I2C.DATA.DATA:

    contain the received byte

</pre> */

#define I2C_DATA__DATA__Pos                                     0                                                                      /*!< Right-most bit position of DATA in I2C.DATA */
#define I2C_DATA__DATA__Msk                                     (0x000000FFUL << I2C_DATA__DATA__Pos)                                  /*!< Mask for DATA in I2C.DATA */
#define I2C_DATA__DATA__Shift(v)                                (((v) << I2C_DATA__DATA__Pos) & I2C_DATA__DATA__Msk)                   /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** I2C_DATA__DATA__SET() sets DATA.DATA to given value.
 *
 * When writing to DATA.DATA, this is recommended to use.
 *
 * @param bf_value new value for DATA.DATA
 */
__I2C_INLINE void I2C_DATA__DATA__SET(uint32_t bf_value)
{
    uint8_t reg = (uint8_t)bf_value & (uint8_t)0xFF;
    I2C_DATA__SETB0(reg);
}

/** I2C_DATA__DATA__GET() gets DATA.DATA's current value.
 *
 * When reading from DATA.DATA, this is recommended to use.
 *
 * @return current value of DATA.DATA
 */
__I2C_INLINE uint32_t I2C_DATA__DATA__GET(void)
{
    uint8_t reg = I2C_DATA__GETB0();
    reg = (reg & (uint8_t)0xFF);
    return (uint32_t)reg;
}

/** I2C_DATA__DATA__MODIFY() modifies DATA.DATA.
 *
 * This is recommended to use when setting more than one bitfield of I2C.DATA.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.DATA
 * @param bf_value new value for DATA.DATA
 * @return new value of I2C.DATA
 */
__I2C_INLINE uint32_t I2C_DATA__DATA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_DATA__DATA__Msk);
    reg = (reg | (I2C_DATA__DATA__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_DATA__DATA__EXTRACT() extracts DATA.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.DATA.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.DATA
 * @return current value of DATA.DATA
 */
__I2C_INLINE uint32_t I2C_DATA__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_DATA__DATA__Msk);
    reg = (reg >> I2C_DATA__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                            CNTR member of I2C_t                            */
/* -------------------------------------------------------------------------- */

/** __I2C_CNTR__ADDRESS returns the address of member CNTR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CNTR
 */
__I2C_INLINE uint32_t* __I2C_CNTR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__I2C_BASE_PTR() + (uint32_t)(offsetof(I2C_t, CNTR)));
}

/** I2C_CNTR__SET() sets CNTR to given value.
 *
 * When writing to CNTR, this is mandatory to use.
 *
 * @param value new value for CNTR
 */
__I2C_INLINE void I2C_CNTR__SET(uint32_t value)
{
    HAL_SET32(__I2C_CNTR__ADDRESS(), value);
}

/** I2C_CNTR__GET() gets CNTR's current value.
 *
 * When reading from CNTR, this is mandatory to use.
 *
 * @return current value of CNTR
 */
__I2C_INLINE uint32_t I2C_CNTR__GET(void)
{
    return HAL_GET32(__I2C_CNTR__ADDRESS());
}

/* ------------------------------ I2C.CNTR.IEN ------------------------------ */


#define I2C_CNTR__IEN__Pos                                      7                                                                      /*!< Right-most bit position of IEN in I2C.CNTR */
#define I2C_CNTR__IEN__Msk                                      (0x00000001UL << I2C_CNTR__IEN__Pos)                                   /*!< Mask for IEN in I2C.CNTR */
#define I2C_CNTR__IEN__Shift(v)                                 (((v) << I2C_CNTR__IEN__Pos) & I2C_CNTR__IEN__Msk)                     /*!< Shift value 'v' into IEN and mask 'v' to fit it into IEN field */

/** I2C_CNTR__IEN__SET() sets CNTR.IEN to given value.
 *
 * When writing to CNTR.IEN, this is recommended to use.
 *
 * @param bf_value new value for CNTR.IEN
 */
__I2C_INLINE void I2C_CNTR__IEN__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_CNTR__GET();
    reg = (reg & ~I2C_CNTR__IEN__Msk);
    reg = (reg | (I2C_CNTR__IEN__Shift((uint32_t)bf_value)));
    I2C_CNTR__SET(reg);
}

/** I2C_CNTR__IEN__GET() gets CNTR.IEN's current value.
 *
 * When reading from CNTR.IEN, this is recommended to use.
 *
 * @return current value of CNTR.IEN
 */
__I2C_INLINE uint32_t I2C_CNTR__IEN__GET(void)
{
    uint32_t reg = I2C_CNTR__GET();
    reg = (reg & I2C_CNTR__IEN__Msk);
    reg = (reg >> I2C_CNTR__IEN__Pos);
    return (uint32_t)reg;
}

/** I2C_CNTR__IEN__MODIFY() modifies CNTR.IEN.
 *
 * This is recommended to use when setting more than one bitfield of I2C.CNTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.CNTR
 * @param bf_value new value for CNTR.IEN
 * @return new value of I2C.CNTR
 */
__I2C_INLINE uint32_t I2C_CNTR__IEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_CNTR__IEN__Msk);
    reg = (reg | (I2C_CNTR__IEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_CNTR__IEN__EXTRACT() extracts CNTR.IEN.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.CNTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.CNTR
 * @return current value of CNTR.IEN
 */
__I2C_INLINE uint32_t I2C_CNTR__IEN__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_CNTR__IEN__Msk);
    reg = (reg >> I2C_CNTR__IEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------------- I2C.CNTR.ENAB ----------------------------- */


#define I2C_CNTR__ENAB__Pos                                     6                                                                      /*!< Right-most bit position of ENAB in I2C.CNTR */
#define I2C_CNTR__ENAB__Msk                                     (0x00000001UL << I2C_CNTR__ENAB__Pos)                                  /*!< Mask for ENAB in I2C.CNTR */
#define I2C_CNTR__ENAB__Shift(v)                                (((v) << I2C_CNTR__ENAB__Pos) & I2C_CNTR__ENAB__Msk)                   /*!< Shift value 'v' into ENAB and mask 'v' to fit it into ENAB field */

/** I2C_CNTR__ENAB__SET() sets CNTR.ENAB to given value.
 *
 * When writing to CNTR.ENAB, this is recommended to use.
 *
 * @param bf_value new value for CNTR.ENAB
 */
__I2C_INLINE void I2C_CNTR__ENAB__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_CNTR__GET();
    reg = (reg & ~I2C_CNTR__ENAB__Msk);
    reg = (reg | (I2C_CNTR__ENAB__Shift((uint32_t)bf_value)));
    I2C_CNTR__SET(reg);
}

/** I2C_CNTR__ENAB__GET() gets CNTR.ENAB's current value.
 *
 * When reading from CNTR.ENAB, this is recommended to use.
 *
 * @return current value of CNTR.ENAB
 */
__I2C_INLINE uint32_t I2C_CNTR__ENAB__GET(void)
{
    uint32_t reg = I2C_CNTR__GET();
    reg = (reg & I2C_CNTR__ENAB__Msk);
    reg = (reg >> I2C_CNTR__ENAB__Pos);
    return (uint32_t)reg;
}

/** I2C_CNTR__ENAB__MODIFY() modifies CNTR.ENAB.
 *
 * This is recommended to use when setting more than one bitfield of I2C.CNTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.CNTR
 * @param bf_value new value for CNTR.ENAB
 * @return new value of I2C.CNTR
 */
__I2C_INLINE uint32_t I2C_CNTR__ENAB__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_CNTR__ENAB__Msk);
    reg = (reg | (I2C_CNTR__ENAB__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_CNTR__ENAB__EXTRACT() extracts CNTR.ENAB.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.CNTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.CNTR
 * @return current value of CNTR.ENAB
 */
__I2C_INLINE uint32_t I2C_CNTR__ENAB__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_CNTR__ENAB__Msk);
    reg = (reg >> I2C_CNTR__ENAB__Pos);
    return (uint32_t)reg;
}

/* ------------------------------ I2C.CNTR.STA ------------------------------ */


#define I2C_CNTR__STA__Pos                                      5                                                                      /*!< Right-most bit position of STA in I2C.CNTR */
#define I2C_CNTR__STA__Msk                                      (0x00000001UL << I2C_CNTR__STA__Pos)                                   /*!< Mask for STA in I2C.CNTR */
#define I2C_CNTR__STA__Shift(v)                                 (((v) << I2C_CNTR__STA__Pos) & I2C_CNTR__STA__Msk)                     /*!< Shift value 'v' into STA and mask 'v' to fit it into STA field */

/** I2C_CNTR__STA__SET() sets CNTR.STA to given value.
 *
 * When writing to CNTR.STA, this is recommended to use.
 *
 * @param bf_value new value for CNTR.STA
 */
__I2C_INLINE void I2C_CNTR__STA__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_CNTR__STA__Shift((uint32_t)bf_value);
    I2C_CNTR__SET(reg);
}


/** I2C_CNTR__STA__MODIFY() modifies CNTR.STA.
 *
 * This is recommended to use when setting more than one bitfield of I2C.CNTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.CNTR
 * @param bf_value new value for CNTR.STA
 * @return new value of I2C.CNTR
 */
__I2C_INLINE uint32_t I2C_CNTR__STA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_CNTR__STA__Msk);
    reg = (reg | (I2C_CNTR__STA__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_CNTR__STA__EXTRACT() extracts CNTR.STA.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.CNTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.CNTR
 * @return current value of CNTR.STA
 */
__I2C_INLINE uint32_t I2C_CNTR__STA__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_CNTR__STA__Msk);
    reg = (reg >> I2C_CNTR__STA__Pos);
    return (uint32_t)reg;
}

/* ------------------------------ I2C.CNTR.STP ------------------------------ */


#define I2C_CNTR__STP__Pos                                      4                                                                      /*!< Right-most bit position of STP in I2C.CNTR */
#define I2C_CNTR__STP__Msk                                      (0x00000001UL << I2C_CNTR__STP__Pos)                                   /*!< Mask for STP in I2C.CNTR */
#define I2C_CNTR__STP__Shift(v)                                 (((v) << I2C_CNTR__STP__Pos) & I2C_CNTR__STP__Msk)                     /*!< Shift value 'v' into STP and mask 'v' to fit it into STP field */

/** I2C_CNTR__STP__SET() sets CNTR.STP to given value.
 *
 * When writing to CNTR.STP, this is recommended to use.
 *
 * @param bf_value new value for CNTR.STP
 */
__I2C_INLINE void I2C_CNTR__STP__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_CNTR__STP__Shift((uint32_t)bf_value);
    I2C_CNTR__SET(reg);
}


/** I2C_CNTR__STP__MODIFY() modifies CNTR.STP.
 *
 * This is recommended to use when setting more than one bitfield of I2C.CNTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.CNTR
 * @param bf_value new value for CNTR.STP
 * @return new value of I2C.CNTR
 */
__I2C_INLINE uint32_t I2C_CNTR__STP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_CNTR__STP__Msk);
    reg = (reg | (I2C_CNTR__STP__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_CNTR__STP__EXTRACT() extracts CNTR.STP.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.CNTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.CNTR
 * @return current value of CNTR.STP
 */
__I2C_INLINE uint32_t I2C_CNTR__STP__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_CNTR__STP__Msk);
    reg = (reg >> I2C_CNTR__STP__Pos);
    return (uint32_t)reg;
}

/* ----------------------------- I2C.CNTR.IFLG ----------------------------- */


#define I2C_CNTR__IFLG__Pos                                     3                                                                      /*!< Right-most bit position of IFLG in I2C.CNTR */
#define I2C_CNTR__IFLG__Msk                                     (0x00000001UL << I2C_CNTR__IFLG__Pos)                                  /*!< Mask for IFLG in I2C.CNTR */
#define I2C_CNTR__IFLG__Shift(v)                                (((v) << I2C_CNTR__IFLG__Pos) & I2C_CNTR__IFLG__Msk)                   /*!< Shift value 'v' into IFLG and mask 'v' to fit it into IFLG field */

/** I2C_CNTR__IFLG__SET() sets CNTR.IFLG to given value.
 *
 * When writing to CNTR.IFLG, this is recommended to use.
 *
 * @param bf_value new value for CNTR.IFLG
 */
__I2C_INLINE void I2C_CNTR__IFLG__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_CNTR__IFLG__Shift((uint32_t)bf_value);
    I2C_CNTR__SET(reg);
}


/** I2C_CNTR__IFLG__MODIFY() modifies CNTR.IFLG.
 *
 * This is recommended to use when setting more than one bitfield of I2C.CNTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.CNTR
 * @param bf_value new value for CNTR.IFLG
 * @return new value of I2C.CNTR
 */
__I2C_INLINE uint32_t I2C_CNTR__IFLG__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_CNTR__IFLG__Msk);
    reg = (reg | (I2C_CNTR__IFLG__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_CNTR__IFLG__EXTRACT() extracts CNTR.IFLG.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.CNTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.CNTR
 * @return current value of CNTR.IFLG
 */
__I2C_INLINE uint32_t I2C_CNTR__IFLG__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_CNTR__IFLG__Msk);
    reg = (reg >> I2C_CNTR__IFLG__Pos);
    return (uint32_t)reg;
}

/* ------------------------------ I2C.CNTR.AAK ------------------------------ */


#define I2C_CNTR__AAK__Pos                                      2                                                                      /*!< Right-most bit position of AAK in I2C.CNTR */
#define I2C_CNTR__AAK__Msk                                      (0x00000001UL << I2C_CNTR__AAK__Pos)                                   /*!< Mask for AAK in I2C.CNTR */
#define I2C_CNTR__AAK__Shift(v)                                 (((v) << I2C_CNTR__AAK__Pos) & I2C_CNTR__AAK__Msk)                     /*!< Shift value 'v' into AAK and mask 'v' to fit it into AAK field */

/** I2C_CNTR__AAK__SET() sets CNTR.AAK to given value.
 *
 * When writing to CNTR.AAK, this is recommended to use.
 *
 * @param bf_value new value for CNTR.AAK
 */
__I2C_INLINE void I2C_CNTR__AAK__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_CNTR__GET();
    reg = (reg & ~I2C_CNTR__AAK__Msk);
    reg = (reg | (I2C_CNTR__AAK__Shift((uint32_t)bf_value)));
    I2C_CNTR__SET(reg);
}

/** I2C_CNTR__AAK__GET() gets CNTR.AAK's current value.
 *
 * When reading from CNTR.AAK, this is recommended to use.
 *
 * @return current value of CNTR.AAK
 */
__I2C_INLINE uint32_t I2C_CNTR__AAK__GET(void)
{
    uint32_t reg = I2C_CNTR__GET();
    reg = (reg & I2C_CNTR__AAK__Msk);
    reg = (reg >> I2C_CNTR__AAK__Pos);
    return (uint32_t)reg;
}

/** I2C_CNTR__AAK__MODIFY() modifies CNTR.AAK.
 *
 * This is recommended to use when setting more than one bitfield of I2C.CNTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.CNTR
 * @param bf_value new value for CNTR.AAK
 * @return new value of I2C.CNTR
 */
__I2C_INLINE uint32_t I2C_CNTR__AAK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_CNTR__AAK__Msk);
    reg = (reg | (I2C_CNTR__AAK__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_CNTR__AAK__EXTRACT() extracts CNTR.AAK.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.CNTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.CNTR
 * @return current value of CNTR.AAK
 */
__I2C_INLINE uint32_t I2C_CNTR__AAK__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_CNTR__AAK__Msk);
    reg = (reg >> I2C_CNTR__AAK__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          STAT_CCR member of I2C_t                          */
/* -------------------------------------------------------------------------- */

/** __I2C_STAT_CCR__ADDRESS returns the address of member STAT_CCR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of STAT_CCR
 */
__I2C_INLINE uint32_t* __I2C_STAT_CCR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__I2C_BASE_PTR() + (uint32_t)(offsetof(I2C_t, STAT_CCR)));
}

/** I2C_STAT_CCR__SET() sets STAT_CCR to given value.
 *
 * When writing to STAT_CCR, this is mandatory to use.
 *
 * @param value new value for STAT_CCR
 */
__I2C_INLINE void I2C_STAT_CCR__SET(uint32_t value)
{
    HAL_SET32(__I2C_STAT_CCR__ADDRESS(), value);
}

/** I2C_STAT_CCR__GET() gets STAT_CCR's current value.
 *
 * When reading from STAT_CCR, this is mandatory to use.
 *
 * @return current value of STAT_CCR
 */
__I2C_INLINE uint32_t I2C_STAT_CCR__GET(void)
{
    return HAL_GET32(__I2C_STAT_CCR__ADDRESS());
}

/* ----------------------------- I2C.STAT_CCR.M ----------------------------- */


#define I2C_STAT_CCR__M__Pos                                    3                                                                      /*!< Right-most bit position of M in I2C.STAT_CCR */
#define I2C_STAT_CCR__M__Msk                                    (0x0000000FUL << I2C_STAT_CCR__M__Pos)                                 /*!< Mask for M in I2C.STAT_CCR */
#define I2C_STAT_CCR__M__Shift(v)                               (((v) << I2C_STAT_CCR__M__Pos) & I2C_STAT_CCR__M__Msk)                 /*!< Shift value 'v' into M and mask 'v' to fit it into M field */

/** I2C_STAT_CCR__M__SET() sets STAT_CCR.M to given value.
 *
 * When writing to STAT_CCR.M, this is recommended to use.
 *
 * @param bf_value new value for STAT_CCR.M
 */
__I2C_INLINE void I2C_STAT_CCR__M__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_STAT_CCR__M__Shift((uint32_t)bf_value);
    I2C_STAT_CCR__SET(reg);
}


/** I2C_STAT_CCR__M__MODIFY() modifies STAT_CCR.M.
 *
 * This is recommended to use when setting more than one bitfield of I2C.STAT_CCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.STAT_CCR
 * @param bf_value new value for STAT_CCR.M
 * @return new value of I2C.STAT_CCR
 */
__I2C_INLINE uint32_t I2C_STAT_CCR__M__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_STAT_CCR__M__Msk);
    reg = (reg | (I2C_STAT_CCR__M__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_STAT_CCR__M__EXTRACT() extracts STAT_CCR.M.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.STAT_CCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.STAT_CCR
 * @return current value of STAT_CCR.M
 */
__I2C_INLINE uint32_t I2C_STAT_CCR__M__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_STAT_CCR__M__Msk);
    reg = (reg >> I2C_STAT_CCR__M__Pos);
    return (uint32_t)reg;
}

/* --------------------------- I2C.STAT_CCR.CODE --------------------------- */


#define I2C_STAT_CCR__CODE__Pos                                 3                                                                      /*!< Right-most bit position of CODE in I2C.STAT_CCR */
#define I2C_STAT_CCR__CODE__Msk                                 (0x0000001FUL << I2C_STAT_CCR__CODE__Pos)                              /*!< Mask for CODE in I2C.STAT_CCR */
#define I2C_STAT_CCR__CODE__Shift(v)                            (((v) << I2C_STAT_CCR__CODE__Pos) & I2C_STAT_CCR__CODE__Msk)           /*!< Shift value 'v' into CODE and mask 'v' to fit it into CODE field */

/** I2C_STAT_CCR__CODE__GET() gets STAT_CCR.CODE's current value.
 *
 * When reading from STAT_CCR.CODE, this is recommended to use.
 *
 * @return current value of STAT_CCR.CODE
 */
__I2C_INLINE uint32_t I2C_STAT_CCR__CODE__GET(void)
{
    uint32_t reg = I2C_STAT_CCR__GET();
    reg = (reg & I2C_STAT_CCR__CODE__Msk);
    reg = (reg >> I2C_STAT_CCR__CODE__Pos);
    return (uint32_t)reg;
}

/** I2C_STAT_CCR__CODE__EXTRACT() extracts STAT_CCR.CODE.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.STAT_CCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.STAT_CCR
 * @return current value of STAT_CCR.CODE
 */
__I2C_INLINE uint32_t I2C_STAT_CCR__CODE__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_STAT_CCR__CODE__Msk);
    reg = (reg >> I2C_STAT_CCR__CODE__Pos);
    return (uint32_t)reg;
}

/* ----------------------------- I2C.STAT_CCR.N ----------------------------- */


#define I2C_STAT_CCR__N__Pos                                    0                                                                      /*!< Right-most bit position of N in I2C.STAT_CCR */
#define I2C_STAT_CCR__N__Msk                                    (0x00000007UL << I2C_STAT_CCR__N__Pos)                                 /*!< Mask for N in I2C.STAT_CCR */
#define I2C_STAT_CCR__N__Shift(v)                               (((v) << I2C_STAT_CCR__N__Pos) & I2C_STAT_CCR__N__Msk)                 /*!< Shift value 'v' into N and mask 'v' to fit it into N field */

/** I2C_STAT_CCR__N__SET() sets STAT_CCR.N to given value.
 *
 * When writing to STAT_CCR.N, this is recommended to use.
 *
 * @param bf_value new value for STAT_CCR.N
 */
__I2C_INLINE void I2C_STAT_CCR__N__SET(uint32_t bf_value)
{
    uint32_t reg = I2C_STAT_CCR__N__Shift((uint32_t)bf_value);
    I2C_STAT_CCR__SET(reg);
}


/** I2C_STAT_CCR__N__MODIFY() modifies STAT_CCR.N.
 *
 * This is recommended to use when setting more than one bitfield of I2C.STAT_CCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.STAT_CCR
 * @param bf_value new value for STAT_CCR.N
 * @return new value of I2C.STAT_CCR
 */
__I2C_INLINE uint32_t I2C_STAT_CCR__N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_STAT_CCR__N__Msk);
    reg = (reg | (I2C_STAT_CCR__N__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_STAT_CCR__N__EXTRACT() extracts STAT_CCR.N.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.STAT_CCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.STAT_CCR
 * @return current value of STAT_CCR.N
 */
__I2C_INLINE uint32_t I2C_STAT_CCR__N__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_STAT_CCR__N__Msk);
    reg = (reg >> I2C_STAT_CCR__N__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           XADDR member of I2C_t                           */
/* -------------------------------------------------------------------------- */

/** __I2C_XADDR__ADDRESS returns the address of member XADDR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of XADDR
 */
__I2C_INLINE uint32_t* __I2C_XADDR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__I2C_BASE_PTR() + (uint32_t)(offsetof(I2C_t, XADDR)));
}

/** I2C_XADDR__SET() sets XADDR to given value.
 *
 * When writing to XADDR, this is mandatory to use.
 *
 * @param value new value for XADDR
 */
__I2C_INLINE void I2C_XADDR__SET(uint32_t value)
{
    HAL_SET32(__I2C_XADDR__ADDRESS(), value);
}

/** I2C_XADDR__SETB0() sets byte 0 of XADDR to given value.
 *
 * When writing to byte 0 of XADDR, this is mandatory to use.
 *
 * @param value new value for byte 0 of XADDR
 */
__I2C_INLINE void I2C_XADDR__SETB0(uint8_t value)
{
    HAL_SET8(((uint8_t*)__I2C_XADDR__ADDRESS()) + 0, value);
}

/** I2C_XADDR__GET() gets XADDR's current value.
 *
 * When reading from XADDR, this is mandatory to use.
 *
 * @return current value of XADDR
 */
__I2C_INLINE uint32_t I2C_XADDR__GET(void)
{
    return HAL_GET32(__I2C_XADDR__ADDRESS());
}

/** I2C_XADDR__GETB0() gets byte 0 of XADDR's current value.
 *
 * When reading from byte 0 of XADDR, this is mandatory to use.
 *
 * @return current value of byte 0 of XADDR
 */
__I2C_INLINE uint8_t I2C_XADDR__GETB0(void)
{
    return HAL_GET8(((uint8_t*)__I2C_XADDR__ADDRESS()) + 0);
}

/* ----------------------------- I2C.XADDR.SLAX ----------------------------- */


#define I2C_XADDR__SLAX__Pos                                    0                                                                      /*!< Right-most bit position of SLAX in I2C.XADDR */
#define I2C_XADDR__SLAX__Msk                                    (0x000000FFUL << I2C_XADDR__SLAX__Pos)                                 /*!< Mask for SLAX in I2C.XADDR */
#define I2C_XADDR__SLAX__Shift(v)                               (((v) << I2C_XADDR__SLAX__Pos) & I2C_XADDR__SLAX__Msk)                 /*!< Shift value 'v' into SLAX and mask 'v' to fit it into SLAX field */

/** I2C_XADDR__SLAX__SET() sets XADDR.SLAX to given value.
 *
 * When writing to XADDR.SLAX, this is recommended to use.
 *
 * @param bf_value new value for XADDR.SLAX
 */
__I2C_INLINE void I2C_XADDR__SLAX__SET(uint32_t bf_value)
{
    uint8_t reg = (uint8_t)bf_value & (uint8_t)0xFF;
    I2C_XADDR__SETB0(reg);
}

/** I2C_XADDR__SLAX__GET() gets XADDR.SLAX's current value.
 *
 * When reading from XADDR.SLAX, this is recommended to use.
 *
 * @return current value of XADDR.SLAX
 */
__I2C_INLINE uint32_t I2C_XADDR__SLAX__GET(void)
{
    uint8_t reg = I2C_XADDR__GETB0();
    reg = (reg & (uint8_t)0xFF);
    return (uint32_t)reg;
}

/** I2C_XADDR__SLAX__MODIFY() modifies XADDR.SLAX.
 *
 * This is recommended to use when setting more than one bitfield of I2C.XADDR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.XADDR
 * @param bf_value new value for XADDR.SLAX
 * @return new value of I2C.XADDR
 */
__I2C_INLINE uint32_t I2C_XADDR__SLAX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_XADDR__SLAX__Msk);
    reg = (reg | (I2C_XADDR__SLAX__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_XADDR__SLAX__EXTRACT() extracts XADDR.SLAX.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.XADDR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.XADDR
 * @return current value of XADDR.SLAX
 */
__I2C_INLINE uint32_t I2C_XADDR__SLAX__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_XADDR__SLAX__Msk);
    reg = (reg >> I2C_XADDR__SLAX__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                            SRST member of I2C_t                            */
/* -------------------------------------------------------------------------- */

/** __I2C_SRST__ADDRESS returns the address of member SRST.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of SRST
 */
__I2C_INLINE uint32_t* __I2C_SRST__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__I2C_BASE_PTR() + (uint32_t)(offsetof(I2C_t, SRST)));
}

/** I2C_SRST__SET() sets SRST to given value.
 *
 * When writing to SRST, this is mandatory to use.
 *
 * @param value new value for SRST
 */
__I2C_INLINE void I2C_SRST__SET(uint32_t value)
{
    HAL_SET32(__I2C_SRST__ADDRESS(), value);
}

/** I2C_SRST__SETB0() sets byte 0 of SRST to given value.
 *
 * When writing to byte 0 of SRST, this is mandatory to use.
 *
 * @param value new value for byte 0 of SRST
 */
__I2C_INLINE void I2C_SRST__SETB0(uint8_t value)
{
    HAL_SET8(((uint8_t*)__I2C_SRST__ADDRESS()) + 0, value);
}


/* ------------------------------ I2C.SRST.RST ------------------------------ */


#define I2C_SRST__RST__Pos                                      0                                                                      /*!< Right-most bit position of RST in I2C.SRST */
#define I2C_SRST__RST__Msk                                      (0x0000007FUL << I2C_SRST__RST__Pos)                                   /*!< Mask for RST in I2C.SRST */
#define I2C_SRST__RST__Shift(v)                                 (((v) << I2C_SRST__RST__Pos) & I2C_SRST__RST__Msk)                     /*!< Shift value 'v' into RST and mask 'v' to fit it into RST field */

/** I2C_SRST__RST__SET() sets SRST.RST to given value.
 *
 * When writing to SRST.RST, this is recommended to use.
 *
 * @param bf_value new value for SRST.RST
 */
__I2C_INLINE void I2C_SRST__RST__SET(uint32_t bf_value)
{
    uint8_t reg = (uint8_t)bf_value & (uint8_t)0x7F;
    I2C_SRST__SETB0(reg);
}


/** I2C_SRST__RST__MODIFY() modifies SRST.RST.
 *
 * This is recommended to use when setting more than one bitfield of I2C.SRST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of I2C.SRST
 * @param bf_value new value for SRST.RST
 * @return new value of I2C.SRST
 */
__I2C_INLINE uint32_t I2C_SRST__RST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~I2C_SRST__RST__Msk);
    reg = (reg | (I2C_SRST__RST__Shift((uint32_t)bf_value)));
    return reg;
}

/** I2C_SRST__RST__EXTRACT() extracts SRST.RST.
 *
 * This is recommended to use when extracting more than one bitfield from I2C.SRST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of I2C.SRST
 * @return current value of SRST.RST
 */
__I2C_INLINE uint32_t I2C_SRST__RST__EXTRACT(uint32_t reg)
{
    reg = (reg & I2C_SRST__RST__Msk);
    reg = (reg >> I2C_SRST__RST__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group i2c block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_I2C_H_ */
