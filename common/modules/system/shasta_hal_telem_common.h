/**
 * @file     shasta_hal_telem_common.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_TELEM_COMMON_H_
#define _SHASTA_HAL_TELEM_COMMON_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup tlmcom
 * @{
 */

#if defined ( __CC_ARM )
#define __TLMCOM_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __TLMCOM_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __TLMCOM_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __TLMCOM_INLINE  static inline
#endif

/** register file of the tlmcom block.
 */
typedef struct _TLMCOM_s
{
    volatile        uint32_t        TLM_KFP                     ; /*!< (@0x00000000) ATSEN, BTSEN and ITSEN telemetry low pass filter coefficient index.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter. <s...(more) */
    volatile        uint32_t        TLM_IRQ_THR_0               ; /*!< (@0x00000004) Telemetry interrupt (IRQ) 0 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_0.  Format based on selected source. <start table_with_heade...(more) */
    volatile        uint32_t        TLM_IRQ_THR_1               ; /*!< (@0x00000008) Telemetry interrupt (IRQ) 1 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_1.  Format based on selected source. <start table_with_heade...(more) */
    volatile        uint32_t        TLM_IRQ_THR_2               ; /*!< (@0x0000000C) Telemetry interrupt (IRQ) 2 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_2.  Format based on selected source. <start table_with_heade...(more) */
    volatile        uint32_t        TLM_IRQ_THR_3               ; /*!< (@0x00000010) Telemetry interrupt (IRQ) 3 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_3.  Format based on selected source. <start table_with_heade...(more) */
    volatile        uint32_t        TLM_IRQ_THR_4               ; /*!< (@0x00000014) Telemetry interrupt (IRQ) 4 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_4.  Format based on selected source. <start table_with_heade...(more) */
    volatile        uint32_t        TLM_IRQ_THR_5               ; /*!< (@0x00000018) Telemetry interrupt (IRQ) 5 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_5.  Format based on selected source. <start table_with_heade...(more) */
    volatile        uint32_t        TLM_IRQ_THR_6               ; /*!< (@0x0000001C) Telemetry interrupt (IRQ) 6 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_6.  Format based on selected source. <start table_with_heade...(more) */
    volatile        uint32_t        TLM_IRQ_THR_7               ; /*!< (@0x00000020) Telemetry interrupt (IRQ) 7 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_7.  Format based on selected source. <start table_with_heade...(more) */
    volatile        uint32_t        TLM_IRQ_THR_8               ; /*!< (@0x00000024) Telemetry interrupt (IRQ) 8 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_8.  Format based on selected source. <start table_with_heade...(more) */
    volatile        uint32_t        TLM_IRQ_THR_9               ; /*!< (@0x00000028) Telemetry interrupt (IRQ) 9 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_9.  Format based on selected source. <start table_with_heade...(more) */
    volatile        uint32_t        TLM_IRQ_THR_10              ; /*!< (@0x0000002C) Telemetry interrupt (IRQ) 10 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_10.  Format based on selected source. <start table_with_hea...(more) */
    volatile        uint32_t        TLM_IRQ_THR_11              ; /*!< (@0x00000030) Telemetry interrupt (IRQ) 11 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_11.  Format based on selected source. <start table_with_hea...(more) */
    volatile        uint32_t        TLM_IRQ_THR_12              ; /*!< (@0x00000034) Telemetry interrupt (IRQ) 12 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_12.  Format based on selected source. <start table_with_hea...(more) */
    volatile        uint32_t        TLM_IRQ_THR_13              ; /*!< (@0x00000038) Telemetry interrupt (IRQ) 13 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_13.  Format based on selected source. <start table_with_hea...(more) */
    volatile        uint32_t        TLM_IRQ_THR_14              ; /*!< (@0x0000003C) Telemetry interrupt (IRQ) 14 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_14.  Format based on selected source. <start table_with_hea...(more) */
    volatile        uint32_t        TLM_IRQ_THR_15              ; /*!< (@0x00000040) Telemetry interrupt (IRQ) 15 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_15.  Format based on selected source. <start table_with_hea...(more) */
    volatile        uint32_t        TLM_ATSEN_LPF               ; /*!< (@0x00000044) Low pass filtered ATSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW....(more) */
    volatile        uint32_t        TLM_ATSEN_FS                ; /*!< (@0x00000048) Unfiltered ATSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW. LSB = ...(more) */
    volatile        uint32_t        TLM_BTSEN_LPF               ; /*!< (@0x0000004C) Low pass filtered BTSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW....(more) */
    volatile        uint32_t        TLM_BTSEN_FS                ; /*!< (@0x00000050) Unfiltered BTSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW. LSB = ...(more) */
    volatile        uint32_t        TLM_ITSEN_LPF               ; /*!< (@0x00000054) Low pass filtered ITSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW....(more) */
    volatile        uint32_t        TLM_ITSEN_FS                ; /*!< (@0x00000058) Unfiltered ITSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW. LSB = ...(more) */
    volatile        uint32_t        TLM_IRQ_POLARITY            ; /*!< (@0x0000005C) Telemetry interrupt (IRQ) comparison polarity select where bit [X] corresponds to IRQX. <start table> 0 "Assert IRQ when Signal > IRQ Threshold" 1 "Assert I...(more) */
    volatile        uint32_t        TLM_IRQ_EN                  ; /*!< (@0x00000060) Telemetry interrupt (IRQ) enable / clear where bit [X] corresponds to IRQX. <start table> 0 "Interrupt disabled and cleared." 1 "Interrupt enabled." <end table> */
    volatile        uint32_t        TLM_IRQ_STAT                ; /*!< (@0x00000064) Telemetry interrupt (IRQ) status where bit [X] corresponds to IRQX. <start table> 0 "IRQ not set" 1 "IRQ set" <end table> */
    volatile        uint32_t        TLM_IMON_LPF                ; /*!< (@0x00000068) Low pass filtered IMON telemetry output when used as a general purpose ADC. LSB = 0.0625 ADC Code, Range = 0 to 1023.9375 ADC Codes */
    volatile        uint32_t        TLM_PRISEN_LPF              ; /*!< (@0x0000006C) Low pass filtered PRISEN telemetry output when used as a general purpose ADC. LSB = 0.0625 ADC Code, Range = 0 to 1023.9375 ADC Codes */
    volatile        uint32_t        TLM_XADDR_PINSET            ; /*!< (@0x00000070) XADDR1 pinset measurement decoded value. */
    volatile        uint32_t        TLM_XADDR1_LPF              ; /*!< (@0x00000074) Low pass filtered XADDR1 telemetry output when used as a general purpose ADC. LSB = 0.0625 ADC Code, Range = 0 to 1023.9375 ADC Codes */
    volatile        uint32_t        TLM_XADDR2_LPF              ; /*!< (@0x00000078) Low pass filtered XADDR2 telemetry output when used as a general purpose ADC. LSB = 0.0625 ADC Code, Range = 0 to 1023.9375 ADC Codes */
} TLMCOM_t;


#define TLMCOM_BASE (0x70005000u)                                                          /*!< tlmcom base address */

/** __TLMCOM_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_BASE_PTR(void)
{
    return (uint32_t*)(TLMCOM_BASE);
}


/* -------------------------------------------------------------------------- */
/*                         TLM_KFP member of TLMCOM_t                         */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_KFP__ADDRESS returns the address of member TLM_KFP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_KFP
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_KFP__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_KFP)));
}

/** TLMCOM_TLM_KFP__SET() sets TLM_KFP to given value.
 *
 * When writing to TLM_KFP, this is mandatory to use.
 *
 * @param value new value for TLM_KFP
 */
__TLMCOM_INLINE void TLMCOM_TLM_KFP__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_KFP__ADDRESS(), value);
}

/** TLMCOM_TLM_KFP__GET() gets TLM_KFP's current value.
 *
 * When reading from TLM_KFP, this is mandatory to use.
 *
 * @return current value of TLM_KFP
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_KFP__ADDRESS());
}

/* ---------------------- TLMCOM.TLM_KFP.TLM_KFP_XADDR ---------------------- */

/**
<pre>
  TLMCOM.TLM_KFP.TLM_KFP_XADDR:

    XADDR1 and XADDR2 telemetry low pass filter coefficient index when used as a general purpose ADC.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter.
    <start table>
    "kfp_exp = tlm_kfp_xaddr[5:2]"
    "kfp_man = 4 + tlm_kfp_xaddr[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(KHz) = [kfp / (1 - kfp)] * 125KHz / 2*pi;"
    <end table>

</pre> */

#define TLMCOM_TLM_KFP__TLM_KFP_XADDR__Pos                      18                                                                     /*!< Right-most bit position of tlm_kfp_xaddr in TLMCOM.TLM_KFP */
#define TLMCOM_TLM_KFP__TLM_KFP_XADDR__Msk                      (0x0000003FUL << TLMCOM_TLM_KFP__TLM_KFP_XADDR__Pos)                   /*!< Mask for tlm_kfp_xaddr in TLMCOM.TLM_KFP */
#define TLMCOM_TLM_KFP__TLM_KFP_XADDR__Shift(v)                 (((v) << TLMCOM_TLM_KFP__TLM_KFP_XADDR__Pos) & TLMCOM_TLM_KFP__TLM_KFP_XADDR__Msk) /*!< Shift value 'v' into tlm_kfp_xaddr and mask 'v' to fit it into tlm_kfp_xaddr field */

/** TLMCOM_TLM_KFP__TLM_KFP_XADDR__SET() sets TLM_KFP.TLM_KFP_XADDR to given value.
 *
 * When writing to TLM_KFP.TLM_KFP_XADDR, this is recommended to use.
 *
 * @param bf_value new value for TLM_KFP.TLM_KFP_XADDR
 */
__TLMCOM_INLINE void TLMCOM_TLM_KFP__TLM_KFP_XADDR__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_KFP__GET();
    reg = (reg & ~TLMCOM_TLM_KFP__TLM_KFP_XADDR__Msk);
    reg = (reg | (TLMCOM_TLM_KFP__TLM_KFP_XADDR__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_KFP__SET(reg);
}

/** TLMCOM_TLM_KFP__TLM_KFP_XADDR__GET() gets TLM_KFP.TLM_KFP_XADDR's current value.
 *
 * When reading from TLM_KFP.TLM_KFP_XADDR, this is recommended to use.
 *
 * @return current value of TLM_KFP.TLM_KFP_XADDR
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_XADDR__GET(void)
{
    uint32_t reg = TLMCOM_TLM_KFP__GET();
    reg = (reg & TLMCOM_TLM_KFP__TLM_KFP_XADDR__Msk);
    reg = (reg >> TLMCOM_TLM_KFP__TLM_KFP_XADDR__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_KFP__TLM_KFP_XADDR__MODIFY() modifies TLM_KFP.TLM_KFP_XADDR.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_KFP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_KFP
 * @param bf_value new value for TLM_KFP.TLM_KFP_XADDR
 * @return new value of TLMCOM.TLM_KFP
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_XADDR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_KFP__TLM_KFP_XADDR__Msk);
    reg = (reg | (TLMCOM_TLM_KFP__TLM_KFP_XADDR__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_KFP__TLM_KFP_XADDR__EXTRACT() extracts TLM_KFP.TLM_KFP_XADDR.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_KFP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_KFP
 * @return current value of TLM_KFP.TLM_KFP_XADDR
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_XADDR__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_KFP__TLM_KFP_XADDR__Msk);
    reg = (reg >> TLMCOM_TLM_KFP__TLM_KFP_XADDR__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TLMCOM.TLM_KFP.TLM_KFP_IMON ---------------------- */

/**
<pre>
  TLMCOM.TLM_KFP.TLM_KFP_IMON:

    IMON telemetry low pass filter coefficient index when used as a general purpose ADC.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter.
    <start table>
    "kfp_exp = tlm_kfp_imon[5:2]"
    "kfp_man = 4 + tlm_kfp_imon[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(KHz) = [kfp / (1 - kfp)] * 125KHz / 2*pi;"
    <end table>

</pre> */

#define TLMCOM_TLM_KFP__TLM_KFP_IMON__Pos                       12                                                                     /*!< Right-most bit position of tlm_kfp_imon in TLMCOM.TLM_KFP */
#define TLMCOM_TLM_KFP__TLM_KFP_IMON__Msk                       (0x0000003FUL << TLMCOM_TLM_KFP__TLM_KFP_IMON__Pos)                    /*!< Mask for tlm_kfp_imon in TLMCOM.TLM_KFP */
#define TLMCOM_TLM_KFP__TLM_KFP_IMON__Shift(v)                  (((v) << TLMCOM_TLM_KFP__TLM_KFP_IMON__Pos) & TLMCOM_TLM_KFP__TLM_KFP_IMON__Msk) /*!< Shift value 'v' into tlm_kfp_imon and mask 'v' to fit it into tlm_kfp_imon field */

/** TLMCOM_TLM_KFP__TLM_KFP_IMON__SET() sets TLM_KFP.TLM_KFP_IMON to given value.
 *
 * When writing to TLM_KFP.TLM_KFP_IMON, this is recommended to use.
 *
 * @param bf_value new value for TLM_KFP.TLM_KFP_IMON
 */
__TLMCOM_INLINE void TLMCOM_TLM_KFP__TLM_KFP_IMON__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_KFP__GET();
    reg = (reg & ~TLMCOM_TLM_KFP__TLM_KFP_IMON__Msk);
    reg = (reg | (TLMCOM_TLM_KFP__TLM_KFP_IMON__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_KFP__SET(reg);
}

/** TLMCOM_TLM_KFP__TLM_KFP_IMON__GET() gets TLM_KFP.TLM_KFP_IMON's current value.
 *
 * When reading from TLM_KFP.TLM_KFP_IMON, this is recommended to use.
 *
 * @return current value of TLM_KFP.TLM_KFP_IMON
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_IMON__GET(void)
{
    uint32_t reg = TLMCOM_TLM_KFP__GET();
    reg = (reg & TLMCOM_TLM_KFP__TLM_KFP_IMON__Msk);
    reg = (reg >> TLMCOM_TLM_KFP__TLM_KFP_IMON__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_KFP__TLM_KFP_IMON__MODIFY() modifies TLM_KFP.TLM_KFP_IMON.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_KFP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_KFP
 * @param bf_value new value for TLM_KFP.TLM_KFP_IMON
 * @return new value of TLMCOM.TLM_KFP
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_IMON__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_KFP__TLM_KFP_IMON__Msk);
    reg = (reg | (TLMCOM_TLM_KFP__TLM_KFP_IMON__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_KFP__TLM_KFP_IMON__EXTRACT() extracts TLM_KFP.TLM_KFP_IMON.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_KFP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_KFP
 * @return current value of TLM_KFP.TLM_KFP_IMON
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_IMON__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_KFP__TLM_KFP_IMON__Msk);
    reg = (reg >> TLMCOM_TLM_KFP__TLM_KFP_IMON__Pos);
    return (uint32_t)reg;
}

/* --------------------- TLMCOM.TLM_KFP.TLM_KFP_PRISEN --------------------- */

/**
<pre>
  TLMCOM.TLM_KFP.TLM_KFP_PRISEN:

    PRISEN telemetry low pass filter coefficient index when used as a general purpose ADC.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter.
    <start table>
    "kfp_exp = tlm_kfp_prisen[5:2]"
    "kfp_man = 4 + tlm_kfp_prisen[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(KHz) = [kfp / (1 - kfp)] * 125KHz / 2*pi;"
    <end table>

</pre> */

#define TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Pos                     6                                                                      /*!< Right-most bit position of tlm_kfp_prisen in TLMCOM.TLM_KFP */
#define TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Msk                     (0x0000003FUL << TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Pos)                  /*!< Mask for tlm_kfp_prisen in TLMCOM.TLM_KFP */
#define TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Shift(v)                (((v) << TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Pos) & TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Msk) /*!< Shift value 'v' into tlm_kfp_prisen and mask 'v' to fit it into tlm_kfp_prisen field */

/** TLMCOM_TLM_KFP__TLM_KFP_PRISEN__SET() sets TLM_KFP.TLM_KFP_PRISEN to given value.
 *
 * When writing to TLM_KFP.TLM_KFP_PRISEN, this is recommended to use.
 *
 * @param bf_value new value for TLM_KFP.TLM_KFP_PRISEN
 */
__TLMCOM_INLINE void TLMCOM_TLM_KFP__TLM_KFP_PRISEN__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_KFP__GET();
    reg = (reg & ~TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Msk);
    reg = (reg | (TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_KFP__SET(reg);
}

/** TLMCOM_TLM_KFP__TLM_KFP_PRISEN__GET() gets TLM_KFP.TLM_KFP_PRISEN's current value.
 *
 * When reading from TLM_KFP.TLM_KFP_PRISEN, this is recommended to use.
 *
 * @return current value of TLM_KFP.TLM_KFP_PRISEN
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_PRISEN__GET(void)
{
    uint32_t reg = TLMCOM_TLM_KFP__GET();
    reg = (reg & TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Msk);
    reg = (reg >> TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_KFP__TLM_KFP_PRISEN__MODIFY() modifies TLM_KFP.TLM_KFP_PRISEN.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_KFP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_KFP
 * @param bf_value new value for TLM_KFP.TLM_KFP_PRISEN
 * @return new value of TLMCOM.TLM_KFP
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_PRISEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Msk);
    reg = (reg | (TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_KFP__TLM_KFP_PRISEN__EXTRACT() extracts TLM_KFP.TLM_KFP_PRISEN.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_KFP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_KFP
 * @return current value of TLM_KFP.TLM_KFP_PRISEN
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_PRISEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Msk);
    reg = (reg >> TLMCOM_TLM_KFP__TLM_KFP_PRISEN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TLMCOM.TLM_KFP.TLM_KFP_TSEN ---------------------- */

/**
<pre>
  TLMCOM.TLM_KFP.TLM_KFP_TSEN:

    ATSEN, BTSEN and ITSEN telemetry low pass filter coefficient index.  Note that exp settings greater than 9 are clamped to 9.  Set to 63 to bypass filter.
    <start table>
    "kfp_exp = tlm_kfp_tsen[5:2]"
    "kfp_man = 4 + tlm_kfp_tsen[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-13"
    "F3db(KHz) = [kfp / (1 - kfp)] * 125KHz / 2*pi;"
    <end table>

</pre> */

#define TLMCOM_TLM_KFP__TLM_KFP_TSEN__Pos                       0                                                                      /*!< Right-most bit position of tlm_kfp_tsen in TLMCOM.TLM_KFP */
#define TLMCOM_TLM_KFP__TLM_KFP_TSEN__Msk                       (0x0000003FUL << TLMCOM_TLM_KFP__TLM_KFP_TSEN__Pos)                    /*!< Mask for tlm_kfp_tsen in TLMCOM.TLM_KFP */
#define TLMCOM_TLM_KFP__TLM_KFP_TSEN__Shift(v)                  (((v) << TLMCOM_TLM_KFP__TLM_KFP_TSEN__Pos) & TLMCOM_TLM_KFP__TLM_KFP_TSEN__Msk) /*!< Shift value 'v' into tlm_kfp_tsen and mask 'v' to fit it into tlm_kfp_tsen field */

/** TLMCOM_TLM_KFP__TLM_KFP_TSEN__SET() sets TLM_KFP.TLM_KFP_TSEN to given value.
 *
 * When writing to TLM_KFP.TLM_KFP_TSEN, this is recommended to use.
 *
 * @param bf_value new value for TLM_KFP.TLM_KFP_TSEN
 */
__TLMCOM_INLINE void TLMCOM_TLM_KFP__TLM_KFP_TSEN__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_KFP__GET();
    reg = (reg & ~TLMCOM_TLM_KFP__TLM_KFP_TSEN__Msk);
    reg = (reg | (TLMCOM_TLM_KFP__TLM_KFP_TSEN__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_KFP__SET(reg);
}

/** TLMCOM_TLM_KFP__TLM_KFP_TSEN__GET() gets TLM_KFP.TLM_KFP_TSEN's current value.
 *
 * When reading from TLM_KFP.TLM_KFP_TSEN, this is recommended to use.
 *
 * @return current value of TLM_KFP.TLM_KFP_TSEN
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_TSEN__GET(void)
{
    uint32_t reg = TLMCOM_TLM_KFP__GET();
    reg = (reg & TLMCOM_TLM_KFP__TLM_KFP_TSEN__Msk);
    reg = (reg >> TLMCOM_TLM_KFP__TLM_KFP_TSEN__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_KFP__TLM_KFP_TSEN__MODIFY() modifies TLM_KFP.TLM_KFP_TSEN.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_KFP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_KFP
 * @param bf_value new value for TLM_KFP.TLM_KFP_TSEN
 * @return new value of TLMCOM.TLM_KFP
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_TSEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_KFP__TLM_KFP_TSEN__Msk);
    reg = (reg | (TLMCOM_TLM_KFP__TLM_KFP_TSEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_KFP__TLM_KFP_TSEN__EXTRACT() extracts TLM_KFP.TLM_KFP_TSEN.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_KFP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_KFP
 * @return current value of TLM_KFP.TLM_KFP_TSEN
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_KFP__TLM_KFP_TSEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_KFP__TLM_KFP_TSEN__Msk);
    reg = (reg >> TLMCOM_TLM_KFP__TLM_KFP_TSEN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_THR_0 member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_0__ADDRESS returns the address of member TLM_IRQ_THR_0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_0
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_0)));
}

/** TLMCOM_TLM_IRQ_THR_0__SET() sets TLM_IRQ_THR_0 to given value.
 *
 * When writing to TLM_IRQ_THR_0, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_0
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_0__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_0__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_0__GET() gets TLM_IRQ_THR_0's current value.
 *
 * When reading from TLM_IRQ_THR_0, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_0
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_0__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_0__ADDRESS());
}

/* --------------- TLMCOM.TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0:

    Telemetry interrupt (IRQ) 0 source select.  Selects signal to compare agains tlm_irq_gereric_thr_0 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Pos        16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_0 in TLMCOM.TLM_IRQ_THR_0 */
#define TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Msk        (0x0000001FUL << TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Pos)     /*!< Mask for tlm_irq_thr_src_sel_0 in TLMCOM.TLM_IRQ_THR_0 */
#define TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Pos) & TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_0 and mask 'v' to fit it into tlm_irq_thr_src_sel_0 field */

/** TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__SET() sets TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0 to given value.
 *
 * When writing to TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_0__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_0__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__GET() gets TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0's current value.
 *
 * When reading from TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_0__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__MODIFY() modifies TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_0
 * @param bf_value new value for TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0
 * @return new value of TLMCOM.TLM_IRQ_THR_0
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__EXTRACT() extracts TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_0
 * @return current value of TLM_IRQ_THR_0.TLM_IRQ_THR_SRC_SEL_0
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_THR_SRC_SEL_0__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0:

    Telemetry interrupt (IRQ) 0 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_0.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Pos        0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_0 in TLMCOM.TLM_IRQ_THR_0 */
#define TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Msk        (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Pos)     /*!< Mask for tlm_irq_gereric_thr_0 in TLMCOM.TLM_IRQ_THR_0 */
#define TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Pos) & TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_0 and mask 'v' to fit it into tlm_irq_gereric_thr_0 field */

/** TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__SET() sets TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0 to given value.
 *
 * When writing to TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_0__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_0__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__GET() gets TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0's current value.
 *
 * When reading from TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_0__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__MODIFY() modifies TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_0
 * @param bf_value new value for TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0
 * @return new value of TLMCOM.TLM_IRQ_THR_0
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__EXTRACT() extracts TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_0
 * @return current value of TLM_IRQ_THR_0.TLM_IRQ_GERERIC_THR_0
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_0__TLM_IRQ_GERERIC_THR_0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_THR_1 member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_1__ADDRESS returns the address of member TLM_IRQ_THR_1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_1
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_1)));
}

/** TLMCOM_TLM_IRQ_THR_1__SET() sets TLM_IRQ_THR_1 to given value.
 *
 * When writing to TLM_IRQ_THR_1, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_1
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_1__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_1__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_1__GET() gets TLM_IRQ_THR_1's current value.
 *
 * When reading from TLM_IRQ_THR_1, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_1
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_1__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_1__ADDRESS());
}

/* --------------- TLMCOM.TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1:

    Telemetry interrupt (IRQ) 1 source select.  Selects signal to compare agains tlm_irq_gereric_thr_1 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Pos        16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_1 in TLMCOM.TLM_IRQ_THR_1 */
#define TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Msk        (0x0000001FUL << TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Pos)     /*!< Mask for tlm_irq_thr_src_sel_1 in TLMCOM.TLM_IRQ_THR_1 */
#define TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Pos) & TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_1 and mask 'v' to fit it into tlm_irq_thr_src_sel_1 field */

/** TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__SET() sets TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1 to given value.
 *
 * When writing to TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_1__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_1__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__GET() gets TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1's current value.
 *
 * When reading from TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_1__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__MODIFY() modifies TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_1
 * @param bf_value new value for TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1
 * @return new value of TLMCOM.TLM_IRQ_THR_1
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__EXTRACT() extracts TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_1
 * @return current value of TLM_IRQ_THR_1.TLM_IRQ_THR_SRC_SEL_1
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_THR_SRC_SEL_1__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1:

    Telemetry interrupt (IRQ) 1 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_1.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Pos        0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_1 in TLMCOM.TLM_IRQ_THR_1 */
#define TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Msk        (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Pos)     /*!< Mask for tlm_irq_gereric_thr_1 in TLMCOM.TLM_IRQ_THR_1 */
#define TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Pos) & TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_1 and mask 'v' to fit it into tlm_irq_gereric_thr_1 field */

/** TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__SET() sets TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1 to given value.
 *
 * When writing to TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_1__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_1__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__GET() gets TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1's current value.
 *
 * When reading from TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_1__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__MODIFY() modifies TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_1
 * @param bf_value new value for TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1
 * @return new value of TLMCOM.TLM_IRQ_THR_1
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__EXTRACT() extracts TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_1
 * @return current value of TLM_IRQ_THR_1.TLM_IRQ_GERERIC_THR_1
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_1__TLM_IRQ_GERERIC_THR_1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_THR_2 member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_2__ADDRESS returns the address of member TLM_IRQ_THR_2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_2
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_2)));
}

/** TLMCOM_TLM_IRQ_THR_2__SET() sets TLM_IRQ_THR_2 to given value.
 *
 * When writing to TLM_IRQ_THR_2, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_2
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_2__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_2__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_2__GET() gets TLM_IRQ_THR_2's current value.
 *
 * When reading from TLM_IRQ_THR_2, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_2
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_2__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_2__ADDRESS());
}

/* --------------- TLMCOM.TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2:

    Telemetry interrupt (IRQ) 2 source select.  Selects signal to compare agains tlm_irq_gereric_thr_2 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Pos        16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_2 in TLMCOM.TLM_IRQ_THR_2 */
#define TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Msk        (0x0000001FUL << TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Pos)     /*!< Mask for tlm_irq_thr_src_sel_2 in TLMCOM.TLM_IRQ_THR_2 */
#define TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Pos) & TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_2 and mask 'v' to fit it into tlm_irq_thr_src_sel_2 field */

/** TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__SET() sets TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2 to given value.
 *
 * When writing to TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_2__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_2__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__GET() gets TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2's current value.
 *
 * When reading from TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_2__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__MODIFY() modifies TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_2
 * @param bf_value new value for TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2
 * @return new value of TLMCOM.TLM_IRQ_THR_2
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__EXTRACT() extracts TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_2
 * @return current value of TLM_IRQ_THR_2.TLM_IRQ_THR_SRC_SEL_2
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_THR_SRC_SEL_2__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2:

    Telemetry interrupt (IRQ) 2 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_2.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Pos        0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_2 in TLMCOM.TLM_IRQ_THR_2 */
#define TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Msk        (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Pos)     /*!< Mask for tlm_irq_gereric_thr_2 in TLMCOM.TLM_IRQ_THR_2 */
#define TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Pos) & TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_2 and mask 'v' to fit it into tlm_irq_gereric_thr_2 field */

/** TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__SET() sets TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2 to given value.
 *
 * When writing to TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_2__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_2__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__GET() gets TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2's current value.
 *
 * When reading from TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_2__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__MODIFY() modifies TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_2
 * @param bf_value new value for TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2
 * @return new value of TLMCOM.TLM_IRQ_THR_2
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__EXTRACT() extracts TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_2
 * @return current value of TLM_IRQ_THR_2.TLM_IRQ_GERERIC_THR_2
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_2__TLM_IRQ_GERERIC_THR_2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_THR_3 member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_3__ADDRESS returns the address of member TLM_IRQ_THR_3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_3
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_3)));
}

/** TLMCOM_TLM_IRQ_THR_3__SET() sets TLM_IRQ_THR_3 to given value.
 *
 * When writing to TLM_IRQ_THR_3, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_3
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_3__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_3__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_3__GET() gets TLM_IRQ_THR_3's current value.
 *
 * When reading from TLM_IRQ_THR_3, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_3
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_3__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_3__ADDRESS());
}

/* --------------- TLMCOM.TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3:

    Telemetry interrupt (IRQ) 3 source select.  Selects signal to compare agains tlm_irq_gereric_thr_3 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Pos        16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_3 in TLMCOM.TLM_IRQ_THR_3 */
#define TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Msk        (0x0000001FUL << TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Pos)     /*!< Mask for tlm_irq_thr_src_sel_3 in TLMCOM.TLM_IRQ_THR_3 */
#define TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Pos) & TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_3 and mask 'v' to fit it into tlm_irq_thr_src_sel_3 field */

/** TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__SET() sets TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3 to given value.
 *
 * When writing to TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_3__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_3__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__GET() gets TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3's current value.
 *
 * When reading from TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_3__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__MODIFY() modifies TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_3
 * @param bf_value new value for TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3
 * @return new value of TLMCOM.TLM_IRQ_THR_3
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__EXTRACT() extracts TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_3
 * @return current value of TLM_IRQ_THR_3.TLM_IRQ_THR_SRC_SEL_3
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_THR_SRC_SEL_3__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3:

    Telemetry interrupt (IRQ) 3 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_3.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Pos        0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_3 in TLMCOM.TLM_IRQ_THR_3 */
#define TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Msk        (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Pos)     /*!< Mask for tlm_irq_gereric_thr_3 in TLMCOM.TLM_IRQ_THR_3 */
#define TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Pos) & TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_3 and mask 'v' to fit it into tlm_irq_gereric_thr_3 field */

/** TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__SET() sets TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3 to given value.
 *
 * When writing to TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_3__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_3__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__GET() gets TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3's current value.
 *
 * When reading from TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_3__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__MODIFY() modifies TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_3
 * @param bf_value new value for TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3
 * @return new value of TLMCOM.TLM_IRQ_THR_3
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__EXTRACT() extracts TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_3
 * @return current value of TLM_IRQ_THR_3.TLM_IRQ_GERERIC_THR_3
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_3__TLM_IRQ_GERERIC_THR_3__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_THR_4 member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_4__ADDRESS returns the address of member TLM_IRQ_THR_4.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_4
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_4__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_4)));
}

/** TLMCOM_TLM_IRQ_THR_4__SET() sets TLM_IRQ_THR_4 to given value.
 *
 * When writing to TLM_IRQ_THR_4, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_4
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_4__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_4__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_4__GET() gets TLM_IRQ_THR_4's current value.
 *
 * When reading from TLM_IRQ_THR_4, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_4
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_4__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_4__ADDRESS());
}

/* --------------- TLMCOM.TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4:

    Telemetry interrupt (IRQ) 4 source select.  Selects signal to compare agains tlm_irq_gereric_thr_4 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Pos        16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_4 in TLMCOM.TLM_IRQ_THR_4 */
#define TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Msk        (0x0000001FUL << TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Pos)     /*!< Mask for tlm_irq_thr_src_sel_4 in TLMCOM.TLM_IRQ_THR_4 */
#define TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Pos) & TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_4 and mask 'v' to fit it into tlm_irq_thr_src_sel_4 field */

/** TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__SET() sets TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4 to given value.
 *
 * When writing to TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_4__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_4__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__GET() gets TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4's current value.
 *
 * When reading from TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_4__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__MODIFY() modifies TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_4
 * @param bf_value new value for TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4
 * @return new value of TLMCOM.TLM_IRQ_THR_4
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__EXTRACT() extracts TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_4
 * @return current value of TLM_IRQ_THR_4.TLM_IRQ_THR_SRC_SEL_4
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_THR_SRC_SEL_4__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4:

    Telemetry interrupt (IRQ) 4 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_4.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Pos        0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_4 in TLMCOM.TLM_IRQ_THR_4 */
#define TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Msk        (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Pos)     /*!< Mask for tlm_irq_gereric_thr_4 in TLMCOM.TLM_IRQ_THR_4 */
#define TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Pos) & TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_4 and mask 'v' to fit it into tlm_irq_gereric_thr_4 field */

/** TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__SET() sets TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4 to given value.
 *
 * When writing to TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_4__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_4__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__GET() gets TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4's current value.
 *
 * When reading from TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_4__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__MODIFY() modifies TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_4
 * @param bf_value new value for TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4
 * @return new value of TLMCOM.TLM_IRQ_THR_4
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__EXTRACT() extracts TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_4
 * @return current value of TLM_IRQ_THR_4.TLM_IRQ_GERERIC_THR_4
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_4__TLM_IRQ_GERERIC_THR_4__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_THR_5 member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_5__ADDRESS returns the address of member TLM_IRQ_THR_5.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_5
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_5__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_5)));
}

/** TLMCOM_TLM_IRQ_THR_5__SET() sets TLM_IRQ_THR_5 to given value.
 *
 * When writing to TLM_IRQ_THR_5, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_5
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_5__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_5__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_5__GET() gets TLM_IRQ_THR_5's current value.
 *
 * When reading from TLM_IRQ_THR_5, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_5
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_5__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_5__ADDRESS());
}

/* --------------- TLMCOM.TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5:

    Telemetry interrupt (IRQ) 5 source select.  Selects signal to compare agains tlm_irq_gereric_thr_5 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Pos        16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_5 in TLMCOM.TLM_IRQ_THR_5 */
#define TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Msk        (0x0000001FUL << TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Pos)     /*!< Mask for tlm_irq_thr_src_sel_5 in TLMCOM.TLM_IRQ_THR_5 */
#define TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Pos) & TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_5 and mask 'v' to fit it into tlm_irq_thr_src_sel_5 field */

/** TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__SET() sets TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5 to given value.
 *
 * When writing to TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_5__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_5__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__GET() gets TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5's current value.
 *
 * When reading from TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_5__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__MODIFY() modifies TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_5
 * @param bf_value new value for TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5
 * @return new value of TLMCOM.TLM_IRQ_THR_5
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__EXTRACT() extracts TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_5
 * @return current value of TLM_IRQ_THR_5.TLM_IRQ_THR_SRC_SEL_5
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_THR_SRC_SEL_5__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5:

    Telemetry interrupt (IRQ) 5 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_5.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Pos        0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_5 in TLMCOM.TLM_IRQ_THR_5 */
#define TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Msk        (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Pos)     /*!< Mask for tlm_irq_gereric_thr_5 in TLMCOM.TLM_IRQ_THR_5 */
#define TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Pos) & TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_5 and mask 'v' to fit it into tlm_irq_gereric_thr_5 field */

/** TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__SET() sets TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5 to given value.
 *
 * When writing to TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_5__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_5__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__GET() gets TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5's current value.
 *
 * When reading from TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_5__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__MODIFY() modifies TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_5
 * @param bf_value new value for TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5
 * @return new value of TLMCOM.TLM_IRQ_THR_5
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__EXTRACT() extracts TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_5
 * @return current value of TLM_IRQ_THR_5.TLM_IRQ_GERERIC_THR_5
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_5__TLM_IRQ_GERERIC_THR_5__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_THR_6 member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_6__ADDRESS returns the address of member TLM_IRQ_THR_6.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_6
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_6__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_6)));
}

/** TLMCOM_TLM_IRQ_THR_6__SET() sets TLM_IRQ_THR_6 to given value.
 *
 * When writing to TLM_IRQ_THR_6, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_6
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_6__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_6__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_6__GET() gets TLM_IRQ_THR_6's current value.
 *
 * When reading from TLM_IRQ_THR_6, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_6
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_6__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_6__ADDRESS());
}

/* --------------- TLMCOM.TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6:

    Telemetry interrupt (IRQ) 6 source select.  Selects signal to compare agains tlm_irq_gereric_thr_6 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Pos        16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_6 in TLMCOM.TLM_IRQ_THR_6 */
#define TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Msk        (0x0000001FUL << TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Pos)     /*!< Mask for tlm_irq_thr_src_sel_6 in TLMCOM.TLM_IRQ_THR_6 */
#define TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Pos) & TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_6 and mask 'v' to fit it into tlm_irq_thr_src_sel_6 field */

/** TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__SET() sets TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6 to given value.
 *
 * When writing to TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_6__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_6__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__GET() gets TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6's current value.
 *
 * When reading from TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_6__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__MODIFY() modifies TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_6.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_6
 * @param bf_value new value for TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6
 * @return new value of TLMCOM.TLM_IRQ_THR_6
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__EXTRACT() extracts TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_6.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_6
 * @return current value of TLM_IRQ_THR_6.TLM_IRQ_THR_SRC_SEL_6
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_THR_SRC_SEL_6__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6:

    Telemetry interrupt (IRQ) 6 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_6.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Pos        0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_6 in TLMCOM.TLM_IRQ_THR_6 */
#define TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Msk        (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Pos)     /*!< Mask for tlm_irq_gereric_thr_6 in TLMCOM.TLM_IRQ_THR_6 */
#define TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Pos) & TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_6 and mask 'v' to fit it into tlm_irq_gereric_thr_6 field */

/** TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__SET() sets TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6 to given value.
 *
 * When writing to TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_6__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_6__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__GET() gets TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6's current value.
 *
 * When reading from TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_6__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__MODIFY() modifies TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_6.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_6
 * @param bf_value new value for TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6
 * @return new value of TLMCOM.TLM_IRQ_THR_6
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__EXTRACT() extracts TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_6.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_6
 * @return current value of TLM_IRQ_THR_6.TLM_IRQ_GERERIC_THR_6
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_6__TLM_IRQ_GERERIC_THR_6__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_THR_7 member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_7__ADDRESS returns the address of member TLM_IRQ_THR_7.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_7
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_7__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_7)));
}

/** TLMCOM_TLM_IRQ_THR_7__SET() sets TLM_IRQ_THR_7 to given value.
 *
 * When writing to TLM_IRQ_THR_7, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_7
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_7__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_7__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_7__GET() gets TLM_IRQ_THR_7's current value.
 *
 * When reading from TLM_IRQ_THR_7, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_7
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_7__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_7__ADDRESS());
}

/* --------------- TLMCOM.TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7:

    Telemetry interrupt (IRQ) 7 source select.  Selects signal to compare agains tlm_irq_gereric_thr_7 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Pos        16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_7 in TLMCOM.TLM_IRQ_THR_7 */
#define TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Msk        (0x0000001FUL << TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Pos)     /*!< Mask for tlm_irq_thr_src_sel_7 in TLMCOM.TLM_IRQ_THR_7 */
#define TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Pos) & TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_7 and mask 'v' to fit it into tlm_irq_thr_src_sel_7 field */

/** TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__SET() sets TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7 to given value.
 *
 * When writing to TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_7__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_7__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__GET() gets TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7's current value.
 *
 * When reading from TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_7__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__MODIFY() modifies TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_7.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_7
 * @param bf_value new value for TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7
 * @return new value of TLMCOM.TLM_IRQ_THR_7
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__EXTRACT() extracts TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_7.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_7
 * @return current value of TLM_IRQ_THR_7.TLM_IRQ_THR_SRC_SEL_7
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_THR_SRC_SEL_7__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7:

    Telemetry interrupt (IRQ) 7 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_7.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Pos        0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_7 in TLMCOM.TLM_IRQ_THR_7 */
#define TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Msk        (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Pos)     /*!< Mask for tlm_irq_gereric_thr_7 in TLMCOM.TLM_IRQ_THR_7 */
#define TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Pos) & TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_7 and mask 'v' to fit it into tlm_irq_gereric_thr_7 field */

/** TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__SET() sets TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7 to given value.
 *
 * When writing to TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_7__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_7__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__GET() gets TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7's current value.
 *
 * When reading from TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_7__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__MODIFY() modifies TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_7.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_7
 * @param bf_value new value for TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7
 * @return new value of TLMCOM.TLM_IRQ_THR_7
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__EXTRACT() extracts TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_7.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_7
 * @return current value of TLM_IRQ_THR_7.TLM_IRQ_GERERIC_THR_7
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_7__TLM_IRQ_GERERIC_THR_7__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_THR_8 member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_8__ADDRESS returns the address of member TLM_IRQ_THR_8.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_8
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_8__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_8)));
}

/** TLMCOM_TLM_IRQ_THR_8__SET() sets TLM_IRQ_THR_8 to given value.
 *
 * When writing to TLM_IRQ_THR_8, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_8
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_8__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_8__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_8__GET() gets TLM_IRQ_THR_8's current value.
 *
 * When reading from TLM_IRQ_THR_8, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_8
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_8__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_8__ADDRESS());
}

/* --------------- TLMCOM.TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8:

    Telemetry interrupt (IRQ) 8 source select.  Selects signal to compare agains tlm_irq_gereric_thr_8 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Pos        16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_8 in TLMCOM.TLM_IRQ_THR_8 */
#define TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Msk        (0x0000001FUL << TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Pos)     /*!< Mask for tlm_irq_thr_src_sel_8 in TLMCOM.TLM_IRQ_THR_8 */
#define TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Pos) & TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_8 and mask 'v' to fit it into tlm_irq_thr_src_sel_8 field */

/** TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__SET() sets TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8 to given value.
 *
 * When writing to TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_8__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_8__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__GET() gets TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8's current value.
 *
 * When reading from TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_8__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__MODIFY() modifies TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_8.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_8
 * @param bf_value new value for TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8
 * @return new value of TLMCOM.TLM_IRQ_THR_8
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__EXTRACT() extracts TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_8.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_8
 * @return current value of TLM_IRQ_THR_8.TLM_IRQ_THR_SRC_SEL_8
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_THR_SRC_SEL_8__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8:

    Telemetry interrupt (IRQ) 8 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_8.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Pos        0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_8 in TLMCOM.TLM_IRQ_THR_8 */
#define TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Msk        (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Pos)     /*!< Mask for tlm_irq_gereric_thr_8 in TLMCOM.TLM_IRQ_THR_8 */
#define TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Pos) & TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_8 and mask 'v' to fit it into tlm_irq_gereric_thr_8 field */

/** TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__SET() sets TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8 to given value.
 *
 * When writing to TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_8__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_8__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__GET() gets TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8's current value.
 *
 * When reading from TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_8__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__MODIFY() modifies TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_8.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_8
 * @param bf_value new value for TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8
 * @return new value of TLMCOM.TLM_IRQ_THR_8
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__EXTRACT() extracts TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_8.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_8
 * @return current value of TLM_IRQ_THR_8.TLM_IRQ_GERERIC_THR_8
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_8__TLM_IRQ_GERERIC_THR_8__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_THR_9 member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_9__ADDRESS returns the address of member TLM_IRQ_THR_9.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_9
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_9__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_9)));
}

/** TLMCOM_TLM_IRQ_THR_9__SET() sets TLM_IRQ_THR_9 to given value.
 *
 * When writing to TLM_IRQ_THR_9, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_9
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_9__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_9__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_9__GET() gets TLM_IRQ_THR_9's current value.
 *
 * When reading from TLM_IRQ_THR_9, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_9
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_9__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_9__ADDRESS());
}

/* --------------- TLMCOM.TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9:

    Telemetry interrupt (IRQ) 9 source select.  Selects signal to compare agains tlm_irq_gereric_thr_9 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Pos        16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_9 in TLMCOM.TLM_IRQ_THR_9 */
#define TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Msk        (0x0000001FUL << TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Pos)     /*!< Mask for tlm_irq_thr_src_sel_9 in TLMCOM.TLM_IRQ_THR_9 */
#define TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Pos) & TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_9 and mask 'v' to fit it into tlm_irq_thr_src_sel_9 field */

/** TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__SET() sets TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9 to given value.
 *
 * When writing to TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_9__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_9__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__GET() gets TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9's current value.
 *
 * When reading from TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_9__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__MODIFY() modifies TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_9.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_9
 * @param bf_value new value for TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9
 * @return new value of TLMCOM.TLM_IRQ_THR_9
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__EXTRACT() extracts TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_9.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_9
 * @return current value of TLM_IRQ_THR_9.TLM_IRQ_THR_SRC_SEL_9
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_THR_SRC_SEL_9__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9 --------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9:

    Telemetry interrupt (IRQ) 9 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_9.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Pos        0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_9 in TLMCOM.TLM_IRQ_THR_9 */
#define TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Msk        (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Pos)     /*!< Mask for tlm_irq_gereric_thr_9 in TLMCOM.TLM_IRQ_THR_9 */
#define TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Shift(v)   (((v) << TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Pos) & TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_9 and mask 'v' to fit it into tlm_irq_gereric_thr_9 field */

/** TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__SET() sets TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9 to given value.
 *
 * When writing to TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_9__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_9__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__GET() gets TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9's current value.
 *
 * When reading from TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_9__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__MODIFY() modifies TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_9.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_9
 * @param bf_value new value for TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9
 * @return new value of TLMCOM.TLM_IRQ_THR_9
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__EXTRACT() extracts TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_9.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_9
 * @return current value of TLM_IRQ_THR_9.TLM_IRQ_GERERIC_THR_9
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_9__TLM_IRQ_GERERIC_THR_9__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     TLM_IRQ_THR_10 member of TLMCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_10__ADDRESS returns the address of member TLM_IRQ_THR_10.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_10
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_10__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_10)));
}

/** TLMCOM_TLM_IRQ_THR_10__SET() sets TLM_IRQ_THR_10 to given value.
 *
 * When writing to TLM_IRQ_THR_10, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_10
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_10__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_10__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_10__GET() gets TLM_IRQ_THR_10's current value.
 *
 * When reading from TLM_IRQ_THR_10, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_10
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_10__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_10__ADDRESS());
}

/* -------------- TLMCOM.TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10:

    Telemetry interrupt (IRQ) 10 source select.  Selects signal to compare agains tlm_irq_gereric_thr_10 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Pos      16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_10 in TLMCOM.TLM_IRQ_THR_10 */
#define TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Msk      (0x0000001FUL << TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Pos)   /*!< Mask for tlm_irq_thr_src_sel_10 in TLMCOM.TLM_IRQ_THR_10 */
#define TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Pos) & TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_10 and mask 'v' to fit it into tlm_irq_thr_src_sel_10 field */

/** TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__SET() sets TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10 to given value.
 *
 * When writing to TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_10__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_10__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__GET() gets TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10's current value.
 *
 * When reading from TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_10__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__MODIFY() modifies TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_10.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_10
 * @param bf_value new value for TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10
 * @return new value of TLMCOM.TLM_IRQ_THR_10
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__EXTRACT() extracts TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_10.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_10
 * @return current value of TLM_IRQ_THR_10.TLM_IRQ_THR_SRC_SEL_10
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_THR_SRC_SEL_10__Pos);
    return (uint32_t)reg;
}

/* -------------- TLMCOM.TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10:

    Telemetry interrupt (IRQ) 10 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_10.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Pos      0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_10 in TLMCOM.TLM_IRQ_THR_10 */
#define TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Msk      (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Pos)   /*!< Mask for tlm_irq_gereric_thr_10 in TLMCOM.TLM_IRQ_THR_10 */
#define TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Pos) & TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_10 and mask 'v' to fit it into tlm_irq_gereric_thr_10 field */

/** TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__SET() sets TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10 to given value.
 *
 * When writing to TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_10__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_10__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__GET() gets TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10's current value.
 *
 * When reading from TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_10__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__MODIFY() modifies TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_10.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_10
 * @param bf_value new value for TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10
 * @return new value of TLMCOM.TLM_IRQ_THR_10
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__EXTRACT() extracts TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_10.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_10
 * @return current value of TLM_IRQ_THR_10.TLM_IRQ_GERERIC_THR_10
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_10__TLM_IRQ_GERERIC_THR_10__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     TLM_IRQ_THR_11 member of TLMCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_11__ADDRESS returns the address of member TLM_IRQ_THR_11.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_11
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_11__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_11)));
}

/** TLMCOM_TLM_IRQ_THR_11__SET() sets TLM_IRQ_THR_11 to given value.
 *
 * When writing to TLM_IRQ_THR_11, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_11
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_11__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_11__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_11__GET() gets TLM_IRQ_THR_11's current value.
 *
 * When reading from TLM_IRQ_THR_11, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_11
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_11__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_11__ADDRESS());
}

/* -------------- TLMCOM.TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11:

    Telemetry interrupt (IRQ) 11 source select.  Selects signal to compare agains tlm_irq_gereric_thr_11 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Pos      16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_11 in TLMCOM.TLM_IRQ_THR_11 */
#define TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Msk      (0x0000001FUL << TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Pos)   /*!< Mask for tlm_irq_thr_src_sel_11 in TLMCOM.TLM_IRQ_THR_11 */
#define TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Pos) & TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_11 and mask 'v' to fit it into tlm_irq_thr_src_sel_11 field */

/** TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__SET() sets TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11 to given value.
 *
 * When writing to TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_11__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_11__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__GET() gets TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11's current value.
 *
 * When reading from TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_11__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__MODIFY() modifies TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_11.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_11
 * @param bf_value new value for TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11
 * @return new value of TLMCOM.TLM_IRQ_THR_11
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__EXTRACT() extracts TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_11.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_11
 * @return current value of TLM_IRQ_THR_11.TLM_IRQ_THR_SRC_SEL_11
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_THR_SRC_SEL_11__Pos);
    return (uint32_t)reg;
}

/* -------------- TLMCOM.TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11:

    Telemetry interrupt (IRQ) 11 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_11.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Pos      0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_11 in TLMCOM.TLM_IRQ_THR_11 */
#define TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Msk      (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Pos)   /*!< Mask for tlm_irq_gereric_thr_11 in TLMCOM.TLM_IRQ_THR_11 */
#define TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Pos) & TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_11 and mask 'v' to fit it into tlm_irq_gereric_thr_11 field */

/** TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__SET() sets TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11 to given value.
 *
 * When writing to TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_11__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_11__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__GET() gets TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11's current value.
 *
 * When reading from TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_11__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__MODIFY() modifies TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_11.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_11
 * @param bf_value new value for TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11
 * @return new value of TLMCOM.TLM_IRQ_THR_11
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__EXTRACT() extracts TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_11.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_11
 * @return current value of TLM_IRQ_THR_11.TLM_IRQ_GERERIC_THR_11
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_11__TLM_IRQ_GERERIC_THR_11__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     TLM_IRQ_THR_12 member of TLMCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_12__ADDRESS returns the address of member TLM_IRQ_THR_12.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_12
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_12__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_12)));
}

/** TLMCOM_TLM_IRQ_THR_12__SET() sets TLM_IRQ_THR_12 to given value.
 *
 * When writing to TLM_IRQ_THR_12, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_12
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_12__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_12__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_12__GET() gets TLM_IRQ_THR_12's current value.
 *
 * When reading from TLM_IRQ_THR_12, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_12
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_12__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_12__ADDRESS());
}

/* -------------- TLMCOM.TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12:

    Telemetry interrupt (IRQ) 12 source select.  Selects signal to compare agains tlm_irq_gereric_thr_12 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Pos      16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_12 in TLMCOM.TLM_IRQ_THR_12 */
#define TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Msk      (0x0000001FUL << TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Pos)   /*!< Mask for tlm_irq_thr_src_sel_12 in TLMCOM.TLM_IRQ_THR_12 */
#define TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Pos) & TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_12 and mask 'v' to fit it into tlm_irq_thr_src_sel_12 field */

/** TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__SET() sets TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12 to given value.
 *
 * When writing to TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_12__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_12__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__GET() gets TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12's current value.
 *
 * When reading from TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_12__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__MODIFY() modifies TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_12.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_12
 * @param bf_value new value for TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12
 * @return new value of TLMCOM.TLM_IRQ_THR_12
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__EXTRACT() extracts TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_12.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_12
 * @return current value of TLM_IRQ_THR_12.TLM_IRQ_THR_SRC_SEL_12
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_THR_SRC_SEL_12__Pos);
    return (uint32_t)reg;
}

/* -------------- TLMCOM.TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12:

    Telemetry interrupt (IRQ) 12 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_12.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Pos      0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_12 in TLMCOM.TLM_IRQ_THR_12 */
#define TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Msk      (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Pos)   /*!< Mask for tlm_irq_gereric_thr_12 in TLMCOM.TLM_IRQ_THR_12 */
#define TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Pos) & TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_12 and mask 'v' to fit it into tlm_irq_gereric_thr_12 field */

/** TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__SET() sets TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12 to given value.
 *
 * When writing to TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_12__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_12__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__GET() gets TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12's current value.
 *
 * When reading from TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_12__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__MODIFY() modifies TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_12.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_12
 * @param bf_value new value for TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12
 * @return new value of TLMCOM.TLM_IRQ_THR_12
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__EXTRACT() extracts TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_12.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_12
 * @return current value of TLM_IRQ_THR_12.TLM_IRQ_GERERIC_THR_12
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_12__TLM_IRQ_GERERIC_THR_12__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     TLM_IRQ_THR_13 member of TLMCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_13__ADDRESS returns the address of member TLM_IRQ_THR_13.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_13
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_13__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_13)));
}

/** TLMCOM_TLM_IRQ_THR_13__SET() sets TLM_IRQ_THR_13 to given value.
 *
 * When writing to TLM_IRQ_THR_13, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_13
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_13__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_13__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_13__GET() gets TLM_IRQ_THR_13's current value.
 *
 * When reading from TLM_IRQ_THR_13, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_13
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_13__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_13__ADDRESS());
}

/* -------------- TLMCOM.TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13:

    Telemetry interrupt (IRQ) 13 source select.  Selects signal to compare agains tlm_irq_gereric_thr_13 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Pos      16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_13 in TLMCOM.TLM_IRQ_THR_13 */
#define TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Msk      (0x0000001FUL << TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Pos)   /*!< Mask for tlm_irq_thr_src_sel_13 in TLMCOM.TLM_IRQ_THR_13 */
#define TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Pos) & TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_13 and mask 'v' to fit it into tlm_irq_thr_src_sel_13 field */

/** TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__SET() sets TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13 to given value.
 *
 * When writing to TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_13__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_13__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__GET() gets TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13's current value.
 *
 * When reading from TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_13__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__MODIFY() modifies TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_13.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_13
 * @param bf_value new value for TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13
 * @return new value of TLMCOM.TLM_IRQ_THR_13
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__EXTRACT() extracts TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_13.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_13
 * @return current value of TLM_IRQ_THR_13.TLM_IRQ_THR_SRC_SEL_13
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_THR_SRC_SEL_13__Pos);
    return (uint32_t)reg;
}

/* -------------- TLMCOM.TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13:

    Telemetry interrupt (IRQ) 13 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_13.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Pos      0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_13 in TLMCOM.TLM_IRQ_THR_13 */
#define TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Msk      (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Pos)   /*!< Mask for tlm_irq_gereric_thr_13 in TLMCOM.TLM_IRQ_THR_13 */
#define TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Pos) & TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_13 and mask 'v' to fit it into tlm_irq_gereric_thr_13 field */

/** TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__SET() sets TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13 to given value.
 *
 * When writing to TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_13__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_13__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__GET() gets TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13's current value.
 *
 * When reading from TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_13__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__MODIFY() modifies TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_13.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_13
 * @param bf_value new value for TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13
 * @return new value of TLMCOM.TLM_IRQ_THR_13
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__EXTRACT() extracts TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_13.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_13
 * @return current value of TLM_IRQ_THR_13.TLM_IRQ_GERERIC_THR_13
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_13__TLM_IRQ_GERERIC_THR_13__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     TLM_IRQ_THR_14 member of TLMCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_14__ADDRESS returns the address of member TLM_IRQ_THR_14.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_14
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_14__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_14)));
}

/** TLMCOM_TLM_IRQ_THR_14__SET() sets TLM_IRQ_THR_14 to given value.
 *
 * When writing to TLM_IRQ_THR_14, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_14
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_14__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_14__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_14__GET() gets TLM_IRQ_THR_14's current value.
 *
 * When reading from TLM_IRQ_THR_14, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_14
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_14__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_14__ADDRESS());
}

/* -------------- TLMCOM.TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14:

    Telemetry interrupt (IRQ) 14 source select.  Selects signal to compare agains tlm_irq_gereric_thr_14 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Pos      16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_14 in TLMCOM.TLM_IRQ_THR_14 */
#define TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Msk      (0x0000001FUL << TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Pos)   /*!< Mask for tlm_irq_thr_src_sel_14 in TLMCOM.TLM_IRQ_THR_14 */
#define TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Pos) & TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_14 and mask 'v' to fit it into tlm_irq_thr_src_sel_14 field */

/** TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__SET() sets TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14 to given value.
 *
 * When writing to TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_14__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_14__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__GET() gets TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14's current value.
 *
 * When reading from TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_14__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__MODIFY() modifies TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_14.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_14
 * @param bf_value new value for TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14
 * @return new value of TLMCOM.TLM_IRQ_THR_14
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__EXTRACT() extracts TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_14.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_14
 * @return current value of TLM_IRQ_THR_14.TLM_IRQ_THR_SRC_SEL_14
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_THR_SRC_SEL_14__Pos);
    return (uint32_t)reg;
}

/* -------------- TLMCOM.TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14:

    Telemetry interrupt (IRQ) 14 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_14.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Pos      0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_14 in TLMCOM.TLM_IRQ_THR_14 */
#define TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Msk      (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Pos)   /*!< Mask for tlm_irq_gereric_thr_14 in TLMCOM.TLM_IRQ_THR_14 */
#define TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Pos) & TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_14 and mask 'v' to fit it into tlm_irq_gereric_thr_14 field */

/** TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__SET() sets TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14 to given value.
 *
 * When writing to TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_14__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_14__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__GET() gets TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14's current value.
 *
 * When reading from TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_14__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__MODIFY() modifies TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_14.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_14
 * @param bf_value new value for TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14
 * @return new value of TLMCOM.TLM_IRQ_THR_14
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__EXTRACT() extracts TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_14.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_14
 * @return current value of TLM_IRQ_THR_14.TLM_IRQ_GERERIC_THR_14
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_14__TLM_IRQ_GERERIC_THR_14__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     TLM_IRQ_THR_15 member of TLMCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_THR_15__ADDRESS returns the address of member TLM_IRQ_THR_15.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_THR_15
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_THR_15__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_THR_15)));
}

/** TLMCOM_TLM_IRQ_THR_15__SET() sets TLM_IRQ_THR_15 to given value.
 *
 * When writing to TLM_IRQ_THR_15, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_THR_15
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_15__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_THR_15__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_THR_15__GET() gets TLM_IRQ_THR_15's current value.
 *
 * When reading from TLM_IRQ_THR_15, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_THR_15
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_15__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_THR_15__ADDRESS());
}

/* -------------- TLMCOM.TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15:

    Telemetry interrupt (IRQ) 15 source select.  Selects signal to compare agains tlm_irq_gereric_thr_15 for IRQ generation.
    <start table_with_header>
    [4:0] Interrupt [4:0] Interrupt
    0 "Loop 0 IOUT" 1 "Loop 1 IOUT"
    2 "Loop 0 VOUT" 3 "Loop 1 VOUT"
    4 "Loop 0 IIN" 5 "Loop 1 IIN"
    6 "Loop 0 VIN" 7 "Loop 1 VIN"
    8 "Loop 0 DUTY" 9 "Loop 1 DUTY"
    10 "Loop 0 FSW" 11 "Loop 1 FSW"
    12 "ATSEN" 13 "BTSEN"
    14 "Internal Temp" 15 "IMON"
    16 "PRISEN" 17 "XADDR1"
    18 "XADDR2" 19-31 Unused
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Pos      16                                                                     /*!< Right-most bit position of tlm_irq_thr_src_sel_15 in TLMCOM.TLM_IRQ_THR_15 */
#define TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Msk      (0x0000001FUL << TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Pos)   /*!< Mask for tlm_irq_thr_src_sel_15 in TLMCOM.TLM_IRQ_THR_15 */
#define TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Pos) & TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Msk) /*!< Shift value 'v' into tlm_irq_thr_src_sel_15 and mask 'v' to fit it into tlm_irq_thr_src_sel_15 field */

/** TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__SET() sets TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15 to given value.
 *
 * When writing to TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_15__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_15__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__GET() gets TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15's current value.
 *
 * When reading from TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_15__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__MODIFY() modifies TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_15.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_15
 * @param bf_value new value for TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15
 * @return new value of TLMCOM.TLM_IRQ_THR_15
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__EXTRACT() extracts TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_15.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_15
 * @return current value of TLM_IRQ_THR_15.TLM_IRQ_THR_SRC_SEL_15
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_THR_SRC_SEL_15__Pos);
    return (uint32_t)reg;
}

/* -------------- TLMCOM.TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15 -------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15:

    Telemetry interrupt (IRQ) 15 threshold.  Compared against signal selected by tlm_irq_thr_src_sel_15.  Format based on selected source.
    <start table_with_header>
    Source Format
    IOUT "signed, LSB = 62.5mA, Range = -256 to +255.9375A"
    VOUT "unsigned, LSB = 156.25uV, Range = 0.0 to 5.11984375V"
    IIN "unsigned, LSB = 7.8125mA, Range = 0.0 to 63.9922A"
    VIN "unsigned, LSB = 62.5mV, Range = 0.0 to 127.9375V"
    DUTY "unsigned, LSB = 2^-16, Range = 0.0 to 0.99998"
    FSW "unsigned, LSB = 1 kHz, Range = 0 to 2047 kHz"
    "ATSEN, BTSEN, ITSEN" "unsigned, LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes"
    "IMON, PRISEN, XADDR1, XADDR2" "unsigned, LSB = 0.0625 ADC Code, Range = 0.0 to 1023.9375 ADC Codes"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Pos      0                                                                      /*!< Right-most bit position of tlm_irq_gereric_thr_15 in TLMCOM.TLM_IRQ_THR_15 */
#define TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Msk      (0x0000FFFFUL << TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Pos)   /*!< Mask for tlm_irq_gereric_thr_15 in TLMCOM.TLM_IRQ_THR_15 */
#define TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Shift(v) (((v) << TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Pos) & TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Msk) /*!< Shift value 'v' into tlm_irq_gereric_thr_15 and mask 'v' to fit it into tlm_irq_gereric_thr_15 field */

/** TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__SET() sets TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15 to given value.
 *
 * When writing to TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_15__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_THR_15__SET(reg);
}

/** TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__GET() gets TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15's current value.
 *
 * When reading from TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15, this is recommended to use.
 *
 * @return current value of TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_THR_15__GET();
    reg = (reg & TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__MODIFY() modifies TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_THR_15.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_15
 * @param bf_value new value for TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15
 * @return new value of TLMCOM.TLM_IRQ_THR_15
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__EXTRACT() extracts TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_THR_15.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_THR_15
 * @return current value of TLM_IRQ_THR_15.TLM_IRQ_GERERIC_THR_15
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_THR_15__TLM_IRQ_GERERIC_THR_15__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_ATSEN_LPF member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_ATSEN_LPF__ADDRESS returns the address of member TLM_ATSEN_LPF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_ATSEN_LPF
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_ATSEN_LPF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_ATSEN_LPF)));
}

/** TLMCOM_TLM_ATSEN_LPF__GET() gets TLM_ATSEN_LPF's current value.
 *
 * When reading from TLM_ATSEN_LPF, this is mandatory to use.
 *
 * @return current value of TLM_ATSEN_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ATSEN_LPF__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_ATSEN_LPF__ADDRESS());
}

/* ------------------- TLMCOM.TLM_ATSEN_LPF.TLM_ATSEN_LPF ------------------- */

/**
<pre>
  TLMCOM.TLM_ATSEN_LPF.TLM_ATSEN_LPF:

    Low pass filtered ATSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW.
    LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes

</pre> */

#define TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__Pos                0                                                                      /*!< Right-most bit position of tlm_atsen_lpf in TLMCOM.TLM_ATSEN_LPF */
#define TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__Msk                (0x000003FFUL << TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__Pos)             /*!< Mask for tlm_atsen_lpf in TLMCOM.TLM_ATSEN_LPF */
#define TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__Shift(v)           (((v) << TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__Pos) & TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__Msk) /*!< Shift value 'v' into tlm_atsen_lpf and mask 'v' to fit it into tlm_atsen_lpf field */

/** TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__GET() gets TLM_ATSEN_LPF.TLM_ATSEN_LPF's current value.
 *
 * When reading from TLM_ATSEN_LPF.TLM_ATSEN_LPF, this is recommended to use.
 *
 * @return current value of TLM_ATSEN_LPF.TLM_ATSEN_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__GET(void)
{
    uint32_t reg = TLMCOM_TLM_ATSEN_LPF__GET();
    reg = (reg & TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__EXTRACT() extracts TLM_ATSEN_LPF.TLM_ATSEN_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_ATSEN_LPF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_ATSEN_LPF
 * @return current value of TLM_ATSEN_LPF.TLM_ATSEN_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_ATSEN_LPF__TLM_ATSEN_LPF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_ATSEN_FS member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_ATSEN_FS__ADDRESS returns the address of member TLM_ATSEN_FS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_ATSEN_FS
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_ATSEN_FS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_ATSEN_FS)));
}

/** TLMCOM_TLM_ATSEN_FS__GET() gets TLM_ATSEN_FS's current value.
 *
 * When reading from TLM_ATSEN_FS, this is mandatory to use.
 *
 * @return current value of TLM_ATSEN_FS
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ATSEN_FS__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_ATSEN_FS__ADDRESS());
}

/* -------------------- TLMCOM.TLM_ATSEN_FS.TLM_ATSEN_FS -------------------- */

/**
<pre>
  TLMCOM.TLM_ATSEN_FS.TLM_ATSEN_FS:

    Unfiltered ATSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW.
    LSB = 0.25 ADC Code, Range = 0 to 1023.75 ADC Codes

</pre> */

#define TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__Pos                  0                                                                      /*!< Right-most bit position of tlm_atsen_fs in TLMCOM.TLM_ATSEN_FS */
#define TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__Msk                  (0x00000FFFUL << TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__Pos)               /*!< Mask for tlm_atsen_fs in TLMCOM.TLM_ATSEN_FS */
#define TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__Shift(v)             (((v) << TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__Pos) & TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__Msk) /*!< Shift value 'v' into tlm_atsen_fs and mask 'v' to fit it into tlm_atsen_fs field */

/** TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__GET() gets TLM_ATSEN_FS.TLM_ATSEN_FS's current value.
 *
 * When reading from TLM_ATSEN_FS.TLM_ATSEN_FS, this is recommended to use.
 *
 * @return current value of TLM_ATSEN_FS.TLM_ATSEN_FS
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__GET(void)
{
    uint32_t reg = TLMCOM_TLM_ATSEN_FS__GET();
    reg = (reg & TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__Msk);
    reg = (reg >> TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__EXTRACT() extracts TLM_ATSEN_FS.TLM_ATSEN_FS.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_ATSEN_FS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_ATSEN_FS
 * @return current value of TLM_ATSEN_FS.TLM_ATSEN_FS
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__Msk);
    reg = (reg >> TLMCOM_TLM_ATSEN_FS__TLM_ATSEN_FS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_BTSEN_LPF member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_BTSEN_LPF__ADDRESS returns the address of member TLM_BTSEN_LPF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_BTSEN_LPF
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_BTSEN_LPF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_BTSEN_LPF)));
}

/** TLMCOM_TLM_BTSEN_LPF__GET() gets TLM_BTSEN_LPF's current value.
 *
 * When reading from TLM_BTSEN_LPF, this is mandatory to use.
 *
 * @return current value of TLM_BTSEN_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_BTSEN_LPF__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_BTSEN_LPF__ADDRESS());
}

/* ------------------- TLMCOM.TLM_BTSEN_LPF.TLM_BTSEN_LPF ------------------- */

/**
<pre>
  TLMCOM.TLM_BTSEN_LPF.TLM_BTSEN_LPF:

    Low pass filtered BTSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW.
    LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes

</pre> */

#define TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__Pos                0                                                                      /*!< Right-most bit position of tlm_btsen_lpf in TLMCOM.TLM_BTSEN_LPF */
#define TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__Msk                (0x000003FFUL << TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__Pos)             /*!< Mask for tlm_btsen_lpf in TLMCOM.TLM_BTSEN_LPF */
#define TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__Shift(v)           (((v) << TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__Pos) & TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__Msk) /*!< Shift value 'v' into tlm_btsen_lpf and mask 'v' to fit it into tlm_btsen_lpf field */

/** TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__GET() gets TLM_BTSEN_LPF.TLM_BTSEN_LPF's current value.
 *
 * When reading from TLM_BTSEN_LPF.TLM_BTSEN_LPF, this is recommended to use.
 *
 * @return current value of TLM_BTSEN_LPF.TLM_BTSEN_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__GET(void)
{
    uint32_t reg = TLMCOM_TLM_BTSEN_LPF__GET();
    reg = (reg & TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__EXTRACT() extracts TLM_BTSEN_LPF.TLM_BTSEN_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_BTSEN_LPF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_BTSEN_LPF
 * @return current value of TLM_BTSEN_LPF.TLM_BTSEN_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_BTSEN_LPF__TLM_BTSEN_LPF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_BTSEN_FS member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_BTSEN_FS__ADDRESS returns the address of member TLM_BTSEN_FS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_BTSEN_FS
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_BTSEN_FS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_BTSEN_FS)));
}

/** TLMCOM_TLM_BTSEN_FS__GET() gets TLM_BTSEN_FS's current value.
 *
 * When reading from TLM_BTSEN_FS, this is mandatory to use.
 *
 * @return current value of TLM_BTSEN_FS
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_BTSEN_FS__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_BTSEN_FS__ADDRESS());
}

/* -------------------- TLMCOM.TLM_BTSEN_FS.TLM_BTSEN_FS -------------------- */

/**
<pre>
  TLMCOM.TLM_BTSEN_FS.TLM_BTSEN_FS:

    Unfiltered BTSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW.
    LSB = 0.25 ADC Code, Range = 0 to 1023.75 ADC Codes

</pre> */

#define TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__Pos                  0                                                                      /*!< Right-most bit position of tlm_btsen_fs in TLMCOM.TLM_BTSEN_FS */
#define TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__Msk                  (0x00000FFFUL << TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__Pos)               /*!< Mask for tlm_btsen_fs in TLMCOM.TLM_BTSEN_FS */
#define TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__Shift(v)             (((v) << TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__Pos) & TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__Msk) /*!< Shift value 'v' into tlm_btsen_fs and mask 'v' to fit it into tlm_btsen_fs field */

/** TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__GET() gets TLM_BTSEN_FS.TLM_BTSEN_FS's current value.
 *
 * When reading from TLM_BTSEN_FS.TLM_BTSEN_FS, this is recommended to use.
 *
 * @return current value of TLM_BTSEN_FS.TLM_BTSEN_FS
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__GET(void)
{
    uint32_t reg = TLMCOM_TLM_BTSEN_FS__GET();
    reg = (reg & TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__Msk);
    reg = (reg >> TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__EXTRACT() extracts TLM_BTSEN_FS.TLM_BTSEN_FS.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_BTSEN_FS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_BTSEN_FS
 * @return current value of TLM_BTSEN_FS.TLM_BTSEN_FS
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__Msk);
    reg = (reg >> TLMCOM_TLM_BTSEN_FS__TLM_BTSEN_FS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_ITSEN_LPF member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_ITSEN_LPF__ADDRESS returns the address of member TLM_ITSEN_LPF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_ITSEN_LPF
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_ITSEN_LPF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_ITSEN_LPF)));
}

/** TLMCOM_TLM_ITSEN_LPF__GET() gets TLM_ITSEN_LPF's current value.
 *
 * When reading from TLM_ITSEN_LPF, this is mandatory to use.
 *
 * @return current value of TLM_ITSEN_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ITSEN_LPF__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_ITSEN_LPF__ADDRESS());
}

/* ------------------- TLMCOM.TLM_ITSEN_LPF.TLM_ITSEN_LPF ------------------- */

/**
<pre>
  TLMCOM.TLM_ITSEN_LPF.TLM_ITSEN_LPF:

    Low pass filtered ITSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW.
    LSB = 1 ADC Code, Range = 0 to 1023 ADC Codes

</pre> */

#define TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__Pos                0                                                                      /*!< Right-most bit position of tlm_itsen_lpf in TLMCOM.TLM_ITSEN_LPF */
#define TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__Msk                (0x000003FFUL << TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__Pos)             /*!< Mask for tlm_itsen_lpf in TLMCOM.TLM_ITSEN_LPF */
#define TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__Shift(v)           (((v) << TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__Pos) & TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__Msk) /*!< Shift value 'v' into tlm_itsen_lpf and mask 'v' to fit it into tlm_itsen_lpf field */

/** TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__GET() gets TLM_ITSEN_LPF.TLM_ITSEN_LPF's current value.
 *
 * When reading from TLM_ITSEN_LPF.TLM_ITSEN_LPF, this is recommended to use.
 *
 * @return current value of TLM_ITSEN_LPF.TLM_ITSEN_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__GET(void)
{
    uint32_t reg = TLMCOM_TLM_ITSEN_LPF__GET();
    reg = (reg & TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__EXTRACT() extracts TLM_ITSEN_LPF.TLM_ITSEN_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_ITSEN_LPF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_ITSEN_LPF
 * @return current value of TLM_ITSEN_LPF.TLM_ITSEN_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_ITSEN_LPF__TLM_ITSEN_LPF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_ITSEN_FS member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_ITSEN_FS__ADDRESS returns the address of member TLM_ITSEN_FS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_ITSEN_FS
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_ITSEN_FS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_ITSEN_FS)));
}

/** TLMCOM_TLM_ITSEN_FS__GET() gets TLM_ITSEN_FS's current value.
 *
 * When reading from TLM_ITSEN_FS, this is mandatory to use.
 *
 * @return current value of TLM_ITSEN_FS
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ITSEN_FS__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_ITSEN_FS__ADDRESS());
}

/* -------------------- TLMCOM.TLM_ITSEN_FS.TLM_ITSEN_FS -------------------- */

/**
<pre>
  TLMCOM.TLM_ITSEN_FS.TLM_ITSEN_FS:

    Unfiltered ITSEN telemetry output.  Note that the format of this register is ADC codes.  The ADC Code to Temperature conversion is implemented in FW.
    LSB = 0.25 ADC Code, Range = 0 to 1023.75 ADC Codes

</pre> */

#define TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__Pos                  0                                                                      /*!< Right-most bit position of tlm_itsen_fs in TLMCOM.TLM_ITSEN_FS */
#define TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__Msk                  (0x00000FFFUL << TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__Pos)               /*!< Mask for tlm_itsen_fs in TLMCOM.TLM_ITSEN_FS */
#define TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__Shift(v)             (((v) << TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__Pos) & TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__Msk) /*!< Shift value 'v' into tlm_itsen_fs and mask 'v' to fit it into tlm_itsen_fs field */

/** TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__GET() gets TLM_ITSEN_FS.TLM_ITSEN_FS's current value.
 *
 * When reading from TLM_ITSEN_FS.TLM_ITSEN_FS, this is recommended to use.
 *
 * @return current value of TLM_ITSEN_FS.TLM_ITSEN_FS
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__GET(void)
{
    uint32_t reg = TLMCOM_TLM_ITSEN_FS__GET();
    reg = (reg & TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__Msk);
    reg = (reg >> TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__EXTRACT() extracts TLM_ITSEN_FS.TLM_ITSEN_FS.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_ITSEN_FS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_ITSEN_FS
 * @return current value of TLM_ITSEN_FS.TLM_ITSEN_FS
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__Msk);
    reg = (reg >> TLMCOM_TLM_ITSEN_FS__TLM_ITSEN_FS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    TLM_IRQ_POLARITY member of TLMCOM_t                    */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_POLARITY__ADDRESS returns the address of member TLM_IRQ_POLARITY.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_POLARITY
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_POLARITY__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_POLARITY)));
}

/** TLMCOM_TLM_IRQ_POLARITY__SET() sets TLM_IRQ_POLARITY to given value.
 *
 * When writing to TLM_IRQ_POLARITY, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_POLARITY
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_POLARITY__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_POLARITY__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_POLARITY__GET() gets TLM_IRQ_POLARITY's current value.
 *
 * When reading from TLM_IRQ_POLARITY, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_POLARITY
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_POLARITY__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_POLARITY__ADDRESS());
}

/* ---------------- TLMCOM.TLM_IRQ_POLARITY.TLM_IRQ_POLARITY ---------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_POLARITY.TLM_IRQ_POLARITY:

    Telemetry interrupt (IRQ) comparison polarity select where bit [X] corresponds to IRQX.
    <start table>
    0 "Assert IRQ when Signal > IRQ Threshold"
    1 "Assert IRQ when Signal <= IRQ Threshold"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Pos          0                                                                      /*!< Right-most bit position of tlm_irq_polarity in TLMCOM.TLM_IRQ_POLARITY */
#define TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Msk          (0x0000FFFFUL << TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Pos)       /*!< Mask for tlm_irq_polarity in TLMCOM.TLM_IRQ_POLARITY */
#define TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Shift(v)     (((v) << TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Pos) & TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Msk) /*!< Shift value 'v' into tlm_irq_polarity and mask 'v' to fit it into tlm_irq_polarity field */

/** TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__SET() sets TLM_IRQ_POLARITY.TLM_IRQ_POLARITY to given value.
 *
 * When writing to TLM_IRQ_POLARITY.TLM_IRQ_POLARITY, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_POLARITY.TLM_IRQ_POLARITY
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_POLARITY__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_POLARITY__SET(reg);
}

/** TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__GET() gets TLM_IRQ_POLARITY.TLM_IRQ_POLARITY's current value.
 *
 * When reading from TLM_IRQ_POLARITY.TLM_IRQ_POLARITY, this is recommended to use.
 *
 * @return current value of TLM_IRQ_POLARITY.TLM_IRQ_POLARITY
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_POLARITY__GET();
    reg = (reg & TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__MODIFY() modifies TLM_IRQ_POLARITY.TLM_IRQ_POLARITY.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_POLARITY.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_POLARITY
 * @param bf_value new value for TLM_IRQ_POLARITY.TLM_IRQ_POLARITY
 * @return new value of TLMCOM.TLM_IRQ_POLARITY
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__EXTRACT() extracts TLM_IRQ_POLARITY.TLM_IRQ_POLARITY.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_POLARITY.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_POLARITY
 * @return current value of TLM_IRQ_POLARITY.TLM_IRQ_POLARITY
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_POLARITY__TLM_IRQ_POLARITY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TLM_IRQ_EN member of TLMCOM_t                       */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_EN__ADDRESS returns the address of member TLM_IRQ_EN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_EN
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_EN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_EN)));
}

/** TLMCOM_TLM_IRQ_EN__SET() sets TLM_IRQ_EN to given value.
 *
 * When writing to TLM_IRQ_EN, this is mandatory to use.
 *
 * @param value new value for TLM_IRQ_EN
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_EN__SET(uint32_t value)
{
    HAL_SET32(__TLMCOM_TLM_IRQ_EN__ADDRESS(), value);
}

/** TLMCOM_TLM_IRQ_EN__GET() gets TLM_IRQ_EN's current value.
 *
 * When reading from TLM_IRQ_EN, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_EN
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_EN__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_EN__ADDRESS());
}

/* ---------------------- TLMCOM.TLM_IRQ_EN.TLM_IRQ_EN ---------------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_EN.TLM_IRQ_EN:

    Telemetry interrupt (IRQ) enable / clear where bit [X] corresponds to IRQX.
    <start table>
    0 "Interrupt disabled and cleared."
    1 "Interrupt enabled."
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Pos                      0                                                                      /*!< Right-most bit position of tlm_irq_en in TLMCOM.TLM_IRQ_EN */
#define TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Msk                      (0x0000FFFFUL << TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Pos)                   /*!< Mask for tlm_irq_en in TLMCOM.TLM_IRQ_EN */
#define TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Shift(v)                 (((v) << TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Pos) & TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Msk) /*!< Shift value 'v' into tlm_irq_en and mask 'v' to fit it into tlm_irq_en field */

/** TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__SET() sets TLM_IRQ_EN.TLM_IRQ_EN to given value.
 *
 * When writing to TLM_IRQ_EN.TLM_IRQ_EN, this is recommended to use.
 *
 * @param bf_value new value for TLM_IRQ_EN.TLM_IRQ_EN
 */
__TLMCOM_INLINE void TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TLMCOM_TLM_IRQ_EN__GET();
    reg = (reg & ~TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Shift((uint32_t)bf_value)));
    TLMCOM_TLM_IRQ_EN__SET(reg);
}

/** TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__GET() gets TLM_IRQ_EN.TLM_IRQ_EN's current value.
 *
 * When reading from TLM_IRQ_EN.TLM_IRQ_EN, this is recommended to use.
 *
 * @return current value of TLM_IRQ_EN.TLM_IRQ_EN
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_EN__GET();
    reg = (reg & TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__MODIFY() modifies TLM_IRQ_EN.TLM_IRQ_EN.
 *
 * This is recommended to use when setting more than one bitfield of TLMCOM.TLM_IRQ_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_EN
 * @param bf_value new value for TLM_IRQ_EN.TLM_IRQ_EN
 * @return new value of TLMCOM.TLM_IRQ_EN
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Msk);
    reg = (reg | (TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__EXTRACT() extracts TLM_IRQ_EN.TLM_IRQ_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_EN
 * @return current value of TLM_IRQ_EN.TLM_IRQ_EN
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_EN__TLM_IRQ_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IRQ_STAT member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IRQ_STAT__ADDRESS returns the address of member TLM_IRQ_STAT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IRQ_STAT
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IRQ_STAT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IRQ_STAT)));
}

/** TLMCOM_TLM_IRQ_STAT__GET() gets TLM_IRQ_STAT's current value.
 *
 * When reading from TLM_IRQ_STAT, this is mandatory to use.
 *
 * @return current value of TLM_IRQ_STAT
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_STAT__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IRQ_STAT__ADDRESS());
}

/* -------------------- TLMCOM.TLM_IRQ_STAT.TLM_IRQ_STAT -------------------- */

/**
<pre>
  TLMCOM.TLM_IRQ_STAT.TLM_IRQ_STAT:

    Telemetry interrupt (IRQ) status where bit [X] corresponds to IRQX.
    <start table>
    0 "IRQ not set"
    1 "IRQ set"
    <end table>

</pre> */

#define TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__Pos                  0                                                                      /*!< Right-most bit position of tlm_irq_stat in TLMCOM.TLM_IRQ_STAT */
#define TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__Msk                  (0x0000FFFFUL << TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__Pos)               /*!< Mask for tlm_irq_stat in TLMCOM.TLM_IRQ_STAT */
#define TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__Shift(v)             (((v) << TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__Pos) & TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__Msk) /*!< Shift value 'v' into tlm_irq_stat and mask 'v' to fit it into tlm_irq_stat field */

/** TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__GET() gets TLM_IRQ_STAT.TLM_IRQ_STAT's current value.
 *
 * When reading from TLM_IRQ_STAT.TLM_IRQ_STAT, this is recommended to use.
 *
 * @return current value of TLM_IRQ_STAT.TLM_IRQ_STAT
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IRQ_STAT__GET();
    reg = (reg & TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__EXTRACT() extracts TLM_IRQ_STAT.TLM_IRQ_STAT.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IRQ_STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IRQ_STAT
 * @return current value of TLM_IRQ_STAT.TLM_IRQ_STAT
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__Msk);
    reg = (reg >> TLMCOM_TLM_IRQ_STAT__TLM_IRQ_STAT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      TLM_IMON_LPF member of TLMCOM_t                      */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_IMON_LPF__ADDRESS returns the address of member TLM_IMON_LPF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_IMON_LPF
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_IMON_LPF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_IMON_LPF)));
}

/** TLMCOM_TLM_IMON_LPF__GET() gets TLM_IMON_LPF's current value.
 *
 * When reading from TLM_IMON_LPF, this is mandatory to use.
 *
 * @return current value of TLM_IMON_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IMON_LPF__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_IMON_LPF__ADDRESS());
}

/* ------------------ TLMCOM.TLM_IMON_LPF.TLM_IMON_ADC_LPF ------------------ */

/**
<pre>
  TLMCOM.TLM_IMON_LPF.TLM_IMON_ADC_LPF:

    Low pass filtered IMON telemetry output when used as a general purpose ADC.
    LSB = 0.0625 ADC Code, Range = 0 to 1023.9375 ADC Codes

</pre> */

#define TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__Pos              0                                                                      /*!< Right-most bit position of tlm_imon_adc_lpf in TLMCOM.TLM_IMON_LPF */
#define TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__Msk              (0x00003FFFUL << TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__Pos)           /*!< Mask for tlm_imon_adc_lpf in TLMCOM.TLM_IMON_LPF */
#define TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__Shift(v)         (((v) << TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__Pos) & TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__Msk) /*!< Shift value 'v' into tlm_imon_adc_lpf and mask 'v' to fit it into tlm_imon_adc_lpf field */

/** TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__GET() gets TLM_IMON_LPF.TLM_IMON_ADC_LPF's current value.
 *
 * When reading from TLM_IMON_LPF.TLM_IMON_ADC_LPF, this is recommended to use.
 *
 * @return current value of TLM_IMON_LPF.TLM_IMON_ADC_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__GET(void)
{
    uint32_t reg = TLMCOM_TLM_IMON_LPF__GET();
    reg = (reg & TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__EXTRACT() extracts TLM_IMON_LPF.TLM_IMON_ADC_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_IMON_LPF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_IMON_LPF
 * @return current value of TLM_IMON_LPF.TLM_IMON_ADC_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_IMON_LPF__TLM_IMON_ADC_LPF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     TLM_PRISEN_LPF member of TLMCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_PRISEN_LPF__ADDRESS returns the address of member TLM_PRISEN_LPF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_PRISEN_LPF
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_PRISEN_LPF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_PRISEN_LPF)));
}

/** TLMCOM_TLM_PRISEN_LPF__GET() gets TLM_PRISEN_LPF's current value.
 *
 * When reading from TLM_PRISEN_LPF, this is mandatory to use.
 *
 * @return current value of TLM_PRISEN_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_PRISEN_LPF__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_PRISEN_LPF__ADDRESS());
}

/* ---------------- TLMCOM.TLM_PRISEN_LPF.TLM_PRISEN_ADC_LPF ---------------- */

/**
<pre>
  TLMCOM.TLM_PRISEN_LPF.TLM_PRISEN_ADC_LPF:

    Low pass filtered PRISEN telemetry output when used as a general purpose ADC.
    LSB = 0.0625 ADC Code, Range = 0 to 1023.9375 ADC Codes

</pre> */

#define TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__Pos          0                                                                      /*!< Right-most bit position of tlm_prisen_adc_lpf in TLMCOM.TLM_PRISEN_LPF */
#define TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__Msk          (0x00003FFFUL << TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__Pos)       /*!< Mask for tlm_prisen_adc_lpf in TLMCOM.TLM_PRISEN_LPF */
#define TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__Shift(v)     (((v) << TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__Pos) & TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__Msk) /*!< Shift value 'v' into tlm_prisen_adc_lpf and mask 'v' to fit it into tlm_prisen_adc_lpf field */

/** TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__GET() gets TLM_PRISEN_LPF.TLM_PRISEN_ADC_LPF's current value.
 *
 * When reading from TLM_PRISEN_LPF.TLM_PRISEN_ADC_LPF, this is recommended to use.
 *
 * @return current value of TLM_PRISEN_LPF.TLM_PRISEN_ADC_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__GET(void)
{
    uint32_t reg = TLMCOM_TLM_PRISEN_LPF__GET();
    reg = (reg & TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__EXTRACT() extracts TLM_PRISEN_LPF.TLM_PRISEN_ADC_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_PRISEN_LPF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_PRISEN_LPF
 * @return current value of TLM_PRISEN_LPF.TLM_PRISEN_ADC_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_PRISEN_LPF__TLM_PRISEN_ADC_LPF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    TLM_XADDR_PINSET member of TLMCOM_t                    */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_XADDR_PINSET__ADDRESS returns the address of member TLM_XADDR_PINSET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_XADDR_PINSET
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_XADDR_PINSET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_XADDR_PINSET)));
}

/** TLMCOM_TLM_XADDR_PINSET__GET() gets TLM_XADDR_PINSET's current value.
 *
 * When reading from TLM_XADDR_PINSET, this is mandatory to use.
 *
 * @return current value of TLM_XADDR_PINSET
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR_PINSET__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_XADDR_PINSET__ADDRESS());
}

/* --------------- TLMCOM.TLM_XADDR_PINSET.TLM_XADDR2_PINSET --------------- */

/**
<pre>
  TLMCOM.TLM_XADDR_PINSET.TLM_XADDR2_PINSET:

    XADDR2 pinset measurement decoded value.

</pre> */

#define TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__Pos         4                                                                      /*!< Right-most bit position of tlm_xaddr2_pinset in TLMCOM.TLM_XADDR_PINSET */
#define TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__Msk         (0x0000000FUL << TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__Pos)      /*!< Mask for tlm_xaddr2_pinset in TLMCOM.TLM_XADDR_PINSET */
#define TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__Shift(v)    (((v) << TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__Pos) & TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__Msk) /*!< Shift value 'v' into tlm_xaddr2_pinset and mask 'v' to fit it into tlm_xaddr2_pinset field */

/** TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__GET() gets TLM_XADDR_PINSET.TLM_XADDR2_PINSET's current value.
 *
 * When reading from TLM_XADDR_PINSET.TLM_XADDR2_PINSET, this is recommended to use.
 *
 * @return current value of TLM_XADDR_PINSET.TLM_XADDR2_PINSET
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__GET(void)
{
    uint32_t reg = TLMCOM_TLM_XADDR_PINSET__GET();
    reg = (reg & TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__Msk);
    reg = (reg >> TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__EXTRACT() extracts TLM_XADDR_PINSET.TLM_XADDR2_PINSET.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_XADDR_PINSET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_XADDR_PINSET
 * @return current value of TLM_XADDR_PINSET.TLM_XADDR2_PINSET
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__Msk);
    reg = (reg >> TLMCOM_TLM_XADDR_PINSET__TLM_XADDR2_PINSET__Pos);
    return (uint32_t)reg;
}

/* --------------- TLMCOM.TLM_XADDR_PINSET.TLM_XADDR1_PINSET --------------- */

/**
<pre>
  TLMCOM.TLM_XADDR_PINSET.TLM_XADDR1_PINSET:

    XADDR1 pinset measurement decoded value.

</pre> */

#define TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__Pos         0                                                                      /*!< Right-most bit position of tlm_xaddr1_pinset in TLMCOM.TLM_XADDR_PINSET */
#define TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__Msk         (0x0000000FUL << TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__Pos)      /*!< Mask for tlm_xaddr1_pinset in TLMCOM.TLM_XADDR_PINSET */
#define TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__Shift(v)    (((v) << TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__Pos) & TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__Msk) /*!< Shift value 'v' into tlm_xaddr1_pinset and mask 'v' to fit it into tlm_xaddr1_pinset field */

/** TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__GET() gets TLM_XADDR_PINSET.TLM_XADDR1_PINSET's current value.
 *
 * When reading from TLM_XADDR_PINSET.TLM_XADDR1_PINSET, this is recommended to use.
 *
 * @return current value of TLM_XADDR_PINSET.TLM_XADDR1_PINSET
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__GET(void)
{
    uint32_t reg = TLMCOM_TLM_XADDR_PINSET__GET();
    reg = (reg & TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__Msk);
    reg = (reg >> TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__EXTRACT() extracts TLM_XADDR_PINSET.TLM_XADDR1_PINSET.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_XADDR_PINSET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_XADDR_PINSET
 * @return current value of TLM_XADDR_PINSET.TLM_XADDR1_PINSET
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__Msk);
    reg = (reg >> TLMCOM_TLM_XADDR_PINSET__TLM_XADDR1_PINSET__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     TLM_XADDR1_LPF member of TLMCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_XADDR1_LPF__ADDRESS returns the address of member TLM_XADDR1_LPF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_XADDR1_LPF
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_XADDR1_LPF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_XADDR1_LPF)));
}

/** TLMCOM_TLM_XADDR1_LPF__GET() gets TLM_XADDR1_LPF's current value.
 *
 * When reading from TLM_XADDR1_LPF, this is mandatory to use.
 *
 * @return current value of TLM_XADDR1_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR1_LPF__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_XADDR1_LPF__ADDRESS());
}

/* ---------------- TLMCOM.TLM_XADDR1_LPF.TLM_XADDR1_ADC_LPF ---------------- */

/**
<pre>
  TLMCOM.TLM_XADDR1_LPF.TLM_XADDR1_ADC_LPF:

    Low pass filtered XADDR1 telemetry output when used as a general purpose ADC.
    LSB = 0.0625 ADC Code, Range = 0 to 1023.9375 ADC Codes

</pre> */

#define TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__Pos          0                                                                      /*!< Right-most bit position of tlm_xaddr1_adc_lpf in TLMCOM.TLM_XADDR1_LPF */
#define TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__Msk          (0x00003FFFUL << TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__Pos)       /*!< Mask for tlm_xaddr1_adc_lpf in TLMCOM.TLM_XADDR1_LPF */
#define TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__Shift(v)     (((v) << TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__Pos) & TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__Msk) /*!< Shift value 'v' into tlm_xaddr1_adc_lpf and mask 'v' to fit it into tlm_xaddr1_adc_lpf field */

/** TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__GET() gets TLM_XADDR1_LPF.TLM_XADDR1_ADC_LPF's current value.
 *
 * When reading from TLM_XADDR1_LPF.TLM_XADDR1_ADC_LPF, this is recommended to use.
 *
 * @return current value of TLM_XADDR1_LPF.TLM_XADDR1_ADC_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__GET(void)
{
    uint32_t reg = TLMCOM_TLM_XADDR1_LPF__GET();
    reg = (reg & TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__EXTRACT() extracts TLM_XADDR1_LPF.TLM_XADDR1_ADC_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_XADDR1_LPF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_XADDR1_LPF
 * @return current value of TLM_XADDR1_LPF.TLM_XADDR1_ADC_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_XADDR1_LPF__TLM_XADDR1_ADC_LPF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     TLM_XADDR2_LPF member of TLMCOM_t                     */
/* -------------------------------------------------------------------------- */

/** __TLMCOM_TLM_XADDR2_LPF__ADDRESS returns the address of member TLM_XADDR2_LPF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TLM_XADDR2_LPF
 */
__TLMCOM_INLINE uint32_t* __TLMCOM_TLM_XADDR2_LPF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TLMCOM_BASE_PTR() + (uint32_t)(offsetof(TLMCOM_t, TLM_XADDR2_LPF)));
}

/** TLMCOM_TLM_XADDR2_LPF__GET() gets TLM_XADDR2_LPF's current value.
 *
 * When reading from TLM_XADDR2_LPF, this is mandatory to use.
 *
 * @return current value of TLM_XADDR2_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR2_LPF__GET(void)
{
    return HAL_GET32(__TLMCOM_TLM_XADDR2_LPF__ADDRESS());
}

/* ---------------- TLMCOM.TLM_XADDR2_LPF.TLM_XADDR2_ADC_LPF ---------------- */

/**
<pre>
  TLMCOM.TLM_XADDR2_LPF.TLM_XADDR2_ADC_LPF:

    Low pass filtered XADDR2 telemetry output when used as a general purpose ADC.
    LSB = 0.0625 ADC Code, Range = 0 to 1023.9375 ADC Codes

</pre> */

#define TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__Pos          0                                                                      /*!< Right-most bit position of tlm_xaddr2_adc_lpf in TLMCOM.TLM_XADDR2_LPF */
#define TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__Msk          (0x00003FFFUL << TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__Pos)       /*!< Mask for tlm_xaddr2_adc_lpf in TLMCOM.TLM_XADDR2_LPF */
#define TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__Shift(v)     (((v) << TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__Pos) & TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__Msk) /*!< Shift value 'v' into tlm_xaddr2_adc_lpf and mask 'v' to fit it into tlm_xaddr2_adc_lpf field */

/** TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__GET() gets TLM_XADDR2_LPF.TLM_XADDR2_ADC_LPF's current value.
 *
 * When reading from TLM_XADDR2_LPF.TLM_XADDR2_ADC_LPF, this is recommended to use.
 *
 * @return current value of TLM_XADDR2_LPF.TLM_XADDR2_ADC_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__GET(void)
{
    uint32_t reg = TLMCOM_TLM_XADDR2_LPF__GET();
    reg = (reg & TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__Pos);
    return (uint32_t)reg;
}

/** TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__EXTRACT() extracts TLM_XADDR2_LPF.TLM_XADDR2_ADC_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from TLMCOM.TLM_XADDR2_LPF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TLMCOM.TLM_XADDR2_LPF
 * @return current value of TLM_XADDR2_LPF.TLM_XADDR2_ADC_LPF
 */
__TLMCOM_INLINE uint32_t TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__Msk);
    reg = (reg >> TLMCOM_TLM_XADDR2_LPF__TLM_XADDR2_ADC_LPF__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group tlmcom block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_TELEM_COMMON_H_ */
