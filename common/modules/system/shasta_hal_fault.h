/**
 * @file     shasta_hal_fault.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_FAULT_H_
#define _SHASTA_HAL_FAULT_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup fault
 * @{
 */

#if defined ( __CC_ARM )
#define __FAULT_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __FAULT_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __FAULT_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __FAULT_INLINE  static inline
#endif

/** register file of the fault block.
 */
typedef struct _FAULT_s
{
    volatile        uint32_t        FAULT_CNT                   ; /*!< (@0x00000000) Output over voltage fault count.  Defines the number of consecutive 50MHz samples the output voltage must exceed the fault threshold in order to assert a fa...(more) */
    volatile        uint32_t        FAULT_CNT_VIN_IIN           ; /*!< (@0x00000004) Input over voltage fault count.  Defines the number of consecutive switching cycles (Tsw) the input voltage must exceed the fault threshold in order to asse...(more) */
    volatile        uint32_t        FAULT_HYST                  ; /*!< (@0x00000008) Output voltage (VOUT) fault (warning) deassertion hysteresis referenced to the VSEN input (i.e., after scaling by VOUT_SCALE_LOOP).  Internally, the VOUT OV...(more) */
    volatile        uint32_t        FAULT_SHUT_MASK_LOOP        ; /*!< (@0x0000000C) Shutdown mask for "Loop" faults.  Individual faults are enabled for shutdown when their corresponding bit is high.  Enabled faults disable the loop output a...(more) */
    volatile        uint32_t        FAULT_T2_SHUT_MASK          ; /*!< (@0x00000010) "T2" shutdown mask for "Loop" faults.  Individual faults are enabled for T2 shutdown when their corresponding bit is high.  Enabled faults disable the loop ...(more) */
    volatile        uint32_t        FAULT_ENABLE_LOOP           ; /*!< (@0x00000014) Fault enable for "Loop" faults.  Individual faults are enabled for fault interrupt generation when their corresponding bit is high.  This register is contro...(more) */
    volatile        uint32_t        FAULT_VOUT_OV_FLT           ; /*!< (@0x00000018) Output over voltage fault threshold.  Note that this threshold is defined with respect to the voltage at the VSEN pin, after the vout sense resistor divider...(more) */
    volatile        uint32_t        FAULT_VOUT_OV_WRN           ; /*!< (@0x0000001C) Output over voltage warning threshold.  Note that this threshold is defined with respect to the voltage at the VSEN pin, after the vout sense resistor divid...(more) */
    volatile        uint32_t        FAULT_VOUT_UV_FLT           ; /*!< (@0x00000020) Output under voltage fault threshold.  Note that this threshold is defined with respect to the voltage at the VSEN pin, after the vout sense resistor divide...(more) */
    volatile        uint32_t        FAULT_VOUT_UV_WRN           ; /*!< (@0x00000024) Output under voltage warning threshold.  Note that this threshold is defined with respect to the voltage at the VSEN pin, after the vout sense resistor divi...(more) */
    volatile        uint32_t        FAULT_VIN_OV_FLT            ; /*!< (@0x00000028) Input over voltage fault threshold. Computed from PMBus command as follows: <start table> "fault_vin_ovp_fault_thresh(U7.3) = (VIN_OV_FAULT_LIMIT(U7.3)*2^-3...(more) */
    volatile        uint32_t        FAULT_VIN_OV_WRN            ; /*!< (@0x0000002C) Input over voltage warning threshold. Computed from PMBus command as follows: <start table> "fault_vin_ovp_warn_thresh(U7.3) = (VIN_OV_WARN_LIMIT(U7.3)*2^-3...(more) */
    volatile        uint32_t        FAULT_VIN_UV_FLT            ; /*!< (@0x00000030) Input under voltage fault threshold. Computed from PMBus command as follows: <start table> "fault_vin_uvp_fault_thresh(U7.3) = (VIN_UV_FAULT_LIMIT(U7.3)*2^-...(more) */
    volatile        uint32_t        FAULT_VIN_UV_WRN            ; /*!< (@0x00000034) Input under voltage warning threshold. Computed from PMBus command as follows: <start table> "fault_vin_uvp_warn_thresh(U7.3) = (VIN_UV_WARN_LIMIT(U7.3)*2^-...(more) */
    volatile        uint32_t        FAULT_IOUT_OC_FLT           ; /*!< (@0x00000038) Output over current fault threshold Computed from PMBus command as follows: <start table> "fault_iout_oc_fault_thresh(U8.0) = IOUT_OC_FAULT_LIMIT(U8.0)" <en...(more) */
    volatile        uint32_t        FAULT_IOUT_LV_FLT           ; /*!< (@0x0000003C) Output over current low voltage fault threshold.  Note that this threshold is defined with respect to the voltage at the VSEN pin, after the vout sense resi...(more) */
    volatile        uint32_t        FAULT_IOUT_OC_WRN           ; /*!< (@0x00000040) Output over current warn threshold. Computed from PMBus command as follows: <start table> "fault_iout_oc_warn_thresh(U8.0) = IOUT_OC_WARN_LIMIT(U8.0)" <end ...(more) */
    volatile        uint32_t        FAULT_IOUT_UC_FLT           ; /*!< (@0x00000044) Output under current fault threshold.  Fault asserted when the cycle averaged output current is below this threshold. Computed from PMBus command as follows...(more) */
    volatile        uint32_t        FAULT_MFR_OC_FLT            ; /*!< (@0x00000048) Fast output over current fault threshold. Computed from PMBus command as follows: <start table> "fault_mfr_iout_oc_fast_thresh(U8.0) = MFR_IOUT_OC_FAST_FAUL...(more) */
    volatile        uint32_t        FAULT_IIN_OC_FLT            ; /*!< (@0x0000004C) Input over current fault threshold. Computed from PMBus command as follows: <start table> "fault_iin_ocp_fault_thresh(U6.2) = IIN_OC_FAULT_LIMIT(U6.2)" <end...(more) */
    volatile        uint32_t        FAULT_IIN_OC_WRN            ; /*!< (@0x00000050) Input over current warning threshold. Computed from PMBus command as follows: <start table> "fault_iin_ocp_warn_thresh(U6.2) = IIN_OC_WARN_LIMIT(U6.2)" <end...(more) */
    volatile        uint32_t        FAULT_OT_FLT                ; /*!< (@0x00000054) Over temperature fault threshold in Telemetry Sense ADC codes.  Note that the ADC Code to Temperature lookup table is implemented in FW. LSB = 1 TS ADC Code...(more) */
    volatile        uint32_t        FAULT_OT_WRN                ; /*!< (@0x00000058) Over temperature warn threshold in Telemetry Sense ADC codes.  Note that the ADC Code to Temperature lookup table is implemented in FW. LSB = 1 TS ADC Code,...(more) */
    volatile        uint32_t        FAULT_UT_FLT                ; /*!< (@0x0000005C) Under temperature fault threshold in Telemetry Sense ADC codes.  Note that the ADC Code to Temperature lookup table is implemented in FW. LSB = 1 TS ADC Cod...(more) */
    volatile        uint32_t        FAULT_UT_WRN                ; /*!< (@0x00000060) Under temperature warn threshold in Telemetry Sense ADC codes.  Note that the ADC Code to Temperature lookup table is implemented in FW. LSB = 1 TS ADC Code...(more) */
    volatile        uint32_t        FAULT_OT_SRC                ; /*!< (@0x00000064) Loop temperature source select. <start table_with_header> [2:0] Source TC 0 "ATSEN input" NTC 1 "BTSEN input" NTC 2 "Internal temperature (ITSEN)" PTC 3 "AT...(more) */
    volatile        uint32_t        FAULT_SHUT_CLR_LOOP         ; /*!< (@0x00000068) Clears shutdown faults in fault_reg_loop when set high. This field should not be written until after FW has completed shutdown related cleanup (e.g., Vcontr...(more) */
    volatile        uint32_t        FAULT_POLARITY_LOOP         ; /*!< (@0x0000006C) Defines the polarity of the fault with respect to the threshold.  When set to 0, the fault / warning is asserted using its default polarity (e.g., "over" ty...(more) */
    volatile        uint32_t        FAULT_FORCE_LOOP            ; /*!< (@0x00000070) Fault force set register.  When the bit corresponding to a fault / warning is set to 1, that fault / warning is asserted as if it had exceeded its threshold...(more) */
    volatile        uint32_t        FAULT_CLEAR_LOOP            ; /*!< (@0x00000074) Fault force clear register.  When the bit corresponding to a fault / warning is set to 1, that fault / warning is cleared in the fault_status_loop and fault...(more) */
    volatile        uint32_t        FAULT_STATUS_LOOP           ; /*!< (@0x00000078) Fault status register generated by sub-sampling fault_reg_loop at 2MHz.  Fault interrupts are generated from this register.  Once a fault bit is set it is l...(more) */
    volatile        uint32_t        FAULT_REG_LOOP              ; /*!< (@0x0000007C) Fault status register updated at 50MHz.  Once a fault bit is set it is latched in this register and can only be cleared via fault_clear_loop. <start table_w...(more) */
    volatile        uint32_t        FAULT_IOUT_CC_RD            ; /*!< (@0x00000080) Status flag indicating IOUT constant current mode operation. <start table> 0 "Normal operation" 1 "Constant current mode" <end table> */
    volatile        uint32_t        FAULT_IOUT_CC_SEL           ; /*!< (@0x00000084) Constant current mode enable for IOUT_OC_FAULT.  Set by IOUT_OC_FAULT_RESPONSE. <start table> 0 "disabled" 1 "enabled" <end table> */
} FAULT_t;


/** enumeration of implemented fault blocks
 */
typedef enum _fault_idx_e
{
    FAULT0 = 0u,    //!< FAULT0
    FAULT1 = 1u     //!< FAULT1
} fault_idx_t;

#define FAULT_BASE (0x70003C00u)                                                          /*!< fault base address */
#define FAULT_STRIDE (0x00000400u)                                                         

/** __FAULT_BASE_PTR returns the base address of the peripheral.
 *
 * @param idp index of peripheral
 * @return base address of peripheral's instance
 */
__FAULT_INLINE uint32_t* __FAULT_BASE_PTR(fault_idx_t idp)
{
    return (uint32_t*)(FAULT_BASE + (uint32_t)((uint32_t)idp * FAULT_STRIDE));
}


/* -------------------------------------------------------------------------- */
/*                        FAULT_CNT member of FAULT_t                        */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_CNT__ADDRESS returns the address of member FAULT_CNT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_CNT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_CNT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_CNT)));
}

/** FAULT_FAULT_CNT__SET() sets FAULT_CNT to given value.
 *
 * When writing to FAULT_CNT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_CNT__ADDRESS(idp), value);
}

/** FAULT_FAULT_CNT__GET() gets FAULT_CNT's current value.
 *
 * When reading from FAULT_CNT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_CNT__ADDRESS(idp));
}

/* ---------------- FAULT.FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT ---------------- */

/**
<pre>
  FAULT.FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT:

    Output under current fault count.  Defines the number of consecutive switching cycles (Tsw) the cycle averaged current must exceed the fault threshold in order to assert a fault.
        Count = fault_iout_uc_fault_cnt + 1

</pre> */

#define FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Pos           23                                                                     /*!< Right-most bit position of fault_iout_uc_fault_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Msk           (0x0000001FUL << FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Pos)        /*!< Mask for fault_iout_uc_fault_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Shift(v)      (((v) << FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Pos) & FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Msk) /*!< Shift value 'v' into fault_iout_uc_fault_cnt and mask 'v' to fit it into fault_iout_uc_fault_cnt field */

/** FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__SET() sets FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT to given value.
 *
 * When writing to FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT__SET(idp, reg);
}

/** FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__GET() gets FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT's current value.
 *
 * When reading from FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__MODIFY() modifies FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @param bf_value new value for FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT
 * @return new value of FAULT.FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__EXTRACT() extracts FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @return current value of FAULT_CNT.FAULT_IOUT_UC_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_IOUT_UC_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/* --------------- FAULT.FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT --------------- */

/**
<pre>
  FAULT.FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT:

    MFR_IOUT_OC_FAST over current fault count.  Defines the number of consecutive switching cycles (Tsw) the cycle averaged current must exceed the fault threshold in order to assert a fault.
        Count = fault_mfr_iout_oc_fast_cnt + 1

</pre> */

#define FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Pos        18                                                                     /*!< Right-most bit position of fault_mfr_iout_oc_fast_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Msk        (0x0000001FUL << FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Pos)     /*!< Mask for fault_mfr_iout_oc_fast_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Shift(v)   (((v) << FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Pos) & FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Msk) /*!< Shift value 'v' into fault_mfr_iout_oc_fast_cnt and mask 'v' to fit it into fault_mfr_iout_oc_fast_cnt field */

/** FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__SET() sets FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT to given value.
 *
 * When writing to FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT__SET(idp, reg);
}

/** FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__GET() gets FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT's current value.
 *
 * When reading from FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__MODIFY() modifies FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @param bf_value new value for FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT
 * @return new value of FAULT.FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__EXTRACT() extracts FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @return current value of FAULT_CNT.FAULT_MFR_IOUT_OC_FAST_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_MFR_IOUT_OC_FAST_CNT__Pos);
    return (uint32_t)reg;
}

/* ----------------- FAULT.FAULT_CNT.FAULT_IOUT_OC_WARN_CNT ----------------- */

/**
<pre>
  FAULT.FAULT_CNT.FAULT_IOUT_OC_WARN_CNT:

    Output over current warning count.  Defines the number of consecutive switching cycles (Tsw) the low pass filtered current must exceed the warn threshold in order to assert a warning.
        Count = fault_iout_oc_warn_cnt + 1

</pre> */

#define FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Pos            13                                                                     /*!< Right-most bit position of fault_iout_oc_warn_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Msk            (0x0000001FUL << FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Pos)         /*!< Mask for fault_iout_oc_warn_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Shift(v)       (((v) << FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Pos) & FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Msk) /*!< Shift value 'v' into fault_iout_oc_warn_cnt and mask 'v' to fit it into fault_iout_oc_warn_cnt field */

/** FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__SET() sets FAULT_CNT.FAULT_IOUT_OC_WARN_CNT to given value.
 *
 * When writing to FAULT_CNT.FAULT_IOUT_OC_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT.FAULT_IOUT_OC_WARN_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT__SET(idp, reg);
}

/** FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__GET() gets FAULT_CNT.FAULT_IOUT_OC_WARN_CNT's current value.
 *
 * When reading from FAULT_CNT.FAULT_IOUT_OC_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT.FAULT_IOUT_OC_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__MODIFY() modifies FAULT_CNT.FAULT_IOUT_OC_WARN_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @param bf_value new value for FAULT_CNT.FAULT_IOUT_OC_WARN_CNT
 * @return new value of FAULT.FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__EXTRACT() extracts FAULT_CNT.FAULT_IOUT_OC_WARN_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @return current value of FAULT_CNT.FAULT_IOUT_OC_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_IOUT_OC_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/* ---------------- FAULT.FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT ---------------- */

/**
<pre>
  FAULT.FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT:

    Output over current fault count.  Defines the number of consecutive switching cycles (Tsw) the low pass filtered current must exceed the fault threshold in order to assert a fault.
        Count = fault_iout_oc_fault_cnt + 1

</pre> */

#define FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Pos           8                                                                      /*!< Right-most bit position of fault_iout_oc_fault_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Msk           (0x0000001FUL << FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Pos)        /*!< Mask for fault_iout_oc_fault_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Shift(v)      (((v) << FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Pos) & FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Msk) /*!< Shift value 'v' into fault_iout_oc_fault_cnt and mask 'v' to fit it into fault_iout_oc_fault_cnt field */

/** FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__SET() sets FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT to given value.
 *
 * When writing to FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT__SET(idp, reg);
}

/** FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__GET() gets FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT's current value.
 *
 * When reading from FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__MODIFY() modifies FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @param bf_value new value for FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT
 * @return new value of FAULT.FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__EXTRACT() extracts FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @return current value of FAULT_CNT.FAULT_IOUT_OC_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_IOUT_OC_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/* ----------------- FAULT.FAULT_CNT.FAULT_VOUT_UV_WARN_CNT ----------------- */

/**
<pre>
  FAULT.FAULT_CNT.FAULT_VOUT_UV_WARN_CNT:

    Output under voltage warning count.  Defines the number of consecutive 50MHz samples the output voltage must exceed the warn threshold in order to assert a warning.
    <start table_with_header>
    [1:0] "# samples" "[1:0]" "# samples"
    0 "1" "2" "4"
    1 "2" "3" "8"
    <end table>

</pre> */

#define FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Pos            6                                                                      /*!< Right-most bit position of fault_vout_uv_warn_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Msk            (0x00000003UL << FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Pos)         /*!< Mask for fault_vout_uv_warn_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Shift(v)       (((v) << FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Pos) & FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Msk) /*!< Shift value 'v' into fault_vout_uv_warn_cnt and mask 'v' to fit it into fault_vout_uv_warn_cnt field */

/** FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__SET() sets FAULT_CNT.FAULT_VOUT_UV_WARN_CNT to given value.
 *
 * When writing to FAULT_CNT.FAULT_VOUT_UV_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT.FAULT_VOUT_UV_WARN_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT__SET(idp, reg);
}

/** FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__GET() gets FAULT_CNT.FAULT_VOUT_UV_WARN_CNT's current value.
 *
 * When reading from FAULT_CNT.FAULT_VOUT_UV_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT.FAULT_VOUT_UV_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__MODIFY() modifies FAULT_CNT.FAULT_VOUT_UV_WARN_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @param bf_value new value for FAULT_CNT.FAULT_VOUT_UV_WARN_CNT
 * @return new value of FAULT.FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__EXTRACT() extracts FAULT_CNT.FAULT_VOUT_UV_WARN_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @return current value of FAULT_CNT.FAULT_VOUT_UV_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_VOUT_UV_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/* ---------------- FAULT.FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT ---------------- */

/**
<pre>
  FAULT.FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT:

    Output under voltage fault count.  Defines the number of consecutive 50MHz samples the output voltage must exceed the fault threshold in order to assert a fault.
    <start table_with_header>
    [1:0] "# samples" "[1:0]" "# samples"
    0 "1" "2" "4"
    1 "2" "3" "8"
    <end table>

</pre> */

#define FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Pos           4                                                                      /*!< Right-most bit position of fault_vout_uv_fault_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Msk           (0x00000003UL << FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Pos)        /*!< Mask for fault_vout_uv_fault_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Shift(v)      (((v) << FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Pos) & FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Msk) /*!< Shift value 'v' into fault_vout_uv_fault_cnt and mask 'v' to fit it into fault_vout_uv_fault_cnt field */

/** FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__SET() sets FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT to given value.
 *
 * When writing to FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT__SET(idp, reg);
}

/** FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__GET() gets FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT's current value.
 *
 * When reading from FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__MODIFY() modifies FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @param bf_value new value for FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT
 * @return new value of FAULT.FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__EXTRACT() extracts FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @return current value of FAULT_CNT.FAULT_VOUT_UV_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_VOUT_UV_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/* ----------------- FAULT.FAULT_CNT.FAULT_VOUT_OV_WARN_CNT ----------------- */

/**
<pre>
  FAULT.FAULT_CNT.FAULT_VOUT_OV_WARN_CNT:

    Output over voltage warning count.  Defines the number of consecutive 50MHz samples the output voltage must exceed the warn threshold in order to assert a warning.
    <start table_with_header>
    [1:0] "# samples" "[1:0]" "# samples"
    0 "1" "2" "4"
    1 "2" "3" "8"
    <end table>

</pre> */

#define FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Pos            2                                                                      /*!< Right-most bit position of fault_vout_ov_warn_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Msk            (0x00000003UL << FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Pos)         /*!< Mask for fault_vout_ov_warn_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Shift(v)       (((v) << FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Pos) & FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Msk) /*!< Shift value 'v' into fault_vout_ov_warn_cnt and mask 'v' to fit it into fault_vout_ov_warn_cnt field */

/** FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__SET() sets FAULT_CNT.FAULT_VOUT_OV_WARN_CNT to given value.
 *
 * When writing to FAULT_CNT.FAULT_VOUT_OV_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT.FAULT_VOUT_OV_WARN_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT__SET(idp, reg);
}

/** FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__GET() gets FAULT_CNT.FAULT_VOUT_OV_WARN_CNT's current value.
 *
 * When reading from FAULT_CNT.FAULT_VOUT_OV_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT.FAULT_VOUT_OV_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__MODIFY() modifies FAULT_CNT.FAULT_VOUT_OV_WARN_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @param bf_value new value for FAULT_CNT.FAULT_VOUT_OV_WARN_CNT
 * @return new value of FAULT.FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__EXTRACT() extracts FAULT_CNT.FAULT_VOUT_OV_WARN_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @return current value of FAULT_CNT.FAULT_VOUT_OV_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_VOUT_OV_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/* ---------------- FAULT.FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT ---------------- */

/**
<pre>
  FAULT.FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT:

    Output over voltage fault count.  Defines the number of consecutive 50MHz samples the output voltage must exceed the fault threshold in order to assert a fault.
    <start table_with_header>
    [1:0] "# samples" "[1:0]" "# samples"
    0 "1" "2" "4"
    1 "2" "3" "8"
    <end table>

</pre> */

#define FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Pos           0                                                                      /*!< Right-most bit position of fault_vout_ov_fault_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Msk           (0x00000003UL << FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Pos)        /*!< Mask for fault_vout_ov_fault_cnt in FAULT.FAULT_CNT */
#define FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Shift(v)      (((v) << FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Pos) & FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Msk) /*!< Shift value 'v' into fault_vout_ov_fault_cnt and mask 'v' to fit it into fault_vout_ov_fault_cnt field */

/** FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__SET() sets FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT to given value.
 *
 * When writing to FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT__SET(idp, reg);
}

/** FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__GET() gets FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT's current value.
 *
 * When reading from FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT__GET(idp);
    reg = (reg & FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__MODIFY() modifies FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @param bf_value new value for FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT
 * @return new value of FAULT.FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__EXTRACT() extracts FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT
 * @return current value of FAULT_CNT.FAULT_VOUT_OV_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT__FAULT_VOUT_OV_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_CNT_VIN_IIN member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_CNT_VIN_IIN__ADDRESS returns the address of member FAULT_CNT_VIN_IIN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_CNT_VIN_IIN
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_CNT_VIN_IIN__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_CNT_VIN_IIN)));
}

/** FAULT_FAULT_CNT_VIN_IIN__SET() sets FAULT_CNT_VIN_IIN to given value.
 *
 * When writing to FAULT_CNT_VIN_IIN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_CNT_VIN_IIN
 */
__FAULT_INLINE void FAULT_FAULT_CNT_VIN_IIN__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_CNT_VIN_IIN__ADDRESS(idp), value);
}

/** FAULT_FAULT_CNT_VIN_IIN__GET() gets FAULT_CNT_VIN_IIN's current value.
 *
 * When reading from FAULT_CNT_VIN_IIN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT_VIN_IIN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_CNT_VIN_IIN__ADDRESS(idp));
}

/* -------------- FAULT.FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST -------------- */

/**
<pre>
  FAULT.FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST:

    Input voltage (VIN) fault (warning) deassertion hysteresis.  Internally, the VIN OV fault is asserted when VIN exceeds VIN_OV_FAULT_LIMIT for fault_vin_ov_fault_cnt samples without dropping below (VIN_OV_FAULT_LIMIT-fault_vin_fault_hyst).  The samples above VIN_OV_FAULT_LIMIT need not be consecutive but a single sample below (VIN_OV_FAULT_LIMIT-fault_vin_fault_hyst) will reset the count.
    For the typical case this parameter should be set to a positive voltage.  This hysteresis parameter applies to all VIN faults and warnings as shown below.
    <start table_with_header>
    Fault Asserted Deasserted
    VIN_OV_FAULT "> VIN_OV_FAULT_LIMIT" "<= (VIN_OV_FAULT_LIMIT-fault_vin_fault_hyst)"
    VIN_OV_WARN "> VIN_OV_WARN_LIMIT" "<= (VIN_OV_WARN_LIMIT-fault_vin_fault_hyst)"
    VIN_UV_WARN "< VIN_OV_WARN_LIMIT" ">= (VIN_UV_WARN_LIMIT+fault_vin_fault_hyst)"
    VIN_UV_FAULT "< VIN_OV_FAULT_LIMIT" ">= (VIN_UV_FAULT_LIMIT+fault_vin_fault_hyst)"
    <end table>
    LSB = 125mV, Range = -4.0 to +3.875V

</pre> */

#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Pos      18                                                                     /*!< Right-most bit position of fault_vin_fault_hyst in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Msk      (0x0000003FUL << FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Pos)   /*!< Mask for fault_vin_fault_hyst in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Shift(v) (((v) << FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Pos) & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Msk) /*!< Shift value 'v' into fault_vin_fault_hyst and mask 'v' to fit it into fault_vin_fault_hyst field */

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__SET() sets FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST to given value.
 *
 * When writing to FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST
 */
__FAULT_INLINE void FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT_VIN_IIN__SET(idp, reg);
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__GET() gets FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST's current value.
 *
 * When reading from FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__MODIFY() modifies FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT_VIN_IIN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST
 * @return new value of FAULT.FAULT_CNT_VIN_IIN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__EXTRACT() extracts FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT_VIN_IIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_VIN_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/* ------------- FAULT.FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT ------------- */

/**
<pre>
  FAULT.FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT:

    Input over current warning count.  Defines the number of consecutive switching cycles (Tsw) the low pass filtered input current must exceed the warn threshold in order to assert a warning
        Count = fault_iin_oc_warn_cnt + 1

</pre> */

#define FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Pos     13                                                                     /*!< Right-most bit position of fault_iin_oc_warn_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Msk     (0x0000001FUL << FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Pos)  /*!< Mask for fault_iin_oc_warn_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Shift(v) (((v) << FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Pos) & FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Msk) /*!< Shift value 'v' into fault_iin_oc_warn_cnt and mask 'v' to fit it into fault_iin_oc_warn_cnt field */

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__SET() sets FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT to given value.
 *
 * When writing to FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT_VIN_IIN__SET(idp, reg);
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__GET() gets FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT's current value.
 *
 * When reading from FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__MODIFY() modifies FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT_VIN_IIN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT
 * @return new value of FAULT.FAULT_CNT_VIN_IIN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__EXTRACT() extracts FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT_VIN_IIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_IIN_OC_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/* ------------- FAULT.FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT ------------- */

/**
<pre>
  FAULT.FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT:

    Input over current fault count.  Defines the number of consecutive switching cycles (Tsw) the low pass filtered input current must exceed the fault threshold in order to assert a fault.
        Count = fault_iin_oc_fault_cnt + 1

</pre> */

#define FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Pos    8                                                                      /*!< Right-most bit position of fault_iin_oc_fault_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Msk    (0x0000001FUL << FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Pos) /*!< Mask for fault_iin_oc_fault_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Shift(v) (((v) << FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Pos) & FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Msk) /*!< Shift value 'v' into fault_iin_oc_fault_cnt and mask 'v' to fit it into fault_iin_oc_fault_cnt field */

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__SET() sets FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT to given value.
 *
 * When writing to FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT_VIN_IIN__SET(idp, reg);
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__GET() gets FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT's current value.
 *
 * When reading from FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__MODIFY() modifies FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT_VIN_IIN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT
 * @return new value of FAULT.FAULT_CNT_VIN_IIN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__EXTRACT() extracts FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT_VIN_IIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_IIN_OC_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_IIN_OC_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/* ------------- FAULT.FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT ------------- */

/**
<pre>
  FAULT.FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT:

    Input under voltage warning count.  Defines the number of consecutive switching cycles (Tsw) the input voltage must exceed the warn threshold in order to assert a warning
    <start table_with_header>
    [1:0] "# samples" "[1:0]" "# samples"
    0 "1" "2" "4"
    1 "2" "3" "8"
    <end table>

</pre> */

#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Pos     6                                                                      /*!< Right-most bit position of fault_vin_uv_warn_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Msk     (0x00000003UL << FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Pos)  /*!< Mask for fault_vin_uv_warn_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Shift(v) (((v) << FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Pos) & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Msk) /*!< Shift value 'v' into fault_vin_uv_warn_cnt and mask 'v' to fit it into fault_vin_uv_warn_cnt field */

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__SET() sets FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT to given value.
 *
 * When writing to FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT_VIN_IIN__SET(idp, reg);
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__GET() gets FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT's current value.
 *
 * When reading from FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__MODIFY() modifies FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT_VIN_IIN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT
 * @return new value of FAULT.FAULT_CNT_VIN_IIN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__EXTRACT() extracts FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT_VIN_IIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_VIN_UV_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/* ------------- FAULT.FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT ------------- */

/**
<pre>
  FAULT.FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT:

    Input under voltage fault count.  Defines the number of consecutive switching cycles (Tsw) the input voltage must exceed the fault threshold in order to assert a fault.
    <start table_with_header>
    [1:0] "# samples" "[1:0]" "# samples"
    0 "1" "2" "4"
    1 "2" "3" "8"
    <end table>

</pre> */

#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Pos    4                                                                      /*!< Right-most bit position of fault_vin_uv_fault_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Msk    (0x00000003UL << FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Pos) /*!< Mask for fault_vin_uv_fault_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Shift(v) (((v) << FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Pos) & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Msk) /*!< Shift value 'v' into fault_vin_uv_fault_cnt and mask 'v' to fit it into fault_vin_uv_fault_cnt field */

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__SET() sets FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT to given value.
 *
 * When writing to FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT_VIN_IIN__SET(idp, reg);
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__GET() gets FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT's current value.
 *
 * When reading from FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__MODIFY() modifies FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT_VIN_IIN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT
 * @return new value of FAULT.FAULT_CNT_VIN_IIN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__EXTRACT() extracts FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT_VIN_IIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_VIN_UV_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_UV_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/* ------------- FAULT.FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT ------------- */

/**
<pre>
  FAULT.FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT:

    Input over voltage warning count.  Defines the number of consecutive switching cycles (Tsw) the input voltage must exceed the warn threshold in order to assert a warning
    <start table_with_header>
    [1:0] "# samples" "[1:0]" "# samples"
    0 "1" "2" "4"
    1 "2" "3" "8"
    <end table>

</pre> */

#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Pos     2                                                                      /*!< Right-most bit position of fault_vin_ov_warn_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Msk     (0x00000003UL << FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Pos)  /*!< Mask for fault_vin_ov_warn_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Shift(v) (((v) << FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Pos) & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Msk) /*!< Shift value 'v' into fault_vin_ov_warn_cnt and mask 'v' to fit it into fault_vin_ov_warn_cnt field */

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__SET() sets FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT to given value.
 *
 * When writing to FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT_VIN_IIN__SET(idp, reg);
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__GET() gets FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT's current value.
 *
 * When reading from FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__MODIFY() modifies FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT_VIN_IIN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT
 * @return new value of FAULT.FAULT_CNT_VIN_IIN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__EXTRACT() extracts FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT_VIN_IIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_VIN_OV_WARN_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_WARN_CNT__Pos);
    return (uint32_t)reg;
}

/* ------------- FAULT.FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT ------------- */

/**
<pre>
  FAULT.FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT:

    Input over voltage fault count.  Defines the number of consecutive switching cycles (Tsw) the input voltage must exceed the fault threshold in order to assert a fault.
    <start table_with_header>
    [1:0] "# samples" "[1:0]" "# samples"
    0 "1" "2" "4"
    1 "2" "3" "8"
    <end table>

</pre> */

#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Pos    0                                                                      /*!< Right-most bit position of fault_vin_ov_fault_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Msk    (0x00000003UL << FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Pos) /*!< Mask for fault_vin_ov_fault_cnt in FAULT.FAULT_CNT_VIN_IIN */
#define FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Shift(v) (((v) << FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Pos) & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Msk) /*!< Shift value 'v' into fault_vin_ov_fault_cnt and mask 'v' to fit it into fault_vin_ov_fault_cnt field */

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__SET() sets FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT to given value.
 *
 * When writing to FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT
 */
__FAULT_INLINE void FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Shift((uint32_t)bf_value)));
    FAULT_FAULT_CNT_VIN_IIN__SET(idp, reg);
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__GET() gets FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT's current value.
 *
 * When reading from FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_CNT_VIN_IIN__GET(idp);
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__MODIFY() modifies FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CNT_VIN_IIN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @param bf_value new value for FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT
 * @return new value of FAULT.FAULT_CNT_VIN_IIN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Msk);
    reg = (reg | (FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__EXTRACT() extracts FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CNT_VIN_IIN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CNT_VIN_IIN
 * @return current value of FAULT_CNT_VIN_IIN.FAULT_VIN_OV_FAULT_CNT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Msk);
    reg = (reg >> FAULT_FAULT_CNT_VIN_IIN__FAULT_VIN_OV_FAULT_CNT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        FAULT_HYST member of FAULT_t                        */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_HYST__ADDRESS returns the address of member FAULT_HYST.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_HYST
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_HYST__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_HYST)));
}

/** FAULT_FAULT_HYST__SET() sets FAULT_HYST to given value.
 *
 * When writing to FAULT_HYST, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_HYST
 */
__FAULT_INLINE void FAULT_FAULT_HYST__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_HYST__ADDRESS(idp), value);
}

/** FAULT_FAULT_HYST__GET() gets FAULT_HYST's current value.
 *
 * When reading from FAULT_HYST, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_HYST__ADDRESS(idp));
}

/* ----------------- FAULT.FAULT_HYST.FAULT_TEMP_FAULT_HYST ----------------- */

/**
<pre>
  FAULT.FAULT_HYST.FAULT_TEMP_FAULT_HYST:

    Temperature fault (warning) deassertion hysteresis.  Internally, the OT fault is asserted when the temperature exceeds the ADC Code corresponding to OT_FAULT_LIMIT.  The direction of the comparison depends on whether a negative temperature coefficient (NTC) or positive temperature coefficient (PTC) sensor is used.  This means the sign of this parameter will also depend on th esensor chosen.
    Typically one should select a negative value for PTC and a positive value for NTC.  This hysteresis parameter applies to all temperature faults and warnings as shown below.
    <start table_with_header>
    TC Fault Asserted Deasserted
    PTC OT_FAULT "> ADC_Code(OT_FAULT_LIMIT)" "< (ADC_Code(OT_FAULT_LIMIT)+fault_temp_fault_hyst)"
    PTC OT_WARN "> ADC_Code(OT_WARN_LIMIT)" "< (ADC_Code(OT_WARN_LIMIT)+fault_temp_fault_hyst)"
    PTC UT_WARN "< ADC_Code(UT_WARN_LIMIT)" "> (ADC_Code(UT_WARN_LIMIT)-fault_temp_fault_hyst)"
    PTC UT_FAULT "< ADC_Code(UT_FAULT_LIMIT)" "> (ADC_Code(UT_FAULT_LIMIT)-fault_temp_fault_hyst)"
    NTC OT_FAULT "< ADC_Code(OT_FAULT_LIMIT)" "> (ADC_Code(OT_FAULT_LIMIT)+fault_temp_fault_hyst)"
    NTC OT_WARN "< ADC_Code(OT_WARN_LIMIT)" "> (ADC_Code(OT_WARN_LIMIT)+fault_temp_fault_hyst)"
    NTC UT_WARN "> ADC_Code(UT_WARN_LIMIT)" "< (ADC_Code(UT_WARN_LIMIT)-fault_temp_fault_hyst)"
    NTC UT_FAULT "> ADC_Code(UT_FAULT_LIMIT)" "< (ADC_Code(UT_FAULT_LIMIT)-fault_temp_fault_hyst)"
    <end table>
    LSB = 1 TS ADC Code, Range = -16 to +15 TS ADC Codes

</pre> */

#define FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Pos            22                                                                     /*!< Right-most bit position of fault_temp_fault_hyst in FAULT.FAULT_HYST */
#define FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Msk            (0x0000001FUL << FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Pos)         /*!< Mask for fault_temp_fault_hyst in FAULT.FAULT_HYST */
#define FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Shift(v)       (((v) << FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Pos) & FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Msk) /*!< Shift value 'v' into fault_temp_fault_hyst and mask 'v' to fit it into fault_temp_fault_hyst field */

/** FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__SET() sets FAULT_HYST.FAULT_TEMP_FAULT_HYST to given value.
 *
 * When writing to FAULT_HYST.FAULT_TEMP_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_HYST.FAULT_TEMP_FAULT_HYST
 */
__FAULT_INLINE void FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_HYST__GET(idp);
    reg = (reg & ~FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Shift((uint32_t)bf_value)));
    FAULT_FAULT_HYST__SET(idp, reg);
}

/** FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__GET() gets FAULT_HYST.FAULT_TEMP_FAULT_HYST's current value.
 *
 * When reading from FAULT_HYST.FAULT_TEMP_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_HYST.FAULT_TEMP_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_HYST__GET(idp);
    reg = (reg & FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__MODIFY() modifies FAULT_HYST.FAULT_TEMP_FAULT_HYST.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_HYST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_HYST
 * @param bf_value new value for FAULT_HYST.FAULT_TEMP_FAULT_HYST
 * @return new value of FAULT.FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__EXTRACT() extracts FAULT_HYST.FAULT_TEMP_FAULT_HYST.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_HYST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_HYST
 * @return current value of FAULT_HYST.FAULT_TEMP_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_HYST__FAULT_TEMP_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/* --------------- FAULT.FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST --------------- */

/**
<pre>
  FAULT.FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST:

    Output under current (IOUT_UC) fault deassertion hysteresis.  Internally, the IOUT UC fault is asserted when IOUT exceeds IOUT_UC_FAULT_LIMIT for fault_iout_uc_fault_cnt samples without rising above (IOUT_UC_FAULT_LIMIT+fault_iout_uc_fault_hyst).  The samples below IOUT_UC_FAULT_LIMIT need not be consecutive but a single sample above (IOUT_UC_FAULT_LIMIT+fault_iout_uc_fault_hyst) will reset the count.  For the typical case this parameter should be set to a positive current.  This hysteresis parameter applies to only the IOUT UC fault as shown below.
    <start table_with_header>
    Fault Asserted Deasserted
    IOUT_UC_FAULT "< IOUT_UC_FAULT_LIMIT" ">= (IOUT_UC_FAULT_LIMIT+fault_iout_uc_fault_hyst)"
    <end table>
    LSB = 0.25A, Range = -8.0 to +7.75A

</pre> */

#define FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Pos         16                                                                     /*!< Right-most bit position of fault_iout_uc_fault_hyst in FAULT.FAULT_HYST */
#define FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Msk         (0x0000003FUL << FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Pos)      /*!< Mask for fault_iout_uc_fault_hyst in FAULT.FAULT_HYST */
#define FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Shift(v)    (((v) << FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Pos) & FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Msk) /*!< Shift value 'v' into fault_iout_uc_fault_hyst and mask 'v' to fit it into fault_iout_uc_fault_hyst field */

/** FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__SET() sets FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST to given value.
 *
 * When writing to FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST
 */
__FAULT_INLINE void FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_HYST__GET(idp);
    reg = (reg & ~FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Shift((uint32_t)bf_value)));
    FAULT_FAULT_HYST__SET(idp, reg);
}

/** FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__GET() gets FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST's current value.
 *
 * When reading from FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_HYST__GET(idp);
    reg = (reg & FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__MODIFY() modifies FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_HYST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_HYST
 * @param bf_value new value for FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST
 * @return new value of FAULT.FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__EXTRACT() extracts FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_HYST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_HYST
 * @return current value of FAULT_HYST.FAULT_IOUT_UC_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_HYST__FAULT_IOUT_UC_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/* --------------- FAULT.FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST --------------- */

/**
<pre>
  FAULT.FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST:

    Output over current (IOUT_OC) fault (warning) deassertion hysteresis.  Internally, the IOUT OC fault is asserted when IOUT exceeds IOUT_OC_FAULT_LIMIT for fault_iout_oc_fault_cnt samples without dropping below (IOUT_OC_FAULT_LIMIT-fault_iout_oc_fault_hyst).  The samples above IOUT_OC_FAULT_LIMIT need not be consecutive but a single sample below (IOUT_OC_FAULT_LIMIT-fault_iout_oc_fault_hyst) will reset the count.
    For the typical case this parameter should be set to a positive current.  This hysteresis parameter applies to all IOUT OC faults and warnings as shown below.
    <start table_with_header>
    Fault Asserted Deasserted
    IOUT_OC_FAULT "> IOUT_OC_FAULT_LIMIT" "<= (IOUT_OC_FAULT_LIMIT-fault_iout_oc_fault_hyst)"
    IOUT_OC_WARN "> IOUT_OC_WARN_LIMIT" "<= (IOUT_OC_WARN_LIMIT-fault_iout_oc_fault_hyst)"
    IOUT_OC_FAST_FAULT "> MFR_IOUT_OC_FAST_FAULT_LIMIT" "<= (MFR_IOUT_OC_FAST_FAULT_LIMIT-fault_iout_oc_fault_hyst)"
    <end table>
    LSB = 0.25A, Range = -8.0 to +7.75A

</pre> */

#define FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Pos         10                                                                     /*!< Right-most bit position of fault_iout_oc_fault_hyst in FAULT.FAULT_HYST */
#define FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Msk         (0x0000003FUL << FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Pos)      /*!< Mask for fault_iout_oc_fault_hyst in FAULT.FAULT_HYST */
#define FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Shift(v)    (((v) << FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Pos) & FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Msk) /*!< Shift value 'v' into fault_iout_oc_fault_hyst and mask 'v' to fit it into fault_iout_oc_fault_hyst field */

/** FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__SET() sets FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST to given value.
 *
 * When writing to FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST
 */
__FAULT_INLINE void FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_HYST__GET(idp);
    reg = (reg & ~FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Shift((uint32_t)bf_value)));
    FAULT_FAULT_HYST__SET(idp, reg);
}

/** FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__GET() gets FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST's current value.
 *
 * When reading from FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_HYST__GET(idp);
    reg = (reg & FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__MODIFY() modifies FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_HYST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_HYST
 * @param bf_value new value for FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST
 * @return new value of FAULT.FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__EXTRACT() extracts FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_HYST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_HYST
 * @return current value of FAULT_HYST.FAULT_IOUT_OC_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_HYST__FAULT_IOUT_OC_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/* ----------------- FAULT.FAULT_HYST.FAULT_IIN_FAULT_HYST ----------------- */

/**
<pre>
  FAULT.FAULT_HYST.FAULT_IIN_FAULT_HYST:

    Input current (IIN) fault (warning) deassertion hysteresis.  Internally, the IIN OV fault is asserted when IIN exceeds IIN_OC_FAULT_LIMIT for fault_iin_oc_fault_cnt samples without dropping below (IIN_OC_FAULT_LIMIT-fault_iin_fault_hyst).  The samples above IIN_OC_FAULT_LIMIT need not be consecutive but a single sample below (IIN_OC_FAULT_LIMIT-fault_iin_fault_hyst) will reset the count.
    For the typical case this parameter should be set to a positive current.  This hysteresis parameter applies to all IIN faults and warnings as shown below.
    <start table_with_header>
    Fault Asserted Deasserted
    IIN_OC_FAULT "> IIN_OC_FAULT_LIMIT" "<= (IIN_OC_FAULT_LIMIT-fault_iin_fault_hyst)"
    IIN_OC_WARN "> IIN_OC_WARN_LIMIT" "<= (IIN_OC_WARN_LIMIT-fault_iin_fault_hyst)"
    <end table>
    LSB = 0.25A, Range = -4 to 3.75A

</pre> */

#define FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Pos             5                                                                      /*!< Right-most bit position of fault_iin_fault_hyst in FAULT.FAULT_HYST */
#define FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Msk             (0x0000001FUL << FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Pos)          /*!< Mask for fault_iin_fault_hyst in FAULT.FAULT_HYST */
#define FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Shift(v)        (((v) << FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Pos) & FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Msk) /*!< Shift value 'v' into fault_iin_fault_hyst and mask 'v' to fit it into fault_iin_fault_hyst field */

/** FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__SET() sets FAULT_HYST.FAULT_IIN_FAULT_HYST to given value.
 *
 * When writing to FAULT_HYST.FAULT_IIN_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_HYST.FAULT_IIN_FAULT_HYST
 */
__FAULT_INLINE void FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_HYST__GET(idp);
    reg = (reg & ~FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Shift((uint32_t)bf_value)));
    FAULT_FAULT_HYST__SET(idp, reg);
}

/** FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__GET() gets FAULT_HYST.FAULT_IIN_FAULT_HYST's current value.
 *
 * When reading from FAULT_HYST.FAULT_IIN_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_HYST.FAULT_IIN_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_HYST__GET(idp);
    reg = (reg & FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__MODIFY() modifies FAULT_HYST.FAULT_IIN_FAULT_HYST.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_HYST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_HYST
 * @param bf_value new value for FAULT_HYST.FAULT_IIN_FAULT_HYST
 * @return new value of FAULT.FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__EXTRACT() extracts FAULT_HYST.FAULT_IIN_FAULT_HYST.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_HYST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_HYST
 * @return current value of FAULT_HYST.FAULT_IIN_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_HYST__FAULT_IIN_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/* ----------------- FAULT.FAULT_HYST.FAULT_VOUT_FAULT_HYST ----------------- */

/**
<pre>
  FAULT.FAULT_HYST.FAULT_VOUT_FAULT_HYST:

    Output voltage (VOUT) fault (warning) deassertion hysteresis referenced to the VSEN input (i.e., after scaling by VOUT_SCALE_LOOP).  Internally, the VOUT OV fault is asserted when VOUT exceeds VOUT_OV_FAULT_LIMIT for fault_vout_ov_fault_cnt samples without dropping below (VOUT_OV_FAULT_LIMIT-fault_vout_fault_hyst).  The samples above VOUT_OV_FAULT_LIMIT need not be consecutive but a single sample below (VOUT_OV_FAULT_LIMIT-fault_vout_fault_hyst) will reset the count.
    For the typical case this parameter should be set to a positive voltage.  This hysteresis parameter applies to all VOUT faults and warnings as shown below.
    <start table_with_header>
    Fault Asserted Deasserted
    VOUT_OV_FAULT "> VOUT_OV_FAULT_LIMIT" "<= (VOUT_OV_FAULT_LIMIT-fault_vout_fault_hyst)"
    VOUT_OV_WARN "> VOUT_OV_WARN_LIMIT" "<= (VOUT_OV_WARN_LIMIT-fault_vout_fault_hyst)"
    VOUT_UV_WARN "< VOUT_OV_WARN_LIMIT" ">= (VOUT_UV_WARN_LIMIT+fault_vout_fault_hyst)"
    VOUT_UV_FAULT "< VOUT_OV_FAULT_LIMIT" ">= (VOUT_UV_FAULT_LIMIT+fault_vout_fault_hyst)"
    <end table>
    LSB = 5mV, Range = -80 to +75mV

</pre> */

#define FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Pos            0                                                                      /*!< Right-most bit position of fault_vout_fault_hyst in FAULT.FAULT_HYST */
#define FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Msk            (0x0000001FUL << FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Pos)         /*!< Mask for fault_vout_fault_hyst in FAULT.FAULT_HYST */
#define FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Shift(v)       (((v) << FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Pos) & FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Msk) /*!< Shift value 'v' into fault_vout_fault_hyst and mask 'v' to fit it into fault_vout_fault_hyst field */

/** FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__SET() sets FAULT_HYST.FAULT_VOUT_FAULT_HYST to given value.
 *
 * When writing to FAULT_HYST.FAULT_VOUT_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_HYST.FAULT_VOUT_FAULT_HYST
 */
__FAULT_INLINE void FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_HYST__GET(idp);
    reg = (reg & ~FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Shift((uint32_t)bf_value)));
    FAULT_FAULT_HYST__SET(idp, reg);
}

/** FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__GET() gets FAULT_HYST.FAULT_VOUT_FAULT_HYST's current value.
 *
 * When reading from FAULT_HYST.FAULT_VOUT_FAULT_HYST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_HYST.FAULT_VOUT_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_HYST__GET(idp);
    reg = (reg & FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__MODIFY() modifies FAULT_HYST.FAULT_VOUT_FAULT_HYST.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_HYST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_HYST
 * @param bf_value new value for FAULT_HYST.FAULT_VOUT_FAULT_HYST
 * @return new value of FAULT.FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Msk);
    reg = (reg | (FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__EXTRACT() extracts FAULT_HYST.FAULT_VOUT_FAULT_HYST.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_HYST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_HYST
 * @return current value of FAULT_HYST.FAULT_VOUT_FAULT_HYST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Msk);
    reg = (reg >> FAULT_FAULT_HYST__FAULT_VOUT_FAULT_HYST__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   FAULT_SHUT_MASK_LOOP member of FAULT_t                   */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_SHUT_MASK_LOOP__ADDRESS returns the address of member FAULT_SHUT_MASK_LOOP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_SHUT_MASK_LOOP
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_SHUT_MASK_LOOP__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_SHUT_MASK_LOOP)));
}

/** FAULT_FAULT_SHUT_MASK_LOOP__SET() sets FAULT_SHUT_MASK_LOOP to given value.
 *
 * When writing to FAULT_SHUT_MASK_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_SHUT_MASK_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_SHUT_MASK_LOOP__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_SHUT_MASK_LOOP__ADDRESS(idp), value);
}

/** FAULT_FAULT_SHUT_MASK_LOOP__GET() gets FAULT_SHUT_MASK_LOOP's current value.
 *
 * When reading from FAULT_SHUT_MASK_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_SHUT_MASK_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_SHUT_MASK_LOOP__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_SHUT_MASK_LOOP__ADDRESS(idp));
}

/* ------------ FAULT.FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP ------------ */

/**
<pre>
  FAULT.FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP:

    Shutdown mask for "Loop" faults.  Individual faults are enabled for shutdown when their corresponding bit is high.  Enabled faults disable the loop output and assert the shutdown interrupt immediately upon fault assertion.  The register is controlled by FW based on settings of the various PMBus fault responses.
    <start table_with_header>
    Bit "Fault" "Bit" "Fault"
    0 "Reserved"   "1" "VOUT_OV_FAULT "
    2 "VOUT_OV_WARN"  "3" "VOUT_UV_FAULT"
    4 "VOUT_UV_WARN"  "5" "VIN_OV_FAULT"
    6 "VIN_OV_WARN"  "7"  "VIN_UV_FAULT"
    8 "VIN_UV_WARN" "9" "IOUT_OC_FAULT"
    10 "IOUT_OC_LV_FAULT" "11" "IOUT_OC_WARN"
    12 "IOUT_UC_FAULT" "13" "MFR_IOUT_OC_FAST"
    14 "IIN_OC_FAULT"  "15" "IIN_OC_WARN"
    16 "OT_FAULT"  "17" "OT_WARN"
    18 "UT_FAULT"  "19" "UT_WARN"
    20 "POWER_LIMIT_MODE" "21" "ISHARE_FAULT"
    22 "VOUT_MAX_MIN_WARN" "23" "SYNC_FAULT"
    24-31 "Unused"
    <end table>

</pre> */

#define FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Pos   0                                                                      /*!< Right-most bit position of fault_shut_mask_loop in FAULT.FAULT_SHUT_MASK_LOOP */
#define FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Msk   (0xFFFFFFFFUL << FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Pos) /*!< Mask for fault_shut_mask_loop in FAULT.FAULT_SHUT_MASK_LOOP */
#define FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Shift(v) (((v) << FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Pos) & FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Msk) /*!< Shift value 'v' into fault_shut_mask_loop and mask 'v' to fit it into fault_shut_mask_loop field */

/** FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__SET() sets FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP to given value.
 *
 * When writing to FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_SHUT_MASK_LOOP__GET(idp);
    reg = (reg & ~FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Shift((uint32_t)bf_value)));
    FAULT_FAULT_SHUT_MASK_LOOP__SET(idp, reg);
}

/** FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__GET() gets FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP's current value.
 *
 * When reading from FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_SHUT_MASK_LOOP__GET(idp);
    reg = (reg & FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__MODIFY() modifies FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_SHUT_MASK_LOOP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_SHUT_MASK_LOOP
 * @param bf_value new value for FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP
 * @return new value of FAULT.FAULT_SHUT_MASK_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__EXTRACT() extracts FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_SHUT_MASK_LOOP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_SHUT_MASK_LOOP
 * @return current value of FAULT_SHUT_MASK_LOOP.FAULT_SHUT_MASK_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_SHUT_MASK_LOOP__FAULT_SHUT_MASK_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_T2_SHUT_MASK member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_T2_SHUT_MASK__ADDRESS returns the address of member FAULT_T2_SHUT_MASK.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_T2_SHUT_MASK
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_T2_SHUT_MASK__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_T2_SHUT_MASK)));
}

/** FAULT_FAULT_T2_SHUT_MASK__SET() sets FAULT_T2_SHUT_MASK to given value.
 *
 * When writing to FAULT_T2_SHUT_MASK, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_T2_SHUT_MASK
 */
__FAULT_INLINE void FAULT_FAULT_T2_SHUT_MASK__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_T2_SHUT_MASK__ADDRESS(idp), value);
}

/** FAULT_FAULT_T2_SHUT_MASK__GET() gets FAULT_T2_SHUT_MASK's current value.
 *
 * When reading from FAULT_T2_SHUT_MASK, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_T2_SHUT_MASK
 */
__FAULT_INLINE uint32_t FAULT_FAULT_T2_SHUT_MASK__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_T2_SHUT_MASK__ADDRESS(idp));
}

/* ------------ FAULT.FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP ------------ */

/**
<pre>
  FAULT.FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP:

    "T2" shutdown mask for "Loop" faults.  Individual faults are enabled for T2 shutdown when their corresponding bit is high.  Enabled faults disable the loop output and assert the shutdown interrupt aligned with the T2 ramp time which typically aligns with the falling edge of the primary side PWM pulse.  Note that when corresponding bits in both fault_shut_mask_loop and fault_t2_shut_mask_loop are set to 1, the immediate shutdown behavior of fault_shut_mask_loop is implemented.
    This register should not be written directly but rather through PMBus command FW_CONFIG_FAULTS bits [199:168] which have a 1 to 1 mapping with bits [31:0] of this register.
    <start table_with_header>
    Bit "Fault" "Bit" "Fault"
    0 "Reserved"   "1" "VOUT_OV_FAULT "
    2 "VOUT_OV_WARN"  "3" "VOUT_UV_FAULT"
    4 "VOUT_UV_WARN"  "5" "VIN_OV_FAULT"
    6 "VIN_OV_WARN"  "7"  "VIN_UV_FAULT"
    8 "VIN_UV_WARN" "9" "IOUT_OC_FAULT"
    10 "IOUT_OC_LV_FAULT" "11" "IOUT_OC_WARN"
    12 "IOUT_UC_FAULT" "13" "MFR_IOUT_OC_FAST"
    14 "IIN_OC_FAULT"  "15" "IIN_OC_WARN"
    16 "OT_FAULT"  "17" "OT_WARN"
    18 "UT_FAULT"  "19" "UT_WARN"
    20 "POWER_LIMIT_MODE" "21" "ISHARE_FAULT"
    22 "VOUT_MAX_MIN_WARN" "23" "SYNC_FAULT"
    24-31 "Unused"
    <end table>

</pre> */

#define FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Pos  0                                                                      /*!< Right-most bit position of fault_t2_shut_mask_loop in FAULT.FAULT_T2_SHUT_MASK */
#define FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Msk  (0xFFFFFFFFUL << FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Pos) /*!< Mask for fault_t2_shut_mask_loop in FAULT.FAULT_T2_SHUT_MASK */
#define FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Shift(v) (((v) << FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Pos) & FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Msk) /*!< Shift value 'v' into fault_t2_shut_mask_loop and mask 'v' to fit it into fault_t2_shut_mask_loop field */

/** FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__SET() sets FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP to given value.
 *
 * When writing to FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_T2_SHUT_MASK__GET(idp);
    reg = (reg & ~FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Shift((uint32_t)bf_value)));
    FAULT_FAULT_T2_SHUT_MASK__SET(idp, reg);
}

/** FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__GET() gets FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP's current value.
 *
 * When reading from FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_T2_SHUT_MASK__GET(idp);
    reg = (reg & FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__MODIFY() modifies FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_T2_SHUT_MASK.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_T2_SHUT_MASK
 * @param bf_value new value for FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP
 * @return new value of FAULT.FAULT_T2_SHUT_MASK
 */
__FAULT_INLINE uint32_t FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__EXTRACT() extracts FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_T2_SHUT_MASK.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_T2_SHUT_MASK
 * @return current value of FAULT_T2_SHUT_MASK.FAULT_T2_SHUT_MASK_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_T2_SHUT_MASK__FAULT_T2_SHUT_MASK_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_ENABLE_LOOP member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_ENABLE_LOOP__ADDRESS returns the address of member FAULT_ENABLE_LOOP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_ENABLE_LOOP
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_ENABLE_LOOP__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_ENABLE_LOOP)));
}

/** FAULT_FAULT_ENABLE_LOOP__SET() sets FAULT_ENABLE_LOOP to given value.
 *
 * When writing to FAULT_ENABLE_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_ENABLE_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_ENABLE_LOOP__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_ENABLE_LOOP__ADDRESS(idp), value);
}

/** FAULT_FAULT_ENABLE_LOOP__GET() gets FAULT_ENABLE_LOOP's current value.
 *
 * When reading from FAULT_ENABLE_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_ENABLE_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_ENABLE_LOOP__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_ENABLE_LOOP__ADDRESS(idp));
}

/* --------------- FAULT.FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP --------------- */

/**
<pre>
  FAULT.FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP:

    Fault enable for "Loop" faults.  Individual faults are enabled for fault interrupt generation when their corresponding bit is high.  This register is controlled by FW based on the PMBus command FW_CONFIG_FAULTS bits [103:72] which have a 1 to 1 mapping with bits [31:0] of this register.
    <start table_with_header>
    Bit "Fault" "Bit" "Fault"
    0 "Reserved"   "1" "VOUT_OV_FAULT "
    2 "VOUT_OV_WARN"  "3" "VOUT_UV_FAULT"
    4 "VOUT_UV_WARN"  "5" "VIN_OV_FAULT"
    6 "VIN_OV_WARN"  "7"  "VIN_UV_FAULT"
    8 "VIN_UV_WARN" "9" "IOUT_OC_FAULT"
    10 "IOUT_OC_LV_FAULT" "11" "IOUT_OC_WARN"
    12 "IOUT_UC_FAULT" "13" "MFR_IOUT_OC_FAST"
    14 "IIN_OC_FAULT"  "15" "IIN_OC_WARN"
    16 "OT_FAULT"  "17" "OT_WARN"
    18 "UT_FAULT"  "19" "UT_WARN"
    20 "POWER_LIMIT_MODE" "21" "ISHARE_FAULT"
    22 "VOUT_MAX_MIN_WARN" "23" "SYNC_FAULT"
    24-31 "Unused"
    <end table>

</pre> */

#define FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Pos         0                                                                      /*!< Right-most bit position of fault_enable_loop in FAULT.FAULT_ENABLE_LOOP */
#define FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Msk         (0xFFFFFFFFUL << FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Pos)      /*!< Mask for fault_enable_loop in FAULT.FAULT_ENABLE_LOOP */
#define FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Shift(v)    (((v) << FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Pos) & FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Msk) /*!< Shift value 'v' into fault_enable_loop and mask 'v' to fit it into fault_enable_loop field */

/** FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__SET() sets FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP to given value.
 *
 * When writing to FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_ENABLE_LOOP__GET(idp);
    reg = (reg & ~FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Shift((uint32_t)bf_value)));
    FAULT_FAULT_ENABLE_LOOP__SET(idp, reg);
}

/** FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__GET() gets FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP's current value.
 *
 * When reading from FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_ENABLE_LOOP__GET(idp);
    reg = (reg & FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__MODIFY() modifies FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_ENABLE_LOOP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_ENABLE_LOOP
 * @param bf_value new value for FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP
 * @return new value of FAULT.FAULT_ENABLE_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__EXTRACT() extracts FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_ENABLE_LOOP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_ENABLE_LOOP
 * @return current value of FAULT_ENABLE_LOOP.FAULT_ENABLE_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_ENABLE_LOOP__FAULT_ENABLE_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_VOUT_OV_FLT member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_VOUT_OV_FLT__ADDRESS returns the address of member FAULT_VOUT_OV_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_VOUT_OV_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_VOUT_OV_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_VOUT_OV_FLT)));
}

/** FAULT_FAULT_VOUT_OV_FLT__SET() sets FAULT_VOUT_OV_FLT to given value.
 *
 * When writing to FAULT_VOUT_OV_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_VOUT_OV_FLT
 */
__FAULT_INLINE void FAULT_FAULT_VOUT_OV_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_VOUT_OV_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_VOUT_OV_FLT__GET() gets FAULT_VOUT_OV_FLT's current value.
 *
 * When reading from FAULT_VOUT_OV_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VOUT_OV_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_OV_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_VOUT_OV_FLT__ADDRESS(idp));
}

/* ----------- FAULT.FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH ----------- */

/**
<pre>
  FAULT.FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH:

    Output over voltage fault threshold.  Note that this threshold is defined with respect to the voltage at the VSEN pin, after the vout sense resistor divider.
    Computed from PMBus command as follows:
    <start table>
    "fault_vout_ovp_fault_thresh(U12.-2) = VOUT_OV_FAULT_LIMIT(U16-X.X) * VOUT_SCALE_LOOP(U0.16) * 200 / (2^X * 2^16)"
    "where, X = negative of VOUT_MODE exponent"
    <end table>
    LSB = 5mV, Range = 0.0 to 5.115V

</pre> */

#define FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Pos 0                                                                      /*!< Right-most bit position of fault_vout_ov_fault_thresh in FAULT.FAULT_VOUT_OV_FLT */
#define FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Msk (0x000003FFUL << FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Pos) /*!< Mask for fault_vout_ov_fault_thresh in FAULT.FAULT_VOUT_OV_FLT */
#define FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Shift(v) (((v) << FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Pos) & FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Msk) /*!< Shift value 'v' into fault_vout_ov_fault_thresh and mask 'v' to fit it into fault_vout_ov_fault_thresh field */

/** FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__SET() sets FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH to given value.
 *
 * When writing to FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_VOUT_OV_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_VOUT_OV_FLT__SET(idp, reg);
}

/** FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__GET() gets FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH's current value.
 *
 * When reading from FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_VOUT_OV_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__MODIFY() modifies FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_VOUT_OV_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_VOUT_OV_FLT
 * @param bf_value new value for FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH
 * @return new value of FAULT.FAULT_VOUT_OV_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__EXTRACT() extracts FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_VOUT_OV_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_VOUT_OV_FLT
 * @return current value of FAULT_VOUT_OV_FLT.FAULT_VOUT_OV_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VOUT_OV_FLT__FAULT_VOUT_OV_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_VOUT_OV_WRN member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_VOUT_OV_WRN__ADDRESS returns the address of member FAULT_VOUT_OV_WRN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_VOUT_OV_WRN
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_VOUT_OV_WRN__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_VOUT_OV_WRN)));
}

/** FAULT_FAULT_VOUT_OV_WRN__SET() sets FAULT_VOUT_OV_WRN to given value.
 *
 * When writing to FAULT_VOUT_OV_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_VOUT_OV_WRN
 */
__FAULT_INLINE void FAULT_FAULT_VOUT_OV_WRN__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_VOUT_OV_WRN__ADDRESS(idp), value);
}

/** FAULT_FAULT_VOUT_OV_WRN__GET() gets FAULT_VOUT_OV_WRN's current value.
 *
 * When reading from FAULT_VOUT_OV_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VOUT_OV_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_OV_WRN__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_VOUT_OV_WRN__ADDRESS(idp));
}

/* ----------- FAULT.FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH ----------- */

/**
<pre>
  FAULT.FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH:

    Output over voltage warning threshold.  Note that this threshold is defined with respect to the voltage at the VSEN pin, after the vout sense resistor divider.
    Computed from PMBus command as follows:
    <start table>
    "fault_vout_ovp_warn_thresh(U12.-2) = VOUT_OV_WARN_LIMIT(U16-X.X) * VOUT_SCALE_LOOP(U0.16) * 200 / (2^X * 2^16)"
    "where, X = negative of VOUT_MODE exponent"
    <end table>
    LSB = 5mV, Range = 0.0 to 5.115V

</pre> */

#define FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Pos 0                                                                      /*!< Right-most bit position of fault_vout_ov_warn_thresh in FAULT.FAULT_VOUT_OV_WRN */
#define FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Msk (0x000003FFUL << FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Pos) /*!< Mask for fault_vout_ov_warn_thresh in FAULT.FAULT_VOUT_OV_WRN */
#define FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Shift(v) (((v) << FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Pos) & FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Msk) /*!< Shift value 'v' into fault_vout_ov_warn_thresh and mask 'v' to fit it into fault_vout_ov_warn_thresh field */

/** FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__SET() sets FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH to given value.
 *
 * When writing to FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_VOUT_OV_WRN__GET(idp);
    reg = (reg & ~FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_VOUT_OV_WRN__SET(idp, reg);
}

/** FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__GET() gets FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH's current value.
 *
 * When reading from FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_VOUT_OV_WRN__GET(idp);
    reg = (reg & FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__MODIFY() modifies FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_VOUT_OV_WRN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_VOUT_OV_WRN
 * @param bf_value new value for FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH
 * @return new value of FAULT.FAULT_VOUT_OV_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__EXTRACT() extracts FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_VOUT_OV_WRN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_VOUT_OV_WRN
 * @return current value of FAULT_VOUT_OV_WRN.FAULT_VOUT_OV_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VOUT_OV_WRN__FAULT_VOUT_OV_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_VOUT_UV_FLT member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_VOUT_UV_FLT__ADDRESS returns the address of member FAULT_VOUT_UV_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_VOUT_UV_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_VOUT_UV_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_VOUT_UV_FLT)));
}

/** FAULT_FAULT_VOUT_UV_FLT__SET() sets FAULT_VOUT_UV_FLT to given value.
 *
 * When writing to FAULT_VOUT_UV_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_VOUT_UV_FLT
 */
__FAULT_INLINE void FAULT_FAULT_VOUT_UV_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_VOUT_UV_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_VOUT_UV_FLT__GET() gets FAULT_VOUT_UV_FLT's current value.
 *
 * When reading from FAULT_VOUT_UV_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VOUT_UV_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_UV_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_VOUT_UV_FLT__ADDRESS(idp));
}

/* ----------- FAULT.FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH ----------- */

/**
<pre>
  FAULT.FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH:

    Output under voltage fault threshold.  Note that this threshold is defined with respect to the voltage at the VSEN pin, after the vout sense resistor divider.
    Computed from PMBus command as follows:
    <start table>
    "fault_vout_uvp_fault_thresh(U12.-2) = VOUT_UV_FAULT_LIMIT(U16-X.X) * VOUT_SCALE_LOOP(U0.16) * 200 / (2^X * 2^16)"
    "where, X = negative of VOUT_MODE exponent"
    <end table>
    LSB = 5mV, Range = 0.0 to 5.115V

</pre> */

#define FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Pos 0                                                                      /*!< Right-most bit position of fault_vout_uv_fault_thresh in FAULT.FAULT_VOUT_UV_FLT */
#define FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Msk (0x000003FFUL << FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Pos) /*!< Mask for fault_vout_uv_fault_thresh in FAULT.FAULT_VOUT_UV_FLT */
#define FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Shift(v) (((v) << FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Pos) & FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Msk) /*!< Shift value 'v' into fault_vout_uv_fault_thresh and mask 'v' to fit it into fault_vout_uv_fault_thresh field */

/** FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__SET() sets FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH to given value.
 *
 * When writing to FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_VOUT_UV_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_VOUT_UV_FLT__SET(idp, reg);
}

/** FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__GET() gets FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH's current value.
 *
 * When reading from FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_VOUT_UV_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__MODIFY() modifies FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_VOUT_UV_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_VOUT_UV_FLT
 * @param bf_value new value for FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH
 * @return new value of FAULT.FAULT_VOUT_UV_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__EXTRACT() extracts FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_VOUT_UV_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_VOUT_UV_FLT
 * @return current value of FAULT_VOUT_UV_FLT.FAULT_VOUT_UV_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VOUT_UV_FLT__FAULT_VOUT_UV_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_VOUT_UV_WRN member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_VOUT_UV_WRN__ADDRESS returns the address of member FAULT_VOUT_UV_WRN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_VOUT_UV_WRN
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_VOUT_UV_WRN__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_VOUT_UV_WRN)));
}

/** FAULT_FAULT_VOUT_UV_WRN__SET() sets FAULT_VOUT_UV_WRN to given value.
 *
 * When writing to FAULT_VOUT_UV_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_VOUT_UV_WRN
 */
__FAULT_INLINE void FAULT_FAULT_VOUT_UV_WRN__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_VOUT_UV_WRN__ADDRESS(idp), value);
}

/** FAULT_FAULT_VOUT_UV_WRN__GET() gets FAULT_VOUT_UV_WRN's current value.
 *
 * When reading from FAULT_VOUT_UV_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VOUT_UV_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_UV_WRN__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_VOUT_UV_WRN__ADDRESS(idp));
}

/* ----------- FAULT.FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH ----------- */

/**
<pre>
  FAULT.FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH:

    Output under voltage warning threshold.  Note that this threshold is defined with respect to the voltage at the VSEN pin, after the vout sense resistor divider.
    Computed from PMBus command as follows:
    <start table>
    "fault_vout_uvp_warn_thresh(U12.-2) = VOUT_UV_WARN_LIMIT(U16-X.X) * VOUT_SCALE_LOOP(U0.16) * 200 / (2^X * 2^16)"
    "where, X = negative of VOUT_MODE exponent"
    <end table>
    LSB = 5mV, Range = 0.0 to 5.115V

</pre> */

#define FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Pos 0                                                                      /*!< Right-most bit position of fault_vout_uv_warn_thresh in FAULT.FAULT_VOUT_UV_WRN */
#define FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Msk (0x000003FFUL << FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Pos) /*!< Mask for fault_vout_uv_warn_thresh in FAULT.FAULT_VOUT_UV_WRN */
#define FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Shift(v) (((v) << FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Pos) & FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Msk) /*!< Shift value 'v' into fault_vout_uv_warn_thresh and mask 'v' to fit it into fault_vout_uv_warn_thresh field */

/** FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__SET() sets FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH to given value.
 *
 * When writing to FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_VOUT_UV_WRN__GET(idp);
    reg = (reg & ~FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_VOUT_UV_WRN__SET(idp, reg);
}

/** FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__GET() gets FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH's current value.
 *
 * When reading from FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_VOUT_UV_WRN__GET(idp);
    reg = (reg & FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__MODIFY() modifies FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_VOUT_UV_WRN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_VOUT_UV_WRN
 * @param bf_value new value for FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH
 * @return new value of FAULT.FAULT_VOUT_UV_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__EXTRACT() extracts FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_VOUT_UV_WRN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_VOUT_UV_WRN
 * @return current value of FAULT_VOUT_UV_WRN.FAULT_VOUT_UV_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VOUT_UV_WRN__FAULT_VOUT_UV_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_VIN_OV_FLT member of FAULT_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_VIN_OV_FLT__ADDRESS returns the address of member FAULT_VIN_OV_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_VIN_OV_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_VIN_OV_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_VIN_OV_FLT)));
}

/** FAULT_FAULT_VIN_OV_FLT__SET() sets FAULT_VIN_OV_FLT to given value.
 *
 * When writing to FAULT_VIN_OV_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_VIN_OV_FLT
 */
__FAULT_INLINE void FAULT_FAULT_VIN_OV_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_VIN_OV_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_VIN_OV_FLT__GET() gets FAULT_VIN_OV_FLT's current value.
 *
 * When reading from FAULT_VIN_OV_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VIN_OV_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_OV_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_VIN_OV_FLT__ADDRESS(idp));
}

/* ------------ FAULT.FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH ------------ */

/**
<pre>
  FAULT.FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH:

    Input over voltage fault threshold.
    Computed from PMBus command as follows:
    <start table>
    "fault_vin_ovp_fault_thresh(U7.3) = (VIN_OV_FAULT_LIMIT(U7.3)*2^-3"
    <end table>
    LSB = 125mV, Range = 0.0 to 127.875V

</pre> */

#define FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Pos  0                                                                      /*!< Right-most bit position of fault_vin_ov_fault_thresh in FAULT.FAULT_VIN_OV_FLT */
#define FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Msk  (0x000003FFUL << FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Pos) /*!< Mask for fault_vin_ov_fault_thresh in FAULT.FAULT_VIN_OV_FLT */
#define FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Shift(v) (((v) << FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Pos) & FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Msk) /*!< Shift value 'v' into fault_vin_ov_fault_thresh and mask 'v' to fit it into fault_vin_ov_fault_thresh field */

/** FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__SET() sets FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH to given value.
 *
 * When writing to FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_VIN_OV_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_VIN_OV_FLT__SET(idp, reg);
}

/** FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__GET() gets FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH's current value.
 *
 * When reading from FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_VIN_OV_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__MODIFY() modifies FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_VIN_OV_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_VIN_OV_FLT
 * @param bf_value new value for FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH
 * @return new value of FAULT.FAULT_VIN_OV_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__EXTRACT() extracts FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_VIN_OV_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_VIN_OV_FLT
 * @return current value of FAULT_VIN_OV_FLT.FAULT_VIN_OV_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VIN_OV_FLT__FAULT_VIN_OV_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_VIN_OV_WRN member of FAULT_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_VIN_OV_WRN__ADDRESS returns the address of member FAULT_VIN_OV_WRN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_VIN_OV_WRN
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_VIN_OV_WRN__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_VIN_OV_WRN)));
}

/** FAULT_FAULT_VIN_OV_WRN__SET() sets FAULT_VIN_OV_WRN to given value.
 *
 * When writing to FAULT_VIN_OV_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_VIN_OV_WRN
 */
__FAULT_INLINE void FAULT_FAULT_VIN_OV_WRN__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_VIN_OV_WRN__ADDRESS(idp), value);
}

/** FAULT_FAULT_VIN_OV_WRN__GET() gets FAULT_VIN_OV_WRN's current value.
 *
 * When reading from FAULT_VIN_OV_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VIN_OV_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_OV_WRN__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_VIN_OV_WRN__ADDRESS(idp));
}

/* ------------ FAULT.FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH ------------ */

/**
<pre>
  FAULT.FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH:

    Input over voltage warning threshold.
    Computed from PMBus command as follows:
    <start table>
    "fault_vin_ovp_warn_thresh(U7.3) = (VIN_OV_WARN_LIMIT(U7.3)*2^-3"
    <end table>
    LSB = 125mV, Range = 0.0 to 127.875V

</pre> */

#define FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Pos   0                                                                      /*!< Right-most bit position of fault_vin_ov_warn_thresh in FAULT.FAULT_VIN_OV_WRN */
#define FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Msk   (0x000003FFUL << FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Pos) /*!< Mask for fault_vin_ov_warn_thresh in FAULT.FAULT_VIN_OV_WRN */
#define FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Shift(v) (((v) << FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Pos) & FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Msk) /*!< Shift value 'v' into fault_vin_ov_warn_thresh and mask 'v' to fit it into fault_vin_ov_warn_thresh field */

/** FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__SET() sets FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH to given value.
 *
 * When writing to FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_VIN_OV_WRN__GET(idp);
    reg = (reg & ~FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_VIN_OV_WRN__SET(idp, reg);
}

/** FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__GET() gets FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH's current value.
 *
 * When reading from FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_VIN_OV_WRN__GET(idp);
    reg = (reg & FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__MODIFY() modifies FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_VIN_OV_WRN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_VIN_OV_WRN
 * @param bf_value new value for FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH
 * @return new value of FAULT.FAULT_VIN_OV_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__EXTRACT() extracts FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_VIN_OV_WRN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_VIN_OV_WRN
 * @return current value of FAULT_VIN_OV_WRN.FAULT_VIN_OV_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VIN_OV_WRN__FAULT_VIN_OV_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_VIN_UV_FLT member of FAULT_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_VIN_UV_FLT__ADDRESS returns the address of member FAULT_VIN_UV_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_VIN_UV_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_VIN_UV_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_VIN_UV_FLT)));
}

/** FAULT_FAULT_VIN_UV_FLT__SET() sets FAULT_VIN_UV_FLT to given value.
 *
 * When writing to FAULT_VIN_UV_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_VIN_UV_FLT
 */
__FAULT_INLINE void FAULT_FAULT_VIN_UV_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_VIN_UV_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_VIN_UV_FLT__GET() gets FAULT_VIN_UV_FLT's current value.
 *
 * When reading from FAULT_VIN_UV_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VIN_UV_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_UV_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_VIN_UV_FLT__ADDRESS(idp));
}

/* ------------ FAULT.FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH ------------ */

/**
<pre>
  FAULT.FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH:

    Input under voltage fault threshold.
    Computed from PMBus command as follows:
    <start table>
    "fault_vin_uvp_fault_thresh(U7.3) = (VIN_UV_FAULT_LIMIT(U7.3)*2^-3"
    <end table>
    LSB = 125mV, Range = 0.0 to 127.875V

</pre> */

#define FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Pos  0                                                                      /*!< Right-most bit position of fault_vin_uv_fault_thresh in FAULT.FAULT_VIN_UV_FLT */
#define FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Msk  (0x000003FFUL << FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Pos) /*!< Mask for fault_vin_uv_fault_thresh in FAULT.FAULT_VIN_UV_FLT */
#define FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Shift(v) (((v) << FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Pos) & FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Msk) /*!< Shift value 'v' into fault_vin_uv_fault_thresh and mask 'v' to fit it into fault_vin_uv_fault_thresh field */

/** FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__SET() sets FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH to given value.
 *
 * When writing to FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_VIN_UV_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_VIN_UV_FLT__SET(idp, reg);
}

/** FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__GET() gets FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH's current value.
 *
 * When reading from FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_VIN_UV_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__MODIFY() modifies FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_VIN_UV_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_VIN_UV_FLT
 * @param bf_value new value for FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH
 * @return new value of FAULT.FAULT_VIN_UV_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__EXTRACT() extracts FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_VIN_UV_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_VIN_UV_FLT
 * @return current value of FAULT_VIN_UV_FLT.FAULT_VIN_UV_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VIN_UV_FLT__FAULT_VIN_UV_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_VIN_UV_WRN member of FAULT_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_VIN_UV_WRN__ADDRESS returns the address of member FAULT_VIN_UV_WRN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_VIN_UV_WRN
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_VIN_UV_WRN__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_VIN_UV_WRN)));
}

/** FAULT_FAULT_VIN_UV_WRN__SET() sets FAULT_VIN_UV_WRN to given value.
 *
 * When writing to FAULT_VIN_UV_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_VIN_UV_WRN
 */
__FAULT_INLINE void FAULT_FAULT_VIN_UV_WRN__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_VIN_UV_WRN__ADDRESS(idp), value);
}

/** FAULT_FAULT_VIN_UV_WRN__GET() gets FAULT_VIN_UV_WRN's current value.
 *
 * When reading from FAULT_VIN_UV_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VIN_UV_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_UV_WRN__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_VIN_UV_WRN__ADDRESS(idp));
}

/* ------------ FAULT.FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH ------------ */

/**
<pre>
  FAULT.FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH:

    Input under voltage warning threshold.
    Computed from PMBus command as follows:
    <start table>
    "fault_vin_uvp_warn_thresh(U7.3) = (VIN_UV_WARN_LIMIT(U7.3)*2^-3"
    <end table>
    LSB = 125mV, Range = 0.0 to 127.875V

</pre> */

#define FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Pos   0                                                                      /*!< Right-most bit position of fault_vin_uv_warn_thresh in FAULT.FAULT_VIN_UV_WRN */
#define FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Msk   (0x000003FFUL << FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Pos) /*!< Mask for fault_vin_uv_warn_thresh in FAULT.FAULT_VIN_UV_WRN */
#define FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Shift(v) (((v) << FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Pos) & FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Msk) /*!< Shift value 'v' into fault_vin_uv_warn_thresh and mask 'v' to fit it into fault_vin_uv_warn_thresh field */

/** FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__SET() sets FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH to given value.
 *
 * When writing to FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_VIN_UV_WRN__GET(idp);
    reg = (reg & ~FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_VIN_UV_WRN__SET(idp, reg);
}

/** FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__GET() gets FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH's current value.
 *
 * When reading from FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_VIN_UV_WRN__GET(idp);
    reg = (reg & FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__MODIFY() modifies FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_VIN_UV_WRN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_VIN_UV_WRN
 * @param bf_value new value for FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH
 * @return new value of FAULT.FAULT_VIN_UV_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__EXTRACT() extracts FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_VIN_UV_WRN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_VIN_UV_WRN
 * @return current value of FAULT_VIN_UV_WRN.FAULT_VIN_UV_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_VIN_UV_WRN__FAULT_VIN_UV_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_IOUT_OC_FLT member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_IOUT_OC_FLT__ADDRESS returns the address of member FAULT_IOUT_OC_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_IOUT_OC_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_IOUT_OC_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_IOUT_OC_FLT)));
}

/** FAULT_FAULT_IOUT_OC_FLT__SET() sets FAULT_IOUT_OC_FLT to given value.
 *
 * When writing to FAULT_IOUT_OC_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_IOUT_OC_FLT
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_OC_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_IOUT_OC_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_IOUT_OC_FLT__GET() gets FAULT_IOUT_OC_FLT's current value.
 *
 * When reading from FAULT_IOUT_OC_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_OC_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_OC_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_IOUT_OC_FLT__ADDRESS(idp));
}

/* ----------- FAULT.FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH ----------- */

/**
<pre>
  FAULT.FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH:

    Output over current fault threshold
    Computed from PMBus command as follows:
    <start table>
    "fault_iout_oc_fault_thresh(U8.0) = IOUT_OC_FAULT_LIMIT(U8.0)"
    <end table>
    LSB = 1A, Range = 0 to 255A

</pre> */

#define FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Pos 0                                                                      /*!< Right-most bit position of fault_iout_oc_fault_thresh in FAULT.FAULT_IOUT_OC_FLT */
#define FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Msk (0x000000FFUL << FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Pos) /*!< Mask for fault_iout_oc_fault_thresh in FAULT.FAULT_IOUT_OC_FLT */
#define FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Shift(v) (((v) << FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Pos) & FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Msk) /*!< Shift value 'v' into fault_iout_oc_fault_thresh and mask 'v' to fit it into fault_iout_oc_fault_thresh field */

/** FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__SET() sets FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH to given value.
 *
 * When writing to FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_IOUT_OC_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_IOUT_OC_FLT__SET(idp, reg);
}

/** FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__GET() gets FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH's current value.
 *
 * When reading from FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_IOUT_OC_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__MODIFY() modifies FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_IOUT_OC_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_IOUT_OC_FLT
 * @param bf_value new value for FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH
 * @return new value of FAULT.FAULT_IOUT_OC_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__EXTRACT() extracts FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_IOUT_OC_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_IOUT_OC_FLT
 * @return current value of FAULT_IOUT_OC_FLT.FAULT_IOUT_OC_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_OC_FLT__FAULT_IOUT_OC_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_IOUT_LV_FLT member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_IOUT_LV_FLT__ADDRESS returns the address of member FAULT_IOUT_LV_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_IOUT_LV_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_IOUT_LV_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_IOUT_LV_FLT)));
}

/** FAULT_FAULT_IOUT_LV_FLT__SET() sets FAULT_IOUT_LV_FLT to given value.
 *
 * When writing to FAULT_IOUT_LV_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_IOUT_LV_FLT
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_LV_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_IOUT_LV_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_IOUT_LV_FLT__GET() gets FAULT_IOUT_LV_FLT's current value.
 *
 * When reading from FAULT_IOUT_LV_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_LV_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_LV_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_IOUT_LV_FLT__ADDRESS(idp));
}

/* --------- FAULT.FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH --------- */

/**
<pre>
  FAULT.FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH:

    Output over current low voltage fault threshold.  Note that this threshold is defined with respect to the voltage at the VSEN pin, after the vout sense resistor divider.
    Computed from PMBus command as follows:
    <start table>
    "fault_iout_oc_lv_fault_thresh(U12.-2) = IOUT_OC_LV_FAULT_LIMIT(U16-X.X) * VOUT_SCALE_LOOP(U0.16) * 200 / (2^X * 2^16)"
    "where, X = negative of VOUT_MODE exponent"
    <end table>
    LSB = 5mV, Range = 0.0 to 5.115V

</pre> */

#define FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Pos 0                                                                      /*!< Right-most bit position of fault_iout_oc_lv_fault_thresh in FAULT.FAULT_IOUT_LV_FLT */
#define FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Msk (0x000003FFUL << FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Pos) /*!< Mask for fault_iout_oc_lv_fault_thresh in FAULT.FAULT_IOUT_LV_FLT */
#define FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Shift(v) (((v) << FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Pos) & FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Msk) /*!< Shift value 'v' into fault_iout_oc_lv_fault_thresh and mask 'v' to fit it into fault_iout_oc_lv_fault_thresh field */

/** FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__SET() sets FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH to given value.
 *
 * When writing to FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_IOUT_LV_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_IOUT_LV_FLT__SET(idp, reg);
}

/** FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__GET() gets FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH's current value.
 *
 * When reading from FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_IOUT_LV_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__MODIFY() modifies FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_IOUT_LV_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_IOUT_LV_FLT
 * @param bf_value new value for FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH
 * @return new value of FAULT.FAULT_IOUT_LV_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__EXTRACT() extracts FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_IOUT_LV_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_IOUT_LV_FLT
 * @return current value of FAULT_IOUT_LV_FLT.FAULT_IOUT_OC_LV_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_LV_FLT__FAULT_IOUT_OC_LV_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_IOUT_OC_WRN member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_IOUT_OC_WRN__ADDRESS returns the address of member FAULT_IOUT_OC_WRN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_IOUT_OC_WRN
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_IOUT_OC_WRN__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_IOUT_OC_WRN)));
}

/** FAULT_FAULT_IOUT_OC_WRN__SET() sets FAULT_IOUT_OC_WRN to given value.
 *
 * When writing to FAULT_IOUT_OC_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_IOUT_OC_WRN
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_OC_WRN__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_IOUT_OC_WRN__ADDRESS(idp), value);
}

/** FAULT_FAULT_IOUT_OC_WRN__GET() gets FAULT_IOUT_OC_WRN's current value.
 *
 * When reading from FAULT_IOUT_OC_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_OC_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_OC_WRN__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_IOUT_OC_WRN__ADDRESS(idp));
}

/* ----------- FAULT.FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH ----------- */

/**
<pre>
  FAULT.FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH:

    Output over current warn threshold.
    Computed from PMBus command as follows:
    <start table>
    "fault_iout_oc_warn_thresh(U8.0) = IOUT_OC_WARN_LIMIT(U8.0)"
    <end table>
    LSB = 1A, Range = 0 to 255A

</pre> */

#define FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Pos 0                                                                      /*!< Right-most bit position of fault_iout_oc_warn_thresh in FAULT.FAULT_IOUT_OC_WRN */
#define FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Msk (0x000000FFUL << FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Pos) /*!< Mask for fault_iout_oc_warn_thresh in FAULT.FAULT_IOUT_OC_WRN */
#define FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Shift(v) (((v) << FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Pos) & FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Msk) /*!< Shift value 'v' into fault_iout_oc_warn_thresh and mask 'v' to fit it into fault_iout_oc_warn_thresh field */

/** FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__SET() sets FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH to given value.
 *
 * When writing to FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_IOUT_OC_WRN__GET(idp);
    reg = (reg & ~FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_IOUT_OC_WRN__SET(idp, reg);
}

/** FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__GET() gets FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH's current value.
 *
 * When reading from FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_IOUT_OC_WRN__GET(idp);
    reg = (reg & FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__MODIFY() modifies FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_IOUT_OC_WRN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_IOUT_OC_WRN
 * @param bf_value new value for FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH
 * @return new value of FAULT.FAULT_IOUT_OC_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__EXTRACT() extracts FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_IOUT_OC_WRN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_IOUT_OC_WRN
 * @return current value of FAULT_IOUT_OC_WRN.FAULT_IOUT_OC_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_OC_WRN__FAULT_IOUT_OC_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_IOUT_UC_FLT member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_IOUT_UC_FLT__ADDRESS returns the address of member FAULT_IOUT_UC_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_IOUT_UC_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_IOUT_UC_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_IOUT_UC_FLT)));
}

/** FAULT_FAULT_IOUT_UC_FLT__SET() sets FAULT_IOUT_UC_FLT to given value.
 *
 * When writing to FAULT_IOUT_UC_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_IOUT_UC_FLT
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_UC_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_IOUT_UC_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_IOUT_UC_FLT__GET() gets FAULT_IOUT_UC_FLT's current value.
 *
 * When reading from FAULT_IOUT_UC_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_UC_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_UC_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_IOUT_UC_FLT__ADDRESS(idp));
}

/* ----------- FAULT.FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH ----------- */

/**
<pre>
  FAULT.FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH:

    Output under current fault threshold.  Fault asserted when the cycle averaged output current is below this threshold.
    Computed from PMBus command as follows:
    <start table>
    "fault_iout_uc_fault_thresh(S8.0) = IOUT_UC_FAULT_LIMIT(S8.0)"
    <end table>
    LSB = 1A, Range = -128 to +127A

</pre> */

#define FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Pos 0                                                                      /*!< Right-most bit position of fault_iout_uc_fault_thresh in FAULT.FAULT_IOUT_UC_FLT */
#define FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Msk (0x000000FFUL << FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Pos) /*!< Mask for fault_iout_uc_fault_thresh in FAULT.FAULT_IOUT_UC_FLT */
#define FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Shift(v) (((v) << FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Pos) & FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Msk) /*!< Shift value 'v' into fault_iout_uc_fault_thresh and mask 'v' to fit it into fault_iout_uc_fault_thresh field */

/** FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__SET() sets FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH to given value.
 *
 * When writing to FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_IOUT_UC_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_IOUT_UC_FLT__SET(idp, reg);
}

/** FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__GET() gets FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH's current value.
 *
 * When reading from FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_IOUT_UC_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__MODIFY() modifies FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_IOUT_UC_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_IOUT_UC_FLT
 * @param bf_value new value for FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH
 * @return new value of FAULT.FAULT_IOUT_UC_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__EXTRACT() extracts FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_IOUT_UC_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_IOUT_UC_FLT
 * @return current value of FAULT_IOUT_UC_FLT.FAULT_IOUT_UC_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_UC_FLT__FAULT_IOUT_UC_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_MFR_OC_FLT member of FAULT_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_MFR_OC_FLT__ADDRESS returns the address of member FAULT_MFR_OC_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_MFR_OC_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_MFR_OC_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_MFR_OC_FLT)));
}

/** FAULT_FAULT_MFR_OC_FLT__SET() sets FAULT_MFR_OC_FLT to given value.
 *
 * When writing to FAULT_MFR_OC_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_MFR_OC_FLT
 */
__FAULT_INLINE void FAULT_FAULT_MFR_OC_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_MFR_OC_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_MFR_OC_FLT__GET() gets FAULT_MFR_OC_FLT's current value.
 *
 * When reading from FAULT_MFR_OC_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_MFR_OC_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_MFR_OC_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_MFR_OC_FLT__ADDRESS(idp));
}

/* ---------- FAULT.FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH ---------- */

/**
<pre>
  FAULT.FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH:

    Fast output over current fault threshold.
    Computed from PMBus command as follows:
    <start table>
    "fault_mfr_iout_oc_fast_thresh(U8.0) = MFR_IOUT_OC_FAST_FAULT_LIMIT(U8.0)"
    <end table>
    LSB = 1A, Range = 0 to 255A

</pre> */

#define FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Pos 0                                                                      /*!< Right-most bit position of fault_mfr_iout_oc_fast_thresh in FAULT.FAULT_MFR_OC_FLT */
#define FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Msk (0x000000FFUL << FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Pos) /*!< Mask for fault_mfr_iout_oc_fast_thresh in FAULT.FAULT_MFR_OC_FLT */
#define FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Shift(v) (((v) << FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Pos) & FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Msk) /*!< Shift value 'v' into fault_mfr_iout_oc_fast_thresh and mask 'v' to fit it into fault_mfr_iout_oc_fast_thresh field */

/** FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__SET() sets FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH to given value.
 *
 * When writing to FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_MFR_OC_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_MFR_OC_FLT__SET(idp, reg);
}

/** FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__GET() gets FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH's current value.
 *
 * When reading from FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_MFR_OC_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__MODIFY() modifies FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_MFR_OC_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_MFR_OC_FLT
 * @param bf_value new value for FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH
 * @return new value of FAULT.FAULT_MFR_OC_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__EXTRACT() extracts FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_MFR_OC_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_MFR_OC_FLT
 * @return current value of FAULT_MFR_OC_FLT.FAULT_MFR_IOUT_OC_FAST_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_MFR_OC_FLT__FAULT_MFR_IOUT_OC_FAST_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_IIN_OC_FLT member of FAULT_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_IIN_OC_FLT__ADDRESS returns the address of member FAULT_IIN_OC_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_IIN_OC_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_IIN_OC_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_IIN_OC_FLT)));
}

/** FAULT_FAULT_IIN_OC_FLT__SET() sets FAULT_IIN_OC_FLT to given value.
 *
 * When writing to FAULT_IIN_OC_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_IIN_OC_FLT
 */
__FAULT_INLINE void FAULT_FAULT_IIN_OC_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_IIN_OC_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_IIN_OC_FLT__GET() gets FAULT_IIN_OC_FLT's current value.
 *
 * When reading from FAULT_IIN_OC_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IIN_OC_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IIN_OC_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_IIN_OC_FLT__ADDRESS(idp));
}

/* ------------ FAULT.FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH ------------ */

/**
<pre>
  FAULT.FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH:

    Input over current fault threshold.
    Computed from PMBus command as follows:
    <start table>
    "fault_iin_ocp_fault_thresh(U6.2) = IIN_OC_FAULT_LIMIT(U6.2)"
    <end table>
    LSB = 0.25A, Range = 0.0 to 63.75A

</pre> */

#define FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Pos  0                                                                      /*!< Right-most bit position of fault_iin_oc_fault_thresh in FAULT.FAULT_IIN_OC_FLT */
#define FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Msk  (0x000000FFUL << FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Pos) /*!< Mask for fault_iin_oc_fault_thresh in FAULT.FAULT_IIN_OC_FLT */
#define FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Shift(v) (((v) << FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Pos) & FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Msk) /*!< Shift value 'v' into fault_iin_oc_fault_thresh and mask 'v' to fit it into fault_iin_oc_fault_thresh field */

/** FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__SET() sets FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH to given value.
 *
 * When writing to FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_IIN_OC_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_IIN_OC_FLT__SET(idp, reg);
}

/** FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__GET() gets FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH's current value.
 *
 * When reading from FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_IIN_OC_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__MODIFY() modifies FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_IIN_OC_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_IIN_OC_FLT
 * @param bf_value new value for FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH
 * @return new value of FAULT.FAULT_IIN_OC_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__EXTRACT() extracts FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_IIN_OC_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_IIN_OC_FLT
 * @return current value of FAULT_IIN_OC_FLT.FAULT_IIN_OC_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IIN_OC_FLT__FAULT_IIN_OC_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_IIN_OC_WRN member of FAULT_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_IIN_OC_WRN__ADDRESS returns the address of member FAULT_IIN_OC_WRN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_IIN_OC_WRN
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_IIN_OC_WRN__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_IIN_OC_WRN)));
}

/** FAULT_FAULT_IIN_OC_WRN__SET() sets FAULT_IIN_OC_WRN to given value.
 *
 * When writing to FAULT_IIN_OC_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_IIN_OC_WRN
 */
__FAULT_INLINE void FAULT_FAULT_IIN_OC_WRN__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_IIN_OC_WRN__ADDRESS(idp), value);
}

/** FAULT_FAULT_IIN_OC_WRN__GET() gets FAULT_IIN_OC_WRN's current value.
 *
 * When reading from FAULT_IIN_OC_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IIN_OC_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IIN_OC_WRN__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_IIN_OC_WRN__ADDRESS(idp));
}

/* ------------ FAULT.FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH ------------ */

/**
<pre>
  FAULT.FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH:

    Input over current warning threshold.
    Computed from PMBus command as follows:
    <start table>
    "fault_iin_ocp_warn_thresh(U6.2) = IIN_OC_WARN_LIMIT(U6.2)"
    <end table>
    LSB = 0.25A, Range = 0.0 to 63.75A

</pre> */

#define FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Pos   0                                                                      /*!< Right-most bit position of fault_iin_oc_warn_thresh in FAULT.FAULT_IIN_OC_WRN */
#define FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Msk   (0x000000FFUL << FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Pos) /*!< Mask for fault_iin_oc_warn_thresh in FAULT.FAULT_IIN_OC_WRN */
#define FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Shift(v) (((v) << FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Pos) & FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Msk) /*!< Shift value 'v' into fault_iin_oc_warn_thresh and mask 'v' to fit it into fault_iin_oc_warn_thresh field */

/** FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__SET() sets FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH to given value.
 *
 * When writing to FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_IIN_OC_WRN__GET(idp);
    reg = (reg & ~FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_IIN_OC_WRN__SET(idp, reg);
}

/** FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__GET() gets FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH's current value.
 *
 * When reading from FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_IIN_OC_WRN__GET(idp);
    reg = (reg & FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__MODIFY() modifies FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_IIN_OC_WRN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_IIN_OC_WRN
 * @param bf_value new value for FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH
 * @return new value of FAULT.FAULT_IIN_OC_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__EXTRACT() extracts FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_IIN_OC_WRN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_IIN_OC_WRN
 * @return current value of FAULT_IIN_OC_WRN.FAULT_IIN_OC_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_IIN_OC_WRN__FAULT_IIN_OC_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       FAULT_OT_FLT member of FAULT_t                       */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_OT_FLT__ADDRESS returns the address of member FAULT_OT_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_OT_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_OT_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_OT_FLT)));
}

/** FAULT_FAULT_OT_FLT__SET() sets FAULT_OT_FLT to given value.
 *
 * When writing to FAULT_OT_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_OT_FLT
 */
__FAULT_INLINE void FAULT_FAULT_OT_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_OT_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_OT_FLT__GET() gets FAULT_OT_FLT's current value.
 *
 * When reading from FAULT_OT_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_OT_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_OT_FLT__ADDRESS(idp));
}

/* ---------------- FAULT.FAULT_OT_FLT.FAULT_OT_FAULT_THRESH ---------------- */

/**
<pre>
  FAULT.FAULT_OT_FLT.FAULT_OT_FAULT_THRESH:

    Over temperature fault threshold in Telemetry Sense ADC codes.  Note that the ADC Code to Temperature lookup table is implemented in FW.
    LSB = 1 TS ADC Code, Range = 0.0 to 1023 AD Codes

</pre> */

#define FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Pos          0                                                                      /*!< Right-most bit position of fault_ot_fault_thresh in FAULT.FAULT_OT_FLT */
#define FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Msk          (0x000003FFUL << FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Pos)       /*!< Mask for fault_ot_fault_thresh in FAULT.FAULT_OT_FLT */
#define FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Shift(v)     (((v) << FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Pos) & FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Msk) /*!< Shift value 'v' into fault_ot_fault_thresh and mask 'v' to fit it into fault_ot_fault_thresh field */

/** FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__SET() sets FAULT_OT_FLT.FAULT_OT_FAULT_THRESH to given value.
 *
 * When writing to FAULT_OT_FLT.FAULT_OT_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_OT_FLT.FAULT_OT_FAULT_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_OT_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_OT_FLT__SET(idp, reg);
}

/** FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__GET() gets FAULT_OT_FLT.FAULT_OT_FAULT_THRESH's current value.
 *
 * When reading from FAULT_OT_FLT.FAULT_OT_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_OT_FLT.FAULT_OT_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_OT_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__MODIFY() modifies FAULT_OT_FLT.FAULT_OT_FAULT_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_OT_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_OT_FLT
 * @param bf_value new value for FAULT_OT_FLT.FAULT_OT_FAULT_THRESH
 * @return new value of FAULT.FAULT_OT_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__EXTRACT() extracts FAULT_OT_FLT.FAULT_OT_FAULT_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_OT_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_OT_FLT
 * @return current value of FAULT_OT_FLT.FAULT_OT_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_OT_FLT__FAULT_OT_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       FAULT_OT_WRN member of FAULT_t                       */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_OT_WRN__ADDRESS returns the address of member FAULT_OT_WRN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_OT_WRN
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_OT_WRN__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_OT_WRN)));
}

/** FAULT_FAULT_OT_WRN__SET() sets FAULT_OT_WRN to given value.
 *
 * When writing to FAULT_OT_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_OT_WRN
 */
__FAULT_INLINE void FAULT_FAULT_OT_WRN__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_OT_WRN__ADDRESS(idp), value);
}

/** FAULT_FAULT_OT_WRN__GET() gets FAULT_OT_WRN's current value.
 *
 * When reading from FAULT_OT_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_OT_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_WRN__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_OT_WRN__ADDRESS(idp));
}

/* ---------------- FAULT.FAULT_OT_WRN.FAULT_OT_WARN_THRESH ---------------- */

/**
<pre>
  FAULT.FAULT_OT_WRN.FAULT_OT_WARN_THRESH:

    Over temperature warn threshold in Telemetry Sense ADC codes.  Note that the ADC Code to Temperature lookup table is implemented in FW.
    LSB = 1 TS ADC Code, Range = 0.0 to 1023 AD Codes

</pre> */

#define FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Pos           0                                                                      /*!< Right-most bit position of fault_ot_warn_thresh in FAULT.FAULT_OT_WRN */
#define FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Msk           (0x000003FFUL << FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Pos)        /*!< Mask for fault_ot_warn_thresh in FAULT.FAULT_OT_WRN */
#define FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Shift(v)      (((v) << FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Pos) & FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Msk) /*!< Shift value 'v' into fault_ot_warn_thresh and mask 'v' to fit it into fault_ot_warn_thresh field */

/** FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__SET() sets FAULT_OT_WRN.FAULT_OT_WARN_THRESH to given value.
 *
 * When writing to FAULT_OT_WRN.FAULT_OT_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_OT_WRN.FAULT_OT_WARN_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_OT_WRN__GET(idp);
    reg = (reg & ~FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_OT_WRN__SET(idp, reg);
}

/** FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__GET() gets FAULT_OT_WRN.FAULT_OT_WARN_THRESH's current value.
 *
 * When reading from FAULT_OT_WRN.FAULT_OT_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_OT_WRN.FAULT_OT_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_OT_WRN__GET(idp);
    reg = (reg & FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__MODIFY() modifies FAULT_OT_WRN.FAULT_OT_WARN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_OT_WRN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_OT_WRN
 * @param bf_value new value for FAULT_OT_WRN.FAULT_OT_WARN_THRESH
 * @return new value of FAULT.FAULT_OT_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__EXTRACT() extracts FAULT_OT_WRN.FAULT_OT_WARN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_OT_WRN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_OT_WRN
 * @return current value of FAULT_OT_WRN.FAULT_OT_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_OT_WRN__FAULT_OT_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       FAULT_UT_FLT member of FAULT_t                       */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_UT_FLT__ADDRESS returns the address of member FAULT_UT_FLT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_UT_FLT
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_UT_FLT__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_UT_FLT)));
}

/** FAULT_FAULT_UT_FLT__SET() sets FAULT_UT_FLT to given value.
 *
 * When writing to FAULT_UT_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_UT_FLT
 */
__FAULT_INLINE void FAULT_FAULT_UT_FLT__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_UT_FLT__ADDRESS(idp), value);
}

/** FAULT_FAULT_UT_FLT__GET() gets FAULT_UT_FLT's current value.
 *
 * When reading from FAULT_UT_FLT, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_UT_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_UT_FLT__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_UT_FLT__ADDRESS(idp));
}

/* ---------------- FAULT.FAULT_UT_FLT.FAULT_UT_FAULT_THRESH ---------------- */

/**
<pre>
  FAULT.FAULT_UT_FLT.FAULT_UT_FAULT_THRESH:

    Under temperature fault threshold in Telemetry Sense ADC codes.  Note that the ADC Code to Temperature lookup table is implemented in FW.
    LSB = 1 TS ADC Code, Range = 0.0 to 1023 AD Codes

</pre> */

#define FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Pos          0                                                                      /*!< Right-most bit position of fault_ut_fault_thresh in FAULT.FAULT_UT_FLT */
#define FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Msk          (0x000003FFUL << FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Pos)       /*!< Mask for fault_ut_fault_thresh in FAULT.FAULT_UT_FLT */
#define FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Shift(v)     (((v) << FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Pos) & FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Msk) /*!< Shift value 'v' into fault_ut_fault_thresh and mask 'v' to fit it into fault_ut_fault_thresh field */

/** FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__SET() sets FAULT_UT_FLT.FAULT_UT_FAULT_THRESH to given value.
 *
 * When writing to FAULT_UT_FLT.FAULT_UT_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_UT_FLT.FAULT_UT_FAULT_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_UT_FLT__GET(idp);
    reg = (reg & ~FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_UT_FLT__SET(idp, reg);
}

/** FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__GET() gets FAULT_UT_FLT.FAULT_UT_FAULT_THRESH's current value.
 *
 * When reading from FAULT_UT_FLT.FAULT_UT_FAULT_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_UT_FLT.FAULT_UT_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_UT_FLT__GET(idp);
    reg = (reg & FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__MODIFY() modifies FAULT_UT_FLT.FAULT_UT_FAULT_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_UT_FLT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_UT_FLT
 * @param bf_value new value for FAULT_UT_FLT.FAULT_UT_FAULT_THRESH
 * @return new value of FAULT.FAULT_UT_FLT
 */
__FAULT_INLINE uint32_t FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__EXTRACT() extracts FAULT_UT_FLT.FAULT_UT_FAULT_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_UT_FLT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_UT_FLT
 * @return current value of FAULT_UT_FLT.FAULT_UT_FAULT_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_UT_FLT__FAULT_UT_FAULT_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       FAULT_UT_WRN member of FAULT_t                       */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_UT_WRN__ADDRESS returns the address of member FAULT_UT_WRN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_UT_WRN
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_UT_WRN__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_UT_WRN)));
}

/** FAULT_FAULT_UT_WRN__SET() sets FAULT_UT_WRN to given value.
 *
 * When writing to FAULT_UT_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_UT_WRN
 */
__FAULT_INLINE void FAULT_FAULT_UT_WRN__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_UT_WRN__ADDRESS(idp), value);
}

/** FAULT_FAULT_UT_WRN__GET() gets FAULT_UT_WRN's current value.
 *
 * When reading from FAULT_UT_WRN, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_UT_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_UT_WRN__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_UT_WRN__ADDRESS(idp));
}

/* ---------------- FAULT.FAULT_UT_WRN.FAULT_UT_WARN_THRESH ---------------- */

/**
<pre>
  FAULT.FAULT_UT_WRN.FAULT_UT_WARN_THRESH:

    Under temperature warn threshold in Telemetry Sense ADC codes.  Note that the ADC Code to Temperature lookup table is implemented in FW.
    LSB = 1 TS ADC Code, Range = 0.0 to 1023 AD Codes

</pre> */

#define FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Pos           0                                                                      /*!< Right-most bit position of fault_ut_warn_thresh in FAULT.FAULT_UT_WRN */
#define FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Msk           (0x000003FFUL << FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Pos)        /*!< Mask for fault_ut_warn_thresh in FAULT.FAULT_UT_WRN */
#define FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Shift(v)      (((v) << FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Pos) & FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Msk) /*!< Shift value 'v' into fault_ut_warn_thresh and mask 'v' to fit it into fault_ut_warn_thresh field */

/** FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__SET() sets FAULT_UT_WRN.FAULT_UT_WARN_THRESH to given value.
 *
 * When writing to FAULT_UT_WRN.FAULT_UT_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_UT_WRN.FAULT_UT_WARN_THRESH
 */
__FAULT_INLINE void FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_UT_WRN__GET(idp);
    reg = (reg & ~FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Shift((uint32_t)bf_value)));
    FAULT_FAULT_UT_WRN__SET(idp, reg);
}

/** FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__GET() gets FAULT_UT_WRN.FAULT_UT_WARN_THRESH's current value.
 *
 * When reading from FAULT_UT_WRN.FAULT_UT_WARN_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_UT_WRN.FAULT_UT_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_UT_WRN__GET(idp);
    reg = (reg & FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__MODIFY() modifies FAULT_UT_WRN.FAULT_UT_WARN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_UT_WRN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_UT_WRN
 * @param bf_value new value for FAULT_UT_WRN.FAULT_UT_WARN_THRESH
 * @return new value of FAULT.FAULT_UT_WRN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Msk);
    reg = (reg | (FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__EXTRACT() extracts FAULT_UT_WRN.FAULT_UT_WARN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_UT_WRN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_UT_WRN
 * @return current value of FAULT_UT_WRN.FAULT_UT_WARN_THRESH
 */
__FAULT_INLINE uint32_t FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Msk);
    reg = (reg >> FAULT_FAULT_UT_WRN__FAULT_UT_WARN_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       FAULT_OT_SRC member of FAULT_t                       */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_OT_SRC__ADDRESS returns the address of member FAULT_OT_SRC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_OT_SRC
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_OT_SRC__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_OT_SRC)));
}

/** FAULT_FAULT_OT_SRC__SET() sets FAULT_OT_SRC to given value.
 *
 * When writing to FAULT_OT_SRC, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_OT_SRC
 */
__FAULT_INLINE void FAULT_FAULT_OT_SRC__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_OT_SRC__ADDRESS(idp), value);
}

/** FAULT_FAULT_OT_SRC__GET() gets FAULT_OT_SRC's current value.
 *
 * When reading from FAULT_OT_SRC, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_OT_SRC
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_SRC__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_OT_SRC__ADDRESS(idp));
}

/* ----------------- FAULT.FAULT_OT_SRC.FAULT_TEMP_SRC_SEL ----------------- */

/**
<pre>
  FAULT.FAULT_OT_SRC.FAULT_TEMP_SRC_SEL:

    Loop temperature source select.
    <start table_with_header>
    [2:0] Source TC
    0 "ATSEN input" NTC
    1 "BTSEN input" NTC
    2 "Internal temperature (ITSEN)" PTC
    3 "ATSEN input" PTC
    4 "BTSEN input" PTC
    <end table>

</pre> */

#define FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Pos             0                                                                      /*!< Right-most bit position of fault_temp_src_sel in FAULT.FAULT_OT_SRC */
#define FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Msk             (0x00000007UL << FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Pos)          /*!< Mask for fault_temp_src_sel in FAULT.FAULT_OT_SRC */
#define FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Shift(v)        (((v) << FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Pos) & FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Msk) /*!< Shift value 'v' into fault_temp_src_sel and mask 'v' to fit it into fault_temp_src_sel field */

/** FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__SET() sets FAULT_OT_SRC.FAULT_TEMP_SRC_SEL to given value.
 *
 * When writing to FAULT_OT_SRC.FAULT_TEMP_SRC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_OT_SRC.FAULT_TEMP_SRC_SEL
 */
__FAULT_INLINE void FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_OT_SRC__GET(idp);
    reg = (reg & ~FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Msk);
    reg = (reg | (FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Shift((uint32_t)bf_value)));
    FAULT_FAULT_OT_SRC__SET(idp, reg);
}

/** FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__GET() gets FAULT_OT_SRC.FAULT_TEMP_SRC_SEL's current value.
 *
 * When reading from FAULT_OT_SRC.FAULT_TEMP_SRC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_OT_SRC.FAULT_TEMP_SRC_SEL
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_OT_SRC__GET(idp);
    reg = (reg & FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Msk);
    reg = (reg >> FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__MODIFY() modifies FAULT_OT_SRC.FAULT_TEMP_SRC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_OT_SRC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_OT_SRC
 * @param bf_value new value for FAULT_OT_SRC.FAULT_TEMP_SRC_SEL
 * @return new value of FAULT.FAULT_OT_SRC
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Msk);
    reg = (reg | (FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__EXTRACT() extracts FAULT_OT_SRC.FAULT_TEMP_SRC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_OT_SRC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_OT_SRC
 * @return current value of FAULT_OT_SRC.FAULT_TEMP_SRC_SEL
 */
__FAULT_INLINE uint32_t FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Msk);
    reg = (reg >> FAULT_FAULT_OT_SRC__FAULT_TEMP_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   FAULT_SHUT_CLR_LOOP member of FAULT_t                   */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_SHUT_CLR_LOOP__ADDRESS returns the address of member FAULT_SHUT_CLR_LOOP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_SHUT_CLR_LOOP
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_SHUT_CLR_LOOP__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_SHUT_CLR_LOOP)));
}

/** FAULT_FAULT_SHUT_CLR_LOOP__SET() sets FAULT_SHUT_CLR_LOOP to given value.
 *
 * When writing to FAULT_SHUT_CLR_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_SHUT_CLR_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_SHUT_CLR_LOOP__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_SHUT_CLR_LOOP__ADDRESS(idp), value);
}


/* ------------- FAULT.FAULT_SHUT_CLR_LOOP.FAULT_SHUT_CLR_LOOP ------------- */

/**
<pre>
  FAULT.FAULT_SHUT_CLR_LOOP.FAULT_SHUT_CLR_LOOP:

    Clears shutdown faults in fault_reg_loop when set high. This field should not be written until after FW has completed shutdown related cleanup (e.g., Vcontrol target returned to 0, appropriate blocks disabled).

</pre> */

#define FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Pos     0                                                                      /*!< Right-most bit position of fault_shut_clr_loop in FAULT.FAULT_SHUT_CLR_LOOP */
#define FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Msk     (0x00000001UL << FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Pos)  /*!< Mask for fault_shut_clr_loop in FAULT.FAULT_SHUT_CLR_LOOP */
#define FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Shift(v) (((v) << FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Pos) & FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Msk) /*!< Shift value 'v' into fault_shut_clr_loop and mask 'v' to fit it into fault_shut_clr_loop field */

/** FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__SET() sets FAULT_SHUT_CLR_LOOP.FAULT_SHUT_CLR_LOOP to given value.
 *
 * When writing to FAULT_SHUT_CLR_LOOP.FAULT_SHUT_CLR_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_SHUT_CLR_LOOP.FAULT_SHUT_CLR_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Shift((uint32_t)bf_value);
    FAULT_FAULT_SHUT_CLR_LOOP__SET(idp, reg);
}


/** FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__MODIFY() modifies FAULT_SHUT_CLR_LOOP.FAULT_SHUT_CLR_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_SHUT_CLR_LOOP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_SHUT_CLR_LOOP
 * @param bf_value new value for FAULT_SHUT_CLR_LOOP.FAULT_SHUT_CLR_LOOP
 * @return new value of FAULT.FAULT_SHUT_CLR_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__EXTRACT() extracts FAULT_SHUT_CLR_LOOP.FAULT_SHUT_CLR_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_SHUT_CLR_LOOP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_SHUT_CLR_LOOP
 * @return current value of FAULT_SHUT_CLR_LOOP.FAULT_SHUT_CLR_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_SHUT_CLR_LOOP__FAULT_SHUT_CLR_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   FAULT_POLARITY_LOOP member of FAULT_t                   */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_POLARITY_LOOP__ADDRESS returns the address of member FAULT_POLARITY_LOOP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_POLARITY_LOOP
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_POLARITY_LOOP__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_POLARITY_LOOP)));
}

/** FAULT_FAULT_POLARITY_LOOP__SET() sets FAULT_POLARITY_LOOP to given value.
 *
 * When writing to FAULT_POLARITY_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_POLARITY_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_POLARITY_LOOP__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_POLARITY_LOOP__ADDRESS(idp), value);
}

/** FAULT_FAULT_POLARITY_LOOP__GET() gets FAULT_POLARITY_LOOP's current value.
 *
 * When reading from FAULT_POLARITY_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_POLARITY_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_POLARITY_LOOP__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_POLARITY_LOOP__ADDRESS(idp));
}

/* ------------- FAULT.FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP ------------- */

/**
<pre>
  FAULT.FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP:

    Defines the polarity of the fault with respect to the threshold.  When set to 0, the fault / warning is asserted using its default polarity (e.g., "over" type fault asserted when above the threshold).  When set to 1, the fault / warning is asserted with the inverse to its default polarity (e.g., "over" type fault asserted when below the threshold).  The inverse polarity may be used to generate an interrupt when a parameter no longer exceeds its fault / warning threshold.
    <start table_with_header>
    Bit "Fault" "Bit" "Fault"
    0 "Reserved"   "1" "VOUT_OV_FAULT "
    2 "VOUT_OV_WARN"  "3" "VOUT_UV_FAULT"
    4 "VOUT_UV_WARN"  "5" "VIN_OV_FAULT"
    6 "VIN_OV_WARN"  "7"  "VIN_UV_FAULT"
    8 "VIN_UV_WARN" "9" "IOUT_OC_FAULT"
    10 "IOUT_OC_LV_FAULT" "11" "IOUT_OC_WARN"
    12 "IOUT_UC_FAULT" "13" "MFR_IOUT_OC_FAST"
    14 "IIN_OC_FAULT"  "15" "IIN_OC_WARN"
    16 "OT_FAULT"  "17" "OT_WARN"
    18 "UT_FAULT"  "19" "UT_WARN"
    20 "POWER_LIMIT_MODE" "21" "ISHARE_FAULT"
    22 "VOUT_MAX_MIN_WARN" "23" "SYNC_FAULT"
    24-31 "Unused"
    <end table>

</pre> */

#define FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Pos     0                                                                      /*!< Right-most bit position of fault_polarity_loop in FAULT.FAULT_POLARITY_LOOP */
#define FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Msk     (0xFFFFFFFFUL << FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Pos)  /*!< Mask for fault_polarity_loop in FAULT.FAULT_POLARITY_LOOP */
#define FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Shift(v) (((v) << FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Pos) & FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Msk) /*!< Shift value 'v' into fault_polarity_loop and mask 'v' to fit it into fault_polarity_loop field */

/** FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__SET() sets FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP to given value.
 *
 * When writing to FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_POLARITY_LOOP__GET(idp);
    reg = (reg & ~FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Shift((uint32_t)bf_value)));
    FAULT_FAULT_POLARITY_LOOP__SET(idp, reg);
}

/** FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__GET() gets FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP's current value.
 *
 * When reading from FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_POLARITY_LOOP__GET(idp);
    reg = (reg & FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__MODIFY() modifies FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_POLARITY_LOOP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_POLARITY_LOOP
 * @param bf_value new value for FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP
 * @return new value of FAULT.FAULT_POLARITY_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__EXTRACT() extracts FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_POLARITY_LOOP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_POLARITY_LOOP
 * @return current value of FAULT_POLARITY_LOOP.FAULT_POLARITY_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_POLARITY_LOOP__FAULT_POLARITY_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_FORCE_LOOP member of FAULT_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_FORCE_LOOP__ADDRESS returns the address of member FAULT_FORCE_LOOP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_FORCE_LOOP
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_FORCE_LOOP__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_FORCE_LOOP)));
}

/** FAULT_FAULT_FORCE_LOOP__SET() sets FAULT_FORCE_LOOP to given value.
 *
 * When writing to FAULT_FORCE_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_FORCE_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_FORCE_LOOP__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_FORCE_LOOP__ADDRESS(idp), value);
}

/** FAULT_FAULT_FORCE_LOOP__GET() gets FAULT_FORCE_LOOP's current value.
 *
 * When reading from FAULT_FORCE_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_FORCE_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_FORCE_LOOP__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_FORCE_LOOP__ADDRESS(idp));
}

/* ---------------- FAULT.FAULT_FORCE_LOOP.FAULT_FORCE_LOOP ---------------- */

/**
<pre>
  FAULT.FAULT_FORCE_LOOP.FAULT_FORCE_LOOP:

    Fault force set register.  When the bit corresponding to a fault / warning is set to 1, that fault / warning is asserted as if it had exceeded its threshold.
    <start table_with_header>
    Bit "Fault" "Bit" "Fault"
    0 "Reserved"   "1" "VOUT_OV_FAULT "
    2 "VOUT_OV_WARN"  "3" "VOUT_UV_FAULT"
    4 "VOUT_UV_WARN"  "5" "VIN_OV_FAULT"
    6 "VIN_OV_WARN"  "7"  "VIN_UV_FAULT"
    8 "VIN_UV_WARN" "9" "IOUT_OC_FAULT"
    10 "IOUT_OC_LV_FAULT" "11" "IOUT_OC_WARN"
    12 "IOUT_UC_FAULT" "13" "MFR_IOUT_OC_FAST"
    14 "IIN_OC_FAULT"  "15" "IIN_OC_WARN"
    16 "OT_FAULT"  "17" "OT_WARN"
    18 "UT_FAULT"  "19" "UT_WARN"
    20 "POWER_LIMIT_MODE" "21" "ISHARE_FAULT"
    22 "VOUT_MAX_MIN_WARN" "23" "SYNC_FAULT"
    24-31 "Unused"
    <end table>

</pre> */

#define FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Pos           0                                                                      /*!< Right-most bit position of fault_force_loop in FAULT.FAULT_FORCE_LOOP */
#define FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Msk           (0xFFFFFFFFUL << FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Pos)        /*!< Mask for fault_force_loop in FAULT.FAULT_FORCE_LOOP */
#define FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Shift(v)      (((v) << FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Pos) & FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Msk) /*!< Shift value 'v' into fault_force_loop and mask 'v' to fit it into fault_force_loop field */

/** FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__SET() sets FAULT_FORCE_LOOP.FAULT_FORCE_LOOP to given value.
 *
 * When writing to FAULT_FORCE_LOOP.FAULT_FORCE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_FORCE_LOOP.FAULT_FORCE_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_FORCE_LOOP__GET(idp);
    reg = (reg & ~FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Shift((uint32_t)bf_value)));
    FAULT_FAULT_FORCE_LOOP__SET(idp, reg);
}

/** FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__GET() gets FAULT_FORCE_LOOP.FAULT_FORCE_LOOP's current value.
 *
 * When reading from FAULT_FORCE_LOOP.FAULT_FORCE_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_FORCE_LOOP.FAULT_FORCE_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_FORCE_LOOP__GET(idp);
    reg = (reg & FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__MODIFY() modifies FAULT_FORCE_LOOP.FAULT_FORCE_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_FORCE_LOOP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_FORCE_LOOP
 * @param bf_value new value for FAULT_FORCE_LOOP.FAULT_FORCE_LOOP
 * @return new value of FAULT.FAULT_FORCE_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__EXTRACT() extracts FAULT_FORCE_LOOP.FAULT_FORCE_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_FORCE_LOOP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_FORCE_LOOP
 * @return current value of FAULT_FORCE_LOOP.FAULT_FORCE_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_FORCE_LOOP__FAULT_FORCE_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_CLEAR_LOOP member of FAULT_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_CLEAR_LOOP__ADDRESS returns the address of member FAULT_CLEAR_LOOP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_CLEAR_LOOP
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_CLEAR_LOOP__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_CLEAR_LOOP)));
}

/** FAULT_FAULT_CLEAR_LOOP__SET() sets FAULT_CLEAR_LOOP to given value.
 *
 * When writing to FAULT_CLEAR_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_CLEAR_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_CLEAR_LOOP__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_CLEAR_LOOP__ADDRESS(idp), value);
}


/* ---------------- FAULT.FAULT_CLEAR_LOOP.FAULT_CLEAR_LOOP ---------------- */

/**
<pre>
  FAULT.FAULT_CLEAR_LOOP.FAULT_CLEAR_LOOP:

    Fault force clear register.  When the bit corresponding to a fault / warning is set to 1, that fault / warning is cleared in the fault_status_loop and fault_ref_loop registers.
    <start table_with_header>
    Bit "Fault" "Bit" "Fault"
    0 "Reserved"   "1" "VOUT_OV_FAULT "
    2 "VOUT_OV_WARN"  "3" "VOUT_UV_FAULT"
    4 "VOUT_UV_WARN"  "5" "VIN_OV_FAULT"
    6 "VIN_OV_WARN"  "7"  "VIN_UV_FAULT"
    8 "VIN_UV_WARN" "9" "IOUT_OC_FAULT"
    10 "IOUT_OC_LV_FAULT" "11" "IOUT_OC_WARN"
    12 "IOUT_UC_FAULT" "13" "MFR_IOUT_OC_FAST"
    14 "IIN_OC_FAULT"  "15" "IIN_OC_WARN"
    16 "OT_FAULT"  "17" "OT_WARN"
    18 "UT_FAULT"  "19" "UT_WARN"
    20 "POWER_LIMIT_MODE" "21" "ISHARE_FAULT"
    22 "VOUT_MAX_MIN_WARN" "23" "SYNC_FAULT"
    24-31 "Unused"
    <end table>

</pre> */

#define FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Pos           0                                                                      /*!< Right-most bit position of fault_clear_loop in FAULT.FAULT_CLEAR_LOOP */
#define FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Msk           (0xFFFFFFFFUL << FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Pos)        /*!< Mask for fault_clear_loop in FAULT.FAULT_CLEAR_LOOP */
#define FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Shift(v)      (((v) << FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Pos) & FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Msk) /*!< Shift value 'v' into fault_clear_loop and mask 'v' to fit it into fault_clear_loop field */

/** FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__SET() sets FAULT_CLEAR_LOOP.FAULT_CLEAR_LOOP to given value.
 *
 * When writing to FAULT_CLEAR_LOOP.FAULT_CLEAR_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_CLEAR_LOOP.FAULT_CLEAR_LOOP
 */
__FAULT_INLINE void FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Shift((uint32_t)bf_value);
    FAULT_FAULT_CLEAR_LOOP__SET(idp, reg);
}


/** FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__MODIFY() modifies FAULT_CLEAR_LOOP.FAULT_CLEAR_LOOP.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_CLEAR_LOOP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_CLEAR_LOOP
 * @param bf_value new value for FAULT_CLEAR_LOOP.FAULT_CLEAR_LOOP
 * @return new value of FAULT.FAULT_CLEAR_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Msk);
    reg = (reg | (FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__EXTRACT() extracts FAULT_CLEAR_LOOP.FAULT_CLEAR_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_CLEAR_LOOP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_CLEAR_LOOP
 * @return current value of FAULT_CLEAR_LOOP.FAULT_CLEAR_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_CLEAR_LOOP__FAULT_CLEAR_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_STATUS_LOOP member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_STATUS_LOOP__ADDRESS returns the address of member FAULT_STATUS_LOOP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_STATUS_LOOP
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_STATUS_LOOP__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_STATUS_LOOP)));
}

/** FAULT_FAULT_STATUS_LOOP__GET() gets FAULT_STATUS_LOOP's current value.
 *
 * When reading from FAULT_STATUS_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_STATUS_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_STATUS_LOOP__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_STATUS_LOOP__ADDRESS(idp));
}

/* --------------- FAULT.FAULT_STATUS_LOOP.FAULT_STATUS_LOOP --------------- */

/**
<pre>
  FAULT.FAULT_STATUS_LOOP.FAULT_STATUS_LOOP:

    Fault status register generated by sub-sampling fault_reg_loop at 2MHz.  Fault interrupts are generated from this register.  Once a fault bit is set it is latched in this register and can only be cleared via fault_clear_loop.
    <start table_with_header>
    Bit "Fault" "Bit" "Fault"
    0 "Reserved"   "1" "VOUT_OV_FAULT "
    2 "VOUT_OV_WARN"  "3" "VOUT_UV_FAULT"
    4 "VOUT_UV_WARN"  "5" "VIN_OV_FAULT"
    6 "VIN_OV_WARN"  "7"  "VIN_UV_FAULT"
    8 "VIN_UV_WARN" "9" "IOUT_OC_FAULT"
    10 "IOUT_OC_LV_FAULT" "11" "IOUT_OC_WARN"
    12 "IOUT_UC_FAULT" "13" "MFR_IOUT_OC_FAST"
    14 "IIN_OC_FAULT"  "15" "IIN_OC_WARN"
    16 "OT_FAULT"  "17" "OT_WARN"
    18 "UT_FAULT"  "19" "UT_WARN"
    20 "POWER_LIMIT_MODE" "21" "ISHARE_FAULT"
    22 "VOUT_MAX_MIN_WARN" "23" "SYNC_FAULT"
    24-31 "Unused"
    <end table>

</pre> */

#define FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__Pos         0                                                                      /*!< Right-most bit position of fault_status_loop in FAULT.FAULT_STATUS_LOOP */
#define FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__Msk         (0xFFFFFFFFUL << FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__Pos)      /*!< Mask for fault_status_loop in FAULT.FAULT_STATUS_LOOP */
#define FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__Shift(v)    (((v) << FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__Pos) & FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__Msk) /*!< Shift value 'v' into fault_status_loop and mask 'v' to fit it into fault_status_loop field */

/** FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__GET() gets FAULT_STATUS_LOOP.FAULT_STATUS_LOOP's current value.
 *
 * When reading from FAULT_STATUS_LOOP.FAULT_STATUS_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_STATUS_LOOP.FAULT_STATUS_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_STATUS_LOOP__GET(idp);
    reg = (reg & FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__EXTRACT() extracts FAULT_STATUS_LOOP.FAULT_STATUS_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_STATUS_LOOP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_STATUS_LOOP
 * @return current value of FAULT_STATUS_LOOP.FAULT_STATUS_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_STATUS_LOOP__FAULT_STATUS_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      FAULT_REG_LOOP member of FAULT_t                      */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_REG_LOOP__ADDRESS returns the address of member FAULT_REG_LOOP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_REG_LOOP
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_REG_LOOP__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_REG_LOOP)));
}

/** FAULT_FAULT_REG_LOOP__GET() gets FAULT_REG_LOOP's current value.
 *
 * When reading from FAULT_REG_LOOP, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_REG_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_REG_LOOP__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_REG_LOOP__ADDRESS(idp));
}

/* ------------------ FAULT.FAULT_REG_LOOP.FAULT_REG_LOOP ------------------ */

/**
<pre>
  FAULT.FAULT_REG_LOOP.FAULT_REG_LOOP:

    Fault status register updated at 50MHz.  Once a fault bit is set it is latched in this register and can only be cleared via fault_clear_loop.
    <start table_with_header>
    Bit "Fault" "Bit" "Fault"
    0 "Reserved"   "1" "VOUT_OV_FAULT "
    2 "VOUT_OV_WARN"  "3" "VOUT_UV_FAULT"
    4 "VOUT_UV_WARN"  "5" "VIN_OV_FAULT"
    6 "VIN_OV_WARN"  "7"  "VIN_UV_FAULT"
    8 "VIN_UV_WARN" "9" "IOUT_OC_FAULT"
    10 "IOUT_OC_LV_FAULT" "11" "IOUT_OC_WARN"
    12 "IOUT_UC_FAULT" "13" "MFR_IOUT_OC_FAST"
    14 "IIN_OC_FAULT"  "15" "IIN_OC_WARN"
    16 "OT_FAULT"  "17" "OT_WARN"
    18 "UT_FAULT"  "19" "UT_WARN"
    20 "POWER_LIMIT_MODE" "21" "ISHARE_FAULT"
    22 "VOUT_MAX_MIN_WARN" "23" "SYNC_FAULT"
    24-31 "Unused"
    <end table>

</pre> */

#define FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__Pos               0                                                                      /*!< Right-most bit position of fault_reg_loop in FAULT.FAULT_REG_LOOP */
#define FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__Msk               (0xFFFFFFFFUL << FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__Pos)            /*!< Mask for fault_reg_loop in FAULT.FAULT_REG_LOOP */
#define FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__Shift(v)          (((v) << FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__Pos) & FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__Msk) /*!< Shift value 'v' into fault_reg_loop and mask 'v' to fit it into fault_reg_loop field */

/** FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__GET() gets FAULT_REG_LOOP.FAULT_REG_LOOP's current value.
 *
 * When reading from FAULT_REG_LOOP.FAULT_REG_LOOP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_REG_LOOP.FAULT_REG_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_REG_LOOP__GET(idp);
    reg = (reg & FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__EXTRACT() extracts FAULT_REG_LOOP.FAULT_REG_LOOP.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_REG_LOOP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_REG_LOOP
 * @return current value of FAULT_REG_LOOP.FAULT_REG_LOOP
 */
__FAULT_INLINE uint32_t FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__Msk);
    reg = (reg >> FAULT_FAULT_REG_LOOP__FAULT_REG_LOOP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     FAULT_IOUT_CC_RD member of FAULT_t                     */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_IOUT_CC_RD__ADDRESS returns the address of member FAULT_IOUT_CC_RD.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_IOUT_CC_RD
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_IOUT_CC_RD__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_IOUT_CC_RD)));
}

/** FAULT_FAULT_IOUT_CC_RD__GET() gets FAULT_IOUT_CC_RD's current value.
 *
 * When reading from FAULT_IOUT_CC_RD, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_CC_RD
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_RD__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_IOUT_CC_RD__ADDRESS(idp));
}

/* ---------------- FAULT.FAULT_IOUT_CC_RD.FAULT_IOUT_CC_ADJ ---------------- */

/**
<pre>
  FAULT.FAULT_IOUT_CC_RD.FAULT_IOUT_CC_ADJ:

    Status register indicating magnitude of constant current mode output voltage adjustment referenced to the VSEN pin (i.e., after the Vout sense resistor divider).
    LSB = 156.25uV, Range = 0.0 to 2.55984375V

</pre> */

#define FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__Pos          1                                                                      /*!< Right-most bit position of fault_iout_cc_adj in FAULT.FAULT_IOUT_CC_RD */
#define FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__Msk          (0x00003FFFUL << FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__Pos)       /*!< Mask for fault_iout_cc_adj in FAULT.FAULT_IOUT_CC_RD */
#define FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__Shift(v)     (((v) << FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__Pos) & FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__Msk) /*!< Shift value 'v' into fault_iout_cc_adj and mask 'v' to fit it into fault_iout_cc_adj field */

/** FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__GET() gets FAULT_IOUT_CC_RD.FAULT_IOUT_CC_ADJ's current value.
 *
 * When reading from FAULT_IOUT_CC_RD.FAULT_IOUT_CC_ADJ, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_CC_RD.FAULT_IOUT_CC_ADJ
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_IOUT_CC_RD__GET(idp);
    reg = (reg & FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__EXTRACT() extracts FAULT_IOUT_CC_RD.FAULT_IOUT_CC_ADJ.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_IOUT_CC_RD.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_IOUT_CC_RD
 * @return current value of FAULT_IOUT_CC_RD.FAULT_IOUT_CC_ADJ
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_ADJ__Pos);
    return (uint32_t)reg;
}

/* --------------- FAULT.FAULT_IOUT_CC_RD.FAULT_IOUT_CC_MODE --------------- */

/**
<pre>
  FAULT.FAULT_IOUT_CC_RD.FAULT_IOUT_CC_MODE:

    Status flag indicating IOUT constant current mode operation.
    <start table>
    0 "Normal operation"
    1 "Constant current mode"
    <end table>

</pre> */

#define FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__Pos         0                                                                      /*!< Right-most bit position of fault_iout_cc_mode in FAULT.FAULT_IOUT_CC_RD */
#define FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__Msk         (0x00000001UL << FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__Pos)      /*!< Mask for fault_iout_cc_mode in FAULT.FAULT_IOUT_CC_RD */
#define FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__Shift(v)    (((v) << FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__Pos) & FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__Msk) /*!< Shift value 'v' into fault_iout_cc_mode and mask 'v' to fit it into fault_iout_cc_mode field */

/** FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__GET() gets FAULT_IOUT_CC_RD.FAULT_IOUT_CC_MODE's current value.
 *
 * When reading from FAULT_IOUT_CC_RD.FAULT_IOUT_CC_MODE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_CC_RD.FAULT_IOUT_CC_MODE
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_IOUT_CC_RD__GET(idp);
    reg = (reg & FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__EXTRACT() extracts FAULT_IOUT_CC_RD.FAULT_IOUT_CC_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_IOUT_CC_RD.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_IOUT_CC_RD
 * @return current value of FAULT_IOUT_CC_RD.FAULT_IOUT_CC_MODE
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_CC_RD__FAULT_IOUT_CC_MODE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    FAULT_IOUT_CC_SEL member of FAULT_t                    */
/* -------------------------------------------------------------------------- */

/** __FAULT_FAULT_IOUT_CC_SEL__ADDRESS returns the address of member FAULT_IOUT_CC_SEL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAULT_IOUT_CC_SEL
 */
__FAULT_INLINE uint32_t* __FAULT_FAULT_IOUT_CC_SEL__ADDRESS(fault_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAULT_BASE_PTR(idp) + (uint32_t)(offsetof(FAULT_t, FAULT_IOUT_CC_SEL)));
}

/** FAULT_FAULT_IOUT_CC_SEL__SET() sets FAULT_IOUT_CC_SEL to given value.
 *
 * When writing to FAULT_IOUT_CC_SEL, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAULT_IOUT_CC_SEL
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_CC_SEL__SET(fault_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAULT_FAULT_IOUT_CC_SEL__ADDRESS(idp), value);
}

/** FAULT_FAULT_IOUT_CC_SEL__GET() gets FAULT_IOUT_CC_SEL's current value.
 *
 * When reading from FAULT_IOUT_CC_SEL, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_CC_SEL
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_SEL__GET(fault_idx_t idp)
{
    return HAL_GET32(__FAULT_FAULT_IOUT_CC_SEL__ADDRESS(idp));
}

/* ------------- FAULT.FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST ------------- */

/**
<pre>
  FAULT.FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST:

    Constant current mode enable for MFR_IOUT_OC_FAST_FAULT.  Set by MFR_IOUT_OC_FAST_FAULT_RESPONSE.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Pos     1                                                                      /*!< Right-most bit position of fault_iout_cc_en_fast in FAULT.FAULT_IOUT_CC_SEL */
#define FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Msk     (0x00000001UL << FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Pos)  /*!< Mask for fault_iout_cc_en_fast in FAULT.FAULT_IOUT_CC_SEL */
#define FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Shift(v) (((v) << FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Pos) & FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Msk) /*!< Shift value 'v' into fault_iout_cc_en_fast and mask 'v' to fit it into fault_iout_cc_en_fast field */

/** FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__SET() sets FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST to given value.
 *
 * When writing to FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_IOUT_CC_SEL__GET(idp);
    reg = (reg & ~FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Shift((uint32_t)bf_value)));
    FAULT_FAULT_IOUT_CC_SEL__SET(idp, reg);
}

/** FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__GET() gets FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST's current value.
 *
 * When reading from FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_IOUT_CC_SEL__GET(idp);
    reg = (reg & FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__MODIFY() modifies FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_IOUT_CC_SEL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_IOUT_CC_SEL
 * @param bf_value new value for FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST
 * @return new value of FAULT.FAULT_IOUT_CC_SEL
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__EXTRACT() extracts FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_IOUT_CC_SEL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_IOUT_CC_SEL
 * @return current value of FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN_FAST
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN_FAST__Pos);
    return (uint32_t)reg;
}

/* ---------------- FAULT.FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN ---------------- */

/**
<pre>
  FAULT.FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN:

    Constant current mode enable for IOUT_OC_FAULT.  Set by IOUT_OC_FAULT_RESPONSE.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Pos          0                                                                      /*!< Right-most bit position of fault_iout_cc_en in FAULT.FAULT_IOUT_CC_SEL */
#define FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Msk          (0x00000001UL << FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Pos)       /*!< Mask for fault_iout_cc_en in FAULT.FAULT_IOUT_CC_SEL */
#define FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Shift(v)     (((v) << FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Pos) & FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Msk) /*!< Shift value 'v' into fault_iout_cc_en and mask 'v' to fit it into fault_iout_cc_en field */

/** FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__SET() sets FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN to given value.
 *
 * When writing to FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN
 */
__FAULT_INLINE void FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__SET(fault_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAULT_FAULT_IOUT_CC_SEL__GET(idp);
    reg = (reg & ~FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Shift((uint32_t)bf_value)));
    FAULT_FAULT_IOUT_CC_SEL__SET(idp, reg);
}

/** FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__GET() gets FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN's current value.
 *
 * When reading from FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__GET(fault_idx_t idp)
{
    uint32_t reg = FAULT_FAULT_IOUT_CC_SEL__GET(idp);
    reg = (reg & FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Pos);
    return (uint32_t)reg;
}

/** FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__MODIFY() modifies FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN.
 *
 * This is recommended to use when setting more than one bitfield of FAULT.FAULT_IOUT_CC_SEL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAULT.FAULT_IOUT_CC_SEL
 * @param bf_value new value for FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN
 * @return new value of FAULT.FAULT_IOUT_CC_SEL
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Msk);
    reg = (reg | (FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__EXTRACT() extracts FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN.
 *
 * This is recommended to use when extracting more than one bitfield from FAULT.FAULT_IOUT_CC_SEL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAULT.FAULT_IOUT_CC_SEL
 * @return current value of FAULT_IOUT_CC_SEL.FAULT_IOUT_CC_EN
 */
__FAULT_INLINE uint32_t FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Msk);
    reg = (reg >> FAULT_FAULT_IOUT_CC_SEL__FAULT_IOUT_CC_EN__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group fault block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_FAULT_H_ */
