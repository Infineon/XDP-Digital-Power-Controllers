/**
 * @file     shasta_hal_isen.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_ISEN_H_
#define _SHASTA_HAL_ISEN_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup isen
 * @{
 */

#if defined ( __CC_ARM )
#define __ISEN_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __ISEN_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __ISEN_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __ISEN_INLINE  static inline
#endif

/** register file of the isen block.
 */
typedef struct _ISEN_s
{
    volatile        uint32_t        CE_CFG1                     ; /*!< (@0x00000000) Current sense tracking gain in the HiZ state.  The tracking gain defines the relative stength of the IS ADC based correction term applied to the emulated cu...(more) */
    volatile        uint32_t        CE_CFG2                     ; /*!< (@0x00000004) Defines the ON state of the current estimator with respect to the PWM outputs where the ON state generally refers to the state when the output inductor curr...(more) */
    volatile        uint32_t        CE_CFG3                     ; /*!< (@0x00000008) Defines the OFF state of the current estimator with respect to the PWM outputs where the OFF state generally refers to the state when the output inductor cu...(more) */
    volatile        uint32_t        ISP_FAULT1                  ; /*!< (@0x0000000C) Short ciruit protection (SCP) fault threshold.  The SCP threshold should be set highest among the various current protection thresholds as it requires only ...(more) */
    volatile        uint32_t        CE_CFG4                     ; /*!< (@0x00000010) Transformer magnetizing inductance (Lm) current sense slope normalized to Code/Samples @ 1.0V.  Only used for primary side current sense. <start table> "ce_...(more) */
    volatile        uint32_t        ISP_FAULT2                  ; /*!< (@0x00000014) Current sense tracking fault enable.  The tracking fault detects the inability of the current sense emulator to track the incoming current sense signal.  Th...(more) */
    volatile        uint32_t        ISP_APC                     ; /*!< (@0x00000018) Current Sense ADC Amps per Code (APC), maps the current sense ADC LSB into Amps. Computed from PMBus command as follows: <start table> "isp_apc(U2.9) = MFR_...(more) */
} ISEN_t;


/** enumeration of implemented isen blocks
 */
typedef enum _isen_idx_e
{
    ISEN0 = 0u,    //!< ISEN0
    ISEN1 = 1u     //!< ISEN1
} isen_idx_t;

#define ISEN_BASE (0x70002400u)                                                          /*!< isen base address */
#define ISEN_STRIDE (0x00000400u)                                                         

/** __ISEN_BASE_PTR returns the base address of the peripheral.
 *
 * @param idp index of peripheral
 * @return base address of peripheral's instance
 */
__ISEN_INLINE uint32_t* __ISEN_BASE_PTR(isen_idx_t idp)
{
    return (uint32_t*)(ISEN_BASE + (uint32_t)((uint32_t)idp * ISEN_STRIDE));
}


/* -------------------------------------------------------------------------- */
/*                          CE_CFG1 member of ISEN_t                          */
/* -------------------------------------------------------------------------- */

/** __ISEN_CE_CFG1__ADDRESS returns the address of member CE_CFG1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of CE_CFG1
 */
__ISEN_INLINE uint32_t* __ISEN_CE_CFG1__ADDRESS(isen_idx_t idp)
{
    return (uint32_t*)((uint32_t)__ISEN_BASE_PTR(idp) + (uint32_t)(offsetof(ISEN_t, CE_CFG1)));
}

/** ISEN_CE_CFG1__SET() sets CE_CFG1 to given value.
 *
 * When writing to CE_CFG1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for CE_CFG1
 */
__ISEN_INLINE void ISEN_CE_CFG1__SET(isen_idx_t idp, uint32_t value)
{
    HAL_SET32(__ISEN_CE_CFG1__ADDRESS(idp), value);
}

/** ISEN_CE_CFG1__GET() gets CE_CFG1's current value.
 *
 * When reading from CE_CFG1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__GET(isen_idx_t idp)
{
    return HAL_GET32(__ISEN_CE_CFG1__ADDRESS(idp));
}

/* --------------------- ISEN.CE_CFG1.CE_PS_CURRENT_EMU --------------------- */

/**
<pre>
  ISEN.CE_CFG1.CE_PS_CURRENT_EMU:

    Primary-side, secondary-side current sense select.
    <start table>
    0 "Secondary-side current sense"
    1 "Primary-side current sense"
    <end table>

</pre> */

#define ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Pos                    31                                                                     /*!< Right-most bit position of ce_ps_current_emu in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Msk                    (0x00000001UL << ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Pos)                 /*!< Mask for ce_ps_current_emu in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Shift(v)               (((v) << ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Pos) & ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Msk) /*!< Shift value 'v' into ce_ps_current_emu and mask 'v' to fit it into ce_ps_current_emu field */

/** ISEN_CE_CFG1__CE_PS_CURRENT_EMU__SET() sets CE_CFG1.CE_PS_CURRENT_EMU to given value.
 *
 * When writing to CE_CFG1.CE_PS_CURRENT_EMU, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG1.CE_PS_CURRENT_EMU
 */
__ISEN_INLINE void ISEN_CE_CFG1__CE_PS_CURRENT_EMU__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ~ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG1__SET(idp, reg);
}

/** ISEN_CE_CFG1__CE_PS_CURRENT_EMU__GET() gets CE_CFG1.CE_PS_CURRENT_EMU's current value.
 *
 * When reading from CE_CFG1.CE_PS_CURRENT_EMU, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG1.CE_PS_CURRENT_EMU
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_PS_CURRENT_EMU__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG1__CE_PS_CURRENT_EMU__MODIFY() modifies CE_CFG1.CE_PS_CURRENT_EMU.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @param bf_value new value for CE_CFG1.CE_PS_CURRENT_EMU
 * @return new value of ISEN.CE_CFG1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_PS_CURRENT_EMU__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG1__CE_PS_CURRENT_EMU__EXTRACT() extracts CE_CFG1.CE_PS_CURRENT_EMU.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @return current value of CE_CFG1.CE_PS_CURRENT_EMU
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_PS_CURRENT_EMU__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_PS_CURRENT_EMU__Pos);
    return (uint32_t)reg;
}

/* ------------------------ ISEN.CE_CFG1.CE_LADJ_EN ------------------------ */

/**
<pre>
  ISEN.CE_CFG1.CE_LADJ_EN:

    Inductor slope correction function enable.  When enabled, the controller will auto correct for errors in ce_kslope_didv based on the incoming current sense waveform.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define ISEN_CE_CFG1__CE_LADJ_EN__Pos                           30                                                                     /*!< Right-most bit position of ce_ladj_en in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_LADJ_EN__Msk                           (0x00000001UL << ISEN_CE_CFG1__CE_LADJ_EN__Pos)                        /*!< Mask for ce_ladj_en in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_LADJ_EN__Shift(v)                      (((v) << ISEN_CE_CFG1__CE_LADJ_EN__Pos) & ISEN_CE_CFG1__CE_LADJ_EN__Msk) /*!< Shift value 'v' into ce_ladj_en and mask 'v' to fit it into ce_ladj_en field */

/** ISEN_CE_CFG1__CE_LADJ_EN__SET() sets CE_CFG1.CE_LADJ_EN to given value.
 *
 * When writing to CE_CFG1.CE_LADJ_EN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG1.CE_LADJ_EN
 */
__ISEN_INLINE void ISEN_CE_CFG1__CE_LADJ_EN__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ~ISEN_CE_CFG1__CE_LADJ_EN__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_LADJ_EN__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG1__SET(idp, reg);
}

/** ISEN_CE_CFG1__CE_LADJ_EN__GET() gets CE_CFG1.CE_LADJ_EN's current value.
 *
 * When reading from CE_CFG1.CE_LADJ_EN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG1.CE_LADJ_EN
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_LADJ_EN__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ISEN_CE_CFG1__CE_LADJ_EN__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_LADJ_EN__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG1__CE_LADJ_EN__MODIFY() modifies CE_CFG1.CE_LADJ_EN.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @param bf_value new value for CE_CFG1.CE_LADJ_EN
 * @return new value of ISEN.CE_CFG1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_LADJ_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG1__CE_LADJ_EN__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_LADJ_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG1__CE_LADJ_EN__EXTRACT() extracts CE_CFG1.CE_LADJ_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @return current value of CE_CFG1.CE_LADJ_EN
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_LADJ_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG1__CE_LADJ_EN__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_LADJ_EN__Pos);
    return (uint32_t)reg;
}

/* --------------------- ISEN.CE_CFG1.CE_PWMWIN_TR_DLY --------------------- */

/**
<pre>
  ISEN.CE_CFG1.CE_PWMWIN_TR_DLY:

    Not used.

</pre> */

#define ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Pos                     28                                                                     /*!< Right-most bit position of ce_pwmwin_tr_dly in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Msk                     (0x00000003UL << ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Pos)                  /*!< Mask for ce_pwmwin_tr_dly in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Shift(v)                (((v) << ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Pos) & ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Msk) /*!< Shift value 'v' into ce_pwmwin_tr_dly and mask 'v' to fit it into ce_pwmwin_tr_dly field */

/** ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__SET() sets CE_CFG1.CE_PWMWIN_TR_DLY to given value.
 *
 * When writing to CE_CFG1.CE_PWMWIN_TR_DLY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG1.CE_PWMWIN_TR_DLY
 */
__ISEN_INLINE void ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ~ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG1__SET(idp, reg);
}

/** ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__GET() gets CE_CFG1.CE_PWMWIN_TR_DLY's current value.
 *
 * When reading from CE_CFG1.CE_PWMWIN_TR_DLY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG1.CE_PWMWIN_TR_DLY
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__MODIFY() modifies CE_CFG1.CE_PWMWIN_TR_DLY.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @param bf_value new value for CE_CFG1.CE_PWMWIN_TR_DLY
 * @return new value of ISEN.CE_CFG1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__EXTRACT() extracts CE_CFG1.CE_PWMWIN_TR_DLY.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @return current value of CE_CFG1.CE_PWMWIN_TR_DLY
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_PWMWIN_TR_DLY__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ISEN.CE_CFG1.CE_PWMWIN_DLY ----------------------- */

/**
<pre>
  ISEN.CE_CFG1.CE_PWMWIN_DLY:

    Defines delay used to align internal PWM signals to incoming current sense waveform.
    <start table>
    "Delay = (ce_pwmwin_dly + 1) * 10ns"
    <end table>
    LSB = 10ns, Range = 10 to 320ns

</pre> */

#define ISEN_CE_CFG1__CE_PWMWIN_DLY__Pos                        23                                                                     /*!< Right-most bit position of ce_pwmwin_dly in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_PWMWIN_DLY__Msk                        (0x0000001FUL << ISEN_CE_CFG1__CE_PWMWIN_DLY__Pos)                     /*!< Mask for ce_pwmwin_dly in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_PWMWIN_DLY__Shift(v)                   (((v) << ISEN_CE_CFG1__CE_PWMWIN_DLY__Pos) & ISEN_CE_CFG1__CE_PWMWIN_DLY__Msk) /*!< Shift value 'v' into ce_pwmwin_dly and mask 'v' to fit it into ce_pwmwin_dly field */

/** ISEN_CE_CFG1__CE_PWMWIN_DLY__SET() sets CE_CFG1.CE_PWMWIN_DLY to given value.
 *
 * When writing to CE_CFG1.CE_PWMWIN_DLY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG1.CE_PWMWIN_DLY
 */
__ISEN_INLINE void ISEN_CE_CFG1__CE_PWMWIN_DLY__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ~ISEN_CE_CFG1__CE_PWMWIN_DLY__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_PWMWIN_DLY__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG1__SET(idp, reg);
}

/** ISEN_CE_CFG1__CE_PWMWIN_DLY__GET() gets CE_CFG1.CE_PWMWIN_DLY's current value.
 *
 * When reading from CE_CFG1.CE_PWMWIN_DLY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG1.CE_PWMWIN_DLY
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_PWMWIN_DLY__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ISEN_CE_CFG1__CE_PWMWIN_DLY__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_PWMWIN_DLY__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG1__CE_PWMWIN_DLY__MODIFY() modifies CE_CFG1.CE_PWMWIN_DLY.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @param bf_value new value for CE_CFG1.CE_PWMWIN_DLY
 * @return new value of ISEN.CE_CFG1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_PWMWIN_DLY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG1__CE_PWMWIN_DLY__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_PWMWIN_DLY__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG1__CE_PWMWIN_DLY__EXTRACT() extracts CE_CFG1.CE_PWMWIN_DLY.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @return current value of CE_CFG1.CE_PWMWIN_DLY
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_PWMWIN_DLY__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG1__CE_PWMWIN_DLY__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_PWMWIN_DLY__Pos);
    return (uint32_t)reg;
}

/* ---------------------- ISEN.CE_CFG1.CE_KSLOPE_DIDV ---------------------- */

/**
<pre>
  ISEN.CE_CFG1.CE_KSLOPE_DIDV:

    Output inductor (Lout) current sense slope normalized to Code/Samples @ 1.0V.
    For secondary current sense:
        didv = 1.0V * 10ns / (Lout(nH) * APC(A))
    For primary current sense:
        didv = 1.0V * 10ns / (Nturn * Lout(nH) * APC(A))
    LSB = 2^-13 V/V, Range = 0.0 to 0.25 V/V

</pre> */

#define ISEN_CE_CFG1__CE_KSLOPE_DIDV__Pos                       12                                                                     /*!< Right-most bit position of ce_kslope_didv in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_KSLOPE_DIDV__Msk                       (0x000007FFUL << ISEN_CE_CFG1__CE_KSLOPE_DIDV__Pos)                    /*!< Mask for ce_kslope_didv in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_KSLOPE_DIDV__Shift(v)                  (((v) << ISEN_CE_CFG1__CE_KSLOPE_DIDV__Pos) & ISEN_CE_CFG1__CE_KSLOPE_DIDV__Msk) /*!< Shift value 'v' into ce_kslope_didv and mask 'v' to fit it into ce_kslope_didv field */

/** ISEN_CE_CFG1__CE_KSLOPE_DIDV__SET() sets CE_CFG1.CE_KSLOPE_DIDV to given value.
 *
 * When writing to CE_CFG1.CE_KSLOPE_DIDV, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG1.CE_KSLOPE_DIDV
 */
__ISEN_INLINE void ISEN_CE_CFG1__CE_KSLOPE_DIDV__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ~ISEN_CE_CFG1__CE_KSLOPE_DIDV__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_KSLOPE_DIDV__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG1__SET(idp, reg);
}

/** ISEN_CE_CFG1__CE_KSLOPE_DIDV__GET() gets CE_CFG1.CE_KSLOPE_DIDV's current value.
 *
 * When reading from CE_CFG1.CE_KSLOPE_DIDV, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG1.CE_KSLOPE_DIDV
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KSLOPE_DIDV__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ISEN_CE_CFG1__CE_KSLOPE_DIDV__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_KSLOPE_DIDV__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG1__CE_KSLOPE_DIDV__MODIFY() modifies CE_CFG1.CE_KSLOPE_DIDV.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @param bf_value new value for CE_CFG1.CE_KSLOPE_DIDV
 * @return new value of ISEN.CE_CFG1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KSLOPE_DIDV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG1__CE_KSLOPE_DIDV__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_KSLOPE_DIDV__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG1__CE_KSLOPE_DIDV__EXTRACT() extracts CE_CFG1.CE_KSLOPE_DIDV.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @return current value of CE_CFG1.CE_KSLOPE_DIDV
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KSLOPE_DIDV__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG1__CE_KSLOPE_DIDV__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_KSLOPE_DIDV__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ISEN.CE_CFG1.CE_KTRACK_ON ----------------------- */

/**
<pre>
  ISEN.CE_CFG1.CE_KTRACK_ON:

    Current sense tracking gain in the ON state.  The tracking gain defines the relative stength of the IS ADC based correction term applied to the emulated current waveform.  The ON state generally refers to the state when the output inductor current is in its upward slope cycle (e.g., primary FETs on in a bridge topology).
    LSB = 1/16 V/V, Range = 0 to 15/16 V/V

</pre> */

#define ISEN_CE_CFG1__CE_KTRACK_ON__Pos                         8                                                                      /*!< Right-most bit position of ce_ktrack_on in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_KTRACK_ON__Msk                         (0x0000000FUL << ISEN_CE_CFG1__CE_KTRACK_ON__Pos)                      /*!< Mask for ce_ktrack_on in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_KTRACK_ON__Shift(v)                    (((v) << ISEN_CE_CFG1__CE_KTRACK_ON__Pos) & ISEN_CE_CFG1__CE_KTRACK_ON__Msk) /*!< Shift value 'v' into ce_ktrack_on and mask 'v' to fit it into ce_ktrack_on field */

/** ISEN_CE_CFG1__CE_KTRACK_ON__SET() sets CE_CFG1.CE_KTRACK_ON to given value.
 *
 * When writing to CE_CFG1.CE_KTRACK_ON, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG1.CE_KTRACK_ON
 */
__ISEN_INLINE void ISEN_CE_CFG1__CE_KTRACK_ON__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ~ISEN_CE_CFG1__CE_KTRACK_ON__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_KTRACK_ON__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG1__SET(idp, reg);
}

/** ISEN_CE_CFG1__CE_KTRACK_ON__GET() gets CE_CFG1.CE_KTRACK_ON's current value.
 *
 * When reading from CE_CFG1.CE_KTRACK_ON, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG1.CE_KTRACK_ON
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KTRACK_ON__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ISEN_CE_CFG1__CE_KTRACK_ON__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_KTRACK_ON__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG1__CE_KTRACK_ON__MODIFY() modifies CE_CFG1.CE_KTRACK_ON.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @param bf_value new value for CE_CFG1.CE_KTRACK_ON
 * @return new value of ISEN.CE_CFG1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KTRACK_ON__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG1__CE_KTRACK_ON__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_KTRACK_ON__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG1__CE_KTRACK_ON__EXTRACT() extracts CE_CFG1.CE_KTRACK_ON.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @return current value of CE_CFG1.CE_KTRACK_ON
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KTRACK_ON__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG1__CE_KTRACK_ON__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_KTRACK_ON__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ISEN.CE_CFG1.CE_KTRACK_OFF ----------------------- */

/**
<pre>
  ISEN.CE_CFG1.CE_KTRACK_OFF:

    Current sense tracking gain in the OFF state.  The tracking gain defines the relative stength of the IS ADC based correction term applied to the emulated current waveform.  The OFF state generally refers to the state when the output inductor current is in its downward slope cycle (e.g., primary FETs off, secondary FETs on in a bridge topology).  Note that this register should be set to 0 for primary side current sense and for the boost topology.
    LSB = 1/16 V/V, Range = 0 to 15/16 V/V

</pre> */

#define ISEN_CE_CFG1__CE_KTRACK_OFF__Pos                        4                                                                      /*!< Right-most bit position of ce_ktrack_off in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_KTRACK_OFF__Msk                        (0x0000000FUL << ISEN_CE_CFG1__CE_KTRACK_OFF__Pos)                     /*!< Mask for ce_ktrack_off in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_KTRACK_OFF__Shift(v)                   (((v) << ISEN_CE_CFG1__CE_KTRACK_OFF__Pos) & ISEN_CE_CFG1__CE_KTRACK_OFF__Msk) /*!< Shift value 'v' into ce_ktrack_off and mask 'v' to fit it into ce_ktrack_off field */

/** ISEN_CE_CFG1__CE_KTRACK_OFF__SET() sets CE_CFG1.CE_KTRACK_OFF to given value.
 *
 * When writing to CE_CFG1.CE_KTRACK_OFF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG1.CE_KTRACK_OFF
 */
__ISEN_INLINE void ISEN_CE_CFG1__CE_KTRACK_OFF__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ~ISEN_CE_CFG1__CE_KTRACK_OFF__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_KTRACK_OFF__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG1__SET(idp, reg);
}

/** ISEN_CE_CFG1__CE_KTRACK_OFF__GET() gets CE_CFG1.CE_KTRACK_OFF's current value.
 *
 * When reading from CE_CFG1.CE_KTRACK_OFF, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG1.CE_KTRACK_OFF
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KTRACK_OFF__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ISEN_CE_CFG1__CE_KTRACK_OFF__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_KTRACK_OFF__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG1__CE_KTRACK_OFF__MODIFY() modifies CE_CFG1.CE_KTRACK_OFF.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @param bf_value new value for CE_CFG1.CE_KTRACK_OFF
 * @return new value of ISEN.CE_CFG1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KTRACK_OFF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG1__CE_KTRACK_OFF__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_KTRACK_OFF__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG1__CE_KTRACK_OFF__EXTRACT() extracts CE_CFG1.CE_KTRACK_OFF.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @return current value of CE_CFG1.CE_KTRACK_OFF
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KTRACK_OFF__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG1__CE_KTRACK_OFF__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_KTRACK_OFF__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ISEN.CE_CFG1.CE_KTRACK_HIZ ----------------------- */

/**
<pre>
  ISEN.CE_CFG1.CE_KTRACK_HIZ:

    Current sense tracking gain in the HiZ state.  The tracking gain defines the relative stength of the IS ADC based correction term applied to the emulated current waveform.  The HiZ state generally refers to the state when all primary and secondary switches are off.  Note that this register should be set to 0 for primary side current sense and for the boost topology.
    LSB = 1/16 V/V, Range = 0 to 15/16 V/V

</pre> */

#define ISEN_CE_CFG1__CE_KTRACK_HIZ__Pos                        0                                                                      /*!< Right-most bit position of ce_ktrack_hiz in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_KTRACK_HIZ__Msk                        (0x0000000FUL << ISEN_CE_CFG1__CE_KTRACK_HIZ__Pos)                     /*!< Mask for ce_ktrack_hiz in ISEN.CE_CFG1 */
#define ISEN_CE_CFG1__CE_KTRACK_HIZ__Shift(v)                   (((v) << ISEN_CE_CFG1__CE_KTRACK_HIZ__Pos) & ISEN_CE_CFG1__CE_KTRACK_HIZ__Msk) /*!< Shift value 'v' into ce_ktrack_hiz and mask 'v' to fit it into ce_ktrack_hiz field */

/** ISEN_CE_CFG1__CE_KTRACK_HIZ__SET() sets CE_CFG1.CE_KTRACK_HIZ to given value.
 *
 * When writing to CE_CFG1.CE_KTRACK_HIZ, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG1.CE_KTRACK_HIZ
 */
__ISEN_INLINE void ISEN_CE_CFG1__CE_KTRACK_HIZ__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ~ISEN_CE_CFG1__CE_KTRACK_HIZ__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_KTRACK_HIZ__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG1__SET(idp, reg);
}

/** ISEN_CE_CFG1__CE_KTRACK_HIZ__GET() gets CE_CFG1.CE_KTRACK_HIZ's current value.
 *
 * When reading from CE_CFG1.CE_KTRACK_HIZ, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG1.CE_KTRACK_HIZ
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KTRACK_HIZ__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG1__GET(idp);
    reg = (reg & ISEN_CE_CFG1__CE_KTRACK_HIZ__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_KTRACK_HIZ__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG1__CE_KTRACK_HIZ__MODIFY() modifies CE_CFG1.CE_KTRACK_HIZ.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @param bf_value new value for CE_CFG1.CE_KTRACK_HIZ
 * @return new value of ISEN.CE_CFG1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KTRACK_HIZ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG1__CE_KTRACK_HIZ__Msk);
    reg = (reg | (ISEN_CE_CFG1__CE_KTRACK_HIZ__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG1__CE_KTRACK_HIZ__EXTRACT() extracts CE_CFG1.CE_KTRACK_HIZ.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG1
 * @return current value of CE_CFG1.CE_KTRACK_HIZ
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG1__CE_KTRACK_HIZ__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG1__CE_KTRACK_HIZ__Msk);
    reg = (reg >> ISEN_CE_CFG1__CE_KTRACK_HIZ__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          CE_CFG2 member of ISEN_t                          */
/* -------------------------------------------------------------------------- */

/** __ISEN_CE_CFG2__ADDRESS returns the address of member CE_CFG2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of CE_CFG2
 */
__ISEN_INLINE uint32_t* __ISEN_CE_CFG2__ADDRESS(isen_idx_t idp)
{
    return (uint32_t*)((uint32_t)__ISEN_BASE_PTR(idp) + (uint32_t)(offsetof(ISEN_t, CE_CFG2)));
}

/** ISEN_CE_CFG2__SET() sets CE_CFG2 to given value.
 *
 * When writing to CE_CFG2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for CE_CFG2
 */
__ISEN_INLINE void ISEN_CE_CFG2__SET(isen_idx_t idp, uint32_t value)
{
    HAL_SET32(__ISEN_CE_CFG2__ADDRESS(idp), value);
}

/** ISEN_CE_CFG2__GET() gets CE_CFG2's current value.
 *
 * When reading from CE_CFG2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG2
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG2__GET(isen_idx_t idp)
{
    return HAL_GET32(__ISEN_CE_CFG2__ADDRESS(idp));
}

/* ----------------------- ISEN.CE_CFG2.CE_DT_L_SLOPE ----------------------- */

/**
<pre>
  ISEN.CE_CFG2.CE_DT_L_SLOPE:

    Defines the slope of the output inductance dependence on current.  Although actual inductor variation with current is non-linear this compensation introduces a linear correction to the inductor slope.  It is recommended to use the 0A inductance as one point.  The user can choose the second point for the best fit curve.
    Computed as follows:
        L0 = inductance at 0A
        L1 = inductance at user selected current, I1
        APC = Amps per Code defined by MFR_IOUT_APC
        ce_dt_l_slope = round(2^14 * (L0/L1 - 1) * APC / I1)
    Example:
        L0 = 470nH, L1 = 420nH @ 50A, APC = 0.25
        ce_dt_l_slope = round(2^14 * (470/420 - 1) * 0.25 / 50) = 10
    LSB = 2^-14 Vs/HA, Range = 0.0 to 0.015564 Vs/HA

</pre> */

#define ISEN_CE_CFG2__CE_DT_L_SLOPE__Pos                        24                                                                     /*!< Right-most bit position of ce_dt_l_slope in ISEN.CE_CFG2 */
#define ISEN_CE_CFG2__CE_DT_L_SLOPE__Msk                        (0x000000FFUL << ISEN_CE_CFG2__CE_DT_L_SLOPE__Pos)                     /*!< Mask for ce_dt_l_slope in ISEN.CE_CFG2 */
#define ISEN_CE_CFG2__CE_DT_L_SLOPE__Shift(v)                   (((v) << ISEN_CE_CFG2__CE_DT_L_SLOPE__Pos) & ISEN_CE_CFG2__CE_DT_L_SLOPE__Msk) /*!< Shift value 'v' into ce_dt_l_slope and mask 'v' to fit it into ce_dt_l_slope field */

/** ISEN_CE_CFG2__CE_DT_L_SLOPE__SET() sets CE_CFG2.CE_DT_L_SLOPE to given value.
 *
 * When writing to CE_CFG2.CE_DT_L_SLOPE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG2.CE_DT_L_SLOPE
 */
__ISEN_INLINE void ISEN_CE_CFG2__CE_DT_L_SLOPE__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG2__GET(idp);
    reg = (reg & ~ISEN_CE_CFG2__CE_DT_L_SLOPE__Msk);
    reg = (reg | (ISEN_CE_CFG2__CE_DT_L_SLOPE__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG2__SET(idp, reg);
}

/** ISEN_CE_CFG2__CE_DT_L_SLOPE__GET() gets CE_CFG2.CE_DT_L_SLOPE's current value.
 *
 * When reading from CE_CFG2.CE_DT_L_SLOPE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG2.CE_DT_L_SLOPE
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG2__CE_DT_L_SLOPE__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG2__GET(idp);
    reg = (reg & ISEN_CE_CFG2__CE_DT_L_SLOPE__Msk);
    reg = (reg >> ISEN_CE_CFG2__CE_DT_L_SLOPE__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG2__CE_DT_L_SLOPE__MODIFY() modifies CE_CFG2.CE_DT_L_SLOPE.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG2
 * @param bf_value new value for CE_CFG2.CE_DT_L_SLOPE
 * @return new value of ISEN.CE_CFG2
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG2__CE_DT_L_SLOPE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG2__CE_DT_L_SLOPE__Msk);
    reg = (reg | (ISEN_CE_CFG2__CE_DT_L_SLOPE__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG2__CE_DT_L_SLOPE__EXTRACT() extracts CE_CFG2.CE_DT_L_SLOPE.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG2
 * @return current value of CE_CFG2.CE_DT_L_SLOPE
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG2__CE_DT_L_SLOPE__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG2__CE_DT_L_SLOPE__Msk);
    reg = (reg >> ISEN_CE_CFG2__CE_DT_L_SLOPE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ ISEN.CE_CFG2.CE_ON_MASK1 ------------------------ */

/**
<pre>
  ISEN.CE_CFG2.CE_ON_MASK1:

    Defines the ON state of the current estimator with respect to the PWM outputs where the ON state generally refers to the state when the output inductor current is in its upward slope cycle (e.g., primary FETs on in a bridge topology).  In bridge topologies there are two ON states per switching cycle.  ce_on_mask0 defines the first ON state and ce_on_mask1 defines the second ON state.  In non-bridge topologies (e.g., ACF, Buck) ce_on_mask0 and ce_on_mask1 typically are set to the same value.
    ON state equation:
        ON = &( ~ce_on_mask0[11:0] | pwm[11:0] ) || &( ~ce_on_mask1[11:0] | pwm[11:0] )
    where, [0] corresponds to PWM1, [11] corresponds to PWM12
    <start table_with_header>
    "Primary Topology" "Set ce_on_mask1 bits corresponding to"
    ACF "Q1"
    HB "Q2"
    FB "Q2,Q4"
    Buck "HSFET"
    <end table>

</pre> */

#define ISEN_CE_CFG2__CE_ON_MASK1__Pos                          12                                                                     /*!< Right-most bit position of ce_on_mask1 in ISEN.CE_CFG2 */
#define ISEN_CE_CFG2__CE_ON_MASK1__Msk                          (0x00000FFFUL << ISEN_CE_CFG2__CE_ON_MASK1__Pos)                       /*!< Mask for ce_on_mask1 in ISEN.CE_CFG2 */
#define ISEN_CE_CFG2__CE_ON_MASK1__Shift(v)                     (((v) << ISEN_CE_CFG2__CE_ON_MASK1__Pos) & ISEN_CE_CFG2__CE_ON_MASK1__Msk) /*!< Shift value 'v' into ce_on_mask1 and mask 'v' to fit it into ce_on_mask1 field */

/** ISEN_CE_CFG2__CE_ON_MASK1__SET() sets CE_CFG2.CE_ON_MASK1 to given value.
 *
 * When writing to CE_CFG2.CE_ON_MASK1, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG2.CE_ON_MASK1
 */
__ISEN_INLINE void ISEN_CE_CFG2__CE_ON_MASK1__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG2__GET(idp);
    reg = (reg & ~ISEN_CE_CFG2__CE_ON_MASK1__Msk);
    reg = (reg | (ISEN_CE_CFG2__CE_ON_MASK1__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG2__SET(idp, reg);
}

/** ISEN_CE_CFG2__CE_ON_MASK1__GET() gets CE_CFG2.CE_ON_MASK1's current value.
 *
 * When reading from CE_CFG2.CE_ON_MASK1, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG2.CE_ON_MASK1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG2__CE_ON_MASK1__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG2__GET(idp);
    reg = (reg & ISEN_CE_CFG2__CE_ON_MASK1__Msk);
    reg = (reg >> ISEN_CE_CFG2__CE_ON_MASK1__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG2__CE_ON_MASK1__MODIFY() modifies CE_CFG2.CE_ON_MASK1.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG2
 * @param bf_value new value for CE_CFG2.CE_ON_MASK1
 * @return new value of ISEN.CE_CFG2
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG2__CE_ON_MASK1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG2__CE_ON_MASK1__Msk);
    reg = (reg | (ISEN_CE_CFG2__CE_ON_MASK1__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG2__CE_ON_MASK1__EXTRACT() extracts CE_CFG2.CE_ON_MASK1.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG2
 * @return current value of CE_CFG2.CE_ON_MASK1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG2__CE_ON_MASK1__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG2__CE_ON_MASK1__Msk);
    reg = (reg >> ISEN_CE_CFG2__CE_ON_MASK1__Pos);
    return (uint32_t)reg;
}

/* ------------------------ ISEN.CE_CFG2.CE_ON_MASK0 ------------------------ */

/**
<pre>
  ISEN.CE_CFG2.CE_ON_MASK0:

    Defines the ON state of the current estimator with respect to the PWM outputs where the ON state generally refers to the state when the output inductor current is in its upward slope cycle (e.g., primary FETs on in a bridge topology).  In bridge topologies there are two ON states per switching cycle.  ce_on_mask0 defines the first ON state and ce_on_mask1 defines the second ON state.  In non-bridge topologies (e.g., ACF, Buck) ce_on_mask0 and ce_on_mask1 typically are set to the same value.
    ON state equation:
        ON = &( ~ce_on_mask0[11:0] | pwm[11:0] ) || &( ~ce_on_mask1[11:0] | pwm[11:0] )
    where, [0] corresponds to PWM1, [11] corresponds to PWM12
    <start table_with_header>
    "Primary Topology" "Set ce_on_mask0 bits corresponding to"
    ACF "Q1"
    HB "Q1"
    FB "Q1,Q3"
    Buck "HSFET"
    <end table>

</pre> */

#define ISEN_CE_CFG2__CE_ON_MASK0__Pos                          0                                                                      /*!< Right-most bit position of ce_on_mask0 in ISEN.CE_CFG2 */
#define ISEN_CE_CFG2__CE_ON_MASK0__Msk                          (0x00000FFFUL << ISEN_CE_CFG2__CE_ON_MASK0__Pos)                       /*!< Mask for ce_on_mask0 in ISEN.CE_CFG2 */
#define ISEN_CE_CFG2__CE_ON_MASK0__Shift(v)                     (((v) << ISEN_CE_CFG2__CE_ON_MASK0__Pos) & ISEN_CE_CFG2__CE_ON_MASK0__Msk) /*!< Shift value 'v' into ce_on_mask0 and mask 'v' to fit it into ce_on_mask0 field */

/** ISEN_CE_CFG2__CE_ON_MASK0__SET() sets CE_CFG2.CE_ON_MASK0 to given value.
 *
 * When writing to CE_CFG2.CE_ON_MASK0, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG2.CE_ON_MASK0
 */
__ISEN_INLINE void ISEN_CE_CFG2__CE_ON_MASK0__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG2__GET(idp);
    reg = (reg & ~ISEN_CE_CFG2__CE_ON_MASK0__Msk);
    reg = (reg | (ISEN_CE_CFG2__CE_ON_MASK0__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG2__SET(idp, reg);
}

/** ISEN_CE_CFG2__CE_ON_MASK0__GET() gets CE_CFG2.CE_ON_MASK0's current value.
 *
 * When reading from CE_CFG2.CE_ON_MASK0, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG2.CE_ON_MASK0
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG2__CE_ON_MASK0__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG2__GET(idp);
    reg = (reg & ISEN_CE_CFG2__CE_ON_MASK0__Msk);
    reg = (reg >> ISEN_CE_CFG2__CE_ON_MASK0__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG2__CE_ON_MASK0__MODIFY() modifies CE_CFG2.CE_ON_MASK0.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG2
 * @param bf_value new value for CE_CFG2.CE_ON_MASK0
 * @return new value of ISEN.CE_CFG2
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG2__CE_ON_MASK0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG2__CE_ON_MASK0__Msk);
    reg = (reg | (ISEN_CE_CFG2__CE_ON_MASK0__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG2__CE_ON_MASK0__EXTRACT() extracts CE_CFG2.CE_ON_MASK0.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG2
 * @return current value of CE_CFG2.CE_ON_MASK0
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG2__CE_ON_MASK0__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG2__CE_ON_MASK0__Msk);
    reg = (reg >> ISEN_CE_CFG2__CE_ON_MASK0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          CE_CFG3 member of ISEN_t                          */
/* -------------------------------------------------------------------------- */

/** __ISEN_CE_CFG3__ADDRESS returns the address of member CE_CFG3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of CE_CFG3
 */
__ISEN_INLINE uint32_t* __ISEN_CE_CFG3__ADDRESS(isen_idx_t idp)
{
    return (uint32_t*)((uint32_t)__ISEN_BASE_PTR(idp) + (uint32_t)(offsetof(ISEN_t, CE_CFG3)));
}

/** ISEN_CE_CFG3__SET() sets CE_CFG3 to given value.
 *
 * When writing to CE_CFG3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for CE_CFG3
 */
__ISEN_INLINE void ISEN_CE_CFG3__SET(isen_idx_t idp, uint32_t value)
{
    HAL_SET32(__ISEN_CE_CFG3__ADDRESS(idp), value);
}

/** ISEN_CE_CFG3__GET() gets CE_CFG3's current value.
 *
 * When reading from CE_CFG3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG3
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG3__GET(isen_idx_t idp)
{
    return HAL_GET32(__ISEN_CE_CFG3__ADDRESS(idp));
}

/* ------------------------- ISEN.CE_CFG3.CE_LTRACE ------------------------- */

/**
<pre>
  ISEN.CE_CFG3.CE_LTRACE:

    Defines parasitic trace inductance as seen by current sense input.
    Computed as follows:
        ce_ltrace = Ltrace / (Rtrace * dt)
    where,
    Ltrace = parasitic trace inductance being compensated
    Rtrace = current sense trace resistance
    dt = 10ns
    Example:
        Ltrace = 300pH, Rtrace = 0.5mOhm
        ce_ltrace = 300pH/(1.0mOhm*10ns) = 30
    LSB = 2 H/Ohm-s, Range = 0 to 62 H/Ohm-s

</pre> */

#define ISEN_CE_CFG3__CE_LTRACE__Pos                            24                                                                     /*!< Right-most bit position of ce_ltrace in ISEN.CE_CFG3 */
#define ISEN_CE_CFG3__CE_LTRACE__Msk                            (0x0000001FUL << ISEN_CE_CFG3__CE_LTRACE__Pos)                         /*!< Mask for ce_ltrace in ISEN.CE_CFG3 */
#define ISEN_CE_CFG3__CE_LTRACE__Shift(v)                       (((v) << ISEN_CE_CFG3__CE_LTRACE__Pos) & ISEN_CE_CFG3__CE_LTRACE__Msk) /*!< Shift value 'v' into ce_ltrace and mask 'v' to fit it into ce_ltrace field */

/** ISEN_CE_CFG3__CE_LTRACE__SET() sets CE_CFG3.CE_LTRACE to given value.
 *
 * When writing to CE_CFG3.CE_LTRACE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG3.CE_LTRACE
 */
__ISEN_INLINE void ISEN_CE_CFG3__CE_LTRACE__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG3__GET(idp);
    reg = (reg & ~ISEN_CE_CFG3__CE_LTRACE__Msk);
    reg = (reg | (ISEN_CE_CFG3__CE_LTRACE__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG3__SET(idp, reg);
}

/** ISEN_CE_CFG3__CE_LTRACE__GET() gets CE_CFG3.CE_LTRACE's current value.
 *
 * When reading from CE_CFG3.CE_LTRACE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG3.CE_LTRACE
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG3__CE_LTRACE__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG3__GET(idp);
    reg = (reg & ISEN_CE_CFG3__CE_LTRACE__Msk);
    reg = (reg >> ISEN_CE_CFG3__CE_LTRACE__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG3__CE_LTRACE__MODIFY() modifies CE_CFG3.CE_LTRACE.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG3
 * @param bf_value new value for CE_CFG3.CE_LTRACE
 * @return new value of ISEN.CE_CFG3
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG3__CE_LTRACE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG3__CE_LTRACE__Msk);
    reg = (reg | (ISEN_CE_CFG3__CE_LTRACE__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG3__CE_LTRACE__EXTRACT() extracts CE_CFG3.CE_LTRACE.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG3
 * @return current value of CE_CFG3.CE_LTRACE
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG3__CE_LTRACE__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG3__CE_LTRACE__Msk);
    reg = (reg >> ISEN_CE_CFG3__CE_LTRACE__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ISEN.CE_CFG3.CE_OFF_MASK1 ----------------------- */

/**
<pre>
  ISEN.CE_CFG3.CE_OFF_MASK1:

    Defines the OFF state of the current estimator with respect to the PWM outputs where the OFF state generally refers to the state when the output inductor current is in its downward slope cycle (e.g., primary FETs off, secondary FETs on in a bridge topology).  In bridge topologies there are two OFF states per switching cycle.  ce_off_mask0 defines the first OFF state and ce_on_mask1 defines the second OFF state.  In non-bridge topologies (e.g., ACF, Buck) ce_off_mask0 and ce_off_mask1 typically are set to the same value.
    OFF state equation:
        OFF = &( ~ce_off_mask0[11:0] | pwm[11:0] ) && &( ~ce_off_mask1[11:0] | pwm[11:0] ) && !ON
    where, [0] corresponds to PWM1, [11] corresponds to PWM12 and ON is defined by ce_on_mask0 and ce_on_mask1
    <start table_with_header>
    "Secondary Topology" "Set ce_off_mask1 bits corresponding to"
    ACF "SR2"
    CT "SR1"
    FW "SR1,SR3"
    CDR "SR2"
    Buck "LSFET"
    <end table>

</pre> */

#define ISEN_CE_CFG3__CE_OFF_MASK1__Pos                         12                                                                     /*!< Right-most bit position of ce_off_mask1 in ISEN.CE_CFG3 */
#define ISEN_CE_CFG3__CE_OFF_MASK1__Msk                         (0x00000FFFUL << ISEN_CE_CFG3__CE_OFF_MASK1__Pos)                      /*!< Mask for ce_off_mask1 in ISEN.CE_CFG3 */
#define ISEN_CE_CFG3__CE_OFF_MASK1__Shift(v)                    (((v) << ISEN_CE_CFG3__CE_OFF_MASK1__Pos) & ISEN_CE_CFG3__CE_OFF_MASK1__Msk) /*!< Shift value 'v' into ce_off_mask1 and mask 'v' to fit it into ce_off_mask1 field */

/** ISEN_CE_CFG3__CE_OFF_MASK1__SET() sets CE_CFG3.CE_OFF_MASK1 to given value.
 *
 * When writing to CE_CFG3.CE_OFF_MASK1, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG3.CE_OFF_MASK1
 */
__ISEN_INLINE void ISEN_CE_CFG3__CE_OFF_MASK1__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG3__GET(idp);
    reg = (reg & ~ISEN_CE_CFG3__CE_OFF_MASK1__Msk);
    reg = (reg | (ISEN_CE_CFG3__CE_OFF_MASK1__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG3__SET(idp, reg);
}

/** ISEN_CE_CFG3__CE_OFF_MASK1__GET() gets CE_CFG3.CE_OFF_MASK1's current value.
 *
 * When reading from CE_CFG3.CE_OFF_MASK1, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG3.CE_OFF_MASK1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG3__CE_OFF_MASK1__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG3__GET(idp);
    reg = (reg & ISEN_CE_CFG3__CE_OFF_MASK1__Msk);
    reg = (reg >> ISEN_CE_CFG3__CE_OFF_MASK1__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG3__CE_OFF_MASK1__MODIFY() modifies CE_CFG3.CE_OFF_MASK1.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG3
 * @param bf_value new value for CE_CFG3.CE_OFF_MASK1
 * @return new value of ISEN.CE_CFG3
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG3__CE_OFF_MASK1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG3__CE_OFF_MASK1__Msk);
    reg = (reg | (ISEN_CE_CFG3__CE_OFF_MASK1__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG3__CE_OFF_MASK1__EXTRACT() extracts CE_CFG3.CE_OFF_MASK1.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG3
 * @return current value of CE_CFG3.CE_OFF_MASK1
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG3__CE_OFF_MASK1__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG3__CE_OFF_MASK1__Msk);
    reg = (reg >> ISEN_CE_CFG3__CE_OFF_MASK1__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ISEN.CE_CFG3.CE_OFF_MASK0 ----------------------- */

/**
<pre>
  ISEN.CE_CFG3.CE_OFF_MASK0:

    Defines the OFF state of the current estimator with respect to the PWM outputs where the OFF state generally refers to the state when the output inductor current is in its downward slope cycle (e.g., primary FETs off, secondary FETs on in a bridge topology).  In bridge topologies there are two OFF states per switching cycle.  ce_off_mask0 defines the first OFF state and ce_on_mask1 defines the second OFF state.  In non-bridge topologies (e.g., ACF, Buck) ce_off_mask0 and ce_off_mask1 typically are set to the same value.
    OFF state equation:
        OFF = &( ~ce_off_mask0[11:0] | pwm[11:0] ) && &( ~ce_off_mask1[11:0] | pwm[11:0] ) && !ON
    where, [0] corresponds to PWM1, [11] corresponds to PWM12 and ON is defined by ce_on_mask0 and ce_on_mask1
    <start table_with_header>
    "Secondary Topology" "Set ce_off_mask0 bits corresponding to"
    ACF "SR2"
    CT "SR2"
    FW "SR2,SR4"
    CDR "SR1"
    Buck "LSFET"
    <end table>

</pre> */

#define ISEN_CE_CFG3__CE_OFF_MASK0__Pos                         0                                                                      /*!< Right-most bit position of ce_off_mask0 in ISEN.CE_CFG3 */
#define ISEN_CE_CFG3__CE_OFF_MASK0__Msk                         (0x00000FFFUL << ISEN_CE_CFG3__CE_OFF_MASK0__Pos)                      /*!< Mask for ce_off_mask0 in ISEN.CE_CFG3 */
#define ISEN_CE_CFG3__CE_OFF_MASK0__Shift(v)                    (((v) << ISEN_CE_CFG3__CE_OFF_MASK0__Pos) & ISEN_CE_CFG3__CE_OFF_MASK0__Msk) /*!< Shift value 'v' into ce_off_mask0 and mask 'v' to fit it into ce_off_mask0 field */

/** ISEN_CE_CFG3__CE_OFF_MASK0__SET() sets CE_CFG3.CE_OFF_MASK0 to given value.
 *
 * When writing to CE_CFG3.CE_OFF_MASK0, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG3.CE_OFF_MASK0
 */
__ISEN_INLINE void ISEN_CE_CFG3__CE_OFF_MASK0__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG3__GET(idp);
    reg = (reg & ~ISEN_CE_CFG3__CE_OFF_MASK0__Msk);
    reg = (reg | (ISEN_CE_CFG3__CE_OFF_MASK0__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG3__SET(idp, reg);
}

/** ISEN_CE_CFG3__CE_OFF_MASK0__GET() gets CE_CFG3.CE_OFF_MASK0's current value.
 *
 * When reading from CE_CFG3.CE_OFF_MASK0, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG3.CE_OFF_MASK0
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG3__CE_OFF_MASK0__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG3__GET(idp);
    reg = (reg & ISEN_CE_CFG3__CE_OFF_MASK0__Msk);
    reg = (reg >> ISEN_CE_CFG3__CE_OFF_MASK0__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG3__CE_OFF_MASK0__MODIFY() modifies CE_CFG3.CE_OFF_MASK0.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG3
 * @param bf_value new value for CE_CFG3.CE_OFF_MASK0
 * @return new value of ISEN.CE_CFG3
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG3__CE_OFF_MASK0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG3__CE_OFF_MASK0__Msk);
    reg = (reg | (ISEN_CE_CFG3__CE_OFF_MASK0__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG3__CE_OFF_MASK0__EXTRACT() extracts CE_CFG3.CE_OFF_MASK0.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG3
 * @return current value of CE_CFG3.CE_OFF_MASK0
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG3__CE_OFF_MASK0__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG3__CE_OFF_MASK0__Msk);
    reg = (reg >> ISEN_CE_CFG3__CE_OFF_MASK0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        ISP_FAULT1 member of ISEN_t                        */
/* -------------------------------------------------------------------------- */

/** __ISEN_ISP_FAULT1__ADDRESS returns the address of member ISP_FAULT1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of ISP_FAULT1
 */
__ISEN_INLINE uint32_t* __ISEN_ISP_FAULT1__ADDRESS(isen_idx_t idp)
{
    return (uint32_t*)((uint32_t)__ISEN_BASE_PTR(idp) + (uint32_t)(offsetof(ISEN_t, ISP_FAULT1)));
}

/** ISEN_ISP_FAULT1__SET() sets ISP_FAULT1 to given value.
 *
 * When writing to ISP_FAULT1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for ISP_FAULT1
 */
__ISEN_INLINE void ISEN_ISP_FAULT1__SET(isen_idx_t idp, uint32_t value)
{
    HAL_SET32(__ISEN_ISP_FAULT1__ADDRESS(idp), value);
}

/** ISEN_ISP_FAULT1__GET() gets ISP_FAULT1's current value.
 *
 * When reading from ISP_FAULT1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_FAULT1
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__GET(isen_idx_t idp)
{
    return HAL_GET32(__ISEN_ISP_FAULT1__ADDRESS(idp));
}

/* -------------------- ISEN.ISP_FAULT1.CE_BLANK_PE_DLY -------------------- */

/**
<pre>
  ISEN.ISP_FAULT1.CE_BLANK_PE_DLY:

    Defines the time after a PWM pulse rising edge during which the current sense is in emulation mode only (i.e., the tracking feedback from the current sense ADC is ignored).  This parameter can be used to blank the ADC feedback if the rising PWM edge causes noise on the current sense signal.
    LSB = 40ns, Range = 0 to 280ns

</pre> */

#define ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Pos                   19                                                                     /*!< Right-most bit position of ce_blank_pe_dly in ISEN.ISP_FAULT1 */
#define ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Msk                   (0x00000007UL << ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Pos)                /*!< Mask for ce_blank_pe_dly in ISEN.ISP_FAULT1 */
#define ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Shift(v)              (((v) << ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Pos) & ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Msk) /*!< Shift value 'v' into ce_blank_pe_dly and mask 'v' to fit it into ce_blank_pe_dly field */

/** ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__SET() sets ISP_FAULT1.CE_BLANK_PE_DLY to given value.
 *
 * When writing to ISP_FAULT1.CE_BLANK_PE_DLY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for ISP_FAULT1.CE_BLANK_PE_DLY
 */
__ISEN_INLINE void ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_ISP_FAULT1__GET(idp);
    reg = (reg & ~ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Msk);
    reg = (reg | (ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Shift((uint32_t)bf_value)));
    ISEN_ISP_FAULT1__SET(idp, reg);
}

/** ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__GET() gets ISP_FAULT1.CE_BLANK_PE_DLY's current value.
 *
 * When reading from ISP_FAULT1.CE_BLANK_PE_DLY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_FAULT1.CE_BLANK_PE_DLY
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_ISP_FAULT1__GET(idp);
    reg = (reg & ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Msk);
    reg = (reg >> ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Pos);
    return (uint32_t)reg;
}

/** ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__MODIFY() modifies ISP_FAULT1.CE_BLANK_PE_DLY.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.ISP_FAULT1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.ISP_FAULT1
 * @param bf_value new value for ISP_FAULT1.CE_BLANK_PE_DLY
 * @return new value of ISEN.ISP_FAULT1
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Msk);
    reg = (reg | (ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__EXTRACT() extracts ISP_FAULT1.CE_BLANK_PE_DLY.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.ISP_FAULT1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.ISP_FAULT1
 * @return current value of ISP_FAULT1.CE_BLANK_PE_DLY
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Msk);
    reg = (reg >> ISEN_ISP_FAULT1__CE_BLANK_PE_DLY__Pos);
    return (uint32_t)reg;
}

/* -------------------- ISEN.ISP_FAULT1.CE_BLANK_NE_DLY -------------------- */

/**
<pre>
  ISEN.ISP_FAULT1.CE_BLANK_NE_DLY:

    Defines the time after a PWM pulse falling edge during which the current sense is in emulation mode only (i.e., the tracking feedback from the current sense ADC is ignored).  This parameter can be used to blank the ADC feedback if the falling PWM edge causes noise on the current sense signal.
    LSB = 40ns, Range = 0 to 280ns

</pre> */

#define ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Pos                   16                                                                     /*!< Right-most bit position of ce_blank_ne_dly in ISEN.ISP_FAULT1 */
#define ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Msk                   (0x00000007UL << ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Pos)                /*!< Mask for ce_blank_ne_dly in ISEN.ISP_FAULT1 */
#define ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Shift(v)              (((v) << ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Pos) & ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Msk) /*!< Shift value 'v' into ce_blank_ne_dly and mask 'v' to fit it into ce_blank_ne_dly field */

/** ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__SET() sets ISP_FAULT1.CE_BLANK_NE_DLY to given value.
 *
 * When writing to ISP_FAULT1.CE_BLANK_NE_DLY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for ISP_FAULT1.CE_BLANK_NE_DLY
 */
__ISEN_INLINE void ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_ISP_FAULT1__GET(idp);
    reg = (reg & ~ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Msk);
    reg = (reg | (ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Shift((uint32_t)bf_value)));
    ISEN_ISP_FAULT1__SET(idp, reg);
}

/** ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__GET() gets ISP_FAULT1.CE_BLANK_NE_DLY's current value.
 *
 * When reading from ISP_FAULT1.CE_BLANK_NE_DLY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_FAULT1.CE_BLANK_NE_DLY
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_ISP_FAULT1__GET(idp);
    reg = (reg & ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Msk);
    reg = (reg >> ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Pos);
    return (uint32_t)reg;
}

/** ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__MODIFY() modifies ISP_FAULT1.CE_BLANK_NE_DLY.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.ISP_FAULT1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.ISP_FAULT1
 * @param bf_value new value for ISP_FAULT1.CE_BLANK_NE_DLY
 * @return new value of ISEN.ISP_FAULT1
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Msk);
    reg = (reg | (ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__EXTRACT() extracts ISP_FAULT1.CE_BLANK_NE_DLY.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.ISP_FAULT1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.ISP_FAULT1
 * @return current value of ISP_FAULT1.CE_BLANK_NE_DLY
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Msk);
    reg = (reg >> ISEN_ISP_FAULT1__CE_BLANK_NE_DLY__Pos);
    return (uint32_t)reg;
}

/* --------------------- ISEN.ISP_FAULT1.ISP_NCL_THRESH --------------------- */

/**
<pre>
  ISEN.ISP_FAULT1.ISP_NCL_THRESH:

    Inductor negative current limit (NCL) fault threshold. The NCL threshold is compared agains the instantaneous phase current.  When the phase current drops below the NCL thrshold the response is to turn off the FETs associated with the OFF state defined in ce_off_mask0,1.  In isolated topologies this corresponds to the SR FETs.
    In general, turning off the SR FETs with a large negative inductor current does not produce a desirable result.  It is therefore recomended to disable this feature in isolated topologies.  Set to the max positive setting, 127, to disable this fault protection and its response.
    LSB = 0.25A, Range = -32 to +31.75A

</pre> */

#define ISEN_ISP_FAULT1__ISP_NCL_THRESH__Pos                    8                                                                      /*!< Right-most bit position of isp_ncl_thresh in ISEN.ISP_FAULT1 */
#define ISEN_ISP_FAULT1__ISP_NCL_THRESH__Msk                    (0x000000FFUL << ISEN_ISP_FAULT1__ISP_NCL_THRESH__Pos)                 /*!< Mask for isp_ncl_thresh in ISEN.ISP_FAULT1 */
#define ISEN_ISP_FAULT1__ISP_NCL_THRESH__Shift(v)               (((v) << ISEN_ISP_FAULT1__ISP_NCL_THRESH__Pos) & ISEN_ISP_FAULT1__ISP_NCL_THRESH__Msk) /*!< Shift value 'v' into isp_ncl_thresh and mask 'v' to fit it into isp_ncl_thresh field */

/** ISEN_ISP_FAULT1__ISP_NCL_THRESH__SET() sets ISP_FAULT1.ISP_NCL_THRESH to given value.
 *
 * When writing to ISP_FAULT1.ISP_NCL_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for ISP_FAULT1.ISP_NCL_THRESH
 */
__ISEN_INLINE void ISEN_ISP_FAULT1__ISP_NCL_THRESH__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_ISP_FAULT1__GET(idp);
    reg = (reg & ~ISEN_ISP_FAULT1__ISP_NCL_THRESH__Msk);
    reg = (reg | (ISEN_ISP_FAULT1__ISP_NCL_THRESH__Shift((uint32_t)bf_value)));
    ISEN_ISP_FAULT1__SET(idp, reg);
}

/** ISEN_ISP_FAULT1__ISP_NCL_THRESH__GET() gets ISP_FAULT1.ISP_NCL_THRESH's current value.
 *
 * When reading from ISP_FAULT1.ISP_NCL_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_FAULT1.ISP_NCL_THRESH
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__ISP_NCL_THRESH__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_ISP_FAULT1__GET(idp);
    reg = (reg & ISEN_ISP_FAULT1__ISP_NCL_THRESH__Msk);
    reg = (reg >> ISEN_ISP_FAULT1__ISP_NCL_THRESH__Pos);
    return (uint32_t)reg;
}

/** ISEN_ISP_FAULT1__ISP_NCL_THRESH__MODIFY() modifies ISP_FAULT1.ISP_NCL_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.ISP_FAULT1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.ISP_FAULT1
 * @param bf_value new value for ISP_FAULT1.ISP_NCL_THRESH
 * @return new value of ISEN.ISP_FAULT1
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__ISP_NCL_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_ISP_FAULT1__ISP_NCL_THRESH__Msk);
    reg = (reg | (ISEN_ISP_FAULT1__ISP_NCL_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_ISP_FAULT1__ISP_NCL_THRESH__EXTRACT() extracts ISP_FAULT1.ISP_NCL_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.ISP_FAULT1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.ISP_FAULT1
 * @return current value of ISP_FAULT1.ISP_NCL_THRESH
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__ISP_NCL_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_ISP_FAULT1__ISP_NCL_THRESH__Msk);
    reg = (reg >> ISEN_ISP_FAULT1__ISP_NCL_THRESH__Pos);
    return (uint32_t)reg;
}

/* --------------------- ISEN.ISP_FAULT1.ISP_SCP_THRESH --------------------- */

/**
<pre>
  ISEN.ISP_FAULT1.ISP_SCP_THRESH:

    Short ciruit protection (SCP) fault threshold.  The SCP threshold should be set highest among the various current protection thresholds as it requires only a single sample above the threshold to trip. The SCP threshold is applied per phase on multi-phase topologies.  Set this threshold to 0 to disable the fault detection.
    LSB = 1A, Range = 0 to 255A

</pre> */

#define ISEN_ISP_FAULT1__ISP_SCP_THRESH__Pos                    0                                                                      /*!< Right-most bit position of isp_scp_thresh in ISEN.ISP_FAULT1 */
#define ISEN_ISP_FAULT1__ISP_SCP_THRESH__Msk                    (0x000000FFUL << ISEN_ISP_FAULT1__ISP_SCP_THRESH__Pos)                 /*!< Mask for isp_scp_thresh in ISEN.ISP_FAULT1 */
#define ISEN_ISP_FAULT1__ISP_SCP_THRESH__Shift(v)               (((v) << ISEN_ISP_FAULT1__ISP_SCP_THRESH__Pos) & ISEN_ISP_FAULT1__ISP_SCP_THRESH__Msk) /*!< Shift value 'v' into isp_scp_thresh and mask 'v' to fit it into isp_scp_thresh field */

/** ISEN_ISP_FAULT1__ISP_SCP_THRESH__SET() sets ISP_FAULT1.ISP_SCP_THRESH to given value.
 *
 * When writing to ISP_FAULT1.ISP_SCP_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for ISP_FAULT1.ISP_SCP_THRESH
 */
__ISEN_INLINE void ISEN_ISP_FAULT1__ISP_SCP_THRESH__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_ISP_FAULT1__GET(idp);
    reg = (reg & ~ISEN_ISP_FAULT1__ISP_SCP_THRESH__Msk);
    reg = (reg | (ISEN_ISP_FAULT1__ISP_SCP_THRESH__Shift((uint32_t)bf_value)));
    ISEN_ISP_FAULT1__SET(idp, reg);
}

/** ISEN_ISP_FAULT1__ISP_SCP_THRESH__GET() gets ISP_FAULT1.ISP_SCP_THRESH's current value.
 *
 * When reading from ISP_FAULT1.ISP_SCP_THRESH, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_FAULT1.ISP_SCP_THRESH
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__ISP_SCP_THRESH__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_ISP_FAULT1__GET(idp);
    reg = (reg & ISEN_ISP_FAULT1__ISP_SCP_THRESH__Msk);
    reg = (reg >> ISEN_ISP_FAULT1__ISP_SCP_THRESH__Pos);
    return (uint32_t)reg;
}

/** ISEN_ISP_FAULT1__ISP_SCP_THRESH__MODIFY() modifies ISP_FAULT1.ISP_SCP_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.ISP_FAULT1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.ISP_FAULT1
 * @param bf_value new value for ISP_FAULT1.ISP_SCP_THRESH
 * @return new value of ISEN.ISP_FAULT1
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__ISP_SCP_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_ISP_FAULT1__ISP_SCP_THRESH__Msk);
    reg = (reg | (ISEN_ISP_FAULT1__ISP_SCP_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_ISP_FAULT1__ISP_SCP_THRESH__EXTRACT() extracts ISP_FAULT1.ISP_SCP_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.ISP_FAULT1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.ISP_FAULT1
 * @return current value of ISP_FAULT1.ISP_SCP_THRESH
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT1__ISP_SCP_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_ISP_FAULT1__ISP_SCP_THRESH__Msk);
    reg = (reg >> ISEN_ISP_FAULT1__ISP_SCP_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          CE_CFG4 member of ISEN_t                          */
/* -------------------------------------------------------------------------- */

/** __ISEN_CE_CFG4__ADDRESS returns the address of member CE_CFG4.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of CE_CFG4
 */
__ISEN_INLINE uint32_t* __ISEN_CE_CFG4__ADDRESS(isen_idx_t idp)
{
    return (uint32_t*)((uint32_t)__ISEN_BASE_PTR(idp) + (uint32_t)(offsetof(ISEN_t, CE_CFG4)));
}

/** ISEN_CE_CFG4__SET() sets CE_CFG4 to given value.
 *
 * When writing to CE_CFG4, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for CE_CFG4
 */
__ISEN_INLINE void ISEN_CE_CFG4__SET(isen_idx_t idp, uint32_t value)
{
    HAL_SET32(__ISEN_CE_CFG4__ADDRESS(idp), value);
}

/** ISEN_CE_CFG4__GET() gets CE_CFG4's current value.
 *
 * When reading from CE_CFG4, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG4
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__GET(isen_idx_t idp)
{
    return HAL_GET32(__ISEN_CE_CFG4__ADDRESS(idp));
}

/* --------------------- ISEN.CE_CFG4.ISP_FSW_SYNC_SEL --------------------- */

/**
<pre>
  ISEN.CE_CFG4.ISP_FSW_SYNC_SEL:

    Defines which loop's frequency is used for averaging current over switching cycle.
    <start table>
    0 "Loop 0 Fswitch"
    1 "Loop 1 Fswitch"
    <end table>
    If ISEN is assigned to Loop 0 and BISEN assigned to Loop 1 then set isen0.isp_fsw_sync_sel=0 and isen1.isp_fsw_sync_sel=1.  If both ISEN and BISEN are assigned to Loop 0 then set both parameters to 0.

</pre> */

#define ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Pos                     29                                                                     /*!< Right-most bit position of isp_fsw_sync_sel in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Msk                     (0x00000001UL << ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Pos)                  /*!< Mask for isp_fsw_sync_sel in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Shift(v)                (((v) << ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Pos) & ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Msk) /*!< Shift value 'v' into isp_fsw_sync_sel and mask 'v' to fit it into isp_fsw_sync_sel field */

/** ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__SET() sets CE_CFG4.ISP_FSW_SYNC_SEL to given value.
 *
 * When writing to CE_CFG4.ISP_FSW_SYNC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG4.ISP_FSW_SYNC_SEL
 */
__ISEN_INLINE void ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ~ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Msk);
    reg = (reg | (ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG4__SET(idp, reg);
}

/** ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__GET() gets CE_CFG4.ISP_FSW_SYNC_SEL's current value.
 *
 * When reading from CE_CFG4.ISP_FSW_SYNC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG4.ISP_FSW_SYNC_SEL
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Msk);
    reg = (reg >> ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__MODIFY() modifies CE_CFG4.ISP_FSW_SYNC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @param bf_value new value for CE_CFG4.ISP_FSW_SYNC_SEL
 * @return new value of ISEN.CE_CFG4
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Msk);
    reg = (reg | (ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__EXTRACT() extracts CE_CFG4.ISP_FSW_SYNC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @return current value of CE_CFG4.ISP_FSW_SYNC_SEL
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Msk);
    reg = (reg >> ISEN_CE_CFG4__ISP_FSW_SYNC_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------------ ISEN.CE_CFG4.CE_TOPOLOGY ------------------------ */

/**
<pre>
  ISEN.CE_CFG4.CE_TOPOLOGY:

    Current emulator topology select.  Defines the inductor voltage equations for Von, Voff.
    <start table_with_header>
    [1:0] Topologies
    0 "Buck, ACF, HB, FB"
    1 "Boost"
    2,3 "Buck-Boost"
    <end table>

</pre> */

#define ISEN_CE_CFG4__CE_TOPOLOGY__Pos                          27                                                                     /*!< Right-most bit position of ce_topology in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_TOPOLOGY__Msk                          (0x00000003UL << ISEN_CE_CFG4__CE_TOPOLOGY__Pos)                       /*!< Mask for ce_topology in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_TOPOLOGY__Shift(v)                     (((v) << ISEN_CE_CFG4__CE_TOPOLOGY__Pos) & ISEN_CE_CFG4__CE_TOPOLOGY__Msk) /*!< Shift value 'v' into ce_topology and mask 'v' to fit it into ce_topology field */

/** ISEN_CE_CFG4__CE_TOPOLOGY__SET() sets CE_CFG4.CE_TOPOLOGY to given value.
 *
 * When writing to CE_CFG4.CE_TOPOLOGY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG4.CE_TOPOLOGY
 */
__ISEN_INLINE void ISEN_CE_CFG4__CE_TOPOLOGY__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ~ISEN_CE_CFG4__CE_TOPOLOGY__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_TOPOLOGY__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG4__SET(idp, reg);
}

/** ISEN_CE_CFG4__CE_TOPOLOGY__GET() gets CE_CFG4.CE_TOPOLOGY's current value.
 *
 * When reading from CE_CFG4.CE_TOPOLOGY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG4.CE_TOPOLOGY
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_TOPOLOGY__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ISEN_CE_CFG4__CE_TOPOLOGY__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_TOPOLOGY__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG4__CE_TOPOLOGY__MODIFY() modifies CE_CFG4.CE_TOPOLOGY.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @param bf_value new value for CE_CFG4.CE_TOPOLOGY
 * @return new value of ISEN.CE_CFG4
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_TOPOLOGY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG4__CE_TOPOLOGY__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_TOPOLOGY__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG4__CE_TOPOLOGY__EXTRACT() extracts CE_CFG4.CE_TOPOLOGY.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @return current value of CE_CFG4.CE_TOPOLOGY
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_TOPOLOGY__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG4__CE_TOPOLOGY__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_TOPOLOGY__Pos);
    return (uint32_t)reg;
}

/* --------------------- ISEN.CE_CFG4.CE_CURRENT_LIMIT --------------------- */

/**
<pre>
  ISEN.CE_CFG4.CE_CURRENT_LIMIT:

    Inductor peak current limit (PCL) fault threshold in ADC codes. The PWM pulse will be truncated beyond this limit.  Set to 0 to disable PCL fault protection.
    <start table>
    "ce_current_limit(U9.0) = current_limit(Amps) / (MFR_IOUT_APC (Amps))"
    <end table>
    LSB = 1A, Range = 0 to 511A

</pre> */

#define ISEN_CE_CFG4__CE_CURRENT_LIMIT__Pos                     18                                                                     /*!< Right-most bit position of ce_current_limit in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_CURRENT_LIMIT__Msk                     (0x000001FFUL << ISEN_CE_CFG4__CE_CURRENT_LIMIT__Pos)                  /*!< Mask for ce_current_limit in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_CURRENT_LIMIT__Shift(v)                (((v) << ISEN_CE_CFG4__CE_CURRENT_LIMIT__Pos) & ISEN_CE_CFG4__CE_CURRENT_LIMIT__Msk) /*!< Shift value 'v' into ce_current_limit and mask 'v' to fit it into ce_current_limit field */

/** ISEN_CE_CFG4__CE_CURRENT_LIMIT__SET() sets CE_CFG4.CE_CURRENT_LIMIT to given value.
 *
 * When writing to CE_CFG4.CE_CURRENT_LIMIT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG4.CE_CURRENT_LIMIT
 */
__ISEN_INLINE void ISEN_CE_CFG4__CE_CURRENT_LIMIT__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ~ISEN_CE_CFG4__CE_CURRENT_LIMIT__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_CURRENT_LIMIT__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG4__SET(idp, reg);
}

/** ISEN_CE_CFG4__CE_CURRENT_LIMIT__GET() gets CE_CFG4.CE_CURRENT_LIMIT's current value.
 *
 * When reading from CE_CFG4.CE_CURRENT_LIMIT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG4.CE_CURRENT_LIMIT
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_CURRENT_LIMIT__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ISEN_CE_CFG4__CE_CURRENT_LIMIT__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_CURRENT_LIMIT__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG4__CE_CURRENT_LIMIT__MODIFY() modifies CE_CFG4.CE_CURRENT_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @param bf_value new value for CE_CFG4.CE_CURRENT_LIMIT
 * @return new value of ISEN.CE_CFG4
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_CURRENT_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG4__CE_CURRENT_LIMIT__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_CURRENT_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG4__CE_CURRENT_LIMIT__EXTRACT() extracts CE_CFG4.CE_CURRENT_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @return current value of CE_CFG4.CE_CURRENT_LIMIT
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_CURRENT_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG4__CE_CURRENT_LIMIT__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_CURRENT_LIMIT__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ISEN.CE_CFG4.CE_VRECT_SEL ----------------------- */

/**
<pre>
  ISEN.CE_CFG4.CE_VRECT_SEL:

    Current sense Vrect source select.
    <start table_with_header>
    Value "CE0 (ISEN)" "CE1 (BISEN)"
    0 "VRS1" "VRS1"
    1 "VRS2" "VRS2"
    2 "pid_ff_vrect_override" "pid_ff_vrect_override"
    3 "PRISEN" "PRISEN"
    4 "VRS1" "Loop 0 Vout"
    5 "VRS2" "Loop 0 Vout"
    6 "pid_ff_vrect_override" "Loop 0 Vout"
    7 "PRISEN" "Loop 0 Vout"
    <end table>

</pre> */

#define ISEN_CE_CFG4__CE_VRECT_SEL__Pos                         15                                                                     /*!< Right-most bit position of ce_vrect_sel in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_VRECT_SEL__Msk                         (0x00000007UL << ISEN_CE_CFG4__CE_VRECT_SEL__Pos)                      /*!< Mask for ce_vrect_sel in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_VRECT_SEL__Shift(v)                    (((v) << ISEN_CE_CFG4__CE_VRECT_SEL__Pos) & ISEN_CE_CFG4__CE_VRECT_SEL__Msk) /*!< Shift value 'v' into ce_vrect_sel and mask 'v' to fit it into ce_vrect_sel field */

/** ISEN_CE_CFG4__CE_VRECT_SEL__SET() sets CE_CFG4.CE_VRECT_SEL to given value.
 *
 * When writing to CE_CFG4.CE_VRECT_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG4.CE_VRECT_SEL
 */
__ISEN_INLINE void ISEN_CE_CFG4__CE_VRECT_SEL__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ~ISEN_CE_CFG4__CE_VRECT_SEL__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_VRECT_SEL__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG4__SET(idp, reg);
}

/** ISEN_CE_CFG4__CE_VRECT_SEL__GET() gets CE_CFG4.CE_VRECT_SEL's current value.
 *
 * When reading from CE_CFG4.CE_VRECT_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG4.CE_VRECT_SEL
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_VRECT_SEL__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ISEN_CE_CFG4__CE_VRECT_SEL__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_VRECT_SEL__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG4__CE_VRECT_SEL__MODIFY() modifies CE_CFG4.CE_VRECT_SEL.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @param bf_value new value for CE_CFG4.CE_VRECT_SEL
 * @return new value of ISEN.CE_CFG4
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_VRECT_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG4__CE_VRECT_SEL__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_VRECT_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG4__CE_VRECT_SEL__EXTRACT() extracts CE_CFG4.CE_VRECT_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @return current value of CE_CFG4.CE_VRECT_SEL
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_VRECT_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG4__CE_VRECT_SEL__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_VRECT_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------------ ISEN.CE_CFG4.CE_VOUT_SEL ------------------------ */

/**
<pre>
  ISEN.CE_CFG4.CE_VOUT_SEL:

    Current sense Vout source select.  Note that CDR in the table below indicates Current DoubleR topology on the secondary.
    <start table_with_header>
    Value "CE0 (ISEN)" "CE1 (BISEN)"
    0 "Loop 0 Vout" "Loop 0 Vout"
    1 "Loop 0 Vout CDR" "Loop 0 Vout CDR"
    2 "Loop 0 Vout" "Loop 1 Vout"
    3 "Loop 0 Vout CDR" "Loop 1 Vout CDR"
    <end table>

</pre> */

#define ISEN_CE_CFG4__CE_VOUT_SEL__Pos                          13                                                                     /*!< Right-most bit position of ce_vout_sel in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_VOUT_SEL__Msk                          (0x00000003UL << ISEN_CE_CFG4__CE_VOUT_SEL__Pos)                       /*!< Mask for ce_vout_sel in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_VOUT_SEL__Shift(v)                     (((v) << ISEN_CE_CFG4__CE_VOUT_SEL__Pos) & ISEN_CE_CFG4__CE_VOUT_SEL__Msk) /*!< Shift value 'v' into ce_vout_sel and mask 'v' to fit it into ce_vout_sel field */

/** ISEN_CE_CFG4__CE_VOUT_SEL__SET() sets CE_CFG4.CE_VOUT_SEL to given value.
 *
 * When writing to CE_CFG4.CE_VOUT_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG4.CE_VOUT_SEL
 */
__ISEN_INLINE void ISEN_CE_CFG4__CE_VOUT_SEL__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ~ISEN_CE_CFG4__CE_VOUT_SEL__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_VOUT_SEL__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG4__SET(idp, reg);
}

/** ISEN_CE_CFG4__CE_VOUT_SEL__GET() gets CE_CFG4.CE_VOUT_SEL's current value.
 *
 * When reading from CE_CFG4.CE_VOUT_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG4.CE_VOUT_SEL
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_VOUT_SEL__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ISEN_CE_CFG4__CE_VOUT_SEL__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_VOUT_SEL__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG4__CE_VOUT_SEL__MODIFY() modifies CE_CFG4.CE_VOUT_SEL.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @param bf_value new value for CE_CFG4.CE_VOUT_SEL
 * @return new value of ISEN.CE_CFG4
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_VOUT_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG4__CE_VOUT_SEL__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_VOUT_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG4__CE_VOUT_SEL__EXTRACT() extracts CE_CFG4.CE_VOUT_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @return current value of CE_CFG4.CE_VOUT_SEL
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_VOUT_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG4__CE_VOUT_SEL__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_VOUT_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------------- ISEN.CE_CFG4.CE_ITERM ------------------------- */

/**
<pre>
  ISEN.CE_CFG4.CE_ITERM:

    Current sense tracking error integrator coefficient.  Set to 0 to disable error accumulation.
    LSB = 2^-13 A/A, Range = 0.0 to 1.833e-3 A/A

</pre> */

#define ISEN_CE_CFG4__CE_ITERM__Pos                             9                                                                      /*!< Right-most bit position of ce_iterm in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_ITERM__Msk                             (0x0000000FUL << ISEN_CE_CFG4__CE_ITERM__Pos)                          /*!< Mask for ce_iterm in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_ITERM__Shift(v)                        (((v) << ISEN_CE_CFG4__CE_ITERM__Pos) & ISEN_CE_CFG4__CE_ITERM__Msk)   /*!< Shift value 'v' into ce_iterm and mask 'v' to fit it into ce_iterm field */

/** ISEN_CE_CFG4__CE_ITERM__SET() sets CE_CFG4.CE_ITERM to given value.
 *
 * When writing to CE_CFG4.CE_ITERM, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG4.CE_ITERM
 */
__ISEN_INLINE void ISEN_CE_CFG4__CE_ITERM__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ~ISEN_CE_CFG4__CE_ITERM__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_ITERM__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG4__SET(idp, reg);
}

/** ISEN_CE_CFG4__CE_ITERM__GET() gets CE_CFG4.CE_ITERM's current value.
 *
 * When reading from CE_CFG4.CE_ITERM, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG4.CE_ITERM
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_ITERM__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ISEN_CE_CFG4__CE_ITERM__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_ITERM__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG4__CE_ITERM__MODIFY() modifies CE_CFG4.CE_ITERM.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @param bf_value new value for CE_CFG4.CE_ITERM
 * @return new value of ISEN.CE_CFG4
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_ITERM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG4__CE_ITERM__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_ITERM__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG4__CE_ITERM__EXTRACT() extracts CE_CFG4.CE_ITERM.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @return current value of CE_CFG4.CE_ITERM
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_ITERM__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG4__CE_ITERM__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_ITERM__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ISEN.CE_CFG4.CE_KSLOPE_LM ----------------------- */

/**
<pre>
  ISEN.CE_CFG4.CE_KSLOPE_LM:

    Transformer magnetizing inductance (Lm) current sense slope normalized to Code/Samples @ 1.0V.  Only used for primary side current sense.
    <start table>
    "ce_kslope_lm(U-4.13) = 1.0V * 10ns * Nturn / (Lm(nH) * APC(A))"
    <end table>
    LSB = 2^-13 V/V, Range = 0.0 to 0.06238 V/V

</pre> */

#define ISEN_CE_CFG4__CE_KSLOPE_LM__Pos                         0                                                                      /*!< Right-most bit position of ce_kslope_lm in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_KSLOPE_LM__Msk                         (0x000001FFUL << ISEN_CE_CFG4__CE_KSLOPE_LM__Pos)                      /*!< Mask for ce_kslope_lm in ISEN.CE_CFG4 */
#define ISEN_CE_CFG4__CE_KSLOPE_LM__Shift(v)                    (((v) << ISEN_CE_CFG4__CE_KSLOPE_LM__Pos) & ISEN_CE_CFG4__CE_KSLOPE_LM__Msk) /*!< Shift value 'v' into ce_kslope_lm and mask 'v' to fit it into ce_kslope_lm field */

/** ISEN_CE_CFG4__CE_KSLOPE_LM__SET() sets CE_CFG4.CE_KSLOPE_LM to given value.
 *
 * When writing to CE_CFG4.CE_KSLOPE_LM, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for CE_CFG4.CE_KSLOPE_LM
 */
__ISEN_INLINE void ISEN_CE_CFG4__CE_KSLOPE_LM__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ~ISEN_CE_CFG4__CE_KSLOPE_LM__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_KSLOPE_LM__Shift((uint32_t)bf_value)));
    ISEN_CE_CFG4__SET(idp, reg);
}

/** ISEN_CE_CFG4__CE_KSLOPE_LM__GET() gets CE_CFG4.CE_KSLOPE_LM's current value.
 *
 * When reading from CE_CFG4.CE_KSLOPE_LM, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of CE_CFG4.CE_KSLOPE_LM
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_KSLOPE_LM__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_CE_CFG4__GET(idp);
    reg = (reg & ISEN_CE_CFG4__CE_KSLOPE_LM__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_KSLOPE_LM__Pos);
    return (uint32_t)reg;
}

/** ISEN_CE_CFG4__CE_KSLOPE_LM__MODIFY() modifies CE_CFG4.CE_KSLOPE_LM.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.CE_CFG4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @param bf_value new value for CE_CFG4.CE_KSLOPE_LM
 * @return new value of ISEN.CE_CFG4
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_KSLOPE_LM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_CE_CFG4__CE_KSLOPE_LM__Msk);
    reg = (reg | (ISEN_CE_CFG4__CE_KSLOPE_LM__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_CE_CFG4__CE_KSLOPE_LM__EXTRACT() extracts CE_CFG4.CE_KSLOPE_LM.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.CE_CFG4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.CE_CFG4
 * @return current value of CE_CFG4.CE_KSLOPE_LM
 */
__ISEN_INLINE uint32_t ISEN_CE_CFG4__CE_KSLOPE_LM__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_CE_CFG4__CE_KSLOPE_LM__Msk);
    reg = (reg >> ISEN_CE_CFG4__CE_KSLOPE_LM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        ISP_FAULT2 member of ISEN_t                        */
/* -------------------------------------------------------------------------- */

/** __ISEN_ISP_FAULT2__ADDRESS returns the address of member ISP_FAULT2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of ISP_FAULT2
 */
__ISEN_INLINE uint32_t* __ISEN_ISP_FAULT2__ADDRESS(isen_idx_t idp)
{
    return (uint32_t*)((uint32_t)__ISEN_BASE_PTR(idp) + (uint32_t)(offsetof(ISEN_t, ISP_FAULT2)));
}

/** ISEN_ISP_FAULT2__SET() sets ISP_FAULT2 to given value.
 *
 * When writing to ISP_FAULT2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for ISP_FAULT2
 */
__ISEN_INLINE void ISEN_ISP_FAULT2__SET(isen_idx_t idp, uint32_t value)
{
    HAL_SET32(__ISEN_ISP_FAULT2__ADDRESS(idp), value);
}

/** ISEN_ISP_FAULT2__GET() gets ISP_FAULT2's current value.
 *
 * When reading from ISP_FAULT2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_FAULT2
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT2__GET(isen_idx_t idp)
{
    return HAL_GET32(__ISEN_ISP_FAULT2__ADDRESS(idp));
}

/* ------------------- ISEN.ISP_FAULT2.ISP_ERR_RATIO_SEL ------------------- */

/**
<pre>
  ISEN.ISP_FAULT2.ISP_ERR_RATIO_SEL:

    Current sense tracking fault error ratio select.
    <start table>
    0 "4  (11.1 % Threshold)"
    1 "8  (20.0 % Threshold)"
    2 "12 (27.3 % Threshold)"
    3 "16 (33.3 % Threshold)"
    4 "24 (42.9 % Threshold)"
    5 "32 (50.0 % Threshold)"
    6 "48 (60.0 % Threshold)"
    7 "64 (66.7 % Threshold)"
    <end table>

</pre> */

#define ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Pos                 1                                                                      /*!< Right-most bit position of isp_err_ratio_sel in ISEN.ISP_FAULT2 */
#define ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Msk                 (0x00000007UL << ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Pos)              /*!< Mask for isp_err_ratio_sel in ISEN.ISP_FAULT2 */
#define ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Shift(v)            (((v) << ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Pos) & ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Msk) /*!< Shift value 'v' into isp_err_ratio_sel and mask 'v' to fit it into isp_err_ratio_sel field */

/** ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__SET() sets ISP_FAULT2.ISP_ERR_RATIO_SEL to given value.
 *
 * When writing to ISP_FAULT2.ISP_ERR_RATIO_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for ISP_FAULT2.ISP_ERR_RATIO_SEL
 */
__ISEN_INLINE void ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_ISP_FAULT2__GET(idp);
    reg = (reg & ~ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Msk);
    reg = (reg | (ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Shift((uint32_t)bf_value)));
    ISEN_ISP_FAULT2__SET(idp, reg);
}

/** ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__GET() gets ISP_FAULT2.ISP_ERR_RATIO_SEL's current value.
 *
 * When reading from ISP_FAULT2.ISP_ERR_RATIO_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_FAULT2.ISP_ERR_RATIO_SEL
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_ISP_FAULT2__GET(idp);
    reg = (reg & ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Msk);
    reg = (reg >> ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Pos);
    return (uint32_t)reg;
}

/** ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__MODIFY() modifies ISP_FAULT2.ISP_ERR_RATIO_SEL.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.ISP_FAULT2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.ISP_FAULT2
 * @param bf_value new value for ISP_FAULT2.ISP_ERR_RATIO_SEL
 * @return new value of ISEN.ISP_FAULT2
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Msk);
    reg = (reg | (ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__EXTRACT() extracts ISP_FAULT2.ISP_ERR_RATIO_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.ISP_FAULT2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.ISP_FAULT2
 * @return current value of ISP_FAULT2.ISP_ERR_RATIO_SEL
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Msk);
    reg = (reg >> ISEN_ISP_FAULT2__ISP_ERR_RATIO_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------- ISEN.ISP_FAULT2.ISP_TRACK_FAULT_EN ------------------- */

/**
<pre>
  ISEN.ISP_FAULT2.ISP_TRACK_FAULT_EN:

    Current sense tracking fault enable.  The tracking fault detects the inability of the current sense emulator to track the incoming current sense signal.  This is typically an indication of board problem (e.g., missing sense resistor, bad pin conection).
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Pos                0                                                                      /*!< Right-most bit position of isp_track_fault_en in ISEN.ISP_FAULT2 */
#define ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Msk                (0x00000001UL << ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Pos)             /*!< Mask for isp_track_fault_en in ISEN.ISP_FAULT2 */
#define ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Shift(v)           (((v) << ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Pos) & ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Msk) /*!< Shift value 'v' into isp_track_fault_en and mask 'v' to fit it into isp_track_fault_en field */

/** ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__SET() sets ISP_FAULT2.ISP_TRACK_FAULT_EN to given value.
 *
 * When writing to ISP_FAULT2.ISP_TRACK_FAULT_EN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for ISP_FAULT2.ISP_TRACK_FAULT_EN
 */
__ISEN_INLINE void ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_ISP_FAULT2__GET(idp);
    reg = (reg & ~ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Msk);
    reg = (reg | (ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Shift((uint32_t)bf_value)));
    ISEN_ISP_FAULT2__SET(idp, reg);
}

/** ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__GET() gets ISP_FAULT2.ISP_TRACK_FAULT_EN's current value.
 *
 * When reading from ISP_FAULT2.ISP_TRACK_FAULT_EN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_FAULT2.ISP_TRACK_FAULT_EN
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_ISP_FAULT2__GET(idp);
    reg = (reg & ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Msk);
    reg = (reg >> ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Pos);
    return (uint32_t)reg;
}

/** ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__MODIFY() modifies ISP_FAULT2.ISP_TRACK_FAULT_EN.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.ISP_FAULT2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.ISP_FAULT2
 * @param bf_value new value for ISP_FAULT2.ISP_TRACK_FAULT_EN
 * @return new value of ISEN.ISP_FAULT2
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Msk);
    reg = (reg | (ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__EXTRACT() extracts ISP_FAULT2.ISP_TRACK_FAULT_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.ISP_FAULT2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.ISP_FAULT2
 * @return current value of ISP_FAULT2.ISP_TRACK_FAULT_EN
 */
__ISEN_INLINE uint32_t ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Msk);
    reg = (reg >> ISEN_ISP_FAULT2__ISP_TRACK_FAULT_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          ISP_APC member of ISEN_t                          */
/* -------------------------------------------------------------------------- */

/** __ISEN_ISP_APC__ADDRESS returns the address of member ISP_APC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of ISP_APC
 */
__ISEN_INLINE uint32_t* __ISEN_ISP_APC__ADDRESS(isen_idx_t idp)
{
    return (uint32_t*)((uint32_t)__ISEN_BASE_PTR(idp) + (uint32_t)(offsetof(ISEN_t, ISP_APC)));
}

/** ISEN_ISP_APC__SET() sets ISP_APC to given value.
 *
 * When writing to ISP_APC, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for ISP_APC
 */
__ISEN_INLINE void ISEN_ISP_APC__SET(isen_idx_t idp, uint32_t value)
{
    HAL_SET32(__ISEN_ISP_APC__ADDRESS(idp), value);
}

/** ISEN_ISP_APC__GET() gets ISP_APC's current value.
 *
 * When reading from ISP_APC, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_APC
 */
__ISEN_INLINE uint32_t ISEN_ISP_APC__GET(isen_idx_t idp)
{
    return HAL_GET32(__ISEN_ISP_APC__ADDRESS(idp));
}

/* ------------------------ ISEN.ISP_APC.ISP_IOFFSET ------------------------ */

/**
<pre>
  ISEN.ISP_APC.ISP_IOFFSET:

    Phase current offset
    Computed from PMBus command as follows:
    <start table>
    "isp_offset(S5.3) = IOUT_CAL_OFFSET(S5.3)"
    <end table>
    LSB = 0.125A, Range = -16 to +15.875A

</pre> */

#define ISEN_ISP_APC__ISP_IOFFSET__Pos                          11                                                                     /*!< Right-most bit position of isp_ioffset in ISEN.ISP_APC */
#define ISEN_ISP_APC__ISP_IOFFSET__Msk                          (0x000000FFUL << ISEN_ISP_APC__ISP_IOFFSET__Pos)                       /*!< Mask for isp_ioffset in ISEN.ISP_APC */
#define ISEN_ISP_APC__ISP_IOFFSET__Shift(v)                     (((v) << ISEN_ISP_APC__ISP_IOFFSET__Pos) & ISEN_ISP_APC__ISP_IOFFSET__Msk) /*!< Shift value 'v' into isp_ioffset and mask 'v' to fit it into isp_ioffset field */

/** ISEN_ISP_APC__ISP_IOFFSET__SET() sets ISP_APC.ISP_IOFFSET to given value.
 *
 * When writing to ISP_APC.ISP_IOFFSET, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for ISP_APC.ISP_IOFFSET
 */
__ISEN_INLINE void ISEN_ISP_APC__ISP_IOFFSET__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_ISP_APC__GET(idp);
    reg = (reg & ~ISEN_ISP_APC__ISP_IOFFSET__Msk);
    reg = (reg | (ISEN_ISP_APC__ISP_IOFFSET__Shift((uint32_t)bf_value)));
    ISEN_ISP_APC__SET(idp, reg);
}

/** ISEN_ISP_APC__ISP_IOFFSET__GET() gets ISP_APC.ISP_IOFFSET's current value.
 *
 * When reading from ISP_APC.ISP_IOFFSET, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_APC.ISP_IOFFSET
 */
__ISEN_INLINE uint32_t ISEN_ISP_APC__ISP_IOFFSET__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_ISP_APC__GET(idp);
    reg = (reg & ISEN_ISP_APC__ISP_IOFFSET__Msk);
    reg = (reg >> ISEN_ISP_APC__ISP_IOFFSET__Pos);
    return (uint32_t)reg;
}

/** ISEN_ISP_APC__ISP_IOFFSET__MODIFY() modifies ISP_APC.ISP_IOFFSET.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.ISP_APC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.ISP_APC
 * @param bf_value new value for ISP_APC.ISP_IOFFSET
 * @return new value of ISEN.ISP_APC
 */
__ISEN_INLINE uint32_t ISEN_ISP_APC__ISP_IOFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_ISP_APC__ISP_IOFFSET__Msk);
    reg = (reg | (ISEN_ISP_APC__ISP_IOFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_ISP_APC__ISP_IOFFSET__EXTRACT() extracts ISP_APC.ISP_IOFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.ISP_APC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.ISP_APC
 * @return current value of ISP_APC.ISP_IOFFSET
 */
__ISEN_INLINE uint32_t ISEN_ISP_APC__ISP_IOFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_ISP_APC__ISP_IOFFSET__Msk);
    reg = (reg >> ISEN_ISP_APC__ISP_IOFFSET__Pos);
    return (uint32_t)reg;
}

/* -------------------------- ISEN.ISP_APC.ISP_APC -------------------------- */

/**
<pre>
  ISEN.ISP_APC.ISP_APC:

    Current Sense ADC Amps per Code (APC), maps the current sense ADC LSB into Amps.
    Computed from PMBus command as follows:
    <start table>
    "isp_apc(U2.9) = MFR_IOUT_APC(U2.9)"
    <end table>
    LSB = 1.9531mA, Range = 0.0 to 3.998A

</pre> */

#define ISEN_ISP_APC__ISP_APC__Pos                              0                                                                      /*!< Right-most bit position of isp_apc in ISEN.ISP_APC */
#define ISEN_ISP_APC__ISP_APC__Msk                              (0x000007FFUL << ISEN_ISP_APC__ISP_APC__Pos)                           /*!< Mask for isp_apc in ISEN.ISP_APC */
#define ISEN_ISP_APC__ISP_APC__Shift(v)                         (((v) << ISEN_ISP_APC__ISP_APC__Pos) & ISEN_ISP_APC__ISP_APC__Msk)     /*!< Shift value 'v' into isp_apc and mask 'v' to fit it into isp_apc field */

/** ISEN_ISP_APC__ISP_APC__SET() sets ISP_APC.ISP_APC to given value.
 *
 * When writing to ISP_APC.ISP_APC, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for ISP_APC.ISP_APC
 */
__ISEN_INLINE void ISEN_ISP_APC__ISP_APC__SET(isen_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = ISEN_ISP_APC__GET(idp);
    reg = (reg & ~ISEN_ISP_APC__ISP_APC__Msk);
    reg = (reg | (ISEN_ISP_APC__ISP_APC__Shift((uint32_t)bf_value)));
    ISEN_ISP_APC__SET(idp, reg);
}

/** ISEN_ISP_APC__ISP_APC__GET() gets ISP_APC.ISP_APC's current value.
 *
 * When reading from ISP_APC.ISP_APC, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of ISP_APC.ISP_APC
 */
__ISEN_INLINE uint32_t ISEN_ISP_APC__ISP_APC__GET(isen_idx_t idp)
{
    uint32_t reg = ISEN_ISP_APC__GET(idp);
    reg = (reg & ISEN_ISP_APC__ISP_APC__Msk);
    reg = (reg >> ISEN_ISP_APC__ISP_APC__Pos);
    return (uint32_t)reg;
}

/** ISEN_ISP_APC__ISP_APC__MODIFY() modifies ISP_APC.ISP_APC.
 *
 * This is recommended to use when setting more than one bitfield of ISEN.ISP_APC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ISEN.ISP_APC
 * @param bf_value new value for ISP_APC.ISP_APC
 * @return new value of ISEN.ISP_APC
 */
__ISEN_INLINE uint32_t ISEN_ISP_APC__ISP_APC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ISEN_ISP_APC__ISP_APC__Msk);
    reg = (reg | (ISEN_ISP_APC__ISP_APC__Shift((uint32_t)bf_value)));
    return reg;
}

/** ISEN_ISP_APC__ISP_APC__EXTRACT() extracts ISP_APC.ISP_APC.
 *
 * This is recommended to use when extracting more than one bitfield from ISEN.ISP_APC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ISEN.ISP_APC
 * @return current value of ISP_APC.ISP_APC
 */
__ISEN_INLINE uint32_t ISEN_ISP_APC__ISP_APC__EXTRACT(uint32_t reg)
{
    reg = (reg & ISEN_ISP_APC__ISP_APC__Msk);
    reg = (reg >> ISEN_ISP_APC__ISP_APC__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group isen block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_ISEN_H_ */
