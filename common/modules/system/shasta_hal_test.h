/**
 * @file     shasta_hal_test.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_TEST_H_
#define _SHASTA_HAL_TEST_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup test
 * @{
 */

#if defined ( __CC_ARM )
#define __TEST_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __TEST_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __TEST_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __TEST_INLINE  static inline
#endif

/** register file of the test block.
 */
typedef struct _TEST_s
{
    volatile        uint32_t        MP_FORCE                    ; /*!< (@0x00000000) ATE Test Control to force all input capable buffers to be enabled. Note: Places corresponding output buffer in HiZ. */
    volatile        uint32_t        MP_TMUX                     ; /*!< (@0x00000004) Not used */
    volatile        uint32_t        TEST_CFG1                   ; /*!< (@0x00000008) Bypass all internal low pass filters (e.g., telemetry) when high. */
    volatile        uint32_t        SM_TEST                     ; /*!< (@0x0000000C) Test state control <start table> 0 "Normal operation" 1 "Test mode" <end table> */
    volatile        uint32_t        TEST_TBUS                   ; /*!< (@0x00000010) Digital test bus (TBUS) status register.  This register contains the output of final tbus mux which is also the input to the Voltage DAC (VDAC). */
    volatile        uint32_t        TMUX_ANA                    ; /*!< (@0x00000014) Analog test mux block select.  This register selects which functional block is selected for the analog test mux output. <start table_with_header> [5:0] "Blo...(more) */
    volatile        uint32_t        TBUS                        ; /*!< (@0x00000018) Digital test bus (TBUS) input select.  This register selects the TBUS mux input within the block selected by tbus_blk_sel. */
    volatile        uint32_t        TMUX                        ; /*!< (@0x0000001C) Digital test mux A (TMUXA) input select.  This register selects the TMUXA input within the block selected by tmuxa_blk_sel. */
    volatile        uint32_t        TEST_REF_DIG                ; /*!< (@0x00000020) Voltage DAC (VDAC, a.k.a. MDAC) test mode forced input value. */
    volatile        uint32_t        TEST_TSADC0                 ; /*!< (@0x00000024) TS ADC BIST expected offset value. */
    volatile        uint32_t        TEST_TSADC1                 ; /*!< (@0x00000028) TS ADC DNL BIST number of samples averaged <start table_with_header> [2:0] "# samples" "[2:0]" "# samples" 0 "128" "4" "2048" 1 "256" "5" "4096" 2 "512" "6"...(more) */
    volatile        uint32_t        TEST_TSADC2                 ; /*!< (@0x0000002C) TS ADC input short control for DNL and offset BIST. <start table> 0 "TS ADC input unshorted" 1 "TS ADC input shorted internally" <end table> */
    volatile        uint32_t        TEST_TSIDAC                 ; /*!< (@0x00000030) TS Current DAC BIST enable <start table> 0 "disabled" 1 "enabled" <end table> */
    volatile        uint32_t        TEST_IS0                    ; /*!< (@0x00000034) IS ADC Offset BIST expected value. */
    volatile        uint32_t        TEST_IS1                    ; /*!< (@0x00000038) IS ADC Gain BIST number of samples averaged <start table_with_header> [2:0] "# samples" "[2:0]" "# samples" 0 "128" "4" "2048" 1 "256" "5" "4096" 2 "512" "6...(more) */
    volatile        uint32_t        TEST_IS2                    ; /*!< (@0x0000003C) IS ADC Comparator BIST comparator select. <start table_with_header> [2:0] Comparator 0 "Comp[0] (+4.5 code offset)" 1 "Comp[1] (+2.5 code offset)" 2 "Comp[2...(more) */
    volatile        uint32_t        TEST_IS3                    ; /*!< (@0x00000040) Engineering evaluation control bits for IS block characterization. */
    volatile        uint32_t        TEST_VS0                    ; /*!< (@0x00000044) VS ADC Offset BIST expected value. */
    volatile        uint32_t        TEST_VS1                    ; /*!< (@0x00000048) VS ADC Gain BIST expected value. */
    volatile        uint32_t        TEST_RAMP_GEN               ; /*!< (@0x0000004C) BIST DAC ramp minimum count. */
    volatile        uint32_t        TEST_RAMP_DLY               ; /*!< (@0x00000050) IS, VS, TS BIST start-of measurement delay time */
    volatile        uint32_t        TEST_LO_CLK1                ; /*!< (@0x00000054) LO Clock BIST trim code error limit. */
    volatile        uint32_t        TEST_LO_CLK2                ; /*!< (@0x00000058) LO Clock BIST (200MHz mode) trim error measurement enable.  When enabled, the BIST will measure the LO Clock trim error. <start table> 0 "disabled" 1 "enabl...(more) */
    volatile        uint32_t        TEST_CONFIG                 ; /*!< (@0x0000005C) DNL BIST status select.  Selects reported value for DNL BIST on VS, IS and TS. <start table> 0 "Max DNL" 1 "Min DNL" 2 "(DNLmax - DNLmin) / 2" 3 "Last repor...(more) */
    volatile        uint32_t        TSEN_XV                     ; /*!< (@0x00000060) X-Valent Config (XADDR) test mode control <start table> 0 "Test mode disabled" 1 "Test mode enabled" <end table> */
    volatile        uint32_t        TEST_GATE                   ; /*!< (@0x00000064) When high, overrides (disables) the XADDR1 test gate input latch. */
} TEST_t;


#define TEST_BASE (0x70005800u)                                                          /*!< test base address */

/** __TEST_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__TEST_INLINE uint32_t* __TEST_BASE_PTR(void)
{
    return (uint32_t*)(TEST_BASE);
}


/* -------------------------------------------------------------------------- */
/*                         MP_FORCE member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_MP_FORCE__ADDRESS returns the address of member MP_FORCE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MP_FORCE
 */
__TEST_INLINE uint32_t* __TEST_MP_FORCE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, MP_FORCE)));
}

/** TEST_MP_FORCE__SET() sets MP_FORCE to given value.
 *
 * When writing to MP_FORCE, this is mandatory to use.
 *
 * @param value new value for MP_FORCE
 */
__TEST_INLINE void TEST_MP_FORCE__SET(uint32_t value)
{
    HAL_SET32(__TEST_MP_FORCE__ADDRESS(), value);
}

/** TEST_MP_FORCE__GET() gets MP_FORCE's current value.
 *
 * When reading from MP_FORCE, this is mandatory to use.
 *
 * @return current value of MP_FORCE
 */
__TEST_INLINE uint32_t TEST_MP_FORCE__GET(void)
{
    return HAL_GET32(__TEST_MP_FORCE__ADDRESS());
}

/* ----------------------- TEST.MP_FORCE.FORCE_ALL_LO ----------------------- */

/**
<pre>
  TEST.MP_FORCE.FORCE_ALL_LO:

    ATE Test Control to force all output capable buffers to output a logic zero. Note: Ouput buffers placed in HiZ if both force_all_hi and force_all_lo are asserted.

</pre> */

#define TEST_MP_FORCE__FORCE_ALL_LO__Pos                        2                                                                      /*!< Right-most bit position of force_all_lo in TEST.MP_FORCE */
#define TEST_MP_FORCE__FORCE_ALL_LO__Msk                        (0x00000001UL << TEST_MP_FORCE__FORCE_ALL_LO__Pos)                     /*!< Mask for force_all_lo in TEST.MP_FORCE */
#define TEST_MP_FORCE__FORCE_ALL_LO__Shift(v)                   (((v) << TEST_MP_FORCE__FORCE_ALL_LO__Pos) & TEST_MP_FORCE__FORCE_ALL_LO__Msk) /*!< Shift value 'v' into force_all_lo and mask 'v' to fit it into force_all_lo field */

/** TEST_MP_FORCE__FORCE_ALL_LO__SET() sets MP_FORCE.FORCE_ALL_LO to given value.
 *
 * When writing to MP_FORCE.FORCE_ALL_LO, this is recommended to use.
 *
 * @param bf_value new value for MP_FORCE.FORCE_ALL_LO
 */
__TEST_INLINE void TEST_MP_FORCE__FORCE_ALL_LO__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_MP_FORCE__GET();
    reg = (reg & ~TEST_MP_FORCE__FORCE_ALL_LO__Msk);
    reg = (reg | (TEST_MP_FORCE__FORCE_ALL_LO__Shift((uint32_t)bf_value)));
    TEST_MP_FORCE__SET(reg);
}

/** TEST_MP_FORCE__FORCE_ALL_LO__GET() gets MP_FORCE.FORCE_ALL_LO's current value.
 *
 * When reading from MP_FORCE.FORCE_ALL_LO, this is recommended to use.
 *
 * @return current value of MP_FORCE.FORCE_ALL_LO
 */
__TEST_INLINE uint32_t TEST_MP_FORCE__FORCE_ALL_LO__GET(void)
{
    uint32_t reg = TEST_MP_FORCE__GET();
    reg = (reg & TEST_MP_FORCE__FORCE_ALL_LO__Msk);
    reg = (reg >> TEST_MP_FORCE__FORCE_ALL_LO__Pos);
    return (uint32_t)reg;
}

/** TEST_MP_FORCE__FORCE_ALL_LO__MODIFY() modifies MP_FORCE.FORCE_ALL_LO.
 *
 * This is recommended to use when setting more than one bitfield of TEST.MP_FORCE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.MP_FORCE
 * @param bf_value new value for MP_FORCE.FORCE_ALL_LO
 * @return new value of TEST.MP_FORCE
 */
__TEST_INLINE uint32_t TEST_MP_FORCE__FORCE_ALL_LO__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_MP_FORCE__FORCE_ALL_LO__Msk);
    reg = (reg | (TEST_MP_FORCE__FORCE_ALL_LO__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_MP_FORCE__FORCE_ALL_LO__EXTRACT() extracts MP_FORCE.FORCE_ALL_LO.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.MP_FORCE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.MP_FORCE
 * @return current value of MP_FORCE.FORCE_ALL_LO
 */
__TEST_INLINE uint32_t TEST_MP_FORCE__FORCE_ALL_LO__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_MP_FORCE__FORCE_ALL_LO__Msk);
    reg = (reg >> TEST_MP_FORCE__FORCE_ALL_LO__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TEST.MP_FORCE.FORCE_ALL_HI ----------------------- */

/**
<pre>
  TEST.MP_FORCE.FORCE_ALL_HI:

    ATE Test Control to force all output capable buffers to output a logic one. Note: Ouput buffers placed in HiZ if both force_all_hi and force_all_lo are asserted.

</pre> */

#define TEST_MP_FORCE__FORCE_ALL_HI__Pos                        1                                                                      /*!< Right-most bit position of force_all_hi in TEST.MP_FORCE */
#define TEST_MP_FORCE__FORCE_ALL_HI__Msk                        (0x00000001UL << TEST_MP_FORCE__FORCE_ALL_HI__Pos)                     /*!< Mask for force_all_hi in TEST.MP_FORCE */
#define TEST_MP_FORCE__FORCE_ALL_HI__Shift(v)                   (((v) << TEST_MP_FORCE__FORCE_ALL_HI__Pos) & TEST_MP_FORCE__FORCE_ALL_HI__Msk) /*!< Shift value 'v' into force_all_hi and mask 'v' to fit it into force_all_hi field */

/** TEST_MP_FORCE__FORCE_ALL_HI__SET() sets MP_FORCE.FORCE_ALL_HI to given value.
 *
 * When writing to MP_FORCE.FORCE_ALL_HI, this is recommended to use.
 *
 * @param bf_value new value for MP_FORCE.FORCE_ALL_HI
 */
__TEST_INLINE void TEST_MP_FORCE__FORCE_ALL_HI__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_MP_FORCE__GET();
    reg = (reg & ~TEST_MP_FORCE__FORCE_ALL_HI__Msk);
    reg = (reg | (TEST_MP_FORCE__FORCE_ALL_HI__Shift((uint32_t)bf_value)));
    TEST_MP_FORCE__SET(reg);
}

/** TEST_MP_FORCE__FORCE_ALL_HI__GET() gets MP_FORCE.FORCE_ALL_HI's current value.
 *
 * When reading from MP_FORCE.FORCE_ALL_HI, this is recommended to use.
 *
 * @return current value of MP_FORCE.FORCE_ALL_HI
 */
__TEST_INLINE uint32_t TEST_MP_FORCE__FORCE_ALL_HI__GET(void)
{
    uint32_t reg = TEST_MP_FORCE__GET();
    reg = (reg & TEST_MP_FORCE__FORCE_ALL_HI__Msk);
    reg = (reg >> TEST_MP_FORCE__FORCE_ALL_HI__Pos);
    return (uint32_t)reg;
}

/** TEST_MP_FORCE__FORCE_ALL_HI__MODIFY() modifies MP_FORCE.FORCE_ALL_HI.
 *
 * This is recommended to use when setting more than one bitfield of TEST.MP_FORCE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.MP_FORCE
 * @param bf_value new value for MP_FORCE.FORCE_ALL_HI
 * @return new value of TEST.MP_FORCE
 */
__TEST_INLINE uint32_t TEST_MP_FORCE__FORCE_ALL_HI__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_MP_FORCE__FORCE_ALL_HI__Msk);
    reg = (reg | (TEST_MP_FORCE__FORCE_ALL_HI__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_MP_FORCE__FORCE_ALL_HI__EXTRACT() extracts MP_FORCE.FORCE_ALL_HI.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.MP_FORCE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.MP_FORCE
 * @return current value of MP_FORCE.FORCE_ALL_HI
 */
__TEST_INLINE uint32_t TEST_MP_FORCE__FORCE_ALL_HI__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_MP_FORCE__FORCE_ALL_HI__Msk);
    reg = (reg >> TEST_MP_FORCE__FORCE_ALL_HI__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TEST.MP_FORCE.FORCE_ALL_IN ----------------------- */

/**
<pre>
  TEST.MP_FORCE.FORCE_ALL_IN:

    ATE Test Control to force all input capable buffers to be enabled. Note: Places corresponding output buffer in HiZ.

</pre> */

#define TEST_MP_FORCE__FORCE_ALL_IN__Pos                        0                                                                      /*!< Right-most bit position of force_all_in in TEST.MP_FORCE */
#define TEST_MP_FORCE__FORCE_ALL_IN__Msk                        (0x00000001UL << TEST_MP_FORCE__FORCE_ALL_IN__Pos)                     /*!< Mask for force_all_in in TEST.MP_FORCE */
#define TEST_MP_FORCE__FORCE_ALL_IN__Shift(v)                   (((v) << TEST_MP_FORCE__FORCE_ALL_IN__Pos) & TEST_MP_FORCE__FORCE_ALL_IN__Msk) /*!< Shift value 'v' into force_all_in and mask 'v' to fit it into force_all_in field */

/** TEST_MP_FORCE__FORCE_ALL_IN__SET() sets MP_FORCE.FORCE_ALL_IN to given value.
 *
 * When writing to MP_FORCE.FORCE_ALL_IN, this is recommended to use.
 *
 * @param bf_value new value for MP_FORCE.FORCE_ALL_IN
 */
__TEST_INLINE void TEST_MP_FORCE__FORCE_ALL_IN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_MP_FORCE__GET();
    reg = (reg & ~TEST_MP_FORCE__FORCE_ALL_IN__Msk);
    reg = (reg | (TEST_MP_FORCE__FORCE_ALL_IN__Shift((uint32_t)bf_value)));
    TEST_MP_FORCE__SET(reg);
}

/** TEST_MP_FORCE__FORCE_ALL_IN__GET() gets MP_FORCE.FORCE_ALL_IN's current value.
 *
 * When reading from MP_FORCE.FORCE_ALL_IN, this is recommended to use.
 *
 * @return current value of MP_FORCE.FORCE_ALL_IN
 */
__TEST_INLINE uint32_t TEST_MP_FORCE__FORCE_ALL_IN__GET(void)
{
    uint32_t reg = TEST_MP_FORCE__GET();
    reg = (reg & TEST_MP_FORCE__FORCE_ALL_IN__Msk);
    reg = (reg >> TEST_MP_FORCE__FORCE_ALL_IN__Pos);
    return (uint32_t)reg;
}

/** TEST_MP_FORCE__FORCE_ALL_IN__MODIFY() modifies MP_FORCE.FORCE_ALL_IN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.MP_FORCE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.MP_FORCE
 * @param bf_value new value for MP_FORCE.FORCE_ALL_IN
 * @return new value of TEST.MP_FORCE
 */
__TEST_INLINE uint32_t TEST_MP_FORCE__FORCE_ALL_IN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_MP_FORCE__FORCE_ALL_IN__Msk);
    reg = (reg | (TEST_MP_FORCE__FORCE_ALL_IN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_MP_FORCE__FORCE_ALL_IN__EXTRACT() extracts MP_FORCE.FORCE_ALL_IN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.MP_FORCE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.MP_FORCE
 * @return current value of MP_FORCE.FORCE_ALL_IN
 */
__TEST_INLINE uint32_t TEST_MP_FORCE__FORCE_ALL_IN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_MP_FORCE__FORCE_ALL_IN__Msk);
    reg = (reg >> TEST_MP_FORCE__FORCE_ALL_IN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          MP_TMUX member of TEST_t                          */
/* -------------------------------------------------------------------------- */

/** __TEST_MP_TMUX__ADDRESS returns the address of member MP_TMUX.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MP_TMUX
 */
__TEST_INLINE uint32_t* __TEST_MP_TMUX__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, MP_TMUX)));
}

/** TEST_MP_TMUX__SET() sets MP_TMUX to given value.
 *
 * When writing to MP_TMUX, this is mandatory to use.
 *
 * @param value new value for MP_TMUX
 */
__TEST_INLINE void TEST_MP_TMUX__SET(uint32_t value)
{
    HAL_SET32(__TEST_MP_TMUX__ADDRESS(), value);
}

/** TEST_MP_TMUX__GET() gets MP_TMUX's current value.
 *
 * When reading from MP_TMUX, this is mandatory to use.
 *
 * @return current value of MP_TMUX
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__GET(void)
{
    return HAL_GET32(__TEST_MP_TMUX__ADDRESS());
}

/* ----------------------- TEST.MP_TMUX.DTMUX_AB_SEL ----------------------- */

/**
<pre>
  TEST.MP_TMUX.DTMUX_AB_SEL:

    Select TMUXB for output on selected pin when corresponding bit is high, otherwise selct TMUXA.
    <start table>
    [0] "FAULT1"
    [1] "FAULT2"
    [2] "IMON"
    [3] "PWM4"
    [4] "SYNC"
    <end table>

</pre> */

#define TEST_MP_TMUX__DTMUX_AB_SEL__Pos                         7                                                                      /*!< Right-most bit position of dtmux_ab_sel in TEST.MP_TMUX */
#define TEST_MP_TMUX__DTMUX_AB_SEL__Msk                         (0x0000001FUL << TEST_MP_TMUX__DTMUX_AB_SEL__Pos)                      /*!< Mask for dtmux_ab_sel in TEST.MP_TMUX */
#define TEST_MP_TMUX__DTMUX_AB_SEL__Shift(v)                    (((v) << TEST_MP_TMUX__DTMUX_AB_SEL__Pos) & TEST_MP_TMUX__DTMUX_AB_SEL__Msk) /*!< Shift value 'v' into dtmux_ab_sel and mask 'v' to fit it into dtmux_ab_sel field */

/** TEST_MP_TMUX__DTMUX_AB_SEL__SET() sets MP_TMUX.DTMUX_AB_SEL to given value.
 *
 * When writing to MP_TMUX.DTMUX_AB_SEL, this is recommended to use.
 *
 * @param bf_value new value for MP_TMUX.DTMUX_AB_SEL
 */
__TEST_INLINE void TEST_MP_TMUX__DTMUX_AB_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_MP_TMUX__GET();
    reg = (reg & ~TEST_MP_TMUX__DTMUX_AB_SEL__Msk);
    reg = (reg | (TEST_MP_TMUX__DTMUX_AB_SEL__Shift((uint32_t)bf_value)));
    TEST_MP_TMUX__SET(reg);
}

/** TEST_MP_TMUX__DTMUX_AB_SEL__GET() gets MP_TMUX.DTMUX_AB_SEL's current value.
 *
 * When reading from MP_TMUX.DTMUX_AB_SEL, this is recommended to use.
 *
 * @return current value of MP_TMUX.DTMUX_AB_SEL
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__DTMUX_AB_SEL__GET(void)
{
    uint32_t reg = TEST_MP_TMUX__GET();
    reg = (reg & TEST_MP_TMUX__DTMUX_AB_SEL__Msk);
    reg = (reg >> TEST_MP_TMUX__DTMUX_AB_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_MP_TMUX__DTMUX_AB_SEL__MODIFY() modifies MP_TMUX.DTMUX_AB_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.MP_TMUX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.MP_TMUX
 * @param bf_value new value for MP_TMUX.DTMUX_AB_SEL
 * @return new value of TEST.MP_TMUX
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__DTMUX_AB_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_MP_TMUX__DTMUX_AB_SEL__Msk);
    reg = (reg | (TEST_MP_TMUX__DTMUX_AB_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_MP_TMUX__DTMUX_AB_SEL__EXTRACT() extracts MP_TMUX.DTMUX_AB_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.MP_TMUX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.MP_TMUX
 * @return current value of MP_TMUX.DTMUX_AB_SEL
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__DTMUX_AB_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_MP_TMUX__DTMUX_AB_SEL__Msk);
    reg = (reg >> TEST_MP_TMUX__DTMUX_AB_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------------- TEST.MP_TMUX.DTMUX_SEL ------------------------- */

/**
<pre>
  TEST.MP_TMUX.DTMUX_SEL:

    Enable digital test mux output on selected pin when corresponding bit is high.
    <start table>
    [0] "FAULT1"
    [1] "FAULT2"
    [2] "IMON"
    [3] "PWM4"
    [4] "SYNC"
    <end table>

</pre> */

#define TEST_MP_TMUX__DTMUX_SEL__Pos                            2                                                                      /*!< Right-most bit position of dtmux_sel in TEST.MP_TMUX */
#define TEST_MP_TMUX__DTMUX_SEL__Msk                            (0x0000001FUL << TEST_MP_TMUX__DTMUX_SEL__Pos)                         /*!< Mask for dtmux_sel in TEST.MP_TMUX */
#define TEST_MP_TMUX__DTMUX_SEL__Shift(v)                       (((v) << TEST_MP_TMUX__DTMUX_SEL__Pos) & TEST_MP_TMUX__DTMUX_SEL__Msk) /*!< Shift value 'v' into dtmux_sel and mask 'v' to fit it into dtmux_sel field */

/** TEST_MP_TMUX__DTMUX_SEL__SET() sets MP_TMUX.DTMUX_SEL to given value.
 *
 * When writing to MP_TMUX.DTMUX_SEL, this is recommended to use.
 *
 * @param bf_value new value for MP_TMUX.DTMUX_SEL
 */
__TEST_INLINE void TEST_MP_TMUX__DTMUX_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_MP_TMUX__GET();
    reg = (reg & ~TEST_MP_TMUX__DTMUX_SEL__Msk);
    reg = (reg | (TEST_MP_TMUX__DTMUX_SEL__Shift((uint32_t)bf_value)));
    TEST_MP_TMUX__SET(reg);
}

/** TEST_MP_TMUX__DTMUX_SEL__GET() gets MP_TMUX.DTMUX_SEL's current value.
 *
 * When reading from MP_TMUX.DTMUX_SEL, this is recommended to use.
 *
 * @return current value of MP_TMUX.DTMUX_SEL
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__DTMUX_SEL__GET(void)
{
    uint32_t reg = TEST_MP_TMUX__GET();
    reg = (reg & TEST_MP_TMUX__DTMUX_SEL__Msk);
    reg = (reg >> TEST_MP_TMUX__DTMUX_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_MP_TMUX__DTMUX_SEL__MODIFY() modifies MP_TMUX.DTMUX_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.MP_TMUX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.MP_TMUX
 * @param bf_value new value for MP_TMUX.DTMUX_SEL
 * @return new value of TEST.MP_TMUX
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__DTMUX_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_MP_TMUX__DTMUX_SEL__Msk);
    reg = (reg | (TEST_MP_TMUX__DTMUX_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_MP_TMUX__DTMUX_SEL__EXTRACT() extracts MP_TMUX.DTMUX_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.MP_TMUX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.MP_TMUX
 * @return current value of MP_TMUX.DTMUX_SEL
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__DTMUX_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_MP_TMUX__DTMUX_SEL__Msk);
    reg = (reg >> TEST_MP_TMUX__DTMUX_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------------- TEST.MP_TMUX.ATMUX_SEL ------------------------- */

/**
<pre>
  TEST.MP_TMUX.ATMUX_SEL:

    Enables Analog Test Mux on SMBALERT# and EN pins when high.

</pre> */

#define TEST_MP_TMUX__ATMUX_SEL__Pos                            1                                                                      /*!< Right-most bit position of atmux_sel in TEST.MP_TMUX */
#define TEST_MP_TMUX__ATMUX_SEL__Msk                            (0x00000001UL << TEST_MP_TMUX__ATMUX_SEL__Pos)                         /*!< Mask for atmux_sel in TEST.MP_TMUX */
#define TEST_MP_TMUX__ATMUX_SEL__Shift(v)                       (((v) << TEST_MP_TMUX__ATMUX_SEL__Pos) & TEST_MP_TMUX__ATMUX_SEL__Msk) /*!< Shift value 'v' into atmux_sel and mask 'v' to fit it into atmux_sel field */

/** TEST_MP_TMUX__ATMUX_SEL__SET() sets MP_TMUX.ATMUX_SEL to given value.
 *
 * When writing to MP_TMUX.ATMUX_SEL, this is recommended to use.
 *
 * @param bf_value new value for MP_TMUX.ATMUX_SEL
 */
__TEST_INLINE void TEST_MP_TMUX__ATMUX_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_MP_TMUX__GET();
    reg = (reg & ~TEST_MP_TMUX__ATMUX_SEL__Msk);
    reg = (reg | (TEST_MP_TMUX__ATMUX_SEL__Shift((uint32_t)bf_value)));
    TEST_MP_TMUX__SET(reg);
}

/** TEST_MP_TMUX__ATMUX_SEL__GET() gets MP_TMUX.ATMUX_SEL's current value.
 *
 * When reading from MP_TMUX.ATMUX_SEL, this is recommended to use.
 *
 * @return current value of MP_TMUX.ATMUX_SEL
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__ATMUX_SEL__GET(void)
{
    uint32_t reg = TEST_MP_TMUX__GET();
    reg = (reg & TEST_MP_TMUX__ATMUX_SEL__Msk);
    reg = (reg >> TEST_MP_TMUX__ATMUX_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_MP_TMUX__ATMUX_SEL__MODIFY() modifies MP_TMUX.ATMUX_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.MP_TMUX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.MP_TMUX
 * @param bf_value new value for MP_TMUX.ATMUX_SEL
 * @return new value of TEST.MP_TMUX
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__ATMUX_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_MP_TMUX__ATMUX_SEL__Msk);
    reg = (reg | (TEST_MP_TMUX__ATMUX_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_MP_TMUX__ATMUX_SEL__EXTRACT() extracts MP_TMUX.ATMUX_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.MP_TMUX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.MP_TMUX
 * @return current value of MP_TMUX.ATMUX_SEL
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__ATMUX_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_MP_TMUX__ATMUX_SEL__Msk);
    reg = (reg >> TEST_MP_TMUX__ATMUX_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------------- TEST.MP_TMUX.DEBUG_SEL ------------------------- */

/**
<pre>
  TEST.MP_TMUX.DEBUG_SEL:

    Not used

</pre> */

#define TEST_MP_TMUX__DEBUG_SEL__Pos                            0                                                                      /*!< Right-most bit position of debug_sel in TEST.MP_TMUX */
#define TEST_MP_TMUX__DEBUG_SEL__Msk                            (0x00000001UL << TEST_MP_TMUX__DEBUG_SEL__Pos)                         /*!< Mask for debug_sel in TEST.MP_TMUX */
#define TEST_MP_TMUX__DEBUG_SEL__Shift(v)                       (((v) << TEST_MP_TMUX__DEBUG_SEL__Pos) & TEST_MP_TMUX__DEBUG_SEL__Msk) /*!< Shift value 'v' into debug_sel and mask 'v' to fit it into debug_sel field */

/** TEST_MP_TMUX__DEBUG_SEL__SET() sets MP_TMUX.DEBUG_SEL to given value.
 *
 * When writing to MP_TMUX.DEBUG_SEL, this is recommended to use.
 *
 * @param bf_value new value for MP_TMUX.DEBUG_SEL
 */
__TEST_INLINE void TEST_MP_TMUX__DEBUG_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_MP_TMUX__GET();
    reg = (reg & ~TEST_MP_TMUX__DEBUG_SEL__Msk);
    reg = (reg | (TEST_MP_TMUX__DEBUG_SEL__Shift((uint32_t)bf_value)));
    TEST_MP_TMUX__SET(reg);
}

/** TEST_MP_TMUX__DEBUG_SEL__GET() gets MP_TMUX.DEBUG_SEL's current value.
 *
 * When reading from MP_TMUX.DEBUG_SEL, this is recommended to use.
 *
 * @return current value of MP_TMUX.DEBUG_SEL
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__DEBUG_SEL__GET(void)
{
    uint32_t reg = TEST_MP_TMUX__GET();
    reg = (reg & TEST_MP_TMUX__DEBUG_SEL__Msk);
    reg = (reg >> TEST_MP_TMUX__DEBUG_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_MP_TMUX__DEBUG_SEL__MODIFY() modifies MP_TMUX.DEBUG_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.MP_TMUX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.MP_TMUX
 * @param bf_value new value for MP_TMUX.DEBUG_SEL
 * @return new value of TEST.MP_TMUX
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__DEBUG_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_MP_TMUX__DEBUG_SEL__Msk);
    reg = (reg | (TEST_MP_TMUX__DEBUG_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_MP_TMUX__DEBUG_SEL__EXTRACT() extracts MP_TMUX.DEBUG_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.MP_TMUX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.MP_TMUX
 * @return current value of MP_TMUX.DEBUG_SEL
 */
__TEST_INLINE uint32_t TEST_MP_TMUX__DEBUG_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_MP_TMUX__DEBUG_SEL__Msk);
    reg = (reg >> TEST_MP_TMUX__DEBUG_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TEST_CFG1 member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_CFG1__ADDRESS returns the address of member TEST_CFG1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_CFG1
 */
__TEST_INLINE uint32_t* __TEST_TEST_CFG1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_CFG1)));
}

/** TEST_TEST_CFG1__SET() sets TEST_CFG1 to given value.
 *
 * When writing to TEST_CFG1, this is mandatory to use.
 *
 * @param value new value for TEST_CFG1
 */
__TEST_INLINE void TEST_TEST_CFG1__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_CFG1__ADDRESS(), value);
}

/** TEST_TEST_CFG1__GET() gets TEST_CFG1's current value.
 *
 * When reading from TEST_CFG1, this is mandatory to use.
 *
 * @return current value of TEST_CFG1
 */
__TEST_INLINE uint32_t TEST_TEST_CFG1__GET(void)
{
    return HAL_GET32(__TEST_TEST_CFG1__ADDRESS());
}

/* ----------------------- TEST.TEST_CFG1.TEST_IRQ_EN ----------------------- */

/**
<pre>
  TEST.TEST_CFG1.TEST_IRQ_EN:

    Test block interrupts (IRQ) enabled when high.

</pre> */

#define TEST_TEST_CFG1__TEST_IRQ_EN__Pos                        1                                                                      /*!< Right-most bit position of test_irq_en in TEST.TEST_CFG1 */
#define TEST_TEST_CFG1__TEST_IRQ_EN__Msk                        (0x00000001UL << TEST_TEST_CFG1__TEST_IRQ_EN__Pos)                     /*!< Mask for test_irq_en in TEST.TEST_CFG1 */
#define TEST_TEST_CFG1__TEST_IRQ_EN__Shift(v)                   (((v) << TEST_TEST_CFG1__TEST_IRQ_EN__Pos) & TEST_TEST_CFG1__TEST_IRQ_EN__Msk) /*!< Shift value 'v' into test_irq_en and mask 'v' to fit it into test_irq_en field */

/** TEST_TEST_CFG1__TEST_IRQ_EN__SET() sets TEST_CFG1.TEST_IRQ_EN to given value.
 *
 * When writing to TEST_CFG1.TEST_IRQ_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_CFG1.TEST_IRQ_EN
 */
__TEST_INLINE void TEST_TEST_CFG1__TEST_IRQ_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_CFG1__GET();
    reg = (reg & ~TEST_TEST_CFG1__TEST_IRQ_EN__Msk);
    reg = (reg | (TEST_TEST_CFG1__TEST_IRQ_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_CFG1__SET(reg);
}

/** TEST_TEST_CFG1__TEST_IRQ_EN__GET() gets TEST_CFG1.TEST_IRQ_EN's current value.
 *
 * When reading from TEST_CFG1.TEST_IRQ_EN, this is recommended to use.
 *
 * @return current value of TEST_CFG1.TEST_IRQ_EN
 */
__TEST_INLINE uint32_t TEST_TEST_CFG1__TEST_IRQ_EN__GET(void)
{
    uint32_t reg = TEST_TEST_CFG1__GET();
    reg = (reg & TEST_TEST_CFG1__TEST_IRQ_EN__Msk);
    reg = (reg >> TEST_TEST_CFG1__TEST_IRQ_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_CFG1__TEST_IRQ_EN__MODIFY() modifies TEST_CFG1.TEST_IRQ_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_CFG1
 * @param bf_value new value for TEST_CFG1.TEST_IRQ_EN
 * @return new value of TEST.TEST_CFG1
 */
__TEST_INLINE uint32_t TEST_TEST_CFG1__TEST_IRQ_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_CFG1__TEST_IRQ_EN__Msk);
    reg = (reg | (TEST_TEST_CFG1__TEST_IRQ_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_CFG1__TEST_IRQ_EN__EXTRACT() extracts TEST_CFG1.TEST_IRQ_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_CFG1
 * @return current value of TEST_CFG1.TEST_IRQ_EN
 */
__TEST_INLINE uint32_t TEST_TEST_CFG1__TEST_IRQ_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_CFG1__TEST_IRQ_EN__Msk);
    reg = (reg >> TEST_TEST_CFG1__TEST_IRQ_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_CFG1.BYPASS_ALL_FILTERS ------------------- */

/**
<pre>
  TEST.TEST_CFG1.BYPASS_ALL_FILTERS:

    Bypass all internal low pass filters (e.g., telemetry) when high.

</pre> */

#define TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Pos                 0                                                                      /*!< Right-most bit position of bypass_all_filters in TEST.TEST_CFG1 */
#define TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Msk                 (0x00000001UL << TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Pos)              /*!< Mask for bypass_all_filters in TEST.TEST_CFG1 */
#define TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Shift(v)            (((v) << TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Pos) & TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Msk) /*!< Shift value 'v' into bypass_all_filters and mask 'v' to fit it into bypass_all_filters field */

/** TEST_TEST_CFG1__BYPASS_ALL_FILTERS__SET() sets TEST_CFG1.BYPASS_ALL_FILTERS to given value.
 *
 * When writing to TEST_CFG1.BYPASS_ALL_FILTERS, this is recommended to use.
 *
 * @param bf_value new value for TEST_CFG1.BYPASS_ALL_FILTERS
 */
__TEST_INLINE void TEST_TEST_CFG1__BYPASS_ALL_FILTERS__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_CFG1__GET();
    reg = (reg & ~TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Msk);
    reg = (reg | (TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Shift((uint32_t)bf_value)));
    TEST_TEST_CFG1__SET(reg);
}

/** TEST_TEST_CFG1__BYPASS_ALL_FILTERS__GET() gets TEST_CFG1.BYPASS_ALL_FILTERS's current value.
 *
 * When reading from TEST_CFG1.BYPASS_ALL_FILTERS, this is recommended to use.
 *
 * @return current value of TEST_CFG1.BYPASS_ALL_FILTERS
 */
__TEST_INLINE uint32_t TEST_TEST_CFG1__BYPASS_ALL_FILTERS__GET(void)
{
    uint32_t reg = TEST_TEST_CFG1__GET();
    reg = (reg & TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Msk);
    reg = (reg >> TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_CFG1__BYPASS_ALL_FILTERS__MODIFY() modifies TEST_CFG1.BYPASS_ALL_FILTERS.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_CFG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_CFG1
 * @param bf_value new value for TEST_CFG1.BYPASS_ALL_FILTERS
 * @return new value of TEST.TEST_CFG1
 */
__TEST_INLINE uint32_t TEST_TEST_CFG1__BYPASS_ALL_FILTERS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Msk);
    reg = (reg | (TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_CFG1__BYPASS_ALL_FILTERS__EXTRACT() extracts TEST_CFG1.BYPASS_ALL_FILTERS.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_CFG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_CFG1
 * @return current value of TEST_CFG1.BYPASS_ALL_FILTERS
 */
__TEST_INLINE uint32_t TEST_TEST_CFG1__BYPASS_ALL_FILTERS__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Msk);
    reg = (reg >> TEST_TEST_CFG1__BYPASS_ALL_FILTERS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          SM_TEST member of TEST_t                          */
/* -------------------------------------------------------------------------- */

/** __TEST_SM_TEST__ADDRESS returns the address of member SM_TEST.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of SM_TEST
 */
__TEST_INLINE uint32_t* __TEST_SM_TEST__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, SM_TEST)));
}

/** TEST_SM_TEST__SET() sets SM_TEST to given value.
 *
 * When writing to SM_TEST, this is mandatory to use.
 *
 * @param value new value for SM_TEST
 */
__TEST_INLINE void TEST_SM_TEST__SET(uint32_t value)
{
    HAL_SET32(__TEST_SM_TEST__ADDRESS(), value);
}

/** TEST_SM_TEST__GET() gets SM_TEST's current value.
 *
 * When reading from SM_TEST, this is mandatory to use.
 *
 * @return current value of SM_TEST
 */
__TEST_INLINE uint32_t TEST_SM_TEST__GET(void)
{
    return HAL_GET32(__TEST_SM_TEST__ADDRESS());
}

/* ----------------------- TEST.SM_TEST.BLOCK_EN_ALL ----------------------- */

/**
<pre>
  TEST.SM_TEST.BLOCK_EN_ALL:

    Test mode override of block enables.  If both sm_test_mode and block_en_all are high then all enables from common.EN_REG1, common.EN_REG2 and common.EN_REG3 are forced high.

</pre> */

#define TEST_SM_TEST__BLOCK_EN_ALL__Pos                         1                                                                      /*!< Right-most bit position of block_en_all in TEST.SM_TEST */
#define TEST_SM_TEST__BLOCK_EN_ALL__Msk                         (0x00000001UL << TEST_SM_TEST__BLOCK_EN_ALL__Pos)                      /*!< Mask for block_en_all in TEST.SM_TEST */
#define TEST_SM_TEST__BLOCK_EN_ALL__Shift(v)                    (((v) << TEST_SM_TEST__BLOCK_EN_ALL__Pos) & TEST_SM_TEST__BLOCK_EN_ALL__Msk) /*!< Shift value 'v' into block_en_all and mask 'v' to fit it into block_en_all field */

/** TEST_SM_TEST__BLOCK_EN_ALL__SET() sets SM_TEST.BLOCK_EN_ALL to given value.
 *
 * When writing to SM_TEST.BLOCK_EN_ALL, this is recommended to use.
 *
 * @param bf_value new value for SM_TEST.BLOCK_EN_ALL
 */
__TEST_INLINE void TEST_SM_TEST__BLOCK_EN_ALL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_SM_TEST__GET();
    reg = (reg & ~TEST_SM_TEST__BLOCK_EN_ALL__Msk);
    reg = (reg | (TEST_SM_TEST__BLOCK_EN_ALL__Shift((uint32_t)bf_value)));
    TEST_SM_TEST__SET(reg);
}

/** TEST_SM_TEST__BLOCK_EN_ALL__GET() gets SM_TEST.BLOCK_EN_ALL's current value.
 *
 * When reading from SM_TEST.BLOCK_EN_ALL, this is recommended to use.
 *
 * @return current value of SM_TEST.BLOCK_EN_ALL
 */
__TEST_INLINE uint32_t TEST_SM_TEST__BLOCK_EN_ALL__GET(void)
{
    uint32_t reg = TEST_SM_TEST__GET();
    reg = (reg & TEST_SM_TEST__BLOCK_EN_ALL__Msk);
    reg = (reg >> TEST_SM_TEST__BLOCK_EN_ALL__Pos);
    return (uint32_t)reg;
}

/** TEST_SM_TEST__BLOCK_EN_ALL__MODIFY() modifies SM_TEST.BLOCK_EN_ALL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.SM_TEST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.SM_TEST
 * @param bf_value new value for SM_TEST.BLOCK_EN_ALL
 * @return new value of TEST.SM_TEST
 */
__TEST_INLINE uint32_t TEST_SM_TEST__BLOCK_EN_ALL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_SM_TEST__BLOCK_EN_ALL__Msk);
    reg = (reg | (TEST_SM_TEST__BLOCK_EN_ALL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_SM_TEST__BLOCK_EN_ALL__EXTRACT() extracts SM_TEST.BLOCK_EN_ALL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.SM_TEST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.SM_TEST
 * @return current value of SM_TEST.BLOCK_EN_ALL
 */
__TEST_INLINE uint32_t TEST_SM_TEST__BLOCK_EN_ALL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_SM_TEST__BLOCK_EN_ALL__Msk);
    reg = (reg >> TEST_SM_TEST__BLOCK_EN_ALL__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TEST.SM_TEST.SM_TEST_MODE ----------------------- */

/**
<pre>
  TEST.SM_TEST.SM_TEST_MODE:

    Test state control
    <start table>
    0 "Normal operation"
    1 "Test mode"
    <end table>

</pre> */

#define TEST_SM_TEST__SM_TEST_MODE__Pos                         0                                                                      /*!< Right-most bit position of sm_test_mode in TEST.SM_TEST */
#define TEST_SM_TEST__SM_TEST_MODE__Msk                         (0x00000001UL << TEST_SM_TEST__SM_TEST_MODE__Pos)                      /*!< Mask for sm_test_mode in TEST.SM_TEST */
#define TEST_SM_TEST__SM_TEST_MODE__Shift(v)                    (((v) << TEST_SM_TEST__SM_TEST_MODE__Pos) & TEST_SM_TEST__SM_TEST_MODE__Msk) /*!< Shift value 'v' into sm_test_mode and mask 'v' to fit it into sm_test_mode field */

/** TEST_SM_TEST__SM_TEST_MODE__SET() sets SM_TEST.SM_TEST_MODE to given value.
 *
 * When writing to SM_TEST.SM_TEST_MODE, this is recommended to use.
 *
 * @param bf_value new value for SM_TEST.SM_TEST_MODE
 */
__TEST_INLINE void TEST_SM_TEST__SM_TEST_MODE__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_SM_TEST__GET();
    reg = (reg & ~TEST_SM_TEST__SM_TEST_MODE__Msk);
    reg = (reg | (TEST_SM_TEST__SM_TEST_MODE__Shift((uint32_t)bf_value)));
    TEST_SM_TEST__SET(reg);
}

/** TEST_SM_TEST__SM_TEST_MODE__GET() gets SM_TEST.SM_TEST_MODE's current value.
 *
 * When reading from SM_TEST.SM_TEST_MODE, this is recommended to use.
 *
 * @return current value of SM_TEST.SM_TEST_MODE
 */
__TEST_INLINE uint32_t TEST_SM_TEST__SM_TEST_MODE__GET(void)
{
    uint32_t reg = TEST_SM_TEST__GET();
    reg = (reg & TEST_SM_TEST__SM_TEST_MODE__Msk);
    reg = (reg >> TEST_SM_TEST__SM_TEST_MODE__Pos);
    return (uint32_t)reg;
}

/** TEST_SM_TEST__SM_TEST_MODE__MODIFY() modifies SM_TEST.SM_TEST_MODE.
 *
 * This is recommended to use when setting more than one bitfield of TEST.SM_TEST.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.SM_TEST
 * @param bf_value new value for SM_TEST.SM_TEST_MODE
 * @return new value of TEST.SM_TEST
 */
__TEST_INLINE uint32_t TEST_SM_TEST__SM_TEST_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_SM_TEST__SM_TEST_MODE__Msk);
    reg = (reg | (TEST_SM_TEST__SM_TEST_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_SM_TEST__SM_TEST_MODE__EXTRACT() extracts SM_TEST.SM_TEST_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.SM_TEST.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.SM_TEST
 * @return current value of SM_TEST.SM_TEST_MODE
 */
__TEST_INLINE uint32_t TEST_SM_TEST__SM_TEST_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_SM_TEST__SM_TEST_MODE__Msk);
    reg = (reg >> TEST_SM_TEST__SM_TEST_MODE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TEST_TBUS member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_TBUS__ADDRESS returns the address of member TEST_TBUS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_TBUS
 */
__TEST_INLINE uint32_t* __TEST_TEST_TBUS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_TBUS)));
}

/** TEST_TEST_TBUS__GET() gets TEST_TBUS's current value.
 *
 * When reading from TEST_TBUS, this is mandatory to use.
 *
 * @return current value of TEST_TBUS
 */
__TEST_INLINE uint32_t TEST_TEST_TBUS__GET(void)
{
    return HAL_GET32(__TEST_TEST_TBUS__ADDRESS());
}

/* ------------------------ TEST.TEST_TBUS.TEST_TBUS ------------------------ */

/**
<pre>
  TEST.TEST_TBUS.TEST_TBUS:

    Digital test bus (TBUS) status register.  This register contains the output of final tbus mux which is also the input to the Voltage DAC (VDAC).

</pre> */

#define TEST_TEST_TBUS__TEST_TBUS__Pos                          0                                                                      /*!< Right-most bit position of test_tbus in TEST.TEST_TBUS */
#define TEST_TEST_TBUS__TEST_TBUS__Msk                          (0x0000FFFFUL << TEST_TEST_TBUS__TEST_TBUS__Pos)                       /*!< Mask for test_tbus in TEST.TEST_TBUS */
#define TEST_TEST_TBUS__TEST_TBUS__Shift(v)                     (((v) << TEST_TEST_TBUS__TEST_TBUS__Pos) & TEST_TEST_TBUS__TEST_TBUS__Msk) /*!< Shift value 'v' into test_tbus and mask 'v' to fit it into test_tbus field */

/** TEST_TEST_TBUS__TEST_TBUS__GET() gets TEST_TBUS.TEST_TBUS's current value.
 *
 * When reading from TEST_TBUS.TEST_TBUS, this is recommended to use.
 *
 * @return current value of TEST_TBUS.TEST_TBUS
 */
__TEST_INLINE uint32_t TEST_TEST_TBUS__TEST_TBUS__GET(void)
{
    uint32_t reg = TEST_TEST_TBUS__GET();
    reg = (reg & TEST_TEST_TBUS__TEST_TBUS__Msk);
    reg = (reg >> TEST_TEST_TBUS__TEST_TBUS__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TBUS__TEST_TBUS__EXTRACT() extracts TEST_TBUS.TEST_TBUS.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TBUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TBUS
 * @return current value of TEST_TBUS.TEST_TBUS
 */
__TEST_INLINE uint32_t TEST_TEST_TBUS__TEST_TBUS__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TBUS__TEST_TBUS__Msk);
    reg = (reg >> TEST_TEST_TBUS__TEST_TBUS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TMUX_ANA member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_TMUX_ANA__ADDRESS returns the address of member TMUX_ANA.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TMUX_ANA
 */
__TEST_INLINE uint32_t* __TEST_TMUX_ANA__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TMUX_ANA)));
}

/** TEST_TMUX_ANA__SET() sets TMUX_ANA to given value.
 *
 * When writing to TMUX_ANA, this is mandatory to use.
 *
 * @param value new value for TMUX_ANA
 */
__TEST_INLINE void TEST_TMUX_ANA__SET(uint32_t value)
{
    HAL_SET32(__TEST_TMUX_ANA__ADDRESS(), value);
}

/** TEST_TMUX_ANA__GET() gets TMUX_ANA's current value.
 *
 * When reading from TMUX_ANA, this is mandatory to use.
 *
 * @return current value of TMUX_ANA
 */
__TEST_INLINE uint32_t TEST_TMUX_ANA__GET(void)
{
    return HAL_GET32(__TEST_TMUX_ANA__ADDRESS());
}

/* -------------------- TEST.TMUX_ANA.TMUX_ANA_MODE_3V3 -------------------- */

/**
<pre>
  TEST.TMUX_ANA.TMUX_ANA_MODE_3V3:

    Analog test mux supply domain select.
    <start table>
    0 1.20V
    1 3.30V
    <end table>

</pre> */

#define TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Pos                   12                                                                     /*!< Right-most bit position of tmux_ana_mode_3v3 in TEST.TMUX_ANA */
#define TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Msk                   (0x00000001UL << TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Pos)                /*!< Mask for tmux_ana_mode_3v3 in TEST.TMUX_ANA */
#define TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Shift(v)              (((v) << TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Pos) & TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Msk) /*!< Shift value 'v' into tmux_ana_mode_3v3 and mask 'v' to fit it into tmux_ana_mode_3v3 field */

/** TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__SET() sets TMUX_ANA.TMUX_ANA_MODE_3V3 to given value.
 *
 * When writing to TMUX_ANA.TMUX_ANA_MODE_3V3, this is recommended to use.
 *
 * @param bf_value new value for TMUX_ANA.TMUX_ANA_MODE_3V3
 */
__TEST_INLINE void TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TMUX_ANA__GET();
    reg = (reg & ~TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Msk);
    reg = (reg | (TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Shift((uint32_t)bf_value)));
    TEST_TMUX_ANA__SET(reg);
}

/** TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__GET() gets TMUX_ANA.TMUX_ANA_MODE_3V3's current value.
 *
 * When reading from TMUX_ANA.TMUX_ANA_MODE_3V3, this is recommended to use.
 *
 * @return current value of TMUX_ANA.TMUX_ANA_MODE_3V3
 */
__TEST_INLINE uint32_t TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__GET(void)
{
    uint32_t reg = TEST_TMUX_ANA__GET();
    reg = (reg & TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Msk);
    reg = (reg >> TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Pos);
    return (uint32_t)reg;
}

/** TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__MODIFY() modifies TMUX_ANA.TMUX_ANA_MODE_3V3.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TMUX_ANA.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TMUX_ANA
 * @param bf_value new value for TMUX_ANA.TMUX_ANA_MODE_3V3
 * @return new value of TEST.TMUX_ANA
 */
__TEST_INLINE uint32_t TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Msk);
    reg = (reg | (TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__EXTRACT() extracts TMUX_ANA.TMUX_ANA_MODE_3V3.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TMUX_ANA.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TMUX_ANA
 * @return current value of TMUX_ANA.TMUX_ANA_MODE_3V3
 */
__TEST_INLINE uint32_t TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Msk);
    reg = (reg >> TEST_TMUX_ANA__TMUX_ANA_MODE_3V3__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TEST.TMUX_ANA.TMUX_SEL_ANA ----------------------- */

/**
<pre>
  TEST.TMUX_ANA.TMUX_SEL_ANA:

    Analog test mux input select.  This register selects the analog test mux input within the block selected by tmux_blk_ana.

</pre> */

#define TEST_TMUX_ANA__TMUX_SEL_ANA__Pos                        6                                                                      /*!< Right-most bit position of tmux_sel_ana in TEST.TMUX_ANA */
#define TEST_TMUX_ANA__TMUX_SEL_ANA__Msk                        (0x0000003FUL << TEST_TMUX_ANA__TMUX_SEL_ANA__Pos)                     /*!< Mask for tmux_sel_ana in TEST.TMUX_ANA */
#define TEST_TMUX_ANA__TMUX_SEL_ANA__Shift(v)                   (((v) << TEST_TMUX_ANA__TMUX_SEL_ANA__Pos) & TEST_TMUX_ANA__TMUX_SEL_ANA__Msk) /*!< Shift value 'v' into tmux_sel_ana and mask 'v' to fit it into tmux_sel_ana field */

/** TEST_TMUX_ANA__TMUX_SEL_ANA__SET() sets TMUX_ANA.TMUX_SEL_ANA to given value.
 *
 * When writing to TMUX_ANA.TMUX_SEL_ANA, this is recommended to use.
 *
 * @param bf_value new value for TMUX_ANA.TMUX_SEL_ANA
 */
__TEST_INLINE void TEST_TMUX_ANA__TMUX_SEL_ANA__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TMUX_ANA__GET();
    reg = (reg & ~TEST_TMUX_ANA__TMUX_SEL_ANA__Msk);
    reg = (reg | (TEST_TMUX_ANA__TMUX_SEL_ANA__Shift((uint32_t)bf_value)));
    TEST_TMUX_ANA__SET(reg);
}

/** TEST_TMUX_ANA__TMUX_SEL_ANA__GET() gets TMUX_ANA.TMUX_SEL_ANA's current value.
 *
 * When reading from TMUX_ANA.TMUX_SEL_ANA, this is recommended to use.
 *
 * @return current value of TMUX_ANA.TMUX_SEL_ANA
 */
__TEST_INLINE uint32_t TEST_TMUX_ANA__TMUX_SEL_ANA__GET(void)
{
    uint32_t reg = TEST_TMUX_ANA__GET();
    reg = (reg & TEST_TMUX_ANA__TMUX_SEL_ANA__Msk);
    reg = (reg >> TEST_TMUX_ANA__TMUX_SEL_ANA__Pos);
    return (uint32_t)reg;
}

/** TEST_TMUX_ANA__TMUX_SEL_ANA__MODIFY() modifies TMUX_ANA.TMUX_SEL_ANA.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TMUX_ANA.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TMUX_ANA
 * @param bf_value new value for TMUX_ANA.TMUX_SEL_ANA
 * @return new value of TEST.TMUX_ANA
 */
__TEST_INLINE uint32_t TEST_TMUX_ANA__TMUX_SEL_ANA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TMUX_ANA__TMUX_SEL_ANA__Msk);
    reg = (reg | (TEST_TMUX_ANA__TMUX_SEL_ANA__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TMUX_ANA__TMUX_SEL_ANA__EXTRACT() extracts TMUX_ANA.TMUX_SEL_ANA.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TMUX_ANA.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TMUX_ANA
 * @return current value of TMUX_ANA.TMUX_SEL_ANA
 */
__TEST_INLINE uint32_t TEST_TMUX_ANA__TMUX_SEL_ANA__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TMUX_ANA__TMUX_SEL_ANA__Msk);
    reg = (reg >> TEST_TMUX_ANA__TMUX_SEL_ANA__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TEST.TMUX_ANA.TMUX_BLK_ANA ----------------------- */

/**
<pre>
  TEST.TMUX_ANA.TMUX_BLK_ANA:

    Analog test mux block select.  This register selects which functional block is selected for the analog test mux output.
    <start table_with_header>
    [5:0] "Block" "[5:0]" "Block"
    0 "Disabled" "1" "IS1"
    2 "IS1" "3" "IS3"
    4 "Bandgap" "5" "MDAC"
    6 "Disabled" "7" "Disabled"
    8 "Disabled" "9" "Disabled"
    10 "TS" "11" "VS0"
    12 "VS1" "13" "VS2"
    14 "Supply" "15" "OTP"
    16-19 "Unused Spares" "20-63" "Disabled"
    <end table>

</pre> */

#define TEST_TMUX_ANA__TMUX_BLK_ANA__Pos                        0                                                                      /*!< Right-most bit position of tmux_blk_ana in TEST.TMUX_ANA */
#define TEST_TMUX_ANA__TMUX_BLK_ANA__Msk                        (0x0000003FUL << TEST_TMUX_ANA__TMUX_BLK_ANA__Pos)                     /*!< Mask for tmux_blk_ana in TEST.TMUX_ANA */
#define TEST_TMUX_ANA__TMUX_BLK_ANA__Shift(v)                   (((v) << TEST_TMUX_ANA__TMUX_BLK_ANA__Pos) & TEST_TMUX_ANA__TMUX_BLK_ANA__Msk) /*!< Shift value 'v' into tmux_blk_ana and mask 'v' to fit it into tmux_blk_ana field */

/** TEST_TMUX_ANA__TMUX_BLK_ANA__SET() sets TMUX_ANA.TMUX_BLK_ANA to given value.
 *
 * When writing to TMUX_ANA.TMUX_BLK_ANA, this is recommended to use.
 *
 * @param bf_value new value for TMUX_ANA.TMUX_BLK_ANA
 */
__TEST_INLINE void TEST_TMUX_ANA__TMUX_BLK_ANA__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TMUX_ANA__GET();
    reg = (reg & ~TEST_TMUX_ANA__TMUX_BLK_ANA__Msk);
    reg = (reg | (TEST_TMUX_ANA__TMUX_BLK_ANA__Shift((uint32_t)bf_value)));
    TEST_TMUX_ANA__SET(reg);
}

/** TEST_TMUX_ANA__TMUX_BLK_ANA__GET() gets TMUX_ANA.TMUX_BLK_ANA's current value.
 *
 * When reading from TMUX_ANA.TMUX_BLK_ANA, this is recommended to use.
 *
 * @return current value of TMUX_ANA.TMUX_BLK_ANA
 */
__TEST_INLINE uint32_t TEST_TMUX_ANA__TMUX_BLK_ANA__GET(void)
{
    uint32_t reg = TEST_TMUX_ANA__GET();
    reg = (reg & TEST_TMUX_ANA__TMUX_BLK_ANA__Msk);
    reg = (reg >> TEST_TMUX_ANA__TMUX_BLK_ANA__Pos);
    return (uint32_t)reg;
}

/** TEST_TMUX_ANA__TMUX_BLK_ANA__MODIFY() modifies TMUX_ANA.TMUX_BLK_ANA.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TMUX_ANA.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TMUX_ANA
 * @param bf_value new value for TMUX_ANA.TMUX_BLK_ANA
 * @return new value of TEST.TMUX_ANA
 */
__TEST_INLINE uint32_t TEST_TMUX_ANA__TMUX_BLK_ANA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TMUX_ANA__TMUX_BLK_ANA__Msk);
    reg = (reg | (TEST_TMUX_ANA__TMUX_BLK_ANA__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TMUX_ANA__TMUX_BLK_ANA__EXTRACT() extracts TMUX_ANA.TMUX_BLK_ANA.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TMUX_ANA.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TMUX_ANA
 * @return current value of TMUX_ANA.TMUX_BLK_ANA
 */
__TEST_INLINE uint32_t TEST_TMUX_ANA__TMUX_BLK_ANA__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TMUX_ANA__TMUX_BLK_ANA__Msk);
    reg = (reg >> TEST_TMUX_ANA__TMUX_BLK_ANA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           TBUS member of TEST_t                           */
/* -------------------------------------------------------------------------- */

/** __TEST_TBUS__ADDRESS returns the address of member TBUS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TBUS
 */
__TEST_INLINE uint32_t* __TEST_TBUS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TBUS)));
}

/** TEST_TBUS__SET() sets TBUS to given value.
 *
 * When writing to TBUS, this is mandatory to use.
 *
 * @param value new value for TBUS
 */
__TEST_INLINE void TEST_TBUS__SET(uint32_t value)
{
    HAL_SET32(__TEST_TBUS__ADDRESS(), value);
}

/** TEST_TBUS__GET() gets TBUS's current value.
 *
 * When reading from TBUS, this is mandatory to use.
 *
 * @return current value of TBUS
 */
__TEST_INLINE uint32_t TEST_TBUS__GET(void)
{
    return HAL_GET32(__TEST_TBUS__ADDRESS());
}

/* ------------------------- TEST.TBUS.TBUS_BLK_SEL ------------------------- */

/**
<pre>
  TEST.TBUS.TBUS_BLK_SEL:

    Digital test bus (TBUS) block select.  This register selects which functional block is selected for the TBUS output.
    <start table_with_header>
    [7:0] Block [7:0] Block [7:0] Block [7:0] Block
    0 "disabled" "1" "Digital Top" "2" "Clock Generator" "3" "CPUS"
    4 "Control Top" "5" "Fault" "6" "Balance" "7" "ISP1"
    8 "ISP2" "9" "PID0" "10" "PID1" "11" "PWM"
    12 "TELEMETRY" "13" "Test" "14" "TSD" "15" "TSP"
    16 "Vcontrol0" "17" "Vcontrol1" "18" "VSP0" "19" "VSP1"
    20 "VSP2" "21" "CE Voltage Select" "22" "Spare" "23-255" "not used"
    <end table>

</pre> */

#define TEST_TBUS__TBUS_BLK_SEL__Pos                            8                                                                      /*!< Right-most bit position of tbus_blk_sel in TEST.TBUS */
#define TEST_TBUS__TBUS_BLK_SEL__Msk                            (0x000000FFUL << TEST_TBUS__TBUS_BLK_SEL__Pos)                         /*!< Mask for tbus_blk_sel in TEST.TBUS */
#define TEST_TBUS__TBUS_BLK_SEL__Shift(v)                       (((v) << TEST_TBUS__TBUS_BLK_SEL__Pos) & TEST_TBUS__TBUS_BLK_SEL__Msk) /*!< Shift value 'v' into tbus_blk_sel and mask 'v' to fit it into tbus_blk_sel field */

/** TEST_TBUS__TBUS_BLK_SEL__SET() sets TBUS.TBUS_BLK_SEL to given value.
 *
 * When writing to TBUS.TBUS_BLK_SEL, this is recommended to use.
 *
 * @param bf_value new value for TBUS.TBUS_BLK_SEL
 */
__TEST_INLINE void TEST_TBUS__TBUS_BLK_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TBUS__GET();
    reg = (reg & ~TEST_TBUS__TBUS_BLK_SEL__Msk);
    reg = (reg | (TEST_TBUS__TBUS_BLK_SEL__Shift((uint32_t)bf_value)));
    TEST_TBUS__SET(reg);
}

/** TEST_TBUS__TBUS_BLK_SEL__GET() gets TBUS.TBUS_BLK_SEL's current value.
 *
 * When reading from TBUS.TBUS_BLK_SEL, this is recommended to use.
 *
 * @return current value of TBUS.TBUS_BLK_SEL
 */
__TEST_INLINE uint32_t TEST_TBUS__TBUS_BLK_SEL__GET(void)
{
    uint32_t reg = TEST_TBUS__GET();
    reg = (reg & TEST_TBUS__TBUS_BLK_SEL__Msk);
    reg = (reg >> TEST_TBUS__TBUS_BLK_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TBUS__TBUS_BLK_SEL__MODIFY() modifies TBUS.TBUS_BLK_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TBUS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TBUS
 * @param bf_value new value for TBUS.TBUS_BLK_SEL
 * @return new value of TEST.TBUS
 */
__TEST_INLINE uint32_t TEST_TBUS__TBUS_BLK_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TBUS__TBUS_BLK_SEL__Msk);
    reg = (reg | (TEST_TBUS__TBUS_BLK_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TBUS__TBUS_BLK_SEL__EXTRACT() extracts TBUS.TBUS_BLK_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TBUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TBUS
 * @return current value of TBUS.TBUS_BLK_SEL
 */
__TEST_INLINE uint32_t TEST_TBUS__TBUS_BLK_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TBUS__TBUS_BLK_SEL__Msk);
    reg = (reg >> TEST_TBUS__TBUS_BLK_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------------- TEST.TBUS.TBUS_SEL --------------------------- */

/**
<pre>
  TEST.TBUS.TBUS_SEL:

    Digital test bus (TBUS) input select.  This register selects the TBUS mux input within the block selected by tbus_blk_sel.

</pre> */

#define TEST_TBUS__TBUS_SEL__Pos                                0                                                                      /*!< Right-most bit position of tbus_sel in TEST.TBUS */
#define TEST_TBUS__TBUS_SEL__Msk                                (0x000000FFUL << TEST_TBUS__TBUS_SEL__Pos)                             /*!< Mask for tbus_sel in TEST.TBUS */
#define TEST_TBUS__TBUS_SEL__Shift(v)                           (((v) << TEST_TBUS__TBUS_SEL__Pos) & TEST_TBUS__TBUS_SEL__Msk)         /*!< Shift value 'v' into tbus_sel and mask 'v' to fit it into tbus_sel field */

/** TEST_TBUS__TBUS_SEL__SET() sets TBUS.TBUS_SEL to given value.
 *
 * When writing to TBUS.TBUS_SEL, this is recommended to use.
 *
 * @param bf_value new value for TBUS.TBUS_SEL
 */
__TEST_INLINE void TEST_TBUS__TBUS_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TBUS__GET();
    reg = (reg & ~TEST_TBUS__TBUS_SEL__Msk);
    reg = (reg | (TEST_TBUS__TBUS_SEL__Shift((uint32_t)bf_value)));
    TEST_TBUS__SET(reg);
}

/** TEST_TBUS__TBUS_SEL__GET() gets TBUS.TBUS_SEL's current value.
 *
 * When reading from TBUS.TBUS_SEL, this is recommended to use.
 *
 * @return current value of TBUS.TBUS_SEL
 */
__TEST_INLINE uint32_t TEST_TBUS__TBUS_SEL__GET(void)
{
    uint32_t reg = TEST_TBUS__GET();
    reg = (reg & TEST_TBUS__TBUS_SEL__Msk);
    reg = (reg >> TEST_TBUS__TBUS_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TBUS__TBUS_SEL__MODIFY() modifies TBUS.TBUS_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TBUS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TBUS
 * @param bf_value new value for TBUS.TBUS_SEL
 * @return new value of TEST.TBUS
 */
__TEST_INLINE uint32_t TEST_TBUS__TBUS_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TBUS__TBUS_SEL__Msk);
    reg = (reg | (TEST_TBUS__TBUS_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TBUS__TBUS_SEL__EXTRACT() extracts TBUS.TBUS_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TBUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TBUS
 * @return current value of TBUS.TBUS_SEL
 */
__TEST_INLINE uint32_t TEST_TBUS__TBUS_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TBUS__TBUS_SEL__Msk);
    reg = (reg >> TEST_TBUS__TBUS_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           TMUX member of TEST_t                           */
/* -------------------------------------------------------------------------- */

/** __TEST_TMUX__ADDRESS returns the address of member TMUX.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TMUX
 */
__TEST_INLINE uint32_t* __TEST_TMUX__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TMUX)));
}

/** TEST_TMUX__SET() sets TMUX to given value.
 *
 * When writing to TMUX, this is mandatory to use.
 *
 * @param value new value for TMUX
 */
__TEST_INLINE void TEST_TMUX__SET(uint32_t value)
{
    HAL_SET32(__TEST_TMUX__ADDRESS(), value);
}

/** TEST_TMUX__GET() gets TMUX's current value.
 *
 * When reading from TMUX, this is mandatory to use.
 *
 * @return current value of TMUX
 */
__TEST_INLINE uint32_t TEST_TMUX__GET(void)
{
    return HAL_GET32(__TEST_TMUX__ADDRESS());
}

/* ------------------------ TEST.TMUX.TMUXB_BLK_SEL ------------------------ */

/**
<pre>
  TEST.TMUX.TMUXB_BLK_SEL:

    Digital test mux B (TMUXB) block select.  This register selects which functional block is selected for the TMUXB output.
    <start table_with_header>
    [7:0] Block [7:0] Block [7:0] Block [7:0] Block
    0 "disabled" "1" "Digital Top" "2" "Clock Generator" "3" "CPUS"
    4 "Control Top" "5" "Fault" "6" "Balance" "7" "ISP1"
    8 "ISP2" "9" "PID0" "10" "PID1" "11" "PWM"
    12 "TELEMETRY" "13" "Test" "14" "TSD" "15" "TSP"
    16 "Vcontrol0" "17" "Vcontrol1" "18" "VSP0" "19" "VSP1"
    20 "VSP2" "21" "CE Voltage Select" "22" "Fan" "23" "Ishare"
    24-255 "not used" "" "" "" "" "" ""
    <end table>

</pre> */

#define TEST_TMUX__TMUXB_BLK_SEL__Pos                           24                                                                     /*!< Right-most bit position of tmuxb_blk_sel in TEST.TMUX */
#define TEST_TMUX__TMUXB_BLK_SEL__Msk                           (0x000000FFUL << TEST_TMUX__TMUXB_BLK_SEL__Pos)                        /*!< Mask for tmuxb_blk_sel in TEST.TMUX */
#define TEST_TMUX__TMUXB_BLK_SEL__Shift(v)                      (((v) << TEST_TMUX__TMUXB_BLK_SEL__Pos) & TEST_TMUX__TMUXB_BLK_SEL__Msk) /*!< Shift value 'v' into tmuxb_blk_sel and mask 'v' to fit it into tmuxb_blk_sel field */

/** TEST_TMUX__TMUXB_BLK_SEL__SET() sets TMUX.TMUXB_BLK_SEL to given value.
 *
 * When writing to TMUX.TMUXB_BLK_SEL, this is recommended to use.
 *
 * @param bf_value new value for TMUX.TMUXB_BLK_SEL
 */
__TEST_INLINE void TEST_TMUX__TMUXB_BLK_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TMUX__GET();
    reg = (reg & ~TEST_TMUX__TMUXB_BLK_SEL__Msk);
    reg = (reg | (TEST_TMUX__TMUXB_BLK_SEL__Shift((uint32_t)bf_value)));
    TEST_TMUX__SET(reg);
}

/** TEST_TMUX__TMUXB_BLK_SEL__GET() gets TMUX.TMUXB_BLK_SEL's current value.
 *
 * When reading from TMUX.TMUXB_BLK_SEL, this is recommended to use.
 *
 * @return current value of TMUX.TMUXB_BLK_SEL
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXB_BLK_SEL__GET(void)
{
    uint32_t reg = TEST_TMUX__GET();
    reg = (reg & TEST_TMUX__TMUXB_BLK_SEL__Msk);
    reg = (reg >> TEST_TMUX__TMUXB_BLK_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TMUX__TMUXB_BLK_SEL__MODIFY() modifies TMUX.TMUXB_BLK_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TMUX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TMUX
 * @param bf_value new value for TMUX.TMUXB_BLK_SEL
 * @return new value of TEST.TMUX
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXB_BLK_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TMUX__TMUXB_BLK_SEL__Msk);
    reg = (reg | (TEST_TMUX__TMUXB_BLK_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TMUX__TMUXB_BLK_SEL__EXTRACT() extracts TMUX.TMUXB_BLK_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TMUX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TMUX
 * @return current value of TMUX.TMUXB_BLK_SEL
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXB_BLK_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TMUX__TMUXB_BLK_SEL__Msk);
    reg = (reg >> TEST_TMUX__TMUXB_BLK_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------- TEST.TMUX.TMUXB_SEL -------------------------- */

/**
<pre>
  TEST.TMUX.TMUXB_SEL:

    Digital test mux B (TMUXB) input select.  This register selects the TMUXB input within the block selected by tmuxa_blk_sel.

</pre> */

#define TEST_TMUX__TMUXB_SEL__Pos                               16                                                                     /*!< Right-most bit position of tmuxb_sel in TEST.TMUX */
#define TEST_TMUX__TMUXB_SEL__Msk                               (0x000000FFUL << TEST_TMUX__TMUXB_SEL__Pos)                            /*!< Mask for tmuxb_sel in TEST.TMUX */
#define TEST_TMUX__TMUXB_SEL__Shift(v)                          (((v) << TEST_TMUX__TMUXB_SEL__Pos) & TEST_TMUX__TMUXB_SEL__Msk)       /*!< Shift value 'v' into tmuxb_sel and mask 'v' to fit it into tmuxb_sel field */

/** TEST_TMUX__TMUXB_SEL__SET() sets TMUX.TMUXB_SEL to given value.
 *
 * When writing to TMUX.TMUXB_SEL, this is recommended to use.
 *
 * @param bf_value new value for TMUX.TMUXB_SEL
 */
__TEST_INLINE void TEST_TMUX__TMUXB_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TMUX__GET();
    reg = (reg & ~TEST_TMUX__TMUXB_SEL__Msk);
    reg = (reg | (TEST_TMUX__TMUXB_SEL__Shift((uint32_t)bf_value)));
    TEST_TMUX__SET(reg);
}

/** TEST_TMUX__TMUXB_SEL__GET() gets TMUX.TMUXB_SEL's current value.
 *
 * When reading from TMUX.TMUXB_SEL, this is recommended to use.
 *
 * @return current value of TMUX.TMUXB_SEL
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXB_SEL__GET(void)
{
    uint32_t reg = TEST_TMUX__GET();
    reg = (reg & TEST_TMUX__TMUXB_SEL__Msk);
    reg = (reg >> TEST_TMUX__TMUXB_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TMUX__TMUXB_SEL__MODIFY() modifies TMUX.TMUXB_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TMUX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TMUX
 * @param bf_value new value for TMUX.TMUXB_SEL
 * @return new value of TEST.TMUX
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXB_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TMUX__TMUXB_SEL__Msk);
    reg = (reg | (TEST_TMUX__TMUXB_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TMUX__TMUXB_SEL__EXTRACT() extracts TMUX.TMUXB_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TMUX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TMUX
 * @return current value of TMUX.TMUXB_SEL
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXB_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TMUX__TMUXB_SEL__Msk);
    reg = (reg >> TEST_TMUX__TMUXB_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TEST.TMUX.TMUXA_BLK_SEL ------------------------ */

/**
<pre>
  TEST.TMUX.TMUXA_BLK_SEL:

    Digital test mux A (TMUXA) block select.  This register selects which functional block is selected for the TMUXA output.
    <start table_with_header>
    [7:0] Block [7:0] Block [7:0] Block [7:0] Block
    0 "disabled" "1" "Digital Top" "2" "Clock Generator" "3" "CPUS"
    4 "Control Top" "5" "Fault" "6" "Balance" "7" "ISP1"
    8 "ISP2" "9" "PID0" "10" "PID1" "11" "PWM"
    12 "TELEMETRY" "13" "Test" "14" "TSD" "15" "TSP"
    16 "Vcontrol0" "17" "Vcontrol1" "18" "VSP0" "19" "VSP1"
    20 "VSP2" "21" "CE Voltage Select" "22" "Fan" "23" "Ishare"
    24-255 "not used" "" "" "" "" "" ""
    <end table>

</pre> */

#define TEST_TMUX__TMUXA_BLK_SEL__Pos                           8                                                                      /*!< Right-most bit position of tmuxa_blk_sel in TEST.TMUX */
#define TEST_TMUX__TMUXA_BLK_SEL__Msk                           (0x000000FFUL << TEST_TMUX__TMUXA_BLK_SEL__Pos)                        /*!< Mask for tmuxa_blk_sel in TEST.TMUX */
#define TEST_TMUX__TMUXA_BLK_SEL__Shift(v)                      (((v) << TEST_TMUX__TMUXA_BLK_SEL__Pos) & TEST_TMUX__TMUXA_BLK_SEL__Msk) /*!< Shift value 'v' into tmuxa_blk_sel and mask 'v' to fit it into tmuxa_blk_sel field */

/** TEST_TMUX__TMUXA_BLK_SEL__SET() sets TMUX.TMUXA_BLK_SEL to given value.
 *
 * When writing to TMUX.TMUXA_BLK_SEL, this is recommended to use.
 *
 * @param bf_value new value for TMUX.TMUXA_BLK_SEL
 */
__TEST_INLINE void TEST_TMUX__TMUXA_BLK_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TMUX__GET();
    reg = (reg & ~TEST_TMUX__TMUXA_BLK_SEL__Msk);
    reg = (reg | (TEST_TMUX__TMUXA_BLK_SEL__Shift((uint32_t)bf_value)));
    TEST_TMUX__SET(reg);
}

/** TEST_TMUX__TMUXA_BLK_SEL__GET() gets TMUX.TMUXA_BLK_SEL's current value.
 *
 * When reading from TMUX.TMUXA_BLK_SEL, this is recommended to use.
 *
 * @return current value of TMUX.TMUXA_BLK_SEL
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXA_BLK_SEL__GET(void)
{
    uint32_t reg = TEST_TMUX__GET();
    reg = (reg & TEST_TMUX__TMUXA_BLK_SEL__Msk);
    reg = (reg >> TEST_TMUX__TMUXA_BLK_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TMUX__TMUXA_BLK_SEL__MODIFY() modifies TMUX.TMUXA_BLK_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TMUX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TMUX
 * @param bf_value new value for TMUX.TMUXA_BLK_SEL
 * @return new value of TEST.TMUX
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXA_BLK_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TMUX__TMUXA_BLK_SEL__Msk);
    reg = (reg | (TEST_TMUX__TMUXA_BLK_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TMUX__TMUXA_BLK_SEL__EXTRACT() extracts TMUX.TMUXA_BLK_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TMUX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TMUX
 * @return current value of TMUX.TMUXA_BLK_SEL
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXA_BLK_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TMUX__TMUXA_BLK_SEL__Msk);
    reg = (reg >> TEST_TMUX__TMUXA_BLK_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------- TEST.TMUX.TMUXA_SEL -------------------------- */

/**
<pre>
  TEST.TMUX.TMUXA_SEL:

    Digital test mux A (TMUXA) input select.  This register selects the TMUXA input within the block selected by tmuxa_blk_sel.

</pre> */

#define TEST_TMUX__TMUXA_SEL__Pos                               0                                                                      /*!< Right-most bit position of tmuxa_sel in TEST.TMUX */
#define TEST_TMUX__TMUXA_SEL__Msk                               (0x000000FFUL << TEST_TMUX__TMUXA_SEL__Pos)                            /*!< Mask for tmuxa_sel in TEST.TMUX */
#define TEST_TMUX__TMUXA_SEL__Shift(v)                          (((v) << TEST_TMUX__TMUXA_SEL__Pos) & TEST_TMUX__TMUXA_SEL__Msk)       /*!< Shift value 'v' into tmuxa_sel and mask 'v' to fit it into tmuxa_sel field */

/** TEST_TMUX__TMUXA_SEL__SET() sets TMUX.TMUXA_SEL to given value.
 *
 * When writing to TMUX.TMUXA_SEL, this is recommended to use.
 *
 * @param bf_value new value for TMUX.TMUXA_SEL
 */
__TEST_INLINE void TEST_TMUX__TMUXA_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TMUX__GET();
    reg = (reg & ~TEST_TMUX__TMUXA_SEL__Msk);
    reg = (reg | (TEST_TMUX__TMUXA_SEL__Shift((uint32_t)bf_value)));
    TEST_TMUX__SET(reg);
}

/** TEST_TMUX__TMUXA_SEL__GET() gets TMUX.TMUXA_SEL's current value.
 *
 * When reading from TMUX.TMUXA_SEL, this is recommended to use.
 *
 * @return current value of TMUX.TMUXA_SEL
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXA_SEL__GET(void)
{
    uint32_t reg = TEST_TMUX__GET();
    reg = (reg & TEST_TMUX__TMUXA_SEL__Msk);
    reg = (reg >> TEST_TMUX__TMUXA_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TMUX__TMUXA_SEL__MODIFY() modifies TMUX.TMUXA_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TMUX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TMUX
 * @param bf_value new value for TMUX.TMUXA_SEL
 * @return new value of TEST.TMUX
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXA_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TMUX__TMUXA_SEL__Msk);
    reg = (reg | (TEST_TMUX__TMUXA_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TMUX__TMUXA_SEL__EXTRACT() extracts TMUX.TMUXA_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TMUX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TMUX
 * @return current value of TMUX.TMUXA_SEL
 */
__TEST_INLINE uint32_t TEST_TMUX__TMUXA_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TMUX__TMUXA_SEL__Msk);
    reg = (reg >> TEST_TMUX__TMUXA_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TEST_REF_DIG member of TEST_t                       */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_REF_DIG__ADDRESS returns the address of member TEST_REF_DIG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_REF_DIG
 */
__TEST_INLINE uint32_t* __TEST_TEST_REF_DIG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_REF_DIG)));
}

/** TEST_TEST_REF_DIG__SET() sets TEST_REF_DIG to given value.
 *
 * When writing to TEST_REF_DIG, this is mandatory to use.
 *
 * @param value new value for TEST_REF_DIG
 */
__TEST_INLINE void TEST_TEST_REF_DIG__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_REF_DIG__ADDRESS(), value);
}

/** TEST_TEST_REF_DIG__GET() gets TEST_REF_DIG's current value.
 *
 * When reading from TEST_REF_DIG, this is mandatory to use.
 *
 * @return current value of TEST_REF_DIG
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__GET(void)
{
    return HAL_GET32(__TEST_TEST_REF_DIG__ADDRESS());
}

/* ---------------- TEST.TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN ---------------- */

/**
<pre>
  TEST.TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN:

    Voltage DAC (VDAC, a.k.a. MDAC) test mode force enable.
    <start table>
    0 "Normal operation"
    1 "Test mode forced input from mdac_ref_dig_force_din[7:0]"
    <end table>

</pre> */

#define TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Pos           21                                                                     /*!< Right-most bit position of mdac_ref_dig_force_en in TEST.TEST_REF_DIG */
#define TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Msk           (0x00000001UL << TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Pos)        /*!< Mask for mdac_ref_dig_force_en in TEST.TEST_REF_DIG */
#define TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Shift(v)      (((v) << TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Pos) & TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Msk) /*!< Shift value 'v' into mdac_ref_dig_force_en and mask 'v' to fit it into mdac_ref_dig_force_en field */

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__SET() sets TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN to given value.
 *
 * When writing to TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN
 */
__TEST_INLINE void TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_REF_DIG__GET();
    reg = (reg & ~TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Msk);
    reg = (reg | (TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_REF_DIG__SET(reg);
}

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__GET() gets TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN's current value.
 *
 * When reading from TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN, this is recommended to use.
 *
 * @return current value of TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__GET(void)
{
    uint32_t reg = TEST_TEST_REF_DIG__GET();
    reg = (reg & TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Msk);
    reg = (reg >> TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__MODIFY() modifies TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_REF_DIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_REF_DIG
 * @param bf_value new value for TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN
 * @return new value of TEST.TEST_REF_DIG
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Msk);
    reg = (reg | (TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__EXTRACT() extracts TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_REF_DIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_REF_DIG
 * @return current value of TEST_REF_DIG.MDAC_REF_DIG_FORCE_EN
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Msk);
    reg = (reg >> TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------- TEST.TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL ---------------- */

/**
<pre>
  TEST.TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL:

    Voltage DAC (VDAC, a.k.a. MDAC)  data source select
    <start table>
    0 "DAC input selected by mdac_ref_dig_force_en"
    1 "DAC input from BIST mode ramp generator"
    <end table>

</pre> */

#define TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Pos           20                                                                     /*!< Right-most bit position of mdac_ref_dig_ramp_sel in TEST.TEST_REF_DIG */
#define TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Msk           (0x00000001UL << TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Pos)        /*!< Mask for mdac_ref_dig_ramp_sel in TEST.TEST_REF_DIG */
#define TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Shift(v)      (((v) << TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Pos) & TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Msk) /*!< Shift value 'v' into mdac_ref_dig_ramp_sel and mask 'v' to fit it into mdac_ref_dig_ramp_sel field */

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__SET() sets TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL to given value.
 *
 * When writing to TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL, this is recommended to use.
 *
 * @param bf_value new value for TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL
 */
__TEST_INLINE void TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_REF_DIG__GET();
    reg = (reg & ~TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Msk);
    reg = (reg | (TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Shift((uint32_t)bf_value)));
    TEST_TEST_REF_DIG__SET(reg);
}

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__GET() gets TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL's current value.
 *
 * When reading from TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL, this is recommended to use.
 *
 * @return current value of TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__GET(void)
{
    uint32_t reg = TEST_TEST_REF_DIG__GET();
    reg = (reg & TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Msk);
    reg = (reg >> TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__MODIFY() modifies TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_REF_DIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_REF_DIG
 * @param bf_value new value for TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL
 * @return new value of TEST.TEST_REF_DIG
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Msk);
    reg = (reg | (TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__EXTRACT() extracts TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_REF_DIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_REF_DIG
 * @return current value of TEST_REF_DIG.MDAC_REF_DIG_RAMP_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Msk);
    reg = (reg >> TEST_TEST_REF_DIG__MDAC_REF_DIG_RAMP_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------- TEST.TEST_REF_DIG.REF_DIG_TARGET -------------------- */

/**
<pre>
  TEST.TEST_REF_DIG.REF_DIG_TARGET:

    Voltage DAC (VDAC, a.k.a. MDAC) DNL BIST target value.

</pre> */

#define TEST_TEST_REF_DIG__REF_DIG_TARGET__Pos                  8                                                                      /*!< Right-most bit position of ref_dig_target in TEST.TEST_REF_DIG */
#define TEST_TEST_REF_DIG__REF_DIG_TARGET__Msk                  (0x00000FFFUL << TEST_TEST_REF_DIG__REF_DIG_TARGET__Pos)               /*!< Mask for ref_dig_target in TEST.TEST_REF_DIG */
#define TEST_TEST_REF_DIG__REF_DIG_TARGET__Shift(v)             (((v) << TEST_TEST_REF_DIG__REF_DIG_TARGET__Pos) & TEST_TEST_REF_DIG__REF_DIG_TARGET__Msk) /*!< Shift value 'v' into ref_dig_target and mask 'v' to fit it into ref_dig_target field */

/** TEST_TEST_REF_DIG__REF_DIG_TARGET__SET() sets TEST_REF_DIG.REF_DIG_TARGET to given value.
 *
 * When writing to TEST_REF_DIG.REF_DIG_TARGET, this is recommended to use.
 *
 * @param bf_value new value for TEST_REF_DIG.REF_DIG_TARGET
 */
__TEST_INLINE void TEST_TEST_REF_DIG__REF_DIG_TARGET__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_REF_DIG__GET();
    reg = (reg & ~TEST_TEST_REF_DIG__REF_DIG_TARGET__Msk);
    reg = (reg | (TEST_TEST_REF_DIG__REF_DIG_TARGET__Shift((uint32_t)bf_value)));
    TEST_TEST_REF_DIG__SET(reg);
}

/** TEST_TEST_REF_DIG__REF_DIG_TARGET__GET() gets TEST_REF_DIG.REF_DIG_TARGET's current value.
 *
 * When reading from TEST_REF_DIG.REF_DIG_TARGET, this is recommended to use.
 *
 * @return current value of TEST_REF_DIG.REF_DIG_TARGET
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__REF_DIG_TARGET__GET(void)
{
    uint32_t reg = TEST_TEST_REF_DIG__GET();
    reg = (reg & TEST_TEST_REF_DIG__REF_DIG_TARGET__Msk);
    reg = (reg >> TEST_TEST_REF_DIG__REF_DIG_TARGET__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_REF_DIG__REF_DIG_TARGET__MODIFY() modifies TEST_REF_DIG.REF_DIG_TARGET.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_REF_DIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_REF_DIG
 * @param bf_value new value for TEST_REF_DIG.REF_DIG_TARGET
 * @return new value of TEST.TEST_REF_DIG
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__REF_DIG_TARGET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_REF_DIG__REF_DIG_TARGET__Msk);
    reg = (reg | (TEST_TEST_REF_DIG__REF_DIG_TARGET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_REF_DIG__REF_DIG_TARGET__EXTRACT() extracts TEST_REF_DIG.REF_DIG_TARGET.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_REF_DIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_REF_DIG
 * @return current value of TEST_REF_DIG.REF_DIG_TARGET
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__REF_DIG_TARGET__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_REF_DIG__REF_DIG_TARGET__Msk);
    reg = (reg >> TEST_TEST_REF_DIG__REF_DIG_TARGET__Pos);
    return (uint32_t)reg;
}

/* ---------------- TEST.TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN ---------------- */

/**
<pre>
  TEST.TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN:

    Voltage DAC (VDAC, a.k.a. MDAC) test mode forced input value.

</pre> */

#define TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Pos          0                                                                      /*!< Right-most bit position of mdac_ref_dig_force_din in TEST.TEST_REF_DIG */
#define TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Msk          (0x000000FFUL << TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Pos)       /*!< Mask for mdac_ref_dig_force_din in TEST.TEST_REF_DIG */
#define TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Shift(v)     (((v) << TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Pos) & TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Msk) /*!< Shift value 'v' into mdac_ref_dig_force_din and mask 'v' to fit it into mdac_ref_dig_force_din field */

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__SET() sets TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN to given value.
 *
 * When writing to TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN, this is recommended to use.
 *
 * @param bf_value new value for TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN
 */
__TEST_INLINE void TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_REF_DIG__GET();
    reg = (reg & ~TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Msk);
    reg = (reg | (TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Shift((uint32_t)bf_value)));
    TEST_TEST_REF_DIG__SET(reg);
}

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__GET() gets TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN's current value.
 *
 * When reading from TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN, this is recommended to use.
 *
 * @return current value of TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__GET(void)
{
    uint32_t reg = TEST_TEST_REF_DIG__GET();
    reg = (reg & TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Msk);
    reg = (reg >> TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__MODIFY() modifies TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_REF_DIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_REF_DIG
 * @param bf_value new value for TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN
 * @return new value of TEST.TEST_REF_DIG
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Msk);
    reg = (reg | (TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__EXTRACT() extracts TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_REF_DIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_REF_DIG
 * @return current value of TEST_REF_DIG.MDAC_REF_DIG_FORCE_DIN
 */
__TEST_INLINE uint32_t TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Msk);
    reg = (reg >> TEST_TEST_REF_DIG__MDAC_REF_DIG_FORCE_DIN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TEST_TSADC0 member of TEST_t                        */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_TSADC0__ADDRESS returns the address of member TEST_TSADC0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_TSADC0
 */
__TEST_INLINE uint32_t* __TEST_TEST_TSADC0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_TSADC0)));
}

/** TEST_TEST_TSADC0__SET() sets TEST_TSADC0 to given value.
 *
 * When writing to TEST_TSADC0, this is mandatory to use.
 *
 * @param value new value for TEST_TSADC0
 */
__TEST_INLINE void TEST_TEST_TSADC0__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_TSADC0__ADDRESS(), value);
}

/** TEST_TEST_TSADC0__GET() gets TEST_TSADC0's current value.
 *
 * When reading from TEST_TSADC0, this is mandatory to use.
 *
 * @return current value of TEST_TSADC0
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC0__GET(void)
{
    return HAL_GET32(__TEST_TEST_TSADC0__ADDRESS());
}

/* --------------- TEST.TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT --------------- */

/**
<pre>
  TEST.TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT:

    TS ADC BIST offset error limit.

</pre> */

#define TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Pos         15                                                                     /*!< Right-most bit position of ts_test_tsadc_offs_limit in TEST.TEST_TSADC0 */
#define TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Msk         (0x0000007FUL << TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Pos)      /*!< Mask for ts_test_tsadc_offs_limit in TEST.TEST_TSADC0 */
#define TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Shift(v)    (((v) << TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Pos) & TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Msk) /*!< Shift value 'v' into ts_test_tsadc_offs_limit and mask 'v' to fit it into ts_test_tsadc_offs_limit field */

/** TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__SET() sets TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT to given value.
 *
 * When writing to TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT
 */
__TEST_INLINE void TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC0__GET();
    reg = (reg & ~TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Msk);
    reg = (reg | (TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC0__SET(reg);
}

/** TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__GET() gets TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT's current value.
 *
 * When reading from TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC0__GET();
    reg = (reg & TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Msk);
    reg = (reg >> TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__MODIFY() modifies TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC0
 * @param bf_value new value for TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT
 * @return new value of TEST.TEST_TSADC0
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Msk);
    reg = (reg | (TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__EXTRACT() extracts TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC0
 * @return current value of TEST_TSADC0.TS_TEST_TSADC_OFFS_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Msk);
    reg = (reg >> TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_LIMIT__Pos);
    return (uint32_t)reg;
}

/* --------------- TEST.TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT --------------- */

/**
<pre>
  TEST.TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT:

    TS ADC BIST gain error limit.

</pre> */

#define TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Pos         8                                                                      /*!< Right-most bit position of ts_test_tsadc_gain_limit in TEST.TEST_TSADC0 */
#define TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Msk         (0x0000007FUL << TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Pos)      /*!< Mask for ts_test_tsadc_gain_limit in TEST.TEST_TSADC0 */
#define TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Shift(v)    (((v) << TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Pos) & TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Msk) /*!< Shift value 'v' into ts_test_tsadc_gain_limit and mask 'v' to fit it into ts_test_tsadc_gain_limit field */

/** TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__SET() sets TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT to given value.
 *
 * When writing to TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT
 */
__TEST_INLINE void TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC0__GET();
    reg = (reg & ~TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Msk);
    reg = (reg | (TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC0__SET(reg);
}

/** TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__GET() gets TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT's current value.
 *
 * When reading from TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC0__GET();
    reg = (reg & TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Msk);
    reg = (reg >> TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__MODIFY() modifies TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC0
 * @param bf_value new value for TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT
 * @return new value of TEST.TEST_TSADC0
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Msk);
    reg = (reg | (TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__EXTRACT() extracts TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC0
 * @return current value of TEST_TSADC0.TS_TEST_TSADC_GAIN_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Msk);
    reg = (reg >> TEST_TEST_TSADC0__TS_TEST_TSADC_GAIN_LIMIT__Pos);
    return (uint32_t)reg;
}

/* -------------- TEST.TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED -------------- */

/**
<pre>
  TEST.TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED:

    TS ADC BIST expected offset value.

</pre> */

#define TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Pos      0                                                                      /*!< Right-most bit position of ts_test_tsadc_offs_expected in TEST.TEST_TSADC0 */
#define TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Msk      (0x000000FFUL << TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Pos)   /*!< Mask for ts_test_tsadc_offs_expected in TEST.TEST_TSADC0 */
#define TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Shift(v) (((v) << TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Pos) & TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Msk) /*!< Shift value 'v' into ts_test_tsadc_offs_expected and mask 'v' to fit it into ts_test_tsadc_offs_expected field */

/** TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__SET() sets TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED to given value.
 *
 * When writing to TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED
 */
__TEST_INLINE void TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC0__GET();
    reg = (reg & ~TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC0__SET(reg);
}

/** TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__GET() gets TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED's current value.
 *
 * When reading from TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED, this is recommended to use.
 *
 * @return current value of TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC0__GET();
    reg = (reg & TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__MODIFY() modifies TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC0
 * @param bf_value new value for TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED
 * @return new value of TEST.TEST_TSADC0
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__EXTRACT() extracts TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC0
 * @return current value of TEST_TSADC0.TS_TEST_TSADC_OFFS_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_TSADC0__TS_TEST_TSADC_OFFS_EXPECTED__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TEST_TSADC1 member of TEST_t                        */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_TSADC1__ADDRESS returns the address of member TEST_TSADC1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_TSADC1
 */
__TEST_INLINE uint32_t* __TEST_TEST_TSADC1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_TSADC1)));
}

/** TEST_TEST_TSADC1__SET() sets TEST_TSADC1 to given value.
 *
 * When writing to TEST_TSADC1, this is mandatory to use.
 *
 * @param value new value for TEST_TSADC1
 */
__TEST_INLINE void TEST_TEST_TSADC1__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_TSADC1__ADDRESS(), value);
}

/** TEST_TEST_TSADC1__GET() gets TEST_TSADC1's current value.
 *
 * When reading from TEST_TSADC1, this is mandatory to use.
 *
 * @return current value of TEST_TSADC1
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__GET(void)
{
    return HAL_GET32(__TEST_TEST_TSADC1__ADDRESS());
}

/* ---------------- TEST.TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT ---------------- */

/**
<pre>
  TEST.TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT:

    TS ADC BIST DNL error limit.

</pre> */

#define TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Pos          16                                                                     /*!< Right-most bit position of ts_test_tsadc_dnl_limit in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Msk          (0x0000000FUL << TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Pos)       /*!< Mask for ts_test_tsadc_dnl_limit in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Shift(v)     (((v) << TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Pos) & TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Msk) /*!< Shift value 'v' into ts_test_tsadc_dnl_limit and mask 'v' to fit it into ts_test_tsadc_dnl_limit field */

/** TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__SET() sets TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT to given value.
 *
 * When writing to TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT
 */
__TEST_INLINE void TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC1__SET(reg);
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__GET() gets TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT's current value.
 *
 * When reading from TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__MODIFY() modifies TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT
 * @return new value of TEST.TEST_TSADC1
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__EXTRACT() extracts TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @return current value of TEST_TSADC1.TS_TEST_TSADC_DNL_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_LIMIT__Pos);
    return (uint32_t)reg;
}

/* --------------- TEST.TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT --------------- */

/**
<pre>
  TEST.TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT:

    TS Current DAC BIST DNL error limit.

</pre> */

#define TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Pos         12                                                                     /*!< Right-most bit position of ts_test_tsidac_dnl_limit in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Msk         (0x0000000FUL << TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Pos)      /*!< Mask for ts_test_tsidac_dnl_limit in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Shift(v)    (((v) << TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Pos) & TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Msk) /*!< Shift value 'v' into ts_test_tsidac_dnl_limit and mask 'v' to fit it into ts_test_tsidac_dnl_limit field */

/** TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__SET() sets TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT to given value.
 *
 * When writing to TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT
 */
__TEST_INLINE void TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC1__SET(reg);
}

/** TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__GET() gets TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT's current value.
 *
 * When reading from TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__MODIFY() modifies TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT
 * @return new value of TEST.TEST_TSADC1
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__EXTRACT() extracts TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @return current value of TEST_TSADC1.TS_TEST_TSIDAC_DNL_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_LIMIT__Pos);
    return (uint32_t)reg;
}

/* -------------- TEST.TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN -------------- */

/**
<pre>
  TEST.TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN:

    TS ADC Offset BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Pos       9                                                                      /*!< Right-most bit position of ts_test_tsadc_offs_avg_len in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Msk       (0x00000007UL << TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Pos)    /*!< Mask for ts_test_tsadc_offs_avg_len in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Shift(v)  (((v) << TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Pos) & TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Msk) /*!< Shift value 'v' into ts_test_tsadc_offs_avg_len and mask 'v' to fit it into ts_test_tsadc_offs_avg_len field */

/** TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__SET() sets TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN to given value.
 *
 * When writing to TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC1__SET(reg);
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__GET() gets TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN's current value.
 *
 * When reading from TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__MODIFY() modifies TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN
 * @return new value of TEST.TEST_TSADC1
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__EXTRACT() extracts TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @return current value of TEST_TSADC1.TS_TEST_TSADC_OFFS_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSADC_OFFS_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* -------------- TEST.TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN -------------- */

/**
<pre>
  TEST.TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN:

    TS Current DAC DNL BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Pos       6                                                                      /*!< Right-most bit position of ts_test_tsidac_dnl_avg_len in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Msk       (0x00000007UL << TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Pos)    /*!< Mask for ts_test_tsidac_dnl_avg_len in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Shift(v)  (((v) << TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Pos) & TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Msk) /*!< Shift value 'v' into ts_test_tsidac_dnl_avg_len and mask 'v' to fit it into ts_test_tsidac_dnl_avg_len field */

/** TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__SET() sets TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN to given value.
 *
 * When writing to TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC1__SET(reg);
}

/** TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__GET() gets TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN's current value.
 *
 * When reading from TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__MODIFY() modifies TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN
 * @return new value of TEST.TEST_TSADC1
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__EXTRACT() extracts TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @return current value of TEST_TSADC1.TS_TEST_TSIDAC_DNL_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSIDAC_DNL_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* -------------- TEST.TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN -------------- */

/**
<pre>
  TEST.TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN:

    TS ADC Gain BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Pos       3                                                                      /*!< Right-most bit position of ts_test_tsadc_gain_avg_len in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Msk       (0x00000007UL << TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Pos)    /*!< Mask for ts_test_tsadc_gain_avg_len in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Shift(v)  (((v) << TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Pos) & TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Msk) /*!< Shift value 'v' into ts_test_tsadc_gain_avg_len and mask 'v' to fit it into ts_test_tsadc_gain_avg_len field */

/** TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__SET() sets TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN to given value.
 *
 * When writing to TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC1__SET(reg);
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__GET() gets TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN's current value.
 *
 * When reading from TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__MODIFY() modifies TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN
 * @return new value of TEST.TEST_TSADC1
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__EXTRACT() extracts TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @return current value of TEST_TSADC1.TS_TEST_TSADC_GAIN_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSADC_GAIN_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* --------------- TEST.TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN --------------- */

/**
<pre>
  TEST.TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN:

    TS ADC DNL BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Pos        0                                                                      /*!< Right-most bit position of ts_test_tsadc_dnl_avg_len in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Msk        (0x00000007UL << TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Pos)     /*!< Mask for ts_test_tsadc_dnl_avg_len in TEST.TEST_TSADC1 */
#define TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Shift(v)   (((v) << TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Pos) & TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Msk) /*!< Shift value 'v' into ts_test_tsadc_dnl_avg_len and mask 'v' to fit it into ts_test_tsadc_dnl_avg_len field */

/** TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__SET() sets TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN to given value.
 *
 * When writing to TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC1__SET(reg);
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__GET() gets TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN's current value.
 *
 * When reading from TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC1__GET();
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__MODIFY() modifies TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @param bf_value new value for TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN
 * @return new value of TEST.TEST_TSADC1
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__EXTRACT() extracts TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC1
 * @return current value of TEST_TSADC1.TS_TEST_TSADC_DNL_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_TSADC1__TS_TEST_TSADC_DNL_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TEST_TSADC2 member of TEST_t                        */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_TSADC2__ADDRESS returns the address of member TEST_TSADC2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_TSADC2
 */
__TEST_INLINE uint32_t* __TEST_TEST_TSADC2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_TSADC2)));
}

/** TEST_TEST_TSADC2__SET() sets TEST_TSADC2 to given value.
 *
 * When writing to TEST_TSADC2, this is mandatory to use.
 *
 * @param value new value for TEST_TSADC2
 */
__TEST_INLINE void TEST_TEST_TSADC2__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_TSADC2__ADDRESS(), value);
}

/** TEST_TEST_TSADC2__GET() gets TEST_TSADC2's current value.
 *
 * When reading from TEST_TSADC2, this is mandatory to use.
 *
 * @return current value of TEST_TSADC2
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__GET(void)
{
    return HAL_GET32(__TEST_TEST_TSADC2__ADDRESS());
}

/* -------------- TEST.TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED -------------- */

/**
<pre>
  TEST.TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED:

    TS ADC Gain BIST expected value.

</pre> */

#define TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Pos      20                                                                     /*!< Right-most bit position of ts_test_tsadc_gain_expected in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Msk      (0x000000FFUL << TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Pos)   /*!< Mask for ts_test_tsadc_gain_expected in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Shift(v) (((v) << TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Pos) & TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Msk) /*!< Shift value 'v' into ts_test_tsadc_gain_expected and mask 'v' to fit it into ts_test_tsadc_gain_expected field */

/** TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__SET() sets TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED to given value.
 *
 * When writing to TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED
 */
__TEST_INLINE void TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC2__SET(reg);
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__GET() gets TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED's current value.
 *
 * When reading from TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED, this is recommended to use.
 *
 * @return current value of TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__MODIFY() modifies TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @param bf_value new value for TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED
 * @return new value of TEST.TEST_TSADC2
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__EXTRACT() extracts TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @return current value of TEST_TSADC2.TS_TEST_TSADC_GAIN_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_TSADC_GAIN_EXPECTED__Pos);
    return (uint32_t)reg;
}

/* ---------------- TEST.TEST_TSADC2.TS_TEST_TSADC_DNL_MASK ---------------- */

/**
<pre>
  TEST.TEST_TSADC2.TS_TEST_TSADC_DNL_MASK:

    Individual mask bit for vs_dac = 64, 48, 32, 16, 8, 4, 2, 1 during DNL measurement

</pre> */

#define TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Pos           12                                                                     /*!< Right-most bit position of ts_test_tsadc_dnl_mask in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Msk           (0x000000FFUL << TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Pos)        /*!< Mask for ts_test_tsadc_dnl_mask in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Shift(v)      (((v) << TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Pos) & TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Msk) /*!< Shift value 'v' into ts_test_tsadc_dnl_mask and mask 'v' to fit it into ts_test_tsadc_dnl_mask field */

/** TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__SET() sets TEST_TSADC2.TS_TEST_TSADC_DNL_MASK to given value.
 *
 * When writing to TEST_TSADC2.TS_TEST_TSADC_DNL_MASK, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC2.TS_TEST_TSADC_DNL_MASK
 */
__TEST_INLINE void TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC2__SET(reg);
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__GET() gets TEST_TSADC2.TS_TEST_TSADC_DNL_MASK's current value.
 *
 * When reading from TEST_TSADC2.TS_TEST_TSADC_DNL_MASK, this is recommended to use.
 *
 * @return current value of TEST_TSADC2.TS_TEST_TSADC_DNL_MASK
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__MODIFY() modifies TEST_TSADC2.TS_TEST_TSADC_DNL_MASK.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @param bf_value new value for TEST_TSADC2.TS_TEST_TSADC_DNL_MASK
 * @return new value of TEST.TEST_TSADC2
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__EXTRACT() extracts TEST_TSADC2.TS_TEST_TSADC_DNL_MASK.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @return current value of TEST_TSADC2.TS_TEST_TSADC_DNL_MASK
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_TSADC_DNL_MASK__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_TSADC2.TS_TEST_TSADC_EN ------------------- */

/**
<pre>
  TEST.TEST_TSADC2.TS_TEST_TSADC_EN:

    Not used

</pre> */

#define TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Pos                 11                                                                     /*!< Right-most bit position of ts_test_tsadc_en in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Msk                 (0x00000001UL << TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Pos)              /*!< Mask for ts_test_tsadc_en in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Shift(v)            (((v) << TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Pos) & TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Msk) /*!< Shift value 'v' into ts_test_tsadc_en and mask 'v' to fit it into ts_test_tsadc_en field */

/** TEST_TEST_TSADC2__TS_TEST_TSADC_EN__SET() sets TEST_TSADC2.TS_TEST_TSADC_EN to given value.
 *
 * When writing to TEST_TSADC2.TS_TEST_TSADC_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC2.TS_TEST_TSADC_EN
 */
__TEST_INLINE void TEST_TEST_TSADC2__TS_TEST_TSADC_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC2__SET(reg);
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_EN__GET() gets TEST_TSADC2.TS_TEST_TSADC_EN's current value.
 *
 * When reading from TEST_TSADC2.TS_TEST_TSADC_EN, this is recommended to use.
 *
 * @return current value of TEST_TSADC2.TS_TEST_TSADC_EN
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_EN__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_EN__MODIFY() modifies TEST_TSADC2.TS_TEST_TSADC_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @param bf_value new value for TEST_TSADC2.TS_TEST_TSADC_EN
 * @return new value of TEST.TEST_TSADC2
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_EN__EXTRACT() extracts TEST_TSADC2.TS_TEST_TSADC_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @return current value of TEST_TSADC2.TS_TEST_TSADC_EN
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_TSADC_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_TSADC2.TS_TEST_P1P2_SEL ------------------- */

/**
<pre>
  TEST.TEST_TSADC2.TS_TEST_P1P2_SEL:

    TS ADC gain calibration testpoint select.
    <start table>
    0 P1
    1 P2
    <end table>

</pre> */

#define TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Pos                 10                                                                     /*!< Right-most bit position of ts_test_p1p2_sel in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Msk                 (0x00000001UL << TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Pos)              /*!< Mask for ts_test_p1p2_sel in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Shift(v)            (((v) << TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Pos) & TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Msk) /*!< Shift value 'v' into ts_test_p1p2_sel and mask 'v' to fit it into ts_test_p1p2_sel field */

/** TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__SET() sets TEST_TSADC2.TS_TEST_P1P2_SEL to given value.
 *
 * When writing to TEST_TSADC2.TS_TEST_P1P2_SEL, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC2.TS_TEST_P1P2_SEL
 */
__TEST_INLINE void TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC2__SET(reg);
}

/** TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__GET() gets TEST_TSADC2.TS_TEST_P1P2_SEL's current value.
 *
 * When reading from TEST_TSADC2.TS_TEST_P1P2_SEL, this is recommended to use.
 *
 * @return current value of TEST_TSADC2.TS_TEST_P1P2_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__MODIFY() modifies TEST_TSADC2.TS_TEST_P1P2_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @param bf_value new value for TEST_TSADC2.TS_TEST_P1P2_SEL
 * @return new value of TEST.TEST_TSADC2
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__EXTRACT() extracts TEST_TSADC2.TS_TEST_P1P2_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @return current value of TEST_TSADC2.TS_TEST_P1P2_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_P1P2_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- TEST.TEST_TSADC2.TS_TEST_MODE --------------------- */

/**
<pre>
  TEST.TEST_TSADC2.TS_TEST_MODE:

    TS ADC / IDAC test mode control
    <start table_with_header>
    [4:0] "Test / BIST Mode"
    0 "Normal Operation"
    1 "DNL Measurement and Offset Compensation"
    2 "DNL Measurement and Offset Compensation (Single Step)"
    3 "Gain Calibration"
    4 "Gain Calibration Re-Measurement"
    5 "Offset Calibration 1X"
    6 "Offset Calibration 1X Re-Measurement"
    7 "Open"
    8 "Open"
    9 "Connectivity Test"
    10 "IDAC DNL Measurement"
    11 "IDAC DNL Measurement (Single Step)"
    12-31 "Reserved"
    <end table>

</pre> */

#define TEST_TEST_TSADC2__TS_TEST_MODE__Pos                     5                                                                      /*!< Right-most bit position of ts_test_mode in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_MODE__Msk                     (0x0000001FUL << TEST_TEST_TSADC2__TS_TEST_MODE__Pos)                  /*!< Mask for ts_test_mode in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_MODE__Shift(v)                (((v) << TEST_TEST_TSADC2__TS_TEST_MODE__Pos) & TEST_TEST_TSADC2__TS_TEST_MODE__Msk) /*!< Shift value 'v' into ts_test_mode and mask 'v' to fit it into ts_test_mode field */

/** TEST_TEST_TSADC2__TS_TEST_MODE__SET() sets TEST_TSADC2.TS_TEST_MODE to given value.
 *
 * When writing to TEST_TSADC2.TS_TEST_MODE, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC2.TS_TEST_MODE
 */
__TEST_INLINE void TEST_TEST_TSADC2__TS_TEST_MODE__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_MODE__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_MODE__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC2__SET(reg);
}

/** TEST_TEST_TSADC2__TS_TEST_MODE__GET() gets TEST_TSADC2.TS_TEST_MODE's current value.
 *
 * When reading from TEST_TSADC2.TS_TEST_MODE, this is recommended to use.
 *
 * @return current value of TEST_TSADC2.TS_TEST_MODE
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_MODE__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_MODE__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_MODE__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC2__TS_TEST_MODE__MODIFY() modifies TEST_TSADC2.TS_TEST_MODE.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @param bf_value new value for TEST_TSADC2.TS_TEST_MODE
 * @return new value of TEST.TEST_TSADC2
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_MODE__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC2__TS_TEST_MODE__EXTRACT() extracts TEST_TSADC2.TS_TEST_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @return current value of TEST_TSADC2.TS_TEST_MODE
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_MODE__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_MODE__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_TSADC2.TS_TSADC_MEAS_SEL ------------------- */

/**
<pre>
  TEST.TEST_TSADC2.TS_TSADC_MEAS_SEL:

    Not used

</pre> */

#define TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Pos                1                                                                      /*!< Right-most bit position of ts_tsadc_meas_sel in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Msk                (0x0000000FUL << TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Pos)             /*!< Mask for ts_tsadc_meas_sel in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Shift(v)           (((v) << TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Pos) & TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Msk) /*!< Shift value 'v' into ts_tsadc_meas_sel and mask 'v' to fit it into ts_tsadc_meas_sel field */

/** TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__SET() sets TEST_TSADC2.TS_TSADC_MEAS_SEL to given value.
 *
 * When writing to TEST_TSADC2.TS_TSADC_MEAS_SEL, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC2.TS_TSADC_MEAS_SEL
 */
__TEST_INLINE void TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & ~TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC2__SET(reg);
}

/** TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__GET() gets TEST_TSADC2.TS_TSADC_MEAS_SEL's current value.
 *
 * When reading from TEST_TSADC2.TS_TSADC_MEAS_SEL, this is recommended to use.
 *
 * @return current value of TEST_TSADC2.TS_TSADC_MEAS_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__MODIFY() modifies TEST_TSADC2.TS_TSADC_MEAS_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @param bf_value new value for TEST_TSADC2.TS_TSADC_MEAS_SEL
 * @return new value of TEST.TEST_TSADC2
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__EXTRACT() extracts TEST_TSADC2.TS_TSADC_MEAS_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @return current value of TEST_TSADC2.TS_TSADC_MEAS_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TSADC_MEAS_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_TSADC2.TS_TEST_TSADC_AZ ------------------- */

/**
<pre>
  TEST.TEST_TSADC2.TS_TEST_TSADC_AZ:

    TS ADC input short control for DNL and offset BIST.
    <start table>
    0 "TS ADC input unshorted"
    1 "TS ADC input shorted internally"
    <end table>

</pre> */

#define TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Pos                 0                                                                      /*!< Right-most bit position of ts_test_tsadc_az in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Msk                 (0x00000001UL << TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Pos)              /*!< Mask for ts_test_tsadc_az in TEST.TEST_TSADC2 */
#define TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Shift(v)            (((v) << TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Pos) & TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Msk) /*!< Shift value 'v' into ts_test_tsadc_az and mask 'v' to fit it into ts_test_tsadc_az field */

/** TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__SET() sets TEST_TSADC2.TS_TEST_TSADC_AZ to given value.
 *
 * When writing to TEST_TSADC2.TS_TEST_TSADC_AZ, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSADC2.TS_TEST_TSADC_AZ
 */
__TEST_INLINE void TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Shift((uint32_t)bf_value)));
    TEST_TEST_TSADC2__SET(reg);
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__GET() gets TEST_TSADC2.TS_TEST_TSADC_AZ's current value.
 *
 * When reading from TEST_TSADC2.TS_TEST_TSADC_AZ, this is recommended to use.
 *
 * @return current value of TEST_TSADC2.TS_TEST_TSADC_AZ
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__GET(void)
{
    uint32_t reg = TEST_TEST_TSADC2__GET();
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__MODIFY() modifies TEST_TSADC2.TS_TEST_TSADC_AZ.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSADC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @param bf_value new value for TEST_TSADC2.TS_TEST_TSADC_AZ
 * @return new value of TEST.TEST_TSADC2
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Msk);
    reg = (reg | (TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__EXTRACT() extracts TEST_TSADC2.TS_TEST_TSADC_AZ.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSADC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSADC2
 * @return current value of TEST_TSADC2.TS_TEST_TSADC_AZ
 */
__TEST_INLINE uint32_t TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Msk);
    reg = (reg >> TEST_TEST_TSADC2__TS_TEST_TSADC_AZ__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TEST_TSIDAC member of TEST_t                        */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_TSIDAC__ADDRESS returns the address of member TEST_TSIDAC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_TSIDAC
 */
__TEST_INLINE uint32_t* __TEST_TEST_TSIDAC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_TSIDAC)));
}

/** TEST_TEST_TSIDAC__SET() sets TEST_TSIDAC to given value.
 *
 * When writing to TEST_TSIDAC, this is mandatory to use.
 *
 * @param value new value for TEST_TSIDAC
 */
__TEST_INLINE void TEST_TEST_TSIDAC__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_TSIDAC__ADDRESS(), value);
}

/** TEST_TEST_TSIDAC__GET() gets TEST_TSIDAC's current value.
 *
 * When reading from TEST_TSIDAC, this is mandatory to use.
 *
 * @return current value of TEST_TSIDAC
 */
__TEST_INLINE uint32_t TEST_TEST_TSIDAC__GET(void)
{
    return HAL_GET32(__TEST_TEST_TSIDAC__ADDRESS());
}

/* ------------------- TEST.TEST_TSIDAC.TS_TEST_TSIDAC_EN ------------------- */

/**
<pre>
  TEST.TEST_TSIDAC.TS_TEST_TSIDAC_EN:

    TS Current DAC BIST enable
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Pos                0                                                                      /*!< Right-most bit position of ts_test_tsidac_en in TEST.TEST_TSIDAC */
#define TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Msk                (0x00000001UL << TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Pos)             /*!< Mask for ts_test_tsidac_en in TEST.TEST_TSIDAC */
#define TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Shift(v)           (((v) << TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Pos) & TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Msk) /*!< Shift value 'v' into ts_test_tsidac_en and mask 'v' to fit it into ts_test_tsidac_en field */

/** TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__SET() sets TEST_TSIDAC.TS_TEST_TSIDAC_EN to given value.
 *
 * When writing to TEST_TSIDAC.TS_TEST_TSIDAC_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_TSIDAC.TS_TEST_TSIDAC_EN
 */
__TEST_INLINE void TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_TSIDAC__GET();
    reg = (reg & ~TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Msk);
    reg = (reg | (TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_TSIDAC__SET(reg);
}

/** TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__GET() gets TEST_TSIDAC.TS_TEST_TSIDAC_EN's current value.
 *
 * When reading from TEST_TSIDAC.TS_TEST_TSIDAC_EN, this is recommended to use.
 *
 * @return current value of TEST_TSIDAC.TS_TEST_TSIDAC_EN
 */
__TEST_INLINE uint32_t TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__GET(void)
{
    uint32_t reg = TEST_TEST_TSIDAC__GET();
    reg = (reg & TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Msk);
    reg = (reg >> TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__MODIFY() modifies TEST_TSIDAC.TS_TEST_TSIDAC_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_TSIDAC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_TSIDAC
 * @param bf_value new value for TEST_TSIDAC.TS_TEST_TSIDAC_EN
 * @return new value of TEST.TEST_TSIDAC
 */
__TEST_INLINE uint32_t TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Msk);
    reg = (reg | (TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__EXTRACT() extracts TEST_TSIDAC.TS_TEST_TSIDAC_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_TSIDAC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_TSIDAC
 * @return current value of TEST_TSIDAC.TS_TEST_TSIDAC_EN
 */
__TEST_INLINE uint32_t TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Msk);
    reg = (reg >> TEST_TEST_TSIDAC__TS_TEST_TSIDAC_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TEST_IS0 member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_IS0__ADDRESS returns the address of member TEST_IS0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_IS0
 */
__TEST_INLINE uint32_t* __TEST_TEST_IS0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_IS0)));
}

/** TEST_TEST_IS0__SET() sets TEST_IS0 to given value.
 *
 * When writing to TEST_IS0, this is mandatory to use.
 *
 * @param value new value for TEST_IS0
 */
__TEST_INLINE void TEST_TEST_IS0__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_IS0__ADDRESS(), value);
}

/** TEST_TEST_IS0__GET() gets TEST_IS0's current value.
 *
 * When reading from TEST_IS0, this is mandatory to use.
 *
 * @return current value of TEST_IS0
 */
__TEST_INLINE uint32_t TEST_TEST_IS0__GET(void)
{
    return HAL_GET32(__TEST_TEST_IS0__ADDRESS());
}

/* -------------------- TEST.TEST_IS0.IS_TEST_OFFS_LIMIT -------------------- */

/**
<pre>
  TEST.TEST_IS0.IS_TEST_OFFS_LIMIT:

    IS ADC BIST offset error limit.

</pre> */

#define TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Pos                  15                                                                     /*!< Right-most bit position of is_test_offs_limit in TEST.TEST_IS0 */
#define TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Msk                  (0x0000003FUL << TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Pos)               /*!< Mask for is_test_offs_limit in TEST.TEST_IS0 */
#define TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Shift(v)             (((v) << TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Pos) & TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Msk) /*!< Shift value 'v' into is_test_offs_limit and mask 'v' to fit it into is_test_offs_limit field */

/** TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__SET() sets TEST_IS0.IS_TEST_OFFS_LIMIT to given value.
 *
 * When writing to TEST_IS0.IS_TEST_OFFS_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS0.IS_TEST_OFFS_LIMIT
 */
__TEST_INLINE void TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS0__GET();
    reg = (reg & ~TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Msk);
    reg = (reg | (TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_IS0__SET(reg);
}

/** TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__GET() gets TEST_IS0.IS_TEST_OFFS_LIMIT's current value.
 *
 * When reading from TEST_IS0.IS_TEST_OFFS_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_IS0.IS_TEST_OFFS_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_IS0__GET();
    reg = (reg & TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Msk);
    reg = (reg >> TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__MODIFY() modifies TEST_IS0.IS_TEST_OFFS_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS0
 * @param bf_value new value for TEST_IS0.IS_TEST_OFFS_LIMIT
 * @return new value of TEST.TEST_IS0
 */
__TEST_INLINE uint32_t TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Msk);
    reg = (reg | (TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__EXTRACT() extracts TEST_IS0.IS_TEST_OFFS_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS0
 * @return current value of TEST_IS0.IS_TEST_OFFS_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Msk);
    reg = (reg >> TEST_TEST_IS0__IS_TEST_OFFS_LIMIT__Pos);
    return (uint32_t)reg;
}

/* -------------------- TEST.TEST_IS0.IS_TEST_GAIN_LIMIT -------------------- */

/**
<pre>
  TEST.TEST_IS0.IS_TEST_GAIN_LIMIT:

    IS ADC BIST gain error limit.

</pre> */

#define TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Pos                  8                                                                      /*!< Right-most bit position of is_test_gain_limit in TEST.TEST_IS0 */
#define TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Msk                  (0x0000007FUL << TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Pos)               /*!< Mask for is_test_gain_limit in TEST.TEST_IS0 */
#define TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Shift(v)             (((v) << TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Pos) & TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Msk) /*!< Shift value 'v' into is_test_gain_limit and mask 'v' to fit it into is_test_gain_limit field */

/** TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__SET() sets TEST_IS0.IS_TEST_GAIN_LIMIT to given value.
 *
 * When writing to TEST_IS0.IS_TEST_GAIN_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS0.IS_TEST_GAIN_LIMIT
 */
__TEST_INLINE void TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS0__GET();
    reg = (reg & ~TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Msk);
    reg = (reg | (TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_IS0__SET(reg);
}

/** TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__GET() gets TEST_IS0.IS_TEST_GAIN_LIMIT's current value.
 *
 * When reading from TEST_IS0.IS_TEST_GAIN_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_IS0.IS_TEST_GAIN_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_IS0__GET();
    reg = (reg & TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Msk);
    reg = (reg >> TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__MODIFY() modifies TEST_IS0.IS_TEST_GAIN_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS0
 * @param bf_value new value for TEST_IS0.IS_TEST_GAIN_LIMIT
 * @return new value of TEST.TEST_IS0
 */
__TEST_INLINE uint32_t TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Msk);
    reg = (reg | (TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__EXTRACT() extracts TEST_IS0.IS_TEST_GAIN_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS0
 * @return current value of TEST_IS0.IS_TEST_GAIN_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Msk);
    reg = (reg >> TEST_TEST_IS0__IS_TEST_GAIN_LIMIT__Pos);
    return (uint32_t)reg;
}

/* ------------------ TEST.TEST_IS0.IS_TEST_OFFS_EXPECTED ------------------ */

/**
<pre>
  TEST.TEST_IS0.IS_TEST_OFFS_EXPECTED:

    IS ADC Offset BIST expected value.

</pre> */

#define TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Pos               0                                                                      /*!< Right-most bit position of is_test_offs_expected in TEST.TEST_IS0 */
#define TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Msk               (0x000000FFUL << TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Pos)            /*!< Mask for is_test_offs_expected in TEST.TEST_IS0 */
#define TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Shift(v)          (((v) << TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Pos) & TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Msk) /*!< Shift value 'v' into is_test_offs_expected and mask 'v' to fit it into is_test_offs_expected field */

/** TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__SET() sets TEST_IS0.IS_TEST_OFFS_EXPECTED to given value.
 *
 * When writing to TEST_IS0.IS_TEST_OFFS_EXPECTED, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS0.IS_TEST_OFFS_EXPECTED
 */
__TEST_INLINE void TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS0__GET();
    reg = (reg & ~TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Shift((uint32_t)bf_value)));
    TEST_TEST_IS0__SET(reg);
}

/** TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__GET() gets TEST_IS0.IS_TEST_OFFS_EXPECTED's current value.
 *
 * When reading from TEST_IS0.IS_TEST_OFFS_EXPECTED, this is recommended to use.
 *
 * @return current value of TEST_IS0.IS_TEST_OFFS_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__GET(void)
{
    uint32_t reg = TEST_TEST_IS0__GET();
    reg = (reg & TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__MODIFY() modifies TEST_IS0.IS_TEST_OFFS_EXPECTED.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS0
 * @param bf_value new value for TEST_IS0.IS_TEST_OFFS_EXPECTED
 * @return new value of TEST.TEST_IS0
 */
__TEST_INLINE uint32_t TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__EXTRACT() extracts TEST_IS0.IS_TEST_OFFS_EXPECTED.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS0
 * @return current value of TEST_IS0.IS_TEST_OFFS_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_IS0__IS_TEST_OFFS_EXPECTED__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TEST_IS1 member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_IS1__ADDRESS returns the address of member TEST_IS1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_IS1
 */
__TEST_INLINE uint32_t* __TEST_TEST_IS1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_IS1)));
}

/** TEST_TEST_IS1__SET() sets TEST_IS1 to given value.
 *
 * When writing to TEST_IS1, this is mandatory to use.
 *
 * @param value new value for TEST_IS1
 */
__TEST_INLINE void TEST_TEST_IS1__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_IS1__ADDRESS(), value);
}

/** TEST_TEST_IS1__GET() gets TEST_IS1's current value.
 *
 * When reading from TEST_IS1, this is mandatory to use.
 *
 * @return current value of TEST_IS1
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__GET(void)
{
    return HAL_GET32(__TEST_TEST_IS1__ADDRESS());
}

/* ------------------ TEST.TEST_IS1.IS_TEST_COMP_EXPECTED ------------------ */

/**
<pre>
  TEST.TEST_IS1.IS_TEST_COMP_EXPECTED:

    IS ADC Comparator BIST expected value.

</pre> */

#define TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Pos               16                                                                     /*!< Right-most bit position of is_test_comp_expected in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Msk               (0x0000001FUL << TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Pos)            /*!< Mask for is_test_comp_expected in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Shift(v)          (((v) << TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Pos) & TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Msk) /*!< Shift value 'v' into is_test_comp_expected and mask 'v' to fit it into is_test_comp_expected field */

/** TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__SET() sets TEST_IS1.IS_TEST_COMP_EXPECTED to given value.
 *
 * When writing to TEST_IS1.IS_TEST_COMP_EXPECTED, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS1.IS_TEST_COMP_EXPECTED
 */
__TEST_INLINE void TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Shift((uint32_t)bf_value)));
    TEST_TEST_IS1__SET(reg);
}

/** TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__GET() gets TEST_IS1.IS_TEST_COMP_EXPECTED's current value.
 *
 * When reading from TEST_IS1.IS_TEST_COMP_EXPECTED, this is recommended to use.
 *
 * @return current value of TEST_IS1.IS_TEST_COMP_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__GET(void)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__MODIFY() modifies TEST_IS1.IS_TEST_COMP_EXPECTED.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS1
 * @param bf_value new value for TEST_IS1.IS_TEST_COMP_EXPECTED
 * @return new value of TEST.TEST_IS1
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__EXTRACT() extracts TEST_IS1.IS_TEST_COMP_EXPECTED.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS1
 * @return current value of TEST_IS1.IS_TEST_COMP_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_COMP_EXPECTED__Pos);
    return (uint32_t)reg;
}

/* -------------------- TEST.TEST_IS1.IS_TEST_COMP_LIMIT -------------------- */

/**
<pre>
  TEST.TEST_IS1.IS_TEST_COMP_LIMIT:

    IS ADC Comparator BIST error limit.

</pre> */

#define TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Pos                  12                                                                     /*!< Right-most bit position of is_test_comp_limit in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Msk                  (0x0000000FUL << TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Pos)               /*!< Mask for is_test_comp_limit in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Shift(v)             (((v) << TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Pos) & TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Msk) /*!< Shift value 'v' into is_test_comp_limit and mask 'v' to fit it into is_test_comp_limit field */

/** TEST_TEST_IS1__IS_TEST_COMP_LIMIT__SET() sets TEST_IS1.IS_TEST_COMP_LIMIT to given value.
 *
 * When writing to TEST_IS1.IS_TEST_COMP_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS1.IS_TEST_COMP_LIMIT
 */
__TEST_INLINE void TEST_TEST_IS1__IS_TEST_COMP_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_IS1__SET(reg);
}

/** TEST_TEST_IS1__IS_TEST_COMP_LIMIT__GET() gets TEST_IS1.IS_TEST_COMP_LIMIT's current value.
 *
 * When reading from TEST_IS1.IS_TEST_COMP_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_IS1.IS_TEST_COMP_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_COMP_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS1__IS_TEST_COMP_LIMIT__MODIFY() modifies TEST_IS1.IS_TEST_COMP_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS1
 * @param bf_value new value for TEST_IS1.IS_TEST_COMP_LIMIT
 * @return new value of TEST.TEST_IS1
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_COMP_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS1__IS_TEST_COMP_LIMIT__EXTRACT() extracts TEST_IS1.IS_TEST_COMP_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS1
 * @return current value of TEST_IS1.IS_TEST_COMP_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_COMP_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_COMP_LIMIT__Pos);
    return (uint32_t)reg;
}

/* -------------------- TEST.TEST_IS1.IS_TEST_DNL_LIMIT -------------------- */

/**
<pre>
  TEST.TEST_IS1.IS_TEST_DNL_LIMIT:

    IS ADC BIST DNL error limit.

</pre> */

#define TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Pos                   9                                                                      /*!< Right-most bit position of is_test_dnl_limit in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Msk                   (0x00000007UL << TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Pos)                /*!< Mask for is_test_dnl_limit in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Shift(v)              (((v) << TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Pos) & TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Msk) /*!< Shift value 'v' into is_test_dnl_limit and mask 'v' to fit it into is_test_dnl_limit field */

/** TEST_TEST_IS1__IS_TEST_DNL_LIMIT__SET() sets TEST_IS1.IS_TEST_DNL_LIMIT to given value.
 *
 * When writing to TEST_IS1.IS_TEST_DNL_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS1.IS_TEST_DNL_LIMIT
 */
__TEST_INLINE void TEST_TEST_IS1__IS_TEST_DNL_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_IS1__SET(reg);
}

/** TEST_TEST_IS1__IS_TEST_DNL_LIMIT__GET() gets TEST_IS1.IS_TEST_DNL_LIMIT's current value.
 *
 * When reading from TEST_IS1.IS_TEST_DNL_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_IS1.IS_TEST_DNL_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_DNL_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS1__IS_TEST_DNL_LIMIT__MODIFY() modifies TEST_IS1.IS_TEST_DNL_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS1
 * @param bf_value new value for TEST_IS1.IS_TEST_DNL_LIMIT
 * @return new value of TEST.TEST_IS1
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_DNL_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS1__IS_TEST_DNL_LIMIT__EXTRACT() extracts TEST_IS1.IS_TEST_DNL_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS1
 * @return current value of TEST_IS1.IS_TEST_DNL_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_DNL_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_DNL_LIMIT__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_IS1.IS_TEST_OFFS_AVG_LEN ------------------- */

/**
<pre>
  TEST.TEST_IS1.IS_TEST_OFFS_AVG_LEN:

    IS ADC Offset BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Pos                6                                                                      /*!< Right-most bit position of is_test_offs_avg_len in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Msk                (0x00000007UL << TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Pos)             /*!< Mask for is_test_offs_avg_len in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Shift(v)           (((v) << TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Pos) & TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Msk) /*!< Shift value 'v' into is_test_offs_avg_len and mask 'v' to fit it into is_test_offs_avg_len field */

/** TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__SET() sets TEST_IS1.IS_TEST_OFFS_AVG_LEN to given value.
 *
 * When writing to TEST_IS1.IS_TEST_OFFS_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS1.IS_TEST_OFFS_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_IS1__SET(reg);
}

/** TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__GET() gets TEST_IS1.IS_TEST_OFFS_AVG_LEN's current value.
 *
 * When reading from TEST_IS1.IS_TEST_OFFS_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_IS1.IS_TEST_OFFS_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__MODIFY() modifies TEST_IS1.IS_TEST_OFFS_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS1
 * @param bf_value new value for TEST_IS1.IS_TEST_OFFS_AVG_LEN
 * @return new value of TEST.TEST_IS1
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__EXTRACT() extracts TEST_IS1.IS_TEST_OFFS_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS1
 * @return current value of TEST_IS1.IS_TEST_OFFS_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_OFFS_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_IS1.IS_TEST_DNL_AVG_LEN ------------------- */

/**
<pre>
  TEST.TEST_IS1.IS_TEST_DNL_AVG_LEN:

    IS ADC DNL BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Pos                 3                                                                      /*!< Right-most bit position of is_test_dnl_avg_len in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Msk                 (0x00000007UL << TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Pos)              /*!< Mask for is_test_dnl_avg_len in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Shift(v)            (((v) << TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Pos) & TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Msk) /*!< Shift value 'v' into is_test_dnl_avg_len and mask 'v' to fit it into is_test_dnl_avg_len field */

/** TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__SET() sets TEST_IS1.IS_TEST_DNL_AVG_LEN to given value.
 *
 * When writing to TEST_IS1.IS_TEST_DNL_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS1.IS_TEST_DNL_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_IS1__SET(reg);
}

/** TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__GET() gets TEST_IS1.IS_TEST_DNL_AVG_LEN's current value.
 *
 * When reading from TEST_IS1.IS_TEST_DNL_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_IS1.IS_TEST_DNL_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__MODIFY() modifies TEST_IS1.IS_TEST_DNL_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS1
 * @param bf_value new value for TEST_IS1.IS_TEST_DNL_AVG_LEN
 * @return new value of TEST.TEST_IS1
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__EXTRACT() extracts TEST_IS1.IS_TEST_DNL_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS1
 * @return current value of TEST_IS1.IS_TEST_DNL_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_DNL_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_IS1.IS_TEST_GAIN_AVG_LEN ------------------- */

/**
<pre>
  TEST.TEST_IS1.IS_TEST_GAIN_AVG_LEN:

    IS ADC Gain BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Pos                0                                                                      /*!< Right-most bit position of is_test_gain_avg_len in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Msk                (0x00000007UL << TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Pos)             /*!< Mask for is_test_gain_avg_len in TEST.TEST_IS1 */
#define TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Shift(v)           (((v) << TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Pos) & TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Msk) /*!< Shift value 'v' into is_test_gain_avg_len and mask 'v' to fit it into is_test_gain_avg_len field */

/** TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__SET() sets TEST_IS1.IS_TEST_GAIN_AVG_LEN to given value.
 *
 * When writing to TEST_IS1.IS_TEST_GAIN_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS1.IS_TEST_GAIN_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_IS1__SET(reg);
}

/** TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__GET() gets TEST_IS1.IS_TEST_GAIN_AVG_LEN's current value.
 *
 * When reading from TEST_IS1.IS_TEST_GAIN_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_IS1.IS_TEST_GAIN_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_IS1__GET();
    reg = (reg & TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__MODIFY() modifies TEST_IS1.IS_TEST_GAIN_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS1
 * @param bf_value new value for TEST_IS1.IS_TEST_GAIN_AVG_LEN
 * @return new value of TEST.TEST_IS1
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__EXTRACT() extracts TEST_IS1.IS_TEST_GAIN_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS1
 * @return current value of TEST_IS1.IS_TEST_GAIN_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_IS1__IS_TEST_GAIN_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TEST_IS2 member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_IS2__ADDRESS returns the address of member TEST_IS2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_IS2
 */
__TEST_INLINE uint32_t* __TEST_TEST_IS2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_IS2)));
}

/** TEST_TEST_IS2__SET() sets TEST_IS2 to given value.
 *
 * When writing to TEST_IS2, this is mandatory to use.
 *
 * @param value new value for TEST_IS2
 */
__TEST_INLINE void TEST_TEST_IS2__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_IS2__ADDRESS(), value);
}

/** TEST_TEST_IS2__GET() gets TEST_IS2's current value.
 *
 * When reading from TEST_IS2, this is mandatory to use.
 *
 * @return current value of TEST_IS2
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__GET(void)
{
    return HAL_GET32(__TEST_TEST_IS2__ADDRESS());
}

/* ------------------ TEST.TEST_IS2.IS_TEST_GAIN_EXPECTED ------------------ */

/**
<pre>
  TEST.TEST_IS2.IS_TEST_GAIN_EXPECTED:

    IS ADC Gain BIST expected value.

</pre> */

#define TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Pos               21                                                                     /*!< Right-most bit position of is_test_gain_expected in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Msk               (0x000000FFUL << TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Pos)            /*!< Mask for is_test_gain_expected in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Shift(v)          (((v) << TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Pos) & TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Msk) /*!< Shift value 'v' into is_test_gain_expected and mask 'v' to fit it into is_test_gain_expected field */

/** TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__SET() sets TEST_IS2.IS_TEST_GAIN_EXPECTED to given value.
 *
 * When writing to TEST_IS2.IS_TEST_GAIN_EXPECTED, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS2.IS_TEST_GAIN_EXPECTED
 */
__TEST_INLINE void TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Shift((uint32_t)bf_value)));
    TEST_TEST_IS2__SET(reg);
}

/** TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__GET() gets TEST_IS2.IS_TEST_GAIN_EXPECTED's current value.
 *
 * When reading from TEST_IS2.IS_TEST_GAIN_EXPECTED, this is recommended to use.
 *
 * @return current value of TEST_IS2.IS_TEST_GAIN_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__GET(void)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__MODIFY() modifies TEST_IS2.IS_TEST_GAIN_EXPECTED.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS2
 * @param bf_value new value for TEST_IS2.IS_TEST_GAIN_EXPECTED
 * @return new value of TEST.TEST_IS2
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__EXTRACT() extracts TEST_IS2.IS_TEST_GAIN_EXPECTED.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS2
 * @return current value of TEST_IS2.IS_TEST_GAIN_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_GAIN_EXPECTED__Pos);
    return (uint32_t)reg;
}

/* --------------------- TEST.TEST_IS2.IS_TEST_DNL_MASK --------------------- */

/**
<pre>
  TEST.TEST_IS2.IS_TEST_DNL_MASK:

    IS ADC Individual mask bit for is_dac = 96, 64, 32, 16, 8, 4, 2, 1 during DNL measurement

</pre> */

#define TEST_TEST_IS2__IS_TEST_DNL_MASK__Pos                    13                                                                     /*!< Right-most bit position of is_test_dnl_mask in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_DNL_MASK__Msk                    (0x000000FFUL << TEST_TEST_IS2__IS_TEST_DNL_MASK__Pos)                 /*!< Mask for is_test_dnl_mask in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_DNL_MASK__Shift(v)               (((v) << TEST_TEST_IS2__IS_TEST_DNL_MASK__Pos) & TEST_TEST_IS2__IS_TEST_DNL_MASK__Msk) /*!< Shift value 'v' into is_test_dnl_mask and mask 'v' to fit it into is_test_dnl_mask field */

/** TEST_TEST_IS2__IS_TEST_DNL_MASK__SET() sets TEST_IS2.IS_TEST_DNL_MASK to given value.
 *
 * When writing to TEST_IS2.IS_TEST_DNL_MASK, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS2.IS_TEST_DNL_MASK
 */
__TEST_INLINE void TEST_TEST_IS2__IS_TEST_DNL_MASK__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_DNL_MASK__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_DNL_MASK__Shift((uint32_t)bf_value)));
    TEST_TEST_IS2__SET(reg);
}

/** TEST_TEST_IS2__IS_TEST_DNL_MASK__GET() gets TEST_IS2.IS_TEST_DNL_MASK's current value.
 *
 * When reading from TEST_IS2.IS_TEST_DNL_MASK, this is recommended to use.
 *
 * @return current value of TEST_IS2.IS_TEST_DNL_MASK
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_DNL_MASK__GET(void)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & TEST_TEST_IS2__IS_TEST_DNL_MASK__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_DNL_MASK__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS2__IS_TEST_DNL_MASK__MODIFY() modifies TEST_IS2.IS_TEST_DNL_MASK.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS2
 * @param bf_value new value for TEST_IS2.IS_TEST_DNL_MASK
 * @return new value of TEST.TEST_IS2
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_DNL_MASK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_DNL_MASK__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_DNL_MASK__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS2__IS_TEST_DNL_MASK__EXTRACT() extracts TEST_IS2.IS_TEST_DNL_MASK.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS2
 * @return current value of TEST_IS2.IS_TEST_DNL_MASK
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_DNL_MASK__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS2__IS_TEST_DNL_MASK__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_DNL_MASK__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_IS2.IS_TEST_ISEN_SRC_SEL ------------------- */

/**
<pre>
  TEST.TEST_IS2.IS_TEST_ISEN_SRC_SEL:

    IS Test Mode IS2 (calibration IS) source select
    <start table>
    0,1 "Test mode force disabled"
    2 "IS2 forced to ISEN input"
    3 "IS2 forced to BISEN input"
    <end table>

</pre> */

#define TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Pos                11                                                                     /*!< Right-most bit position of is_test_isen_src_sel in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Msk                (0x00000003UL << TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Pos)             /*!< Mask for is_test_isen_src_sel in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Shift(v)           (((v) << TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Pos) & TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Msk) /*!< Shift value 'v' into is_test_isen_src_sel and mask 'v' to fit it into is_test_isen_src_sel field */

/** TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__SET() sets TEST_IS2.IS_TEST_ISEN_SRC_SEL to given value.
 *
 * When writing to TEST_IS2.IS_TEST_ISEN_SRC_SEL, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS2.IS_TEST_ISEN_SRC_SEL
 */
__TEST_INLINE void TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Shift((uint32_t)bf_value)));
    TEST_TEST_IS2__SET(reg);
}

/** TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__GET() gets TEST_IS2.IS_TEST_ISEN_SRC_SEL's current value.
 *
 * When reading from TEST_IS2.IS_TEST_ISEN_SRC_SEL, this is recommended to use.
 *
 * @return current value of TEST_IS2.IS_TEST_ISEN_SRC_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__GET(void)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__MODIFY() modifies TEST_IS2.IS_TEST_ISEN_SRC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS2
 * @param bf_value new value for TEST_IS2.IS_TEST_ISEN_SRC_SEL
 * @return new value of TEST.TEST_IS2
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__EXTRACT() extracts TEST_IS2.IS_TEST_ISEN_SRC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS2
 * @return current value of TEST_IS2.IS_TEST_ISEN_SRC_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_ISEN_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TEST.TEST_IS2.IS_AUTO_CAL_EN ---------------------- */

/**
<pre>
  TEST.TEST_IS2.IS_AUTO_CAL_EN:

    No longer used, set to 0.

</pre> */

#define TEST_TEST_IS2__IS_AUTO_CAL_EN__Pos                      10                                                                     /*!< Right-most bit position of is_auto_cal_en in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_AUTO_CAL_EN__Msk                      (0x00000001UL << TEST_TEST_IS2__IS_AUTO_CAL_EN__Pos)                   /*!< Mask for is_auto_cal_en in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_AUTO_CAL_EN__Shift(v)                 (((v) << TEST_TEST_IS2__IS_AUTO_CAL_EN__Pos) & TEST_TEST_IS2__IS_AUTO_CAL_EN__Msk) /*!< Shift value 'v' into is_auto_cal_en and mask 'v' to fit it into is_auto_cal_en field */

/** TEST_TEST_IS2__IS_AUTO_CAL_EN__SET() sets TEST_IS2.IS_AUTO_CAL_EN to given value.
 *
 * When writing to TEST_IS2.IS_AUTO_CAL_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS2.IS_AUTO_CAL_EN
 */
__TEST_INLINE void TEST_TEST_IS2__IS_AUTO_CAL_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & ~TEST_TEST_IS2__IS_AUTO_CAL_EN__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_AUTO_CAL_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_IS2__SET(reg);
}

/** TEST_TEST_IS2__IS_AUTO_CAL_EN__GET() gets TEST_IS2.IS_AUTO_CAL_EN's current value.
 *
 * When reading from TEST_IS2.IS_AUTO_CAL_EN, this is recommended to use.
 *
 * @return current value of TEST_IS2.IS_AUTO_CAL_EN
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_AUTO_CAL_EN__GET(void)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & TEST_TEST_IS2__IS_AUTO_CAL_EN__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_AUTO_CAL_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS2__IS_AUTO_CAL_EN__MODIFY() modifies TEST_IS2.IS_AUTO_CAL_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS2
 * @param bf_value new value for TEST_IS2.IS_AUTO_CAL_EN
 * @return new value of TEST.TEST_IS2
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_AUTO_CAL_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS2__IS_AUTO_CAL_EN__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_AUTO_CAL_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS2__IS_AUTO_CAL_EN__EXTRACT() extracts TEST_IS2.IS_AUTO_CAL_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS2
 * @return current value of TEST_IS2.IS_AUTO_CAL_EN
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_AUTO_CAL_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS2__IS_AUTO_CAL_EN__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_AUTO_CAL_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TEST.TEST_IS2.IS_TEST_DAC_EN ---------------------- */

/**
<pre>
  TEST.TEST_IS2.IS_TEST_DAC_EN:

    IS DAC Source Select
    <start table>
    0 "ISD DAC input based on is_test_mode."
    1 "ISD DAC input forced to is_test_dac from BIST function.  Note that there is currently no method to override the is_test_dac BIST output so this setting has limited usefulness."
    <end table>

</pre> */

#define TEST_TEST_IS2__IS_TEST_DAC_EN__Pos                      9                                                                      /*!< Right-most bit position of is_test_dac_en in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_DAC_EN__Msk                      (0x00000001UL << TEST_TEST_IS2__IS_TEST_DAC_EN__Pos)                   /*!< Mask for is_test_dac_en in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_DAC_EN__Shift(v)                 (((v) << TEST_TEST_IS2__IS_TEST_DAC_EN__Pos) & TEST_TEST_IS2__IS_TEST_DAC_EN__Msk) /*!< Shift value 'v' into is_test_dac_en and mask 'v' to fit it into is_test_dac_en field */

/** TEST_TEST_IS2__IS_TEST_DAC_EN__SET() sets TEST_IS2.IS_TEST_DAC_EN to given value.
 *
 * When writing to TEST_IS2.IS_TEST_DAC_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS2.IS_TEST_DAC_EN
 */
__TEST_INLINE void TEST_TEST_IS2__IS_TEST_DAC_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_DAC_EN__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_DAC_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_IS2__SET(reg);
}

/** TEST_TEST_IS2__IS_TEST_DAC_EN__GET() gets TEST_IS2.IS_TEST_DAC_EN's current value.
 *
 * When reading from TEST_IS2.IS_TEST_DAC_EN, this is recommended to use.
 *
 * @return current value of TEST_IS2.IS_TEST_DAC_EN
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_DAC_EN__GET(void)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & TEST_TEST_IS2__IS_TEST_DAC_EN__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_DAC_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS2__IS_TEST_DAC_EN__MODIFY() modifies TEST_IS2.IS_TEST_DAC_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS2
 * @param bf_value new value for TEST_IS2.IS_TEST_DAC_EN
 * @return new value of TEST.TEST_IS2
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_DAC_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_DAC_EN__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_DAC_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS2__IS_TEST_DAC_EN__EXTRACT() extracts TEST_IS2.IS_TEST_DAC_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS2
 * @return current value of TEST_IS2.IS_TEST_DAC_EN
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_DAC_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS2__IS_TEST_DAC_EN__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_DAC_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TEST.TEST_IS2.IS_TEST_MODE ----------------------- */

/**
<pre>
  TEST.TEST_IS2.IS_TEST_MODE:

    IS ADC test mode control.
    <start table_with_header>
    [3:0] "Test / BIST Mode"
    0 "Normal Operation"
    1 "DNL Measurement (Sweep)"
    2 "DNL Measurement (Single Step)"
    3 "Gain Calibration"
    4 "Gain Calibration Re-Measurement"
    5 "Offset Calibration"
    6 "Offset Calibration Re-Measurement"
    7 "Comp Measurement (Sweep)"
    8 "Single Comp Measurement"
    9-15 "Reserved"
    <end table>

</pre> */

#define TEST_TEST_IS2__IS_TEST_MODE__Pos                        5                                                                      /*!< Right-most bit position of is_test_mode in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_MODE__Msk                        (0x0000000FUL << TEST_TEST_IS2__IS_TEST_MODE__Pos)                     /*!< Mask for is_test_mode in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_MODE__Shift(v)                   (((v) << TEST_TEST_IS2__IS_TEST_MODE__Pos) & TEST_TEST_IS2__IS_TEST_MODE__Msk) /*!< Shift value 'v' into is_test_mode and mask 'v' to fit it into is_test_mode field */

/** TEST_TEST_IS2__IS_TEST_MODE__SET() sets TEST_IS2.IS_TEST_MODE to given value.
 *
 * When writing to TEST_IS2.IS_TEST_MODE, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS2.IS_TEST_MODE
 */
__TEST_INLINE void TEST_TEST_IS2__IS_TEST_MODE__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_MODE__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_MODE__Shift((uint32_t)bf_value)));
    TEST_TEST_IS2__SET(reg);
}

/** TEST_TEST_IS2__IS_TEST_MODE__GET() gets TEST_IS2.IS_TEST_MODE's current value.
 *
 * When reading from TEST_IS2.IS_TEST_MODE, this is recommended to use.
 *
 * @return current value of TEST_IS2.IS_TEST_MODE
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_MODE__GET(void)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & TEST_TEST_IS2__IS_TEST_MODE__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_MODE__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS2__IS_TEST_MODE__MODIFY() modifies TEST_IS2.IS_TEST_MODE.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS2
 * @param bf_value new value for TEST_IS2.IS_TEST_MODE
 * @return new value of TEST.TEST_IS2
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_MODE__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS2__IS_TEST_MODE__EXTRACT() extracts TEST_IS2.IS_TEST_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS2
 * @return current value of TEST_IS2.IS_TEST_MODE
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS2__IS_TEST_MODE__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_MODE__Pos);
    return (uint32_t)reg;
}

/* --------------------- TEST.TEST_IS2.IS_TEST_COMP_EN --------------------- */

/**
<pre>
  TEST.TEST_IS2.IS_TEST_COMP_EN:

    IS ADC Comparator BIST enable / mode select
    <start table>
    0 "Normal operation"
    1 "Comparator BIST enabled, comparator selected by is_test_comp_sel_ib"
    2-3 "Comparator BIST enabled, comparator under test selected by is_test_comp_sel_ib, second comparator enabled for hysteretic operation"
    <end table>

</pre> */

#define TEST_TEST_IS2__IS_TEST_COMP_EN__Pos                     3                                                                      /*!< Right-most bit position of is_test_comp_en in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_COMP_EN__Msk                     (0x00000003UL << TEST_TEST_IS2__IS_TEST_COMP_EN__Pos)                  /*!< Mask for is_test_comp_en in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_COMP_EN__Shift(v)                (((v) << TEST_TEST_IS2__IS_TEST_COMP_EN__Pos) & TEST_TEST_IS2__IS_TEST_COMP_EN__Msk) /*!< Shift value 'v' into is_test_comp_en and mask 'v' to fit it into is_test_comp_en field */

/** TEST_TEST_IS2__IS_TEST_COMP_EN__SET() sets TEST_IS2.IS_TEST_COMP_EN to given value.
 *
 * When writing to TEST_IS2.IS_TEST_COMP_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS2.IS_TEST_COMP_EN
 */
__TEST_INLINE void TEST_TEST_IS2__IS_TEST_COMP_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_COMP_EN__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_COMP_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_IS2__SET(reg);
}

/** TEST_TEST_IS2__IS_TEST_COMP_EN__GET() gets TEST_IS2.IS_TEST_COMP_EN's current value.
 *
 * When reading from TEST_IS2.IS_TEST_COMP_EN, this is recommended to use.
 *
 * @return current value of TEST_IS2.IS_TEST_COMP_EN
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_COMP_EN__GET(void)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & TEST_TEST_IS2__IS_TEST_COMP_EN__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_COMP_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS2__IS_TEST_COMP_EN__MODIFY() modifies TEST_IS2.IS_TEST_COMP_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS2
 * @param bf_value new value for TEST_IS2.IS_TEST_COMP_EN
 * @return new value of TEST.TEST_IS2
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_COMP_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_COMP_EN__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_COMP_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS2__IS_TEST_COMP_EN__EXTRACT() extracts TEST_IS2.IS_TEST_COMP_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS2
 * @return current value of TEST_IS2.IS_TEST_COMP_EN
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_COMP_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS2__IS_TEST_COMP_EN__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_COMP_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_IS2.IS_TEST_COMP_SEL_IB ------------------- */

/**
<pre>
  TEST.TEST_IS2.IS_TEST_COMP_SEL_IB:

    IS ADC Comparator BIST comparator select.
    <start table_with_header>
    [2:0] Comparator
    0 "Comp[0] (+4.5 code offset)"
    1 "Comp[1] (+2.5 code offset)"
    2 "Comp[2] (+0.5 code offset)"
    3 "Comp[3] (-1.5 code offset)"
    4 "Comp[4] (-3.5 code offset)"
    <end table>

</pre> */

#define TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Pos                 0                                                                      /*!< Right-most bit position of is_test_comp_sel_ib in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Msk                 (0x00000007UL << TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Pos)              /*!< Mask for is_test_comp_sel_ib in TEST.TEST_IS2 */
#define TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Shift(v)            (((v) << TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Pos) & TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Msk) /*!< Shift value 'v' into is_test_comp_sel_ib and mask 'v' to fit it into is_test_comp_sel_ib field */

/** TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__SET() sets TEST_IS2.IS_TEST_COMP_SEL_IB to given value.
 *
 * When writing to TEST_IS2.IS_TEST_COMP_SEL_IB, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS2.IS_TEST_COMP_SEL_IB
 */
__TEST_INLINE void TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Shift((uint32_t)bf_value)));
    TEST_TEST_IS2__SET(reg);
}

/** TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__GET() gets TEST_IS2.IS_TEST_COMP_SEL_IB's current value.
 *
 * When reading from TEST_IS2.IS_TEST_COMP_SEL_IB, this is recommended to use.
 *
 * @return current value of TEST_IS2.IS_TEST_COMP_SEL_IB
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__GET(void)
{
    uint32_t reg = TEST_TEST_IS2__GET();
    reg = (reg & TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__MODIFY() modifies TEST_IS2.IS_TEST_COMP_SEL_IB.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS2
 * @param bf_value new value for TEST_IS2.IS_TEST_COMP_SEL_IB
 * @return new value of TEST.TEST_IS2
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Msk);
    reg = (reg | (TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__EXTRACT() extracts TEST_IS2.IS_TEST_COMP_SEL_IB.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS2
 * @return current value of TEST_IS2.IS_TEST_COMP_SEL_IB
 */
__TEST_INLINE uint32_t TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Msk);
    reg = (reg >> TEST_TEST_IS2__IS_TEST_COMP_SEL_IB__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TEST_IS3 member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_IS3__ADDRESS returns the address of member TEST_IS3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_IS3
 */
__TEST_INLINE uint32_t* __TEST_TEST_IS3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_IS3)));
}

/** TEST_TEST_IS3__SET() sets TEST_IS3 to given value.
 *
 * When writing to TEST_IS3, this is mandatory to use.
 *
 * @param value new value for TEST_IS3
 */
__TEST_INLINE void TEST_TEST_IS3__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_IS3__ADDRESS(), value);
}

/** TEST_TEST_IS3__GET() gets TEST_IS3's current value.
 *
 * When reading from TEST_IS3, this is mandatory to use.
 *
 * @return current value of TEST_IS3
 */
__TEST_INLINE uint32_t TEST_TEST_IS3__GET(void)
{
    return HAL_GET32(__TEST_TEST_IS3__ADDRESS());
}

/* ----------------------- TEST.TEST_IS3.IS_TEST_STEP ----------------------- */

/**
<pre>
  TEST.TEST_IS3.IS_TEST_STEP:

    IS / TS ADC DNL BIST tracking loop step-size.

</pre> */

#define TEST_TEST_IS3__IS_TEST_STEP__Pos                        9                                                                      /*!< Right-most bit position of is_test_step in TEST.TEST_IS3 */
#define TEST_TEST_IS3__IS_TEST_STEP__Msk                        (0x0000000FUL << TEST_TEST_IS3__IS_TEST_STEP__Pos)                     /*!< Mask for is_test_step in TEST.TEST_IS3 */
#define TEST_TEST_IS3__IS_TEST_STEP__Shift(v)                   (((v) << TEST_TEST_IS3__IS_TEST_STEP__Pos) & TEST_TEST_IS3__IS_TEST_STEP__Msk) /*!< Shift value 'v' into is_test_step and mask 'v' to fit it into is_test_step field */

/** TEST_TEST_IS3__IS_TEST_STEP__SET() sets TEST_IS3.IS_TEST_STEP to given value.
 *
 * When writing to TEST_IS3.IS_TEST_STEP, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS3.IS_TEST_STEP
 */
__TEST_INLINE void TEST_TEST_IS3__IS_TEST_STEP__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS3__GET();
    reg = (reg & ~TEST_TEST_IS3__IS_TEST_STEP__Msk);
    reg = (reg | (TEST_TEST_IS3__IS_TEST_STEP__Shift((uint32_t)bf_value)));
    TEST_TEST_IS3__SET(reg);
}

/** TEST_TEST_IS3__IS_TEST_STEP__GET() gets TEST_IS3.IS_TEST_STEP's current value.
 *
 * When reading from TEST_IS3.IS_TEST_STEP, this is recommended to use.
 *
 * @return current value of TEST_IS3.IS_TEST_STEP
 */
__TEST_INLINE uint32_t TEST_TEST_IS3__IS_TEST_STEP__GET(void)
{
    uint32_t reg = TEST_TEST_IS3__GET();
    reg = (reg & TEST_TEST_IS3__IS_TEST_STEP__Msk);
    reg = (reg >> TEST_TEST_IS3__IS_TEST_STEP__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS3__IS_TEST_STEP__MODIFY() modifies TEST_IS3.IS_TEST_STEP.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS3
 * @param bf_value new value for TEST_IS3.IS_TEST_STEP
 * @return new value of TEST.TEST_IS3
 */
__TEST_INLINE uint32_t TEST_TEST_IS3__IS_TEST_STEP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS3__IS_TEST_STEP__Msk);
    reg = (reg | (TEST_TEST_IS3__IS_TEST_STEP__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS3__IS_TEST_STEP__EXTRACT() extracts TEST_IS3.IS_TEST_STEP.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS3
 * @return current value of TEST_IS3.IS_TEST_STEP
 */
__TEST_INLINE uint32_t TEST_TEST_IS3__IS_TEST_STEP__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS3__IS_TEST_STEP__Msk);
    reg = (reg >> TEST_TEST_IS3__IS_TEST_STEP__Pos);
    return (uint32_t)reg;
}

/* --------------------- TEST.TEST_IS3.IS_TEST_STEP_EN --------------------- */

/**
<pre>
  TEST.TEST_IS3.IS_TEST_STEP_EN:

    IS / TS ADC DNL BIST tracking loop step-size select.
    <start table>
    0 "0.5 ADC Codes"
    1 "Set by is_test_step[3:0]"
    <end table>

</pre> */

#define TEST_TEST_IS3__IS_TEST_STEP_EN__Pos                     8                                                                      /*!< Right-most bit position of is_test_step_en in TEST.TEST_IS3 */
#define TEST_TEST_IS3__IS_TEST_STEP_EN__Msk                     (0x00000001UL << TEST_TEST_IS3__IS_TEST_STEP_EN__Pos)                  /*!< Mask for is_test_step_en in TEST.TEST_IS3 */
#define TEST_TEST_IS3__IS_TEST_STEP_EN__Shift(v)                (((v) << TEST_TEST_IS3__IS_TEST_STEP_EN__Pos) & TEST_TEST_IS3__IS_TEST_STEP_EN__Msk) /*!< Shift value 'v' into is_test_step_en and mask 'v' to fit it into is_test_step_en field */

/** TEST_TEST_IS3__IS_TEST_STEP_EN__SET() sets TEST_IS3.IS_TEST_STEP_EN to given value.
 *
 * When writing to TEST_IS3.IS_TEST_STEP_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS3.IS_TEST_STEP_EN
 */
__TEST_INLINE void TEST_TEST_IS3__IS_TEST_STEP_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS3__GET();
    reg = (reg & ~TEST_TEST_IS3__IS_TEST_STEP_EN__Msk);
    reg = (reg | (TEST_TEST_IS3__IS_TEST_STEP_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_IS3__SET(reg);
}

/** TEST_TEST_IS3__IS_TEST_STEP_EN__GET() gets TEST_IS3.IS_TEST_STEP_EN's current value.
 *
 * When reading from TEST_IS3.IS_TEST_STEP_EN, this is recommended to use.
 *
 * @return current value of TEST_IS3.IS_TEST_STEP_EN
 */
__TEST_INLINE uint32_t TEST_TEST_IS3__IS_TEST_STEP_EN__GET(void)
{
    uint32_t reg = TEST_TEST_IS3__GET();
    reg = (reg & TEST_TEST_IS3__IS_TEST_STEP_EN__Msk);
    reg = (reg >> TEST_TEST_IS3__IS_TEST_STEP_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS3__IS_TEST_STEP_EN__MODIFY() modifies TEST_IS3.IS_TEST_STEP_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS3
 * @param bf_value new value for TEST_IS3.IS_TEST_STEP_EN
 * @return new value of TEST.TEST_IS3
 */
__TEST_INLINE uint32_t TEST_TEST_IS3__IS_TEST_STEP_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS3__IS_TEST_STEP_EN__Msk);
    reg = (reg | (TEST_TEST_IS3__IS_TEST_STEP_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS3__IS_TEST_STEP_EN__EXTRACT() extracts TEST_IS3.IS_TEST_STEP_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS3
 * @return current value of TEST_IS3.IS_TEST_STEP_EN
 */
__TEST_INLINE uint32_t TEST_TEST_IS3__IS_TEST_STEP_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS3__IS_TEST_STEP_EN__Msk);
    reg = (reg >> TEST_TEST_IS3__IS_TEST_STEP_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TEST.TEST_IS3.IS_TEST_EEC ----------------------- */

/**
<pre>
  TEST.TEST_IS3.IS_TEST_EEC:

    Engineering evaluation control bits for IS block characterization.

</pre> */

#define TEST_TEST_IS3__IS_TEST_EEC__Pos                         0                                                                      /*!< Right-most bit position of is_test_eec in TEST.TEST_IS3 */
#define TEST_TEST_IS3__IS_TEST_EEC__Msk                         (0x000000FFUL << TEST_TEST_IS3__IS_TEST_EEC__Pos)                      /*!< Mask for is_test_eec in TEST.TEST_IS3 */
#define TEST_TEST_IS3__IS_TEST_EEC__Shift(v)                    (((v) << TEST_TEST_IS3__IS_TEST_EEC__Pos) & TEST_TEST_IS3__IS_TEST_EEC__Msk) /*!< Shift value 'v' into is_test_eec and mask 'v' to fit it into is_test_eec field */

/** TEST_TEST_IS3__IS_TEST_EEC__SET() sets TEST_IS3.IS_TEST_EEC to given value.
 *
 * When writing to TEST_IS3.IS_TEST_EEC, this is recommended to use.
 *
 * @param bf_value new value for TEST_IS3.IS_TEST_EEC
 */
__TEST_INLINE void TEST_TEST_IS3__IS_TEST_EEC__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_IS3__GET();
    reg = (reg & ~TEST_TEST_IS3__IS_TEST_EEC__Msk);
    reg = (reg | (TEST_TEST_IS3__IS_TEST_EEC__Shift((uint32_t)bf_value)));
    TEST_TEST_IS3__SET(reg);
}

/** TEST_TEST_IS3__IS_TEST_EEC__GET() gets TEST_IS3.IS_TEST_EEC's current value.
 *
 * When reading from TEST_IS3.IS_TEST_EEC, this is recommended to use.
 *
 * @return current value of TEST_IS3.IS_TEST_EEC
 */
__TEST_INLINE uint32_t TEST_TEST_IS3__IS_TEST_EEC__GET(void)
{
    uint32_t reg = TEST_TEST_IS3__GET();
    reg = (reg & TEST_TEST_IS3__IS_TEST_EEC__Msk);
    reg = (reg >> TEST_TEST_IS3__IS_TEST_EEC__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_IS3__IS_TEST_EEC__MODIFY() modifies TEST_IS3.IS_TEST_EEC.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_IS3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_IS3
 * @param bf_value new value for TEST_IS3.IS_TEST_EEC
 * @return new value of TEST.TEST_IS3
 */
__TEST_INLINE uint32_t TEST_TEST_IS3__IS_TEST_EEC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_IS3__IS_TEST_EEC__Msk);
    reg = (reg | (TEST_TEST_IS3__IS_TEST_EEC__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_IS3__IS_TEST_EEC__EXTRACT() extracts TEST_IS3.IS_TEST_EEC.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_IS3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_IS3
 * @return current value of TEST_IS3.IS_TEST_EEC
 */
__TEST_INLINE uint32_t TEST_TEST_IS3__IS_TEST_EEC__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_IS3__IS_TEST_EEC__Msk);
    reg = (reg >> TEST_TEST_IS3__IS_TEST_EEC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TEST_VS0 member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_VS0__ADDRESS returns the address of member TEST_VS0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_VS0
 */
__TEST_INLINE uint32_t* __TEST_TEST_VS0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_VS0)));
}

/** TEST_TEST_VS0__SET() sets TEST_VS0 to given value.
 *
 * When writing to TEST_VS0, this is mandatory to use.
 *
 * @param value new value for TEST_VS0
 */
__TEST_INLINE void TEST_TEST_VS0__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_VS0__ADDRESS(), value);
}

/** TEST_TEST_VS0__GET() gets TEST_VS0's current value.
 *
 * When reading from TEST_VS0, this is mandatory to use.
 *
 * @return current value of TEST_VS0
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__GET(void)
{
    return HAL_GET32(__TEST_TEST_VS0__ADDRESS());
}

/* ------------------- TEST.TEST_VS0.VS_TEST_OFFS_AVG_LEN ------------------- */

/**
<pre>
  TEST.TEST_VS0.VS_TEST_OFFS_AVG_LEN:

    VS ADC Offset BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Pos                28                                                                     /*!< Right-most bit position of vs_test_offs_avg_len in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Msk                (0x00000007UL << TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Pos)             /*!< Mask for vs_test_offs_avg_len in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Shift(v)           (((v) << TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Pos) & TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Msk) /*!< Shift value 'v' into vs_test_offs_avg_len and mask 'v' to fit it into vs_test_offs_avg_len field */

/** TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__SET() sets TEST_VS0.VS_TEST_OFFS_AVG_LEN to given value.
 *
 * When writing to TEST_VS0.VS_TEST_OFFS_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS0.VS_TEST_OFFS_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_VS0__SET(reg);
}

/** TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__GET() gets TEST_VS0.VS_TEST_OFFS_AVG_LEN's current value.
 *
 * When reading from TEST_VS0.VS_TEST_OFFS_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_VS0.VS_TEST_OFFS_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__MODIFY() modifies TEST_VS0.VS_TEST_OFFS_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS0
 * @param bf_value new value for TEST_VS0.VS_TEST_OFFS_AVG_LEN
 * @return new value of TEST.TEST_VS0
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__EXTRACT() extracts TEST_VS0.VS_TEST_OFFS_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS0
 * @return current value of TEST_VS0.VS_TEST_OFFS_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_OFFS_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_VS0.VS_TEST_GAIN_AVG_LEN ------------------- */

/**
<pre>
  TEST.TEST_VS0.VS_TEST_GAIN_AVG_LEN:

    VS ADC Gain BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Pos                25                                                                     /*!< Right-most bit position of vs_test_gain_avg_len in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Msk                (0x00000007UL << TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Pos)             /*!< Mask for vs_test_gain_avg_len in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Shift(v)           (((v) << TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Pos) & TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Msk) /*!< Shift value 'v' into vs_test_gain_avg_len and mask 'v' to fit it into vs_test_gain_avg_len field */

/** TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__SET() sets TEST_VS0.VS_TEST_GAIN_AVG_LEN to given value.
 *
 * When writing to TEST_VS0.VS_TEST_GAIN_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS0.VS_TEST_GAIN_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_VS0__SET(reg);
}

/** TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__GET() gets TEST_VS0.VS_TEST_GAIN_AVG_LEN's current value.
 *
 * When reading from TEST_VS0.VS_TEST_GAIN_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_VS0.VS_TEST_GAIN_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__MODIFY() modifies TEST_VS0.VS_TEST_GAIN_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS0
 * @param bf_value new value for TEST_VS0.VS_TEST_GAIN_AVG_LEN
 * @return new value of TEST.TEST_VS0
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__EXTRACT() extracts TEST_VS0.VS_TEST_GAIN_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS0
 * @return current value of TEST_VS0.VS_TEST_GAIN_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_GAIN_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_VS0.VS_TEST_DNL_AVG_LEN ------------------- */

/**
<pre>
  TEST.TEST_VS0.VS_TEST_DNL_AVG_LEN:

    VS ADC DNL BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Pos                 22                                                                     /*!< Right-most bit position of vs_test_dnl_avg_len in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Msk                 (0x00000007UL << TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Pos)              /*!< Mask for vs_test_dnl_avg_len in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Shift(v)            (((v) << TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Pos) & TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Msk) /*!< Shift value 'v' into vs_test_dnl_avg_len and mask 'v' to fit it into vs_test_dnl_avg_len field */

/** TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__SET() sets TEST_VS0.VS_TEST_DNL_AVG_LEN to given value.
 *
 * When writing to TEST_VS0.VS_TEST_DNL_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS0.VS_TEST_DNL_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_VS0__SET(reg);
}

/** TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__GET() gets TEST_VS0.VS_TEST_DNL_AVG_LEN's current value.
 *
 * When reading from TEST_VS0.VS_TEST_DNL_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_VS0.VS_TEST_DNL_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__MODIFY() modifies TEST_VS0.VS_TEST_DNL_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS0
 * @param bf_value new value for TEST_VS0.VS_TEST_DNL_AVG_LEN
 * @return new value of TEST.TEST_VS0
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__EXTRACT() extracts TEST_VS0.VS_TEST_DNL_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS0
 * @return current value of TEST_VS0.VS_TEST_DNL_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_DNL_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* -------------------- TEST.TEST_VS0.VS_TEST_OFFS_LIMIT -------------------- */

/**
<pre>
  TEST.TEST_VS0.VS_TEST_OFFS_LIMIT:

    VS ADC Offset BIST error limit.

</pre> */

#define TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Pos                  15                                                                     /*!< Right-most bit position of vs_test_offs_limit in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Msk                  (0x0000007FUL << TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Pos)               /*!< Mask for vs_test_offs_limit in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Shift(v)             (((v) << TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Pos) & TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Msk) /*!< Shift value 'v' into vs_test_offs_limit and mask 'v' to fit it into vs_test_offs_limit field */

/** TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__SET() sets TEST_VS0.VS_TEST_OFFS_LIMIT to given value.
 *
 * When writing to TEST_VS0.VS_TEST_OFFS_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS0.VS_TEST_OFFS_LIMIT
 */
__TEST_INLINE void TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_VS0__SET(reg);
}

/** TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__GET() gets TEST_VS0.VS_TEST_OFFS_LIMIT's current value.
 *
 * When reading from TEST_VS0.VS_TEST_OFFS_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_VS0.VS_TEST_OFFS_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__MODIFY() modifies TEST_VS0.VS_TEST_OFFS_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS0
 * @param bf_value new value for TEST_VS0.VS_TEST_OFFS_LIMIT
 * @return new value of TEST.TEST_VS0
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__EXTRACT() extracts TEST_VS0.VS_TEST_OFFS_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS0
 * @return current value of TEST_VS0.VS_TEST_OFFS_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_OFFS_LIMIT__Pos);
    return (uint32_t)reg;
}

/* -------------------- TEST.TEST_VS0.VS_TEST_GAIN_LIMIT -------------------- */

/**
<pre>
  TEST.TEST_VS0.VS_TEST_GAIN_LIMIT:

    VS ADC Gain BIST error limit.

</pre> */

#define TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Pos                  8                                                                      /*!< Right-most bit position of vs_test_gain_limit in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Msk                  (0x0000007FUL << TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Pos)               /*!< Mask for vs_test_gain_limit in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Shift(v)             (((v) << TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Pos) & TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Msk) /*!< Shift value 'v' into vs_test_gain_limit and mask 'v' to fit it into vs_test_gain_limit field */

/** TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__SET() sets TEST_VS0.VS_TEST_GAIN_LIMIT to given value.
 *
 * When writing to TEST_VS0.VS_TEST_GAIN_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS0.VS_TEST_GAIN_LIMIT
 */
__TEST_INLINE void TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_VS0__SET(reg);
}

/** TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__GET() gets TEST_VS0.VS_TEST_GAIN_LIMIT's current value.
 *
 * When reading from TEST_VS0.VS_TEST_GAIN_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_VS0.VS_TEST_GAIN_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__MODIFY() modifies TEST_VS0.VS_TEST_GAIN_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS0
 * @param bf_value new value for TEST_VS0.VS_TEST_GAIN_LIMIT
 * @return new value of TEST.TEST_VS0
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__EXTRACT() extracts TEST_VS0.VS_TEST_GAIN_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS0
 * @return current value of TEST_VS0.VS_TEST_GAIN_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_GAIN_LIMIT__Pos);
    return (uint32_t)reg;
}

/* ------------------ TEST.TEST_VS0.VS_TEST_OFFS_EXPECTED ------------------ */

/**
<pre>
  TEST.TEST_VS0.VS_TEST_OFFS_EXPECTED:

    VS ADC Offset BIST expected value.

</pre> */

#define TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Pos               0                                                                      /*!< Right-most bit position of vs_test_offs_expected in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Msk               (0x000000FFUL << TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Pos)            /*!< Mask for vs_test_offs_expected in TEST.TEST_VS0 */
#define TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Shift(v)          (((v) << TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Pos) & TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Msk) /*!< Shift value 'v' into vs_test_offs_expected and mask 'v' to fit it into vs_test_offs_expected field */

/** TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__SET() sets TEST_VS0.VS_TEST_OFFS_EXPECTED to given value.
 *
 * When writing to TEST_VS0.VS_TEST_OFFS_EXPECTED, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS0.VS_TEST_OFFS_EXPECTED
 */
__TEST_INLINE void TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Shift((uint32_t)bf_value)));
    TEST_TEST_VS0__SET(reg);
}

/** TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__GET() gets TEST_VS0.VS_TEST_OFFS_EXPECTED's current value.
 *
 * When reading from TEST_VS0.VS_TEST_OFFS_EXPECTED, this is recommended to use.
 *
 * @return current value of TEST_VS0.VS_TEST_OFFS_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__GET(void)
{
    uint32_t reg = TEST_TEST_VS0__GET();
    reg = (reg & TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__MODIFY() modifies TEST_VS0.VS_TEST_OFFS_EXPECTED.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS0
 * @param bf_value new value for TEST_VS0.VS_TEST_OFFS_EXPECTED
 * @return new value of TEST.TEST_VS0
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__EXTRACT() extracts TEST_VS0.VS_TEST_OFFS_EXPECTED.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS0
 * @return current value of TEST_VS0.VS_TEST_OFFS_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_VS0__VS_TEST_OFFS_EXPECTED__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TEST_VS1 member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_VS1__ADDRESS returns the address of member TEST_VS1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_VS1
 */
__TEST_INLINE uint32_t* __TEST_TEST_VS1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_VS1)));
}

/** TEST_TEST_VS1__SET() sets TEST_VS1 to given value.
 *
 * When writing to TEST_VS1, this is mandatory to use.
 *
 * @param value new value for TEST_VS1
 */
__TEST_INLINE void TEST_TEST_VS1__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_VS1__ADDRESS(), value);
}

/** TEST_TEST_VS1__GET() gets TEST_VS1's current value.
 *
 * When reading from TEST_VS1, this is mandatory to use.
 *
 * @return current value of TEST_VS1
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__GET(void)
{
    return HAL_GET32(__TEST_TEST_VS1__ADDRESS());
}

/* ------------------ TEST.TEST_VS1.VS_TEST_STRESS_AVG_LEN ------------------ */

/**
<pre>
  TEST.TEST_VS1.VS_TEST_STRESS_AVG_LEN:

    VS ADC Stress Compensation BIST number of samples averaged
    <start table_with_header>
    [2:0] "# samples" "[2:0]" "# samples"
    0 "128" "4" "2048"
    1 "256" "5" "4096"
    2 "512" "6" "8192"
    3 "1024" "7" "16384"
    <end table>

</pre> */

#define TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Pos              25                                                                     /*!< Right-most bit position of vs_test_stress_avg_len in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Msk              (0x00000007UL << TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Pos)           /*!< Mask for vs_test_stress_avg_len in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Shift(v)         (((v) << TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Pos) & TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Msk) /*!< Shift value 'v' into vs_test_stress_avg_len and mask 'v' to fit it into vs_test_stress_avg_len field */

/** TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__SET() sets TEST_VS1.VS_TEST_STRESS_AVG_LEN to given value.
 *
 * When writing to TEST_VS1.VS_TEST_STRESS_AVG_LEN, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS1.VS_TEST_STRESS_AVG_LEN
 */
__TEST_INLINE void TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Shift((uint32_t)bf_value)));
    TEST_TEST_VS1__SET(reg);
}

/** TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__GET() gets TEST_VS1.VS_TEST_STRESS_AVG_LEN's current value.
 *
 * When reading from TEST_VS1.VS_TEST_STRESS_AVG_LEN, this is recommended to use.
 *
 * @return current value of TEST_VS1.VS_TEST_STRESS_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__GET(void)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__MODIFY() modifies TEST_VS1.VS_TEST_STRESS_AVG_LEN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS1
 * @param bf_value new value for TEST_VS1.VS_TEST_STRESS_AVG_LEN
 * @return new value of TEST.TEST_VS1
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__EXTRACT() extracts TEST_VS1.VS_TEST_STRESS_AVG_LEN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS1
 * @return current value of TEST_VS1.VS_TEST_STRESS_AVG_LEN
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_STRESS_AVG_LEN__Pos);
    return (uint32_t)reg;
}

/* --------------------- TEST.TEST_VS1.VS_TEST_DNL_MASK --------------------- */

/**
<pre>
  TEST.TEST_VS1.VS_TEST_DNL_MASK:

    Individual mask bit for vs_dac = 96, 64, 32, 16, 8, 4, 2, 1 during DNL measurement

</pre> */

#define TEST_TEST_VS1__VS_TEST_DNL_MASK__Pos                    17                                                                     /*!< Right-most bit position of vs_test_dnl_mask in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_DNL_MASK__Msk                    (0x000000FFUL << TEST_TEST_VS1__VS_TEST_DNL_MASK__Pos)                 /*!< Mask for vs_test_dnl_mask in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_DNL_MASK__Shift(v)               (((v) << TEST_TEST_VS1__VS_TEST_DNL_MASK__Pos) & TEST_TEST_VS1__VS_TEST_DNL_MASK__Msk) /*!< Shift value 'v' into vs_test_dnl_mask and mask 'v' to fit it into vs_test_dnl_mask field */

/** TEST_TEST_VS1__VS_TEST_DNL_MASK__SET() sets TEST_VS1.VS_TEST_DNL_MASK to given value.
 *
 * When writing to TEST_VS1.VS_TEST_DNL_MASK, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS1.VS_TEST_DNL_MASK
 */
__TEST_INLINE void TEST_TEST_VS1__VS_TEST_DNL_MASK__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_DNL_MASK__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_DNL_MASK__Shift((uint32_t)bf_value)));
    TEST_TEST_VS1__SET(reg);
}

/** TEST_TEST_VS1__VS_TEST_DNL_MASK__GET() gets TEST_VS1.VS_TEST_DNL_MASK's current value.
 *
 * When reading from TEST_VS1.VS_TEST_DNL_MASK, this is recommended to use.
 *
 * @return current value of TEST_VS1.VS_TEST_DNL_MASK
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_DNL_MASK__GET(void)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & TEST_TEST_VS1__VS_TEST_DNL_MASK__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_DNL_MASK__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS1__VS_TEST_DNL_MASK__MODIFY() modifies TEST_VS1.VS_TEST_DNL_MASK.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS1
 * @param bf_value new value for TEST_VS1.VS_TEST_DNL_MASK
 * @return new value of TEST.TEST_VS1
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_DNL_MASK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_DNL_MASK__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_DNL_MASK__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS1__VS_TEST_DNL_MASK__EXTRACT() extracts TEST_VS1.VS_TEST_DNL_MASK.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS1
 * @return current value of TEST_VS1.VS_TEST_DNL_MASK
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_DNL_MASK__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS1__VS_TEST_DNL_MASK__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_DNL_MASK__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TEST.TEST_VS1.VS_TEST_DAC_EN ---------------------- */

/**
<pre>
  TEST.TEST_VS1.VS_TEST_DAC_EN:

    VS DAC Source Select
    <start table>
    0 "VSD DAC input based on vs_test_mode."
    1 "VSD DAC input forced to vs_test_dac from BIST function.  Note that there is currently no method to override the vs_test_dac BIST output so this setting has limited usefulness."
    <end table>

</pre> */

#define TEST_TEST_VS1__VS_TEST_DAC_EN__Pos                      16                                                                     /*!< Right-most bit position of vs_test_dac_en in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_DAC_EN__Msk                      (0x00000001UL << TEST_TEST_VS1__VS_TEST_DAC_EN__Pos)                   /*!< Mask for vs_test_dac_en in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_DAC_EN__Shift(v)                 (((v) << TEST_TEST_VS1__VS_TEST_DAC_EN__Pos) & TEST_TEST_VS1__VS_TEST_DAC_EN__Msk) /*!< Shift value 'v' into vs_test_dac_en and mask 'v' to fit it into vs_test_dac_en field */

/** TEST_TEST_VS1__VS_TEST_DAC_EN__SET() sets TEST_VS1.VS_TEST_DAC_EN to given value.
 *
 * When writing to TEST_VS1.VS_TEST_DAC_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS1.VS_TEST_DAC_EN
 */
__TEST_INLINE void TEST_TEST_VS1__VS_TEST_DAC_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_DAC_EN__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_DAC_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_VS1__SET(reg);
}

/** TEST_TEST_VS1__VS_TEST_DAC_EN__GET() gets TEST_VS1.VS_TEST_DAC_EN's current value.
 *
 * When reading from TEST_VS1.VS_TEST_DAC_EN, this is recommended to use.
 *
 * @return current value of TEST_VS1.VS_TEST_DAC_EN
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_DAC_EN__GET(void)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & TEST_TEST_VS1__VS_TEST_DAC_EN__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_DAC_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS1__VS_TEST_DAC_EN__MODIFY() modifies TEST_VS1.VS_TEST_DAC_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS1
 * @param bf_value new value for TEST_VS1.VS_TEST_DAC_EN
 * @return new value of TEST.TEST_VS1
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_DAC_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_DAC_EN__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_DAC_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS1__VS_TEST_DAC_EN__EXTRACT() extracts TEST_VS1.VS_TEST_DAC_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS1
 * @return current value of TEST_VS1.VS_TEST_DAC_EN
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_DAC_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS1__VS_TEST_DAC_EN__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_DAC_EN__Pos);
    return (uint32_t)reg;
}

/* --------------------- TEST.TEST_VS1.VS_TEST_P1P2_SEL --------------------- */

/**
<pre>
  TEST.TEST_VS1.VS_TEST_P1P2_SEL:

    VS ADC gain calibration testpoint select.
    <start table>
    0 P1
    1 P2
    <end table>

</pre> */

#define TEST_TEST_VS1__VS_TEST_P1P2_SEL__Pos                    15                                                                     /*!< Right-most bit position of vs_test_p1p2_sel in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_P1P2_SEL__Msk                    (0x00000001UL << TEST_TEST_VS1__VS_TEST_P1P2_SEL__Pos)                 /*!< Mask for vs_test_p1p2_sel in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_P1P2_SEL__Shift(v)               (((v) << TEST_TEST_VS1__VS_TEST_P1P2_SEL__Pos) & TEST_TEST_VS1__VS_TEST_P1P2_SEL__Msk) /*!< Shift value 'v' into vs_test_p1p2_sel and mask 'v' to fit it into vs_test_p1p2_sel field */

/** TEST_TEST_VS1__VS_TEST_P1P2_SEL__SET() sets TEST_VS1.VS_TEST_P1P2_SEL to given value.
 *
 * When writing to TEST_VS1.VS_TEST_P1P2_SEL, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS1.VS_TEST_P1P2_SEL
 */
__TEST_INLINE void TEST_TEST_VS1__VS_TEST_P1P2_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_P1P2_SEL__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_P1P2_SEL__Shift((uint32_t)bf_value)));
    TEST_TEST_VS1__SET(reg);
}

/** TEST_TEST_VS1__VS_TEST_P1P2_SEL__GET() gets TEST_VS1.VS_TEST_P1P2_SEL's current value.
 *
 * When reading from TEST_VS1.VS_TEST_P1P2_SEL, this is recommended to use.
 *
 * @return current value of TEST_VS1.VS_TEST_P1P2_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_P1P2_SEL__GET(void)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & TEST_TEST_VS1__VS_TEST_P1P2_SEL__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_P1P2_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS1__VS_TEST_P1P2_SEL__MODIFY() modifies TEST_VS1.VS_TEST_P1P2_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS1
 * @param bf_value new value for TEST_VS1.VS_TEST_P1P2_SEL
 * @return new value of TEST.TEST_VS1
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_P1P2_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_P1P2_SEL__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_P1P2_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS1__VS_TEST_P1P2_SEL__EXTRACT() extracts TEST_VS1.VS_TEST_P1P2_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS1
 * @return current value of TEST_VS1.VS_TEST_P1P2_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_P1P2_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS1__VS_TEST_P1P2_SEL__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_P1P2_SEL__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TEST.TEST_VS1.VS_TEST_MODE ----------------------- */

/**
<pre>
  TEST.TEST_VS1.VS_TEST_MODE:

    VS ADC test mode control.
    <start table_with_header>
    [3:0] "Test / BIST Mode"
    0 "Normal Operation"
    1 "DNL Measurement (Sweep)"
    2 "DNL Measurement (Single Step)"
    3 "Gain Calibration"
    4 "Gain Re-Measurement"
    5 "Offset Calibration"
    6 "Offset Re-Measurement"
    7 "Continuous ADC Averager"
    8 "Stress Compensation Loop Measurement with dither (Sweep)"
    9 "Stress Compensation Loop Measurement without dither (Sweep)"
    10 "Stress Compensation Loop Measurement with dither (Single Step)"
    11 "Stress Compensation Loop Measurement without dither (Single Step)"
    12-15 "Reserved"
    <end table>

</pre> */

#define TEST_TEST_VS1__VS_TEST_MODE__Pos                        11                                                                     /*!< Right-most bit position of vs_test_mode in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_MODE__Msk                        (0x0000000FUL << TEST_TEST_VS1__VS_TEST_MODE__Pos)                     /*!< Mask for vs_test_mode in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_MODE__Shift(v)                   (((v) << TEST_TEST_VS1__VS_TEST_MODE__Pos) & TEST_TEST_VS1__VS_TEST_MODE__Msk) /*!< Shift value 'v' into vs_test_mode and mask 'v' to fit it into vs_test_mode field */

/** TEST_TEST_VS1__VS_TEST_MODE__SET() sets TEST_VS1.VS_TEST_MODE to given value.
 *
 * When writing to TEST_VS1.VS_TEST_MODE, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS1.VS_TEST_MODE
 */
__TEST_INLINE void TEST_TEST_VS1__VS_TEST_MODE__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_MODE__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_MODE__Shift((uint32_t)bf_value)));
    TEST_TEST_VS1__SET(reg);
}

/** TEST_TEST_VS1__VS_TEST_MODE__GET() gets TEST_VS1.VS_TEST_MODE's current value.
 *
 * When reading from TEST_VS1.VS_TEST_MODE, this is recommended to use.
 *
 * @return current value of TEST_VS1.VS_TEST_MODE
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_MODE__GET(void)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & TEST_TEST_VS1__VS_TEST_MODE__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_MODE__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS1__VS_TEST_MODE__MODIFY() modifies TEST_VS1.VS_TEST_MODE.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS1
 * @param bf_value new value for TEST_VS1.VS_TEST_MODE
 * @return new value of TEST.TEST_VS1
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_MODE__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS1__VS_TEST_MODE__EXTRACT() extracts TEST_VS1.VS_TEST_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS1
 * @return current value of TEST_VS1.VS_TEST_MODE
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS1__VS_TEST_MODE__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_MODE__Pos);
    return (uint32_t)reg;
}

/* -------------------- TEST.TEST_VS1.VS_TEST_DNL_LIMIT -------------------- */

/**
<pre>
  TEST.TEST_VS1.VS_TEST_DNL_LIMIT:

    VS ADC DNL BIST error limit.

</pre> */

#define TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Pos                   8                                                                      /*!< Right-most bit position of vs_test_dnl_limit in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Msk                   (0x00000007UL << TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Pos)                /*!< Mask for vs_test_dnl_limit in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Shift(v)              (((v) << TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Pos) & TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Msk) /*!< Shift value 'v' into vs_test_dnl_limit and mask 'v' to fit it into vs_test_dnl_limit field */

/** TEST_TEST_VS1__VS_TEST_DNL_LIMIT__SET() sets TEST_VS1.VS_TEST_DNL_LIMIT to given value.
 *
 * When writing to TEST_VS1.VS_TEST_DNL_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS1.VS_TEST_DNL_LIMIT
 */
__TEST_INLINE void TEST_TEST_VS1__VS_TEST_DNL_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_VS1__SET(reg);
}

/** TEST_TEST_VS1__VS_TEST_DNL_LIMIT__GET() gets TEST_VS1.VS_TEST_DNL_LIMIT's current value.
 *
 * When reading from TEST_VS1.VS_TEST_DNL_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_VS1.VS_TEST_DNL_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_DNL_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS1__VS_TEST_DNL_LIMIT__MODIFY() modifies TEST_VS1.VS_TEST_DNL_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS1
 * @param bf_value new value for TEST_VS1.VS_TEST_DNL_LIMIT
 * @return new value of TEST.TEST_VS1
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_DNL_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS1__VS_TEST_DNL_LIMIT__EXTRACT() extracts TEST_VS1.VS_TEST_DNL_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS1
 * @return current value of TEST_VS1.VS_TEST_DNL_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_DNL_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_DNL_LIMIT__Pos);
    return (uint32_t)reg;
}

/* ------------------ TEST.TEST_VS1.VS_TEST_GAIN_EXPECTED ------------------ */

/**
<pre>
  TEST.TEST_VS1.VS_TEST_GAIN_EXPECTED:

    VS ADC Gain BIST expected value.

</pre> */

#define TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Pos               0                                                                      /*!< Right-most bit position of vs_test_gain_expected in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Msk               (0x000000FFUL << TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Pos)            /*!< Mask for vs_test_gain_expected in TEST.TEST_VS1 */
#define TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Shift(v)          (((v) << TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Pos) & TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Msk) /*!< Shift value 'v' into vs_test_gain_expected and mask 'v' to fit it into vs_test_gain_expected field */

/** TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__SET() sets TEST_VS1.VS_TEST_GAIN_EXPECTED to given value.
 *
 * When writing to TEST_VS1.VS_TEST_GAIN_EXPECTED, this is recommended to use.
 *
 * @param bf_value new value for TEST_VS1.VS_TEST_GAIN_EXPECTED
 */
__TEST_INLINE void TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Shift((uint32_t)bf_value)));
    TEST_TEST_VS1__SET(reg);
}

/** TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__GET() gets TEST_VS1.VS_TEST_GAIN_EXPECTED's current value.
 *
 * When reading from TEST_VS1.VS_TEST_GAIN_EXPECTED, this is recommended to use.
 *
 * @return current value of TEST_VS1.VS_TEST_GAIN_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__GET(void)
{
    uint32_t reg = TEST_TEST_VS1__GET();
    reg = (reg & TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__MODIFY() modifies TEST_VS1.VS_TEST_GAIN_EXPECTED.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_VS1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_VS1
 * @param bf_value new value for TEST_VS1.VS_TEST_GAIN_EXPECTED
 * @return new value of TEST.TEST_VS1
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Msk);
    reg = (reg | (TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__EXTRACT() extracts TEST_VS1.VS_TEST_GAIN_EXPECTED.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_VS1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_VS1
 * @return current value of TEST_VS1.VS_TEST_GAIN_EXPECTED
 */
__TEST_INLINE uint32_t TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Msk);
    reg = (reg >> TEST_TEST_VS1__VS_TEST_GAIN_EXPECTED__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TEST_RAMP_GEN member of TEST_t                       */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_RAMP_GEN__ADDRESS returns the address of member TEST_RAMP_GEN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_RAMP_GEN
 */
__TEST_INLINE uint32_t* __TEST_TEST_RAMP_GEN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_RAMP_GEN)));
}

/** TEST_TEST_RAMP_GEN__SET() sets TEST_RAMP_GEN to given value.
 *
 * When writing to TEST_RAMP_GEN, this is mandatory to use.
 *
 * @param value new value for TEST_RAMP_GEN
 */
__TEST_INLINE void TEST_TEST_RAMP_GEN__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_RAMP_GEN__ADDRESS(), value);
}

/** TEST_TEST_RAMP_GEN__GET() gets TEST_RAMP_GEN's current value.
 *
 * When reading from TEST_RAMP_GEN, this is mandatory to use.
 *
 * @return current value of TEST_RAMP_GEN
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__GET(void)
{
    return HAL_GET32(__TEST_TEST_RAMP_GEN__ADDRESS());
}

/* -------------------- TEST.TEST_RAMP_GEN.RAMP_GEN_ARM -------------------- */

/**
<pre>
  TEST.TEST_RAMP_GEN.RAMP_GEN_ARM:

    BIST DAC ramp generation arm counter signal
    <start table>
    0 "ramp counter reset to min count"
    1 "ramp generator armed for counting, will start based on ramp_gen_start_mode"
    <end table>

</pre> */

#define TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Pos                   30                                                                     /*!< Right-most bit position of ramp_gen_arm in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Msk                   (0x00000001UL << TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Pos)                /*!< Mask for ramp_gen_arm in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Shift(v)              (((v) << TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Pos) & TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Msk) /*!< Shift value 'v' into ramp_gen_arm and mask 'v' to fit it into ramp_gen_arm field */

/** TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__SET() sets TEST_RAMP_GEN.RAMP_GEN_ARM to given value.
 *
 * When writing to TEST_RAMP_GEN.RAMP_GEN_ARM, this is recommended to use.
 *
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_ARM
 */
__TEST_INLINE void TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Shift((uint32_t)bf_value)));
    TEST_TEST_RAMP_GEN__SET(reg);
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__GET() gets TEST_RAMP_GEN.RAMP_GEN_ARM's current value.
 *
 * When reading from TEST_RAMP_GEN.RAMP_GEN_ARM, this is recommended to use.
 *
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_ARM
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__GET(void)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__MODIFY() modifies TEST_RAMP_GEN.RAMP_GEN_ARM.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_RAMP_GEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_ARM
 * @return new value of TEST.TEST_RAMP_GEN
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__EXTRACT() extracts TEST_RAMP_GEN.RAMP_GEN_ARM.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_RAMP_GEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_ARM
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_ARM__Pos);
    return (uint32_t)reg;
}

/* ------------------ TEST.TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT ------------------ */

/**
<pre>
  TEST.TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT:

    BIST DAC ramp generator clock source select
    <start table>
    0 "Internal clock"
    1 "External clock"
    <end table>

</pre> */

#define TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Pos              29                                                                     /*!< Right-most bit position of ramp_gen_one_shot in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Msk              (0x00000001UL << TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Pos)           /*!< Mask for ramp_gen_one_shot in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Shift(v)         (((v) << TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Pos) & TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Msk) /*!< Shift value 'v' into ramp_gen_one_shot and mask 'v' to fit it into ramp_gen_one_shot field */

/** TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__SET() sets TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT to given value.
 *
 * When writing to TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT, this is recommended to use.
 *
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT
 */
__TEST_INLINE void TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Shift((uint32_t)bf_value)));
    TEST_TEST_RAMP_GEN__SET(reg);
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__GET() gets TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT's current value.
 *
 * When reading from TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT, this is recommended to use.
 *
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__GET(void)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__MODIFY() modifies TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_RAMP_GEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT
 * @return new value of TEST.TEST_RAMP_GEN
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__EXTRACT() extracts TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_RAMP_GEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_ONE_SHOT
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_ONE_SHOT__Pos);
    return (uint32_t)reg;
}

/* ------------------- TEST.TEST_RAMP_GEN.RAMP_GEN_START ------------------- */

/**
<pre>
  TEST.TEST_RAMP_GEN.RAMP_GEN_START:

    BIST DAC ramp generator start signal.  When selected via ramp_gen_start_mode, this register enables or disables the ramp generator.
    <start table>
    0 "ramp generator disabled"
    1 "ramp generator enabled"
    <end table>

</pre> */

#define TEST_TEST_RAMP_GEN__RAMP_GEN_START__Pos                 28                                                                     /*!< Right-most bit position of ramp_gen_start in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_START__Msk                 (0x00000001UL << TEST_TEST_RAMP_GEN__RAMP_GEN_START__Pos)              /*!< Mask for ramp_gen_start in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_START__Shift(v)            (((v) << TEST_TEST_RAMP_GEN__RAMP_GEN_START__Pos) & TEST_TEST_RAMP_GEN__RAMP_GEN_START__Msk) /*!< Shift value 'v' into ramp_gen_start and mask 'v' to fit it into ramp_gen_start field */

/** TEST_TEST_RAMP_GEN__RAMP_GEN_START__SET() sets TEST_RAMP_GEN.RAMP_GEN_START to given value.
 *
 * When writing to TEST_RAMP_GEN.RAMP_GEN_START, this is recommended to use.
 *
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_START
 */
__TEST_INLINE void TEST_TEST_RAMP_GEN__RAMP_GEN_START__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_START__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_START__Shift((uint32_t)bf_value)));
    TEST_TEST_RAMP_GEN__SET(reg);
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_START__GET() gets TEST_RAMP_GEN.RAMP_GEN_START's current value.
 *
 * When reading from TEST_RAMP_GEN.RAMP_GEN_START, this is recommended to use.
 *
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_START
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_START__GET(void)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_START__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_START__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_START__MODIFY() modifies TEST_RAMP_GEN.RAMP_GEN_START.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_RAMP_GEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_START
 * @return new value of TEST.TEST_RAMP_GEN
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_START__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_START__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_START__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_START__EXTRACT() extracts TEST_RAMP_GEN.RAMP_GEN_START.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_RAMP_GEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_START
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_START__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_START__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_START__Pos);
    return (uint32_t)reg;
}

/* ----------------- TEST.TEST_RAMP_GEN.RAMP_GEN_START_MODE ----------------- */

/**
<pre>
  TEST.TEST_RAMP_GEN.RAMP_GEN_START_MODE:

    BIST DAC ramp generator start mode select.
    <start table>
    0 "Ramp generator start after 2048 internal clocks"
    1 "Ramp generator start based on state of ramp_gen_start"
    <end table>

</pre> */

#define TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Pos            27                                                                     /*!< Right-most bit position of ramp_gen_start_mode in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Msk            (0x00000001UL << TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Pos)         /*!< Mask for ramp_gen_start_mode in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Shift(v)       (((v) << TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Pos) & TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Msk) /*!< Shift value 'v' into ramp_gen_start_mode and mask 'v' to fit it into ramp_gen_start_mode field */

/** TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__SET() sets TEST_RAMP_GEN.RAMP_GEN_START_MODE to given value.
 *
 * When writing to TEST_RAMP_GEN.RAMP_GEN_START_MODE, this is recommended to use.
 *
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_START_MODE
 */
__TEST_INLINE void TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Shift((uint32_t)bf_value)));
    TEST_TEST_RAMP_GEN__SET(reg);
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__GET() gets TEST_RAMP_GEN.RAMP_GEN_START_MODE's current value.
 *
 * When reading from TEST_RAMP_GEN.RAMP_GEN_START_MODE, this is recommended to use.
 *
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_START_MODE
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__GET(void)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__MODIFY() modifies TEST_RAMP_GEN.RAMP_GEN_START_MODE.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_RAMP_GEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_START_MODE
 * @return new value of TEST.TEST_RAMP_GEN
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__EXTRACT() extracts TEST_RAMP_GEN.RAMP_GEN_START_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_RAMP_GEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_START_MODE
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_START_MODE__Pos);
    return (uint32_t)reg;
}

/* -------------------- TEST.TEST_RAMP_GEN.RAMP_GEN_TYPE -------------------- */

/**
<pre>
  TEST.TEST_RAMP_GEN.RAMP_GEN_TYPE:

    BIST DAC ramp generator waveform shape select.
    <start table>
    0 "Saw tooth wave"
    1 "Triangle wave"
    <end table>

</pre> */

#define TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Pos                  26                                                                     /*!< Right-most bit position of ramp_gen_type in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Msk                  (0x00000001UL << TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Pos)               /*!< Mask for ramp_gen_type in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Shift(v)             (((v) << TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Pos) & TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Msk) /*!< Shift value 'v' into ramp_gen_type and mask 'v' to fit it into ramp_gen_type field */

/** TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__SET() sets TEST_RAMP_GEN.RAMP_GEN_TYPE to given value.
 *
 * When writing to TEST_RAMP_GEN.RAMP_GEN_TYPE, this is recommended to use.
 *
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_TYPE
 */
__TEST_INLINE void TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Shift((uint32_t)bf_value)));
    TEST_TEST_RAMP_GEN__SET(reg);
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__GET() gets TEST_RAMP_GEN.RAMP_GEN_TYPE's current value.
 *
 * When reading from TEST_RAMP_GEN.RAMP_GEN_TYPE, this is recommended to use.
 *
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_TYPE
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__GET(void)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__MODIFY() modifies TEST_RAMP_GEN.RAMP_GEN_TYPE.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_RAMP_GEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_TYPE
 * @return new value of TEST.TEST_RAMP_GEN
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__EXTRACT() extracts TEST_RAMP_GEN.RAMP_GEN_TYPE.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_RAMP_GEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_TYPE
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_TYPE__Pos);
    return (uint32_t)reg;
}

/* ----------------- TEST.TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT ----------------- */

/**
<pre>
  TEST.TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT:

    BIST DAC ramp dwell time.  Defines the time spent at each step in the ramp.

</pre> */

#define TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Pos             16                                                                     /*!< Right-most bit position of ramp_gen_dwell_cnt in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Msk             (0x000003FFUL << TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Pos)          /*!< Mask for ramp_gen_dwell_cnt in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Shift(v)        (((v) << TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Pos) & TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Msk) /*!< Shift value 'v' into ramp_gen_dwell_cnt and mask 'v' to fit it into ramp_gen_dwell_cnt field */

/** TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__SET() sets TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT to given value.
 *
 * When writing to TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT, this is recommended to use.
 *
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT
 */
__TEST_INLINE void TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Shift((uint32_t)bf_value)));
    TEST_TEST_RAMP_GEN__SET(reg);
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__GET() gets TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT's current value.
 *
 * When reading from TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT, this is recommended to use.
 *
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__GET(void)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__MODIFY() modifies TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_RAMP_GEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT
 * @return new value of TEST.TEST_RAMP_GEN
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__EXTRACT() extracts TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_RAMP_GEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_DWELL_CNT
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_DWELL_CNT__Pos);
    return (uint32_t)reg;
}

/* ------------------ TEST.TEST_RAMP_GEN.RAMP_GEN_MAX_CNT ------------------ */

/**
<pre>
  TEST.TEST_RAMP_GEN.RAMP_GEN_MAX_CNT:

    BIST DAC ramp maximum count.

</pre> */

#define TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Pos               8                                                                      /*!< Right-most bit position of ramp_gen_max_cnt in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Msk               (0x000000FFUL << TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Pos)            /*!< Mask for ramp_gen_max_cnt in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Shift(v)          (((v) << TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Pos) & TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Msk) /*!< Shift value 'v' into ramp_gen_max_cnt and mask 'v' to fit it into ramp_gen_max_cnt field */

/** TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__SET() sets TEST_RAMP_GEN.RAMP_GEN_MAX_CNT to given value.
 *
 * When writing to TEST_RAMP_GEN.RAMP_GEN_MAX_CNT, this is recommended to use.
 *
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_MAX_CNT
 */
__TEST_INLINE void TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Shift((uint32_t)bf_value)));
    TEST_TEST_RAMP_GEN__SET(reg);
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__GET() gets TEST_RAMP_GEN.RAMP_GEN_MAX_CNT's current value.
 *
 * When reading from TEST_RAMP_GEN.RAMP_GEN_MAX_CNT, this is recommended to use.
 *
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_MAX_CNT
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__GET(void)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__MODIFY() modifies TEST_RAMP_GEN.RAMP_GEN_MAX_CNT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_RAMP_GEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_MAX_CNT
 * @return new value of TEST.TEST_RAMP_GEN
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__EXTRACT() extracts TEST_RAMP_GEN.RAMP_GEN_MAX_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_RAMP_GEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_MAX_CNT
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_MAX_CNT__Pos);
    return (uint32_t)reg;
}

/* ------------------ TEST.TEST_RAMP_GEN.RAMP_GEN_MIN_CNT ------------------ */

/**
<pre>
  TEST.TEST_RAMP_GEN.RAMP_GEN_MIN_CNT:

    BIST DAC ramp minimum count.

</pre> */

#define TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Pos               0                                                                      /*!< Right-most bit position of ramp_gen_min_cnt in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Msk               (0x000000FFUL << TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Pos)            /*!< Mask for ramp_gen_min_cnt in TEST.TEST_RAMP_GEN */
#define TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Shift(v)          (((v) << TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Pos) & TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Msk) /*!< Shift value 'v' into ramp_gen_min_cnt and mask 'v' to fit it into ramp_gen_min_cnt field */

/** TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__SET() sets TEST_RAMP_GEN.RAMP_GEN_MIN_CNT to given value.
 *
 * When writing to TEST_RAMP_GEN.RAMP_GEN_MIN_CNT, this is recommended to use.
 *
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_MIN_CNT
 */
__TEST_INLINE void TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Shift((uint32_t)bf_value)));
    TEST_TEST_RAMP_GEN__SET(reg);
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__GET() gets TEST_RAMP_GEN.RAMP_GEN_MIN_CNT's current value.
 *
 * When reading from TEST_RAMP_GEN.RAMP_GEN_MIN_CNT, this is recommended to use.
 *
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_MIN_CNT
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__GET(void)
{
    uint32_t reg = TEST_TEST_RAMP_GEN__GET();
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__MODIFY() modifies TEST_RAMP_GEN.RAMP_GEN_MIN_CNT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_RAMP_GEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @param bf_value new value for TEST_RAMP_GEN.RAMP_GEN_MIN_CNT
 * @return new value of TEST.TEST_RAMP_GEN
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Msk);
    reg = (reg | (TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__EXTRACT() extracts TEST_RAMP_GEN.RAMP_GEN_MIN_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_RAMP_GEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_RAMP_GEN
 * @return current value of TEST_RAMP_GEN.RAMP_GEN_MIN_CNT
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Msk);
    reg = (reg >> TEST_TEST_RAMP_GEN__RAMP_GEN_MIN_CNT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TEST_RAMP_DLY member of TEST_t                       */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_RAMP_DLY__ADDRESS returns the address of member TEST_RAMP_DLY.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_RAMP_DLY
 */
__TEST_INLINE uint32_t* __TEST_TEST_RAMP_DLY__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_RAMP_DLY)));
}

/** TEST_TEST_RAMP_DLY__SET() sets TEST_RAMP_DLY to given value.
 *
 * When writing to TEST_RAMP_DLY, this is mandatory to use.
 *
 * @param value new value for TEST_RAMP_DLY
 */
__TEST_INLINE void TEST_TEST_RAMP_DLY__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_RAMP_DLY__ADDRESS(), value);
}

/** TEST_TEST_RAMP_DLY__GET() gets TEST_RAMP_DLY's current value.
 *
 * When reading from TEST_RAMP_DLY, this is mandatory to use.
 *
 * @return current value of TEST_RAMP_DLY
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_DLY__GET(void)
{
    return HAL_GET32(__TEST_TEST_RAMP_DLY__ADDRESS());
}

/* -------------------- TEST.TEST_RAMP_DLY.RAMP_DLY_TIME -------------------- */

/**
<pre>
  TEST.TEST_RAMP_DLY.RAMP_DLY_TIME:

    IS, VS, TS BIST start-of measurement delay time

</pre> */

#define TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Pos                  0                                                                      /*!< Right-most bit position of ramp_dly_time in TEST.TEST_RAMP_DLY */
#define TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Msk                  (0x000000FFUL << TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Pos)               /*!< Mask for ramp_dly_time in TEST.TEST_RAMP_DLY */
#define TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Shift(v)             (((v) << TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Pos) & TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Msk) /*!< Shift value 'v' into ramp_dly_time and mask 'v' to fit it into ramp_dly_time field */

/** TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__SET() sets TEST_RAMP_DLY.RAMP_DLY_TIME to given value.
 *
 * When writing to TEST_RAMP_DLY.RAMP_DLY_TIME, this is recommended to use.
 *
 * @param bf_value new value for TEST_RAMP_DLY.RAMP_DLY_TIME
 */
__TEST_INLINE void TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_RAMP_DLY__GET();
    reg = (reg & ~TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Msk);
    reg = (reg | (TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Shift((uint32_t)bf_value)));
    TEST_TEST_RAMP_DLY__SET(reg);
}

/** TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__GET() gets TEST_RAMP_DLY.RAMP_DLY_TIME's current value.
 *
 * When reading from TEST_RAMP_DLY.RAMP_DLY_TIME, this is recommended to use.
 *
 * @return current value of TEST_RAMP_DLY.RAMP_DLY_TIME
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__GET(void)
{
    uint32_t reg = TEST_TEST_RAMP_DLY__GET();
    reg = (reg & TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Msk);
    reg = (reg >> TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__MODIFY() modifies TEST_RAMP_DLY.RAMP_DLY_TIME.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_RAMP_DLY.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_RAMP_DLY
 * @param bf_value new value for TEST_RAMP_DLY.RAMP_DLY_TIME
 * @return new value of TEST.TEST_RAMP_DLY
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Msk);
    reg = (reg | (TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__EXTRACT() extracts TEST_RAMP_DLY.RAMP_DLY_TIME.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_RAMP_DLY.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_RAMP_DLY
 * @return current value of TEST_RAMP_DLY.RAMP_DLY_TIME
 */
__TEST_INLINE uint32_t TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Msk);
    reg = (reg >> TEST_TEST_RAMP_DLY__RAMP_DLY_TIME__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TEST_LO_CLK1 member of TEST_t                       */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_LO_CLK1__ADDRESS returns the address of member TEST_LO_CLK1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_LO_CLK1
 */
__TEST_INLINE uint32_t* __TEST_TEST_LO_CLK1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_LO_CLK1)));
}

/** TEST_TEST_LO_CLK1__SET() sets TEST_LO_CLK1 to given value.
 *
 * When writing to TEST_LO_CLK1, this is mandatory to use.
 *
 * @param value new value for TEST_LO_CLK1
 */
__TEST_INLINE void TEST_TEST_LO_CLK1__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_LO_CLK1__ADDRESS(), value);
}

/** TEST_TEST_LO_CLK1__GET() gets TEST_LO_CLK1's current value.
 *
 * When reading from TEST_LO_CLK1, this is mandatory to use.
 *
 * @return current value of TEST_LO_CLK1
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK1__GET(void)
{
    return HAL_GET32(__TEST_TEST_LO_CLK1__ADDRESS());
}

/* ---------------- TEST.TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT ---------------- */

/**
<pre>
  TEST.TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT:

    LO Clock BIST trim code error limit.

</pre> */

#define TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Pos           0                                                                      /*!< Right-most bit position of lo_clk_trim_err_limit in TEST.TEST_LO_CLK1 */
#define TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Msk           (0x0000007FUL << TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Pos)        /*!< Mask for lo_clk_trim_err_limit in TEST.TEST_LO_CLK1 */
#define TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Shift(v)      (((v) << TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Pos) & TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Msk) /*!< Shift value 'v' into lo_clk_trim_err_limit and mask 'v' to fit it into lo_clk_trim_err_limit field */

/** TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__SET() sets TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT to given value.
 *
 * When writing to TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT, this is recommended to use.
 *
 * @param bf_value new value for TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT
 */
__TEST_INLINE void TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_LO_CLK1__GET();
    reg = (reg & ~TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Msk);
    reg = (reg | (TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Shift((uint32_t)bf_value)));
    TEST_TEST_LO_CLK1__SET(reg);
}

/** TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__GET() gets TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT's current value.
 *
 * When reading from TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT, this is recommended to use.
 *
 * @return current value of TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__GET(void)
{
    uint32_t reg = TEST_TEST_LO_CLK1__GET();
    reg = (reg & TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Msk);
    reg = (reg >> TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__MODIFY() modifies TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_LO_CLK1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_LO_CLK1
 * @param bf_value new value for TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT
 * @return new value of TEST.TEST_LO_CLK1
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Msk);
    reg = (reg | (TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__EXTRACT() extracts TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_LO_CLK1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_LO_CLK1
 * @return current value of TEST_LO_CLK1.LO_CLK_TRIM_ERR_LIMIT
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Msk);
    reg = (reg >> TEST_TEST_LO_CLK1__LO_CLK_TRIM_ERR_LIMIT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       TEST_LO_CLK2 member of TEST_t                       */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_LO_CLK2__ADDRESS returns the address of member TEST_LO_CLK2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_LO_CLK2
 */
__TEST_INLINE uint32_t* __TEST_TEST_LO_CLK2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_LO_CLK2)));
}

/** TEST_TEST_LO_CLK2__SET() sets TEST_LO_CLK2 to given value.
 *
 * When writing to TEST_LO_CLK2, this is mandatory to use.
 *
 * @param value new value for TEST_LO_CLK2
 */
__TEST_INLINE void TEST_TEST_LO_CLK2__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_LO_CLK2__ADDRESS(), value);
}

/** TEST_TEST_LO_CLK2__GET() gets TEST_LO_CLK2's current value.
 *
 * When reading from TEST_LO_CLK2, this is mandatory to use.
 *
 * @return current value of TEST_LO_CLK2
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__GET(void)
{
    return HAL_GET32(__TEST_TEST_LO_CLK2__ADDRESS());
}

/* ----------------- TEST.TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN ----------------- */

/**
<pre>
  TEST.TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN:

    LO Clock BIST (20MHz mode) enable control.  When enabled, the BIST function will self trim the LO Clock.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Pos            3                                                                      /*!< Right-most bit position of lo_clk_20mhz_trim_en in TEST.TEST_LO_CLK2 */
#define TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Msk            (0x00000001UL << TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Pos)         /*!< Mask for lo_clk_20mhz_trim_en in TEST.TEST_LO_CLK2 */
#define TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Shift(v)       (((v) << TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Pos) & TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Msk) /*!< Shift value 'v' into lo_clk_20mhz_trim_en and mask 'v' to fit it into lo_clk_20mhz_trim_en field */

/** TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__SET() sets TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN to given value.
 *
 * When writing to TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN
 */
__TEST_INLINE void TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_LO_CLK2__GET();
    reg = (reg & ~TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Msk);
    reg = (reg | (TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_LO_CLK2__SET(reg);
}

/** TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__GET() gets TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN's current value.
 *
 * When reading from TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN, this is recommended to use.
 *
 * @return current value of TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__GET(void)
{
    uint32_t reg = TEST_TEST_LO_CLK2__GET();
    reg = (reg & TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Msk);
    reg = (reg >> TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__MODIFY() modifies TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_LO_CLK2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_LO_CLK2
 * @param bf_value new value for TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN
 * @return new value of TEST.TEST_LO_CLK2
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Msk);
    reg = (reg | (TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__EXTRACT() extracts TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_LO_CLK2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_LO_CLK2
 * @return current value of TEST_LO_CLK2.LO_CLK_20MHZ_TRIM_EN
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Msk);
    reg = (reg >> TEST_TEST_LO_CLK2__LO_CLK_20MHZ_TRIM_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------- TEST.TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN ----------------- */

/**
<pre>
  TEST.TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN:

    LO Clock BIST (20MHz mode) trim error measurement enable.  When enabled, the BIST will measure the LO Clock trim error.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Pos            2                                                                      /*!< Right-most bit position of lo_clk_20mhz_meas_en in TEST.TEST_LO_CLK2 */
#define TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Msk            (0x00000001UL << TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Pos)         /*!< Mask for lo_clk_20mhz_meas_en in TEST.TEST_LO_CLK2 */
#define TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Shift(v)       (((v) << TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Pos) & TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Msk) /*!< Shift value 'v' into lo_clk_20mhz_meas_en and mask 'v' to fit it into lo_clk_20mhz_meas_en field */

/** TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__SET() sets TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN to given value.
 *
 * When writing to TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN
 */
__TEST_INLINE void TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_LO_CLK2__GET();
    reg = (reg & ~TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Msk);
    reg = (reg | (TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_LO_CLK2__SET(reg);
}

/** TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__GET() gets TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN's current value.
 *
 * When reading from TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN, this is recommended to use.
 *
 * @return current value of TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__GET(void)
{
    uint32_t reg = TEST_TEST_LO_CLK2__GET();
    reg = (reg & TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Msk);
    reg = (reg >> TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__MODIFY() modifies TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_LO_CLK2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_LO_CLK2
 * @param bf_value new value for TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN
 * @return new value of TEST.TEST_LO_CLK2
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Msk);
    reg = (reg | (TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__EXTRACT() extracts TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_LO_CLK2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_LO_CLK2
 * @return current value of TEST_LO_CLK2.LO_CLK_20MHZ_MEAS_EN
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Msk);
    reg = (reg >> TEST_TEST_LO_CLK2__LO_CLK_20MHZ_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- TEST.TEST_LO_CLK2.LO_CLK_TRIM_EN -------------------- */

/**
<pre>
  TEST.TEST_LO_CLK2.LO_CLK_TRIM_EN:

    LO Clock BIST (200MHz mode) enable control.  When enabled, the BIST function will self trim the LO Clock.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Pos                  1                                                                      /*!< Right-most bit position of lo_clk_trim_en in TEST.TEST_LO_CLK2 */
#define TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Msk                  (0x00000001UL << TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Pos)               /*!< Mask for lo_clk_trim_en in TEST.TEST_LO_CLK2 */
#define TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Shift(v)             (((v) << TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Pos) & TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Msk) /*!< Shift value 'v' into lo_clk_trim_en and mask 'v' to fit it into lo_clk_trim_en field */

/** TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__SET() sets TEST_LO_CLK2.LO_CLK_TRIM_EN to given value.
 *
 * When writing to TEST_LO_CLK2.LO_CLK_TRIM_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_LO_CLK2.LO_CLK_TRIM_EN
 */
__TEST_INLINE void TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_LO_CLK2__GET();
    reg = (reg & ~TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Msk);
    reg = (reg | (TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_LO_CLK2__SET(reg);
}

/** TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__GET() gets TEST_LO_CLK2.LO_CLK_TRIM_EN's current value.
 *
 * When reading from TEST_LO_CLK2.LO_CLK_TRIM_EN, this is recommended to use.
 *
 * @return current value of TEST_LO_CLK2.LO_CLK_TRIM_EN
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__GET(void)
{
    uint32_t reg = TEST_TEST_LO_CLK2__GET();
    reg = (reg & TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Msk);
    reg = (reg >> TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__MODIFY() modifies TEST_LO_CLK2.LO_CLK_TRIM_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_LO_CLK2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_LO_CLK2
 * @param bf_value new value for TEST_LO_CLK2.LO_CLK_TRIM_EN
 * @return new value of TEST.TEST_LO_CLK2
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Msk);
    reg = (reg | (TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__EXTRACT() extracts TEST_LO_CLK2.LO_CLK_TRIM_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_LO_CLK2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_LO_CLK2
 * @return current value of TEST_LO_CLK2.LO_CLK_TRIM_EN
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Msk);
    reg = (reg >> TEST_TEST_LO_CLK2__LO_CLK_TRIM_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- TEST.TEST_LO_CLK2.LO_CLK_MEAS_EN -------------------- */

/**
<pre>
  TEST.TEST_LO_CLK2.LO_CLK_MEAS_EN:

    LO Clock BIST (200MHz mode) trim error measurement enable.  When enabled, the BIST will measure the LO Clock trim error.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Pos                  0                                                                      /*!< Right-most bit position of lo_clk_meas_en in TEST.TEST_LO_CLK2 */
#define TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Msk                  (0x00000001UL << TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Pos)               /*!< Mask for lo_clk_meas_en in TEST.TEST_LO_CLK2 */
#define TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Shift(v)             (((v) << TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Pos) & TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Msk) /*!< Shift value 'v' into lo_clk_meas_en and mask 'v' to fit it into lo_clk_meas_en field */

/** TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__SET() sets TEST_LO_CLK2.LO_CLK_MEAS_EN to given value.
 *
 * When writing to TEST_LO_CLK2.LO_CLK_MEAS_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_LO_CLK2.LO_CLK_MEAS_EN
 */
__TEST_INLINE void TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_LO_CLK2__GET();
    reg = (reg & ~TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Msk);
    reg = (reg | (TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_LO_CLK2__SET(reg);
}

/** TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__GET() gets TEST_LO_CLK2.LO_CLK_MEAS_EN's current value.
 *
 * When reading from TEST_LO_CLK2.LO_CLK_MEAS_EN, this is recommended to use.
 *
 * @return current value of TEST_LO_CLK2.LO_CLK_MEAS_EN
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__GET(void)
{
    uint32_t reg = TEST_TEST_LO_CLK2__GET();
    reg = (reg & TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Msk);
    reg = (reg >> TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__MODIFY() modifies TEST_LO_CLK2.LO_CLK_MEAS_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_LO_CLK2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_LO_CLK2
 * @param bf_value new value for TEST_LO_CLK2.LO_CLK_MEAS_EN
 * @return new value of TEST.TEST_LO_CLK2
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Msk);
    reg = (reg | (TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__EXTRACT() extracts TEST_LO_CLK2.LO_CLK_MEAS_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_LO_CLK2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_LO_CLK2
 * @return current value of TEST_LO_CLK2.LO_CLK_MEAS_EN
 */
__TEST_INLINE uint32_t TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Msk);
    reg = (reg >> TEST_TEST_LO_CLK2__LO_CLK_MEAS_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        TEST_CONFIG member of TEST_t                        */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_CONFIG__ADDRESS returns the address of member TEST_CONFIG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_CONFIG
 */
__TEST_INLINE uint32_t* __TEST_TEST_CONFIG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_CONFIG)));
}

/** TEST_TEST_CONFIG__SET() sets TEST_CONFIG to given value.
 *
 * When writing to TEST_CONFIG, this is mandatory to use.
 *
 * @param value new value for TEST_CONFIG
 */
__TEST_INLINE void TEST_TEST_CONFIG__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_CONFIG__ADDRESS(), value);
}

/** TEST_TEST_CONFIG__GET() gets TEST_CONFIG's current value.
 *
 * When reading from TEST_CONFIG, this is mandatory to use.
 *
 * @return current value of TEST_CONFIG
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__GET(void)
{
    return HAL_GET32(__TEST_TEST_CONFIG__ADDRESS());
}

/* --------------------- TEST.TEST_CONFIG.IADC_SRC_SEL --------------------- */

/**
<pre>
  TEST.TEST_CONFIG.IADC_SRC_SEL:

    Not used

</pre> */

#define TEST_TEST_CONFIG__IADC_SRC_SEL__Pos                     7                                                                      /*!< Right-most bit position of iadc_src_sel in TEST.TEST_CONFIG */
#define TEST_TEST_CONFIG__IADC_SRC_SEL__Msk                     (0x00000001UL << TEST_TEST_CONFIG__IADC_SRC_SEL__Pos)                  /*!< Mask for iadc_src_sel in TEST.TEST_CONFIG */
#define TEST_TEST_CONFIG__IADC_SRC_SEL__Shift(v)                (((v) << TEST_TEST_CONFIG__IADC_SRC_SEL__Pos) & TEST_TEST_CONFIG__IADC_SRC_SEL__Msk) /*!< Shift value 'v' into iadc_src_sel and mask 'v' to fit it into iadc_src_sel field */

/** TEST_TEST_CONFIG__IADC_SRC_SEL__SET() sets TEST_CONFIG.IADC_SRC_SEL to given value.
 *
 * When writing to TEST_CONFIG.IADC_SRC_SEL, this is recommended to use.
 *
 * @param bf_value new value for TEST_CONFIG.IADC_SRC_SEL
 */
__TEST_INLINE void TEST_TEST_CONFIG__IADC_SRC_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_CONFIG__GET();
    reg = (reg & ~TEST_TEST_CONFIG__IADC_SRC_SEL__Msk);
    reg = (reg | (TEST_TEST_CONFIG__IADC_SRC_SEL__Shift((uint32_t)bf_value)));
    TEST_TEST_CONFIG__SET(reg);
}

/** TEST_TEST_CONFIG__IADC_SRC_SEL__GET() gets TEST_CONFIG.IADC_SRC_SEL's current value.
 *
 * When reading from TEST_CONFIG.IADC_SRC_SEL, this is recommended to use.
 *
 * @return current value of TEST_CONFIG.IADC_SRC_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__IADC_SRC_SEL__GET(void)
{
    uint32_t reg = TEST_TEST_CONFIG__GET();
    reg = (reg & TEST_TEST_CONFIG__IADC_SRC_SEL__Msk);
    reg = (reg >> TEST_TEST_CONFIG__IADC_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_CONFIG__IADC_SRC_SEL__MODIFY() modifies TEST_CONFIG.IADC_SRC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_CONFIG
 * @param bf_value new value for TEST_CONFIG.IADC_SRC_SEL
 * @return new value of TEST.TEST_CONFIG
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__IADC_SRC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_CONFIG__IADC_SRC_SEL__Msk);
    reg = (reg | (TEST_TEST_CONFIG__IADC_SRC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_CONFIG__IADC_SRC_SEL__EXTRACT() extracts TEST_CONFIG.IADC_SRC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_CONFIG
 * @return current value of TEST_CONFIG.IADC_SRC_SEL
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__IADC_SRC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_CONFIG__IADC_SRC_SEL__Msk);
    reg = (reg >> TEST_TEST_CONFIG__IADC_SRC_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- TEST.TEST_CONFIG.TEST_STEP_EN --------------------- */

/**
<pre>
  TEST.TEST_CONFIG.TEST_STEP_EN:

    Not used

</pre> */

#define TEST_TEST_CONFIG__TEST_STEP_EN__Pos                     6                                                                      /*!< Right-most bit position of test_step_en in TEST.TEST_CONFIG */
#define TEST_TEST_CONFIG__TEST_STEP_EN__Msk                     (0x00000001UL << TEST_TEST_CONFIG__TEST_STEP_EN__Pos)                  /*!< Mask for test_step_en in TEST.TEST_CONFIG */
#define TEST_TEST_CONFIG__TEST_STEP_EN__Shift(v)                (((v) << TEST_TEST_CONFIG__TEST_STEP_EN__Pos) & TEST_TEST_CONFIG__TEST_STEP_EN__Msk) /*!< Shift value 'v' into test_step_en and mask 'v' to fit it into test_step_en field */

/** TEST_TEST_CONFIG__TEST_STEP_EN__SET() sets TEST_CONFIG.TEST_STEP_EN to given value.
 *
 * When writing to TEST_CONFIG.TEST_STEP_EN, this is recommended to use.
 *
 * @param bf_value new value for TEST_CONFIG.TEST_STEP_EN
 */
__TEST_INLINE void TEST_TEST_CONFIG__TEST_STEP_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_CONFIG__GET();
    reg = (reg & ~TEST_TEST_CONFIG__TEST_STEP_EN__Msk);
    reg = (reg | (TEST_TEST_CONFIG__TEST_STEP_EN__Shift((uint32_t)bf_value)));
    TEST_TEST_CONFIG__SET(reg);
}

/** TEST_TEST_CONFIG__TEST_STEP_EN__GET() gets TEST_CONFIG.TEST_STEP_EN's current value.
 *
 * When reading from TEST_CONFIG.TEST_STEP_EN, this is recommended to use.
 *
 * @return current value of TEST_CONFIG.TEST_STEP_EN
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__TEST_STEP_EN__GET(void)
{
    uint32_t reg = TEST_TEST_CONFIG__GET();
    reg = (reg & TEST_TEST_CONFIG__TEST_STEP_EN__Msk);
    reg = (reg >> TEST_TEST_CONFIG__TEST_STEP_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_CONFIG__TEST_STEP_EN__MODIFY() modifies TEST_CONFIG.TEST_STEP_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_CONFIG
 * @param bf_value new value for TEST_CONFIG.TEST_STEP_EN
 * @return new value of TEST.TEST_CONFIG
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__TEST_STEP_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_CONFIG__TEST_STEP_EN__Msk);
    reg = (reg | (TEST_TEST_CONFIG__TEST_STEP_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_CONFIG__TEST_STEP_EN__EXTRACT() extracts TEST_CONFIG.TEST_STEP_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_CONFIG
 * @return current value of TEST_CONFIG.TEST_STEP_EN
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__TEST_STEP_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_CONFIG__TEST_STEP_EN__Msk);
    reg = (reg >> TEST_TEST_CONFIG__TEST_STEP_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TEST.TEST_CONFIG.TEST_STEP ----------------------- */

/**
<pre>
  TEST.TEST_CONFIG.TEST_STEP:

    Not used

</pre> */

#define TEST_TEST_CONFIG__TEST_STEP__Pos                        2                                                                      /*!< Right-most bit position of test_step in TEST.TEST_CONFIG */
#define TEST_TEST_CONFIG__TEST_STEP__Msk                        (0x0000000FUL << TEST_TEST_CONFIG__TEST_STEP__Pos)                     /*!< Mask for test_step in TEST.TEST_CONFIG */
#define TEST_TEST_CONFIG__TEST_STEP__Shift(v)                   (((v) << TEST_TEST_CONFIG__TEST_STEP__Pos) & TEST_TEST_CONFIG__TEST_STEP__Msk) /*!< Shift value 'v' into test_step and mask 'v' to fit it into test_step field */

/** TEST_TEST_CONFIG__TEST_STEP__SET() sets TEST_CONFIG.TEST_STEP to given value.
 *
 * When writing to TEST_CONFIG.TEST_STEP, this is recommended to use.
 *
 * @param bf_value new value for TEST_CONFIG.TEST_STEP
 */
__TEST_INLINE void TEST_TEST_CONFIG__TEST_STEP__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_CONFIG__GET();
    reg = (reg & ~TEST_TEST_CONFIG__TEST_STEP__Msk);
    reg = (reg | (TEST_TEST_CONFIG__TEST_STEP__Shift((uint32_t)bf_value)));
    TEST_TEST_CONFIG__SET(reg);
}

/** TEST_TEST_CONFIG__TEST_STEP__GET() gets TEST_CONFIG.TEST_STEP's current value.
 *
 * When reading from TEST_CONFIG.TEST_STEP, this is recommended to use.
 *
 * @return current value of TEST_CONFIG.TEST_STEP
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__TEST_STEP__GET(void)
{
    uint32_t reg = TEST_TEST_CONFIG__GET();
    reg = (reg & TEST_TEST_CONFIG__TEST_STEP__Msk);
    reg = (reg >> TEST_TEST_CONFIG__TEST_STEP__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_CONFIG__TEST_STEP__MODIFY() modifies TEST_CONFIG.TEST_STEP.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_CONFIG
 * @param bf_value new value for TEST_CONFIG.TEST_STEP
 * @return new value of TEST.TEST_CONFIG
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__TEST_STEP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_CONFIG__TEST_STEP__Msk);
    reg = (reg | (TEST_TEST_CONFIG__TEST_STEP__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_CONFIG__TEST_STEP__EXTRACT() extracts TEST_CONFIG.TEST_STEP.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_CONFIG
 * @return current value of TEST_CONFIG.TEST_STEP
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__TEST_STEP__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_CONFIG__TEST_STEP__Msk);
    reg = (reg >> TEST_TEST_CONFIG__TEST_STEP__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TEST.TEST_CONFIG.DNL_MUX ------------------------ */

/**
<pre>
  TEST.TEST_CONFIG.DNL_MUX:

    DNL BIST status select.  Selects reported value for DNL BIST on VS, IS and TS.
    <start table>
    0 "Max DNL"
    1 "Min DNL"
    2 "(DNLmax - DNLmin) / 2"
    3 "Last report DNL value"
    <end table>

</pre> */

#define TEST_TEST_CONFIG__DNL_MUX__Pos                          0                                                                      /*!< Right-most bit position of dnl_mux in TEST.TEST_CONFIG */
#define TEST_TEST_CONFIG__DNL_MUX__Msk                          (0x00000003UL << TEST_TEST_CONFIG__DNL_MUX__Pos)                       /*!< Mask for dnl_mux in TEST.TEST_CONFIG */
#define TEST_TEST_CONFIG__DNL_MUX__Shift(v)                     (((v) << TEST_TEST_CONFIG__DNL_MUX__Pos) & TEST_TEST_CONFIG__DNL_MUX__Msk) /*!< Shift value 'v' into dnl_mux and mask 'v' to fit it into dnl_mux field */

/** TEST_TEST_CONFIG__DNL_MUX__SET() sets TEST_CONFIG.DNL_MUX to given value.
 *
 * When writing to TEST_CONFIG.DNL_MUX, this is recommended to use.
 *
 * @param bf_value new value for TEST_CONFIG.DNL_MUX
 */
__TEST_INLINE void TEST_TEST_CONFIG__DNL_MUX__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_CONFIG__GET();
    reg = (reg & ~TEST_TEST_CONFIG__DNL_MUX__Msk);
    reg = (reg | (TEST_TEST_CONFIG__DNL_MUX__Shift((uint32_t)bf_value)));
    TEST_TEST_CONFIG__SET(reg);
}

/** TEST_TEST_CONFIG__DNL_MUX__GET() gets TEST_CONFIG.DNL_MUX's current value.
 *
 * When reading from TEST_CONFIG.DNL_MUX, this is recommended to use.
 *
 * @return current value of TEST_CONFIG.DNL_MUX
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__DNL_MUX__GET(void)
{
    uint32_t reg = TEST_TEST_CONFIG__GET();
    reg = (reg & TEST_TEST_CONFIG__DNL_MUX__Msk);
    reg = (reg >> TEST_TEST_CONFIG__DNL_MUX__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_CONFIG__DNL_MUX__MODIFY() modifies TEST_CONFIG.DNL_MUX.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_CONFIG
 * @param bf_value new value for TEST_CONFIG.DNL_MUX
 * @return new value of TEST.TEST_CONFIG
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__DNL_MUX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_CONFIG__DNL_MUX__Msk);
    reg = (reg | (TEST_TEST_CONFIG__DNL_MUX__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_CONFIG__DNL_MUX__EXTRACT() extracts TEST_CONFIG.DNL_MUX.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_CONFIG
 * @return current value of TEST_CONFIG.DNL_MUX
 */
__TEST_INLINE uint32_t TEST_TEST_CONFIG__DNL_MUX__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_CONFIG__DNL_MUX__Msk);
    reg = (reg >> TEST_TEST_CONFIG__DNL_MUX__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          TSEN_XV member of TEST_t                          */
/* -------------------------------------------------------------------------- */

/** __TEST_TSEN_XV__ADDRESS returns the address of member TSEN_XV.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TSEN_XV
 */
__TEST_INLINE uint32_t* __TEST_TSEN_XV__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TSEN_XV)));
}

/** TEST_TSEN_XV__SET() sets TSEN_XV to given value.
 *
 * When writing to TSEN_XV, this is mandatory to use.
 *
 * @param value new value for TSEN_XV
 */
__TEST_INLINE void TEST_TSEN_XV__SET(uint32_t value)
{
    HAL_SET32(__TEST_TSEN_XV__ADDRESS(), value);
}

/** TEST_TSEN_XV__GET() gets TSEN_XV's current value.
 *
 * When reading from TSEN_XV, this is mandatory to use.
 *
 * @return current value of TSEN_XV
 */
__TEST_INLINE uint32_t TEST_TSEN_XV__GET(void)
{
    return HAL_GET32(__TEST_TSEN_XV__ADDRESS());
}

/* --------------------- TEST.TSEN_XV.XV_INMUX_TEST_SEL --------------------- */

/**
<pre>
  TEST.TSEN_XV.XV_INMUX_TEST_SEL:

    X-Valent Config (XADDR) test mode source select
    <start table>
    0 "Not used"
    1 XADDR1
    2 XADDR2
    3 "Not used"
    <end table>

</pre> */

#define TEST_TSEN_XV__XV_INMUX_TEST_SEL__Pos                    1                                                                      /*!< Right-most bit position of xv_inmux_test_sel in TEST.TSEN_XV */
#define TEST_TSEN_XV__XV_INMUX_TEST_SEL__Msk                    (0x00000003UL << TEST_TSEN_XV__XV_INMUX_TEST_SEL__Pos)                 /*!< Mask for xv_inmux_test_sel in TEST.TSEN_XV */
#define TEST_TSEN_XV__XV_INMUX_TEST_SEL__Shift(v)               (((v) << TEST_TSEN_XV__XV_INMUX_TEST_SEL__Pos) & TEST_TSEN_XV__XV_INMUX_TEST_SEL__Msk) /*!< Shift value 'v' into xv_inmux_test_sel and mask 'v' to fit it into xv_inmux_test_sel field */

/** TEST_TSEN_XV__XV_INMUX_TEST_SEL__SET() sets TSEN_XV.XV_INMUX_TEST_SEL to given value.
 *
 * When writing to TSEN_XV.XV_INMUX_TEST_SEL, this is recommended to use.
 *
 * @param bf_value new value for TSEN_XV.XV_INMUX_TEST_SEL
 */
__TEST_INLINE void TEST_TSEN_XV__XV_INMUX_TEST_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TSEN_XV__GET();
    reg = (reg & ~TEST_TSEN_XV__XV_INMUX_TEST_SEL__Msk);
    reg = (reg | (TEST_TSEN_XV__XV_INMUX_TEST_SEL__Shift((uint32_t)bf_value)));
    TEST_TSEN_XV__SET(reg);
}

/** TEST_TSEN_XV__XV_INMUX_TEST_SEL__GET() gets TSEN_XV.XV_INMUX_TEST_SEL's current value.
 *
 * When reading from TSEN_XV.XV_INMUX_TEST_SEL, this is recommended to use.
 *
 * @return current value of TSEN_XV.XV_INMUX_TEST_SEL
 */
__TEST_INLINE uint32_t TEST_TSEN_XV__XV_INMUX_TEST_SEL__GET(void)
{
    uint32_t reg = TEST_TSEN_XV__GET();
    reg = (reg & TEST_TSEN_XV__XV_INMUX_TEST_SEL__Msk);
    reg = (reg >> TEST_TSEN_XV__XV_INMUX_TEST_SEL__Pos);
    return (uint32_t)reg;
}

/** TEST_TSEN_XV__XV_INMUX_TEST_SEL__MODIFY() modifies TSEN_XV.XV_INMUX_TEST_SEL.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TSEN_XV.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TSEN_XV
 * @param bf_value new value for TSEN_XV.XV_INMUX_TEST_SEL
 * @return new value of TEST.TSEN_XV
 */
__TEST_INLINE uint32_t TEST_TSEN_XV__XV_INMUX_TEST_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TSEN_XV__XV_INMUX_TEST_SEL__Msk);
    reg = (reg | (TEST_TSEN_XV__XV_INMUX_TEST_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TSEN_XV__XV_INMUX_TEST_SEL__EXTRACT() extracts TSEN_XV.XV_INMUX_TEST_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TSEN_XV.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TSEN_XV
 * @return current value of TSEN_XV.XV_INMUX_TEST_SEL
 */
__TEST_INLINE uint32_t TEST_TSEN_XV__XV_INMUX_TEST_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TSEN_XV__XV_INMUX_TEST_SEL__Msk);
    reg = (reg >> TEST_TSEN_XV__XV_INMUX_TEST_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- TEST.TSEN_XV.XV_CONFIG_TEST_EN --------------------- */

/**
<pre>
  TEST.TSEN_XV.XV_CONFIG_TEST_EN:

    X-Valent Config (XADDR) test mode control
    <start table>
    0 "Test mode disabled"
    1 "Test mode enabled"
    <end table>

</pre> */

#define TEST_TSEN_XV__XV_CONFIG_TEST_EN__Pos                    0                                                                      /*!< Right-most bit position of xv_config_test_en in TEST.TSEN_XV */
#define TEST_TSEN_XV__XV_CONFIG_TEST_EN__Msk                    (0x00000001UL << TEST_TSEN_XV__XV_CONFIG_TEST_EN__Pos)                 /*!< Mask for xv_config_test_en in TEST.TSEN_XV */
#define TEST_TSEN_XV__XV_CONFIG_TEST_EN__Shift(v)               (((v) << TEST_TSEN_XV__XV_CONFIG_TEST_EN__Pos) & TEST_TSEN_XV__XV_CONFIG_TEST_EN__Msk) /*!< Shift value 'v' into xv_config_test_en and mask 'v' to fit it into xv_config_test_en field */

/** TEST_TSEN_XV__XV_CONFIG_TEST_EN__SET() sets TSEN_XV.XV_CONFIG_TEST_EN to given value.
 *
 * When writing to TSEN_XV.XV_CONFIG_TEST_EN, this is recommended to use.
 *
 * @param bf_value new value for TSEN_XV.XV_CONFIG_TEST_EN
 */
__TEST_INLINE void TEST_TSEN_XV__XV_CONFIG_TEST_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TSEN_XV__GET();
    reg = (reg & ~TEST_TSEN_XV__XV_CONFIG_TEST_EN__Msk);
    reg = (reg | (TEST_TSEN_XV__XV_CONFIG_TEST_EN__Shift((uint32_t)bf_value)));
    TEST_TSEN_XV__SET(reg);
}

/** TEST_TSEN_XV__XV_CONFIG_TEST_EN__GET() gets TSEN_XV.XV_CONFIG_TEST_EN's current value.
 *
 * When reading from TSEN_XV.XV_CONFIG_TEST_EN, this is recommended to use.
 *
 * @return current value of TSEN_XV.XV_CONFIG_TEST_EN
 */
__TEST_INLINE uint32_t TEST_TSEN_XV__XV_CONFIG_TEST_EN__GET(void)
{
    uint32_t reg = TEST_TSEN_XV__GET();
    reg = (reg & TEST_TSEN_XV__XV_CONFIG_TEST_EN__Msk);
    reg = (reg >> TEST_TSEN_XV__XV_CONFIG_TEST_EN__Pos);
    return (uint32_t)reg;
}

/** TEST_TSEN_XV__XV_CONFIG_TEST_EN__MODIFY() modifies TSEN_XV.XV_CONFIG_TEST_EN.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TSEN_XV.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TSEN_XV
 * @param bf_value new value for TSEN_XV.XV_CONFIG_TEST_EN
 * @return new value of TEST.TSEN_XV
 */
__TEST_INLINE uint32_t TEST_TSEN_XV__XV_CONFIG_TEST_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TSEN_XV__XV_CONFIG_TEST_EN__Msk);
    reg = (reg | (TEST_TSEN_XV__XV_CONFIG_TEST_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TSEN_XV__XV_CONFIG_TEST_EN__EXTRACT() extracts TSEN_XV.XV_CONFIG_TEST_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TSEN_XV.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TSEN_XV
 * @return current value of TSEN_XV.XV_CONFIG_TEST_EN
 */
__TEST_INLINE uint32_t TEST_TSEN_XV__XV_CONFIG_TEST_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TSEN_XV__XV_CONFIG_TEST_EN__Msk);
    reg = (reg >> TEST_TSEN_XV__XV_CONFIG_TEST_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TEST_GATE member of TEST_t                         */
/* -------------------------------------------------------------------------- */

/** __TEST_TEST_GATE__ADDRESS returns the address of member TEST_GATE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TEST_GATE
 */
__TEST_INLINE uint32_t* __TEST_TEST_GATE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TEST_BASE_PTR() + (uint32_t)(offsetof(TEST_t, TEST_GATE)));
}

/** TEST_TEST_GATE__SET() sets TEST_GATE to given value.
 *
 * When writing to TEST_GATE, this is mandatory to use.
 *
 * @param value new value for TEST_GATE
 */
__TEST_INLINE void TEST_TEST_GATE__SET(uint32_t value)
{
    HAL_SET32(__TEST_TEST_GATE__ADDRESS(), value);
}

/** TEST_TEST_GATE__GET() gets TEST_GATE's current value.
 *
 * When reading from TEST_GATE, this is mandatory to use.
 *
 * @return current value of TEST_GATE
 */
__TEST_INLINE uint32_t TEST_TEST_GATE__GET(void)
{
    return HAL_GET32(__TEST_TEST_GATE__ADDRESS());
}

/* ------------------ TEST.TEST_GATE.TEST_GATE_KILL_SWITCH ------------------ */

/**
<pre>
  TEST.TEST_GATE.TEST_GATE_KILL_SWITCH:

    When high, overrides (disables) the XADDR1 test gate input latch.

</pre> */

#define TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Pos              0                                                                      /*!< Right-most bit position of test_gate_kill_switch in TEST.TEST_GATE */
#define TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Msk              (0x00000001UL << TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Pos)           /*!< Mask for test_gate_kill_switch in TEST.TEST_GATE */
#define TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Shift(v)         (((v) << TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Pos) & TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Msk) /*!< Shift value 'v' into test_gate_kill_switch and mask 'v' to fit it into test_gate_kill_switch field */

/** TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__SET() sets TEST_GATE.TEST_GATE_KILL_SWITCH to given value.
 *
 * When writing to TEST_GATE.TEST_GATE_KILL_SWITCH, this is recommended to use.
 *
 * @param bf_value new value for TEST_GATE.TEST_GATE_KILL_SWITCH
 */
__TEST_INLINE void TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__SET(uint32_t bf_value)
{
    uint32_t reg = TEST_TEST_GATE__GET();
    reg = (reg & ~TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Msk);
    reg = (reg | (TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Shift((uint32_t)bf_value)));
    TEST_TEST_GATE__SET(reg);
}

/** TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__GET() gets TEST_GATE.TEST_GATE_KILL_SWITCH's current value.
 *
 * When reading from TEST_GATE.TEST_GATE_KILL_SWITCH, this is recommended to use.
 *
 * @return current value of TEST_GATE.TEST_GATE_KILL_SWITCH
 */
__TEST_INLINE uint32_t TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__GET(void)
{
    uint32_t reg = TEST_TEST_GATE__GET();
    reg = (reg & TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Msk);
    reg = (reg >> TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Pos);
    return (uint32_t)reg;
}

/** TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__MODIFY() modifies TEST_GATE.TEST_GATE_KILL_SWITCH.
 *
 * This is recommended to use when setting more than one bitfield of TEST.TEST_GATE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TEST.TEST_GATE
 * @param bf_value new value for TEST_GATE.TEST_GATE_KILL_SWITCH
 * @return new value of TEST.TEST_GATE
 */
__TEST_INLINE uint32_t TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Msk);
    reg = (reg | (TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Shift((uint32_t)bf_value)));
    return reg;
}

/** TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__EXTRACT() extracts TEST_GATE.TEST_GATE_KILL_SWITCH.
 *
 * This is recommended to use when extracting more than one bitfield from TEST.TEST_GATE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TEST.TEST_GATE
 * @return current value of TEST_GATE.TEST_GATE_KILL_SWITCH
 */
__TEST_INLINE uint32_t TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__EXTRACT(uint32_t reg)
{
    reg = (reg & TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Msk);
    reg = (reg >> TEST_TEST_GATE__TEST_GATE_KILL_SWITCH__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group test block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_TEST_H_ */
