/**
 * @file     shasta_hal_vcontrol.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_VCONTROL_H_
#define _SHASTA_HAL_VCONTROL_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup vcontrol
 * @{
 */

#if defined ( __CC_ARM )
#define __VCONTROL_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __VCONTROL_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __VCONTROL_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __VCONTROL_INLINE  static inline
#endif

/** register file of the vcontrol block.
 */
typedef struct _VCONTROL_s
{
    volatile        uint32_t        VC_VAVP1                    ; /*!< (@0x00000000) Negative droop (load line) clamp voltage, can be used to limit negative droop voltage independent of VOUT_MAX (e.g., set to 0 to disable negative droop). <b...(more) */
    volatile        uint32_t        VC_VRAMP1                   ; /*!< (@0x00000004) Ramp target value referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP).  Note that while digitally this command can handle a wider range, the t...(more) */
    volatile        uint32_t        VC_VRAMP2                   ; /*!< (@0x00000008) Ramp time step, defines voltage ramp slew rate. Computed from PMBus commands as follows: <start table> "<b>Using VOUT_TRANSITION_RATE:</b>" "tstep(U18.-2) =...(more) */
    volatile        uint32_t        VC_VAVP2                    ; /*!< (@0x0000000C) Total current offset term applied to Droop computations only.  Allows FW to apply offset to HW computed current. LSB = 0.0625A, Range = -256 to +255.9375A */
    volatile        uint32_t        VC_VAVP3                    ; /*!< (@0x00000010) Loadline (droop) resistance referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP). <b>Computed from PMBus commands as follows:</b> <start table>...(more) */
    volatile        uint32_t        VC_VRAMP3                   ; /*!< (@0x00000014) Vcontrol output offset adjust referenced to the VSEN input (i.e., after scaling by VOUT_SCALE_LOOP). Computed from PMBus commands as follows: <start table> ...(more) */
    volatile        uint32_t        VC_MIN_MAX                  ; /*!< (@0x00000018) Vout max limit referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP). Target voltages (including droop) above this limit will be clamped to this...(more) */
    volatile        uint32_t        VC_VAVP4                    ; /*!< (@0x0000001C) Loadline (droop) resistance referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP) when load current is negative. Computed from PMBus commands as...(more) */
    volatile        uint32_t        VC_IRQ                      ; /*!< (@0x00000020) Interrupt enable for Vcontrol.  When the bit indicated is high, the corresponding signal is enabled to generate an interrupt. <start table_with_header> Bit ...(more) */
    volatile        uint32_t        VC_IRQ_STAT_FLAG            ; /*!< (@0x00000024) Interrupt status for Vcontrol. <start table_with_header> Bit Signal 0 "Ramp at target" 1 "Ramp within vc_vramp_target window of target voltage" <end table> */
    volatile        uint32_t        VC_VCTRL_RD                 ; /*!< (@0x00000028) Vcontrol status register.  Reflects target voltage referenced to the VSEN input (i.e., after scaling by VOUT_SCALE_LOOP) including offsets, droop, etc. LSB ...(more) */
    volatile        uint32_t        VC_VAVP5                    ; /*!< (@0x0000002C) Loadline (droop) resistance referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP) when load current exceeds vc_vavp_ithr_seg2 Computed from PMBu...(more) */
    volatile        uint32_t        VC_VAVP6                    ; /*!< (@0x00000030) Loadline (droop) resistance referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP) when load current exceeds vc_vavp_ithr_seg3 Computed from PMBu...(more) */
    volatile        uint32_t        VC_VAVP7                    ; /*!< (@0x00000034) When load current is above vc_vavp_ithr_seg2 and less than or equal to vc_vavp_ithr_seg3 the loadline (droop) resistance will be defined by vc_vavp_rll_seg2...(more) */
    volatile        uint32_t        VC_VAVP8                    ; /*!< (@0x00000038) When load current is above vc_vavp_ithr_seg3 the loadline (droop) resistance will be defined by vc_vavp_rll_seg3.  Note that a setting of 0 will disable thi...(more) */
    volatile        uint32_t        VC_VAVP9                    ; /*!< (@0x0000003C) Total current replacement term.  Allows FW to override HW computed total current for Droop computation when selected by vc_vavp_itot_uc_sel. LSB = 62.5mA, R...(more) */
} VCONTROL_t;


/** enumeration of implemented vcontrol blocks
 */
typedef enum _vcontrol_idx_e
{
    VCONTROL0 = 0u,    //!< VCONTROL0
    VCONTROL1 = 1u     //!< VCONTROL1
} vcontrol_idx_t;

#define VCONTROL_BASE (0x70001400u)                                                          /*!< vcontrol base address */
#define VCONTROL_STRIDE (0x00000400u)                                                         

/** __VCONTROL_BASE_PTR returns the base address of the peripheral.
 *
 * @param idp index of peripheral
 * @return base address of peripheral's instance
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_BASE_PTR(vcontrol_idx_t idp)
{
    return (uint32_t*)(VCONTROL_BASE + (uint32_t)((uint32_t)idp * VCONTROL_STRIDE));
}


/* -------------------------------------------------------------------------- */
/*                       VC_VAVP1 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VAVP1__ADDRESS returns the address of member VC_VAVP1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VAVP1
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VAVP1__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VAVP1)));
}

/** VCONTROL_VC_VAVP1__SET() sets VC_VAVP1 to given value.
 *
 * When writing to VC_VAVP1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VAVP1
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP1__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VAVP1__ADDRESS(idp), value);
}

/** VCONTROL_VC_VAVP1__GET() gets VC_VAVP1's current value.
 *
 * When reading from VC_VAVP1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP1
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VAVP1__ADDRESS(idp));
}

/* ------------------- VCONTROL.VC_VAVP1.VC_VAVP_KFP_LOBW ------------------- */

/**
<pre>
  VCONTROL.VC_VAVP1.VC_VAVP_KFP_LOBW:

    LPF coefficient for "low" BW filter applied to the higher gain segments 2 and 3, set to all 1's to bypass.
    <start table>
    "kfp_exp = vavp_kfp_i[4:2], kfp_man = 4 + vavp_kfp_i[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-17"
    "F3db(MHz) = [kfp/(1-kfp)] * 25MHz / 2*pi;"
    <end table>

</pre> */

#define VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Pos                19                                                                     /*!< Right-most bit position of vc_vavp_kfp_lobw in VCONTROL.VC_VAVP1 */
#define VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Msk                (0x0000001FUL << VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Pos)             /*!< Mask for vc_vavp_kfp_lobw in VCONTROL.VC_VAVP1 */
#define VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Shift(v)           (((v) << VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Pos) & VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Msk) /*!< Shift value 'v' into vc_vavp_kfp_lobw and mask 'v' to fit it into vc_vavp_kfp_lobw field */

/** VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__SET() sets VC_VAVP1.VC_VAVP_KFP_LOBW to given value.
 *
 * When writing to VC_VAVP1.VC_VAVP_KFP_LOBW, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP1.VC_VAVP_KFP_LOBW
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP1__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Msk);
    reg = (reg | (VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP1__SET(idp, reg);
}

/** VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__GET() gets VC_VAVP1.VC_VAVP_KFP_LOBW's current value.
 *
 * When reading from VC_VAVP1.VC_VAVP_KFP_LOBW, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP1.VC_VAVP_KFP_LOBW
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP1__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Msk);
    reg = (reg >> VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__MODIFY() modifies VC_VAVP1.VC_VAVP_KFP_LOBW.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP1
 * @param bf_value new value for VC_VAVP1.VC_VAVP_KFP_LOBW
 * @return new value of VCONTROL.VC_VAVP1
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Msk);
    reg = (reg | (VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__EXTRACT() extracts VC_VAVP1.VC_VAVP_KFP_LOBW.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP1
 * @return current value of VC_VAVP1.VC_VAVP_KFP_LOBW
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Msk);
    reg = (reg >> VCONTROL_VC_VAVP1__VC_VAVP_KFP_LOBW__Pos);
    return (uint32_t)reg;
}

/* --------------------- VCONTROL.VC_VAVP1.VC_VAVP_KFP --------------------- */

/**
<pre>
  VCONTROL.VC_VAVP1.VC_VAVP_KFP:

    LPF coefficient for "high" BW filter applied to the negative and VOUT_DROOP segments, set to all 1's to bypass.
    <start table>
    "kfp_exp = vavp_kfp_i[4:2], kfp_man = 4 + vavp_kfp_i[1:0]"
    "kfp = kfp_man * 2^kfp_exp * 2^-14"
    "F3db(MHz) = [kfp/(1-kfp)] * 25MHz / 2*pi;"
    <end table>

</pre> */

#define VCONTROL_VC_VAVP1__VC_VAVP_KFP__Pos                     14                                                                     /*!< Right-most bit position of vc_vavp_kfp in VCONTROL.VC_VAVP1 */
#define VCONTROL_VC_VAVP1__VC_VAVP_KFP__Msk                     (0x0000001FUL << VCONTROL_VC_VAVP1__VC_VAVP_KFP__Pos)                  /*!< Mask for vc_vavp_kfp in VCONTROL.VC_VAVP1 */
#define VCONTROL_VC_VAVP1__VC_VAVP_KFP__Shift(v)                (((v) << VCONTROL_VC_VAVP1__VC_VAVP_KFP__Pos) & VCONTROL_VC_VAVP1__VC_VAVP_KFP__Msk) /*!< Shift value 'v' into vc_vavp_kfp and mask 'v' to fit it into vc_vavp_kfp field */

/** VCONTROL_VC_VAVP1__VC_VAVP_KFP__SET() sets VC_VAVP1.VC_VAVP_KFP to given value.
 *
 * When writing to VC_VAVP1.VC_VAVP_KFP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP1.VC_VAVP_KFP
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP1__VC_VAVP_KFP__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP1__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP1__VC_VAVP_KFP__Msk);
    reg = (reg | (VCONTROL_VC_VAVP1__VC_VAVP_KFP__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP1__SET(idp, reg);
}

/** VCONTROL_VC_VAVP1__VC_VAVP_KFP__GET() gets VC_VAVP1.VC_VAVP_KFP's current value.
 *
 * When reading from VC_VAVP1.VC_VAVP_KFP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP1.VC_VAVP_KFP
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_KFP__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP1__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP1__VC_VAVP_KFP__Msk);
    reg = (reg >> VCONTROL_VC_VAVP1__VC_VAVP_KFP__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP1__VC_VAVP_KFP__MODIFY() modifies VC_VAVP1.VC_VAVP_KFP.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP1
 * @param bf_value new value for VC_VAVP1.VC_VAVP_KFP
 * @return new value of VCONTROL.VC_VAVP1
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_KFP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP1__VC_VAVP_KFP__Msk);
    reg = (reg | (VCONTROL_VC_VAVP1__VC_VAVP_KFP__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP1__VC_VAVP_KFP__EXTRACT() extracts VC_VAVP1.VC_VAVP_KFP.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP1
 * @return current value of VC_VAVP1.VC_VAVP_KFP
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_KFP__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP1__VC_VAVP_KFP__Msk);
    reg = (reg >> VCONTROL_VC_VAVP1__VC_VAVP_KFP__Pos);
    return (uint32_t)reg;
}

/* ------------------ VCONTROL.VC_VAVP1.VC_VAVP_CLAMP_POS ------------------ */

/**
<pre>
  VCONTROL.VC_VAVP1.VC_VAVP_CLAMP_POS:

    Positive droop (load line) clamp voltage,  can be used to limit positive droop voltage independent of VOUT_MIN.
    <b>Note:</b> Positive droop refers to decreasing voltage with positive IOUT, Negative droop refers increasing voltage with negative IOUT.
    LSB = 20mV, Range = 0.0 to 2.54V

</pre> */

#define VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Pos               7                                                                      /*!< Right-most bit position of vc_vavp_clamp_pos in VCONTROL.VC_VAVP1 */
#define VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Msk               (0x0000007FUL << VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Pos)            /*!< Mask for vc_vavp_clamp_pos in VCONTROL.VC_VAVP1 */
#define VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Shift(v)          (((v) << VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Pos) & VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Msk) /*!< Shift value 'v' into vc_vavp_clamp_pos and mask 'v' to fit it into vc_vavp_clamp_pos field */

/** VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__SET() sets VC_VAVP1.VC_VAVP_CLAMP_POS to given value.
 *
 * When writing to VC_VAVP1.VC_VAVP_CLAMP_POS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP1.VC_VAVP_CLAMP_POS
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP1__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Msk);
    reg = (reg | (VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP1__SET(idp, reg);
}

/** VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__GET() gets VC_VAVP1.VC_VAVP_CLAMP_POS's current value.
 *
 * When reading from VC_VAVP1.VC_VAVP_CLAMP_POS, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP1.VC_VAVP_CLAMP_POS
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP1__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Msk);
    reg = (reg >> VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__MODIFY() modifies VC_VAVP1.VC_VAVP_CLAMP_POS.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP1
 * @param bf_value new value for VC_VAVP1.VC_VAVP_CLAMP_POS
 * @return new value of VCONTROL.VC_VAVP1
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Msk);
    reg = (reg | (VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__EXTRACT() extracts VC_VAVP1.VC_VAVP_CLAMP_POS.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP1
 * @return current value of VC_VAVP1.VC_VAVP_CLAMP_POS
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Msk);
    reg = (reg >> VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_POS__Pos);
    return (uint32_t)reg;
}

/* ------------------ VCONTROL.VC_VAVP1.VC_VAVP_CLAMP_NEG ------------------ */

/**
<pre>
  VCONTROL.VC_VAVP1.VC_VAVP_CLAMP_NEG:

    Negative droop (load line) clamp voltage, can be used to limit negative droop voltage independent of VOUT_MAX (e.g., set to 0 to disable negative droop).
    <b>Note:</b> Positive droop refers to decreasing voltage with positive IOUT, Negative droop refers increasing voltage with negative IOUT.
    LSB = -20mV, Range = 0.0 to -2.54V

</pre> */

#define VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Pos               0                                                                      /*!< Right-most bit position of vc_vavp_clamp_neg in VCONTROL.VC_VAVP1 */
#define VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Msk               (0x0000007FUL << VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Pos)            /*!< Mask for vc_vavp_clamp_neg in VCONTROL.VC_VAVP1 */
#define VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Shift(v)          (((v) << VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Pos) & VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Msk) /*!< Shift value 'v' into vc_vavp_clamp_neg and mask 'v' to fit it into vc_vavp_clamp_neg field */

/** VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__SET() sets VC_VAVP1.VC_VAVP_CLAMP_NEG to given value.
 *
 * When writing to VC_VAVP1.VC_VAVP_CLAMP_NEG, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP1.VC_VAVP_CLAMP_NEG
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP1__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Msk);
    reg = (reg | (VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP1__SET(idp, reg);
}

/** VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__GET() gets VC_VAVP1.VC_VAVP_CLAMP_NEG's current value.
 *
 * When reading from VC_VAVP1.VC_VAVP_CLAMP_NEG, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP1.VC_VAVP_CLAMP_NEG
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP1__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Msk);
    reg = (reg >> VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__MODIFY() modifies VC_VAVP1.VC_VAVP_CLAMP_NEG.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP1
 * @param bf_value new value for VC_VAVP1.VC_VAVP_CLAMP_NEG
 * @return new value of VCONTROL.VC_VAVP1
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Msk);
    reg = (reg | (VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__EXTRACT() extracts VC_VAVP1.VC_VAVP_CLAMP_NEG.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP1
 * @return current value of VC_VAVP1.VC_VAVP_CLAMP_NEG
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Msk);
    reg = (reg >> VCONTROL_VC_VAVP1__VC_VAVP_CLAMP_NEG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VRAMP1 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VRAMP1__ADDRESS returns the address of member VC_VRAMP1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VRAMP1
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VRAMP1__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VRAMP1)));
}

/** VCONTROL_VC_VRAMP1__SET() sets VC_VRAMP1 to given value.
 *
 * When writing to VC_VRAMP1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VRAMP1
 */
__VCONTROL_INLINE void VCONTROL_VC_VRAMP1__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VRAMP1__ADDRESS(idp), value);
}

/** VCONTROL_VC_VRAMP1__GET() gets VC_VRAMP1's current value.
 *
 * When reading from VC_VRAMP1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VRAMP1
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VRAMP1__ADDRESS(idp));
}

/* --------------------- VCONTROL.VC_VRAMP1.VC_VRAMP_ON --------------------- */

/**
<pre>
  VCONTROL.VC_VRAMP1.VC_VRAMP_ON:

    When high, indicates the ramp should respond to target changes and that that loop is actively regulating.  Note: in addition to vcontrol, this signal is used by the PID, PWM and current estimator as an indication that we are actively regulating the output.

</pre> */

#define VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Pos                    24                                                                     /*!< Right-most bit position of vc_vramp_on in VCONTROL.VC_VRAMP1 */
#define VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Msk                    (0x00000001UL << VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Pos)                 /*!< Mask for vc_vramp_on in VCONTROL.VC_VRAMP1 */
#define VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Shift(v)               (((v) << VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Pos) & VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Msk) /*!< Shift value 'v' into vc_vramp_on and mask 'v' to fit it into vc_vramp_on field */

/** VCONTROL_VC_VRAMP1__VC_VRAMP_ON__SET() sets VC_VRAMP1.VC_VRAMP_ON to given value.
 *
 * When writing to VC_VRAMP1.VC_VRAMP_ON, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VRAMP1.VC_VRAMP_ON
 */
__VCONTROL_INLINE void VCONTROL_VC_VRAMP1__VC_VRAMP_ON__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VRAMP1__GET(idp);
    reg = (reg & ~VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VRAMP1__SET(idp, reg);
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_ON__GET() gets VC_VRAMP1.VC_VRAMP_ON's current value.
 *
 * When reading from VC_VRAMP1.VC_VRAMP_ON, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VRAMP1.VC_VRAMP_ON
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_ON__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VRAMP1__GET(idp);
    reg = (reg & VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_ON__MODIFY() modifies VC_VRAMP1.VC_VRAMP_ON.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VRAMP1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VRAMP1
 * @param bf_value new value for VC_VRAMP1.VC_VRAMP_ON
 * @return new value of VCONTROL.VC_VRAMP1
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_ON__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_ON__EXTRACT() extracts VC_VRAMP1.VC_VRAMP_ON.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VRAMP1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VRAMP1
 * @return current value of VC_VRAMP1.VC_VRAMP_ON
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_ON__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP1__VC_VRAMP_ON__Pos);
    return (uint32_t)reg;
}

/* --------------- VCONTROL.VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE --------------- */

/**
<pre>
  VCONTROL.VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE:

    Immediately loads vc_vramp_target into ramp output when high.  Otherwise the ramp output is slewed to vc_vramp_target at a rate determined by vc_vramp_tstep.  The typical use for this field is during prebias startup.  The prebias voltage can be immediately loaded into the ramp to define the ramp start voltage then the target voltage (e.g., VOUT_COMMAND) can be set on vc_vramp_target with load_immediate set low to slew to the final voltage.
    <start table>
    0 "slew ramp output to vc_vramp_target"
    1 "immediately set ramp output to vc_vramp_target"
    <end table>

</pre> */

#define VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Pos        23                                                                     /*!< Right-most bit position of vc_vramp_load_immediate in VCONTROL.VC_VRAMP1 */
#define VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Msk        (0x00000001UL << VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Pos)     /*!< Mask for vc_vramp_load_immediate in VCONTROL.VC_VRAMP1 */
#define VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Shift(v)   (((v) << VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Pos) & VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Msk) /*!< Shift value 'v' into vc_vramp_load_immediate and mask 'v' to fit it into vc_vramp_load_immediate field */

/** VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__SET() sets VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE to given value.
 *
 * When writing to VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE
 */
__VCONTROL_INLINE void VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VRAMP1__GET(idp);
    reg = (reg & ~VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VRAMP1__SET(idp, reg);
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__GET() gets VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE's current value.
 *
 * When reading from VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VRAMP1__GET(idp);
    reg = (reg & VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__MODIFY() modifies VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VRAMP1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VRAMP1
 * @param bf_value new value for VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE
 * @return new value of VCONTROL.VC_VRAMP1
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__EXTRACT() extracts VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VRAMP1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VRAMP1
 * @return current value of VC_VRAMP1.VC_VRAMP_LOAD_IMMEDIATE
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP1__VC_VRAMP_LOAD_IMMEDIATE__Pos);
    return (uint32_t)reg;
}

/* --------------- VCONTROL.VC_VRAMP1.VC_VRAMP_TARGET_WINDOW --------------- */

/**
<pre>
  VCONTROL.VC_VRAMP1.VC_VRAMP_TARGET_WINDOW:

    Ramp target window, used to define interupt prior to reaching ramp target (e.g., during soft-start may be used by FW to enable SR's prior to reaching final target).
    LSB = 1.25mV, Range = 0.0 to 318.75mV

</pre> */

#define VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Pos         15                                                                     /*!< Right-most bit position of vc_vramp_target_window in VCONTROL.VC_VRAMP1 */
#define VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Msk         (0x000000FFUL << VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Pos)      /*!< Mask for vc_vramp_target_window in VCONTROL.VC_VRAMP1 */
#define VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Shift(v)    (((v) << VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Pos) & VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Msk) /*!< Shift value 'v' into vc_vramp_target_window and mask 'v' to fit it into vc_vramp_target_window field */

/** VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__SET() sets VC_VRAMP1.VC_VRAMP_TARGET_WINDOW to given value.
 *
 * When writing to VC_VRAMP1.VC_VRAMP_TARGET_WINDOW, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VRAMP1.VC_VRAMP_TARGET_WINDOW
 */
__VCONTROL_INLINE void VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VRAMP1__GET(idp);
    reg = (reg & ~VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VRAMP1__SET(idp, reg);
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__GET() gets VC_VRAMP1.VC_VRAMP_TARGET_WINDOW's current value.
 *
 * When reading from VC_VRAMP1.VC_VRAMP_TARGET_WINDOW, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VRAMP1.VC_VRAMP_TARGET_WINDOW
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VRAMP1__GET(idp);
    reg = (reg & VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__MODIFY() modifies VC_VRAMP1.VC_VRAMP_TARGET_WINDOW.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VRAMP1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VRAMP1
 * @param bf_value new value for VC_VRAMP1.VC_VRAMP_TARGET_WINDOW
 * @return new value of VCONTROL.VC_VRAMP1
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__EXTRACT() extracts VC_VRAMP1.VC_VRAMP_TARGET_WINDOW.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VRAMP1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VRAMP1
 * @return current value of VC_VRAMP1.VC_VRAMP_TARGET_WINDOW
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET_WINDOW__Pos);
    return (uint32_t)reg;
}

/* ------------------- VCONTROL.VC_VRAMP1.VC_VRAMP_TARGET ------------------- */

/**
<pre>
  VCONTROL.VC_VRAMP1.VC_VRAMP_TARGET:

    Ramp target value referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP).  Note that while digitally this command can handle a wider range, the target value is limited to 2.1V by the analog circuitry.
    Computed from PMBus commands as follows:
    <start table>
    "vc_vramp_target(U12.0) = VOUT_COMMAND(U16-X.X) * VOUT_SCALE_LOOP(U0.16) * 6400 / (2^X * 2^16)"
    "where, X = negative of VOUT_MODE exponent"
    "<b>Note:</b>  VOUT_COMMAND above may be replaced with VOUT_MARGIN_HIGH or VOUT_MARGIN_LOW based on OPERATION setting"
    <end table>
    LSB = 0.15625mV, Range = 0.0 to 2.1V

</pre> */

#define VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Pos                0                                                                      /*!< Right-most bit position of vc_vramp_target in VCONTROL.VC_VRAMP1 */
#define VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Msk                (0x00007FFFUL << VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Pos)             /*!< Mask for vc_vramp_target in VCONTROL.VC_VRAMP1 */
#define VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Shift(v)           (((v) << VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Pos) & VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Msk) /*!< Shift value 'v' into vc_vramp_target and mask 'v' to fit it into vc_vramp_target field */

/** VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__SET() sets VC_VRAMP1.VC_VRAMP_TARGET to given value.
 *
 * When writing to VC_VRAMP1.VC_VRAMP_TARGET, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VRAMP1.VC_VRAMP_TARGET
 */
__VCONTROL_INLINE void VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VRAMP1__GET(idp);
    reg = (reg & ~VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VRAMP1__SET(idp, reg);
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__GET() gets VC_VRAMP1.VC_VRAMP_TARGET's current value.
 *
 * When reading from VC_VRAMP1.VC_VRAMP_TARGET, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VRAMP1.VC_VRAMP_TARGET
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VRAMP1__GET(idp);
    reg = (reg & VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__MODIFY() modifies VC_VRAMP1.VC_VRAMP_TARGET.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VRAMP1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VRAMP1
 * @param bf_value new value for VC_VRAMP1.VC_VRAMP_TARGET
 * @return new value of VCONTROL.VC_VRAMP1
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__EXTRACT() extracts VC_VRAMP1.VC_VRAMP_TARGET.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VRAMP1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VRAMP1
 * @return current value of VC_VRAMP1.VC_VRAMP_TARGET
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP1__VC_VRAMP_TARGET__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VRAMP2 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VRAMP2__ADDRESS returns the address of member VC_VRAMP2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VRAMP2
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VRAMP2__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VRAMP2)));
}

/** VCONTROL_VC_VRAMP2__SET() sets VC_VRAMP2 to given value.
 *
 * When writing to VC_VRAMP2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VRAMP2
 */
__VCONTROL_INLINE void VCONTROL_VC_VRAMP2__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VRAMP2__ADDRESS(idp), value);
}

/** VCONTROL_VC_VRAMP2__GET() gets VC_VRAMP2's current value.
 *
 * When reading from VC_VRAMP2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VRAMP2
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP2__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VRAMP2__ADDRESS(idp));
}

/* ------------------- VCONTROL.VC_VRAMP2.VC_VRAMP_TSTEP ------------------- */

/**
<pre>
  VCONTROL.VC_VRAMP2.VC_VRAMP_TSTEP:

    Ramp time step, defines voltage ramp slew rate.
    Computed from PMBus commands as follows:
    <start table>
    "<b>Using VOUT_TRANSITION_RATE:</b>"
    "tstep(U18.-2) = [(0.15625mV/0.02us) * (2^3 * 2^16) / (VOUT_TRANSITION_RATE(U6.3) * VOUT_SCALE_LOOP(U0.16))] - 1"
    "    = [7.8125 * 2^19 / (VOUT_TRANSITION_RATE(U6.3) * VOUT_SCALE_LOOP(U0.16))] - 1"
    "<b>Using TON_RISE assuming ramping from 0V:</b>"
    "tstep(U18.-2) = [(0.15625mV/0.02us) * (2^-2 * 2^8 * 2*16) * TON_RISE(U5.2) / (VOUT_COMMAND(U8.8) * VOUT_SCALE_LOOP(U0.16))] - 1"
    "    = [7.8125 * 2^22 * TON_RISE(U5.2) / (VOUT_COMMAND(U8.8) * VOUT_SCALE_LOOP(U0.16))] - 1"
    "<b>Using TOFF_FALL assuming ramping to 0V:</b>"
    "tstep(U18.-2) = [(0.15625mV/0.02us) * (2^-2 * 2^8 * 2*16) * TON_FALL(U5.2) / (VOUT_COMMAND(U8.8) * VOUT_SCALE_LOOP(U0.16))] - 1"
    "    = [7.8125 * 2^22 * TON_FALL(U5.2) / (VOUT_COMMAND(U8.8) * VOUT_SCALE_LOOP(U0.16))] - 1"
    "<b>Note:</b>  VOUT_COMMAND above may be replaced with VOUT_MARGIN_HIGH or VOUT_MARGIN_LOW based on OPERATION setting"
    <end table>
    LSB = 20ns, Range = 0.0 to 1.3107ms

</pre> */

#define VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Pos                 0                                                                      /*!< Right-most bit position of vc_vramp_tstep in VCONTROL.VC_VRAMP2 */
#define VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Msk                 (0x0000FFFFUL << VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Pos)              /*!< Mask for vc_vramp_tstep in VCONTROL.VC_VRAMP2 */
#define VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Shift(v)            (((v) << VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Pos) & VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Msk) /*!< Shift value 'v' into vc_vramp_tstep and mask 'v' to fit it into vc_vramp_tstep field */

/** VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__SET() sets VC_VRAMP2.VC_VRAMP_TSTEP to given value.
 *
 * When writing to VC_VRAMP2.VC_VRAMP_TSTEP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VRAMP2.VC_VRAMP_TSTEP
 */
__VCONTROL_INLINE void VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VRAMP2__GET(idp);
    reg = (reg & ~VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VRAMP2__SET(idp, reg);
}

/** VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__GET() gets VC_VRAMP2.VC_VRAMP_TSTEP's current value.
 *
 * When reading from VC_VRAMP2.VC_VRAMP_TSTEP, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VRAMP2.VC_VRAMP_TSTEP
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VRAMP2__GET(idp);
    reg = (reg & VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__MODIFY() modifies VC_VRAMP2.VC_VRAMP_TSTEP.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VRAMP2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VRAMP2
 * @param bf_value new value for VC_VRAMP2.VC_VRAMP_TSTEP
 * @return new value of VCONTROL.VC_VRAMP2
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__EXTRACT() extracts VC_VRAMP2.VC_VRAMP_TSTEP.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VRAMP2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VRAMP2
 * @return current value of VC_VRAMP2.VC_VRAMP_TSTEP
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP2__VC_VRAMP_TSTEP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VAVP2 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VAVP2__ADDRESS returns the address of member VC_VAVP2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VAVP2
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VAVP2__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VAVP2)));
}

/** VCONTROL_VC_VAVP2__SET() sets VC_VAVP2 to given value.
 *
 * When writing to VC_VAVP2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VAVP2
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP2__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VAVP2__ADDRESS(idp), value);
}

/** VCONTROL_VC_VAVP2__GET() gets VC_VAVP2's current value.
 *
 * When reading from VC_VAVP2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP2
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP2__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VAVP2__ADDRESS(idp));
}

/* ------------------ VCONTROL.VC_VAVP2.VC_VAVP_ITOT_DELTA ------------------ */

/**
<pre>
  VCONTROL.VC_VAVP2.VC_VAVP_ITOT_DELTA:

    Total current offset term applied to Droop computations only.  Allows FW to apply offset to HW computed current.
    LSB = 0.0625A, Range = -256 to +255.9375A

</pre> */

#define VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Pos              0                                                                      /*!< Right-most bit position of vc_vavp_itot_delta in VCONTROL.VC_VAVP2 */
#define VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Msk              (0x00001FFFUL << VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Pos)           /*!< Mask for vc_vavp_itot_delta in VCONTROL.VC_VAVP2 */
#define VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Shift(v)         (((v) << VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Pos) & VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Msk) /*!< Shift value 'v' into vc_vavp_itot_delta and mask 'v' to fit it into vc_vavp_itot_delta field */

/** VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__SET() sets VC_VAVP2.VC_VAVP_ITOT_DELTA to given value.
 *
 * When writing to VC_VAVP2.VC_VAVP_ITOT_DELTA, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP2.VC_VAVP_ITOT_DELTA
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP2__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Msk);
    reg = (reg | (VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP2__SET(idp, reg);
}

/** VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__GET() gets VC_VAVP2.VC_VAVP_ITOT_DELTA's current value.
 *
 * When reading from VC_VAVP2.VC_VAVP_ITOT_DELTA, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP2.VC_VAVP_ITOT_DELTA
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP2__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Msk);
    reg = (reg >> VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__MODIFY() modifies VC_VAVP2.VC_VAVP_ITOT_DELTA.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP2
 * @param bf_value new value for VC_VAVP2.VC_VAVP_ITOT_DELTA
 * @return new value of VCONTROL.VC_VAVP2
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Msk);
    reg = (reg | (VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__EXTRACT() extracts VC_VAVP2.VC_VAVP_ITOT_DELTA.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP2
 * @return current value of VC_VAVP2.VC_VAVP_ITOT_DELTA
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Msk);
    reg = (reg >> VCONTROL_VC_VAVP2__VC_VAVP_ITOT_DELTA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VAVP3 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VAVP3__ADDRESS returns the address of member VC_VAVP3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VAVP3
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VAVP3__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VAVP3)));
}

/** VCONTROL_VC_VAVP3__SET() sets VC_VAVP3 to given value.
 *
 * When writing to VC_VAVP3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VAVP3
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP3__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VAVP3__ADDRESS(idp), value);
}

/** VCONTROL_VC_VAVP3__GET() gets VC_VAVP3's current value.
 *
 * When reading from VC_VAVP3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP3
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP3__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VAVP3__ADDRESS(idp));
}

/* --------------------- VCONTROL.VC_VAVP3.VC_VAVP_RLL --------------------- */

/**
<pre>
  VCONTROL.VC_VAVP3.VC_VAVP_RLL:

    Loadline (droop) resistance referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP).
    <b>Computed from PMBus commands as follows:</b>
    <start table>
    "vc_vavp_rll(U4.7) = VOUT_DROOP(Ux.y) * VOUT_SCALE_LOOP(U0.16) / (2^y * 2^(16-7))"
    "where, y = -1 * LINEAR11 exponent of VOUT_DROOP"
    <end table>
    LSB=7.8125uOhm, Range = 0.0 to 15.992mOhm

</pre> */

#define VCONTROL_VC_VAVP3__VC_VAVP_RLL__Pos                     0                                                                      /*!< Right-most bit position of vc_vavp_rll in VCONTROL.VC_VAVP3 */
#define VCONTROL_VC_VAVP3__VC_VAVP_RLL__Msk                     (0x000007FFUL << VCONTROL_VC_VAVP3__VC_VAVP_RLL__Pos)                  /*!< Mask for vc_vavp_rll in VCONTROL.VC_VAVP3 */
#define VCONTROL_VC_VAVP3__VC_VAVP_RLL__Shift(v)                (((v) << VCONTROL_VC_VAVP3__VC_VAVP_RLL__Pos) & VCONTROL_VC_VAVP3__VC_VAVP_RLL__Msk) /*!< Shift value 'v' into vc_vavp_rll and mask 'v' to fit it into vc_vavp_rll field */

/** VCONTROL_VC_VAVP3__VC_VAVP_RLL__SET() sets VC_VAVP3.VC_VAVP_RLL to given value.
 *
 * When writing to VC_VAVP3.VC_VAVP_RLL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP3.VC_VAVP_RLL
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP3__VC_VAVP_RLL__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP3__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP3__VC_VAVP_RLL__Msk);
    reg = (reg | (VCONTROL_VC_VAVP3__VC_VAVP_RLL__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP3__SET(idp, reg);
}

/** VCONTROL_VC_VAVP3__VC_VAVP_RLL__GET() gets VC_VAVP3.VC_VAVP_RLL's current value.
 *
 * When reading from VC_VAVP3.VC_VAVP_RLL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP3.VC_VAVP_RLL
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP3__VC_VAVP_RLL__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP3__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP3__VC_VAVP_RLL__Msk);
    reg = (reg >> VCONTROL_VC_VAVP3__VC_VAVP_RLL__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP3__VC_VAVP_RLL__MODIFY() modifies VC_VAVP3.VC_VAVP_RLL.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP3
 * @param bf_value new value for VC_VAVP3.VC_VAVP_RLL
 * @return new value of VCONTROL.VC_VAVP3
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP3__VC_VAVP_RLL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP3__VC_VAVP_RLL__Msk);
    reg = (reg | (VCONTROL_VC_VAVP3__VC_VAVP_RLL__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP3__VC_VAVP_RLL__EXTRACT() extracts VC_VAVP3.VC_VAVP_RLL.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP3
 * @return current value of VC_VAVP3.VC_VAVP_RLL
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP3__VC_VAVP_RLL__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP3__VC_VAVP_RLL__Msk);
    reg = (reg >> VCONTROL_VC_VAVP3__VC_VAVP_RLL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VRAMP3 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VRAMP3__ADDRESS returns the address of member VC_VRAMP3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VRAMP3
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VRAMP3__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VRAMP3)));
}

/** VCONTROL_VC_VRAMP3__SET() sets VC_VRAMP3 to given value.
 *
 * When writing to VC_VRAMP3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VRAMP3
 */
__VCONTROL_INLINE void VCONTROL_VC_VRAMP3__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VRAMP3__ADDRESS(idp), value);
}

/** VCONTROL_VC_VRAMP3__GET() gets VC_VRAMP3's current value.
 *
 * When reading from VC_VRAMP3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VRAMP3
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP3__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VRAMP3__ADDRESS(idp));
}

/* ------------------ VCONTROL.VC_VRAMP3.VC_VCONTROL_DELTA ------------------ */

/**
<pre>
  VCONTROL.VC_VRAMP3.VC_VCONTROL_DELTA:

    Vcontrol output offset adjust referenced to the VSEN input (i.e., after scaling by VOUT_SCALE_LOOP).
    Computed from PMBus commands as follows:
    <start table>
    "vcontrol_delta(S10.0) = (VOUT_TRIM(S16-X.X) + VOUT_CAL_OFFSET(S16-X.X)) * VOUT_SCALE_LOOP(U0.16) * 6400 / (2^X * 2^16)"
    "where, X = negative of VOUT_MODE exponent"
    <end table>
    LSB = 0.15625mV, Range = -640 to +639.84375mV

</pre> */

#define VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Pos              0                                                                      /*!< Right-most bit position of vc_vcontrol_delta in VCONTROL.VC_VRAMP3 */
#define VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Msk              (0x00001FFFUL << VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Pos)           /*!< Mask for vc_vcontrol_delta in VCONTROL.VC_VRAMP3 */
#define VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Shift(v)         (((v) << VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Pos) & VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Msk) /*!< Shift value 'v' into vc_vcontrol_delta and mask 'v' to fit it into vc_vcontrol_delta field */

/** VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__SET() sets VC_VRAMP3.VC_VCONTROL_DELTA to given value.
 *
 * When writing to VC_VRAMP3.VC_VCONTROL_DELTA, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VRAMP3.VC_VCONTROL_DELTA
 */
__VCONTROL_INLINE void VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VRAMP3__GET(idp);
    reg = (reg & ~VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VRAMP3__SET(idp, reg);
}

/** VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__GET() gets VC_VRAMP3.VC_VCONTROL_DELTA's current value.
 *
 * When reading from VC_VRAMP3.VC_VCONTROL_DELTA, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VRAMP3.VC_VCONTROL_DELTA
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VRAMP3__GET(idp);
    reg = (reg & VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__MODIFY() modifies VC_VRAMP3.VC_VCONTROL_DELTA.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VRAMP3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VRAMP3
 * @param bf_value new value for VC_VRAMP3.VC_VCONTROL_DELTA
 * @return new value of VCONTROL.VC_VRAMP3
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Msk);
    reg = (reg | (VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__EXTRACT() extracts VC_VRAMP3.VC_VCONTROL_DELTA.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VRAMP3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VRAMP3
 * @return current value of VC_VRAMP3.VC_VCONTROL_DELTA
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Msk);
    reg = (reg >> VCONTROL_VC_VRAMP3__VC_VCONTROL_DELTA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      VC_MIN_MAX member of VCONTROL_t                      */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_MIN_MAX__ADDRESS returns the address of member VC_MIN_MAX.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_MIN_MAX
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_MIN_MAX__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_MIN_MAX)));
}

/** VCONTROL_VC_MIN_MAX__SET() sets VC_MIN_MAX to given value.
 *
 * When writing to VC_MIN_MAX, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_MIN_MAX
 */
__VCONTROL_INLINE void VCONTROL_VC_MIN_MAX__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_MIN_MAX__ADDRESS(idp), value);
}

/** VCONTROL_VC_MIN_MAX__GET() gets VC_MIN_MAX's current value.
 *
 * When reading from VC_MIN_MAX, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_MIN_MAX
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_MIN_MAX__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_MIN_MAX__ADDRESS(idp));
}

/* ---------------- VCONTROL.VC_MIN_MAX.VC_VCONTROL_VOUT_MIN ---------------- */

/**
<pre>
  VCONTROL.VC_MIN_MAX.VC_VCONTROL_VOUT_MIN:

    Vout min limit referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP. Target voltages (including droop) below this limit will be clamped to this level.
    Computed from PMBus commands as follows:
    <start table>
    "vout_min(U12.-4) =VOUT_MIN(U8.8) * VOUT_SCALE_LOOP(U0.16) * 50 / (2^8 * 2^16)"
    <end table>
    LSB = 20mV, Range = 0.0 to 5.1V

</pre> */

#define VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Pos          8                                                                      /*!< Right-most bit position of vc_vcontrol_vout_min in VCONTROL.VC_MIN_MAX */
#define VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Msk          (0x000000FFUL << VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Pos)       /*!< Mask for vc_vcontrol_vout_min in VCONTROL.VC_MIN_MAX */
#define VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Shift(v)     (((v) << VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Pos) & VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Msk) /*!< Shift value 'v' into vc_vcontrol_vout_min and mask 'v' to fit it into vc_vcontrol_vout_min field */

/** VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__SET() sets VC_MIN_MAX.VC_VCONTROL_VOUT_MIN to given value.
 *
 * When writing to VC_MIN_MAX.VC_VCONTROL_VOUT_MIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_MIN_MAX.VC_VCONTROL_VOUT_MIN
 */
__VCONTROL_INLINE void VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_MIN_MAX__GET(idp);
    reg = (reg & ~VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Msk);
    reg = (reg | (VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Shift((uint32_t)bf_value)));
    VCONTROL_VC_MIN_MAX__SET(idp, reg);
}

/** VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__GET() gets VC_MIN_MAX.VC_VCONTROL_VOUT_MIN's current value.
 *
 * When reading from VC_MIN_MAX.VC_VCONTROL_VOUT_MIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_MIN_MAX.VC_VCONTROL_VOUT_MIN
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_MIN_MAX__GET(idp);
    reg = (reg & VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Msk);
    reg = (reg >> VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__MODIFY() modifies VC_MIN_MAX.VC_VCONTROL_VOUT_MIN.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_MIN_MAX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_MIN_MAX
 * @param bf_value new value for VC_MIN_MAX.VC_VCONTROL_VOUT_MIN
 * @return new value of VCONTROL.VC_MIN_MAX
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Msk);
    reg = (reg | (VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__EXTRACT() extracts VC_MIN_MAX.VC_VCONTROL_VOUT_MIN.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_MIN_MAX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_MIN_MAX
 * @return current value of VC_MIN_MAX.VC_VCONTROL_VOUT_MIN
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Msk);
    reg = (reg >> VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MIN__Pos);
    return (uint32_t)reg;
}

/* ---------------- VCONTROL.VC_MIN_MAX.VC_VCONTROL_VOUT_MAX ---------------- */

/**
<pre>
  VCONTROL.VC_MIN_MAX.VC_VCONTROL_VOUT_MAX:

    Vout max limit referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP). Target voltages (including droop) above this limit will be clamped to this level.
    Computed from PMBus commands as follows:
    <start table>
    "vout_max(U12.-4) = VOUT_MAX(U8.8) * VOUT_SCALE_LOOP(U0.16) * 50 / (2^8 * 2^16)"
    <end table>
    LSB = 20mV, Range = 0.0 to 5.1V

</pre> */

#define VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Pos          0                                                                      /*!< Right-most bit position of vc_vcontrol_vout_max in VCONTROL.VC_MIN_MAX */
#define VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Msk          (0x000000FFUL << VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Pos)       /*!< Mask for vc_vcontrol_vout_max in VCONTROL.VC_MIN_MAX */
#define VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Shift(v)     (((v) << VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Pos) & VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Msk) /*!< Shift value 'v' into vc_vcontrol_vout_max and mask 'v' to fit it into vc_vcontrol_vout_max field */

/** VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__SET() sets VC_MIN_MAX.VC_VCONTROL_VOUT_MAX to given value.
 *
 * When writing to VC_MIN_MAX.VC_VCONTROL_VOUT_MAX, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_MIN_MAX.VC_VCONTROL_VOUT_MAX
 */
__VCONTROL_INLINE void VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_MIN_MAX__GET(idp);
    reg = (reg & ~VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Msk);
    reg = (reg | (VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Shift((uint32_t)bf_value)));
    VCONTROL_VC_MIN_MAX__SET(idp, reg);
}

/** VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__GET() gets VC_MIN_MAX.VC_VCONTROL_VOUT_MAX's current value.
 *
 * When reading from VC_MIN_MAX.VC_VCONTROL_VOUT_MAX, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_MIN_MAX.VC_VCONTROL_VOUT_MAX
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_MIN_MAX__GET(idp);
    reg = (reg & VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Msk);
    reg = (reg >> VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__MODIFY() modifies VC_MIN_MAX.VC_VCONTROL_VOUT_MAX.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_MIN_MAX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_MIN_MAX
 * @param bf_value new value for VC_MIN_MAX.VC_VCONTROL_VOUT_MAX
 * @return new value of VCONTROL.VC_MIN_MAX
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Msk);
    reg = (reg | (VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__EXTRACT() extracts VC_MIN_MAX.VC_VCONTROL_VOUT_MAX.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_MIN_MAX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_MIN_MAX
 * @return current value of VC_MIN_MAX.VC_VCONTROL_VOUT_MAX
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Msk);
    reg = (reg >> VCONTROL_VC_MIN_MAX__VC_VCONTROL_VOUT_MAX__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VAVP4 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VAVP4__ADDRESS returns the address of member VC_VAVP4.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VAVP4
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VAVP4__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VAVP4)));
}

/** VCONTROL_VC_VAVP4__SET() sets VC_VAVP4 to given value.
 *
 * When writing to VC_VAVP4, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VAVP4
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP4__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VAVP4__ADDRESS(idp), value);
}

/** VCONTROL_VC_VAVP4__GET() gets VC_VAVP4's current value.
 *
 * When reading from VC_VAVP4, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP4
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP4__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VAVP4__ADDRESS(idp));
}

/* ------------------- VCONTROL.VC_VAVP4.VC_VAVP_RLL_NEG ------------------- */

/**
<pre>
  VCONTROL.VC_VAVP4.VC_VAVP_RLL_NEG:

    Loadline (droop) resistance referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP) when load current is negative.
    Computed from PMBus commands as follows:
    <start table>
    "vc_vavp_rll_neg(U4.7) = MFR_RDROOP_RLL_NEG(Ux.y) * VOUT_SCALE_LOOP(U0.16) / (2^y * 2^(16-7))"
    "where, y = -1 * LINEAR11 exponent of MFR_RDROOP_RLL_NEG"
    <end table>
    LSB = 7.8125uOhm, Range = 0.0 to 15.9922mOhm

</pre> */

#define VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Pos                 0                                                                      /*!< Right-most bit position of vc_vavp_rll_neg in VCONTROL.VC_VAVP4 */
#define VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Msk                 (0x000007FFUL << VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Pos)              /*!< Mask for vc_vavp_rll_neg in VCONTROL.VC_VAVP4 */
#define VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Shift(v)            (((v) << VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Pos) & VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Msk) /*!< Shift value 'v' into vc_vavp_rll_neg and mask 'v' to fit it into vc_vavp_rll_neg field */

/** VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__SET() sets VC_VAVP4.VC_VAVP_RLL_NEG to given value.
 *
 * When writing to VC_VAVP4.VC_VAVP_RLL_NEG, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP4.VC_VAVP_RLL_NEG
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP4__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Msk);
    reg = (reg | (VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP4__SET(idp, reg);
}

/** VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__GET() gets VC_VAVP4.VC_VAVP_RLL_NEG's current value.
 *
 * When reading from VC_VAVP4.VC_VAVP_RLL_NEG, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP4.VC_VAVP_RLL_NEG
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP4__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Msk);
    reg = (reg >> VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__MODIFY() modifies VC_VAVP4.VC_VAVP_RLL_NEG.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP4
 * @param bf_value new value for VC_VAVP4.VC_VAVP_RLL_NEG
 * @return new value of VCONTROL.VC_VAVP4
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Msk);
    reg = (reg | (VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__EXTRACT() extracts VC_VAVP4.VC_VAVP_RLL_NEG.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP4
 * @return current value of VC_VAVP4.VC_VAVP_RLL_NEG
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Msk);
    reg = (reg >> VCONTROL_VC_VAVP4__VC_VAVP_RLL_NEG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        VC_IRQ member of VCONTROL_t                        */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_IRQ__ADDRESS returns the address of member VC_IRQ.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_IRQ
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_IRQ__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_IRQ)));
}

/** VCONTROL_VC_IRQ__SET() sets VC_IRQ to given value.
 *
 * When writing to VC_IRQ, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_IRQ
 */
__VCONTROL_INLINE void VCONTROL_VC_IRQ__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_IRQ__ADDRESS(idp), value);
}

/** VCONTROL_VC_IRQ__GET() gets VC_IRQ's current value.
 *
 * When reading from VC_IRQ, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_IRQ
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_IRQ__ADDRESS(idp));
}

/* ------------------- VCONTROL.VC_IRQ.VC_VCONTROL_IRQ_EN ------------------- */

/**
<pre>
  VCONTROL.VC_IRQ.VC_VCONTROL_IRQ_EN:

    Interrupt enable for Vcontrol.  When the bit indicated is high, the corresponding signal is enabled to generate an interrupt.
    <start table_with_header>
    Bit Signal
    0 "Ramp at target"
    1 "Ramp within vc_vramp_target window of target voltage"
    <end table>

</pre> */

#define VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Pos                0                                                                      /*!< Right-most bit position of vc_vcontrol_irq_en in VCONTROL.VC_IRQ */
#define VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Msk                (0x00000003UL << VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Pos)             /*!< Mask for vc_vcontrol_irq_en in VCONTROL.VC_IRQ */
#define VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Shift(v)           (((v) << VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Pos) & VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Msk) /*!< Shift value 'v' into vc_vcontrol_irq_en and mask 'v' to fit it into vc_vcontrol_irq_en field */

/** VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__SET() sets VC_IRQ.VC_VCONTROL_IRQ_EN to given value.
 *
 * When writing to VC_IRQ.VC_VCONTROL_IRQ_EN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_IRQ.VC_VCONTROL_IRQ_EN
 */
__VCONTROL_INLINE void VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_IRQ__GET(idp);
    reg = (reg & ~VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Msk);
    reg = (reg | (VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Shift((uint32_t)bf_value)));
    VCONTROL_VC_IRQ__SET(idp, reg);
}

/** VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__GET() gets VC_IRQ.VC_VCONTROL_IRQ_EN's current value.
 *
 * When reading from VC_IRQ.VC_VCONTROL_IRQ_EN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_IRQ.VC_VCONTROL_IRQ_EN
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_IRQ__GET(idp);
    reg = (reg & VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Msk);
    reg = (reg >> VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__MODIFY() modifies VC_IRQ.VC_VCONTROL_IRQ_EN.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_IRQ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_IRQ
 * @param bf_value new value for VC_IRQ.VC_VCONTROL_IRQ_EN
 * @return new value of VCONTROL.VC_IRQ
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Msk);
    reg = (reg | (VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__EXTRACT() extracts VC_IRQ.VC_VCONTROL_IRQ_EN.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_IRQ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_IRQ
 * @return current value of VC_IRQ.VC_VCONTROL_IRQ_EN
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Msk);
    reg = (reg >> VCONTROL_VC_IRQ__VC_VCONTROL_IRQ_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   VC_IRQ_STAT_FLAG member of VCONTROL_t                   */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_IRQ_STAT_FLAG__ADDRESS returns the address of member VC_IRQ_STAT_FLAG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_IRQ_STAT_FLAG
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_IRQ_STAT_FLAG__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_IRQ_STAT_FLAG)));
}

/** VCONTROL_VC_IRQ_STAT_FLAG__GET() gets VC_IRQ_STAT_FLAG's current value.
 *
 * When reading from VC_IRQ_STAT_FLAG, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_IRQ_STAT_FLAG
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_IRQ_STAT_FLAG__ADDRESS(idp));
}

/* ------------ VCONTROL.VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_RISE ------------ */

/**
<pre>
  VCONTROL.VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_RISE:

    Status flag indicating the vcontrol ramp is slewing in a rising direction.
    <start table>
    0 "ramp not rising (i.e., falling or at target)"
    1 "ramp rising"
    <end table>

</pre> */

#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__Pos   7                                                                      /*!< Right-most bit position of vc_vcontrol_ramp_rise in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__Msk   (0x00000001UL << VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__Pos) /*!< Mask for vc_vcontrol_ramp_rise in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__Shift(v) (((v) << VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__Pos) & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__Msk) /*!< Shift value 'v' into vc_vcontrol_ramp_rise and mask 'v' to fit it into vc_vcontrol_ramp_rise field */

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__GET() gets VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_RISE's current value.
 *
 * When reading from VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_RISE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_RISE
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_IRQ_STAT_FLAG__GET(idp);
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__EXTRACT() extracts VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_RISE.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_IRQ_STAT_FLAG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_IRQ_STAT_FLAG
 * @return current value of VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_RISE
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_RISE__Pos);
    return (uint32_t)reg;
}

/* ------------ VCONTROL.VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_FALL ------------ */

/**
<pre>
  VCONTROL.VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_FALL:

    Status flag indicating the vcontrol ramp is slewing in a falling direction.
    <start table>
    0 "ramp not falling (i.e., rising or at target)"
    1 "ramp falling"
    <end table>

</pre> */

#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__Pos   6                                                                      /*!< Right-most bit position of vc_vcontrol_ramp_fall in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__Msk   (0x00000001UL << VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__Pos) /*!< Mask for vc_vcontrol_ramp_fall in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__Shift(v) (((v) << VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__Pos) & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__Msk) /*!< Shift value 'v' into vc_vcontrol_ramp_fall and mask 'v' to fit it into vc_vcontrol_ramp_fall field */

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__GET() gets VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_FALL's current value.
 *
 * When reading from VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_FALL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_FALL
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_IRQ_STAT_FLAG__GET(idp);
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__EXTRACT() extracts VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_FALL.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_IRQ_STAT_FLAG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_IRQ_STAT_FLAG
 * @return current value of VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_FALL
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_FALL__Pos);
    return (uint32_t)reg;
}

/* ------------ VCONTROL.VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_BUSY ------------ */

/**
<pre>
  VCONTROL.VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_BUSY:

    Status flag indicating the vcontrol ramp is slewing (inverse of vc_vcontrol_at_target).
    <start table>
    0 "ramp not slewing"
    1 "ramp slewing"
    <end table>

</pre> */

#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__Pos   5                                                                      /*!< Right-most bit position of vc_vcontrol_ramp_busy in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__Msk   (0x00000001UL << VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__Pos) /*!< Mask for vc_vcontrol_ramp_busy in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__Shift(v) (((v) << VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__Pos) & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__Msk) /*!< Shift value 'v' into vc_vcontrol_ramp_busy and mask 'v' to fit it into vc_vcontrol_ramp_busy field */

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__GET() gets VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_BUSY's current value.
 *
 * When reading from VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_BUSY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_BUSY
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_IRQ_STAT_FLAG__GET(idp);
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__EXTRACT() extracts VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_BUSY.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_IRQ_STAT_FLAG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_IRQ_STAT_FLAG
 * @return current value of VC_IRQ_STAT_FLAG.VC_VCONTROL_RAMP_BUSY
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_RAMP_BUSY__Pos);
    return (uint32_t)reg;
}

/* ------------ VCONTROL.VC_IRQ_STAT_FLAG.VC_VCONTROL_AT_TARGET ------------ */

/**
<pre>
  VCONTROL.VC_IRQ_STAT_FLAG.VC_VCONTROL_AT_TARGET:

    Status flag indicating the vcontrol ramp is at the target voltage.
    <start table>
    0 "ramp not at target voltage"
    1 "ramp at target voltage"
    <end table>

</pre> */

#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__Pos   4                                                                      /*!< Right-most bit position of vc_vcontrol_at_target in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__Msk   (0x00000001UL << VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__Pos) /*!< Mask for vc_vcontrol_at_target in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__Shift(v) (((v) << VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__Pos) & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__Msk) /*!< Shift value 'v' into vc_vcontrol_at_target and mask 'v' to fit it into vc_vcontrol_at_target field */

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__GET() gets VC_IRQ_STAT_FLAG.VC_VCONTROL_AT_TARGET's current value.
 *
 * When reading from VC_IRQ_STAT_FLAG.VC_VCONTROL_AT_TARGET, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_IRQ_STAT_FLAG.VC_VCONTROL_AT_TARGET
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_IRQ_STAT_FLAG__GET(idp);
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__EXTRACT() extracts VC_IRQ_STAT_FLAG.VC_VCONTROL_AT_TARGET.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_IRQ_STAT_FLAG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_IRQ_STAT_FLAG
 * @return current value of VC_IRQ_STAT_FLAG.VC_VCONTROL_AT_TARGET
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_AT_TARGET__Pos);
    return (uint32_t)reg;
}

/* -------------- VCONTROL.VC_IRQ_STAT_FLAG.VC_UNDER_VOUT_MIN -------------- */

/**
<pre>
  VCONTROL.VC_IRQ_STAT_FLAG.VC_UNDER_VOUT_MIN:

    Vout min status flag
    <start table>
    0 "commanded target above vc_vout_min"
    1 "commanded target below vc_vout_min, will be clamped to vout_min (target of 0 is an exception that will not be clamped)."
    <end table>

</pre> */

#define VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__Pos       3                                                                      /*!< Right-most bit position of vc_under_vout_min in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__Msk       (0x00000001UL << VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__Pos)    /*!< Mask for vc_under_vout_min in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__Shift(v)  (((v) << VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__Pos) & VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__Msk) /*!< Shift value 'v' into vc_under_vout_min and mask 'v' to fit it into vc_under_vout_min field */

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__GET() gets VC_IRQ_STAT_FLAG.VC_UNDER_VOUT_MIN's current value.
 *
 * When reading from VC_IRQ_STAT_FLAG.VC_UNDER_VOUT_MIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_IRQ_STAT_FLAG.VC_UNDER_VOUT_MIN
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_IRQ_STAT_FLAG__GET(idp);
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__EXTRACT() extracts VC_IRQ_STAT_FLAG.VC_UNDER_VOUT_MIN.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_IRQ_STAT_FLAG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_IRQ_STAT_FLAG
 * @return current value of VC_IRQ_STAT_FLAG.VC_UNDER_VOUT_MIN
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_UNDER_VOUT_MIN__Pos);
    return (uint32_t)reg;
}

/* --------------- VCONTROL.VC_IRQ_STAT_FLAG.VC_OVER_VOUT_MAX --------------- */

/**
<pre>
  VCONTROL.VC_IRQ_STAT_FLAG.VC_OVER_VOUT_MAX:

    Vout max status flag
    <start table>
    0 "Vcontrol output below vc_vout_max"
    1 "Vcontrol output clamped to vc_vout_max"
    <end table>

</pre> */

#define VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__Pos        2                                                                      /*!< Right-most bit position of vc_over_vout_max in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__Msk        (0x00000001UL << VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__Pos)     /*!< Mask for vc_over_vout_max in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__Shift(v)   (((v) << VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__Pos) & VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__Msk) /*!< Shift value 'v' into vc_over_vout_max and mask 'v' to fit it into vc_over_vout_max field */

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__GET() gets VC_IRQ_STAT_FLAG.VC_OVER_VOUT_MAX's current value.
 *
 * When reading from VC_IRQ_STAT_FLAG.VC_OVER_VOUT_MAX, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_IRQ_STAT_FLAG.VC_OVER_VOUT_MAX
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_IRQ_STAT_FLAG__GET(idp);
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__EXTRACT() extracts VC_IRQ_STAT_FLAG.VC_OVER_VOUT_MAX.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_IRQ_STAT_FLAG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_IRQ_STAT_FLAG
 * @return current value of VC_IRQ_STAT_FLAG.VC_OVER_VOUT_MAX
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_OVER_VOUT_MAX__Pos);
    return (uint32_t)reg;
}

/* ------------- VCONTROL.VC_IRQ_STAT_FLAG.VC_VCONTROL_IRQ_STAT ------------- */

/**
<pre>
  VCONTROL.VC_IRQ_STAT_FLAG.VC_VCONTROL_IRQ_STAT:

    Interrupt status for Vcontrol.
    <start table_with_header>
    Bit Signal
    0 "Ramp at target"
    1 "Ramp within vc_vramp_target window of target voltage"
    <end table>

</pre> */

#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__Pos    0                                                                      /*!< Right-most bit position of vc_vcontrol_irq_stat in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__Msk    (0x00000003UL << VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__Pos) /*!< Mask for vc_vcontrol_irq_stat in VCONTROL.VC_IRQ_STAT_FLAG */
#define VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__Shift(v) (((v) << VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__Pos) & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__Msk) /*!< Shift value 'v' into vc_vcontrol_irq_stat and mask 'v' to fit it into vc_vcontrol_irq_stat field */

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__GET() gets VC_IRQ_STAT_FLAG.VC_VCONTROL_IRQ_STAT's current value.
 *
 * When reading from VC_IRQ_STAT_FLAG.VC_VCONTROL_IRQ_STAT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_IRQ_STAT_FLAG.VC_VCONTROL_IRQ_STAT
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_IRQ_STAT_FLAG__GET(idp);
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__EXTRACT() extracts VC_IRQ_STAT_FLAG.VC_VCONTROL_IRQ_STAT.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_IRQ_STAT_FLAG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_IRQ_STAT_FLAG
 * @return current value of VC_IRQ_STAT_FLAG.VC_VCONTROL_IRQ_STAT
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__Msk);
    reg = (reg >> VCONTROL_VC_IRQ_STAT_FLAG__VC_VCONTROL_IRQ_STAT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      VC_VCTRL_RD member of VCONTROL_t                      */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VCTRL_RD__ADDRESS returns the address of member VC_VCTRL_RD.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VCTRL_RD
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VCTRL_RD__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VCTRL_RD)));
}

/** VCONTROL_VC_VCTRL_RD__GET() gets VC_VCTRL_RD's current value.
 *
 * When reading from VC_VCTRL_RD, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VCTRL_RD
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VCTRL_RD__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VCTRL_RD__ADDRESS(idp));
}

/* -------------------- VCONTROL.VC_VCTRL_RD.VC_VCONTROL -------------------- */

/**
<pre>
  VCONTROL.VC_VCTRL_RD.VC_VCONTROL:

    Vcontrol status register.  Reflects target voltage referenced to the VSEN input (i.e., after scaling by VOUT_SCALE_LOOP) including offsets, droop, etc.
    LSB = 0.15625mV, Range = 0.0 to 5.119844V

</pre> */

#define VCONTROL_VC_VCTRL_RD__VC_VCONTROL__Pos                  0                                                                      /*!< Right-most bit position of vc_vcontrol in VCONTROL.VC_VCTRL_RD */
#define VCONTROL_VC_VCTRL_RD__VC_VCONTROL__Msk                  (0x00007FFFUL << VCONTROL_VC_VCTRL_RD__VC_VCONTROL__Pos)               /*!< Mask for vc_vcontrol in VCONTROL.VC_VCTRL_RD */
#define VCONTROL_VC_VCTRL_RD__VC_VCONTROL__Shift(v)             (((v) << VCONTROL_VC_VCTRL_RD__VC_VCONTROL__Pos) & VCONTROL_VC_VCTRL_RD__VC_VCONTROL__Msk) /*!< Shift value 'v' into vc_vcontrol and mask 'v' to fit it into vc_vcontrol field */

/** VCONTROL_VC_VCTRL_RD__VC_VCONTROL__GET() gets VC_VCTRL_RD.VC_VCONTROL's current value.
 *
 * When reading from VC_VCTRL_RD.VC_VCONTROL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VCTRL_RD.VC_VCONTROL
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VCTRL_RD__VC_VCONTROL__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VCTRL_RD__GET(idp);
    reg = (reg & VCONTROL_VC_VCTRL_RD__VC_VCONTROL__Msk);
    reg = (reg >> VCONTROL_VC_VCTRL_RD__VC_VCONTROL__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VCTRL_RD__VC_VCONTROL__EXTRACT() extracts VC_VCTRL_RD.VC_VCONTROL.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VCTRL_RD.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VCTRL_RD
 * @return current value of VC_VCTRL_RD.VC_VCONTROL
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VCTRL_RD__VC_VCONTROL__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VCTRL_RD__VC_VCONTROL__Msk);
    reg = (reg >> VCONTROL_VC_VCTRL_RD__VC_VCONTROL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VAVP5 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VAVP5__ADDRESS returns the address of member VC_VAVP5.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VAVP5
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VAVP5__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VAVP5)));
}

/** VCONTROL_VC_VAVP5__SET() sets VC_VAVP5 to given value.
 *
 * When writing to VC_VAVP5, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VAVP5
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP5__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VAVP5__ADDRESS(idp), value);
}

/** VCONTROL_VC_VAVP5__GET() gets VC_VAVP5's current value.
 *
 * When reading from VC_VAVP5, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP5
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP5__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VAVP5__ADDRESS(idp));
}

/* ------------------- VCONTROL.VC_VAVP5.VC_VAVP_RLL_SEG2 ------------------- */

/**
<pre>
  VCONTROL.VC_VAVP5.VC_VAVP_RLL_SEG2:

    Loadline (droop) resistance referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP) when load current exceeds vc_vavp_ithr_seg2
    Computed from PMBus commands as follows:
    <start table>
    "vc_vavp_rll_seg2(U9.1) = MFR_RDROOP_RLL_SEG2(Ux.y) * VOUT_SCALE_LOOP(U0.16) / (2^y * 2^(16-1))"
    "where, y = -1 * LINEAR11 exponent of MFR_RDROOP_RLL_SEG2"
    <end table>
    LSB = 0.5mOhm, Range = 0.0 to 511.5mOhm

</pre> */

#define VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Pos                0                                                                      /*!< Right-most bit position of vc_vavp_rll_seg2 in VCONTROL.VC_VAVP5 */
#define VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Msk                (0x000003FFUL << VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Pos)             /*!< Mask for vc_vavp_rll_seg2 in VCONTROL.VC_VAVP5 */
#define VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Shift(v)           (((v) << VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Pos) & VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Msk) /*!< Shift value 'v' into vc_vavp_rll_seg2 and mask 'v' to fit it into vc_vavp_rll_seg2 field */

/** VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__SET() sets VC_VAVP5.VC_VAVP_RLL_SEG2 to given value.
 *
 * When writing to VC_VAVP5.VC_VAVP_RLL_SEG2, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP5.VC_VAVP_RLL_SEG2
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP5__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Msk);
    reg = (reg | (VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP5__SET(idp, reg);
}

/** VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__GET() gets VC_VAVP5.VC_VAVP_RLL_SEG2's current value.
 *
 * When reading from VC_VAVP5.VC_VAVP_RLL_SEG2, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP5.VC_VAVP_RLL_SEG2
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP5__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Msk);
    reg = (reg >> VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__MODIFY() modifies VC_VAVP5.VC_VAVP_RLL_SEG2.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP5
 * @param bf_value new value for VC_VAVP5.VC_VAVP_RLL_SEG2
 * @return new value of VCONTROL.VC_VAVP5
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Msk);
    reg = (reg | (VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__EXTRACT() extracts VC_VAVP5.VC_VAVP_RLL_SEG2.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP5
 * @return current value of VC_VAVP5.VC_VAVP_RLL_SEG2
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Msk);
    reg = (reg >> VCONTROL_VC_VAVP5__VC_VAVP_RLL_SEG2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VAVP6 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VAVP6__ADDRESS returns the address of member VC_VAVP6.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VAVP6
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VAVP6__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VAVP6)));
}

/** VCONTROL_VC_VAVP6__SET() sets VC_VAVP6 to given value.
 *
 * When writing to VC_VAVP6, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VAVP6
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP6__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VAVP6__ADDRESS(idp), value);
}

/** VCONTROL_VC_VAVP6__GET() gets VC_VAVP6's current value.
 *
 * When reading from VC_VAVP6, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP6
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP6__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VAVP6__ADDRESS(idp));
}

/* ------------------- VCONTROL.VC_VAVP6.VC_VAVP_RLL_SEG3 ------------------- */

/**
<pre>
  VCONTROL.VC_VAVP6.VC_VAVP_RLL_SEG3:

    Loadline (droop) resistance referenced to VSEN input (i.e., after scaling by VOUT_SCALE_LOOP) when load current exceeds vc_vavp_ithr_seg3
    Computed from PMBus commands as follows:
    <start table>
    "vc_vavp_rll_seg3(U9.1) =MFR_RDROOP_RLL_SEG3(Ux.y) * VOUT_SCALE_LOOP(U0.16) / (2^y * 2^(16-1))"
    "where, y = -1 * LINEAR11 exponent of MFR_RDROOP_RLL_SEG3"
    <end table>
    LSB = 0.5mOhm, Range = 0.0 to 511.5mOhm

</pre> */

#define VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Pos                0                                                                      /*!< Right-most bit position of vc_vavp_rll_seg3 in VCONTROL.VC_VAVP6 */
#define VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Msk                (0x000003FFUL << VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Pos)             /*!< Mask for vc_vavp_rll_seg3 in VCONTROL.VC_VAVP6 */
#define VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Shift(v)           (((v) << VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Pos) & VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Msk) /*!< Shift value 'v' into vc_vavp_rll_seg3 and mask 'v' to fit it into vc_vavp_rll_seg3 field */

/** VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__SET() sets VC_VAVP6.VC_VAVP_RLL_SEG3 to given value.
 *
 * When writing to VC_VAVP6.VC_VAVP_RLL_SEG3, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP6.VC_VAVP_RLL_SEG3
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP6__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Msk);
    reg = (reg | (VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP6__SET(idp, reg);
}

/** VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__GET() gets VC_VAVP6.VC_VAVP_RLL_SEG3's current value.
 *
 * When reading from VC_VAVP6.VC_VAVP_RLL_SEG3, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP6.VC_VAVP_RLL_SEG3
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP6__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Msk);
    reg = (reg >> VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__MODIFY() modifies VC_VAVP6.VC_VAVP_RLL_SEG3.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP6.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP6
 * @param bf_value new value for VC_VAVP6.VC_VAVP_RLL_SEG3
 * @return new value of VCONTROL.VC_VAVP6
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Msk);
    reg = (reg | (VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__EXTRACT() extracts VC_VAVP6.VC_VAVP_RLL_SEG3.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP6.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP6
 * @return current value of VC_VAVP6.VC_VAVP_RLL_SEG3
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Msk);
    reg = (reg >> VCONTROL_VC_VAVP6__VC_VAVP_RLL_SEG3__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VAVP7 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VAVP7__ADDRESS returns the address of member VC_VAVP7.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VAVP7
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VAVP7__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VAVP7)));
}

/** VCONTROL_VC_VAVP7__SET() sets VC_VAVP7 to given value.
 *
 * When writing to VC_VAVP7, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VAVP7
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP7__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VAVP7__ADDRESS(idp), value);
}

/** VCONTROL_VC_VAVP7__GET() gets VC_VAVP7's current value.
 *
 * When reading from VC_VAVP7, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP7
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP7__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VAVP7__ADDRESS(idp));
}

/* ------------------ VCONTROL.VC_VAVP7.VC_VAVP_ITHR_SEG2 ------------------ */

/**
<pre>
  VCONTROL.VC_VAVP7.VC_VAVP_ITHR_SEG2:

    When load current is above vc_vavp_ithr_seg2 and less than or equal to vc_vavp_ithr_seg3 the loadline (droop) resistance will be defined by vc_vavp_rll_seg2.  Note that a setting of 0 will disable this segment.
    Computed from PMBus command as follows:
    <start table>
    "vc_vavp_ithr_seg2(U8.1) = MFR_RDROOP_ITHR_SEG2(UX.Y) * 2^Y"
    "where, Y = LINEAR11 exponent of MFR_RDROOP_ITHR_SEG2"
    <end table>
    LSB = 0.5A, Range = 0.0 to 255.5A

</pre> */

#define VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Pos               0                                                                      /*!< Right-most bit position of vc_vavp_ithr_seg2 in VCONTROL.VC_VAVP7 */
#define VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Msk               (0x000001FFUL << VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Pos)            /*!< Mask for vc_vavp_ithr_seg2 in VCONTROL.VC_VAVP7 */
#define VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Shift(v)          (((v) << VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Pos) & VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Msk) /*!< Shift value 'v' into vc_vavp_ithr_seg2 and mask 'v' to fit it into vc_vavp_ithr_seg2 field */

/** VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__SET() sets VC_VAVP7.VC_VAVP_ITHR_SEG2 to given value.
 *
 * When writing to VC_VAVP7.VC_VAVP_ITHR_SEG2, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP7.VC_VAVP_ITHR_SEG2
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP7__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Msk);
    reg = (reg | (VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP7__SET(idp, reg);
}

/** VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__GET() gets VC_VAVP7.VC_VAVP_ITHR_SEG2's current value.
 *
 * When reading from VC_VAVP7.VC_VAVP_ITHR_SEG2, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP7.VC_VAVP_ITHR_SEG2
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP7__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Msk);
    reg = (reg >> VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__MODIFY() modifies VC_VAVP7.VC_VAVP_ITHR_SEG2.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP7.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP7
 * @param bf_value new value for VC_VAVP7.VC_VAVP_ITHR_SEG2
 * @return new value of VCONTROL.VC_VAVP7
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Msk);
    reg = (reg | (VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__EXTRACT() extracts VC_VAVP7.VC_VAVP_ITHR_SEG2.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP7.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP7
 * @return current value of VC_VAVP7.VC_VAVP_ITHR_SEG2
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Msk);
    reg = (reg >> VCONTROL_VC_VAVP7__VC_VAVP_ITHR_SEG2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VAVP8 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VAVP8__ADDRESS returns the address of member VC_VAVP8.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VAVP8
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VAVP8__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VAVP8)));
}

/** VCONTROL_VC_VAVP8__SET() sets VC_VAVP8 to given value.
 *
 * When writing to VC_VAVP8, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VAVP8
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP8__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VAVP8__ADDRESS(idp), value);
}

/** VCONTROL_VC_VAVP8__GET() gets VC_VAVP8's current value.
 *
 * When reading from VC_VAVP8, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP8
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP8__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VAVP8__ADDRESS(idp));
}

/* ------------------ VCONTROL.VC_VAVP8.VC_VAVP_ITHR_SEG3 ------------------ */

/**
<pre>
  VCONTROL.VC_VAVP8.VC_VAVP_ITHR_SEG3:

    When load current is above vc_vavp_ithr_seg3 the loadline (droop) resistance will be defined by vc_vavp_rll_seg3.  Note that a setting of 0 will disable this segment.
    Computed from PMBus command as follows:
    <start table>
    "vc_vavp_ithr_seg3(U8.1) = MFR_RDROOP_ITHR_SEG3(UX.Y) * 2^Y"
    "where, Y = LINEAR11 exponent of MFR_RDROOP_ITHR_SEG3"
    <end table>
    LSB = 0.5A, Range = 0.0 to 255.5A

</pre> */

#define VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Pos               0                                                                      /*!< Right-most bit position of vc_vavp_ithr_seg3 in VCONTROL.VC_VAVP8 */
#define VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Msk               (0x000001FFUL << VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Pos)            /*!< Mask for vc_vavp_ithr_seg3 in VCONTROL.VC_VAVP8 */
#define VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Shift(v)          (((v) << VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Pos) & VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Msk) /*!< Shift value 'v' into vc_vavp_ithr_seg3 and mask 'v' to fit it into vc_vavp_ithr_seg3 field */

/** VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__SET() sets VC_VAVP8.VC_VAVP_ITHR_SEG3 to given value.
 *
 * When writing to VC_VAVP8.VC_VAVP_ITHR_SEG3, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP8.VC_VAVP_ITHR_SEG3
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP8__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Msk);
    reg = (reg | (VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP8__SET(idp, reg);
}

/** VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__GET() gets VC_VAVP8.VC_VAVP_ITHR_SEG3's current value.
 *
 * When reading from VC_VAVP8.VC_VAVP_ITHR_SEG3, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP8.VC_VAVP_ITHR_SEG3
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP8__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Msk);
    reg = (reg >> VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__MODIFY() modifies VC_VAVP8.VC_VAVP_ITHR_SEG3.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP8.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP8
 * @param bf_value new value for VC_VAVP8.VC_VAVP_ITHR_SEG3
 * @return new value of VCONTROL.VC_VAVP8
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Msk);
    reg = (reg | (VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__EXTRACT() extracts VC_VAVP8.VC_VAVP_ITHR_SEG3.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP8.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP8
 * @return current value of VC_VAVP8.VC_VAVP_ITHR_SEG3
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Msk);
    reg = (reg >> VCONTROL_VC_VAVP8__VC_VAVP_ITHR_SEG3__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VC_VAVP9 member of VCONTROL_t                       */
/* -------------------------------------------------------------------------- */

/** __VCONTROL_VC_VAVP9__ADDRESS returns the address of member VC_VAVP9.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of VC_VAVP9
 */
__VCONTROL_INLINE uint32_t* __VCONTROL_VC_VAVP9__ADDRESS(vcontrol_idx_t idp)
{
    return (uint32_t*)((uint32_t)__VCONTROL_BASE_PTR(idp) + (uint32_t)(offsetof(VCONTROL_t, VC_VAVP9)));
}

/** VCONTROL_VC_VAVP9__SET() sets VC_VAVP9 to given value.
 *
 * When writing to VC_VAVP9, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for VC_VAVP9
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP9__SET(vcontrol_idx_t idp, uint32_t value)
{
    HAL_SET32(__VCONTROL_VC_VAVP9__ADDRESS(idp), value);
}

/** VCONTROL_VC_VAVP9__GET() gets VC_VAVP9's current value.
 *
 * When reading from VC_VAVP9, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP9
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP9__GET(vcontrol_idx_t idp)
{
    return HAL_GET32(__VCONTROL_VC_VAVP9__ADDRESS(idp));
}

/* ----------------- VCONTROL.VC_VAVP9.VC_VAVP_ITOT_UC_SEL ----------------- */

/**
<pre>
  VCONTROL.VC_VAVP9.VC_VAVP_ITOT_UC_SEL:

    Selects total current used by AVP (Droop) function
    <start table>
    0 "HW computed current +vc_vavp_itot_delta"
    1 vc_vavp_otpt_uc_sel
    <end table>

</pre> */

#define VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Pos             13                                                                     /*!< Right-most bit position of vc_vavp_itot_uc_sel in VCONTROL.VC_VAVP9 */
#define VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Msk             (0x00000001UL << VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Pos)          /*!< Mask for vc_vavp_itot_uc_sel in VCONTROL.VC_VAVP9 */
#define VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Shift(v)        (((v) << VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Pos) & VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Msk) /*!< Shift value 'v' into vc_vavp_itot_uc_sel and mask 'v' to fit it into vc_vavp_itot_uc_sel field */

/** VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__SET() sets VC_VAVP9.VC_VAVP_ITOT_UC_SEL to given value.
 *
 * When writing to VC_VAVP9.VC_VAVP_ITOT_UC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP9.VC_VAVP_ITOT_UC_SEL
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP9__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Msk);
    reg = (reg | (VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP9__SET(idp, reg);
}

/** VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__GET() gets VC_VAVP9.VC_VAVP_ITOT_UC_SEL's current value.
 *
 * When reading from VC_VAVP9.VC_VAVP_ITOT_UC_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP9.VC_VAVP_ITOT_UC_SEL
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP9__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Msk);
    reg = (reg >> VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__MODIFY() modifies VC_VAVP9.VC_VAVP_ITOT_UC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP9.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP9
 * @param bf_value new value for VC_VAVP9.VC_VAVP_ITOT_UC_SEL
 * @return new value of VCONTROL.VC_VAVP9
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Msk);
    reg = (reg | (VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__EXTRACT() extracts VC_VAVP9.VC_VAVP_ITOT_UC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP9.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP9
 * @return current value of VC_VAVP9.VC_VAVP_ITOT_UC_SEL
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Msk);
    reg = (reg >> VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------- VCONTROL.VC_VAVP9.VC_VAVP_ITOT_UC ------------------- */

/**
<pre>
  VCONTROL.VC_VAVP9.VC_VAVP_ITOT_UC:

    Total current replacement term.  Allows FW to override HW computed total current for Droop computation when selected by vc_vavp_itot_uc_sel.
    LSB = 62.5mA, Range = -256 to +2559375A

</pre> */

#define VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Pos                 0                                                                      /*!< Right-most bit position of vc_vavp_itot_uc in VCONTROL.VC_VAVP9 */
#define VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Msk                 (0x00001FFFUL << VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Pos)              /*!< Mask for vc_vavp_itot_uc in VCONTROL.VC_VAVP9 */
#define VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Shift(v)            (((v) << VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Pos) & VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Msk) /*!< Shift value 'v' into vc_vavp_itot_uc and mask 'v' to fit it into vc_vavp_itot_uc field */

/** VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__SET() sets VC_VAVP9.VC_VAVP_ITOT_UC to given value.
 *
 * When writing to VC_VAVP9.VC_VAVP_ITOT_UC, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for VC_VAVP9.VC_VAVP_ITOT_UC
 */
__VCONTROL_INLINE void VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__SET(vcontrol_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = VCONTROL_VC_VAVP9__GET(idp);
    reg = (reg & ~VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Msk);
    reg = (reg | (VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Shift((uint32_t)bf_value)));
    VCONTROL_VC_VAVP9__SET(idp, reg);
}

/** VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__GET() gets VC_VAVP9.VC_VAVP_ITOT_UC's current value.
 *
 * When reading from VC_VAVP9.VC_VAVP_ITOT_UC, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of VC_VAVP9.VC_VAVP_ITOT_UC
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__GET(vcontrol_idx_t idp)
{
    uint32_t reg = VCONTROL_VC_VAVP9__GET(idp);
    reg = (reg & VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Msk);
    reg = (reg >> VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Pos);
    return (uint32_t)reg;
}

/** VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__MODIFY() modifies VC_VAVP9.VC_VAVP_ITOT_UC.
 *
 * This is recommended to use when setting more than one bitfield of VCONTROL.VC_VAVP9.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of VCONTROL.VC_VAVP9
 * @param bf_value new value for VC_VAVP9.VC_VAVP_ITOT_UC
 * @return new value of VCONTROL.VC_VAVP9
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Msk);
    reg = (reg | (VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Shift((uint32_t)bf_value)));
    return reg;
}

/** VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__EXTRACT() extracts VC_VAVP9.VC_VAVP_ITOT_UC.
 *
 * This is recommended to use when extracting more than one bitfield from VCONTROL.VC_VAVP9.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of VCONTROL.VC_VAVP9
 * @return current value of VC_VAVP9.VC_VAVP_ITOT_UC
 */
__VCONTROL_INLINE uint32_t VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__EXTRACT(uint32_t reg)
{
    reg = (reg & VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Msk);
    reg = (reg >> VCONTROL_VC_VAVP9__VC_VAVP_ITOT_UC__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group vcontrol block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_VCONTROL_H_ */
