/**
 * @file     shasta_hal_scu.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_SCU_H_
#define _SHASTA_HAL_SCU_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup scu
 * @{
 */

#if defined ( __CC_ARM )
#define __SCU_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __SCU_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __SCU_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __SCU_INLINE  static inline
#endif

/** register file of the scu block.
 */
typedef struct _SCU_s
{
    volatile        uint32_t        CPUS_CFG                    ; /*!< (@0x00000000) CPU Subsystem Configuration Register */
    volatile        uint32_t        CPUS_CFG_SET                ; /*!< (@0x00000004) CPU Subsystem Configuration Register */
    volatile        uint32_t        CPUS_CFG_CLR                ; /*!< (@0x00000008) CPU Subsystem Configuration Register */
    volatile        uint32_t        NMI_SRC_EN                  ; /*!< (@0x0000000C) NMI Source Enable Register */
    volatile        uint32_t        DRVR                        ; /*!< (@0x00000010) MSM Status Register */
    volatile        uint32_t        MONR                        ; /*!< (@0x00000014) MSM Status Register */
    volatile        uint8_t         REGMEMGAP0[8]               ; /*!< (@0x00000018) gap in address space */
    volatile        uint32_t        SPARE_FF                    ; /*!< (@0x00000020) Spare Register */
} SCU_t;


#define SCU_BASE (0x40000000u)                                                          /*!< scu base address */

/** __SCU_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__SCU_INLINE uint32_t* __SCU_BASE_PTR(void)
{
    return (uint32_t*)(SCU_BASE);
}


/* -------------------------------------------------------------------------- */
/*                          CPUS_CFG member of SCU_t                          */
/* -------------------------------------------------------------------------- */

/** __SCU_CPUS_CFG__ADDRESS returns the address of member CPUS_CFG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CPUS_CFG
 */
__SCU_INLINE uint32_t* __SCU_CPUS_CFG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__SCU_BASE_PTR() + (uint32_t)(offsetof(SCU_t, CPUS_CFG)));
}

/** SCU_CPUS_CFG__SET() sets CPUS_CFG to given value.
 *
 * When writing to CPUS_CFG, this is mandatory to use.
 *
 * @param value new value for CPUS_CFG
 */
__SCU_INLINE void SCU_CPUS_CFG__SET(uint32_t value)
{
    HAL_SET32(__SCU_CPUS_CFG__ADDRESS(), value);
}

/** SCU_CPUS_CFG__GET() gets CPUS_CFG's current value.
 *
 * When reading from CPUS_CFG, this is mandatory to use.
 *
 * @return current value of CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__GET(void)
{
    return HAL_GET32(__SCU_CPUS_CFG__ADDRESS());
}

/* ----------------------- SCU.CPUS_CFG.EN_GPIO1_WKUP ----------------------- */

/**
<pre>
  SCU.CPUS_CFG.EN_GPIO1_WKUP:

    1: CPUS GPIO1_IRQ wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG__EN_GPIO1_WKUP__Pos                        23                                                                     /*!< Right-most bit position of EN_GPIO1_WKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_GPIO1_WKUP__Msk                        (0x00000001UL << SCU_CPUS_CFG__EN_GPIO1_WKUP__Pos)                     /*!< Mask for EN_GPIO1_WKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_GPIO1_WKUP__Shift(v)                   (((v) << SCU_CPUS_CFG__EN_GPIO1_WKUP__Pos) & SCU_CPUS_CFG__EN_GPIO1_WKUP__Msk) /*!< Shift value 'v' into EN_GPIO1_WKUP and mask 'v' to fit it into EN_GPIO1_WKUP field */

/** SCU_CPUS_CFG__EN_GPIO1_WKUP__SET() sets CPUS_CFG.EN_GPIO1_WKUP to given value.
 *
 * When writing to CPUS_CFG.EN_GPIO1_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.EN_GPIO1_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG__EN_GPIO1_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__EN_GPIO1_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_GPIO1_WKUP__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__EN_GPIO1_WKUP__GET() gets CPUS_CFG.EN_GPIO1_WKUP's current value.
 *
 * When reading from CPUS_CFG.EN_GPIO1_WKUP, this is recommended to use.
 *
 * @return current value of CPUS_CFG.EN_GPIO1_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_GPIO1_WKUP__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__EN_GPIO1_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_GPIO1_WKUP__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__EN_GPIO1_WKUP__MODIFY() modifies CPUS_CFG.EN_GPIO1_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.EN_GPIO1_WKUP
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_GPIO1_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__EN_GPIO1_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_GPIO1_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__EN_GPIO1_WKUP__EXTRACT() extracts CPUS_CFG.EN_GPIO1_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.EN_GPIO1_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_GPIO1_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__EN_GPIO1_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_GPIO1_WKUP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG.EN_GPIO0_WKUP ----------------------- */

/**
<pre>
  SCU.CPUS_CFG.EN_GPIO0_WKUP:

    1: CPUS GPIO0_IRQ wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG__EN_GPIO0_WKUP__Pos                        22                                                                     /*!< Right-most bit position of EN_GPIO0_WKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_GPIO0_WKUP__Msk                        (0x00000001UL << SCU_CPUS_CFG__EN_GPIO0_WKUP__Pos)                     /*!< Mask for EN_GPIO0_WKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_GPIO0_WKUP__Shift(v)                   (((v) << SCU_CPUS_CFG__EN_GPIO0_WKUP__Pos) & SCU_CPUS_CFG__EN_GPIO0_WKUP__Msk) /*!< Shift value 'v' into EN_GPIO0_WKUP and mask 'v' to fit it into EN_GPIO0_WKUP field */

/** SCU_CPUS_CFG__EN_GPIO0_WKUP__SET() sets CPUS_CFG.EN_GPIO0_WKUP to given value.
 *
 * When writing to CPUS_CFG.EN_GPIO0_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.EN_GPIO0_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG__EN_GPIO0_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__EN_GPIO0_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_GPIO0_WKUP__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__EN_GPIO0_WKUP__GET() gets CPUS_CFG.EN_GPIO0_WKUP's current value.
 *
 * When reading from CPUS_CFG.EN_GPIO0_WKUP, this is recommended to use.
 *
 * @return current value of CPUS_CFG.EN_GPIO0_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_GPIO0_WKUP__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__EN_GPIO0_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_GPIO0_WKUP__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__EN_GPIO0_WKUP__MODIFY() modifies CPUS_CFG.EN_GPIO0_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.EN_GPIO0_WKUP
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_GPIO0_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__EN_GPIO0_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_GPIO0_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__EN_GPIO0_WKUP__EXTRACT() extracts CPUS_CFG.EN_GPIO0_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.EN_GPIO0_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_GPIO0_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__EN_GPIO0_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_GPIO0_WKUP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG.EN_PMBUS_WKUP ----------------------- */

/**
<pre>
  SCU.CPUS_CFG.EN_PMBUS_WKUP:

    1: CPUS PMBUS_IRQ wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG__EN_PMBUS_WKUP__Pos                        21                                                                     /*!< Right-most bit position of EN_PMBUS_WKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_PMBUS_WKUP__Msk                        (0x00000001UL << SCU_CPUS_CFG__EN_PMBUS_WKUP__Pos)                     /*!< Mask for EN_PMBUS_WKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_PMBUS_WKUP__Shift(v)                   (((v) << SCU_CPUS_CFG__EN_PMBUS_WKUP__Pos) & SCU_CPUS_CFG__EN_PMBUS_WKUP__Msk) /*!< Shift value 'v' into EN_PMBUS_WKUP and mask 'v' to fit it into EN_PMBUS_WKUP field */

/** SCU_CPUS_CFG__EN_PMBUS_WKUP__SET() sets CPUS_CFG.EN_PMBUS_WKUP to given value.
 *
 * When writing to CPUS_CFG.EN_PMBUS_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.EN_PMBUS_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG__EN_PMBUS_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__EN_PMBUS_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_PMBUS_WKUP__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__EN_PMBUS_WKUP__GET() gets CPUS_CFG.EN_PMBUS_WKUP's current value.
 *
 * When reading from CPUS_CFG.EN_PMBUS_WKUP, this is recommended to use.
 *
 * @return current value of CPUS_CFG.EN_PMBUS_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_PMBUS_WKUP__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__EN_PMBUS_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_PMBUS_WKUP__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__EN_PMBUS_WKUP__MODIFY() modifies CPUS_CFG.EN_PMBUS_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.EN_PMBUS_WKUP
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_PMBUS_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__EN_PMBUS_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_PMBUS_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__EN_PMBUS_WKUP__EXTRACT() extracts CPUS_CFG.EN_PMBUS_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.EN_PMBUS_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_PMBUS_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__EN_PMBUS_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_PMBUS_WKUP__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.CPUS_CFG.EN_AUX_EXTWKUP ---------------------- */

/**
<pre>
  SCU.CPUS_CFG.EN_AUX_EXTWKUP:

    1: CPUS EXT-3 wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG__EN_AUX_EXTWKUP__Pos                       20                                                                     /*!< Right-most bit position of EN_AUX_EXTWKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_AUX_EXTWKUP__Msk                       (0x00000001UL << SCU_CPUS_CFG__EN_AUX_EXTWKUP__Pos)                    /*!< Mask for EN_AUX_EXTWKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_AUX_EXTWKUP__Shift(v)                  (((v) << SCU_CPUS_CFG__EN_AUX_EXTWKUP__Pos) & SCU_CPUS_CFG__EN_AUX_EXTWKUP__Msk) /*!< Shift value 'v' into EN_AUX_EXTWKUP and mask 'v' to fit it into EN_AUX_EXTWKUP field */

/** SCU_CPUS_CFG__EN_AUX_EXTWKUP__SET() sets CPUS_CFG.EN_AUX_EXTWKUP to given value.
 *
 * When writing to CPUS_CFG.EN_AUX_EXTWKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.EN_AUX_EXTWKUP
 */
__SCU_INLINE void SCU_CPUS_CFG__EN_AUX_EXTWKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__EN_AUX_EXTWKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_AUX_EXTWKUP__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__EN_AUX_EXTWKUP__GET() gets CPUS_CFG.EN_AUX_EXTWKUP's current value.
 *
 * When reading from CPUS_CFG.EN_AUX_EXTWKUP, this is recommended to use.
 *
 * @return current value of CPUS_CFG.EN_AUX_EXTWKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_AUX_EXTWKUP__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__EN_AUX_EXTWKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_AUX_EXTWKUP__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__EN_AUX_EXTWKUP__MODIFY() modifies CPUS_CFG.EN_AUX_EXTWKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.EN_AUX_EXTWKUP
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_AUX_EXTWKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__EN_AUX_EXTWKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_AUX_EXTWKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__EN_AUX_EXTWKUP__EXTRACT() extracts CPUS_CFG.EN_AUX_EXTWKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.EN_AUX_EXTWKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_AUX_EXTWKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__EN_AUX_EXTWKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_AUX_EXTWKUP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG.EN_SVID1_WKUP ----------------------- */

/**
<pre>
  SCU.CPUS_CFG.EN_SVID1_WKUP:

    1: CPUS INT_SVID1 wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG__EN_SVID1_WKUP__Pos                        19                                                                     /*!< Right-most bit position of EN_SVID1_WKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_SVID1_WKUP__Msk                        (0x00000001UL << SCU_CPUS_CFG__EN_SVID1_WKUP__Pos)                     /*!< Mask for EN_SVID1_WKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_SVID1_WKUP__Shift(v)                   (((v) << SCU_CPUS_CFG__EN_SVID1_WKUP__Pos) & SCU_CPUS_CFG__EN_SVID1_WKUP__Msk) /*!< Shift value 'v' into EN_SVID1_WKUP and mask 'v' to fit it into EN_SVID1_WKUP field */

/** SCU_CPUS_CFG__EN_SVID1_WKUP__SET() sets CPUS_CFG.EN_SVID1_WKUP to given value.
 *
 * When writing to CPUS_CFG.EN_SVID1_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.EN_SVID1_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG__EN_SVID1_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__EN_SVID1_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_SVID1_WKUP__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__EN_SVID1_WKUP__GET() gets CPUS_CFG.EN_SVID1_WKUP's current value.
 *
 * When reading from CPUS_CFG.EN_SVID1_WKUP, this is recommended to use.
 *
 * @return current value of CPUS_CFG.EN_SVID1_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_SVID1_WKUP__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__EN_SVID1_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_SVID1_WKUP__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__EN_SVID1_WKUP__MODIFY() modifies CPUS_CFG.EN_SVID1_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.EN_SVID1_WKUP
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_SVID1_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__EN_SVID1_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_SVID1_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__EN_SVID1_WKUP__EXTRACT() extracts CPUS_CFG.EN_SVID1_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.EN_SVID1_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_SVID1_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__EN_SVID1_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_SVID1_WKUP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG.EN_SVID0_WKUP ----------------------- */

/**
<pre>
  SCU.CPUS_CFG.EN_SVID0_WKUP:

    1: CPUS INT_SVID0 wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG__EN_SVID0_WKUP__Pos                        18                                                                     /*!< Right-most bit position of EN_SVID0_WKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_SVID0_WKUP__Msk                        (0x00000001UL << SCU_CPUS_CFG__EN_SVID0_WKUP__Pos)                     /*!< Mask for EN_SVID0_WKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_SVID0_WKUP__Shift(v)                   (((v) << SCU_CPUS_CFG__EN_SVID0_WKUP__Pos) & SCU_CPUS_CFG__EN_SVID0_WKUP__Msk) /*!< Shift value 'v' into EN_SVID0_WKUP and mask 'v' to fit it into EN_SVID0_WKUP field */

/** SCU_CPUS_CFG__EN_SVID0_WKUP__SET() sets CPUS_CFG.EN_SVID0_WKUP to given value.
 *
 * When writing to CPUS_CFG.EN_SVID0_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.EN_SVID0_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG__EN_SVID0_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__EN_SVID0_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_SVID0_WKUP__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__EN_SVID0_WKUP__GET() gets CPUS_CFG.EN_SVID0_WKUP's current value.
 *
 * When reading from CPUS_CFG.EN_SVID0_WKUP, this is recommended to use.
 *
 * @return current value of CPUS_CFG.EN_SVID0_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_SVID0_WKUP__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__EN_SVID0_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_SVID0_WKUP__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__EN_SVID0_WKUP__MODIFY() modifies CPUS_CFG.EN_SVID0_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.EN_SVID0_WKUP
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_SVID0_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__EN_SVID0_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_SVID0_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__EN_SVID0_WKUP__EXTRACT() extracts CPUS_CFG.EN_SVID0_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.EN_SVID0_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_SVID0_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__EN_SVID0_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_SVID0_WKUP__Pos);
    return (uint32_t)reg;
}

/* ----------------- SCU.CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK ----------------- */

/**
<pre>
  SCU.CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Pos             17                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER11_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Msk             (0x00000001UL << SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Pos)          /*!< Mask for SEL_SRC_DTIMER11_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Shift(v)        (((v) << SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Pos) & SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER11_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER11_KRN_CLK field */

/** SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__SET() sets CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__GET() gets CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK's current value.
 *
 * When reading from CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK, this is recommended to use.
 *
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__MODIFY() modifies CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__EXTRACT() extracts CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER11_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER11_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* ----------------- SCU.CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK ----------------- */

/**
<pre>
  SCU.CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Pos             16                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER12_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Msk             (0x00000001UL << SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Pos)          /*!< Mask for SEL_SRC_DTIMER12_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Shift(v)        (((v) << SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Pos) & SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER12_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER12_KRN_CLK field */

/** SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__SET() sets CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__GET() gets CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK's current value.
 *
 * When reading from CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK, this is recommended to use.
 *
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__MODIFY() modifies CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__EXTRACT() extracts CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER12_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER12_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* ----------------- SCU.CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK ----------------- */

/**
<pre>
  SCU.CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Pos             15                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER21_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Msk             (0x00000001UL << SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Pos)          /*!< Mask for SEL_SRC_DTIMER21_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Shift(v)        (((v) << SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Pos) & SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER21_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER21_KRN_CLK field */

/** SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__SET() sets CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__GET() gets CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK's current value.
 *
 * When reading from CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK, this is recommended to use.
 *
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__MODIFY() modifies CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__EXTRACT() extracts CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER21_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER21_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* ----------------- SCU.CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK ----------------- */

/**
<pre>
  SCU.CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Pos             14                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER22_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Msk             (0x00000001UL << SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Pos)          /*!< Mask for SEL_SRC_DTIMER22_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Shift(v)        (((v) << SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Pos) & SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER22_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER22_KRN_CLK field */

/** SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__SET() sets CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__GET() gets CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK's current value.
 *
 * When reading from CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK, this is recommended to use.
 *
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__MODIFY() modifies CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__EXTRACT() extracts CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER22_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER22_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* ----------------- SCU.CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK ----------------- */

/**
<pre>
  SCU.CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Pos             13                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER31_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Msk             (0x00000001UL << SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Pos)          /*!< Mask for SEL_SRC_DTIMER31_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Shift(v)        (((v) << SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Pos) & SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER31_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER31_KRN_CLK field */

/** SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__SET() sets CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__GET() gets CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK's current value.
 *
 * When reading from CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK, this is recommended to use.
 *
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__MODIFY() modifies CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__EXTRACT() extracts CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER31_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER31_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* ----------------- SCU.CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK ----------------- */

/**
<pre>
  SCU.CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Pos             12                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER32_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Msk             (0x00000001UL << SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Pos)          /*!< Mask for SEL_SRC_DTIMER32_KRN_CLK in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Shift(v)        (((v) << SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Pos) & SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER32_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER32_KRN_CLK field */

/** SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__SET() sets CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__GET() gets CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK's current value.
 *
 * When reading from CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK, this is recommended to use.
 *
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__MODIFY() modifies CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__EXTRACT() extracts CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.SEL_SRC_DTIMER32_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG__SEL_SRC_DTIMER32_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.CPUS_CFG.OTP_KEEP_PWR_ST ---------------------- */

/**
<pre>
  SCU.CPUS_CFG.OTP_KEEP_PWR_ST:

    1: OTP keep power state after a reset

</pre> */

#define SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Pos                      11                                                                     /*!< Right-most bit position of OTP_KEEP_PWR_ST in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Msk                      (0x00000001UL << SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Pos)                   /*!< Mask for OTP_KEEP_PWR_ST in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Shift(v)                 (((v) << SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Pos) & SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Msk) /*!< Shift value 'v' into OTP_KEEP_PWR_ST and mask 'v' to fit it into OTP_KEEP_PWR_ST field */

/** SCU_CPUS_CFG__OTP_KEEP_PWR_ST__SET() sets CPUS_CFG.OTP_KEEP_PWR_ST to given value.
 *
 * When writing to CPUS_CFG.OTP_KEEP_PWR_ST, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.OTP_KEEP_PWR_ST
 */
__SCU_INLINE void SCU_CPUS_CFG__OTP_KEEP_PWR_ST__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Msk);
    reg = (reg | (SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__OTP_KEEP_PWR_ST__GET() gets CPUS_CFG.OTP_KEEP_PWR_ST's current value.
 *
 * When reading from CPUS_CFG.OTP_KEEP_PWR_ST, this is recommended to use.
 *
 * @return current value of CPUS_CFG.OTP_KEEP_PWR_ST
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__OTP_KEEP_PWR_ST__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Msk);
    reg = (reg >> SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__OTP_KEEP_PWR_ST__MODIFY() modifies CPUS_CFG.OTP_KEEP_PWR_ST.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.OTP_KEEP_PWR_ST
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__OTP_KEEP_PWR_ST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Msk);
    reg = (reg | (SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__OTP_KEEP_PWR_ST__EXTRACT() extracts CPUS_CFG.OTP_KEEP_PWR_ST.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.OTP_KEEP_PWR_ST
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__OTP_KEEP_PWR_ST__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Msk);
    reg = (reg >> SCU_CPUS_CFG__OTP_KEEP_PWR_ST__Pos);
    return (uint32_t)reg;
}

/* ------------------------- SCU.CPUS_CFG.USR_CNFG6 ------------------------- */

/**
<pre>
  SCU.CPUS_CFG.USR_CNFG6:

    1: USR_CNFG6 signal set to High

</pre> */

#define SCU_CPUS_CFG__USR_CNFG6__Pos                            10                                                                     /*!< Right-most bit position of USR_CNFG6 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG6__Msk                            (0x00000001UL << SCU_CPUS_CFG__USR_CNFG6__Pos)                         /*!< Mask for USR_CNFG6 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG6__Shift(v)                       (((v) << SCU_CPUS_CFG__USR_CNFG6__Pos) & SCU_CPUS_CFG__USR_CNFG6__Msk) /*!< Shift value 'v' into USR_CNFG6 and mask 'v' to fit it into USR_CNFG6 field */

/** SCU_CPUS_CFG__USR_CNFG6__SET() sets CPUS_CFG.USR_CNFG6 to given value.
 *
 * When writing to CPUS_CFG.USR_CNFG6, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.USR_CNFG6
 */
__SCU_INLINE void SCU_CPUS_CFG__USR_CNFG6__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG6__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG6__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__USR_CNFG6__GET() gets CPUS_CFG.USR_CNFG6's current value.
 *
 * When reading from CPUS_CFG.USR_CNFG6, this is recommended to use.
 *
 * @return current value of CPUS_CFG.USR_CNFG6
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG6__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__USR_CNFG6__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG6__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__USR_CNFG6__MODIFY() modifies CPUS_CFG.USR_CNFG6.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.USR_CNFG6
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG6__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG6__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG6__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__USR_CNFG6__EXTRACT() extracts CPUS_CFG.USR_CNFG6.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.USR_CNFG6
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG6__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__USR_CNFG6__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG6__Pos);
    return (uint32_t)reg;
}

/* ------------------------- SCU.CPUS_CFG.USR_CNFG5 ------------------------- */

/**
<pre>
  SCU.CPUS_CFG.USR_CNFG5:

    1: USR_CNFG5 signal set to High

</pre> */

#define SCU_CPUS_CFG__USR_CNFG5__Pos                            9                                                                      /*!< Right-most bit position of USR_CNFG5 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG5__Msk                            (0x00000001UL << SCU_CPUS_CFG__USR_CNFG5__Pos)                         /*!< Mask for USR_CNFG5 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG5__Shift(v)                       (((v) << SCU_CPUS_CFG__USR_CNFG5__Pos) & SCU_CPUS_CFG__USR_CNFG5__Msk) /*!< Shift value 'v' into USR_CNFG5 and mask 'v' to fit it into USR_CNFG5 field */

/** SCU_CPUS_CFG__USR_CNFG5__SET() sets CPUS_CFG.USR_CNFG5 to given value.
 *
 * When writing to CPUS_CFG.USR_CNFG5, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.USR_CNFG5
 */
__SCU_INLINE void SCU_CPUS_CFG__USR_CNFG5__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG5__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG5__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__USR_CNFG5__GET() gets CPUS_CFG.USR_CNFG5's current value.
 *
 * When reading from CPUS_CFG.USR_CNFG5, this is recommended to use.
 *
 * @return current value of CPUS_CFG.USR_CNFG5
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG5__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__USR_CNFG5__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG5__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__USR_CNFG5__MODIFY() modifies CPUS_CFG.USR_CNFG5.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.USR_CNFG5
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG5__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG5__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG5__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__USR_CNFG5__EXTRACT() extracts CPUS_CFG.USR_CNFG5.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.USR_CNFG5
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG5__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__USR_CNFG5__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG5__Pos);
    return (uint32_t)reg;
}

/* ------------------------- SCU.CPUS_CFG.USR_CNFG4 ------------------------- */

/**
<pre>
  SCU.CPUS_CFG.USR_CNFG4:

    1: USR_CNFG4 signal set to High

</pre> */

#define SCU_CPUS_CFG__USR_CNFG4__Pos                            8                                                                      /*!< Right-most bit position of USR_CNFG4 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG4__Msk                            (0x00000001UL << SCU_CPUS_CFG__USR_CNFG4__Pos)                         /*!< Mask for USR_CNFG4 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG4__Shift(v)                       (((v) << SCU_CPUS_CFG__USR_CNFG4__Pos) & SCU_CPUS_CFG__USR_CNFG4__Msk) /*!< Shift value 'v' into USR_CNFG4 and mask 'v' to fit it into USR_CNFG4 field */

/** SCU_CPUS_CFG__USR_CNFG4__SET() sets CPUS_CFG.USR_CNFG4 to given value.
 *
 * When writing to CPUS_CFG.USR_CNFG4, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.USR_CNFG4
 */
__SCU_INLINE void SCU_CPUS_CFG__USR_CNFG4__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG4__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG4__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__USR_CNFG4__GET() gets CPUS_CFG.USR_CNFG4's current value.
 *
 * When reading from CPUS_CFG.USR_CNFG4, this is recommended to use.
 *
 * @return current value of CPUS_CFG.USR_CNFG4
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG4__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__USR_CNFG4__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG4__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__USR_CNFG4__MODIFY() modifies CPUS_CFG.USR_CNFG4.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.USR_CNFG4
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG4__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG4__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG4__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__USR_CNFG4__EXTRACT() extracts CPUS_CFG.USR_CNFG4.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.USR_CNFG4
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG4__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__USR_CNFG4__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG4__Pos);
    return (uint32_t)reg;
}

/* ------------------------- SCU.CPUS_CFG.USR_CNFG3 ------------------------- */

/**
<pre>
  SCU.CPUS_CFG.USR_CNFG3:

    1: USR_CNFG3 signal set to High

</pre> */

#define SCU_CPUS_CFG__USR_CNFG3__Pos                            7                                                                      /*!< Right-most bit position of USR_CNFG3 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG3__Msk                            (0x00000001UL << SCU_CPUS_CFG__USR_CNFG3__Pos)                         /*!< Mask for USR_CNFG3 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG3__Shift(v)                       (((v) << SCU_CPUS_CFG__USR_CNFG3__Pos) & SCU_CPUS_CFG__USR_CNFG3__Msk) /*!< Shift value 'v' into USR_CNFG3 and mask 'v' to fit it into USR_CNFG3 field */

/** SCU_CPUS_CFG__USR_CNFG3__SET() sets CPUS_CFG.USR_CNFG3 to given value.
 *
 * When writing to CPUS_CFG.USR_CNFG3, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.USR_CNFG3
 */
__SCU_INLINE void SCU_CPUS_CFG__USR_CNFG3__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG3__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG3__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__USR_CNFG3__GET() gets CPUS_CFG.USR_CNFG3's current value.
 *
 * When reading from CPUS_CFG.USR_CNFG3, this is recommended to use.
 *
 * @return current value of CPUS_CFG.USR_CNFG3
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG3__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__USR_CNFG3__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG3__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__USR_CNFG3__MODIFY() modifies CPUS_CFG.USR_CNFG3.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.USR_CNFG3
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG3__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG3__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__USR_CNFG3__EXTRACT() extracts CPUS_CFG.USR_CNFG3.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.USR_CNFG3
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG3__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__USR_CNFG3__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG3__Pos);
    return (uint32_t)reg;
}

/* ------------------------- SCU.CPUS_CFG.USR_CNFG2 ------------------------- */

/**
<pre>
  SCU.CPUS_CFG.USR_CNFG2:

    1: USR_CNFG2 signal set to High

</pre> */

#define SCU_CPUS_CFG__USR_CNFG2__Pos                            6                                                                      /*!< Right-most bit position of USR_CNFG2 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG2__Msk                            (0x00000001UL << SCU_CPUS_CFG__USR_CNFG2__Pos)                         /*!< Mask for USR_CNFG2 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG2__Shift(v)                       (((v) << SCU_CPUS_CFG__USR_CNFG2__Pos) & SCU_CPUS_CFG__USR_CNFG2__Msk) /*!< Shift value 'v' into USR_CNFG2 and mask 'v' to fit it into USR_CNFG2 field */

/** SCU_CPUS_CFG__USR_CNFG2__SET() sets CPUS_CFG.USR_CNFG2 to given value.
 *
 * When writing to CPUS_CFG.USR_CNFG2, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.USR_CNFG2
 */
__SCU_INLINE void SCU_CPUS_CFG__USR_CNFG2__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG2__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG2__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__USR_CNFG2__GET() gets CPUS_CFG.USR_CNFG2's current value.
 *
 * When reading from CPUS_CFG.USR_CNFG2, this is recommended to use.
 *
 * @return current value of CPUS_CFG.USR_CNFG2
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG2__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__USR_CNFG2__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG2__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__USR_CNFG2__MODIFY() modifies CPUS_CFG.USR_CNFG2.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.USR_CNFG2
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG2__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG2__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__USR_CNFG2__EXTRACT() extracts CPUS_CFG.USR_CNFG2.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.USR_CNFG2
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG2__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__USR_CNFG2__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG2__Pos);
    return (uint32_t)reg;
}

/* ------------------------- SCU.CPUS_CFG.USR_CNFG1 ------------------------- */

/**
<pre>
  SCU.CPUS_CFG.USR_CNFG1:

    1: USR_CNFG1 signal set to High

</pre> */

#define SCU_CPUS_CFG__USR_CNFG1__Pos                            5                                                                      /*!< Right-most bit position of USR_CNFG1 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG1__Msk                            (0x00000001UL << SCU_CPUS_CFG__USR_CNFG1__Pos)                         /*!< Mask for USR_CNFG1 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG1__Shift(v)                       (((v) << SCU_CPUS_CFG__USR_CNFG1__Pos) & SCU_CPUS_CFG__USR_CNFG1__Msk) /*!< Shift value 'v' into USR_CNFG1 and mask 'v' to fit it into USR_CNFG1 field */

/** SCU_CPUS_CFG__USR_CNFG1__SET() sets CPUS_CFG.USR_CNFG1 to given value.
 *
 * When writing to CPUS_CFG.USR_CNFG1, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.USR_CNFG1
 */
__SCU_INLINE void SCU_CPUS_CFG__USR_CNFG1__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG1__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG1__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__USR_CNFG1__GET() gets CPUS_CFG.USR_CNFG1's current value.
 *
 * When reading from CPUS_CFG.USR_CNFG1, this is recommended to use.
 *
 * @return current value of CPUS_CFG.USR_CNFG1
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG1__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__USR_CNFG1__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG1__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__USR_CNFG1__MODIFY() modifies CPUS_CFG.USR_CNFG1.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.USR_CNFG1
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG1__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG1__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__USR_CNFG1__EXTRACT() extracts CPUS_CFG.USR_CNFG1.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.USR_CNFG1
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG1__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__USR_CNFG1__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG1__Pos);
    return (uint32_t)reg;
}

/* ------------------------- SCU.CPUS_CFG.USR_CNFG0 ------------------------- */

/**
<pre>
  SCU.CPUS_CFG.USR_CNFG0:

    1: USR_CNFG0 signal set to High

</pre> */

#define SCU_CPUS_CFG__USR_CNFG0__Pos                            4                                                                      /*!< Right-most bit position of USR_CNFG0 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG0__Msk                            (0x00000001UL << SCU_CPUS_CFG__USR_CNFG0__Pos)                         /*!< Mask for USR_CNFG0 in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__USR_CNFG0__Shift(v)                       (((v) << SCU_CPUS_CFG__USR_CNFG0__Pos) & SCU_CPUS_CFG__USR_CNFG0__Msk) /*!< Shift value 'v' into USR_CNFG0 and mask 'v' to fit it into USR_CNFG0 field */

/** SCU_CPUS_CFG__USR_CNFG0__SET() sets CPUS_CFG.USR_CNFG0 to given value.
 *
 * When writing to CPUS_CFG.USR_CNFG0, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.USR_CNFG0
 */
__SCU_INLINE void SCU_CPUS_CFG__USR_CNFG0__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG0__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG0__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__USR_CNFG0__GET() gets CPUS_CFG.USR_CNFG0's current value.
 *
 * When reading from CPUS_CFG.USR_CNFG0, this is recommended to use.
 *
 * @return current value of CPUS_CFG.USR_CNFG0
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG0__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__USR_CNFG0__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG0__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__USR_CNFG0__MODIFY() modifies CPUS_CFG.USR_CNFG0.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.USR_CNFG0
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__USR_CNFG0__Msk);
    reg = (reg | (SCU_CPUS_CFG__USR_CNFG0__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__USR_CNFG0__EXTRACT() extracts CPUS_CFG.USR_CNFG0.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.USR_CNFG0
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__USR_CNFG0__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__USR_CNFG0__Msk);
    reg = (reg >> SCU_CPUS_CFG__USR_CNFG0__Pos);
    return (uint32_t)reg;
}

/* ------------------------ SCU.CPUS_CFG.EN_EXTWKUP ------------------------ */

/**
<pre>
  SCU.CPUS_CFG.EN_EXTWKUP:

    1: CPUS Ext wakeup is enabled

</pre> */

#define SCU_CPUS_CFG__EN_EXTWKUP__Pos                           3                                                                      /*!< Right-most bit position of EN_EXTWKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_EXTWKUP__Msk                           (0x00000001UL << SCU_CPUS_CFG__EN_EXTWKUP__Pos)                        /*!< Mask for EN_EXTWKUP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__EN_EXTWKUP__Shift(v)                      (((v) << SCU_CPUS_CFG__EN_EXTWKUP__Pos) & SCU_CPUS_CFG__EN_EXTWKUP__Msk) /*!< Shift value 'v' into EN_EXTWKUP and mask 'v' to fit it into EN_EXTWKUP field */

/** SCU_CPUS_CFG__EN_EXTWKUP__SET() sets CPUS_CFG.EN_EXTWKUP to given value.
 *
 * When writing to CPUS_CFG.EN_EXTWKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.EN_EXTWKUP
 */
__SCU_INLINE void SCU_CPUS_CFG__EN_EXTWKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__EN_EXTWKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_EXTWKUP__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__EN_EXTWKUP__GET() gets CPUS_CFG.EN_EXTWKUP's current value.
 *
 * When reading from CPUS_CFG.EN_EXTWKUP, this is recommended to use.
 *
 * @return current value of CPUS_CFG.EN_EXTWKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_EXTWKUP__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__EN_EXTWKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_EXTWKUP__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__EN_EXTWKUP__MODIFY() modifies CPUS_CFG.EN_EXTWKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.EN_EXTWKUP
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_EXTWKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__EN_EXTWKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG__EN_EXTWKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__EN_EXTWKUP__EXTRACT() extracts CPUS_CFG.EN_EXTWKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.EN_EXTWKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__EN_EXTWKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__EN_EXTWKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG__EN_EXTWKUP__Pos);
    return (uint32_t)reg;
}

/* ------------------------ SCU.CPUS_CFG.DS_DBGPORT ------------------------ */

/**
<pre>
  SCU.CPUS_CFG.DS_DBGPORT:

    1: DBG Port connection is disabled

</pre> */

#define SCU_CPUS_CFG__DS_DBGPORT__Pos                           2                                                                      /*!< Right-most bit position of DS_DBGPORT in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__DS_DBGPORT__Msk                           (0x00000001UL << SCU_CPUS_CFG__DS_DBGPORT__Pos)                        /*!< Mask for DS_DBGPORT in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__DS_DBGPORT__Shift(v)                      (((v) << SCU_CPUS_CFG__DS_DBGPORT__Pos) & SCU_CPUS_CFG__DS_DBGPORT__Msk) /*!< Shift value 'v' into DS_DBGPORT and mask 'v' to fit it into DS_DBGPORT field */

/** SCU_CPUS_CFG__DS_DBGPORT__SET() sets CPUS_CFG.DS_DBGPORT to given value.
 *
 * When writing to CPUS_CFG.DS_DBGPORT, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.DS_DBGPORT
 */
__SCU_INLINE void SCU_CPUS_CFG__DS_DBGPORT__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__DS_DBGPORT__Msk);
    reg = (reg | (SCU_CPUS_CFG__DS_DBGPORT__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__DS_DBGPORT__GET() gets CPUS_CFG.DS_DBGPORT's current value.
 *
 * When reading from CPUS_CFG.DS_DBGPORT, this is recommended to use.
 *
 * @return current value of CPUS_CFG.DS_DBGPORT
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__DS_DBGPORT__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__DS_DBGPORT__Msk);
    reg = (reg >> SCU_CPUS_CFG__DS_DBGPORT__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__DS_DBGPORT__MODIFY() modifies CPUS_CFG.DS_DBGPORT.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.DS_DBGPORT
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__DS_DBGPORT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__DS_DBGPORT__Msk);
    reg = (reg | (SCU_CPUS_CFG__DS_DBGPORT__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__DS_DBGPORT__EXTRACT() extracts CPUS_CFG.DS_DBGPORT.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.DS_DBGPORT
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__DS_DBGPORT__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__DS_DBGPORT__Msk);
    reg = (reg >> SCU_CPUS_CFG__DS_DBGPORT__Pos);
    return (uint32_t)reg;
}

/* ------------------------- SCU.CPUS_CFG.SET_REMAP ------------------------- */

/**
<pre>
  SCU.CPUS_CFG.SET_REMAP:

    1: Remap signal set to 1

</pre> */

#define SCU_CPUS_CFG__SET_REMAP__Pos                            0                                                                      /*!< Right-most bit position of SET_REMAP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SET_REMAP__Msk                            (0x00000001UL << SCU_CPUS_CFG__SET_REMAP__Pos)                         /*!< Mask for SET_REMAP in SCU.CPUS_CFG */
#define SCU_CPUS_CFG__SET_REMAP__Shift(v)                       (((v) << SCU_CPUS_CFG__SET_REMAP__Pos) & SCU_CPUS_CFG__SET_REMAP__Msk) /*!< Shift value 'v' into SET_REMAP and mask 'v' to fit it into SET_REMAP field */

/** SCU_CPUS_CFG__SET_REMAP__SET() sets CPUS_CFG.SET_REMAP to given value.
 *
 * When writing to CPUS_CFG.SET_REMAP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG.SET_REMAP
 */
__SCU_INLINE void SCU_CPUS_CFG__SET_REMAP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & ~SCU_CPUS_CFG__SET_REMAP__Msk);
    reg = (reg | (SCU_CPUS_CFG__SET_REMAP__Shift((uint32_t)bf_value)));
    SCU_CPUS_CFG__SET(reg);
}

/** SCU_CPUS_CFG__SET_REMAP__GET() gets CPUS_CFG.SET_REMAP's current value.
 *
 * When reading from CPUS_CFG.SET_REMAP, this is recommended to use.
 *
 * @return current value of CPUS_CFG.SET_REMAP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SET_REMAP__GET(void)
{
    uint32_t reg = SCU_CPUS_CFG__GET();
    reg = (reg & SCU_CPUS_CFG__SET_REMAP__Msk);
    reg = (reg >> SCU_CPUS_CFG__SET_REMAP__Pos);
    return (uint32_t)reg;
}

/** SCU_CPUS_CFG__SET_REMAP__MODIFY() modifies CPUS_CFG.SET_REMAP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @param bf_value new value for CPUS_CFG.SET_REMAP
 * @return new value of SCU.CPUS_CFG
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SET_REMAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG__SET_REMAP__Msk);
    reg = (reg | (SCU_CPUS_CFG__SET_REMAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG__SET_REMAP__EXTRACT() extracts CPUS_CFG.SET_REMAP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG
 * @return current value of CPUS_CFG.SET_REMAP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG__SET_REMAP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG__SET_REMAP__Msk);
    reg = (reg >> SCU_CPUS_CFG__SET_REMAP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        CPUS_CFG_SET member of SCU_t                        */
/* -------------------------------------------------------------------------- */

/** __SCU_CPUS_CFG_SET__ADDRESS returns the address of member CPUS_CFG_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CPUS_CFG_SET
 */
__SCU_INLINE uint32_t* __SCU_CPUS_CFG_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__SCU_BASE_PTR() + (uint32_t)(offsetof(SCU_t, CPUS_CFG_SET)));
}

/** SCU_CPUS_CFG_SET__SET() sets CPUS_CFG_SET to given value.
 *
 * When writing to CPUS_CFG_SET, this is mandatory to use.
 *
 * @param value new value for CPUS_CFG_SET
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__SET(uint32_t value)
{
    HAL_SET32(__SCU_CPUS_CFG_SET__ADDRESS(), value);
}


/* --------------------- SCU.CPUS_CFG_SET.EN_GPIO1_WKUP --------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.EN_GPIO1_WKUP:

    1: CPUS GPIO1_IRQ wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Pos                    23                                                                     /*!< Right-most bit position of EN_GPIO1_WKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Msk                    (0x00000001UL << SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Pos)                 /*!< Mask for EN_GPIO1_WKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Shift(v)               (((v) << SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Pos) & SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Msk) /*!< Shift value 'v' into EN_GPIO1_WKUP and mask 'v' to fit it into EN_GPIO1_WKUP field */

/** SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__SET() sets CPUS_CFG_SET.EN_GPIO1_WKUP to given value.
 *
 * When writing to CPUS_CFG_SET.EN_GPIO1_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.EN_GPIO1_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__MODIFY() modifies CPUS_CFG_SET.EN_GPIO1_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.EN_GPIO1_WKUP
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__EXTRACT() extracts CPUS_CFG_SET.EN_GPIO1_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.EN_GPIO1_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__EN_GPIO1_WKUP__Pos);
    return (uint32_t)reg;
}

/* --------------------- SCU.CPUS_CFG_SET.EN_GPIO0_WKUP --------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.EN_GPIO0_WKUP:

    1: CPUS GPIO0_IRQ wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Pos                    22                                                                     /*!< Right-most bit position of EN_GPIO0_WKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Msk                    (0x00000001UL << SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Pos)                 /*!< Mask for EN_GPIO0_WKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Shift(v)               (((v) << SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Pos) & SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Msk) /*!< Shift value 'v' into EN_GPIO0_WKUP and mask 'v' to fit it into EN_GPIO0_WKUP field */

/** SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__SET() sets CPUS_CFG_SET.EN_GPIO0_WKUP to given value.
 *
 * When writing to CPUS_CFG_SET.EN_GPIO0_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.EN_GPIO0_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__MODIFY() modifies CPUS_CFG_SET.EN_GPIO0_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.EN_GPIO0_WKUP
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__EXTRACT() extracts CPUS_CFG_SET.EN_GPIO0_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.EN_GPIO0_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__EN_GPIO0_WKUP__Pos);
    return (uint32_t)reg;
}

/* --------------------- SCU.CPUS_CFG_SET.EN_PMBUS_WKUP --------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.EN_PMBUS_WKUP:

    1: CPUS PMBUS_IRQ wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Pos                    21                                                                     /*!< Right-most bit position of EN_PMBUS_WKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Msk                    (0x00000001UL << SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Pos)                 /*!< Mask for EN_PMBUS_WKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Shift(v)               (((v) << SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Pos) & SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Msk) /*!< Shift value 'v' into EN_PMBUS_WKUP and mask 'v' to fit it into EN_PMBUS_WKUP field */

/** SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__SET() sets CPUS_CFG_SET.EN_PMBUS_WKUP to given value.
 *
 * When writing to CPUS_CFG_SET.EN_PMBUS_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.EN_PMBUS_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__MODIFY() modifies CPUS_CFG_SET.EN_PMBUS_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.EN_PMBUS_WKUP
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__EXTRACT() extracts CPUS_CFG_SET.EN_PMBUS_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.EN_PMBUS_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__EN_PMBUS_WKUP__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.CPUS_CFG_SET.EN_AUX_EXTWKUP -------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.EN_AUX_EXTWKUP:

    1: CPUS EXT-3 wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Pos                   20                                                                     /*!< Right-most bit position of EN_AUX_EXTWKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Msk                   (0x00000001UL << SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Pos)                /*!< Mask for EN_AUX_EXTWKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Shift(v)              (((v) << SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Pos) & SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Msk) /*!< Shift value 'v' into EN_AUX_EXTWKUP and mask 'v' to fit it into EN_AUX_EXTWKUP field */

/** SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__SET() sets CPUS_CFG_SET.EN_AUX_EXTWKUP to given value.
 *
 * When writing to CPUS_CFG_SET.EN_AUX_EXTWKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.EN_AUX_EXTWKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__MODIFY() modifies CPUS_CFG_SET.EN_AUX_EXTWKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.EN_AUX_EXTWKUP
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__EXTRACT() extracts CPUS_CFG_SET.EN_AUX_EXTWKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.EN_AUX_EXTWKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__EN_AUX_EXTWKUP__Pos);
    return (uint32_t)reg;
}

/* --------------------- SCU.CPUS_CFG_SET.EN_SVID1_WKUP --------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.EN_SVID1_WKUP:

    1: CPUS INT_SVID1 wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Pos                    19                                                                     /*!< Right-most bit position of EN_SVID1_WKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Msk                    (0x00000001UL << SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Pos)                 /*!< Mask for EN_SVID1_WKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Shift(v)               (((v) << SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Pos) & SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Msk) /*!< Shift value 'v' into EN_SVID1_WKUP and mask 'v' to fit it into EN_SVID1_WKUP field */

/** SCU_CPUS_CFG_SET__EN_SVID1_WKUP__SET() sets CPUS_CFG_SET.EN_SVID1_WKUP to given value.
 *
 * When writing to CPUS_CFG_SET.EN_SVID1_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.EN_SVID1_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__EN_SVID1_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__EN_SVID1_WKUP__MODIFY() modifies CPUS_CFG_SET.EN_SVID1_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.EN_SVID1_WKUP
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_SVID1_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__EN_SVID1_WKUP__EXTRACT() extracts CPUS_CFG_SET.EN_SVID1_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.EN_SVID1_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_SVID1_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__EN_SVID1_WKUP__Pos);
    return (uint32_t)reg;
}

/* --------------------- SCU.CPUS_CFG_SET.EN_SVID0_WKUP --------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.EN_SVID0_WKUP:

    1: CPUS INT_SVID0 wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Pos                    18                                                                     /*!< Right-most bit position of EN_SVID0_WKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Msk                    (0x00000001UL << SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Pos)                 /*!< Mask for EN_SVID0_WKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Shift(v)               (((v) << SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Pos) & SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Msk) /*!< Shift value 'v' into EN_SVID0_WKUP and mask 'v' to fit it into EN_SVID0_WKUP field */

/** SCU_CPUS_CFG_SET__EN_SVID0_WKUP__SET() sets CPUS_CFG_SET.EN_SVID0_WKUP to given value.
 *
 * When writing to CPUS_CFG_SET.EN_SVID0_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.EN_SVID0_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__EN_SVID0_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__EN_SVID0_WKUP__MODIFY() modifies CPUS_CFG_SET.EN_SVID0_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.EN_SVID0_WKUP
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_SVID0_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__EN_SVID0_WKUP__EXTRACT() extracts CPUS_CFG_SET.EN_SVID0_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.EN_SVID0_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_SVID0_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__EN_SVID0_WKUP__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_SET.SEL_SRC_DTIMER11_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.SEL_SRC_DTIMER11_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Pos         17                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER11_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER11_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Pos) & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER11_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER11_KRN_CLK field */

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__SET() sets CPUS_CFG_SET.SEL_SRC_DTIMER11_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_SET.SEL_SRC_DTIMER11_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER11_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__MODIFY() modifies CPUS_CFG_SET.SEL_SRC_DTIMER11_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER11_KRN_CLK
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__EXTRACT() extracts CPUS_CFG_SET.SEL_SRC_DTIMER11_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.SEL_SRC_DTIMER11_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__SEL_SRC_DTIMER11_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_SET.SEL_SRC_DTIMER12_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.SEL_SRC_DTIMER12_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Pos         16                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER12_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER12_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Pos) & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER12_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER12_KRN_CLK field */

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__SET() sets CPUS_CFG_SET.SEL_SRC_DTIMER12_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_SET.SEL_SRC_DTIMER12_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER12_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__MODIFY() modifies CPUS_CFG_SET.SEL_SRC_DTIMER12_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER12_KRN_CLK
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__EXTRACT() extracts CPUS_CFG_SET.SEL_SRC_DTIMER12_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.SEL_SRC_DTIMER12_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__SEL_SRC_DTIMER12_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_SET.SEL_SRC_DTIMER21_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.SEL_SRC_DTIMER21_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Pos         15                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER21_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER21_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Pos) & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER21_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER21_KRN_CLK field */

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__SET() sets CPUS_CFG_SET.SEL_SRC_DTIMER21_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_SET.SEL_SRC_DTIMER21_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER21_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__MODIFY() modifies CPUS_CFG_SET.SEL_SRC_DTIMER21_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER21_KRN_CLK
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__EXTRACT() extracts CPUS_CFG_SET.SEL_SRC_DTIMER21_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.SEL_SRC_DTIMER21_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__SEL_SRC_DTIMER21_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_SET.SEL_SRC_DTIMER22_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.SEL_SRC_DTIMER22_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Pos         14                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER22_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER22_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Pos) & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER22_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER22_KRN_CLK field */

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__SET() sets CPUS_CFG_SET.SEL_SRC_DTIMER22_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_SET.SEL_SRC_DTIMER22_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER22_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__MODIFY() modifies CPUS_CFG_SET.SEL_SRC_DTIMER22_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER22_KRN_CLK
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__EXTRACT() extracts CPUS_CFG_SET.SEL_SRC_DTIMER22_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.SEL_SRC_DTIMER22_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__SEL_SRC_DTIMER22_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_SET.SEL_SRC_DTIMER31_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.SEL_SRC_DTIMER31_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Pos         13                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER31_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER31_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Pos) & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER31_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER31_KRN_CLK field */

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__SET() sets CPUS_CFG_SET.SEL_SRC_DTIMER31_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_SET.SEL_SRC_DTIMER31_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER31_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__MODIFY() modifies CPUS_CFG_SET.SEL_SRC_DTIMER31_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER31_KRN_CLK
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__EXTRACT() extracts CPUS_CFG_SET.SEL_SRC_DTIMER31_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.SEL_SRC_DTIMER31_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__SEL_SRC_DTIMER31_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_SET.SEL_SRC_DTIMER32_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.SEL_SRC_DTIMER32_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Pos         12                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER32_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER32_KRN_CLK in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Pos) & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER32_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER32_KRN_CLK field */

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__SET() sets CPUS_CFG_SET.SEL_SRC_DTIMER32_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_SET.SEL_SRC_DTIMER32_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER32_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__MODIFY() modifies CPUS_CFG_SET.SEL_SRC_DTIMER32_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.SEL_SRC_DTIMER32_KRN_CLK
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__EXTRACT() extracts CPUS_CFG_SET.SEL_SRC_DTIMER32_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.SEL_SRC_DTIMER32_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__SEL_SRC_DTIMER32_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.CPUS_CFG_SET.OTP_KEEP_PWR_ST -------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.OTP_KEEP_PWR_ST:

    1: OTP keep power state after a reset

</pre> */

#define SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Pos                  11                                                                     /*!< Right-most bit position of OTP_KEEP_PWR_ST in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Msk                  (0x00000001UL << SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Pos)               /*!< Mask for OTP_KEEP_PWR_ST in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Shift(v)             (((v) << SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Pos) & SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Msk) /*!< Shift value 'v' into OTP_KEEP_PWR_ST and mask 'v' to fit it into OTP_KEEP_PWR_ST field */

/** SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__SET() sets CPUS_CFG_SET.OTP_KEEP_PWR_ST to given value.
 *
 * When writing to CPUS_CFG_SET.OTP_KEEP_PWR_ST, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.OTP_KEEP_PWR_ST
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__MODIFY() modifies CPUS_CFG_SET.OTP_KEEP_PWR_ST.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.OTP_KEEP_PWR_ST
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__EXTRACT() extracts CPUS_CFG_SET.OTP_KEEP_PWR_ST.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.OTP_KEEP_PWR_ST
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__OTP_KEEP_PWR_ST__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_SET.USR_CNFG6 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.USR_CNFG6:

    1: USR_CNFG6 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__USR_CNFG6__Pos                        10                                                                     /*!< Right-most bit position of USR_CNFG6 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG6__Msk                        (0x00000001UL << SCU_CPUS_CFG_SET__USR_CNFG6__Pos)                     /*!< Mask for USR_CNFG6 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG6__Shift(v)                   (((v) << SCU_CPUS_CFG_SET__USR_CNFG6__Pos) & SCU_CPUS_CFG_SET__USR_CNFG6__Msk) /*!< Shift value 'v' into USR_CNFG6 and mask 'v' to fit it into USR_CNFG6 field */

/** SCU_CPUS_CFG_SET__USR_CNFG6__SET() sets CPUS_CFG_SET.USR_CNFG6 to given value.
 *
 * When writing to CPUS_CFG_SET.USR_CNFG6, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG6
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__USR_CNFG6__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__USR_CNFG6__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__USR_CNFG6__MODIFY() modifies CPUS_CFG_SET.USR_CNFG6.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG6
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG6__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__USR_CNFG6__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__USR_CNFG6__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__USR_CNFG6__EXTRACT() extracts CPUS_CFG_SET.USR_CNFG6.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.USR_CNFG6
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG6__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__USR_CNFG6__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__USR_CNFG6__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_SET.USR_CNFG5 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.USR_CNFG5:

    1: USR_CNFG5 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__USR_CNFG5__Pos                        9                                                                      /*!< Right-most bit position of USR_CNFG5 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG5__Msk                        (0x00000001UL << SCU_CPUS_CFG_SET__USR_CNFG5__Pos)                     /*!< Mask for USR_CNFG5 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG5__Shift(v)                   (((v) << SCU_CPUS_CFG_SET__USR_CNFG5__Pos) & SCU_CPUS_CFG_SET__USR_CNFG5__Msk) /*!< Shift value 'v' into USR_CNFG5 and mask 'v' to fit it into USR_CNFG5 field */

/** SCU_CPUS_CFG_SET__USR_CNFG5__SET() sets CPUS_CFG_SET.USR_CNFG5 to given value.
 *
 * When writing to CPUS_CFG_SET.USR_CNFG5, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG5
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__USR_CNFG5__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__USR_CNFG5__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__USR_CNFG5__MODIFY() modifies CPUS_CFG_SET.USR_CNFG5.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG5
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG5__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__USR_CNFG5__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__USR_CNFG5__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__USR_CNFG5__EXTRACT() extracts CPUS_CFG_SET.USR_CNFG5.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.USR_CNFG5
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG5__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__USR_CNFG5__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__USR_CNFG5__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_SET.USR_CNFG4 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.USR_CNFG4:

    1: USR_CNFG4 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__USR_CNFG4__Pos                        8                                                                      /*!< Right-most bit position of USR_CNFG4 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG4__Msk                        (0x00000001UL << SCU_CPUS_CFG_SET__USR_CNFG4__Pos)                     /*!< Mask for USR_CNFG4 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG4__Shift(v)                   (((v) << SCU_CPUS_CFG_SET__USR_CNFG4__Pos) & SCU_CPUS_CFG_SET__USR_CNFG4__Msk) /*!< Shift value 'v' into USR_CNFG4 and mask 'v' to fit it into USR_CNFG4 field */

/** SCU_CPUS_CFG_SET__USR_CNFG4__SET() sets CPUS_CFG_SET.USR_CNFG4 to given value.
 *
 * When writing to CPUS_CFG_SET.USR_CNFG4, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG4
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__USR_CNFG4__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__USR_CNFG4__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__USR_CNFG4__MODIFY() modifies CPUS_CFG_SET.USR_CNFG4.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG4
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG4__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__USR_CNFG4__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__USR_CNFG4__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__USR_CNFG4__EXTRACT() extracts CPUS_CFG_SET.USR_CNFG4.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.USR_CNFG4
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG4__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__USR_CNFG4__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__USR_CNFG4__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_SET.USR_CNFG3 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.USR_CNFG3:

    1: USR_CNFG3 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__USR_CNFG3__Pos                        7                                                                      /*!< Right-most bit position of USR_CNFG3 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG3__Msk                        (0x00000001UL << SCU_CPUS_CFG_SET__USR_CNFG3__Pos)                     /*!< Mask for USR_CNFG3 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG3__Shift(v)                   (((v) << SCU_CPUS_CFG_SET__USR_CNFG3__Pos) & SCU_CPUS_CFG_SET__USR_CNFG3__Msk) /*!< Shift value 'v' into USR_CNFG3 and mask 'v' to fit it into USR_CNFG3 field */

/** SCU_CPUS_CFG_SET__USR_CNFG3__SET() sets CPUS_CFG_SET.USR_CNFG3 to given value.
 *
 * When writing to CPUS_CFG_SET.USR_CNFG3, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG3
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__USR_CNFG3__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__USR_CNFG3__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__USR_CNFG3__MODIFY() modifies CPUS_CFG_SET.USR_CNFG3.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG3
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__USR_CNFG3__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__USR_CNFG3__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__USR_CNFG3__EXTRACT() extracts CPUS_CFG_SET.USR_CNFG3.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.USR_CNFG3
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG3__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__USR_CNFG3__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__USR_CNFG3__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_SET.USR_CNFG2 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.USR_CNFG2:

    1: USR_CNFG2 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__USR_CNFG2__Pos                        6                                                                      /*!< Right-most bit position of USR_CNFG2 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG2__Msk                        (0x00000001UL << SCU_CPUS_CFG_SET__USR_CNFG2__Pos)                     /*!< Mask for USR_CNFG2 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG2__Shift(v)                   (((v) << SCU_CPUS_CFG_SET__USR_CNFG2__Pos) & SCU_CPUS_CFG_SET__USR_CNFG2__Msk) /*!< Shift value 'v' into USR_CNFG2 and mask 'v' to fit it into USR_CNFG2 field */

/** SCU_CPUS_CFG_SET__USR_CNFG2__SET() sets CPUS_CFG_SET.USR_CNFG2 to given value.
 *
 * When writing to CPUS_CFG_SET.USR_CNFG2, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG2
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__USR_CNFG2__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__USR_CNFG2__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__USR_CNFG2__MODIFY() modifies CPUS_CFG_SET.USR_CNFG2.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG2
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__USR_CNFG2__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__USR_CNFG2__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__USR_CNFG2__EXTRACT() extracts CPUS_CFG_SET.USR_CNFG2.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.USR_CNFG2
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG2__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__USR_CNFG2__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__USR_CNFG2__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_SET.USR_CNFG1 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.USR_CNFG1:

    1: USR_CNFG1 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__USR_CNFG1__Pos                        5                                                                      /*!< Right-most bit position of USR_CNFG1 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG1__Msk                        (0x00000001UL << SCU_CPUS_CFG_SET__USR_CNFG1__Pos)                     /*!< Mask for USR_CNFG1 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG1__Shift(v)                   (((v) << SCU_CPUS_CFG_SET__USR_CNFG1__Pos) & SCU_CPUS_CFG_SET__USR_CNFG1__Msk) /*!< Shift value 'v' into USR_CNFG1 and mask 'v' to fit it into USR_CNFG1 field */

/** SCU_CPUS_CFG_SET__USR_CNFG1__SET() sets CPUS_CFG_SET.USR_CNFG1 to given value.
 *
 * When writing to CPUS_CFG_SET.USR_CNFG1, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG1
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__USR_CNFG1__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__USR_CNFG1__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__USR_CNFG1__MODIFY() modifies CPUS_CFG_SET.USR_CNFG1.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG1
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__USR_CNFG1__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__USR_CNFG1__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__USR_CNFG1__EXTRACT() extracts CPUS_CFG_SET.USR_CNFG1.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.USR_CNFG1
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG1__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__USR_CNFG1__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__USR_CNFG1__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_SET.USR_CNFG0 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.USR_CNFG0:

    1: USR_CNFG0 signal set to High

</pre> */

#define SCU_CPUS_CFG_SET__USR_CNFG0__Pos                        4                                                                      /*!< Right-most bit position of USR_CNFG0 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG0__Msk                        (0x00000001UL << SCU_CPUS_CFG_SET__USR_CNFG0__Pos)                     /*!< Mask for USR_CNFG0 in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__USR_CNFG0__Shift(v)                   (((v) << SCU_CPUS_CFG_SET__USR_CNFG0__Pos) & SCU_CPUS_CFG_SET__USR_CNFG0__Msk) /*!< Shift value 'v' into USR_CNFG0 and mask 'v' to fit it into USR_CNFG0 field */

/** SCU_CPUS_CFG_SET__USR_CNFG0__SET() sets CPUS_CFG_SET.USR_CNFG0 to given value.
 *
 * When writing to CPUS_CFG_SET.USR_CNFG0, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG0
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__USR_CNFG0__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__USR_CNFG0__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__USR_CNFG0__MODIFY() modifies CPUS_CFG_SET.USR_CNFG0.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.USR_CNFG0
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__USR_CNFG0__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__USR_CNFG0__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__USR_CNFG0__EXTRACT() extracts CPUS_CFG_SET.USR_CNFG0.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.USR_CNFG0
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__USR_CNFG0__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__USR_CNFG0__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__USR_CNFG0__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.CPUS_CFG_SET.EN_EXTWKUP ---------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.EN_EXTWKUP:

    1: CPUS Ext wakeup is enabled

</pre> */

#define SCU_CPUS_CFG_SET__EN_EXTWKUP__Pos                       3                                                                      /*!< Right-most bit position of EN_EXTWKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_EXTWKUP__Msk                       (0x00000001UL << SCU_CPUS_CFG_SET__EN_EXTWKUP__Pos)                    /*!< Mask for EN_EXTWKUP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__EN_EXTWKUP__Shift(v)                  (((v) << SCU_CPUS_CFG_SET__EN_EXTWKUP__Pos) & SCU_CPUS_CFG_SET__EN_EXTWKUP__Msk) /*!< Shift value 'v' into EN_EXTWKUP and mask 'v' to fit it into EN_EXTWKUP field */

/** SCU_CPUS_CFG_SET__EN_EXTWKUP__SET() sets CPUS_CFG_SET.EN_EXTWKUP to given value.
 *
 * When writing to CPUS_CFG_SET.EN_EXTWKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.EN_EXTWKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__EN_EXTWKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__EN_EXTWKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__EN_EXTWKUP__MODIFY() modifies CPUS_CFG_SET.EN_EXTWKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.EN_EXTWKUP
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_EXTWKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__EN_EXTWKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__EN_EXTWKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__EN_EXTWKUP__EXTRACT() extracts CPUS_CFG_SET.EN_EXTWKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.EN_EXTWKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__EN_EXTWKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__EN_EXTWKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__EN_EXTWKUP__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.CPUS_CFG_SET.DS_DBGPORT ---------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.DS_DBGPORT:

    1: DBG Port connection is disabled

</pre> */

#define SCU_CPUS_CFG_SET__DS_DBGPORT__Pos                       2                                                                      /*!< Right-most bit position of DS_DBGPORT in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__DS_DBGPORT__Msk                       (0x00000001UL << SCU_CPUS_CFG_SET__DS_DBGPORT__Pos)                    /*!< Mask for DS_DBGPORT in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__DS_DBGPORT__Shift(v)                  (((v) << SCU_CPUS_CFG_SET__DS_DBGPORT__Pos) & SCU_CPUS_CFG_SET__DS_DBGPORT__Msk) /*!< Shift value 'v' into DS_DBGPORT and mask 'v' to fit it into DS_DBGPORT field */

/** SCU_CPUS_CFG_SET__DS_DBGPORT__SET() sets CPUS_CFG_SET.DS_DBGPORT to given value.
 *
 * When writing to CPUS_CFG_SET.DS_DBGPORT, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.DS_DBGPORT
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__DS_DBGPORT__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__DS_DBGPORT__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__DS_DBGPORT__MODIFY() modifies CPUS_CFG_SET.DS_DBGPORT.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.DS_DBGPORT
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__DS_DBGPORT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__DS_DBGPORT__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__DS_DBGPORT__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__DS_DBGPORT__EXTRACT() extracts CPUS_CFG_SET.DS_DBGPORT.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.DS_DBGPORT
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__DS_DBGPORT__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__DS_DBGPORT__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__DS_DBGPORT__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_SET.SET_REMAP ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_SET.SET_REMAP:

    1: Remap signal set to 1

</pre> */

#define SCU_CPUS_CFG_SET__SET_REMAP__Pos                        0                                                                      /*!< Right-most bit position of SET_REMAP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SET_REMAP__Msk                        (0x00000001UL << SCU_CPUS_CFG_SET__SET_REMAP__Pos)                     /*!< Mask for SET_REMAP in SCU.CPUS_CFG_SET */
#define SCU_CPUS_CFG_SET__SET_REMAP__Shift(v)                   (((v) << SCU_CPUS_CFG_SET__SET_REMAP__Pos) & SCU_CPUS_CFG_SET__SET_REMAP__Msk) /*!< Shift value 'v' into SET_REMAP and mask 'v' to fit it into SET_REMAP field */

/** SCU_CPUS_CFG_SET__SET_REMAP__SET() sets CPUS_CFG_SET.SET_REMAP to given value.
 *
 * When writing to CPUS_CFG_SET.SET_REMAP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_SET.SET_REMAP
 */
__SCU_INLINE void SCU_CPUS_CFG_SET__SET_REMAP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_SET__SET_REMAP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_SET__SET(reg);
}


/** SCU_CPUS_CFG_SET__SET_REMAP__MODIFY() modifies CPUS_CFG_SET.SET_REMAP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @param bf_value new value for CPUS_CFG_SET.SET_REMAP
 * @return new value of SCU.CPUS_CFG_SET
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SET_REMAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_SET__SET_REMAP__Msk);
    reg = (reg | (SCU_CPUS_CFG_SET__SET_REMAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_SET__SET_REMAP__EXTRACT() extracts CPUS_CFG_SET.SET_REMAP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_SET
 * @return current value of CPUS_CFG_SET.SET_REMAP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_SET__SET_REMAP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_SET__SET_REMAP__Msk);
    reg = (reg >> SCU_CPUS_CFG_SET__SET_REMAP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        CPUS_CFG_CLR member of SCU_t                        */
/* -------------------------------------------------------------------------- */

/** __SCU_CPUS_CFG_CLR__ADDRESS returns the address of member CPUS_CFG_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t* __SCU_CPUS_CFG_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__SCU_BASE_PTR() + (uint32_t)(offsetof(SCU_t, CPUS_CFG_CLR)));
}

/** SCU_CPUS_CFG_CLR__SET() sets CPUS_CFG_CLR to given value.
 *
 * When writing to CPUS_CFG_CLR, this is mandatory to use.
 *
 * @param value new value for CPUS_CFG_CLR
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__SET(uint32_t value)
{
    HAL_SET32(__SCU_CPUS_CFG_CLR__ADDRESS(), value);
}


/* --------------------- SCU.CPUS_CFG_CLR.EN_GPIO1_WKUP --------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.EN_GPIO1_WKUP:

    1: CPUS GPIO1_IRQ wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Pos                    23                                                                     /*!< Right-most bit position of EN_GPIO1_WKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Msk                    (0x00000001UL << SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Pos)                 /*!< Mask for EN_GPIO1_WKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Shift(v)               (((v) << SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Pos) & SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Msk) /*!< Shift value 'v' into EN_GPIO1_WKUP and mask 'v' to fit it into EN_GPIO1_WKUP field */

/** SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__SET() sets CPUS_CFG_CLR.EN_GPIO1_WKUP to given value.
 *
 * When writing to CPUS_CFG_CLR.EN_GPIO1_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.EN_GPIO1_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__MODIFY() modifies CPUS_CFG_CLR.EN_GPIO1_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.EN_GPIO1_WKUP
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__EXTRACT() extracts CPUS_CFG_CLR.EN_GPIO1_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.EN_GPIO1_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__EN_GPIO1_WKUP__Pos);
    return (uint32_t)reg;
}

/* --------------------- SCU.CPUS_CFG_CLR.EN_GPIO0_WKUP --------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.EN_GPIO0_WKUP:

    1: CPUS GPIO0_IRQ wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Pos                    22                                                                     /*!< Right-most bit position of EN_GPIO0_WKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Msk                    (0x00000001UL << SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Pos)                 /*!< Mask for EN_GPIO0_WKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Shift(v)               (((v) << SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Pos) & SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Msk) /*!< Shift value 'v' into EN_GPIO0_WKUP and mask 'v' to fit it into EN_GPIO0_WKUP field */

/** SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__SET() sets CPUS_CFG_CLR.EN_GPIO0_WKUP to given value.
 *
 * When writing to CPUS_CFG_CLR.EN_GPIO0_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.EN_GPIO0_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__MODIFY() modifies CPUS_CFG_CLR.EN_GPIO0_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.EN_GPIO0_WKUP
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__EXTRACT() extracts CPUS_CFG_CLR.EN_GPIO0_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.EN_GPIO0_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__EN_GPIO0_WKUP__Pos);
    return (uint32_t)reg;
}

/* --------------------- SCU.CPUS_CFG_CLR.EN_PMBUS_WKUP --------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.EN_PMBUS_WKUP:

    1: CPUS PMBUS_IRQ wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Pos                    21                                                                     /*!< Right-most bit position of EN_PMBUS_WKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Msk                    (0x00000001UL << SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Pos)                 /*!< Mask for EN_PMBUS_WKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Shift(v)               (((v) << SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Pos) & SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Msk) /*!< Shift value 'v' into EN_PMBUS_WKUP and mask 'v' to fit it into EN_PMBUS_WKUP field */

/** SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__SET() sets CPUS_CFG_CLR.EN_PMBUS_WKUP to given value.
 *
 * When writing to CPUS_CFG_CLR.EN_PMBUS_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.EN_PMBUS_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__MODIFY() modifies CPUS_CFG_CLR.EN_PMBUS_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.EN_PMBUS_WKUP
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__EXTRACT() extracts CPUS_CFG_CLR.EN_PMBUS_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.EN_PMBUS_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__EN_PMBUS_WKUP__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.CPUS_CFG_CLR.EN_AUX_EXTWKUP -------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.EN_AUX_EXTWKUP:

    1: CPUS EXT-3 wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Pos                   20                                                                     /*!< Right-most bit position of EN_AUX_EXTWKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Msk                   (0x00000001UL << SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Pos)                /*!< Mask for EN_AUX_EXTWKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Shift(v)              (((v) << SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Pos) & SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Msk) /*!< Shift value 'v' into EN_AUX_EXTWKUP and mask 'v' to fit it into EN_AUX_EXTWKUP field */

/** SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__SET() sets CPUS_CFG_CLR.EN_AUX_EXTWKUP to given value.
 *
 * When writing to CPUS_CFG_CLR.EN_AUX_EXTWKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.EN_AUX_EXTWKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__MODIFY() modifies CPUS_CFG_CLR.EN_AUX_EXTWKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.EN_AUX_EXTWKUP
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__EXTRACT() extracts CPUS_CFG_CLR.EN_AUX_EXTWKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.EN_AUX_EXTWKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__EN_AUX_EXTWKUP__Pos);
    return (uint32_t)reg;
}

/* --------------------- SCU.CPUS_CFG_CLR.EN_SVID1_WKUP --------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.EN_SVID1_WKUP:

    1: CPUS INT_SVID1 wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Pos                    19                                                                     /*!< Right-most bit position of EN_SVID1_WKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Msk                    (0x00000001UL << SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Pos)                 /*!< Mask for EN_SVID1_WKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Shift(v)               (((v) << SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Pos) & SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Msk) /*!< Shift value 'v' into EN_SVID1_WKUP and mask 'v' to fit it into EN_SVID1_WKUP field */

/** SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__SET() sets CPUS_CFG_CLR.EN_SVID1_WKUP to given value.
 *
 * When writing to CPUS_CFG_CLR.EN_SVID1_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.EN_SVID1_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__MODIFY() modifies CPUS_CFG_CLR.EN_SVID1_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.EN_SVID1_WKUP
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__EXTRACT() extracts CPUS_CFG_CLR.EN_SVID1_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.EN_SVID1_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__EN_SVID1_WKUP__Pos);
    return (uint32_t)reg;
}

/* --------------------- SCU.CPUS_CFG_CLR.EN_SVID0_WKUP --------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.EN_SVID0_WKUP:

    1: CPUS INT_SVID0 wakeup source is enabled

</pre> */

#define SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Pos                    18                                                                     /*!< Right-most bit position of EN_SVID0_WKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Msk                    (0x00000001UL << SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Pos)                 /*!< Mask for EN_SVID0_WKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Shift(v)               (((v) << SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Pos) & SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Msk) /*!< Shift value 'v' into EN_SVID0_WKUP and mask 'v' to fit it into EN_SVID0_WKUP field */

/** SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__SET() sets CPUS_CFG_CLR.EN_SVID0_WKUP to given value.
 *
 * When writing to CPUS_CFG_CLR.EN_SVID0_WKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.EN_SVID0_WKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__MODIFY() modifies CPUS_CFG_CLR.EN_SVID0_WKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.EN_SVID0_WKUP
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__EXTRACT() extracts CPUS_CFG_CLR.EN_SVID0_WKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.EN_SVID0_WKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__EN_SVID0_WKUP__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER11_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER11_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Pos         17                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER11_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER11_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Pos) & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER11_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER11_KRN_CLK field */

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__SET() sets CPUS_CFG_CLR.SEL_SRC_DTIMER11_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_CLR.SEL_SRC_DTIMER11_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER11_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__MODIFY() modifies CPUS_CFG_CLR.SEL_SRC_DTIMER11_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER11_KRN_CLK
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__EXTRACT() extracts CPUS_CFG_CLR.SEL_SRC_DTIMER11_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.SEL_SRC_DTIMER11_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER11_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER12_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER12_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Pos         16                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER12_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER12_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Pos) & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER12_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER12_KRN_CLK field */

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__SET() sets CPUS_CFG_CLR.SEL_SRC_DTIMER12_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_CLR.SEL_SRC_DTIMER12_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER12_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__MODIFY() modifies CPUS_CFG_CLR.SEL_SRC_DTIMER12_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER12_KRN_CLK
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__EXTRACT() extracts CPUS_CFG_CLR.SEL_SRC_DTIMER12_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.SEL_SRC_DTIMER12_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER12_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER21_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER21_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Pos         15                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER21_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER21_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Pos) & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER21_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER21_KRN_CLK field */

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__SET() sets CPUS_CFG_CLR.SEL_SRC_DTIMER21_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_CLR.SEL_SRC_DTIMER21_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER21_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__MODIFY() modifies CPUS_CFG_CLR.SEL_SRC_DTIMER21_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER21_KRN_CLK
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__EXTRACT() extracts CPUS_CFG_CLR.SEL_SRC_DTIMER21_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.SEL_SRC_DTIMER21_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER21_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER22_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER22_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Pos         14                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER22_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER22_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Pos) & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER22_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER22_KRN_CLK field */

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__SET() sets CPUS_CFG_CLR.SEL_SRC_DTIMER22_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_CLR.SEL_SRC_DTIMER22_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER22_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__MODIFY() modifies CPUS_CFG_CLR.SEL_SRC_DTIMER22_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER22_KRN_CLK
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__EXTRACT() extracts CPUS_CFG_CLR.SEL_SRC_DTIMER22_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.SEL_SRC_DTIMER22_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER22_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER31_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER31_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Pos         13                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER31_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER31_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Pos) & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER31_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER31_KRN_CLK field */

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__SET() sets CPUS_CFG_CLR.SEL_SRC_DTIMER31_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_CLR.SEL_SRC_DTIMER31_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER31_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__MODIFY() modifies CPUS_CFG_CLR.SEL_SRC_DTIMER31_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER31_KRN_CLK
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__EXTRACT() extracts CPUS_CFG_CLR.SEL_SRC_DTIMER31_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.SEL_SRC_DTIMER31_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER31_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* --------------- SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER32_KRN_CLK --------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.SEL_SRC_DTIMER32_KRN_CLK:

    1: USR_CNFG7 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Pos         12                                                                     /*!< Right-most bit position of SEL_SRC_DTIMER32_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Msk         (0x00000001UL << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Pos)      /*!< Mask for SEL_SRC_DTIMER32_KRN_CLK in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Shift(v)    (((v) << SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Pos) & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Msk) /*!< Shift value 'v' into SEL_SRC_DTIMER32_KRN_CLK and mask 'v' to fit it into SEL_SRC_DTIMER32_KRN_CLK field */

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__SET() sets CPUS_CFG_CLR.SEL_SRC_DTIMER32_KRN_CLK to given value.
 *
 * When writing to CPUS_CFG_CLR.SEL_SRC_DTIMER32_KRN_CLK, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER32_KRN_CLK
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__MODIFY() modifies CPUS_CFG_CLR.SEL_SRC_DTIMER32_KRN_CLK.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.SEL_SRC_DTIMER32_KRN_CLK
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__EXTRACT() extracts CPUS_CFG_CLR.SEL_SRC_DTIMER32_KRN_CLK.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.SEL_SRC_DTIMER32_KRN_CLK
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__SEL_SRC_DTIMER32_KRN_CLK__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.CPUS_CFG_CLR.OTP_KEEP_PWR_ST -------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.OTP_KEEP_PWR_ST:

    1: OTP keep power state after a reset

</pre> */

#define SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Pos                  11                                                                     /*!< Right-most bit position of OTP_KEEP_PWR_ST in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Msk                  (0x00000001UL << SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Pos)               /*!< Mask for OTP_KEEP_PWR_ST in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Shift(v)             (((v) << SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Pos) & SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Msk) /*!< Shift value 'v' into OTP_KEEP_PWR_ST and mask 'v' to fit it into OTP_KEEP_PWR_ST field */

/** SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__SET() sets CPUS_CFG_CLR.OTP_KEEP_PWR_ST to given value.
 *
 * When writing to CPUS_CFG_CLR.OTP_KEEP_PWR_ST, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.OTP_KEEP_PWR_ST
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__MODIFY() modifies CPUS_CFG_CLR.OTP_KEEP_PWR_ST.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.OTP_KEEP_PWR_ST
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__EXTRACT() extracts CPUS_CFG_CLR.OTP_KEEP_PWR_ST.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.OTP_KEEP_PWR_ST
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__OTP_KEEP_PWR_ST__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_CLR.USR_CNFG6 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.USR_CNFG6:

    1: USR_CNFG6 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__USR_CNFG6__Pos                        10                                                                     /*!< Right-most bit position of USR_CNFG6 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG6__Msk                        (0x00000001UL << SCU_CPUS_CFG_CLR__USR_CNFG6__Pos)                     /*!< Mask for USR_CNFG6 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG6__Shift(v)                   (((v) << SCU_CPUS_CFG_CLR__USR_CNFG6__Pos) & SCU_CPUS_CFG_CLR__USR_CNFG6__Msk) /*!< Shift value 'v' into USR_CNFG6 and mask 'v' to fit it into USR_CNFG6 field */

/** SCU_CPUS_CFG_CLR__USR_CNFG6__SET() sets CPUS_CFG_CLR.USR_CNFG6 to given value.
 *
 * When writing to CPUS_CFG_CLR.USR_CNFG6, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG6
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__USR_CNFG6__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__USR_CNFG6__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__USR_CNFG6__MODIFY() modifies CPUS_CFG_CLR.USR_CNFG6.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG6
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG6__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__USR_CNFG6__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__USR_CNFG6__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__USR_CNFG6__EXTRACT() extracts CPUS_CFG_CLR.USR_CNFG6.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.USR_CNFG6
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG6__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__USR_CNFG6__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__USR_CNFG6__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_CLR.USR_CNFG5 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.USR_CNFG5:

    1: USR_CNFG5 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__USR_CNFG5__Pos                        9                                                                      /*!< Right-most bit position of USR_CNFG5 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG5__Msk                        (0x00000001UL << SCU_CPUS_CFG_CLR__USR_CNFG5__Pos)                     /*!< Mask for USR_CNFG5 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG5__Shift(v)                   (((v) << SCU_CPUS_CFG_CLR__USR_CNFG5__Pos) & SCU_CPUS_CFG_CLR__USR_CNFG5__Msk) /*!< Shift value 'v' into USR_CNFG5 and mask 'v' to fit it into USR_CNFG5 field */

/** SCU_CPUS_CFG_CLR__USR_CNFG5__SET() sets CPUS_CFG_CLR.USR_CNFG5 to given value.
 *
 * When writing to CPUS_CFG_CLR.USR_CNFG5, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG5
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__USR_CNFG5__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__USR_CNFG5__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__USR_CNFG5__MODIFY() modifies CPUS_CFG_CLR.USR_CNFG5.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG5
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG5__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__USR_CNFG5__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__USR_CNFG5__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__USR_CNFG5__EXTRACT() extracts CPUS_CFG_CLR.USR_CNFG5.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.USR_CNFG5
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG5__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__USR_CNFG5__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__USR_CNFG5__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_CLR.USR_CNFG4 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.USR_CNFG4:

    1: USR_CNFG4 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__USR_CNFG4__Pos                        8                                                                      /*!< Right-most bit position of USR_CNFG4 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG4__Msk                        (0x00000001UL << SCU_CPUS_CFG_CLR__USR_CNFG4__Pos)                     /*!< Mask for USR_CNFG4 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG4__Shift(v)                   (((v) << SCU_CPUS_CFG_CLR__USR_CNFG4__Pos) & SCU_CPUS_CFG_CLR__USR_CNFG4__Msk) /*!< Shift value 'v' into USR_CNFG4 and mask 'v' to fit it into USR_CNFG4 field */

/** SCU_CPUS_CFG_CLR__USR_CNFG4__SET() sets CPUS_CFG_CLR.USR_CNFG4 to given value.
 *
 * When writing to CPUS_CFG_CLR.USR_CNFG4, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG4
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__USR_CNFG4__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__USR_CNFG4__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__USR_CNFG4__MODIFY() modifies CPUS_CFG_CLR.USR_CNFG4.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG4
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG4__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__USR_CNFG4__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__USR_CNFG4__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__USR_CNFG4__EXTRACT() extracts CPUS_CFG_CLR.USR_CNFG4.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.USR_CNFG4
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG4__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__USR_CNFG4__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__USR_CNFG4__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_CLR.USR_CNFG3 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.USR_CNFG3:

    1: USR_CNFG3 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__USR_CNFG3__Pos                        7                                                                      /*!< Right-most bit position of USR_CNFG3 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG3__Msk                        (0x00000001UL << SCU_CPUS_CFG_CLR__USR_CNFG3__Pos)                     /*!< Mask for USR_CNFG3 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG3__Shift(v)                   (((v) << SCU_CPUS_CFG_CLR__USR_CNFG3__Pos) & SCU_CPUS_CFG_CLR__USR_CNFG3__Msk) /*!< Shift value 'v' into USR_CNFG3 and mask 'v' to fit it into USR_CNFG3 field */

/** SCU_CPUS_CFG_CLR__USR_CNFG3__SET() sets CPUS_CFG_CLR.USR_CNFG3 to given value.
 *
 * When writing to CPUS_CFG_CLR.USR_CNFG3, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG3
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__USR_CNFG3__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__USR_CNFG3__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__USR_CNFG3__MODIFY() modifies CPUS_CFG_CLR.USR_CNFG3.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG3
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__USR_CNFG3__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__USR_CNFG3__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__USR_CNFG3__EXTRACT() extracts CPUS_CFG_CLR.USR_CNFG3.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.USR_CNFG3
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG3__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__USR_CNFG3__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__USR_CNFG3__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_CLR.USR_CNFG2 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.USR_CNFG2:

    1: USR_CNFG2 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__USR_CNFG2__Pos                        6                                                                      /*!< Right-most bit position of USR_CNFG2 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG2__Msk                        (0x00000001UL << SCU_CPUS_CFG_CLR__USR_CNFG2__Pos)                     /*!< Mask for USR_CNFG2 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG2__Shift(v)                   (((v) << SCU_CPUS_CFG_CLR__USR_CNFG2__Pos) & SCU_CPUS_CFG_CLR__USR_CNFG2__Msk) /*!< Shift value 'v' into USR_CNFG2 and mask 'v' to fit it into USR_CNFG2 field */

/** SCU_CPUS_CFG_CLR__USR_CNFG2__SET() sets CPUS_CFG_CLR.USR_CNFG2 to given value.
 *
 * When writing to CPUS_CFG_CLR.USR_CNFG2, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG2
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__USR_CNFG2__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__USR_CNFG2__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__USR_CNFG2__MODIFY() modifies CPUS_CFG_CLR.USR_CNFG2.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG2
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__USR_CNFG2__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__USR_CNFG2__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__USR_CNFG2__EXTRACT() extracts CPUS_CFG_CLR.USR_CNFG2.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.USR_CNFG2
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG2__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__USR_CNFG2__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__USR_CNFG2__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_CLR.USR_CNFG1 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.USR_CNFG1:

    1: USR_CNFG1 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__USR_CNFG1__Pos                        5                                                                      /*!< Right-most bit position of USR_CNFG1 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG1__Msk                        (0x00000001UL << SCU_CPUS_CFG_CLR__USR_CNFG1__Pos)                     /*!< Mask for USR_CNFG1 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG1__Shift(v)                   (((v) << SCU_CPUS_CFG_CLR__USR_CNFG1__Pos) & SCU_CPUS_CFG_CLR__USR_CNFG1__Msk) /*!< Shift value 'v' into USR_CNFG1 and mask 'v' to fit it into USR_CNFG1 field */

/** SCU_CPUS_CFG_CLR__USR_CNFG1__SET() sets CPUS_CFG_CLR.USR_CNFG1 to given value.
 *
 * When writing to CPUS_CFG_CLR.USR_CNFG1, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG1
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__USR_CNFG1__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__USR_CNFG1__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__USR_CNFG1__MODIFY() modifies CPUS_CFG_CLR.USR_CNFG1.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG1
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__USR_CNFG1__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__USR_CNFG1__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__USR_CNFG1__EXTRACT() extracts CPUS_CFG_CLR.USR_CNFG1.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.USR_CNFG1
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG1__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__USR_CNFG1__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__USR_CNFG1__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_CLR.USR_CNFG0 ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.USR_CNFG0:

    1: USR_CNFG0 signal set to High

</pre> */

#define SCU_CPUS_CFG_CLR__USR_CNFG0__Pos                        4                                                                      /*!< Right-most bit position of USR_CNFG0 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG0__Msk                        (0x00000001UL << SCU_CPUS_CFG_CLR__USR_CNFG0__Pos)                     /*!< Mask for USR_CNFG0 in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__USR_CNFG0__Shift(v)                   (((v) << SCU_CPUS_CFG_CLR__USR_CNFG0__Pos) & SCU_CPUS_CFG_CLR__USR_CNFG0__Msk) /*!< Shift value 'v' into USR_CNFG0 and mask 'v' to fit it into USR_CNFG0 field */

/** SCU_CPUS_CFG_CLR__USR_CNFG0__SET() sets CPUS_CFG_CLR.USR_CNFG0 to given value.
 *
 * When writing to CPUS_CFG_CLR.USR_CNFG0, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG0
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__USR_CNFG0__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__USR_CNFG0__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__USR_CNFG0__MODIFY() modifies CPUS_CFG_CLR.USR_CNFG0.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.USR_CNFG0
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__USR_CNFG0__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__USR_CNFG0__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__USR_CNFG0__EXTRACT() extracts CPUS_CFG_CLR.USR_CNFG0.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.USR_CNFG0
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__USR_CNFG0__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__USR_CNFG0__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__USR_CNFG0__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.CPUS_CFG_CLR.EN_EXTWKUP ---------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.EN_EXTWKUP:

    1: CPUS Ext wakeup is enabled

</pre> */

#define SCU_CPUS_CFG_CLR__EN_EXTWKUP__Pos                       3                                                                      /*!< Right-most bit position of EN_EXTWKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_EXTWKUP__Msk                       (0x00000001UL << SCU_CPUS_CFG_CLR__EN_EXTWKUP__Pos)                    /*!< Mask for EN_EXTWKUP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__EN_EXTWKUP__Shift(v)                  (((v) << SCU_CPUS_CFG_CLR__EN_EXTWKUP__Pos) & SCU_CPUS_CFG_CLR__EN_EXTWKUP__Msk) /*!< Shift value 'v' into EN_EXTWKUP and mask 'v' to fit it into EN_EXTWKUP field */

/** SCU_CPUS_CFG_CLR__EN_EXTWKUP__SET() sets CPUS_CFG_CLR.EN_EXTWKUP to given value.
 *
 * When writing to CPUS_CFG_CLR.EN_EXTWKUP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.EN_EXTWKUP
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__EN_EXTWKUP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__EN_EXTWKUP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__EN_EXTWKUP__MODIFY() modifies CPUS_CFG_CLR.EN_EXTWKUP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.EN_EXTWKUP
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_EXTWKUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__EN_EXTWKUP__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__EN_EXTWKUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__EN_EXTWKUP__EXTRACT() extracts CPUS_CFG_CLR.EN_EXTWKUP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.EN_EXTWKUP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__EN_EXTWKUP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__EN_EXTWKUP__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__EN_EXTWKUP__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.CPUS_CFG_CLR.DS_DBGPORT ---------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.DS_DBGPORT:

    1: DBG Port connection is disabled

</pre> */

#define SCU_CPUS_CFG_CLR__DS_DBGPORT__Pos                       2                                                                      /*!< Right-most bit position of DS_DBGPORT in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__DS_DBGPORT__Msk                       (0x00000001UL << SCU_CPUS_CFG_CLR__DS_DBGPORT__Pos)                    /*!< Mask for DS_DBGPORT in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__DS_DBGPORT__Shift(v)                  (((v) << SCU_CPUS_CFG_CLR__DS_DBGPORT__Pos) & SCU_CPUS_CFG_CLR__DS_DBGPORT__Msk) /*!< Shift value 'v' into DS_DBGPORT and mask 'v' to fit it into DS_DBGPORT field */

/** SCU_CPUS_CFG_CLR__DS_DBGPORT__SET() sets CPUS_CFG_CLR.DS_DBGPORT to given value.
 *
 * When writing to CPUS_CFG_CLR.DS_DBGPORT, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.DS_DBGPORT
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__DS_DBGPORT__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__DS_DBGPORT__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__DS_DBGPORT__MODIFY() modifies CPUS_CFG_CLR.DS_DBGPORT.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.DS_DBGPORT
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__DS_DBGPORT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__DS_DBGPORT__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__DS_DBGPORT__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__DS_DBGPORT__EXTRACT() extracts CPUS_CFG_CLR.DS_DBGPORT.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.DS_DBGPORT
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__DS_DBGPORT__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__DS_DBGPORT__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__DS_DBGPORT__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.CPUS_CFG_CLR.SET_REMAP ----------------------- */

/**
<pre>
  SCU.CPUS_CFG_CLR.SET_REMAP:

    1: Remap signal set to 1

</pre> */

#define SCU_CPUS_CFG_CLR__SET_REMAP__Pos                        0                                                                      /*!< Right-most bit position of SET_REMAP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SET_REMAP__Msk                        (0x00000001UL << SCU_CPUS_CFG_CLR__SET_REMAP__Pos)                     /*!< Mask for SET_REMAP in SCU.CPUS_CFG_CLR */
#define SCU_CPUS_CFG_CLR__SET_REMAP__Shift(v)                   (((v) << SCU_CPUS_CFG_CLR__SET_REMAP__Pos) & SCU_CPUS_CFG_CLR__SET_REMAP__Msk) /*!< Shift value 'v' into SET_REMAP and mask 'v' to fit it into SET_REMAP field */

/** SCU_CPUS_CFG_CLR__SET_REMAP__SET() sets CPUS_CFG_CLR.SET_REMAP to given value.
 *
 * When writing to CPUS_CFG_CLR.SET_REMAP, this is recommended to use.
 *
 * @param bf_value new value for CPUS_CFG_CLR.SET_REMAP
 */
__SCU_INLINE void SCU_CPUS_CFG_CLR__SET_REMAP__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_CPUS_CFG_CLR__SET_REMAP__Shift((uint32_t)bf_value);
    SCU_CPUS_CFG_CLR__SET(reg);
}


/** SCU_CPUS_CFG_CLR__SET_REMAP__MODIFY() modifies CPUS_CFG_CLR.SET_REMAP.
 *
 * This is recommended to use when setting more than one bitfield of SCU.CPUS_CFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @param bf_value new value for CPUS_CFG_CLR.SET_REMAP
 * @return new value of SCU.CPUS_CFG_CLR
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SET_REMAP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_CPUS_CFG_CLR__SET_REMAP__Msk);
    reg = (reg | (SCU_CPUS_CFG_CLR__SET_REMAP__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_CPUS_CFG_CLR__SET_REMAP__EXTRACT() extracts CPUS_CFG_CLR.SET_REMAP.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.CPUS_CFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.CPUS_CFG_CLR
 * @return current value of CPUS_CFG_CLR.SET_REMAP
 */
__SCU_INLINE uint32_t SCU_CPUS_CFG_CLR__SET_REMAP__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_CPUS_CFG_CLR__SET_REMAP__Msk);
    reg = (reg >> SCU_CPUS_CFG_CLR__SET_REMAP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         NMI_SRC_EN member of SCU_t                         */
/* -------------------------------------------------------------------------- */

/** __SCU_NMI_SRC_EN__ADDRESS returns the address of member NMI_SRC_EN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of NMI_SRC_EN
 */
__SCU_INLINE uint32_t* __SCU_NMI_SRC_EN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__SCU_BASE_PTR() + (uint32_t)(offsetof(SCU_t, NMI_SRC_EN)));
}

/** SCU_NMI_SRC_EN__SET() sets NMI_SRC_EN to given value.
 *
 * When writing to NMI_SRC_EN, this is mandatory to use.
 *
 * @param value new value for NMI_SRC_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__SET(uint32_t value)
{
    HAL_SET32(__SCU_NMI_SRC_EN__ADDRESS(), value);
}

/** SCU_NMI_SRC_EN__GET() gets NMI_SRC_EN's current value.
 *
 * When reading from NMI_SRC_EN, this is mandatory to use.
 *
 * @return current value of NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__GET(void)
{
    return HAL_GET32(__SCU_NMI_SRC_EN__ADDRESS());
}

/* ----------------------- SCU.NMI_SRC_EN.UART_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.UART_NMI_EN:

    Enable UART_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__UART_NMI_EN__Pos                        31                                                                     /*!< Right-most bit position of UART_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__UART_NMI_EN__Msk                        (0x00000001UL << SCU_NMI_SRC_EN__UART_NMI_EN__Pos)                     /*!< Mask for UART_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__UART_NMI_EN__Shift(v)                   (((v) << SCU_NMI_SRC_EN__UART_NMI_EN__Pos) & SCU_NMI_SRC_EN__UART_NMI_EN__Msk) /*!< Shift value 'v' into UART_NMI_EN and mask 'v' to fit it into UART_NMI_EN field */

/** SCU_NMI_SRC_EN__UART_NMI_EN__SET() sets NMI_SRC_EN.UART_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.UART_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.UART_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__UART_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__UART_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__UART_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__UART_NMI_EN__GET() gets NMI_SRC_EN.UART_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.UART_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.UART_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__UART_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__UART_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__UART_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__UART_NMI_EN__MODIFY() modifies NMI_SRC_EN.UART_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.UART_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__UART_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__UART_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__UART_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__UART_NMI_EN__EXTRACT() extracts NMI_SRC_EN.UART_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.UART_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__UART_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__UART_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__UART_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.I2C_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.I2C_NMI_EN:

    Enable I2C_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__I2C_NMI_EN__Pos                         30                                                                     /*!< Right-most bit position of I2C_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__I2C_NMI_EN__Msk                         (0x00000001UL << SCU_NMI_SRC_EN__I2C_NMI_EN__Pos)                      /*!< Mask for I2C_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__I2C_NMI_EN__Shift(v)                    (((v) << SCU_NMI_SRC_EN__I2C_NMI_EN__Pos) & SCU_NMI_SRC_EN__I2C_NMI_EN__Msk) /*!< Shift value 'v' into I2C_NMI_EN and mask 'v' to fit it into I2C_NMI_EN field */

/** SCU_NMI_SRC_EN__I2C_NMI_EN__SET() sets NMI_SRC_EN.I2C_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.I2C_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.I2C_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__I2C_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__I2C_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__I2C_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__I2C_NMI_EN__GET() gets NMI_SRC_EN.I2C_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.I2C_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.I2C_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__I2C_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__I2C_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__I2C_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__I2C_NMI_EN__MODIFY() modifies NMI_SRC_EN.I2C_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.I2C_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__I2C_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__I2C_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__I2C_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__I2C_NMI_EN__EXTRACT() extracts NMI_SRC_EN.I2C_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.I2C_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__I2C_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__I2C_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__I2C_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.SSP_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.SSP_NMI_EN:

    Enable SSP_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__SSP_NMI_EN__Pos                         29                                                                     /*!< Right-most bit position of SSP_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__SSP_NMI_EN__Msk                         (0x00000001UL << SCU_NMI_SRC_EN__SSP_NMI_EN__Pos)                      /*!< Mask for SSP_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__SSP_NMI_EN__Shift(v)                    (((v) << SCU_NMI_SRC_EN__SSP_NMI_EN__Pos) & SCU_NMI_SRC_EN__SSP_NMI_EN__Msk) /*!< Shift value 'v' into SSP_NMI_EN and mask 'v' to fit it into SSP_NMI_EN field */

/** SCU_NMI_SRC_EN__SSP_NMI_EN__SET() sets NMI_SRC_EN.SSP_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.SSP_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.SSP_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__SSP_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__SSP_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__SSP_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__SSP_NMI_EN__GET() gets NMI_SRC_EN.SSP_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.SSP_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.SSP_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__SSP_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__SSP_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__SSP_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__SSP_NMI_EN__MODIFY() modifies NMI_SRC_EN.SSP_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.SSP_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__SSP_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__SSP_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__SSP_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__SSP_NMI_EN__EXTRACT() extracts NMI_SRC_EN.SSP_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.SSP_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__SSP_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__SSP_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__SSP_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.DMA_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.DMA_NMI_EN:

    Enable DMA_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__DMA_NMI_EN__Pos                         28                                                                     /*!< Right-most bit position of DMA_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DMA_NMI_EN__Msk                         (0x00000001UL << SCU_NMI_SRC_EN__DMA_NMI_EN__Pos)                      /*!< Mask for DMA_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DMA_NMI_EN__Shift(v)                    (((v) << SCU_NMI_SRC_EN__DMA_NMI_EN__Pos) & SCU_NMI_SRC_EN__DMA_NMI_EN__Msk) /*!< Shift value 'v' into DMA_NMI_EN and mask 'v' to fit it into DMA_NMI_EN field */

/** SCU_NMI_SRC_EN__DMA_NMI_EN__SET() sets NMI_SRC_EN.DMA_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.DMA_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.DMA_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__DMA_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__DMA_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DMA_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__DMA_NMI_EN__GET() gets NMI_SRC_EN.DMA_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.DMA_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.DMA_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DMA_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__DMA_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DMA_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__DMA_NMI_EN__MODIFY() modifies NMI_SRC_EN.DMA_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.DMA_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DMA_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__DMA_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DMA_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__DMA_NMI_EN__EXTRACT() extracts NMI_SRC_EN.DMA_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.DMA_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DMA_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__DMA_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DMA_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- SCU.NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN ------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN:

    Enable FSW_IRQn as NMI (FSW0 and FSW1 interrupts are OR-ed)

</pre> */

#define SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Pos                26                                                                     /*!< Right-most bit position of FSW0_OR_FSW1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Msk                (0x00000001UL << SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Pos)             /*!< Mask for FSW0_OR_FSW1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Shift(v)           (((v) << SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Pos) & SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Msk) /*!< Shift value 'v' into FSW0_OR_FSW1_NMI_EN and mask 'v' to fit it into FSW0_OR_FSW1_NMI_EN field */

/** SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__SET() sets NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__GET() gets NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__MODIFY() modifies NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__EXTRACT() extracts NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.FSW0_OR_FSW1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__FSW0_OR_FSW1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.TLM_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.TLM_NMI_EN:

    Enable TLM_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__TLM_NMI_EN__Pos                         25                                                                     /*!< Right-most bit position of TLM_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__TLM_NMI_EN__Msk                         (0x00000001UL << SCU_NMI_SRC_EN__TLM_NMI_EN__Pos)                      /*!< Mask for TLM_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__TLM_NMI_EN__Shift(v)                    (((v) << SCU_NMI_SRC_EN__TLM_NMI_EN__Pos) & SCU_NMI_SRC_EN__TLM_NMI_EN__Msk) /*!< Shift value 'v' into TLM_NMI_EN and mask 'v' to fit it into TLM_NMI_EN field */

/** SCU_NMI_SRC_EN__TLM_NMI_EN__SET() sets NMI_SRC_EN.TLM_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.TLM_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.TLM_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__TLM_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__TLM_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__TLM_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__TLM_NMI_EN__GET() gets NMI_SRC_EN.TLM_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.TLM_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.TLM_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__TLM_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__TLM_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__TLM_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__TLM_NMI_EN__MODIFY() modifies NMI_SRC_EN.TLM_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.TLM_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__TLM_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__TLM_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__TLM_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__TLM_NMI_EN__EXTRACT() extracts NMI_SRC_EN.TLM_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.TLM_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__TLM_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__TLM_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__TLM_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- SCU.NMI_SRC_EN.VC1_VCONTROL_NMI_EN ------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.VC1_VCONTROL_NMI_EN:

    Enable VC1_VCONTROL_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Pos                24                                                                     /*!< Right-most bit position of VC1_VCONTROL_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Msk                (0x00000001UL << SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Pos)             /*!< Mask for VC1_VCONTROL_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Shift(v)           (((v) << SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Pos) & SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Msk) /*!< Shift value 'v' into VC1_VCONTROL_NMI_EN and mask 'v' to fit it into VC1_VCONTROL_NMI_EN field */

/** SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__SET() sets NMI_SRC_EN.VC1_VCONTROL_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.VC1_VCONTROL_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.VC1_VCONTROL_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__GET() gets NMI_SRC_EN.VC1_VCONTROL_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.VC1_VCONTROL_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.VC1_VCONTROL_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__MODIFY() modifies NMI_SRC_EN.VC1_VCONTROL_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.VC1_VCONTROL_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__EXTRACT() extracts NMI_SRC_EN.VC1_VCONTROL_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.VC1_VCONTROL_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__VC1_VCONTROL_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- SCU.NMI_SRC_EN.VC0_VCONTROL_NMI_EN ------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.VC0_VCONTROL_NMI_EN:

    Enable VC0_VCONTROL_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Pos                23                                                                     /*!< Right-most bit position of VC0_VCONTROL_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Msk                (0x00000001UL << SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Pos)             /*!< Mask for VC0_VCONTROL_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Shift(v)           (((v) << SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Pos) & SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Msk) /*!< Shift value 'v' into VC0_VCONTROL_NMI_EN and mask 'v' to fit it into VC0_VCONTROL_NMI_EN field */

/** SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__SET() sets NMI_SRC_EN.VC0_VCONTROL_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.VC0_VCONTROL_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.VC0_VCONTROL_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__GET() gets NMI_SRC_EN.VC0_VCONTROL_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.VC0_VCONTROL_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.VC0_VCONTROL_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__MODIFY() modifies NMI_SRC_EN.VC0_VCONTROL_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.VC0_VCONTROL_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__EXTRACT() extracts NMI_SRC_EN.VC0_VCONTROL_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.VC0_VCONTROL_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__VC0_VCONTROL_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.TEST_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.TEST_NMI_EN:

    Enable TEST_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__TEST_NMI_EN__Pos                        22                                                                     /*!< Right-most bit position of TEST_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__TEST_NMI_EN__Msk                        (0x00000001UL << SCU_NMI_SRC_EN__TEST_NMI_EN__Pos)                     /*!< Mask for TEST_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__TEST_NMI_EN__Shift(v)                   (((v) << SCU_NMI_SRC_EN__TEST_NMI_EN__Pos) & SCU_NMI_SRC_EN__TEST_NMI_EN__Msk) /*!< Shift value 'v' into TEST_NMI_EN and mask 'v' to fit it into TEST_NMI_EN field */

/** SCU_NMI_SRC_EN__TEST_NMI_EN__SET() sets NMI_SRC_EN.TEST_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.TEST_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.TEST_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__TEST_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__TEST_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__TEST_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__TEST_NMI_EN__GET() gets NMI_SRC_EN.TEST_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.TEST_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.TEST_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__TEST_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__TEST_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__TEST_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__TEST_NMI_EN__MODIFY() modifies NMI_SRC_EN.TEST_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.TEST_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__TEST_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__TEST_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__TEST_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__TEST_NMI_EN__EXTRACT() extracts NMI_SRC_EN.TEST_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.TEST_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__TEST_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__TEST_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__TEST_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.NMI_SRC_EN.FAULT_NMI_EN ---------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.FAULT_NMI_EN:

    Enable FAULT_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__FAULT_NMI_EN__Pos                       21                                                                     /*!< Right-most bit position of FAULT_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__FAULT_NMI_EN__Msk                       (0x00000001UL << SCU_NMI_SRC_EN__FAULT_NMI_EN__Pos)                    /*!< Mask for FAULT_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__FAULT_NMI_EN__Shift(v)                  (((v) << SCU_NMI_SRC_EN__FAULT_NMI_EN__Pos) & SCU_NMI_SRC_EN__FAULT_NMI_EN__Msk) /*!< Shift value 'v' into FAULT_NMI_EN and mask 'v' to fit it into FAULT_NMI_EN field */

/** SCU_NMI_SRC_EN__FAULT_NMI_EN__SET() sets NMI_SRC_EN.FAULT_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.FAULT_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.FAULT_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__FAULT_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__FAULT_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__FAULT_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__FAULT_NMI_EN__GET() gets NMI_SRC_EN.FAULT_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.FAULT_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.FAULT_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__FAULT_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__FAULT_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__FAULT_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__FAULT_NMI_EN__MODIFY() modifies NMI_SRC_EN.FAULT_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.FAULT_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__FAULT_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__FAULT_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__FAULT_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__FAULT_NMI_EN__EXTRACT() extracts NMI_SRC_EN.FAULT_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.FAULT_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__FAULT_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__FAULT_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__FAULT_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.NMI_SRC_EN.GPIO1_NMI_EN ---------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.GPIO1_NMI_EN:

    Enable GPIO1_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__GPIO1_NMI_EN__Pos                       20                                                                     /*!< Right-most bit position of GPIO1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__GPIO1_NMI_EN__Msk                       (0x00000001UL << SCU_NMI_SRC_EN__GPIO1_NMI_EN__Pos)                    /*!< Mask for GPIO1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__GPIO1_NMI_EN__Shift(v)                  (((v) << SCU_NMI_SRC_EN__GPIO1_NMI_EN__Pos) & SCU_NMI_SRC_EN__GPIO1_NMI_EN__Msk) /*!< Shift value 'v' into GPIO1_NMI_EN and mask 'v' to fit it into GPIO1_NMI_EN field */

/** SCU_NMI_SRC_EN__GPIO1_NMI_EN__SET() sets NMI_SRC_EN.GPIO1_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.GPIO1_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.GPIO1_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__GPIO1_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__GPIO1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__GPIO1_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__GPIO1_NMI_EN__GET() gets NMI_SRC_EN.GPIO1_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.GPIO1_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.GPIO1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__GPIO1_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__GPIO1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__GPIO1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__GPIO1_NMI_EN__MODIFY() modifies NMI_SRC_EN.GPIO1_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.GPIO1_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__GPIO1_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__GPIO1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__GPIO1_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__GPIO1_NMI_EN__EXTRACT() extracts NMI_SRC_EN.GPIO1_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.GPIO1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__GPIO1_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__GPIO1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__GPIO1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.NMI_SRC_EN.GPIO0_NMI_EN ---------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.GPIO0_NMI_EN:

    Enable GPIO0_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__GPIO0_NMI_EN__Pos                       19                                                                     /*!< Right-most bit position of GPIO0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__GPIO0_NMI_EN__Msk                       (0x00000001UL << SCU_NMI_SRC_EN__GPIO0_NMI_EN__Pos)                    /*!< Mask for GPIO0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__GPIO0_NMI_EN__Shift(v)                  (((v) << SCU_NMI_SRC_EN__GPIO0_NMI_EN__Pos) & SCU_NMI_SRC_EN__GPIO0_NMI_EN__Msk) /*!< Shift value 'v' into GPIO0_NMI_EN and mask 'v' to fit it into GPIO0_NMI_EN field */

/** SCU_NMI_SRC_EN__GPIO0_NMI_EN__SET() sets NMI_SRC_EN.GPIO0_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.GPIO0_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.GPIO0_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__GPIO0_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__GPIO0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__GPIO0_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__GPIO0_NMI_EN__GET() gets NMI_SRC_EN.GPIO0_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.GPIO0_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.GPIO0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__GPIO0_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__GPIO0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__GPIO0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__GPIO0_NMI_EN__MODIFY() modifies NMI_SRC_EN.GPIO0_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.GPIO0_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__GPIO0_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__GPIO0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__GPIO0_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__GPIO0_NMI_EN__EXTRACT() extracts NMI_SRC_EN.GPIO0_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.GPIO0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__GPIO0_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__GPIO0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__GPIO0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.NMI_SRC_EN.DTIMER3_1_NMI_EN -------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.DTIMER3_1_NMI_EN:

    Enable DTIMER3_1_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Pos                   18                                                                     /*!< Right-most bit position of DTIMER3_1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Msk                   (0x00000001UL << SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Pos)                /*!< Mask for DTIMER3_1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Shift(v)              (((v) << SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Pos) & SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Msk) /*!< Shift value 'v' into DTIMER3_1_NMI_EN and mask 'v' to fit it into DTIMER3_1_NMI_EN field */

/** SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__SET() sets NMI_SRC_EN.DTIMER3_1_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.DTIMER3_1_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.DTIMER3_1_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__GET() gets NMI_SRC_EN.DTIMER3_1_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.DTIMER3_1_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.DTIMER3_1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__MODIFY() modifies NMI_SRC_EN.DTIMER3_1_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.DTIMER3_1_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__EXTRACT() extracts NMI_SRC_EN.DTIMER3_1_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.DTIMER3_1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER3_1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.NMI_SRC_EN.DTIMER3_0_NMI_EN -------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.DTIMER3_0_NMI_EN:

    Enable DTIMER3_0_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Pos                   17                                                                     /*!< Right-most bit position of DTIMER3_0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Msk                   (0x00000001UL << SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Pos)                /*!< Mask for DTIMER3_0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Shift(v)              (((v) << SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Pos) & SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Msk) /*!< Shift value 'v' into DTIMER3_0_NMI_EN and mask 'v' to fit it into DTIMER3_0_NMI_EN field */

/** SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__SET() sets NMI_SRC_EN.DTIMER3_0_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.DTIMER3_0_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.DTIMER3_0_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__GET() gets NMI_SRC_EN.DTIMER3_0_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.DTIMER3_0_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.DTIMER3_0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__MODIFY() modifies NMI_SRC_EN.DTIMER3_0_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.DTIMER3_0_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__EXTRACT() extracts NMI_SRC_EN.DTIMER3_0_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.DTIMER3_0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER3_0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.NMI_SRC_EN.DTIMER2_1_NMI_EN -------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.DTIMER2_1_NMI_EN:

    Enable DTIMER2_1_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Pos                   16                                                                     /*!< Right-most bit position of DTIMER2_1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Msk                   (0x00000001UL << SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Pos)                /*!< Mask for DTIMER2_1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Shift(v)              (((v) << SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Pos) & SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Msk) /*!< Shift value 'v' into DTIMER2_1_NMI_EN and mask 'v' to fit it into DTIMER2_1_NMI_EN field */

/** SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__SET() sets NMI_SRC_EN.DTIMER2_1_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.DTIMER2_1_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.DTIMER2_1_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__GET() gets NMI_SRC_EN.DTIMER2_1_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.DTIMER2_1_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.DTIMER2_1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__MODIFY() modifies NMI_SRC_EN.DTIMER2_1_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.DTIMER2_1_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__EXTRACT() extracts NMI_SRC_EN.DTIMER2_1_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.DTIMER2_1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER2_1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.NMI_SRC_EN.DTIMER2_0_NMI_EN -------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.DTIMER2_0_NMI_EN:

    Enable DTIMER2_0_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Pos                   15                                                                     /*!< Right-most bit position of DTIMER2_0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Msk                   (0x00000001UL << SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Pos)                /*!< Mask for DTIMER2_0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Shift(v)              (((v) << SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Pos) & SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Msk) /*!< Shift value 'v' into DTIMER2_0_NMI_EN and mask 'v' to fit it into DTIMER2_0_NMI_EN field */

/** SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__SET() sets NMI_SRC_EN.DTIMER2_0_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.DTIMER2_0_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.DTIMER2_0_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__GET() gets NMI_SRC_EN.DTIMER2_0_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.DTIMER2_0_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.DTIMER2_0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__MODIFY() modifies NMI_SRC_EN.DTIMER2_0_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.DTIMER2_0_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__EXTRACT() extracts NMI_SRC_EN.DTIMER2_0_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.DTIMER2_0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER2_0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.NMI_SRC_EN.DTIMER1_1_NMI_EN -------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.DTIMER1_1_NMI_EN:

    Enable DTIMER1_1_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Pos                   14                                                                     /*!< Right-most bit position of DTIMER1_1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Msk                   (0x00000001UL << SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Pos)                /*!< Mask for DTIMER1_1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Shift(v)              (((v) << SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Pos) & SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Msk) /*!< Shift value 'v' into DTIMER1_1_NMI_EN and mask 'v' to fit it into DTIMER1_1_NMI_EN field */

/** SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__SET() sets NMI_SRC_EN.DTIMER1_1_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.DTIMER1_1_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.DTIMER1_1_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__GET() gets NMI_SRC_EN.DTIMER1_1_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.DTIMER1_1_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.DTIMER1_1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__MODIFY() modifies NMI_SRC_EN.DTIMER1_1_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.DTIMER1_1_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__EXTRACT() extracts NMI_SRC_EN.DTIMER1_1_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.DTIMER1_1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER1_1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.NMI_SRC_EN.DTIMER1_0_NMI_EN -------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.DTIMER1_0_NMI_EN:

    Enable DTIMER1_0_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Pos                   13                                                                     /*!< Right-most bit position of DTIMER1_0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Msk                   (0x00000001UL << SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Pos)                /*!< Mask for DTIMER1_0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Shift(v)              (((v) << SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Pos) & SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Msk) /*!< Shift value 'v' into DTIMER1_0_NMI_EN and mask 'v' to fit it into DTIMER1_0_NMI_EN field */

/** SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__SET() sets NMI_SRC_EN.DTIMER1_0_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.DTIMER1_0_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.DTIMER1_0_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__GET() gets NMI_SRC_EN.DTIMER1_0_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.DTIMER1_0_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.DTIMER1_0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__MODIFY() modifies NMI_SRC_EN.DTIMER1_0_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.DTIMER1_0_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__EXTRACT() extracts NMI_SRC_EN.DTIMER1_0_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.DTIMER1_0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__DTIMER1_0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.WDT_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.WDT_NMI_EN:

    Enable WDT_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__WDT_NMI_EN__Pos                         12                                                                     /*!< Right-most bit position of WDT_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__WDT_NMI_EN__Msk                         (0x00000001UL << SCU_NMI_SRC_EN__WDT_NMI_EN__Pos)                      /*!< Mask for WDT_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__WDT_NMI_EN__Shift(v)                    (((v) << SCU_NMI_SRC_EN__WDT_NMI_EN__Pos) & SCU_NMI_SRC_EN__WDT_NMI_EN__Msk) /*!< Shift value 'v' into WDT_NMI_EN and mask 'v' to fit it into WDT_NMI_EN field */

/** SCU_NMI_SRC_EN__WDT_NMI_EN__SET() sets NMI_SRC_EN.WDT_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.WDT_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.WDT_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__WDT_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__WDT_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__WDT_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__WDT_NMI_EN__GET() gets NMI_SRC_EN.WDT_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.WDT_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.WDT_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__WDT_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__WDT_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__WDT_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__WDT_NMI_EN__MODIFY() modifies NMI_SRC_EN.WDT_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.WDT_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__WDT_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__WDT_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__WDT_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__WDT_NMI_EN__EXTRACT() extracts NMI_SRC_EN.WDT_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.WDT_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__WDT_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__WDT_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__WDT_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.EXT6_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.EXT6_NMI_EN:

    Enable EXT6_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__EXT6_NMI_EN__Pos                        11                                                                     /*!< Right-most bit position of EXT6_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT6_NMI_EN__Msk                        (0x00000001UL << SCU_NMI_SRC_EN__EXT6_NMI_EN__Pos)                     /*!< Mask for EXT6_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT6_NMI_EN__Shift(v)                   (((v) << SCU_NMI_SRC_EN__EXT6_NMI_EN__Pos) & SCU_NMI_SRC_EN__EXT6_NMI_EN__Msk) /*!< Shift value 'v' into EXT6_NMI_EN and mask 'v' to fit it into EXT6_NMI_EN field */

/** SCU_NMI_SRC_EN__EXT6_NMI_EN__SET() sets NMI_SRC_EN.EXT6_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.EXT6_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.EXT6_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__EXT6_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__EXT6_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT6_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__EXT6_NMI_EN__GET() gets NMI_SRC_EN.EXT6_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.EXT6_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.EXT6_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT6_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__EXT6_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT6_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__EXT6_NMI_EN__MODIFY() modifies NMI_SRC_EN.EXT6_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.EXT6_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT6_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__EXT6_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT6_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__EXT6_NMI_EN__EXTRACT() extracts NMI_SRC_EN.EXT6_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.EXT6_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT6_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__EXT6_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT6_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.EXT5_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.EXT5_NMI_EN:

    Enable EXT5_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__EXT5_NMI_EN__Pos                        10                                                                     /*!< Right-most bit position of EXT5_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT5_NMI_EN__Msk                        (0x00000001UL << SCU_NMI_SRC_EN__EXT5_NMI_EN__Pos)                     /*!< Mask for EXT5_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT5_NMI_EN__Shift(v)                   (((v) << SCU_NMI_SRC_EN__EXT5_NMI_EN__Pos) & SCU_NMI_SRC_EN__EXT5_NMI_EN__Msk) /*!< Shift value 'v' into EXT5_NMI_EN and mask 'v' to fit it into EXT5_NMI_EN field */

/** SCU_NMI_SRC_EN__EXT5_NMI_EN__SET() sets NMI_SRC_EN.EXT5_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.EXT5_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.EXT5_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__EXT5_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__EXT5_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT5_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__EXT5_NMI_EN__GET() gets NMI_SRC_EN.EXT5_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.EXT5_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.EXT5_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT5_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__EXT5_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT5_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__EXT5_NMI_EN__MODIFY() modifies NMI_SRC_EN.EXT5_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.EXT5_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT5_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__EXT5_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT5_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__EXT5_NMI_EN__EXTRACT() extracts NMI_SRC_EN.EXT5_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.EXT5_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT5_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__EXT5_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT5_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.EXT4_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.EXT4_NMI_EN:

    Enable EXT4_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__EXT4_NMI_EN__Pos                        9                                                                      /*!< Right-most bit position of EXT4_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT4_NMI_EN__Msk                        (0x00000001UL << SCU_NMI_SRC_EN__EXT4_NMI_EN__Pos)                     /*!< Mask for EXT4_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT4_NMI_EN__Shift(v)                   (((v) << SCU_NMI_SRC_EN__EXT4_NMI_EN__Pos) & SCU_NMI_SRC_EN__EXT4_NMI_EN__Msk) /*!< Shift value 'v' into EXT4_NMI_EN and mask 'v' to fit it into EXT4_NMI_EN field */

/** SCU_NMI_SRC_EN__EXT4_NMI_EN__SET() sets NMI_SRC_EN.EXT4_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.EXT4_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.EXT4_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__EXT4_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__EXT4_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT4_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__EXT4_NMI_EN__GET() gets NMI_SRC_EN.EXT4_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.EXT4_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.EXT4_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT4_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__EXT4_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT4_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__EXT4_NMI_EN__MODIFY() modifies NMI_SRC_EN.EXT4_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.EXT4_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT4_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__EXT4_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT4_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__EXT4_NMI_EN__EXTRACT() extracts NMI_SRC_EN.EXT4_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.EXT4_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT4_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__EXT4_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT4_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.EXT3_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.EXT3_NMI_EN:

    Enable EXT3_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__EXT3_NMI_EN__Pos                        8                                                                      /*!< Right-most bit position of EXT3_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT3_NMI_EN__Msk                        (0x00000001UL << SCU_NMI_SRC_EN__EXT3_NMI_EN__Pos)                     /*!< Mask for EXT3_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT3_NMI_EN__Shift(v)                   (((v) << SCU_NMI_SRC_EN__EXT3_NMI_EN__Pos) & SCU_NMI_SRC_EN__EXT3_NMI_EN__Msk) /*!< Shift value 'v' into EXT3_NMI_EN and mask 'v' to fit it into EXT3_NMI_EN field */

/** SCU_NMI_SRC_EN__EXT3_NMI_EN__SET() sets NMI_SRC_EN.EXT3_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.EXT3_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.EXT3_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__EXT3_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__EXT3_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT3_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__EXT3_NMI_EN__GET() gets NMI_SRC_EN.EXT3_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.EXT3_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.EXT3_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT3_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__EXT3_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT3_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__EXT3_NMI_EN__MODIFY() modifies NMI_SRC_EN.EXT3_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.EXT3_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT3_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__EXT3_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT3_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__EXT3_NMI_EN__EXTRACT() extracts NMI_SRC_EN.EXT3_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.EXT3_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT3_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__EXT3_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT3_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.EXT2_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.EXT2_NMI_EN:

    Enable EXT2_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__EXT2_NMI_EN__Pos                        7                                                                      /*!< Right-most bit position of EXT2_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT2_NMI_EN__Msk                        (0x00000001UL << SCU_NMI_SRC_EN__EXT2_NMI_EN__Pos)                     /*!< Mask for EXT2_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT2_NMI_EN__Shift(v)                   (((v) << SCU_NMI_SRC_EN__EXT2_NMI_EN__Pos) & SCU_NMI_SRC_EN__EXT2_NMI_EN__Msk) /*!< Shift value 'v' into EXT2_NMI_EN and mask 'v' to fit it into EXT2_NMI_EN field */

/** SCU_NMI_SRC_EN__EXT2_NMI_EN__SET() sets NMI_SRC_EN.EXT2_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.EXT2_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.EXT2_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__EXT2_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__EXT2_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT2_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__EXT2_NMI_EN__GET() gets NMI_SRC_EN.EXT2_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.EXT2_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.EXT2_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT2_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__EXT2_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT2_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__EXT2_NMI_EN__MODIFY() modifies NMI_SRC_EN.EXT2_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.EXT2_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT2_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__EXT2_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT2_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__EXT2_NMI_EN__EXTRACT() extracts NMI_SRC_EN.EXT2_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.EXT2_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT2_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__EXT2_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT2_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.EXT1_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.EXT1_NMI_EN:

    Enable EXT1_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__EXT1_NMI_EN__Pos                        6                                                                      /*!< Right-most bit position of EXT1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT1_NMI_EN__Msk                        (0x00000001UL << SCU_NMI_SRC_EN__EXT1_NMI_EN__Pos)                     /*!< Mask for EXT1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT1_NMI_EN__Shift(v)                   (((v) << SCU_NMI_SRC_EN__EXT1_NMI_EN__Pos) & SCU_NMI_SRC_EN__EXT1_NMI_EN__Msk) /*!< Shift value 'v' into EXT1_NMI_EN and mask 'v' to fit it into EXT1_NMI_EN field */

/** SCU_NMI_SRC_EN__EXT1_NMI_EN__SET() sets NMI_SRC_EN.EXT1_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.EXT1_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.EXT1_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__EXT1_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__EXT1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT1_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__EXT1_NMI_EN__GET() gets NMI_SRC_EN.EXT1_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.EXT1_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.EXT1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT1_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__EXT1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__EXT1_NMI_EN__MODIFY() modifies NMI_SRC_EN.EXT1_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.EXT1_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT1_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__EXT1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT1_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__EXT1_NMI_EN__EXTRACT() extracts NMI_SRC_EN.EXT1_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.EXT1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT1_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__EXT1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.NMI_SRC_EN.OTP1_W_NMI_EN ---------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.OTP1_W_NMI_EN:

    Enable OTP1_W_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Pos                      5                                                                      /*!< Right-most bit position of OTP1_W_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Msk                      (0x00000001UL << SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Pos)                   /*!< Mask for OTP1_W_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Shift(v)                 (((v) << SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Pos) & SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Msk) /*!< Shift value 'v' into OTP1_W_NMI_EN and mask 'v' to fit it into OTP1_W_NMI_EN field */

/** SCU_NMI_SRC_EN__OTP1_W_NMI_EN__SET() sets NMI_SRC_EN.OTP1_W_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.OTP1_W_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.OTP1_W_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__OTP1_W_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__OTP1_W_NMI_EN__GET() gets NMI_SRC_EN.OTP1_W_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.OTP1_W_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.OTP1_W_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__OTP1_W_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__OTP1_W_NMI_EN__MODIFY() modifies NMI_SRC_EN.OTP1_W_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.OTP1_W_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__OTP1_W_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__OTP1_W_NMI_EN__EXTRACT() extracts NMI_SRC_EN.OTP1_W_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.OTP1_W_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__OTP1_W_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__OTP1_W_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- SCU.NMI_SRC_EN.PMBUS_NMI_EN ---------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.PMBUS_NMI_EN:

    Enable PMBUS_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__PMBUS_NMI_EN__Pos                       4                                                                      /*!< Right-most bit position of PMBUS_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__PMBUS_NMI_EN__Msk                       (0x00000001UL << SCU_NMI_SRC_EN__PMBUS_NMI_EN__Pos)                    /*!< Mask for PMBUS_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__PMBUS_NMI_EN__Shift(v)                  (((v) << SCU_NMI_SRC_EN__PMBUS_NMI_EN__Pos) & SCU_NMI_SRC_EN__PMBUS_NMI_EN__Msk) /*!< Shift value 'v' into PMBUS_NMI_EN and mask 'v' to fit it into PMBUS_NMI_EN field */

/** SCU_NMI_SRC_EN__PMBUS_NMI_EN__SET() sets NMI_SRC_EN.PMBUS_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.PMBUS_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.PMBUS_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__PMBUS_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__PMBUS_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__PMBUS_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__PMBUS_NMI_EN__GET() gets NMI_SRC_EN.PMBUS_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.PMBUS_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.PMBUS_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__PMBUS_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__PMBUS_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__PMBUS_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__PMBUS_NMI_EN__MODIFY() modifies NMI_SRC_EN.PMBUS_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.PMBUS_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__PMBUS_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__PMBUS_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__PMBUS_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__PMBUS_NMI_EN__EXTRACT() extracts NMI_SRC_EN.PMBUS_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.PMBUS_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__PMBUS_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__PMBUS_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__PMBUS_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.CSC_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.CSC_NMI_EN:

    Enable CSC_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__CSC_NMI_EN__Pos                         3                                                                      /*!< Right-most bit position of CSC_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__CSC_NMI_EN__Msk                         (0x00000001UL << SCU_NMI_SRC_EN__CSC_NMI_EN__Pos)                      /*!< Mask for CSC_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__CSC_NMI_EN__Shift(v)                    (((v) << SCU_NMI_SRC_EN__CSC_NMI_EN__Pos) & SCU_NMI_SRC_EN__CSC_NMI_EN__Msk) /*!< Shift value 'v' into CSC_NMI_EN and mask 'v' to fit it into CSC_NMI_EN field */

/** SCU_NMI_SRC_EN__CSC_NMI_EN__SET() sets NMI_SRC_EN.CSC_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.CSC_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.CSC_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__CSC_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__CSC_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__CSC_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__CSC_NMI_EN__GET() gets NMI_SRC_EN.CSC_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.CSC_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.CSC_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__CSC_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__CSC_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__CSC_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__CSC_NMI_EN__MODIFY() modifies NMI_SRC_EN.CSC_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.CSC_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__CSC_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__CSC_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__CSC_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__CSC_NMI_EN__EXTRACT() extracts NMI_SRC_EN.CSC_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.CSC_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__CSC_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__CSC_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__CSC_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.NMI_SRC_EN.INT_SVID1_NMI_EN -------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.INT_SVID1_NMI_EN:

    Enable INT_SVID1_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Pos                   2                                                                      /*!< Right-most bit position of INT_SVID1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Msk                   (0x00000001UL << SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Pos)                /*!< Mask for INT_SVID1_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Shift(v)              (((v) << SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Pos) & SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Msk) /*!< Shift value 'v' into INT_SVID1_NMI_EN and mask 'v' to fit it into INT_SVID1_NMI_EN field */

/** SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__SET() sets NMI_SRC_EN.INT_SVID1_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.INT_SVID1_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.INT_SVID1_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__GET() gets NMI_SRC_EN.INT_SVID1_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.INT_SVID1_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.INT_SVID1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__MODIFY() modifies NMI_SRC_EN.INT_SVID1_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.INT_SVID1_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__EXTRACT() extracts NMI_SRC_EN.INT_SVID1_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.INT_SVID1_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__INT_SVID1_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- SCU.NMI_SRC_EN.INT_SVID0_NMI_EN -------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.INT_SVID0_NMI_EN:

    Enable INT_SVID0_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Pos                   1                                                                      /*!< Right-most bit position of INT_SVID0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Msk                   (0x00000001UL << SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Pos)                /*!< Mask for INT_SVID0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Shift(v)              (((v) << SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Pos) & SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Msk) /*!< Shift value 'v' into INT_SVID0_NMI_EN and mask 'v' to fit it into INT_SVID0_NMI_EN field */

/** SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__SET() sets NMI_SRC_EN.INT_SVID0_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.INT_SVID0_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.INT_SVID0_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__GET() gets NMI_SRC_EN.INT_SVID0_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.INT_SVID0_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.INT_SVID0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__MODIFY() modifies NMI_SRC_EN.INT_SVID0_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.INT_SVID0_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__EXTRACT() extracts NMI_SRC_EN.INT_SVID0_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.INT_SVID0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__INT_SVID0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- SCU.NMI_SRC_EN.EXT0_NMI_EN ----------------------- */

/**
<pre>
  SCU.NMI_SRC_EN.EXT0_NMI_EN:

    Enable EXT0_IRQn as NMI

</pre> */

#define SCU_NMI_SRC_EN__EXT0_NMI_EN__Pos                        0                                                                      /*!< Right-most bit position of EXT0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT0_NMI_EN__Msk                        (0x00000001UL << SCU_NMI_SRC_EN__EXT0_NMI_EN__Pos)                     /*!< Mask for EXT0_NMI_EN in SCU.NMI_SRC_EN */
#define SCU_NMI_SRC_EN__EXT0_NMI_EN__Shift(v)                   (((v) << SCU_NMI_SRC_EN__EXT0_NMI_EN__Pos) & SCU_NMI_SRC_EN__EXT0_NMI_EN__Msk) /*!< Shift value 'v' into EXT0_NMI_EN and mask 'v' to fit it into EXT0_NMI_EN field */

/** SCU_NMI_SRC_EN__EXT0_NMI_EN__SET() sets NMI_SRC_EN.EXT0_NMI_EN to given value.
 *
 * When writing to NMI_SRC_EN.EXT0_NMI_EN, this is recommended to use.
 *
 * @param bf_value new value for NMI_SRC_EN.EXT0_NMI_EN
 */
__SCU_INLINE void SCU_NMI_SRC_EN__EXT0_NMI_EN__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & ~SCU_NMI_SRC_EN__EXT0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT0_NMI_EN__Shift((uint32_t)bf_value)));
    SCU_NMI_SRC_EN__SET(reg);
}

/** SCU_NMI_SRC_EN__EXT0_NMI_EN__GET() gets NMI_SRC_EN.EXT0_NMI_EN's current value.
 *
 * When reading from NMI_SRC_EN.EXT0_NMI_EN, this is recommended to use.
 *
 * @return current value of NMI_SRC_EN.EXT0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT0_NMI_EN__GET(void)
{
    uint32_t reg = SCU_NMI_SRC_EN__GET();
    reg = (reg & SCU_NMI_SRC_EN__EXT0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/** SCU_NMI_SRC_EN__EXT0_NMI_EN__MODIFY() modifies NMI_SRC_EN.EXT0_NMI_EN.
 *
 * This is recommended to use when setting more than one bitfield of SCU.NMI_SRC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @param bf_value new value for NMI_SRC_EN.EXT0_NMI_EN
 * @return new value of SCU.NMI_SRC_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT0_NMI_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_NMI_SRC_EN__EXT0_NMI_EN__Msk);
    reg = (reg | (SCU_NMI_SRC_EN__EXT0_NMI_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_NMI_SRC_EN__EXT0_NMI_EN__EXTRACT() extracts NMI_SRC_EN.EXT0_NMI_EN.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.NMI_SRC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.NMI_SRC_EN
 * @return current value of NMI_SRC_EN.EXT0_NMI_EN
 */
__SCU_INLINE uint32_t SCU_NMI_SRC_EN__EXT0_NMI_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_NMI_SRC_EN__EXT0_NMI_EN__Msk);
    reg = (reg >> SCU_NMI_SRC_EN__EXT0_NMI_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                            DRVR member of SCU_t                            */
/* -------------------------------------------------------------------------- */

/** __SCU_DRVR__ADDRESS returns the address of member DRVR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DRVR
 */
__SCU_INLINE uint32_t* __SCU_DRVR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__SCU_BASE_PTR() + (uint32_t)(offsetof(SCU_t, DRVR)));
}

/** SCU_DRVR__SET() sets DRVR to given value.
 *
 * When writing to DRVR, this is mandatory to use.
 *
 * @param value new value for DRVR
 */
__SCU_INLINE void SCU_DRVR__SET(uint32_t value)
{
    HAL_SET32(__SCU_DRVR__ADDRESS(), value);
}


/* ------------------------------ SCU.DRVR.DRV ------------------------------ */

/**
<pre>
  SCU.DRVR.DRV:

    1: lp2_st_ss is high

</pre> */

#define SCU_DRVR__DRV__Pos                                      0                                                                      /*!< Right-most bit position of DRV in SCU.DRVR */
#define SCU_DRVR__DRV__Msk                                      (0x000000FFUL << SCU_DRVR__DRV__Pos)                                   /*!< Mask for DRV in SCU.DRVR */
#define SCU_DRVR__DRV__Shift(v)                                 (((v) << SCU_DRVR__DRV__Pos) & SCU_DRVR__DRV__Msk)                     /*!< Shift value 'v' into DRV and mask 'v' to fit it into DRV field */

/** SCU_DRVR__DRV__SET() sets DRVR.DRV to given value.
 *
 * When writing to DRVR.DRV, this is recommended to use.
 *
 * @param bf_value new value for DRVR.DRV
 */
__SCU_INLINE void SCU_DRVR__DRV__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_DRVR__DRV__Shift((uint32_t)bf_value);
    SCU_DRVR__SET(reg);
}


/** SCU_DRVR__DRV__MODIFY() modifies DRVR.DRV.
 *
 * This is recommended to use when setting more than one bitfield of SCU.DRVR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.DRVR
 * @param bf_value new value for DRVR.DRV
 * @return new value of SCU.DRVR
 */
__SCU_INLINE uint32_t SCU_DRVR__DRV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_DRVR__DRV__Msk);
    reg = (reg | (SCU_DRVR__DRV__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_DRVR__DRV__EXTRACT() extracts DRVR.DRV.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.DRVR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.DRVR
 * @return current value of DRVR.DRV
 */
__SCU_INLINE uint32_t SCU_DRVR__DRV__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_DRVR__DRV__Msk);
    reg = (reg >> SCU_DRVR__DRV__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                            MONR member of SCU_t                            */
/* -------------------------------------------------------------------------- */

/** __SCU_MONR__ADDRESS returns the address of member MONR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MONR
 */
__SCU_INLINE uint32_t* __SCU_MONR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__SCU_BASE_PTR() + (uint32_t)(offsetof(SCU_t, MONR)));
}

/** SCU_MONR__GET() gets MONR's current value.
 *
 * When reading from MONR, this is mandatory to use.
 *
 * @return current value of MONR
 */
__SCU_INLINE uint32_t SCU_MONR__GET(void)
{
    return HAL_GET32(__SCU_MONR__ADDRESS());
}

/* -------------------------- SCU.MONR.CPUSENSTAT -------------------------- */

/**
<pre>
  SCU.MONR.CPUSENSTAT:

    1: CPUS_EN is high

</pre> */

#define SCU_MONR__CPUSENSTAT__Pos                               8                                                                      /*!< Right-most bit position of CPUSENSTAT in SCU.MONR */
#define SCU_MONR__CPUSENSTAT__Msk                               (0x00000001UL << SCU_MONR__CPUSENSTAT__Pos)                            /*!< Mask for CPUSENSTAT in SCU.MONR */
#define SCU_MONR__CPUSENSTAT__Shift(v)                          (((v) << SCU_MONR__CPUSENSTAT__Pos) & SCU_MONR__CPUSENSTAT__Msk)       /*!< Shift value 'v' into CPUSENSTAT and mask 'v' to fit it into CPUSENSTAT field */

/** SCU_MONR__CPUSENSTAT__GET() gets MONR.CPUSENSTAT's current value.
 *
 * When reading from MONR.CPUSENSTAT, this is recommended to use.
 *
 * @return current value of MONR.CPUSENSTAT
 */
__SCU_INLINE uint32_t SCU_MONR__CPUSENSTAT__GET(void)
{
    uint32_t reg = SCU_MONR__GET();
    reg = (reg & SCU_MONR__CPUSENSTAT__Msk);
    reg = (reg >> SCU_MONR__CPUSENSTAT__Pos);
    return (uint32_t)reg;
}

/** SCU_MONR__CPUSENSTAT__EXTRACT() extracts MONR.CPUSENSTAT.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.MONR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.MONR
 * @return current value of MONR.CPUSENSTAT
 */
__SCU_INLINE uint32_t SCU_MONR__CPUSENSTAT__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_MONR__CPUSENSTAT__Msk);
    reg = (reg >> SCU_MONR__CPUSENSTAT__Pos);
    return (uint32_t)reg;
}

/* ------------------------------ SCU.MONR.MON ------------------------------ */

/**
<pre>
  SCU.MONR.MON:

    1: st_test is high

</pre> */

#define SCU_MONR__MON__Pos                                      0                                                                      /*!< Right-most bit position of MON in SCU.MONR */
#define SCU_MONR__MON__Msk                                      (0x000000FFUL << SCU_MONR__MON__Pos)                                   /*!< Mask for MON in SCU.MONR */
#define SCU_MONR__MON__Shift(v)                                 (((v) << SCU_MONR__MON__Pos) & SCU_MONR__MON__Msk)                     /*!< Shift value 'v' into MON and mask 'v' to fit it into MON field */

/** SCU_MONR__MON__GET() gets MONR.MON's current value.
 *
 * When reading from MONR.MON, this is recommended to use.
 *
 * @return current value of MONR.MON
 */
__SCU_INLINE uint32_t SCU_MONR__MON__GET(void)
{
    uint32_t reg = SCU_MONR__GET();
    reg = (reg & SCU_MONR__MON__Msk);
    reg = (reg >> SCU_MONR__MON__Pos);
    return (uint32_t)reg;
}

/** SCU_MONR__MON__EXTRACT() extracts MONR.MON.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.MONR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.MONR
 * @return current value of MONR.MON
 */
__SCU_INLINE uint32_t SCU_MONR__MON__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_MONR__MON__Msk);
    reg = (reg >> SCU_MONR__MON__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          SPARE_FF member of SCU_t                          */
/* -------------------------------------------------------------------------- */

/** __SCU_SPARE_FF__ADDRESS returns the address of member SPARE_FF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of SPARE_FF
 */
__SCU_INLINE uint32_t* __SCU_SPARE_FF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__SCU_BASE_PTR() + (uint32_t)(offsetof(SCU_t, SPARE_FF)));
}

/** SCU_SPARE_FF__SET() sets SPARE_FF to given value.
 *
 * When writing to SPARE_FF, this is mandatory to use.
 *
 * @param value new value for SPARE_FF
 */
__SCU_INLINE void SCU_SPARE_FF__SET(uint32_t value)
{
    HAL_SET32(__SCU_SPARE_FF__ADDRESS(), value);
}

/** SCU_SPARE_FF__GET() gets SPARE_FF's current value.
 *
 * When reading from SPARE_FF, this is mandatory to use.
 *
 * @return current value of SPARE_FF
 */
__SCU_INLINE uint32_t SCU_SPARE_FF__GET(void)
{
    return HAL_GET32(__SCU_SPARE_FF__ADDRESS());
}

/* ------------------------- SCU.SPARE_FF.SPARE_FF ------------------------- */

/**
<pre>
  SCU.SPARE_FF.SPARE_FF:

    Spare Register

</pre> */

#define SCU_SPARE_FF__SPARE_FF__Pos                             0                                                                      /*!< Right-most bit position of SPARE_FF in SCU.SPARE_FF */
#define SCU_SPARE_FF__SPARE_FF__Msk                             (0xFFFFFFFFUL << SCU_SPARE_FF__SPARE_FF__Pos)                          /*!< Mask for SPARE_FF in SCU.SPARE_FF */
#define SCU_SPARE_FF__SPARE_FF__Shift(v)                        (((v) << SCU_SPARE_FF__SPARE_FF__Pos) & SCU_SPARE_FF__SPARE_FF__Msk)   /*!< Shift value 'v' into SPARE_FF and mask 'v' to fit it into SPARE_FF field */

/** SCU_SPARE_FF__SPARE_FF__SET() sets SPARE_FF.SPARE_FF to given value.
 *
 * When writing to SPARE_FF.SPARE_FF, this is recommended to use.
 *
 * @param bf_value new value for SPARE_FF.SPARE_FF
 */
__SCU_INLINE void SCU_SPARE_FF__SPARE_FF__SET(uint32_t bf_value)
{
    uint32_t reg = SCU_SPARE_FF__GET();
    reg = (reg & ~SCU_SPARE_FF__SPARE_FF__Msk);
    reg = (reg | (SCU_SPARE_FF__SPARE_FF__Shift((uint32_t)bf_value)));
    SCU_SPARE_FF__SET(reg);
}

/** SCU_SPARE_FF__SPARE_FF__GET() gets SPARE_FF.SPARE_FF's current value.
 *
 * When reading from SPARE_FF.SPARE_FF, this is recommended to use.
 *
 * @return current value of SPARE_FF.SPARE_FF
 */
__SCU_INLINE uint32_t SCU_SPARE_FF__SPARE_FF__GET(void)
{
    uint32_t reg = SCU_SPARE_FF__GET();
    reg = (reg & SCU_SPARE_FF__SPARE_FF__Msk);
    reg = (reg >> SCU_SPARE_FF__SPARE_FF__Pos);
    return (uint32_t)reg;
}

/** SCU_SPARE_FF__SPARE_FF__MODIFY() modifies SPARE_FF.SPARE_FF.
 *
 * This is recommended to use when setting more than one bitfield of SCU.SPARE_FF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of SCU.SPARE_FF
 * @param bf_value new value for SPARE_FF.SPARE_FF
 * @return new value of SCU.SPARE_FF
 */
__SCU_INLINE uint32_t SCU_SPARE_FF__SPARE_FF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~SCU_SPARE_FF__SPARE_FF__Msk);
    reg = (reg | (SCU_SPARE_FF__SPARE_FF__Shift((uint32_t)bf_value)));
    return reg;
}

/** SCU_SPARE_FF__SPARE_FF__EXTRACT() extracts SPARE_FF.SPARE_FF.
 *
 * This is recommended to use when extracting more than one bitfield from SCU.SPARE_FF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of SCU.SPARE_FF
 * @return current value of SPARE_FF.SPARE_FF
 */
__SCU_INLINE uint32_t SCU_SPARE_FF__SPARE_FF__EXTRACT(uint32_t reg)
{
    reg = (reg & SCU_SPARE_FF__SPARE_FF__Msk);
    reg = (reg >> SCU_SPARE_FF__SPARE_FF__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group scu block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_SCU_H_ */
