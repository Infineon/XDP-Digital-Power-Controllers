/**
 * @file     shasta_hal_gpio.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_GPIO_H_
#define _SHASTA_HAL_GPIO_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup gpio
 * @{
 */

#if defined ( __CC_ARM )
#define __GPIO_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __GPIO_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __GPIO_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __GPIO_INLINE  static inline
#endif

/** register file of the gpio block.
 */
typedef struct _GPIO_s
{
    volatile        uint32_t        GPIODATA[256]               ; /*!< (@0x00000000) Data Register */
    volatile        uint32_t        GPIODIR                     ; /*!< (@0x00000400) Data Direction Register */
    volatile        uint32_t        GPIOIS                      ; /*!< (@0x00000404) Interrupt Sense Register */
    volatile        uint32_t        GPIOIBE                     ; /*!< (@0x00000408) Interrupt Both-Edges Register */
    volatile        uint32_t        GPIOIEV                     ; /*!< (@0x0000040C) Interrupt Event Register */
    volatile        uint32_t        GPIOIE                      ; /*!< (@0x00000410) Interrupt Mask Register */
    volatile        uint32_t        GPIORIS                     ; /*!< (@0x00000414) Raw Interrupt Status Register */
    volatile        uint32_t        GPIOMIS                     ; /*!< (@0x00000418) Masked Interrupt Status Register */
    volatile        uint32_t        GPIOIC                      ; /*!< (@0x0000041C) Interrupt Clear Register */
    volatile        uint32_t        GPIOAFSEL                   ; /*!< (@0x00000420) Mode Control Select Register */
    volatile        uint8_t         REGMEMGAP0[3004]            ; /*!< (@0x00000424) gap in address space */
    volatile        uint32_t        GPIOPERIPHID0               ; /*!< (@0x00000FE0) GPIO Identification Register 0 */
    volatile        uint32_t        GPIOPERIPHID1               ; /*!< (@0x00000FE4) GPIO Identification Register 1 */
    volatile        uint32_t        GPIOPERIPHID2               ; /*!< (@0x00000FE8) GPIO Identification Register 2 */
    volatile        uint32_t        GPIOPERIPHID3               ; /*!< (@0x00000FEC) GPIO Identification Register 3 */
    volatile        uint32_t        GPIOPCELLID0                ; /*!< (@0x00000FF0) PrimeCell Identification Register 0 */
    volatile        uint32_t        GPIOPCELLID1                ; /*!< (@0x00000FF4) PrimeCell Identification Register 1 */
    volatile        uint32_t        GPIOPCELLID2                ; /*!< (@0x00000FF8) PrimeCell Identification Register 2 */
    volatile        uint32_t        GPIOPCELLID3                ; /*!< (@0x00000FFC) PrimeCell Identification Register 3 */
} GPIO_t;

/** enumeration of GPIO.GPIODATA member index
 */
/*lint -parent(uint32_t, gpio_gpiodata_idx_t) -strong(AJX)*/
typedef enum _gpio_gpiodata_idx_e
{
    gpio_gpiodata_0 = 0u,    //!< Index 0
    gpio_gpiodata_1 = 1u,    //!< Index 1
    gpio_gpiodata_2 = 2u,    //!< Index 2
    gpio_gpiodata_3 = 3u,    //!< Index 3
    gpio_gpiodata_4 = 4u,    //!< Index 4
    gpio_gpiodata_5 = 5u,    //!< Index 5
    gpio_gpiodata_6 = 6u,    //!< Index 6
    gpio_gpiodata_7 = 7u,    //!< Index 7
    gpio_gpiodata_8 = 8u,    //!< Index 8
    gpio_gpiodata_9 = 9u,    //!< Index 9
    gpio_gpiodata_10 = 10u,    //!< Index 10
    gpio_gpiodata_11 = 11u,    //!< Index 11
    gpio_gpiodata_12 = 12u,    //!< Index 12
    gpio_gpiodata_13 = 13u,    //!< Index 13
    gpio_gpiodata_14 = 14u,    //!< Index 14
    gpio_gpiodata_15 = 15u,    //!< Index 15
    gpio_gpiodata_16 = 16u,    //!< Index 16
    gpio_gpiodata_17 = 17u,    //!< Index 17
    gpio_gpiodata_18 = 18u,    //!< Index 18
    gpio_gpiodata_19 = 19u,    //!< Index 19
    gpio_gpiodata_20 = 20u,    //!< Index 20
    gpio_gpiodata_21 = 21u,    //!< Index 21
    gpio_gpiodata_22 = 22u,    //!< Index 22
    gpio_gpiodata_23 = 23u,    //!< Index 23
    gpio_gpiodata_24 = 24u,    //!< Index 24
    gpio_gpiodata_25 = 25u,    //!< Index 25
    gpio_gpiodata_26 = 26u,    //!< Index 26
    gpio_gpiodata_27 = 27u,    //!< Index 27
    gpio_gpiodata_28 = 28u,    //!< Index 28
    gpio_gpiodata_29 = 29u,    //!< Index 29
    gpio_gpiodata_30 = 30u,    //!< Index 30
    gpio_gpiodata_31 = 31u,    //!< Index 31
    gpio_gpiodata_32 = 32u,    //!< Index 32
    gpio_gpiodata_33 = 33u,    //!< Index 33
    gpio_gpiodata_34 = 34u,    //!< Index 34
    gpio_gpiodata_35 = 35u,    //!< Index 35
    gpio_gpiodata_36 = 36u,    //!< Index 36
    gpio_gpiodata_37 = 37u,    //!< Index 37
    gpio_gpiodata_38 = 38u,    //!< Index 38
    gpio_gpiodata_39 = 39u,    //!< Index 39
    gpio_gpiodata_40 = 40u,    //!< Index 40
    gpio_gpiodata_41 = 41u,    //!< Index 41
    gpio_gpiodata_42 = 42u,    //!< Index 42
    gpio_gpiodata_43 = 43u,    //!< Index 43
    gpio_gpiodata_44 = 44u,    //!< Index 44
    gpio_gpiodata_45 = 45u,    //!< Index 45
    gpio_gpiodata_46 = 46u,    //!< Index 46
    gpio_gpiodata_47 = 47u,    //!< Index 47
    gpio_gpiodata_48 = 48u,    //!< Index 48
    gpio_gpiodata_49 = 49u,    //!< Index 49
    gpio_gpiodata_50 = 50u,    //!< Index 50
    gpio_gpiodata_51 = 51u,    //!< Index 51
    gpio_gpiodata_52 = 52u,    //!< Index 52
    gpio_gpiodata_53 = 53u,    //!< Index 53
    gpio_gpiodata_54 = 54u,    //!< Index 54
    gpio_gpiodata_55 = 55u,    //!< Index 55
    gpio_gpiodata_56 = 56u,    //!< Index 56
    gpio_gpiodata_57 = 57u,    //!< Index 57
    gpio_gpiodata_58 = 58u,    //!< Index 58
    gpio_gpiodata_59 = 59u,    //!< Index 59
    gpio_gpiodata_60 = 60u,    //!< Index 60
    gpio_gpiodata_61 = 61u,    //!< Index 61
    gpio_gpiodata_62 = 62u,    //!< Index 62
    gpio_gpiodata_63 = 63u,    //!< Index 63
    gpio_gpiodata_64 = 64u,    //!< Index 64
    gpio_gpiodata_65 = 65u,    //!< Index 65
    gpio_gpiodata_66 = 66u,    //!< Index 66
    gpio_gpiodata_67 = 67u,    //!< Index 67
    gpio_gpiodata_68 = 68u,    //!< Index 68
    gpio_gpiodata_69 = 69u,    //!< Index 69
    gpio_gpiodata_70 = 70u,    //!< Index 70
    gpio_gpiodata_71 = 71u,    //!< Index 71
    gpio_gpiodata_72 = 72u,    //!< Index 72
    gpio_gpiodata_73 = 73u,    //!< Index 73
    gpio_gpiodata_74 = 74u,    //!< Index 74
    gpio_gpiodata_75 = 75u,    //!< Index 75
    gpio_gpiodata_76 = 76u,    //!< Index 76
    gpio_gpiodata_77 = 77u,    //!< Index 77
    gpio_gpiodata_78 = 78u,    //!< Index 78
    gpio_gpiodata_79 = 79u,    //!< Index 79
    gpio_gpiodata_80 = 80u,    //!< Index 80
    gpio_gpiodata_81 = 81u,    //!< Index 81
    gpio_gpiodata_82 = 82u,    //!< Index 82
    gpio_gpiodata_83 = 83u,    //!< Index 83
    gpio_gpiodata_84 = 84u,    //!< Index 84
    gpio_gpiodata_85 = 85u,    //!< Index 85
    gpio_gpiodata_86 = 86u,    //!< Index 86
    gpio_gpiodata_87 = 87u,    //!< Index 87
    gpio_gpiodata_88 = 88u,    //!< Index 88
    gpio_gpiodata_89 = 89u,    //!< Index 89
    gpio_gpiodata_90 = 90u,    //!< Index 90
    gpio_gpiodata_91 = 91u,    //!< Index 91
    gpio_gpiodata_92 = 92u,    //!< Index 92
    gpio_gpiodata_93 = 93u,    //!< Index 93
    gpio_gpiodata_94 = 94u,    //!< Index 94
    gpio_gpiodata_95 = 95u,    //!< Index 95
    gpio_gpiodata_96 = 96u,    //!< Index 96
    gpio_gpiodata_97 = 97u,    //!< Index 97
    gpio_gpiodata_98 = 98u,    //!< Index 98
    gpio_gpiodata_99 = 99u,    //!< Index 99
    gpio_gpiodata_100 = 100u,    //!< Index 100
    gpio_gpiodata_101 = 101u,    //!< Index 101
    gpio_gpiodata_102 = 102u,    //!< Index 102
    gpio_gpiodata_103 = 103u,    //!< Index 103
    gpio_gpiodata_104 = 104u,    //!< Index 104
    gpio_gpiodata_105 = 105u,    //!< Index 105
    gpio_gpiodata_106 = 106u,    //!< Index 106
    gpio_gpiodata_107 = 107u,    //!< Index 107
    gpio_gpiodata_108 = 108u,    //!< Index 108
    gpio_gpiodata_109 = 109u,    //!< Index 109
    gpio_gpiodata_110 = 110u,    //!< Index 110
    gpio_gpiodata_111 = 111u,    //!< Index 111
    gpio_gpiodata_112 = 112u,    //!< Index 112
    gpio_gpiodata_113 = 113u,    //!< Index 113
    gpio_gpiodata_114 = 114u,    //!< Index 114
    gpio_gpiodata_115 = 115u,    //!< Index 115
    gpio_gpiodata_116 = 116u,    //!< Index 116
    gpio_gpiodata_117 = 117u,    //!< Index 117
    gpio_gpiodata_118 = 118u,    //!< Index 118
    gpio_gpiodata_119 = 119u,    //!< Index 119
    gpio_gpiodata_120 = 120u,    //!< Index 120
    gpio_gpiodata_121 = 121u,    //!< Index 121
    gpio_gpiodata_122 = 122u,    //!< Index 122
    gpio_gpiodata_123 = 123u,    //!< Index 123
    gpio_gpiodata_124 = 124u,    //!< Index 124
    gpio_gpiodata_125 = 125u,    //!< Index 125
    gpio_gpiodata_126 = 126u,    //!< Index 126
    gpio_gpiodata_127 = 127u,    //!< Index 127
    gpio_gpiodata_128 = 128u,    //!< Index 128
    gpio_gpiodata_129 = 129u,    //!< Index 129
    gpio_gpiodata_130 = 130u,    //!< Index 130
    gpio_gpiodata_131 = 131u,    //!< Index 131
    gpio_gpiodata_132 = 132u,    //!< Index 132
    gpio_gpiodata_133 = 133u,    //!< Index 133
    gpio_gpiodata_134 = 134u,    //!< Index 134
    gpio_gpiodata_135 = 135u,    //!< Index 135
    gpio_gpiodata_136 = 136u,    //!< Index 136
    gpio_gpiodata_137 = 137u,    //!< Index 137
    gpio_gpiodata_138 = 138u,    //!< Index 138
    gpio_gpiodata_139 = 139u,    //!< Index 139
    gpio_gpiodata_140 = 140u,    //!< Index 140
    gpio_gpiodata_141 = 141u,    //!< Index 141
    gpio_gpiodata_142 = 142u,    //!< Index 142
    gpio_gpiodata_143 = 143u,    //!< Index 143
    gpio_gpiodata_144 = 144u,    //!< Index 144
    gpio_gpiodata_145 = 145u,    //!< Index 145
    gpio_gpiodata_146 = 146u,    //!< Index 146
    gpio_gpiodata_147 = 147u,    //!< Index 147
    gpio_gpiodata_148 = 148u,    //!< Index 148
    gpio_gpiodata_149 = 149u,    //!< Index 149
    gpio_gpiodata_150 = 150u,    //!< Index 150
    gpio_gpiodata_151 = 151u,    //!< Index 151
    gpio_gpiodata_152 = 152u,    //!< Index 152
    gpio_gpiodata_153 = 153u,    //!< Index 153
    gpio_gpiodata_154 = 154u,    //!< Index 154
    gpio_gpiodata_155 = 155u,    //!< Index 155
    gpio_gpiodata_156 = 156u,    //!< Index 156
    gpio_gpiodata_157 = 157u,    //!< Index 157
    gpio_gpiodata_158 = 158u,    //!< Index 158
    gpio_gpiodata_159 = 159u,    //!< Index 159
    gpio_gpiodata_160 = 160u,    //!< Index 160
    gpio_gpiodata_161 = 161u,    //!< Index 161
    gpio_gpiodata_162 = 162u,    //!< Index 162
    gpio_gpiodata_163 = 163u,    //!< Index 163
    gpio_gpiodata_164 = 164u,    //!< Index 164
    gpio_gpiodata_165 = 165u,    //!< Index 165
    gpio_gpiodata_166 = 166u,    //!< Index 166
    gpio_gpiodata_167 = 167u,    //!< Index 167
    gpio_gpiodata_168 = 168u,    //!< Index 168
    gpio_gpiodata_169 = 169u,    //!< Index 169
    gpio_gpiodata_170 = 170u,    //!< Index 170
    gpio_gpiodata_171 = 171u,    //!< Index 171
    gpio_gpiodata_172 = 172u,    //!< Index 172
    gpio_gpiodata_173 = 173u,    //!< Index 173
    gpio_gpiodata_174 = 174u,    //!< Index 174
    gpio_gpiodata_175 = 175u,    //!< Index 175
    gpio_gpiodata_176 = 176u,    //!< Index 176
    gpio_gpiodata_177 = 177u,    //!< Index 177
    gpio_gpiodata_178 = 178u,    //!< Index 178
    gpio_gpiodata_179 = 179u,    //!< Index 179
    gpio_gpiodata_180 = 180u,    //!< Index 180
    gpio_gpiodata_181 = 181u,    //!< Index 181
    gpio_gpiodata_182 = 182u,    //!< Index 182
    gpio_gpiodata_183 = 183u,    //!< Index 183
    gpio_gpiodata_184 = 184u,    //!< Index 184
    gpio_gpiodata_185 = 185u,    //!< Index 185
    gpio_gpiodata_186 = 186u,    //!< Index 186
    gpio_gpiodata_187 = 187u,    //!< Index 187
    gpio_gpiodata_188 = 188u,    //!< Index 188
    gpio_gpiodata_189 = 189u,    //!< Index 189
    gpio_gpiodata_190 = 190u,    //!< Index 190
    gpio_gpiodata_191 = 191u,    //!< Index 191
    gpio_gpiodata_192 = 192u,    //!< Index 192
    gpio_gpiodata_193 = 193u,    //!< Index 193
    gpio_gpiodata_194 = 194u,    //!< Index 194
    gpio_gpiodata_195 = 195u,    //!< Index 195
    gpio_gpiodata_196 = 196u,    //!< Index 196
    gpio_gpiodata_197 = 197u,    //!< Index 197
    gpio_gpiodata_198 = 198u,    //!< Index 198
    gpio_gpiodata_199 = 199u,    //!< Index 199
    gpio_gpiodata_200 = 200u,    //!< Index 200
    gpio_gpiodata_201 = 201u,    //!< Index 201
    gpio_gpiodata_202 = 202u,    //!< Index 202
    gpio_gpiodata_203 = 203u,    //!< Index 203
    gpio_gpiodata_204 = 204u,    //!< Index 204
    gpio_gpiodata_205 = 205u,    //!< Index 205
    gpio_gpiodata_206 = 206u,    //!< Index 206
    gpio_gpiodata_207 = 207u,    //!< Index 207
    gpio_gpiodata_208 = 208u,    //!< Index 208
    gpio_gpiodata_209 = 209u,    //!< Index 209
    gpio_gpiodata_210 = 210u,    //!< Index 210
    gpio_gpiodata_211 = 211u,    //!< Index 211
    gpio_gpiodata_212 = 212u,    //!< Index 212
    gpio_gpiodata_213 = 213u,    //!< Index 213
    gpio_gpiodata_214 = 214u,    //!< Index 214
    gpio_gpiodata_215 = 215u,    //!< Index 215
    gpio_gpiodata_216 = 216u,    //!< Index 216
    gpio_gpiodata_217 = 217u,    //!< Index 217
    gpio_gpiodata_218 = 218u,    //!< Index 218
    gpio_gpiodata_219 = 219u,    //!< Index 219
    gpio_gpiodata_220 = 220u,    //!< Index 220
    gpio_gpiodata_221 = 221u,    //!< Index 221
    gpio_gpiodata_222 = 222u,    //!< Index 222
    gpio_gpiodata_223 = 223u,    //!< Index 223
    gpio_gpiodata_224 = 224u,    //!< Index 224
    gpio_gpiodata_225 = 225u,    //!< Index 225
    gpio_gpiodata_226 = 226u,    //!< Index 226
    gpio_gpiodata_227 = 227u,    //!< Index 227
    gpio_gpiodata_228 = 228u,    //!< Index 228
    gpio_gpiodata_229 = 229u,    //!< Index 229
    gpio_gpiodata_230 = 230u,    //!< Index 230
    gpio_gpiodata_231 = 231u,    //!< Index 231
    gpio_gpiodata_232 = 232u,    //!< Index 232
    gpio_gpiodata_233 = 233u,    //!< Index 233
    gpio_gpiodata_234 = 234u,    //!< Index 234
    gpio_gpiodata_235 = 235u,    //!< Index 235
    gpio_gpiodata_236 = 236u,    //!< Index 236
    gpio_gpiodata_237 = 237u,    //!< Index 237
    gpio_gpiodata_238 = 238u,    //!< Index 238
    gpio_gpiodata_239 = 239u,    //!< Index 239
    gpio_gpiodata_240 = 240u,    //!< Index 240
    gpio_gpiodata_241 = 241u,    //!< Index 241
    gpio_gpiodata_242 = 242u,    //!< Index 242
    gpio_gpiodata_243 = 243u,    //!< Index 243
    gpio_gpiodata_244 = 244u,    //!< Index 244
    gpio_gpiodata_245 = 245u,    //!< Index 245
    gpio_gpiodata_246 = 246u,    //!< Index 246
    gpio_gpiodata_247 = 247u,    //!< Index 247
    gpio_gpiodata_248 = 248u,    //!< Index 248
    gpio_gpiodata_249 = 249u,    //!< Index 249
    gpio_gpiodata_250 = 250u,    //!< Index 250
    gpio_gpiodata_251 = 251u,    //!< Index 251
    gpio_gpiodata_252 = 252u,    //!< Index 252
    gpio_gpiodata_253 = 253u,    //!< Index 253
    gpio_gpiodata_254 = 254u,    //!< Index 254
    gpio_gpiodata_255 = 255u     //!< Index 255
} gpio_gpiodata_idx_t;


/** enumeration of implemented gpio blocks
 */
typedef enum _gpio_idx_e
{
    GPIO_0 = 0u,    //!< GPIO_0
    GPIO_1 = 1u     //!< GPIO_1
} gpio_idx_t;

#define GPIO_BASE (0x60040000u)                                                          /*!< gpio base address */
#define GPIO_STRIDE (0x00010000u)                                                         

/** __GPIO_BASE_PTR returns the base address of the peripheral.
 *
 * @param idp index of peripheral
 * @return base address of peripheral's instance
 */
__GPIO_INLINE uint32_t* __GPIO_BASE_PTR(gpio_idx_t idp)
{
    return (uint32_t*)(GPIO_BASE + (uint32_t)((uint32_t)idp * GPIO_STRIDE));
}


/* -------------------------------------------------------------------------- */
/*                         GPIODATA member of GPIO_t                         */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIODATA__ADDRESS returns the address of member GPIODATA.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @param ida index in GPIODATA array
 * @return address of GPIODATA
 */
__GPIO_INLINE uint32_t* __GPIO_GPIODATA__ADDRESS(gpio_idx_t idp, gpio_gpiodata_idx_t ida)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIODATA)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** GPIO_GPIODATA__SET() sets GPIODATA to given value.
 *
 * When writing to GPIODATA, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param ida index in GPIODATA array
 * @param value new value for GPIODATA
 */
__GPIO_INLINE void GPIO_GPIODATA__SET(gpio_idx_t idp, gpio_gpiodata_idx_t ida, uint32_t value)
{
    HAL_SET32(__GPIO_GPIODATA__ADDRESS(idp, ida), value);
}

/** GPIO_GPIODATA__GET() gets GPIODATA's current value.
 *
 * When reading from GPIODATA, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param ida index in GPIODATA array
 * @return current value of GPIODATA
 */
__GPIO_INLINE uint32_t GPIO_GPIODATA__GET(gpio_idx_t idp, gpio_gpiodata_idx_t ida)
{
    return HAL_GET32(__GPIO_GPIODATA__ADDRESS(idp, ida));
}

/* --------------------------- GPIO.GPIODATA.DATA --------------------------- */

/**
<pre>
  GPIO.GPIODATA.DATA:

    Input / Output Data

</pre> */

#define GPIO_GPIODATA__DATA__Pos                                0                                                                      /*!< Right-most bit position of DATA in GPIO.GPIODATA */
#define GPIO_GPIODATA__DATA__Msk                                (0x000000FFUL << GPIO_GPIODATA__DATA__Pos)                             /*!< Mask for DATA in GPIO.GPIODATA */
#define GPIO_GPIODATA__DATA__Shift(v)                           (((v) << GPIO_GPIODATA__DATA__Pos) & GPIO_GPIODATA__DATA__Msk)         /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** GPIO_GPIODATA__DATA__SET() sets GPIODATA.DATA to given value.
 *
 * When writing to GPIODATA.DATA, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param ida index in GPIODATA array
 * @param bf_value new value for GPIODATA.DATA
 */
__GPIO_INLINE void GPIO_GPIODATA__DATA__SET(gpio_idx_t idp, gpio_gpiodata_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = GPIO_GPIODATA__GET(idp, ida);
    reg = (reg & ~GPIO_GPIODATA__DATA__Msk);
    reg = (reg | (GPIO_GPIODATA__DATA__Shift((uint32_t)bf_value)));
    GPIO_GPIODATA__SET(idp, ida, reg);
}

/** GPIO_GPIODATA__DATA__GET() gets GPIODATA.DATA's current value.
 *
 * When reading from GPIODATA.DATA, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param ida index in GPIODATA array
 * @return current value of GPIODATA.DATA
 */
__GPIO_INLINE uint32_t GPIO_GPIODATA__DATA__GET(gpio_idx_t idp, gpio_gpiodata_idx_t ida)
{
    uint32_t reg = GPIO_GPIODATA__GET(idp, ida);
    reg = (reg & GPIO_GPIODATA__DATA__Msk);
    reg = (reg >> GPIO_GPIODATA__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          GPIODIR member of GPIO_t                          */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIODIR__ADDRESS returns the address of member GPIODIR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIODIR
 */
__GPIO_INLINE uint32_t* __GPIO_GPIODIR__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIODIR)));
}

/** GPIO_GPIODIR__SET() sets GPIODIR to given value.
 *
 * When writing to GPIODIR, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for GPIODIR
 */
__GPIO_INLINE void GPIO_GPIODIR__SET(gpio_idx_t idp, uint32_t value)
{
    HAL_SET32(__GPIO_GPIODIR__ADDRESS(idp), value);
}

/** GPIO_GPIODIR__GET() gets GPIODIR's current value.
 *
 * When reading from GPIODIR, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIODIR
 */
__GPIO_INLINE uint32_t GPIO_GPIODIR__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIODIR__ADDRESS(idp));
}

/* ---------------------------- GPIO.GPIODIR.DIR ---------------------------- */

/**
<pre>
  GPIO.GPIODIR.DIR:

    Data Direction Control

</pre> */

/*lint -parent(uint32_t, gpio_gpiodir__dir_t) -strong(AJX)*/
typedef enum gpio_gpiodir__dir_e                                                                                                       /*!< Data Direction Control */
{
    gpio_gpiodir__dir_s0 = 0u,                                                                                                         /*!<      Pin direction is input */
    gpio_gpiodir__dir_s1 = 1u                                                                                                          /*!<      Pin direction is output */
} gpio_gpiodir__dir_t;

#define GPIO_GPIODIR__DIR__Pos                                  0                                                                      /*!< Right-most bit position of DIR in GPIO.GPIODIR */
#define GPIO_GPIODIR__DIR__Msk                                  (0x000000FFUL << GPIO_GPIODIR__DIR__Pos)                               /*!< Mask for DIR in GPIO.GPIODIR */
#define GPIO_GPIODIR__DIR__Shift(v)                             (((v) << GPIO_GPIODIR__DIR__Pos) & GPIO_GPIODIR__DIR__Msk)             /*!< Shift value 'v' into DIR and mask 'v' to fit it into DIR field */

/** GPIO_GPIODIR__DIR__SET() sets GPIODIR.DIR to given value.
 *
 * When writing to GPIODIR.DIR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for GPIODIR.DIR
 */
__GPIO_INLINE void GPIO_GPIODIR__DIR__SET(gpio_idx_t idp, gpio_gpiodir__dir_t bf_value)
{
    uint32_t reg = GPIO_GPIODIR__GET(idp);
    reg = (reg & ~GPIO_GPIODIR__DIR__Msk);
    reg = (reg | (GPIO_GPIODIR__DIR__Shift((uint32_t)bf_value)));
    GPIO_GPIODIR__SET(idp, reg);
}

/** GPIO_GPIODIR__DIR__GET() gets GPIODIR.DIR's current value.
 *
 * When reading from GPIODIR.DIR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIODIR.DIR
 */
__GPIO_INLINE gpio_gpiodir__dir_t GPIO_GPIODIR__DIR__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIODIR__GET(idp);
    reg = (reg & GPIO_GPIODIR__DIR__Msk);
    reg = (reg >> GPIO_GPIODIR__DIR__Pos);
    return (gpio_gpiodir__dir_t)reg;
}

/** GPIO_GPIODIR__DIR__MODIFY() modifies GPIODIR.DIR.
 *
 * This is recommended to use when setting more than one bitfield of GPIO.GPIODIR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of GPIO.GPIODIR
 * @param bf_value new value for GPIODIR.DIR
 * @return new value of GPIO.GPIODIR
 */
__GPIO_INLINE uint32_t GPIO_GPIODIR__DIR__MODIFY(uint32_t reg, gpio_gpiodir__dir_t bf_value)
{
    reg = (reg & ~GPIO_GPIODIR__DIR__Msk);
    reg = (reg | (GPIO_GPIODIR__DIR__Shift((uint32_t)bf_value)));
    return reg;
}

/** GPIO_GPIODIR__DIR__EXTRACT() extracts GPIODIR.DIR.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIODIR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIODIR
 * @return current value of GPIODIR.DIR
 */
__GPIO_INLINE gpio_gpiodir__dir_t GPIO_GPIODIR__DIR__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIODIR__DIR__Msk);
    reg = (reg >> GPIO_GPIODIR__DIR__Pos);
    return (gpio_gpiodir__dir_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          GPIOIS member of GPIO_t                          */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOIS__ADDRESS returns the address of member GPIOIS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOIS
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOIS__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOIS)));
}

/** GPIO_GPIOIS__SET() sets GPIOIS to given value.
 *
 * When writing to GPIOIS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for GPIOIS
 */
__GPIO_INLINE void GPIO_GPIOIS__SET(gpio_idx_t idp, uint32_t value)
{
    HAL_SET32(__GPIO_GPIOIS__ADDRESS(idp), value);
}

/** GPIO_GPIOIS__GET() gets GPIOIS's current value.
 *
 * When reading from GPIOIS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOIS
 */
__GPIO_INLINE uint32_t GPIO_GPIOIS__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOIS__ADDRESS(idp));
}

/* -------------------------- GPIO.GPIOIS.INTSENSE -------------------------- */

/**
<pre>
  GPIO.GPIOIS.INTSENSE:

    Interrupt Sense Control

</pre> */

/*lint -parent(uint32_t, gpio_gpiois__intsense_t) -strong(AJX)*/
typedef enum gpio_gpiois__intsense_e                                                                                                   /*!< Interrupt Sense Control */
{
    gpio_gpiois__intsense_s0 = 0u,                                                                                                     /*!<      Edge on corresponding pin is detected */
    gpio_gpiois__intsense_s1 = 1u                                                                                                      /*!<      Level on corresponding pin is detected */
} gpio_gpiois__intsense_t;

#define GPIO_GPIOIS__INTSENSE__Pos                              0                                                                      /*!< Right-most bit position of INTSENSE in GPIO.GPIOIS */
#define GPIO_GPIOIS__INTSENSE__Msk                              (0x000000FFUL << GPIO_GPIOIS__INTSENSE__Pos)                           /*!< Mask for INTSENSE in GPIO.GPIOIS */
#define GPIO_GPIOIS__INTSENSE__Shift(v)                         (((v) << GPIO_GPIOIS__INTSENSE__Pos) & GPIO_GPIOIS__INTSENSE__Msk)     /*!< Shift value 'v' into INTSENSE and mask 'v' to fit it into INTSENSE field */

/** GPIO_GPIOIS__INTSENSE__SET() sets GPIOIS.INTSENSE to given value.
 *
 * When writing to GPIOIS.INTSENSE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for GPIOIS.INTSENSE
 */
__GPIO_INLINE void GPIO_GPIOIS__INTSENSE__SET(gpio_idx_t idp, gpio_gpiois__intsense_t bf_value)
{
    uint32_t reg = GPIO_GPIOIS__GET(idp);
    reg = (reg & ~GPIO_GPIOIS__INTSENSE__Msk);
    reg = (reg | (GPIO_GPIOIS__INTSENSE__Shift((uint32_t)bf_value)));
    GPIO_GPIOIS__SET(idp, reg);
}

/** GPIO_GPIOIS__INTSENSE__GET() gets GPIOIS.INTSENSE's current value.
 *
 * When reading from GPIOIS.INTSENSE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOIS.INTSENSE
 */
__GPIO_INLINE gpio_gpiois__intsense_t GPIO_GPIOIS__INTSENSE__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOIS__GET(idp);
    reg = (reg & GPIO_GPIOIS__INTSENSE__Msk);
    reg = (reg >> GPIO_GPIOIS__INTSENSE__Pos);
    return (gpio_gpiois__intsense_t)reg;
}

/** GPIO_GPIOIS__INTSENSE__MODIFY() modifies GPIOIS.INTSENSE.
 *
 * This is recommended to use when setting more than one bitfield of GPIO.GPIOIS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of GPIO.GPIOIS
 * @param bf_value new value for GPIOIS.INTSENSE
 * @return new value of GPIO.GPIOIS
 */
__GPIO_INLINE uint32_t GPIO_GPIOIS__INTSENSE__MODIFY(uint32_t reg, gpio_gpiois__intsense_t bf_value)
{
    reg = (reg & ~GPIO_GPIOIS__INTSENSE__Msk);
    reg = (reg | (GPIO_GPIOIS__INTSENSE__Shift((uint32_t)bf_value)));
    return reg;
}

/** GPIO_GPIOIS__INTSENSE__EXTRACT() extracts GPIOIS.INTSENSE.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOIS
 * @return current value of GPIOIS.INTSENSE
 */
__GPIO_INLINE gpio_gpiois__intsense_t GPIO_GPIOIS__INTSENSE__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOIS__INTSENSE__Msk);
    reg = (reg >> GPIO_GPIOIS__INTSENSE__Pos);
    return (gpio_gpiois__intsense_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          GPIOIBE member of GPIO_t                          */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOIBE__ADDRESS returns the address of member GPIOIBE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOIBE
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOIBE__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOIBE)));
}

/** GPIO_GPIOIBE__SET() sets GPIOIBE to given value.
 *
 * When writing to GPIOIBE, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for GPIOIBE
 */
__GPIO_INLINE void GPIO_GPIOIBE__SET(gpio_idx_t idp, uint32_t value)
{
    HAL_SET32(__GPIO_GPIOIBE__ADDRESS(idp), value);
}

/** GPIO_GPIOIBE__GET() gets GPIOIBE's current value.
 *
 * When reading from GPIOIBE, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOIBE
 */
__GPIO_INLINE uint32_t GPIO_GPIOIBE__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOIBE__ADDRESS(idp));
}

/* -------------------------- GPIO.GPIOIBE.INTEDGE -------------------------- */

/**
<pre>
  GPIO.GPIOIBE.INTEDGE:

    Interrupt Both-Edges Control

</pre> */

#define GPIO_GPIOIBE__INTEDGE__Pos                              0                                                                      /*!< Right-most bit position of INTEDGE in GPIO.GPIOIBE */
#define GPIO_GPIOIBE__INTEDGE__Msk                              (0x000000FFUL << GPIO_GPIOIBE__INTEDGE__Pos)                           /*!< Mask for INTEDGE in GPIO.GPIOIBE */
#define GPIO_GPIOIBE__INTEDGE__Shift(v)                         (((v) << GPIO_GPIOIBE__INTEDGE__Pos) & GPIO_GPIOIBE__INTEDGE__Msk)     /*!< Shift value 'v' into INTEDGE and mask 'v' to fit it into INTEDGE field */

/** GPIO_GPIOIBE__INTEDGE__SET() sets GPIOIBE.INTEDGE to given value.
 *
 * When writing to GPIOIBE.INTEDGE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for GPIOIBE.INTEDGE
 */
__GPIO_INLINE void GPIO_GPIOIBE__INTEDGE__SET(gpio_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = GPIO_GPIOIBE__GET(idp);
    reg = (reg & ~GPIO_GPIOIBE__INTEDGE__Msk);
    reg = (reg | (GPIO_GPIOIBE__INTEDGE__Shift((uint32_t)bf_value)));
    GPIO_GPIOIBE__SET(idp, reg);
}

/** GPIO_GPIOIBE__INTEDGE__GET() gets GPIOIBE.INTEDGE's current value.
 *
 * When reading from GPIOIBE.INTEDGE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOIBE.INTEDGE
 */
__GPIO_INLINE uint32_t GPIO_GPIOIBE__INTEDGE__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOIBE__GET(idp);
    reg = (reg & GPIO_GPIOIBE__INTEDGE__Msk);
    reg = (reg >> GPIO_GPIOIBE__INTEDGE__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOIBE__INTEDGE__MODIFY() modifies GPIOIBE.INTEDGE.
 *
 * This is recommended to use when setting more than one bitfield of GPIO.GPIOIBE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of GPIO.GPIOIBE
 * @param bf_value new value for GPIOIBE.INTEDGE
 * @return new value of GPIO.GPIOIBE
 */
__GPIO_INLINE uint32_t GPIO_GPIOIBE__INTEDGE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~GPIO_GPIOIBE__INTEDGE__Msk);
    reg = (reg | (GPIO_GPIOIBE__INTEDGE__Shift((uint32_t)bf_value)));
    return reg;
}

/** GPIO_GPIOIBE__INTEDGE__EXTRACT() extracts GPIOIBE.INTEDGE.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOIBE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOIBE
 * @return current value of GPIOIBE.INTEDGE
 */
__GPIO_INLINE uint32_t GPIO_GPIOIBE__INTEDGE__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOIBE__INTEDGE__Msk);
    reg = (reg >> GPIO_GPIOIBE__INTEDGE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          GPIOIEV member of GPIO_t                          */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOIEV__ADDRESS returns the address of member GPIOIEV.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOIEV
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOIEV__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOIEV)));
}

/** GPIO_GPIOIEV__SET() sets GPIOIEV to given value.
 *
 * When writing to GPIOIEV, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for GPIOIEV
 */
__GPIO_INLINE void GPIO_GPIOIEV__SET(gpio_idx_t idp, uint32_t value)
{
    HAL_SET32(__GPIO_GPIOIEV__ADDRESS(idp), value);
}

/** GPIO_GPIOIEV__GET() gets GPIOIEV's current value.
 *
 * When reading from GPIOIEV, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOIEV
 */
__GPIO_INLINE uint32_t GPIO_GPIOIEV__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOIEV__ADDRESS(idp));
}

/* ------------------------- GPIO.GPIOIEV.INTEVENT ------------------------- */

/**
<pre>
  GPIO.GPIOIEV.INTEVENT:

    Interrupt Event Control

</pre> */

#define GPIO_GPIOIEV__INTEVENT__Pos                             0                                                                      /*!< Right-most bit position of INTEVENT in GPIO.GPIOIEV */
#define GPIO_GPIOIEV__INTEVENT__Msk                             (0x000000FFUL << GPIO_GPIOIEV__INTEVENT__Pos)                          /*!< Mask for INTEVENT in GPIO.GPIOIEV */
#define GPIO_GPIOIEV__INTEVENT__Shift(v)                        (((v) << GPIO_GPIOIEV__INTEVENT__Pos) & GPIO_GPIOIEV__INTEVENT__Msk)   /*!< Shift value 'v' into INTEVENT and mask 'v' to fit it into INTEVENT field */

/** GPIO_GPIOIEV__INTEVENT__SET() sets GPIOIEV.INTEVENT to given value.
 *
 * When writing to GPIOIEV.INTEVENT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for GPIOIEV.INTEVENT
 */
__GPIO_INLINE void GPIO_GPIOIEV__INTEVENT__SET(gpio_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = GPIO_GPIOIEV__GET(idp);
    reg = (reg & ~GPIO_GPIOIEV__INTEVENT__Msk);
    reg = (reg | (GPIO_GPIOIEV__INTEVENT__Shift((uint32_t)bf_value)));
    GPIO_GPIOIEV__SET(idp, reg);
}

/** GPIO_GPIOIEV__INTEVENT__GET() gets GPIOIEV.INTEVENT's current value.
 *
 * When reading from GPIOIEV.INTEVENT, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOIEV.INTEVENT
 */
__GPIO_INLINE uint32_t GPIO_GPIOIEV__INTEVENT__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOIEV__GET(idp);
    reg = (reg & GPIO_GPIOIEV__INTEVENT__Msk);
    reg = (reg >> GPIO_GPIOIEV__INTEVENT__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOIEV__INTEVENT__MODIFY() modifies GPIOIEV.INTEVENT.
 *
 * This is recommended to use when setting more than one bitfield of GPIO.GPIOIEV.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of GPIO.GPIOIEV
 * @param bf_value new value for GPIOIEV.INTEVENT
 * @return new value of GPIO.GPIOIEV
 */
__GPIO_INLINE uint32_t GPIO_GPIOIEV__INTEVENT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~GPIO_GPIOIEV__INTEVENT__Msk);
    reg = (reg | (GPIO_GPIOIEV__INTEVENT__Shift((uint32_t)bf_value)));
    return reg;
}

/** GPIO_GPIOIEV__INTEVENT__EXTRACT() extracts GPIOIEV.INTEVENT.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOIEV.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOIEV
 * @return current value of GPIOIEV.INTEVENT
 */
__GPIO_INLINE uint32_t GPIO_GPIOIEV__INTEVENT__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOIEV__INTEVENT__Msk);
    reg = (reg >> GPIO_GPIOIEV__INTEVENT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          GPIOIE member of GPIO_t                          */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOIE__ADDRESS returns the address of member GPIOIE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOIE
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOIE__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOIE)));
}

/** GPIO_GPIOIE__SET() sets GPIOIE to given value.
 *
 * When writing to GPIOIE, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for GPIOIE
 */
__GPIO_INLINE void GPIO_GPIOIE__SET(gpio_idx_t idp, uint32_t value)
{
    HAL_SET32(__GPIO_GPIOIE__ADDRESS(idp), value);
}

/** GPIO_GPIOIE__GET() gets GPIOIE's current value.
 *
 * When reading from GPIOIE, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOIE
 */
__GPIO_INLINE uint32_t GPIO_GPIOIE__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOIE__ADDRESS(idp));
}

/* --------------------------- GPIO.GPIOIE.INTENA --------------------------- */

/**
<pre>
  GPIO.GPIOIE.INTENA:

    Interrupt Mask Control

</pre> */

/*lint -parent(uint32_t, gpio_gpioie__intena_t) -strong(AJX)*/
typedef enum gpio_gpioie__intena_e                                                                                                     /*!< Interrupt Mask Control */
{
    gpio_gpioie__intena_s0 = 0u,                                                                                                       /*!<      Corresponding pin interrupt is masked */
    gpio_gpioie__intena_s1 = 1u                                                                                                        /*!<      Corresponding pin interrupt is NOT masked */
} gpio_gpioie__intena_t;

#define GPIO_GPIOIE__INTENA__Pos                                0                                                                      /*!< Right-most bit position of INTENA in GPIO.GPIOIE */
#define GPIO_GPIOIE__INTENA__Msk                                (0x000000FFUL << GPIO_GPIOIE__INTENA__Pos)                             /*!< Mask for INTENA in GPIO.GPIOIE */
#define GPIO_GPIOIE__INTENA__Shift(v)                           (((v) << GPIO_GPIOIE__INTENA__Pos) & GPIO_GPIOIE__INTENA__Msk)         /*!< Shift value 'v' into INTENA and mask 'v' to fit it into INTENA field */

/** GPIO_GPIOIE__INTENA__SET() sets GPIOIE.INTENA to given value.
 *
 * When writing to GPIOIE.INTENA, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for GPIOIE.INTENA
 */
__GPIO_INLINE void GPIO_GPIOIE__INTENA__SET(gpio_idx_t idp, gpio_gpioie__intena_t bf_value)
{
    uint32_t reg = GPIO_GPIOIE__GET(idp);
    reg = (reg & ~GPIO_GPIOIE__INTENA__Msk);
    reg = (reg | (GPIO_GPIOIE__INTENA__Shift((uint32_t)bf_value)));
    GPIO_GPIOIE__SET(idp, reg);
}

/** GPIO_GPIOIE__INTENA__GET() gets GPIOIE.INTENA's current value.
 *
 * When reading from GPIOIE.INTENA, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOIE.INTENA
 */
__GPIO_INLINE gpio_gpioie__intena_t GPIO_GPIOIE__INTENA__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOIE__GET(idp);
    reg = (reg & GPIO_GPIOIE__INTENA__Msk);
    reg = (reg >> GPIO_GPIOIE__INTENA__Pos);
    return (gpio_gpioie__intena_t)reg;
}

/** GPIO_GPIOIE__INTENA__MODIFY() modifies GPIOIE.INTENA.
 *
 * This is recommended to use when setting more than one bitfield of GPIO.GPIOIE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of GPIO.GPIOIE
 * @param bf_value new value for GPIOIE.INTENA
 * @return new value of GPIO.GPIOIE
 */
__GPIO_INLINE uint32_t GPIO_GPIOIE__INTENA__MODIFY(uint32_t reg, gpio_gpioie__intena_t bf_value)
{
    reg = (reg & ~GPIO_GPIOIE__INTENA__Msk);
    reg = (reg | (GPIO_GPIOIE__INTENA__Shift((uint32_t)bf_value)));
    return reg;
}

/** GPIO_GPIOIE__INTENA__EXTRACT() extracts GPIOIE.INTENA.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOIE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOIE
 * @return current value of GPIOIE.INTENA
 */
__GPIO_INLINE gpio_gpioie__intena_t GPIO_GPIOIE__INTENA__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOIE__INTENA__Msk);
    reg = (reg >> GPIO_GPIOIE__INTENA__Pos);
    return (gpio_gpioie__intena_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          GPIORIS member of GPIO_t                          */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIORIS__ADDRESS returns the address of member GPIORIS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIORIS
 */
__GPIO_INLINE uint32_t* __GPIO_GPIORIS__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIORIS)));
}

/** GPIO_GPIORIS__GET() gets GPIORIS's current value.
 *
 * When reading from GPIORIS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIORIS
 */
__GPIO_INLINE uint32_t GPIO_GPIORIS__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIORIS__ADDRESS(idp));
}

/* -------------------------- GPIO.GPIORIS.INTRAW -------------------------- */

/**
<pre>
  GPIO.GPIORIS.INTRAW:

    Raw Interrupt Status

</pre> */

/*lint -parent(uint32_t, gpio_gpioris__intraw_t) -strong(AJX)*/
typedef enum gpio_gpioris__intraw_e                                                                                                    /*!< Raw Interrupt Status */
{
    gpio_gpioris__intraw_s0 = 0u,                                                                                                      /*!<      Requirements not met */
    gpio_gpioris__intraw_s1 = 1u                                                                                                       /*!<      Requirements met by corresponding pin */
} gpio_gpioris__intraw_t;

#define GPIO_GPIORIS__INTRAW__Pos                               0                                                                      /*!< Right-most bit position of INTRAW in GPIO.GPIORIS */
#define GPIO_GPIORIS__INTRAW__Msk                               (0x000000FFUL << GPIO_GPIORIS__INTRAW__Pos)                            /*!< Mask for INTRAW in GPIO.GPIORIS */
#define GPIO_GPIORIS__INTRAW__Shift(v)                          (((v) << GPIO_GPIORIS__INTRAW__Pos) & GPIO_GPIORIS__INTRAW__Msk)       /*!< Shift value 'v' into INTRAW and mask 'v' to fit it into INTRAW field */

/** GPIO_GPIORIS__INTRAW__GET() gets GPIORIS.INTRAW's current value.
 *
 * When reading from GPIORIS.INTRAW, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIORIS.INTRAW
 */
__GPIO_INLINE gpio_gpioris__intraw_t GPIO_GPIORIS__INTRAW__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIORIS__GET(idp);
    reg = (reg & GPIO_GPIORIS__INTRAW__Msk);
    reg = (reg >> GPIO_GPIORIS__INTRAW__Pos);
    return (gpio_gpioris__intraw_t)reg;
}

/** GPIO_GPIORIS__INTRAW__EXTRACT() extracts GPIORIS.INTRAW.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIORIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIORIS
 * @return current value of GPIORIS.INTRAW
 */
__GPIO_INLINE gpio_gpioris__intraw_t GPIO_GPIORIS__INTRAW__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIORIS__INTRAW__Msk);
    reg = (reg >> GPIO_GPIORIS__INTRAW__Pos);
    return (gpio_gpioris__intraw_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          GPIOMIS member of GPIO_t                          */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOMIS__ADDRESS returns the address of member GPIOMIS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOMIS
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOMIS__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOMIS)));
}

/** GPIO_GPIOMIS__GET() gets GPIOMIS's current value.
 *
 * When reading from GPIOMIS, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOMIS
 */
__GPIO_INLINE uint32_t GPIO_GPIOMIS__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOMIS__ADDRESS(idp));
}

/* -------------------------- GPIO.GPIOMIS.INTMASK -------------------------- */

/**
<pre>
  GPIO.GPIOMIS.INTMASK:

    Masked Interrupt Status

</pre> */

/*lint -parent(uint32_t, gpio_gpiomis__intmask_t) -strong(AJX)*/
typedef enum gpio_gpiomis__intmask_e                                                                                                   /*!< Masked Interrupt Status */
{
    gpio_gpiomis__intmask_s0 = 0u,                                                                                                     /*!<      GPIO line interrupt not active */
    gpio_gpiomis__intmask_s1 = 1u                                                                                                      /*!<      GPIO line asserting interrupt */
} gpio_gpiomis__intmask_t;

#define GPIO_GPIOMIS__INTMASK__Pos                              0                                                                      /*!< Right-most bit position of INTMASK in GPIO.GPIOMIS */
#define GPIO_GPIOMIS__INTMASK__Msk                              (0x000000FFUL << GPIO_GPIOMIS__INTMASK__Pos)                           /*!< Mask for INTMASK in GPIO.GPIOMIS */
#define GPIO_GPIOMIS__INTMASK__Shift(v)                         (((v) << GPIO_GPIOMIS__INTMASK__Pos) & GPIO_GPIOMIS__INTMASK__Msk)     /*!< Shift value 'v' into INTMASK and mask 'v' to fit it into INTMASK field */

/** GPIO_GPIOMIS__INTMASK__GET() gets GPIOMIS.INTMASK's current value.
 *
 * When reading from GPIOMIS.INTMASK, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOMIS.INTMASK
 */
__GPIO_INLINE gpio_gpiomis__intmask_t GPIO_GPIOMIS__INTMASK__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOMIS__GET(idp);
    reg = (reg & GPIO_GPIOMIS__INTMASK__Msk);
    reg = (reg >> GPIO_GPIOMIS__INTMASK__Pos);
    return (gpio_gpiomis__intmask_t)reg;
}

/** GPIO_GPIOMIS__INTMASK__EXTRACT() extracts GPIOMIS.INTMASK.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOMIS
 * @return current value of GPIOMIS.INTMASK
 */
__GPIO_INLINE gpio_gpiomis__intmask_t GPIO_GPIOMIS__INTMASK__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOMIS__INTMASK__Msk);
    reg = (reg >> GPIO_GPIOMIS__INTMASK__Pos);
    return (gpio_gpiomis__intmask_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          GPIOIC member of GPIO_t                          */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOIC__ADDRESS returns the address of member GPIOIC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOIC
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOIC__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOIC)));
}

/** GPIO_GPIOIC__SET() sets GPIOIC to given value.
 *
 * When writing to GPIOIC, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for GPIOIC
 */
__GPIO_INLINE void GPIO_GPIOIC__SET(gpio_idx_t idp, uint32_t value)
{
    HAL_SET32(__GPIO_GPIOIC__ADDRESS(idp), value);
}

/** GPIO_GPIOIC__GET() gets GPIOIC's current value.
 *
 * When reading from GPIOIC, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOIC
 */
__GPIO_INLINE uint32_t GPIO_GPIOIC__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOIC__ADDRESS(idp));
}

/* --------------------------- GPIO.GPIOIC.INTCLR --------------------------- */

/**
<pre>
  GPIO.GPIOIC.INTCLR:

    Interrupt Clear Control

</pre> */

/*lint -parent(uint32_t, gpio_gpioic__intclr_t) -strong(AJX)*/
typedef enum gpio_gpioic__intclr_e                                                                                                     /*!< Interrupt Clear Control */
{
    gpio_gpioic__intclr_s0 = 0u,                                                                                                       /*!<      No effect */
    gpio_gpioic__intclr_s1 = 1u                                                                                                        /*!<      Clears edge detection logic */
} gpio_gpioic__intclr_t;

#define GPIO_GPIOIC__INTCLR__Pos                                0                                                                      /*!< Right-most bit position of INTCLR in GPIO.GPIOIC */
#define GPIO_GPIOIC__INTCLR__Msk                                (0x000000FFUL << GPIO_GPIOIC__INTCLR__Pos)                             /*!< Mask for INTCLR in GPIO.GPIOIC */
#define GPIO_GPIOIC__INTCLR__Shift(v)                           (((v) << GPIO_GPIOIC__INTCLR__Pos) & GPIO_GPIOIC__INTCLR__Msk)         /*!< Shift value 'v' into INTCLR and mask 'v' to fit it into INTCLR field */

/** GPIO_GPIOIC__INTCLR__SET() sets GPIOIC.INTCLR to given value.
 *
 * When writing to GPIOIC.INTCLR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for GPIOIC.INTCLR
 */
__GPIO_INLINE void GPIO_GPIOIC__INTCLR__SET(gpio_idx_t idp, gpio_gpioic__intclr_t bf_value)
{
    uint32_t reg = GPIO_GPIOIC__INTCLR__Shift((uint32_t)bf_value);
    GPIO_GPIOIC__SET(idp, reg);
}


/** GPIO_GPIOIC__INTCLR__MODIFY() modifies GPIOIC.INTCLR.
 *
 * This is recommended to use when setting more than one bitfield of GPIO.GPIOIC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of GPIO.GPIOIC
 * @param bf_value new value for GPIOIC.INTCLR
 * @return new value of GPIO.GPIOIC
 */
__GPIO_INLINE uint32_t GPIO_GPIOIC__INTCLR__MODIFY(uint32_t reg, gpio_gpioic__intclr_t bf_value)
{
    reg = (reg & ~GPIO_GPIOIC__INTCLR__Msk);
    reg = (reg | (GPIO_GPIOIC__INTCLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** GPIO_GPIOIC__INTCLR__EXTRACT() extracts GPIOIC.INTCLR.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOIC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOIC
 * @return current value of GPIOIC.INTCLR
 */
__GPIO_INLINE gpio_gpioic__intclr_t GPIO_GPIOIC__INTCLR__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOIC__INTCLR__Msk);
    reg = (reg >> GPIO_GPIOIC__INTCLR__Pos);
    return (gpio_gpioic__intclr_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         GPIOAFSEL member of GPIO_t                         */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOAFSEL__ADDRESS returns the address of member GPIOAFSEL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOAFSEL
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOAFSEL__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOAFSEL)));
}

/** GPIO_GPIOAFSEL__SET() sets GPIOAFSEL to given value.
 *
 * When writing to GPIOAFSEL, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for GPIOAFSEL
 */
__GPIO_INLINE void GPIO_GPIOAFSEL__SET(gpio_idx_t idp, uint32_t value)
{
    HAL_SET32(__GPIO_GPIOAFSEL__ADDRESS(idp), value);
}

/** GPIO_GPIOAFSEL__GET() gets GPIOAFSEL's current value.
 *
 * When reading from GPIOAFSEL, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOAFSEL
 */
__GPIO_INLINE uint32_t GPIO_GPIOAFSEL__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOAFSEL__ADDRESS(idp));
}

/* -------------------------- GPIO.GPIOAFSEL.MSEL -------------------------- */

/**
<pre>
  GPIO.GPIOAFSEL.MSEL:

    Mode Control Select

</pre> */

/*lint -parent(uint32_t, gpio_gpioafsel__msel_t) -strong(AJX)*/
typedef enum gpio_gpioafsel__msel_e                                                                                                    /*!< Mode Control Select */
{
    gpio_gpioafsel__msel_s0 = 0u,                                                                                                      /*!<      Enables software control mode */
    gpio_gpioafsel__msel_s1 = 1u                                                                                                       /*!<      Enables hardware control mode */
} gpio_gpioafsel__msel_t;

#define GPIO_GPIOAFSEL__MSEL__Pos                               0                                                                      /*!< Right-most bit position of MSEL in GPIO.GPIOAFSEL */
#define GPIO_GPIOAFSEL__MSEL__Msk                               (0x000000FFUL << GPIO_GPIOAFSEL__MSEL__Pos)                            /*!< Mask for MSEL in GPIO.GPIOAFSEL */
#define GPIO_GPIOAFSEL__MSEL__Shift(v)                          (((v) << GPIO_GPIOAFSEL__MSEL__Pos) & GPIO_GPIOAFSEL__MSEL__Msk)       /*!< Shift value 'v' into MSEL and mask 'v' to fit it into MSEL field */

/** GPIO_GPIOAFSEL__MSEL__SET() sets GPIOAFSEL.MSEL to given value.
 *
 * When writing to GPIOAFSEL.MSEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for GPIOAFSEL.MSEL
 */
__GPIO_INLINE void GPIO_GPIOAFSEL__MSEL__SET(gpio_idx_t idp, gpio_gpioafsel__msel_t bf_value)
{
    uint32_t reg = GPIO_GPIOAFSEL__GET(idp);
    reg = (reg & ~GPIO_GPIOAFSEL__MSEL__Msk);
    reg = (reg | (GPIO_GPIOAFSEL__MSEL__Shift((uint32_t)bf_value)));
    GPIO_GPIOAFSEL__SET(idp, reg);
}

/** GPIO_GPIOAFSEL__MSEL__GET() gets GPIOAFSEL.MSEL's current value.
 *
 * When reading from GPIOAFSEL.MSEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOAFSEL.MSEL
 */
__GPIO_INLINE gpio_gpioafsel__msel_t GPIO_GPIOAFSEL__MSEL__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOAFSEL__GET(idp);
    reg = (reg & GPIO_GPIOAFSEL__MSEL__Msk);
    reg = (reg >> GPIO_GPIOAFSEL__MSEL__Pos);
    return (gpio_gpioafsel__msel_t)reg;
}

/** GPIO_GPIOAFSEL__MSEL__MODIFY() modifies GPIOAFSEL.MSEL.
 *
 * This is recommended to use when setting more than one bitfield of GPIO.GPIOAFSEL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of GPIO.GPIOAFSEL
 * @param bf_value new value for GPIOAFSEL.MSEL
 * @return new value of GPIO.GPIOAFSEL
 */
__GPIO_INLINE uint32_t GPIO_GPIOAFSEL__MSEL__MODIFY(uint32_t reg, gpio_gpioafsel__msel_t bf_value)
{
    reg = (reg & ~GPIO_GPIOAFSEL__MSEL__Msk);
    reg = (reg | (GPIO_GPIOAFSEL__MSEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** GPIO_GPIOAFSEL__MSEL__EXTRACT() extracts GPIOAFSEL.MSEL.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOAFSEL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOAFSEL
 * @return current value of GPIOAFSEL.MSEL
 */
__GPIO_INLINE gpio_gpioafsel__msel_t GPIO_GPIOAFSEL__MSEL__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOAFSEL__MSEL__Msk);
    reg = (reg >> GPIO_GPIOAFSEL__MSEL__Pos);
    return (gpio_gpioafsel__msel_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       GPIOPERIPHID0 member of GPIO_t                       */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOPERIPHID0__ADDRESS returns the address of member GPIOPERIPHID0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOPERIPHID0
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOPERIPHID0__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOPERIPHID0)));
}

/** GPIO_GPIOPERIPHID0__GET() gets GPIOPERIPHID0's current value.
 *
 * When reading from GPIOPERIPHID0, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPERIPHID0
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID0__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOPERIPHID0__ADDRESS(idp));
}

/* --------------------- GPIO.GPIOPERIPHID0.PARTNUMBER0 --------------------- */

/**
<pre>
  GPIO.GPIOPERIPHID0.PARTNUMBER0:

    Part Number 0

</pre> */

#define GPIO_GPIOPERIPHID0__PARTNUMBER0__Pos                    0                                                                      /*!< Right-most bit position of PartNumber0 in GPIO.GPIOPERIPHID0 */
#define GPIO_GPIOPERIPHID0__PARTNUMBER0__Msk                    (0x000000FFUL << GPIO_GPIOPERIPHID0__PARTNUMBER0__Pos)                 /*!< Mask for PartNumber0 in GPIO.GPIOPERIPHID0 */
#define GPIO_GPIOPERIPHID0__PARTNUMBER0__Shift(v)               (((v) << GPIO_GPIOPERIPHID0__PARTNUMBER0__Pos) & GPIO_GPIOPERIPHID0__PARTNUMBER0__Msk) /*!< Shift value 'v' into PartNumber0 and mask 'v' to fit it into PartNumber0 field */

/** GPIO_GPIOPERIPHID0__PARTNUMBER0__GET() gets GPIOPERIPHID0.PARTNUMBER0's current value.
 *
 * When reading from GPIOPERIPHID0.PARTNUMBER0, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPERIPHID0.PARTNUMBER0
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID0__PARTNUMBER0__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOPERIPHID0__GET(idp);
    reg = (reg & GPIO_GPIOPERIPHID0__PARTNUMBER0__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID0__PARTNUMBER0__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOPERIPHID0__PARTNUMBER0__EXTRACT() extracts GPIOPERIPHID0.PARTNUMBER0.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOPERIPHID0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOPERIPHID0
 * @return current value of GPIOPERIPHID0.PARTNUMBER0
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID0__PARTNUMBER0__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOPERIPHID0__PARTNUMBER0__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID0__PARTNUMBER0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       GPIOPERIPHID1 member of GPIO_t                       */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOPERIPHID1__ADDRESS returns the address of member GPIOPERIPHID1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOPERIPHID1
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOPERIPHID1__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOPERIPHID1)));
}

/** GPIO_GPIOPERIPHID1__GET() gets GPIOPERIPHID1's current value.
 *
 * When reading from GPIOPERIPHID1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPERIPHID1
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID1__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOPERIPHID1__ADDRESS(idp));
}

/* ---------------------- GPIO.GPIOPERIPHID1.DESIGNER0 ---------------------- */

/**
<pre>
  GPIO.GPIOPERIPHID1.DESIGNER0:

    Designer Number 0

</pre> */

#define GPIO_GPIOPERIPHID1__DESIGNER0__Pos                      4                                                                      /*!< Right-most bit position of Designer0 in GPIO.GPIOPERIPHID1 */
#define GPIO_GPIOPERIPHID1__DESIGNER0__Msk                      (0x0000000FUL << GPIO_GPIOPERIPHID1__DESIGNER0__Pos)                   /*!< Mask for Designer0 in GPIO.GPIOPERIPHID1 */
#define GPIO_GPIOPERIPHID1__DESIGNER0__Shift(v)                 (((v) << GPIO_GPIOPERIPHID1__DESIGNER0__Pos) & GPIO_GPIOPERIPHID1__DESIGNER0__Msk) /*!< Shift value 'v' into Designer0 and mask 'v' to fit it into Designer0 field */

/** GPIO_GPIOPERIPHID1__DESIGNER0__GET() gets GPIOPERIPHID1.DESIGNER0's current value.
 *
 * When reading from GPIOPERIPHID1.DESIGNER0, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPERIPHID1.DESIGNER0
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID1__DESIGNER0__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOPERIPHID1__GET(idp);
    reg = (reg & GPIO_GPIOPERIPHID1__DESIGNER0__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID1__DESIGNER0__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOPERIPHID1__DESIGNER0__EXTRACT() extracts GPIOPERIPHID1.DESIGNER0.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOPERIPHID1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOPERIPHID1
 * @return current value of GPIOPERIPHID1.DESIGNER0
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID1__DESIGNER0__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOPERIPHID1__DESIGNER0__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID1__DESIGNER0__Pos);
    return (uint32_t)reg;
}

/* --------------------- GPIO.GPIOPERIPHID1.PARTNUMBER1 --------------------- */

/**
<pre>
  GPIO.GPIOPERIPHID1.PARTNUMBER1:

    Part Number 1

</pre> */

#define GPIO_GPIOPERIPHID1__PARTNUMBER1__Pos                    0                                                                      /*!< Right-most bit position of PartNumber1 in GPIO.GPIOPERIPHID1 */
#define GPIO_GPIOPERIPHID1__PARTNUMBER1__Msk                    (0x0000000FUL << GPIO_GPIOPERIPHID1__PARTNUMBER1__Pos)                 /*!< Mask for PartNumber1 in GPIO.GPIOPERIPHID1 */
#define GPIO_GPIOPERIPHID1__PARTNUMBER1__Shift(v)               (((v) << GPIO_GPIOPERIPHID1__PARTNUMBER1__Pos) & GPIO_GPIOPERIPHID1__PARTNUMBER1__Msk) /*!< Shift value 'v' into PartNumber1 and mask 'v' to fit it into PartNumber1 field */

/** GPIO_GPIOPERIPHID1__PARTNUMBER1__GET() gets GPIOPERIPHID1.PARTNUMBER1's current value.
 *
 * When reading from GPIOPERIPHID1.PARTNUMBER1, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPERIPHID1.PARTNUMBER1
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID1__PARTNUMBER1__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOPERIPHID1__GET(idp);
    reg = (reg & GPIO_GPIOPERIPHID1__PARTNUMBER1__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID1__PARTNUMBER1__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOPERIPHID1__PARTNUMBER1__EXTRACT() extracts GPIOPERIPHID1.PARTNUMBER1.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOPERIPHID1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOPERIPHID1
 * @return current value of GPIOPERIPHID1.PARTNUMBER1
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID1__PARTNUMBER1__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOPERIPHID1__PARTNUMBER1__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID1__PARTNUMBER1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       GPIOPERIPHID2 member of GPIO_t                       */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOPERIPHID2__ADDRESS returns the address of member GPIOPERIPHID2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOPERIPHID2
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOPERIPHID2__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOPERIPHID2)));
}

/** GPIO_GPIOPERIPHID2__GET() gets GPIOPERIPHID2's current value.
 *
 * When reading from GPIOPERIPHID2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPERIPHID2
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID2__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOPERIPHID2__ADDRESS(idp));
}

/* ---------------------- GPIO.GPIOPERIPHID2.REVISION ---------------------- */

/**
<pre>
  GPIO.GPIOPERIPHID2.REVISION:

    Revision Number

</pre> */

#define GPIO_GPIOPERIPHID2__REVISION__Pos                       4                                                                      /*!< Right-most bit position of Revision in GPIO.GPIOPERIPHID2 */
#define GPIO_GPIOPERIPHID2__REVISION__Msk                       (0x0000000FUL << GPIO_GPIOPERIPHID2__REVISION__Pos)                    /*!< Mask for Revision in GPIO.GPIOPERIPHID2 */
#define GPIO_GPIOPERIPHID2__REVISION__Shift(v)                  (((v) << GPIO_GPIOPERIPHID2__REVISION__Pos) & GPIO_GPIOPERIPHID2__REVISION__Msk) /*!< Shift value 'v' into Revision and mask 'v' to fit it into Revision field */

/** GPIO_GPIOPERIPHID2__REVISION__GET() gets GPIOPERIPHID2.REVISION's current value.
 *
 * When reading from GPIOPERIPHID2.REVISION, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPERIPHID2.REVISION
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID2__REVISION__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOPERIPHID2__GET(idp);
    reg = (reg & GPIO_GPIOPERIPHID2__REVISION__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID2__REVISION__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOPERIPHID2__REVISION__EXTRACT() extracts GPIOPERIPHID2.REVISION.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOPERIPHID2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOPERIPHID2
 * @return current value of GPIOPERIPHID2.REVISION
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID2__REVISION__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOPERIPHID2__REVISION__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID2__REVISION__Pos);
    return (uint32_t)reg;
}

/* ---------------------- GPIO.GPIOPERIPHID2.DESIGNER1 ---------------------- */

/**
<pre>
  GPIO.GPIOPERIPHID2.DESIGNER1:

    Designer Number 1

</pre> */

#define GPIO_GPIOPERIPHID2__DESIGNER1__Pos                      0                                                                      /*!< Right-most bit position of Designer1 in GPIO.GPIOPERIPHID2 */
#define GPIO_GPIOPERIPHID2__DESIGNER1__Msk                      (0x0000000FUL << GPIO_GPIOPERIPHID2__DESIGNER1__Pos)                   /*!< Mask for Designer1 in GPIO.GPIOPERIPHID2 */
#define GPIO_GPIOPERIPHID2__DESIGNER1__Shift(v)                 (((v) << GPIO_GPIOPERIPHID2__DESIGNER1__Pos) & GPIO_GPIOPERIPHID2__DESIGNER1__Msk) /*!< Shift value 'v' into Designer1 and mask 'v' to fit it into Designer1 field */

/** GPIO_GPIOPERIPHID2__DESIGNER1__GET() gets GPIOPERIPHID2.DESIGNER1's current value.
 *
 * When reading from GPIOPERIPHID2.DESIGNER1, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPERIPHID2.DESIGNER1
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID2__DESIGNER1__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOPERIPHID2__GET(idp);
    reg = (reg & GPIO_GPIOPERIPHID2__DESIGNER1__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID2__DESIGNER1__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOPERIPHID2__DESIGNER1__EXTRACT() extracts GPIOPERIPHID2.DESIGNER1.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOPERIPHID2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOPERIPHID2
 * @return current value of GPIOPERIPHID2.DESIGNER1
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID2__DESIGNER1__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOPERIPHID2__DESIGNER1__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID2__DESIGNER1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       GPIOPERIPHID3 member of GPIO_t                       */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOPERIPHID3__ADDRESS returns the address of member GPIOPERIPHID3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOPERIPHID3
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOPERIPHID3__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOPERIPHID3)));
}

/** GPIO_GPIOPERIPHID3__GET() gets GPIOPERIPHID3's current value.
 *
 * When reading from GPIOPERIPHID3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPERIPHID3
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID3__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOPERIPHID3__ADDRESS(idp));
}

/* -------------------- GPIO.GPIOPERIPHID3.CONFIGURATION -------------------- */

/**
<pre>
  GPIO.GPIOPERIPHID3.CONFIGURATION:

    Configuration Number

</pre> */

#define GPIO_GPIOPERIPHID3__CONFIGURATION__Pos                  0                                                                      /*!< Right-most bit position of Configuration in GPIO.GPIOPERIPHID3 */
#define GPIO_GPIOPERIPHID3__CONFIGURATION__Msk                  (0x000000FFUL << GPIO_GPIOPERIPHID3__CONFIGURATION__Pos)               /*!< Mask for Configuration in GPIO.GPIOPERIPHID3 */
#define GPIO_GPIOPERIPHID3__CONFIGURATION__Shift(v)             (((v) << GPIO_GPIOPERIPHID3__CONFIGURATION__Pos) & GPIO_GPIOPERIPHID3__CONFIGURATION__Msk) /*!< Shift value 'v' into Configuration and mask 'v' to fit it into Configuration field */

/** GPIO_GPIOPERIPHID3__CONFIGURATION__GET() gets GPIOPERIPHID3.CONFIGURATION's current value.
 *
 * When reading from GPIOPERIPHID3.CONFIGURATION, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPERIPHID3.CONFIGURATION
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID3__CONFIGURATION__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOPERIPHID3__GET(idp);
    reg = (reg & GPIO_GPIOPERIPHID3__CONFIGURATION__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID3__CONFIGURATION__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOPERIPHID3__CONFIGURATION__EXTRACT() extracts GPIOPERIPHID3.CONFIGURATION.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOPERIPHID3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOPERIPHID3
 * @return current value of GPIOPERIPHID3.CONFIGURATION
 */
__GPIO_INLINE uint32_t GPIO_GPIOPERIPHID3__CONFIGURATION__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOPERIPHID3__CONFIGURATION__Msk);
    reg = (reg >> GPIO_GPIOPERIPHID3__CONFIGURATION__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       GPIOPCELLID0 member of GPIO_t                       */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOPCELLID0__ADDRESS returns the address of member GPIOPCELLID0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOPCELLID0
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOPCELLID0__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOPCELLID0)));
}

/** GPIO_GPIOPCELLID0__GET() gets GPIOPCELLID0's current value.
 *
 * When reading from GPIOPCELLID0, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPCELLID0
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID0__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOPCELLID0__ADDRESS(idp));
}

/* --------------------- GPIO.GPIOPCELLID0.GPIOPCELLID0 --------------------- */

/**
<pre>
  GPIO.GPIOPCELLID0.GPIOPCELLID0:

    Cell Identification Number 0

</pre> */

#define GPIO_GPIOPCELLID0__GPIOPCELLID0__Pos                    0                                                                      /*!< Right-most bit position of GPIOPCellID0 in GPIO.GPIOPCELLID0 */
#define GPIO_GPIOPCELLID0__GPIOPCELLID0__Msk                    (0x000000FFUL << GPIO_GPIOPCELLID0__GPIOPCELLID0__Pos)                 /*!< Mask for GPIOPCellID0 in GPIO.GPIOPCELLID0 */
#define GPIO_GPIOPCELLID0__GPIOPCELLID0__Shift(v)               (((v) << GPIO_GPIOPCELLID0__GPIOPCELLID0__Pos) & GPIO_GPIOPCELLID0__GPIOPCELLID0__Msk) /*!< Shift value 'v' into GPIOPCellID0 and mask 'v' to fit it into GPIOPCellID0 field */

/** GPIO_GPIOPCELLID0__GPIOPCELLID0__GET() gets GPIOPCELLID0.GPIOPCELLID0's current value.
 *
 * When reading from GPIOPCELLID0.GPIOPCELLID0, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPCELLID0.GPIOPCELLID0
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID0__GPIOPCELLID0__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOPCELLID0__GET(idp);
    reg = (reg & GPIO_GPIOPCELLID0__GPIOPCELLID0__Msk);
    reg = (reg >> GPIO_GPIOPCELLID0__GPIOPCELLID0__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOPCELLID0__GPIOPCELLID0__EXTRACT() extracts GPIOPCELLID0.GPIOPCELLID0.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOPCELLID0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOPCELLID0
 * @return current value of GPIOPCELLID0.GPIOPCELLID0
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID0__GPIOPCELLID0__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOPCELLID0__GPIOPCELLID0__Msk);
    reg = (reg >> GPIO_GPIOPCELLID0__GPIOPCELLID0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       GPIOPCELLID1 member of GPIO_t                       */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOPCELLID1__ADDRESS returns the address of member GPIOPCELLID1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOPCELLID1
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOPCELLID1__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOPCELLID1)));
}

/** GPIO_GPIOPCELLID1__GET() gets GPIOPCELLID1's current value.
 *
 * When reading from GPIOPCELLID1, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPCELLID1
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID1__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOPCELLID1__ADDRESS(idp));
}

/* --------------------- GPIO.GPIOPCELLID1.GPIOPCELLID1 --------------------- */

/**
<pre>
  GPIO.GPIOPCELLID1.GPIOPCELLID1:

    Cell Identification Number 1

</pre> */

#define GPIO_GPIOPCELLID1__GPIOPCELLID1__Pos                    0                                                                      /*!< Right-most bit position of GPIOPCellID1 in GPIO.GPIOPCELLID1 */
#define GPIO_GPIOPCELLID1__GPIOPCELLID1__Msk                    (0x000000FFUL << GPIO_GPIOPCELLID1__GPIOPCELLID1__Pos)                 /*!< Mask for GPIOPCellID1 in GPIO.GPIOPCELLID1 */
#define GPIO_GPIOPCELLID1__GPIOPCELLID1__Shift(v)               (((v) << GPIO_GPIOPCELLID1__GPIOPCELLID1__Pos) & GPIO_GPIOPCELLID1__GPIOPCELLID1__Msk) /*!< Shift value 'v' into GPIOPCellID1 and mask 'v' to fit it into GPIOPCellID1 field */

/** GPIO_GPIOPCELLID1__GPIOPCELLID1__GET() gets GPIOPCELLID1.GPIOPCELLID1's current value.
 *
 * When reading from GPIOPCELLID1.GPIOPCELLID1, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPCELLID1.GPIOPCELLID1
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID1__GPIOPCELLID1__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOPCELLID1__GET(idp);
    reg = (reg & GPIO_GPIOPCELLID1__GPIOPCELLID1__Msk);
    reg = (reg >> GPIO_GPIOPCELLID1__GPIOPCELLID1__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOPCELLID1__GPIOPCELLID1__EXTRACT() extracts GPIOPCELLID1.GPIOPCELLID1.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOPCELLID1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOPCELLID1
 * @return current value of GPIOPCELLID1.GPIOPCELLID1
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID1__GPIOPCELLID1__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOPCELLID1__GPIOPCELLID1__Msk);
    reg = (reg >> GPIO_GPIOPCELLID1__GPIOPCELLID1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       GPIOPCELLID2 member of GPIO_t                       */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOPCELLID2__ADDRESS returns the address of member GPIOPCELLID2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOPCELLID2
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOPCELLID2__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOPCELLID2)));
}

/** GPIO_GPIOPCELLID2__GET() gets GPIOPCELLID2's current value.
 *
 * When reading from GPIOPCELLID2, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPCELLID2
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID2__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOPCELLID2__ADDRESS(idp));
}

/* --------------------- GPIO.GPIOPCELLID2.GPIOPCELLID2 --------------------- */

/**
<pre>
  GPIO.GPIOPCELLID2.GPIOPCELLID2:

    Cell Identification Number 2

</pre> */

#define GPIO_GPIOPCELLID2__GPIOPCELLID2__Pos                    0                                                                      /*!< Right-most bit position of GPIOPCellID2 in GPIO.GPIOPCELLID2 */
#define GPIO_GPIOPCELLID2__GPIOPCELLID2__Msk                    (0x000000FFUL << GPIO_GPIOPCELLID2__GPIOPCELLID2__Pos)                 /*!< Mask for GPIOPCellID2 in GPIO.GPIOPCELLID2 */
#define GPIO_GPIOPCELLID2__GPIOPCELLID2__Shift(v)               (((v) << GPIO_GPIOPCELLID2__GPIOPCELLID2__Pos) & GPIO_GPIOPCELLID2__GPIOPCELLID2__Msk) /*!< Shift value 'v' into GPIOPCellID2 and mask 'v' to fit it into GPIOPCellID2 field */

/** GPIO_GPIOPCELLID2__GPIOPCELLID2__GET() gets GPIOPCELLID2.GPIOPCELLID2's current value.
 *
 * When reading from GPIOPCELLID2.GPIOPCELLID2, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPCELLID2.GPIOPCELLID2
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID2__GPIOPCELLID2__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOPCELLID2__GET(idp);
    reg = (reg & GPIO_GPIOPCELLID2__GPIOPCELLID2__Msk);
    reg = (reg >> GPIO_GPIOPCELLID2__GPIOPCELLID2__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOPCELLID2__GPIOPCELLID2__EXTRACT() extracts GPIOPCELLID2.GPIOPCELLID2.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOPCELLID2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOPCELLID2
 * @return current value of GPIOPCELLID2.GPIOPCELLID2
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID2__GPIOPCELLID2__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOPCELLID2__GPIOPCELLID2__Msk);
    reg = (reg >> GPIO_GPIOPCELLID2__GPIOPCELLID2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       GPIOPCELLID3 member of GPIO_t                       */
/* -------------------------------------------------------------------------- */

/** __GPIO_GPIOPCELLID3__ADDRESS returns the address of member GPIOPCELLID3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of GPIOPCELLID3
 */
__GPIO_INLINE uint32_t* __GPIO_GPIOPCELLID3__ADDRESS(gpio_idx_t idp)
{
    return (uint32_t*)((uint32_t)__GPIO_BASE_PTR(idp) + (uint32_t)(offsetof(GPIO_t, GPIOPCELLID3)));
}

/** GPIO_GPIOPCELLID3__GET() gets GPIOPCELLID3's current value.
 *
 * When reading from GPIOPCELLID3, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPCELLID3
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID3__GET(gpio_idx_t idp)
{
    return HAL_GET32(__GPIO_GPIOPCELLID3__ADDRESS(idp));
}

/* --------------------- GPIO.GPIOPCELLID3.GPIOPCELLID3 --------------------- */

/**
<pre>
  GPIO.GPIOPCELLID3.GPIOPCELLID3:

    Cell Identification Number 3

</pre> */

#define GPIO_GPIOPCELLID3__GPIOPCELLID3__Pos                    0                                                                      /*!< Right-most bit position of GPIOPCellID3 in GPIO.GPIOPCELLID3 */
#define GPIO_GPIOPCELLID3__GPIOPCELLID3__Msk                    (0x000000FFUL << GPIO_GPIOPCELLID3__GPIOPCELLID3__Pos)                 /*!< Mask for GPIOPCellID3 in GPIO.GPIOPCELLID3 */
#define GPIO_GPIOPCELLID3__GPIOPCELLID3__Shift(v)               (((v) << GPIO_GPIOPCELLID3__GPIOPCELLID3__Pos) & GPIO_GPIOPCELLID3__GPIOPCELLID3__Msk) /*!< Shift value 'v' into GPIOPCellID3 and mask 'v' to fit it into GPIOPCellID3 field */

/** GPIO_GPIOPCELLID3__GPIOPCELLID3__GET() gets GPIOPCELLID3.GPIOPCELLID3's current value.
 *
 * When reading from GPIOPCELLID3.GPIOPCELLID3, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of GPIOPCELLID3.GPIOPCELLID3
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID3__GPIOPCELLID3__GET(gpio_idx_t idp)
{
    uint32_t reg = GPIO_GPIOPCELLID3__GET(idp);
    reg = (reg & GPIO_GPIOPCELLID3__GPIOPCELLID3__Msk);
    reg = (reg >> GPIO_GPIOPCELLID3__GPIOPCELLID3__Pos);
    return (uint32_t)reg;
}

/** GPIO_GPIOPCELLID3__GPIOPCELLID3__EXTRACT() extracts GPIOPCELLID3.GPIOPCELLID3.
 *
 * This is recommended to use when extracting more than one bitfield from GPIO.GPIOPCELLID3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of GPIO.GPIOPCELLID3
 * @return current value of GPIOPCELLID3.GPIOPCELLID3
 */
__GPIO_INLINE uint32_t GPIO_GPIOPCELLID3__GPIOPCELLID3__EXTRACT(uint32_t reg)
{
    reg = (reg & GPIO_GPIOPCELLID3__GPIOPCELLID3__Msk);
    reg = (reg >> GPIO_GPIOPCELLID3__GPIOPCELLID3__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group gpio block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_GPIO_H_ */
