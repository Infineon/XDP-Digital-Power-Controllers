/**
 * @file     shasta_hal_common.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_COMMON_H_
#define _SHASTA_HAL_COMMON_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup common
 * @{
 */

#if defined ( __CC_ARM )
#define __COMMON_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __COMMON_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __COMMON_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __COMMON_INLINE  static inline
#endif

/** register file of the common block.
 */
typedef struct _COMMON_s
{
    volatile        uint32_t        BALANCE_CFG                 ; /*!< (@0x00000000) Current balance PI filter proportional coefficient index.  Set to 0 to disable the proportional component of the filter.  Note that index settings greater t...(more) */
    volatile        uint32_t        MP_FUNC1                    ; /*!< (@0x00000004) Pin BEN function definition <start table_with_header> [2:0] "Direction" "Function" "[2:0]" "Direction" "Function" 0 "IO" "BEN (GPIO1[0])" "4" "I" "UARTRXD" ...(more) */
    volatile        uint32_t        MP_FUNC2                    ; /*!< (@0x00000008) Pin IMON function definition <start table_with_header> [2:0] "Direction" "Function" "[2:0]" "Direction" "Function" 0 "Analog" "IMON" "4" "I" "FAN1_TACH" 1 "...(more) */
    volatile        uint32_t        MP_FUNC3                    ; /*!< (@0x0000000C) Pin PWM1 function definition <start table_with_header> [2:0] "Direction" "Function" "[2:0]" "Direction" "Function" 0 "O" "PWM1" "4" "na" "na" 1 "IO" "GPIO0[...(more) */
    volatile        uint32_t        MP_FUNC4                    ; /*!< (@0x00000010) Pin PWM6 function definition <start table_with_header> [2:0] "Direction" "Function" "[2:0]" "Direction" "Function" 0 "O" "PWM6" "4" "O" "UARTTXD" 1 "IO" "GP...(more) */
    volatile        uint32_t        MP_FUNC5                    ; /*!< (@0x00000014) Pin PWM11 function definition <start table_with_header> [2:0] "Direction" "Function" "[2:0]" "Direction" "Function" 0 "O" "PWM11" "4" "O" "FAN1_PWM" 1 "IO" ...(more) */
    volatile        uint32_t        VRS_CFG                     ; /*!< (@0x00000018) Vrect comparator watchdog timeout threshold.  The watchdog timer measures from the rising edge of the PWM's indicated in ceX_on_mask0 and ceX_on_mask1 (wher...(more) */
    volatile        uint32_t        VRS_VOLTAGE_INIT            ; /*!< (@0x0000001C) Initial voltage for VRSEN and BVRSEN tracking integrators when operating in VRS mode as observed at the VRSEN/BVRSEN inputs (i.e., after the sense resistor ...(more) */
    volatile        uint32_t        ISHARE                      ; /*!< (@0x00000020) Used for current sharing, this register defines a pre-scale gain applied to the internal current telemetry before sending to the current output DAC on the I...(more) */
    volatile        uint32_t        ISHARE1                     ; /*!< (@0x00000024) Negative clamp applied to active current sharing voltage adjustment.  This value reflects the voltage at the VSEN input.  To convert to Vout divide by VOUT_...(more) */
    volatile        uint32_t        GPIO_DBEN                   ; /*!< (@0x00000028) Spare configuration register space */
    volatile        uint32_t        CGATE                       ; /*!< (@0x0000002C) HW block clock gating bypassed when bit is high.  In general, since the HW block enables are FW controlled, these bits should all be set to 0. <start table>...(more) */
    volatile        uint32_t        FBAL_THRESH                 ; /*!< (@0x00000030) Flux balance error fault threshold. LSB = 2 V-us, Range = 0 to 510 V-us */
    volatile        uint32_t        VSP1_VRS_VRECTE             ; /*!< (@0x00000034) Measured VRSEN rectification voltage on the even half cycle. LSB = 1.25mV, Range = 0.0 to 2.1V */
    volatile        uint32_t        VSP1_VRS_VRECTO             ; /*!< (@0x00000038) Measured VRSEN rectification voltage on the odd half cycle. LSB = 1.25mV, Range = 0.0 to 2.1V */
    volatile        uint32_t        VSP1_VRS_VRECT_AVG          ; /*!< (@0x0000003C) Average of measured VRSEN even and odd half cycle rectification voltages. LSB = 1.25mV, Range = 0.0 to 2.1V */
    volatile        uint32_t        VSP2_VRS_VRECTE             ; /*!< (@0x00000040) Measured BVRSEN rectification voltage on the even half cycle. LSB = 1.25mV, Range = 0.0 to 2.1V */
    volatile        uint32_t        VSP2_VRS_VRECTO             ; /*!< (@0x00000044) Measured BVRSEN rectification voltage on the odd half cycle. LSB = 1.25mV, Range = 0.0 to 2.1V */
    volatile        uint32_t        VSP2_VRS_VRECT_AVG          ; /*!< (@0x00000048) Average of measured BVRSEN even and odd half cycle rectification voltages. LSB = 1.25mV, Range = 0.0 to 2.1V */
    volatile        uint32_t        EN_REG1                     ; /*!< (@0x0000004C) FW driven HW block enable for Loop 0 VCONTROL function <start table> 0 "disabled" 1 "enabled" <end table> */
    volatile        uint32_t        EN_REG2                     ; /*!< (@0x00000050) FW driven HW block enable for Loop 1 VCONTROL function <start table> 0 "disabled" 1 "enabled" <end table> */
    volatile        uint32_t        EN_REG3                     ; /*!< (@0x00000054) FW driven HW block enable for TS ADC <start table> 0 "disabled" 1 "enabled" <end table> */
    volatile        uint32_t        FPGA_STATUS                 ; /*!< (@0x00000058) FPGA Status register.  See bitfile release notes for description. */
    volatile        uint32_t        FPGA_CONFIG                 ; /*!< (@0x0000005C) FPGA Configuration Register: <start table_with_header> Bits Function [2:0] "ISEN Mapping (e.g., [2:0]=0, ISEN mapped to ISEN1)" [5:3] "BISEN Mapping (e.g., ...(more) */
    volatile        uint32_t        VSP1_SR_CNT                 ; /*!< (@0x00000060) Block averaged VRSEN SR FET falling edge to VRS Comp rising edge measurement result. LSB = 5ns, Range = 0 to 1275ns */
    volatile        uint32_t        VSP1_VRS_CNT                ; /*!< (@0x00000064) Non-averaged VRSEN VRS Comp pulse width measurement result for ACF topology or the even half cycle of bridge topologies. LSB = 5ns, Range = 0 to 1025ns */
    volatile        uint32_t        VSP2_SR_CNT                 ; /*!< (@0x00000068) Block averaged BVRSEN SR FET falling edge to VRS Comp rising edge measurement result. LSB = 5ns, Range = 0 to 1275ns */
    volatile        uint32_t        VSP2_VRS_CNT                ; /*!< (@0x0000006C) Non-averaged BVRSEN VRS Comp pulse width measurement result for ACF topology or the even half cycle of bridge topologies. LSB = 5ns, Range = 0 to 1025ns */
    volatile        uint32_t        FSW_IRQ0                    ; /*!< (@0x00000070) Defines the Fswitch based interrupt rate in number of switching periods, tswitch0.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active...(more) */
    volatile        uint32_t        FSW_IRQ1                    ; /*!< (@0x00000074) Defines the Fswitch based interrupt rate in number of switching periods, tswitch1.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active...(more) */
    volatile        uint32_t        IBAL_FW                     ; /*!< (@0x00000078) When ibal_fw_en is high, this register overrides the HW current balance duty cycle adjust output with a FW controlled setting. LSB = 0.195 %, Range = 0.0 to...(more) */
    volatile        uint32_t        FBAL1_FW                    ; /*!< (@0x0000007C) When fbal1_fw_en is high, this register overrides the Loop 0, Phase 1 HW flux / voltage balance duty cycle adjust output with a FW controlled setting. LSB =...(more) */
    volatile        uint32_t        FBAL2_FW                    ; /*!< (@0x00000080) When fbal2_fw_en is high, this register overrides the Loop 0, Phase 2 or Loop 1 HW flux / voltage balance duty cycle adjust output with a FW controlled sett...(more) */
    volatile        uint32_t        ISHARE_FW                   ; /*!< (@0x00000084) When ishr_fw_en is high, this register overrides the HW current share voltage adjust output with a FW controlled setting. LSB = 156.25uV, Range = -320 to +3...(more) */
    volatile        uint32_t        IDAC_FW                     ; /*!< (@0x00000088) When idac_fw_en is high, this register overrides the HW current DAC output with a FW controlled setting. LSB = 0.625uA, Range = 0.0 to 639.375uA */
    volatile        uint32_t        XADDR1                      ; /*!< (@0x0000008C) XADDR1 weak pulldown control <start table> 0 "pulldown disabled" 1 "pulldown enabled except when xv_pinset1_meas=1" <end table> */
    volatile        uint32_t        IO_IN                       ; /*!< (@0x00000090) IO inputs for test.  Only active when force_all_in=1. <start table_with_header> Bit Pin Bit Pin Bit Pin Bit Pin 0 EN 1 PWRGD 2 BEN 3 BPRWGD 4 SCL 5 SDA 6 SM...(more) */
    volatile        uint32_t        CE0_IOFFSET                 ; /*!< (@0x00000094) CE0 / IS1 (ISEN) calibrated offset status register. LSB = 0.0625 Codes, Range = -256 to +255.9375 Codes */
    volatile        uint32_t        CE1_IOFFSET                 ; /*!< (@0x00000098) CE1 / IS2 calibrated offset status register. LSB = 0.0625 Codes, Range = -256 to +255.9375 Codes */
    volatile        uint32_t        CE2_IOFFSET                 ; /*!< (@0x0000009C) CE2 / IS3 (BISEN) calibrated offset status register. LSB = 0.0625 Codes, Range = -256 to +255.9375 Codes */
    volatile        uint32_t        ISHARE_DZ                   ; /*!< (@0x000000A0) Ishare dead zone below which current sharing is not attempted. To convert to Amps divide by ishr_scale. LSB = 1 Code, Range = 0 to 255 Codes */
    volatile        uint32_t        LO_SLEEP                    ; /*!< (@0x000000A4) Function not in use. */
    volatile        uint32_t        DIG_SYNC                    ; /*!< (@0x000000A8) Current SYNC flywheel period, will match incoming period when lock achieved. LSB = 5ns, Range = 0 to 10.235us */
    volatile        uint32_t        VDAC_CFG                    ; /*!< (@0x000000AC) Offset added to Voltage DAC 16-bit input word. */
    volatile        uint32_t        VDAC_EN                     ; /*!< (@0x000000B0) Voltage DAC analog block enable <start table> 0 "disabled" 1 "enabled" <end table> */
    volatile        uint32_t        VDAC_MASK                   ; /*!< (@0x000000B4) Active high mask applied to the Voltage DAC 16-bit input word to zero out selected bits.  Applied as, <start table> "vdac_in_masked[15:0] = vdac_in[15:0] & ...(more) */
    volatile        uint32_t        VDAC_DIG                    ; /*!< (@0x000000B8) Voltage DAC output word. */
    volatile        uint32_t        FW_RESET                    ; /*!< (@0x000000BC) Controller reset.  Setting this register high initiates the equivalent of a power on reset to all controller functions except the CPU debugger access port w...(more) */
    volatile        uint32_t        FSW_IRQ_CLR                 ; /*!< (@0x000000C0) FSW0_IRQ CLEAR <start table> 0 "fsw0_irq0 clear" 1 "fsw0_irq1 clear" 2 "fsw0_irq2 clear" 3 "fsw0_irq3 clear" 4 "fsw0_irq4 clear" 5 "fsw0_irq5 clear" 6 "fsw0...(more) */
    volatile        uint32_t        FSW_STAT                    ; /*!< (@0x000000C4) FSW0_IRQ STATUS <start table> 0 "fsw0_irq0 status" 1 "fsw0_irq1 status" 2 "fsw0_irq2  status" 3 "fsw0_irq3  status" 4 "fsw0_irq4  status" 5 "fsw0_irq5  stat...(more) */
} COMMON_t;


#define COMMON_BASE (0x70003000u)                                                          /*!< common base address */

/** __COMMON_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__COMMON_INLINE uint32_t* __COMMON_BASE_PTR(void)
{
    return (uint32_t*)(COMMON_BASE);
}


/* -------------------------------------------------------------------------- */
/*                       BALANCE_CFG member of COMMON_t                       */
/* -------------------------------------------------------------------------- */

/** __COMMON_BALANCE_CFG__ADDRESS returns the address of member BALANCE_CFG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BALANCE_CFG
 */
__COMMON_INLINE uint32_t* __COMMON_BALANCE_CFG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, BALANCE_CFG)));
}

/** COMMON_BALANCE_CFG__SET() sets BALANCE_CFG to given value.
 *
 * When writing to BALANCE_CFG, this is mandatory to use.
 *
 * @param value new value for BALANCE_CFG
 */
__COMMON_INLINE void COMMON_BALANCE_CFG__SET(uint32_t value)
{
    HAL_SET32(__COMMON_BALANCE_CFG__ADDRESS(), value);
}

/** COMMON_BALANCE_CFG__GET() gets BALANCE_CFG's current value.
 *
 * When reading from BALANCE_CFG, this is mandatory to use.
 *
 * @return current value of BALANCE_CFG
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__GET(void)
{
    return HAL_GET32(__COMMON_BALANCE_CFG__ADDRESS());
}

/* ------------------- COMMON.BALANCE_CFG.FBAL_TIME_ONLY ------------------- */

/**
<pre>
  COMMON.BALANCE_CFG.FBAL_TIME_ONLY:

    In the flux balance mode of the Flux / voltage balance PI filter, select between volt-second or time only balancing.
    <start table>
    0 "Volt-second balance mode"
    1 "Time only balance mode"
    <end table>

</pre> */

#define COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Pos                 28                                                                     /*!< Right-most bit position of fbal_time_only in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Msk                 (0x00000001UL << COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Pos)              /*!< Mask for fbal_time_only in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Shift(v)            (((v) << COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Pos) & COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Msk) /*!< Shift value 'v' into fbal_time_only and mask 'v' to fit it into fbal_time_only field */

/** COMMON_BALANCE_CFG__FBAL_TIME_ONLY__SET() sets BALANCE_CFG.FBAL_TIME_ONLY to given value.
 *
 * When writing to BALANCE_CFG.FBAL_TIME_ONLY, this is recommended to use.
 *
 * @param bf_value new value for BALANCE_CFG.FBAL_TIME_ONLY
 */
__COMMON_INLINE void COMMON_BALANCE_CFG__FBAL_TIME_ONLY__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & ~COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Shift((uint32_t)bf_value)));
    COMMON_BALANCE_CFG__SET(reg);
}

/** COMMON_BALANCE_CFG__FBAL_TIME_ONLY__GET() gets BALANCE_CFG.FBAL_TIME_ONLY's current value.
 *
 * When reading from BALANCE_CFG.FBAL_TIME_ONLY, this is recommended to use.
 *
 * @return current value of BALANCE_CFG.FBAL_TIME_ONLY
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__FBAL_TIME_ONLY__GET(void)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Pos);
    return (uint32_t)reg;
}

/** COMMON_BALANCE_CFG__FBAL_TIME_ONLY__MODIFY() modifies BALANCE_CFG.FBAL_TIME_ONLY.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.BALANCE_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @param bf_value new value for BALANCE_CFG.FBAL_TIME_ONLY
 * @return new value of COMMON.BALANCE_CFG
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__FBAL_TIME_ONLY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_BALANCE_CFG__FBAL_TIME_ONLY__EXTRACT() extracts BALANCE_CFG.FBAL_TIME_ONLY.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.BALANCE_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @return current value of BALANCE_CFG.FBAL_TIME_ONLY
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__FBAL_TIME_ONLY__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__FBAL_TIME_ONLY__Pos);
    return (uint32_t)reg;
}

/* ------------------- COMMON.BALANCE_CFG.IBAL_EN_THRESH ------------------- */

/**
<pre>
  COMMON.BALANCE_CFG.IBAL_EN_THRESH:

    Total current level above which current balancing is enabled in interleaved (multi-phase) topologies.  Set to higher value if concerned about low current accuracy.
    <start table>
    0,1 "Always enabled"
    2 3A
    3 5A
    <end table>

</pre> */

#define COMMON_BALANCE_CFG__IBAL_EN_THRESH__Pos                 26                                                                     /*!< Right-most bit position of ibal_en_thresh in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__IBAL_EN_THRESH__Msk                 (0x00000003UL << COMMON_BALANCE_CFG__IBAL_EN_THRESH__Pos)              /*!< Mask for ibal_en_thresh in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__IBAL_EN_THRESH__Shift(v)            (((v) << COMMON_BALANCE_CFG__IBAL_EN_THRESH__Pos) & COMMON_BALANCE_CFG__IBAL_EN_THRESH__Msk) /*!< Shift value 'v' into ibal_en_thresh and mask 'v' to fit it into ibal_en_thresh field */

/** COMMON_BALANCE_CFG__IBAL_EN_THRESH__SET() sets BALANCE_CFG.IBAL_EN_THRESH to given value.
 *
 * When writing to BALANCE_CFG.IBAL_EN_THRESH, this is recommended to use.
 *
 * @param bf_value new value for BALANCE_CFG.IBAL_EN_THRESH
 */
__COMMON_INLINE void COMMON_BALANCE_CFG__IBAL_EN_THRESH__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & ~COMMON_BALANCE_CFG__IBAL_EN_THRESH__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__IBAL_EN_THRESH__Shift((uint32_t)bf_value)));
    COMMON_BALANCE_CFG__SET(reg);
}

/** COMMON_BALANCE_CFG__IBAL_EN_THRESH__GET() gets BALANCE_CFG.IBAL_EN_THRESH's current value.
 *
 * When reading from BALANCE_CFG.IBAL_EN_THRESH, this is recommended to use.
 *
 * @return current value of BALANCE_CFG.IBAL_EN_THRESH
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__IBAL_EN_THRESH__GET(void)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & COMMON_BALANCE_CFG__IBAL_EN_THRESH__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__IBAL_EN_THRESH__Pos);
    return (uint32_t)reg;
}

/** COMMON_BALANCE_CFG__IBAL_EN_THRESH__MODIFY() modifies BALANCE_CFG.IBAL_EN_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.BALANCE_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @param bf_value new value for BALANCE_CFG.IBAL_EN_THRESH
 * @return new value of COMMON.BALANCE_CFG
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__IBAL_EN_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_BALANCE_CFG__IBAL_EN_THRESH__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__IBAL_EN_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_BALANCE_CFG__IBAL_EN_THRESH__EXTRACT() extracts BALANCE_CFG.IBAL_EN_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.BALANCE_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @return current value of BALANCE_CFG.IBAL_EN_THRESH
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__IBAL_EN_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_BALANCE_CFG__IBAL_EN_THRESH__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__IBAL_EN_THRESH__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.BALANCE_CFG.ICAL_EN ----------------------- */

/**
<pre>
  COMMON.BALANCE_CFG.ICAL_EN:

    Current sense sensor offset calibration enable.
    <start table>
    0 "Calibration disabled, ATE offset trim used"
    1 "Calibration enabled"
    <end table>

</pre> */

#define COMMON_BALANCE_CFG__ICAL_EN__Pos                        25                                                                     /*!< Right-most bit position of ical_en in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__ICAL_EN__Msk                        (0x00000001UL << COMMON_BALANCE_CFG__ICAL_EN__Pos)                     /*!< Mask for ical_en in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__ICAL_EN__Shift(v)                   (((v) << COMMON_BALANCE_CFG__ICAL_EN__Pos) & COMMON_BALANCE_CFG__ICAL_EN__Msk) /*!< Shift value 'v' into ical_en and mask 'v' to fit it into ical_en field */

/** COMMON_BALANCE_CFG__ICAL_EN__SET() sets BALANCE_CFG.ICAL_EN to given value.
 *
 * When writing to BALANCE_CFG.ICAL_EN, this is recommended to use.
 *
 * @param bf_value new value for BALANCE_CFG.ICAL_EN
 */
__COMMON_INLINE void COMMON_BALANCE_CFG__ICAL_EN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & ~COMMON_BALANCE_CFG__ICAL_EN__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__ICAL_EN__Shift((uint32_t)bf_value)));
    COMMON_BALANCE_CFG__SET(reg);
}

/** COMMON_BALANCE_CFG__ICAL_EN__GET() gets BALANCE_CFG.ICAL_EN's current value.
 *
 * When reading from BALANCE_CFG.ICAL_EN, this is recommended to use.
 *
 * @return current value of BALANCE_CFG.ICAL_EN
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__ICAL_EN__GET(void)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & COMMON_BALANCE_CFG__ICAL_EN__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__ICAL_EN__Pos);
    return (uint32_t)reg;
}

/** COMMON_BALANCE_CFG__ICAL_EN__MODIFY() modifies BALANCE_CFG.ICAL_EN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.BALANCE_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @param bf_value new value for BALANCE_CFG.ICAL_EN
 * @return new value of COMMON.BALANCE_CFG
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__ICAL_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_BALANCE_CFG__ICAL_EN__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__ICAL_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_BALANCE_CFG__ICAL_EN__EXTRACT() extracts BALANCE_CFG.ICAL_EN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.BALANCE_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @return current value of BALANCE_CFG.ICAL_EN
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__ICAL_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_BALANCE_CFG__ICAL_EN__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__ICAL_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------- COMMON.BALANCE_CFG.VBAL_MODE_SEL -------------------- */

/**
<pre>
  COMMON.BALANCE_CFG.VBAL_MODE_SEL:

    Flux / Voltage balance mode select.  Flux balance mode balances based on the Volt-second product unless fbal_time_only is set to 1 in which case balancing is based only on the Vrect pulse width.  Voltage balance mode balances based on the Vrect voltage.
    <start table>
    0 "Flux balance mode (select for Full-Bridge primary)"
    1 "Voltage balance mode (select for Half-Bridge primary)"
    <end table>

</pre> */

#define COMMON_BALANCE_CFG__VBAL_MODE_SEL__Pos                  24                                                                     /*!< Right-most bit position of vbal_mode_sel in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__VBAL_MODE_SEL__Msk                  (0x00000001UL << COMMON_BALANCE_CFG__VBAL_MODE_SEL__Pos)               /*!< Mask for vbal_mode_sel in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__VBAL_MODE_SEL__Shift(v)             (((v) << COMMON_BALANCE_CFG__VBAL_MODE_SEL__Pos) & COMMON_BALANCE_CFG__VBAL_MODE_SEL__Msk) /*!< Shift value 'v' into vbal_mode_sel and mask 'v' to fit it into vbal_mode_sel field */

/** COMMON_BALANCE_CFG__VBAL_MODE_SEL__SET() sets BALANCE_CFG.VBAL_MODE_SEL to given value.
 *
 * When writing to BALANCE_CFG.VBAL_MODE_SEL, this is recommended to use.
 *
 * @param bf_value new value for BALANCE_CFG.VBAL_MODE_SEL
 */
__COMMON_INLINE void COMMON_BALANCE_CFG__VBAL_MODE_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & ~COMMON_BALANCE_CFG__VBAL_MODE_SEL__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__VBAL_MODE_SEL__Shift((uint32_t)bf_value)));
    COMMON_BALANCE_CFG__SET(reg);
}

/** COMMON_BALANCE_CFG__VBAL_MODE_SEL__GET() gets BALANCE_CFG.VBAL_MODE_SEL's current value.
 *
 * When reading from BALANCE_CFG.VBAL_MODE_SEL, this is recommended to use.
 *
 * @return current value of BALANCE_CFG.VBAL_MODE_SEL
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__VBAL_MODE_SEL__GET(void)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & COMMON_BALANCE_CFG__VBAL_MODE_SEL__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__VBAL_MODE_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_BALANCE_CFG__VBAL_MODE_SEL__MODIFY() modifies BALANCE_CFG.VBAL_MODE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.BALANCE_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @param bf_value new value for BALANCE_CFG.VBAL_MODE_SEL
 * @return new value of COMMON.BALANCE_CFG
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__VBAL_MODE_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_BALANCE_CFG__VBAL_MODE_SEL__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__VBAL_MODE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_BALANCE_CFG__VBAL_MODE_SEL__EXTRACT() extracts BALANCE_CFG.VBAL_MODE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.BALANCE_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @return current value of BALANCE_CFG.VBAL_MODE_SEL
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__VBAL_MODE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_BALANCE_CFG__VBAL_MODE_SEL__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__VBAL_MODE_SEL__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.BALANCE_CFG.KI_FBAL ----------------------- */

/**
<pre>
  COMMON.BALANCE_CFG.KI_FBAL:

    Flux/Voltage balance PI filter integral coefficient index.  Set to 0 to disable the integral component of the filter.  Note that index settings greater than 55 are clamped to 55.  Note also that flux balancing requires that duty cycle locking is enabled by rampX_dutyc_lock.
    <start table>
    "ki_exp = ki_fbal[5:3]"
    "ki_man = 8 + ki_fbal[2:0]"
    "ki = ki_man * 2^ki_exp * 2^-22"
    <end table>

</pre> */

#define COMMON_BALANCE_CFG__KI_FBAL__Pos                        18                                                                     /*!< Right-most bit position of ki_fbal in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__KI_FBAL__Msk                        (0x0000003FUL << COMMON_BALANCE_CFG__KI_FBAL__Pos)                     /*!< Mask for ki_fbal in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__KI_FBAL__Shift(v)                   (((v) << COMMON_BALANCE_CFG__KI_FBAL__Pos) & COMMON_BALANCE_CFG__KI_FBAL__Msk) /*!< Shift value 'v' into ki_fbal and mask 'v' to fit it into ki_fbal field */

/** COMMON_BALANCE_CFG__KI_FBAL__SET() sets BALANCE_CFG.KI_FBAL to given value.
 *
 * When writing to BALANCE_CFG.KI_FBAL, this is recommended to use.
 *
 * @param bf_value new value for BALANCE_CFG.KI_FBAL
 */
__COMMON_INLINE void COMMON_BALANCE_CFG__KI_FBAL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & ~COMMON_BALANCE_CFG__KI_FBAL__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__KI_FBAL__Shift((uint32_t)bf_value)));
    COMMON_BALANCE_CFG__SET(reg);
}

/** COMMON_BALANCE_CFG__KI_FBAL__GET() gets BALANCE_CFG.KI_FBAL's current value.
 *
 * When reading from BALANCE_CFG.KI_FBAL, this is recommended to use.
 *
 * @return current value of BALANCE_CFG.KI_FBAL
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KI_FBAL__GET(void)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & COMMON_BALANCE_CFG__KI_FBAL__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__KI_FBAL__Pos);
    return (uint32_t)reg;
}

/** COMMON_BALANCE_CFG__KI_FBAL__MODIFY() modifies BALANCE_CFG.KI_FBAL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.BALANCE_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @param bf_value new value for BALANCE_CFG.KI_FBAL
 * @return new value of COMMON.BALANCE_CFG
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KI_FBAL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_BALANCE_CFG__KI_FBAL__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__KI_FBAL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_BALANCE_CFG__KI_FBAL__EXTRACT() extracts BALANCE_CFG.KI_FBAL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.BALANCE_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @return current value of BALANCE_CFG.KI_FBAL
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KI_FBAL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_BALANCE_CFG__KI_FBAL__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__KI_FBAL__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.BALANCE_CFG.KP_FBAL ----------------------- */

/**
<pre>
  COMMON.BALANCE_CFG.KP_FBAL:

    Flux/Voltage balance PI filter proportional coefficient index.  Set to 0 to disable the proportional component of the filter.  Note that index settings greater than 55 are clamped to 55.  Note also that flux balancing requires that duty cycle locking is enabled by rampX_dutyc_lock.
    <start table>
    "kp_exp = kp_fbal[5:3]"
    "kp_man = 8 + kp_fbal[2:0]"
    "kp = kp_man * 2^kp_exp * 2^-18"
    <end table>

</pre> */

#define COMMON_BALANCE_CFG__KP_FBAL__Pos                        12                                                                     /*!< Right-most bit position of kp_fbal in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__KP_FBAL__Msk                        (0x0000003FUL << COMMON_BALANCE_CFG__KP_FBAL__Pos)                     /*!< Mask for kp_fbal in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__KP_FBAL__Shift(v)                   (((v) << COMMON_BALANCE_CFG__KP_FBAL__Pos) & COMMON_BALANCE_CFG__KP_FBAL__Msk) /*!< Shift value 'v' into kp_fbal and mask 'v' to fit it into kp_fbal field */

/** COMMON_BALANCE_CFG__KP_FBAL__SET() sets BALANCE_CFG.KP_FBAL to given value.
 *
 * When writing to BALANCE_CFG.KP_FBAL, this is recommended to use.
 *
 * @param bf_value new value for BALANCE_CFG.KP_FBAL
 */
__COMMON_INLINE void COMMON_BALANCE_CFG__KP_FBAL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & ~COMMON_BALANCE_CFG__KP_FBAL__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__KP_FBAL__Shift((uint32_t)bf_value)));
    COMMON_BALANCE_CFG__SET(reg);
}

/** COMMON_BALANCE_CFG__KP_FBAL__GET() gets BALANCE_CFG.KP_FBAL's current value.
 *
 * When reading from BALANCE_CFG.KP_FBAL, this is recommended to use.
 *
 * @return current value of BALANCE_CFG.KP_FBAL
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KP_FBAL__GET(void)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & COMMON_BALANCE_CFG__KP_FBAL__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__KP_FBAL__Pos);
    return (uint32_t)reg;
}

/** COMMON_BALANCE_CFG__KP_FBAL__MODIFY() modifies BALANCE_CFG.KP_FBAL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.BALANCE_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @param bf_value new value for BALANCE_CFG.KP_FBAL
 * @return new value of COMMON.BALANCE_CFG
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KP_FBAL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_BALANCE_CFG__KP_FBAL__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__KP_FBAL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_BALANCE_CFG__KP_FBAL__EXTRACT() extracts BALANCE_CFG.KP_FBAL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.BALANCE_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @return current value of BALANCE_CFG.KP_FBAL
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KP_FBAL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_BALANCE_CFG__KP_FBAL__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__KP_FBAL__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.BALANCE_CFG.KI_IBAL ----------------------- */

/**
<pre>
  COMMON.BALANCE_CFG.KI_IBAL:

    Current balance PI filter integral coefficient index.  Set to 0 to disable the integral component of the filter.  Note that index settings greater than 55 are clamped to 55.
    <start table>
    "ki_exp = ki_ibal[5:3]"
    "ki_man = 8 + ki_ibal[2:0]"
    "ki = kp_man * 2^ki_exp * 2^-20"
    <end table>

</pre> */

#define COMMON_BALANCE_CFG__KI_IBAL__Pos                        6                                                                      /*!< Right-most bit position of ki_ibal in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__KI_IBAL__Msk                        (0x0000003FUL << COMMON_BALANCE_CFG__KI_IBAL__Pos)                     /*!< Mask for ki_ibal in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__KI_IBAL__Shift(v)                   (((v) << COMMON_BALANCE_CFG__KI_IBAL__Pos) & COMMON_BALANCE_CFG__KI_IBAL__Msk) /*!< Shift value 'v' into ki_ibal and mask 'v' to fit it into ki_ibal field */

/** COMMON_BALANCE_CFG__KI_IBAL__SET() sets BALANCE_CFG.KI_IBAL to given value.
 *
 * When writing to BALANCE_CFG.KI_IBAL, this is recommended to use.
 *
 * @param bf_value new value for BALANCE_CFG.KI_IBAL
 */
__COMMON_INLINE void COMMON_BALANCE_CFG__KI_IBAL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & ~COMMON_BALANCE_CFG__KI_IBAL__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__KI_IBAL__Shift((uint32_t)bf_value)));
    COMMON_BALANCE_CFG__SET(reg);
}

/** COMMON_BALANCE_CFG__KI_IBAL__GET() gets BALANCE_CFG.KI_IBAL's current value.
 *
 * When reading from BALANCE_CFG.KI_IBAL, this is recommended to use.
 *
 * @return current value of BALANCE_CFG.KI_IBAL
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KI_IBAL__GET(void)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & COMMON_BALANCE_CFG__KI_IBAL__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__KI_IBAL__Pos);
    return (uint32_t)reg;
}

/** COMMON_BALANCE_CFG__KI_IBAL__MODIFY() modifies BALANCE_CFG.KI_IBAL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.BALANCE_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @param bf_value new value for BALANCE_CFG.KI_IBAL
 * @return new value of COMMON.BALANCE_CFG
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KI_IBAL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_BALANCE_CFG__KI_IBAL__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__KI_IBAL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_BALANCE_CFG__KI_IBAL__EXTRACT() extracts BALANCE_CFG.KI_IBAL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.BALANCE_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @return current value of BALANCE_CFG.KI_IBAL
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KI_IBAL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_BALANCE_CFG__KI_IBAL__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__KI_IBAL__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.BALANCE_CFG.KP_IBAL ----------------------- */

/**
<pre>
  COMMON.BALANCE_CFG.KP_IBAL:

    Current balance PI filter proportional coefficient index.  Set to 0 to disable the proportional component of the filter.  Note that index settings greater than 55 are clamped to 55.
    <start table>
    "kp_exp = kp_ibal[5:3]"
    "kp_man = 8 + kp_ibal[2:0]"
    "kp = kp_man * 2^kp_exp * 2^-14"
    <end table>

</pre> */

#define COMMON_BALANCE_CFG__KP_IBAL__Pos                        0                                                                      /*!< Right-most bit position of kp_ibal in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__KP_IBAL__Msk                        (0x0000003FUL << COMMON_BALANCE_CFG__KP_IBAL__Pos)                     /*!< Mask for kp_ibal in COMMON.BALANCE_CFG */
#define COMMON_BALANCE_CFG__KP_IBAL__Shift(v)                   (((v) << COMMON_BALANCE_CFG__KP_IBAL__Pos) & COMMON_BALANCE_CFG__KP_IBAL__Msk) /*!< Shift value 'v' into kp_ibal and mask 'v' to fit it into kp_ibal field */

/** COMMON_BALANCE_CFG__KP_IBAL__SET() sets BALANCE_CFG.KP_IBAL to given value.
 *
 * When writing to BALANCE_CFG.KP_IBAL, this is recommended to use.
 *
 * @param bf_value new value for BALANCE_CFG.KP_IBAL
 */
__COMMON_INLINE void COMMON_BALANCE_CFG__KP_IBAL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & ~COMMON_BALANCE_CFG__KP_IBAL__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__KP_IBAL__Shift((uint32_t)bf_value)));
    COMMON_BALANCE_CFG__SET(reg);
}

/** COMMON_BALANCE_CFG__KP_IBAL__GET() gets BALANCE_CFG.KP_IBAL's current value.
 *
 * When reading from BALANCE_CFG.KP_IBAL, this is recommended to use.
 *
 * @return current value of BALANCE_CFG.KP_IBAL
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KP_IBAL__GET(void)
{
    uint32_t reg = COMMON_BALANCE_CFG__GET();
    reg = (reg & COMMON_BALANCE_CFG__KP_IBAL__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__KP_IBAL__Pos);
    return (uint32_t)reg;
}

/** COMMON_BALANCE_CFG__KP_IBAL__MODIFY() modifies BALANCE_CFG.KP_IBAL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.BALANCE_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @param bf_value new value for BALANCE_CFG.KP_IBAL
 * @return new value of COMMON.BALANCE_CFG
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KP_IBAL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_BALANCE_CFG__KP_IBAL__Msk);
    reg = (reg | (COMMON_BALANCE_CFG__KP_IBAL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_BALANCE_CFG__KP_IBAL__EXTRACT() extracts BALANCE_CFG.KP_IBAL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.BALANCE_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.BALANCE_CFG
 * @return current value of BALANCE_CFG.KP_IBAL
 */
__COMMON_INLINE uint32_t COMMON_BALANCE_CFG__KP_IBAL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_BALANCE_CFG__KP_IBAL__Msk);
    reg = (reg >> COMMON_BALANCE_CFG__KP_IBAL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        MP_FUNC1 member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_MP_FUNC1__ADDRESS returns the address of member MP_FUNC1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MP_FUNC1
 */
__COMMON_INLINE uint32_t* __COMMON_MP_FUNC1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, MP_FUNC1)));
}

/** COMMON_MP_FUNC1__SET() sets MP_FUNC1 to given value.
 *
 * When writing to MP_FUNC1, this is mandatory to use.
 *
 * @param value new value for MP_FUNC1
 */
__COMMON_INLINE void COMMON_MP_FUNC1__SET(uint32_t value)
{
    HAL_SET32(__COMMON_MP_FUNC1__ADDRESS(), value);
}

/** COMMON_MP_FUNC1__GET() gets MP_FUNC1's current value.
 *
 * When reading from MP_FUNC1, this is mandatory to use.
 *
 * @return current value of MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__GET(void)
{
    return HAL_GET32(__COMMON_MP_FUNC1__ADDRESS());
}

/* ---------------------- COMMON.MP_FUNC1.FAULT2_PPEN ---------------------- */

/**
<pre>
  COMMON.MP_FUNC1.FAULT2_PPEN:

    Pin FAULT2 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__FAULT2_PPEN__Pos                       29                                                                     /*!< Right-most bit position of fault2_ppen in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT2_PPEN__Msk                       (0x00000001UL << COMMON_MP_FUNC1__FAULT2_PPEN__Pos)                    /*!< Mask for fault2_ppen in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT2_PPEN__Shift(v)                  (((v) << COMMON_MP_FUNC1__FAULT2_PPEN__Pos) & COMMON_MP_FUNC1__FAULT2_PPEN__Msk) /*!< Shift value 'v' into fault2_ppen and mask 'v' to fit it into fault2_ppen field */

/** COMMON_MP_FUNC1__FAULT2_PPEN__SET() sets MP_FUNC1.FAULT2_PPEN to given value.
 *
 * When writing to MP_FUNC1.FAULT2_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.FAULT2_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC1__FAULT2_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__FAULT2_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT2_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__FAULT2_PPEN__GET() gets MP_FUNC1.FAULT2_PPEN's current value.
 *
 * When reading from MP_FUNC1.FAULT2_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC1.FAULT2_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__FAULT2_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT2_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__FAULT2_PPEN__MODIFY() modifies MP_FUNC1.FAULT2_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.FAULT2_PPEN
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__FAULT2_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT2_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__FAULT2_PPEN__EXTRACT() extracts MP_FUNC1.FAULT2_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.FAULT2_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__FAULT2_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT2_PPEN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC1.FAULT2_PU_N ---------------------- */

/**
<pre>
  COMMON.MP_FUNC1.FAULT2_PU_N:

    Pin FAULT2 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__FAULT2_PU_N__Pos                       28                                                                     /*!< Right-most bit position of fault2_pu_n in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT2_PU_N__Msk                       (0x00000001UL << COMMON_MP_FUNC1__FAULT2_PU_N__Pos)                    /*!< Mask for fault2_pu_n in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT2_PU_N__Shift(v)                  (((v) << COMMON_MP_FUNC1__FAULT2_PU_N__Pos) & COMMON_MP_FUNC1__FAULT2_PU_N__Msk) /*!< Shift value 'v' into fault2_pu_n and mask 'v' to fit it into fault2_pu_n field */

/** COMMON_MP_FUNC1__FAULT2_PU_N__SET() sets MP_FUNC1.FAULT2_PU_N to given value.
 *
 * When writing to MP_FUNC1.FAULT2_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.FAULT2_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC1__FAULT2_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__FAULT2_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT2_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__FAULT2_PU_N__GET() gets MP_FUNC1.FAULT2_PU_N's current value.
 *
 * When reading from MP_FUNC1.FAULT2_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC1.FAULT2_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__FAULT2_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT2_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__FAULT2_PU_N__MODIFY() modifies MP_FUNC1.FAULT2_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.FAULT2_PU_N
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__FAULT2_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT2_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__FAULT2_PU_N__EXTRACT() extracts MP_FUNC1.FAULT2_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.FAULT2_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__FAULT2_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT2_PU_N__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC1.FAULT2_PD ----------------------- */

/**
<pre>
  COMMON.MP_FUNC1.FAULT2_PD:

    Pin FAULT2 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__FAULT2_PD__Pos                         27                                                                     /*!< Right-most bit position of fault2_pd in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT2_PD__Msk                         (0x00000001UL << COMMON_MP_FUNC1__FAULT2_PD__Pos)                      /*!< Mask for fault2_pd in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT2_PD__Shift(v)                    (((v) << COMMON_MP_FUNC1__FAULT2_PD__Pos) & COMMON_MP_FUNC1__FAULT2_PD__Msk) /*!< Shift value 'v' into fault2_pd and mask 'v' to fit it into fault2_pd field */

/** COMMON_MP_FUNC1__FAULT2_PD__SET() sets MP_FUNC1.FAULT2_PD to given value.
 *
 * When writing to MP_FUNC1.FAULT2_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.FAULT2_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC1__FAULT2_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__FAULT2_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT2_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__FAULT2_PD__GET() gets MP_FUNC1.FAULT2_PD's current value.
 *
 * When reading from MP_FUNC1.FAULT2_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC1.FAULT2_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__FAULT2_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT2_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__FAULT2_PD__MODIFY() modifies MP_FUNC1.FAULT2_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.FAULT2_PD
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__FAULT2_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT2_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__FAULT2_PD__EXTRACT() extracts MP_FUNC1.FAULT2_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.FAULT2_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__FAULT2_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT2_PD__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC1.FAULT2_FUNC ---------------------- */

/**
<pre>
  COMMON.MP_FUNC1.FAULT2_FUNC:

    Pin FAULT2 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "IO" "FAULT2 (GPIO1[2])" "4" "I" "FAN2_TACH"
    1 "IO" "GPIO0[2]" "5" "IO" "SCL2"
    2 "IO" "GPIO1[2]" "6" "O" "UARTTXD"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__FAULT2_FUNC__Pos                       24                                                                     /*!< Right-most bit position of fault2_func in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT2_FUNC__Msk                       (0x00000007UL << COMMON_MP_FUNC1__FAULT2_FUNC__Pos)                    /*!< Mask for fault2_func in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT2_FUNC__Shift(v)                  (((v) << COMMON_MP_FUNC1__FAULT2_FUNC__Pos) & COMMON_MP_FUNC1__FAULT2_FUNC__Msk) /*!< Shift value 'v' into fault2_func and mask 'v' to fit it into fault2_func field */

/** COMMON_MP_FUNC1__FAULT2_FUNC__SET() sets MP_FUNC1.FAULT2_FUNC to given value.
 *
 * When writing to MP_FUNC1.FAULT2_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.FAULT2_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC1__FAULT2_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__FAULT2_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT2_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__FAULT2_FUNC__GET() gets MP_FUNC1.FAULT2_FUNC's current value.
 *
 * When reading from MP_FUNC1.FAULT2_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC1.FAULT2_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__FAULT2_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT2_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__FAULT2_FUNC__MODIFY() modifies MP_FUNC1.FAULT2_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.FAULT2_FUNC
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__FAULT2_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT2_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__FAULT2_FUNC__EXTRACT() extracts MP_FUNC1.FAULT2_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.FAULT2_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT2_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__FAULT2_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT2_FUNC__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC1.FAULT1_PPEN ---------------------- */

/**
<pre>
  COMMON.MP_FUNC1.FAULT1_PPEN:

    Pin FAULT1 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__FAULT1_PPEN__Pos                       23                                                                     /*!< Right-most bit position of fault1_ppen in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT1_PPEN__Msk                       (0x00000001UL << COMMON_MP_FUNC1__FAULT1_PPEN__Pos)                    /*!< Mask for fault1_ppen in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT1_PPEN__Shift(v)                  (((v) << COMMON_MP_FUNC1__FAULT1_PPEN__Pos) & COMMON_MP_FUNC1__FAULT1_PPEN__Msk) /*!< Shift value 'v' into fault1_ppen and mask 'v' to fit it into fault1_ppen field */

/** COMMON_MP_FUNC1__FAULT1_PPEN__SET() sets MP_FUNC1.FAULT1_PPEN to given value.
 *
 * When writing to MP_FUNC1.FAULT1_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.FAULT1_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC1__FAULT1_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__FAULT1_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT1_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__FAULT1_PPEN__GET() gets MP_FUNC1.FAULT1_PPEN's current value.
 *
 * When reading from MP_FUNC1.FAULT1_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC1.FAULT1_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__FAULT1_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT1_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__FAULT1_PPEN__MODIFY() modifies MP_FUNC1.FAULT1_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.FAULT1_PPEN
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__FAULT1_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT1_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__FAULT1_PPEN__EXTRACT() extracts MP_FUNC1.FAULT1_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.FAULT1_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__FAULT1_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT1_PPEN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC1.FAULT1_PU_N ---------------------- */

/**
<pre>
  COMMON.MP_FUNC1.FAULT1_PU_N:

    Pin FAULT1 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__FAULT1_PU_N__Pos                       22                                                                     /*!< Right-most bit position of fault1_pu_n in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT1_PU_N__Msk                       (0x00000001UL << COMMON_MP_FUNC1__FAULT1_PU_N__Pos)                    /*!< Mask for fault1_pu_n in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT1_PU_N__Shift(v)                  (((v) << COMMON_MP_FUNC1__FAULT1_PU_N__Pos) & COMMON_MP_FUNC1__FAULT1_PU_N__Msk) /*!< Shift value 'v' into fault1_pu_n and mask 'v' to fit it into fault1_pu_n field */

/** COMMON_MP_FUNC1__FAULT1_PU_N__SET() sets MP_FUNC1.FAULT1_PU_N to given value.
 *
 * When writing to MP_FUNC1.FAULT1_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.FAULT1_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC1__FAULT1_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__FAULT1_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT1_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__FAULT1_PU_N__GET() gets MP_FUNC1.FAULT1_PU_N's current value.
 *
 * When reading from MP_FUNC1.FAULT1_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC1.FAULT1_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__FAULT1_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT1_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__FAULT1_PU_N__MODIFY() modifies MP_FUNC1.FAULT1_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.FAULT1_PU_N
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__FAULT1_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT1_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__FAULT1_PU_N__EXTRACT() extracts MP_FUNC1.FAULT1_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.FAULT1_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__FAULT1_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT1_PU_N__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC1.FAULT1_PD ----------------------- */

/**
<pre>
  COMMON.MP_FUNC1.FAULT1_PD:

    Pin FAULT1 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__FAULT1_PD__Pos                         21                                                                     /*!< Right-most bit position of fault1_pd in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT1_PD__Msk                         (0x00000001UL << COMMON_MP_FUNC1__FAULT1_PD__Pos)                      /*!< Mask for fault1_pd in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT1_PD__Shift(v)                    (((v) << COMMON_MP_FUNC1__FAULT1_PD__Pos) & COMMON_MP_FUNC1__FAULT1_PD__Msk) /*!< Shift value 'v' into fault1_pd and mask 'v' to fit it into fault1_pd field */

/** COMMON_MP_FUNC1__FAULT1_PD__SET() sets MP_FUNC1.FAULT1_PD to given value.
 *
 * When writing to MP_FUNC1.FAULT1_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.FAULT1_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC1__FAULT1_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__FAULT1_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT1_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__FAULT1_PD__GET() gets MP_FUNC1.FAULT1_PD's current value.
 *
 * When reading from MP_FUNC1.FAULT1_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC1.FAULT1_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__FAULT1_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT1_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__FAULT1_PD__MODIFY() modifies MP_FUNC1.FAULT1_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.FAULT1_PD
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__FAULT1_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT1_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__FAULT1_PD__EXTRACT() extracts MP_FUNC1.FAULT1_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.FAULT1_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__FAULT1_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT1_PD__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC1.FAULT1_FUNC ---------------------- */

/**
<pre>
  COMMON.MP_FUNC1.FAULT1_FUNC:

    Pin FAULT1 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "IO" "FAULT1 (GPIO0[2])" "4" "O" "FAN2_PWM"
    1 "IO" "GPIO0[2]" "5" "IO" "SDA2"
    2 "IO" "GPIO1[2]" "6" "I" "UARTRXD"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__FAULT1_FUNC__Pos                       18                                                                     /*!< Right-most bit position of fault1_func in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT1_FUNC__Msk                       (0x00000007UL << COMMON_MP_FUNC1__FAULT1_FUNC__Pos)                    /*!< Mask for fault1_func in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__FAULT1_FUNC__Shift(v)                  (((v) << COMMON_MP_FUNC1__FAULT1_FUNC__Pos) & COMMON_MP_FUNC1__FAULT1_FUNC__Msk) /*!< Shift value 'v' into fault1_func and mask 'v' to fit it into fault1_func field */

/** COMMON_MP_FUNC1__FAULT1_FUNC__SET() sets MP_FUNC1.FAULT1_FUNC to given value.
 *
 * When writing to MP_FUNC1.FAULT1_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.FAULT1_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC1__FAULT1_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__FAULT1_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT1_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__FAULT1_FUNC__GET() gets MP_FUNC1.FAULT1_FUNC's current value.
 *
 * When reading from MP_FUNC1.FAULT1_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC1.FAULT1_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__FAULT1_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT1_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__FAULT1_FUNC__MODIFY() modifies MP_FUNC1.FAULT1_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.FAULT1_FUNC
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__FAULT1_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC1__FAULT1_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__FAULT1_FUNC__EXTRACT() extracts MP_FUNC1.FAULT1_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.FAULT1_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__FAULT1_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__FAULT1_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC1__FAULT1_FUNC__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC1.EN_PPEN ------------------------ */

/**
<pre>
  COMMON.MP_FUNC1.EN_PPEN:

    Pin EN output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__EN_PPEN__Pos                           17                                                                     /*!< Right-most bit position of en_ppen in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__EN_PPEN__Msk                           (0x00000001UL << COMMON_MP_FUNC1__EN_PPEN__Pos)                        /*!< Mask for en_ppen in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__EN_PPEN__Shift(v)                      (((v) << COMMON_MP_FUNC1__EN_PPEN__Pos) & COMMON_MP_FUNC1__EN_PPEN__Msk) /*!< Shift value 'v' into en_ppen and mask 'v' to fit it into en_ppen field */

/** COMMON_MP_FUNC1__EN_PPEN__SET() sets MP_FUNC1.EN_PPEN to given value.
 *
 * When writing to MP_FUNC1.EN_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.EN_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC1__EN_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__EN_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC1__EN_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__EN_PPEN__GET() gets MP_FUNC1.EN_PPEN's current value.
 *
 * When reading from MP_FUNC1.EN_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC1.EN_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__EN_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC1__EN_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__EN_PPEN__MODIFY() modifies MP_FUNC1.EN_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.EN_PPEN
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__EN_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC1__EN_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__EN_PPEN__EXTRACT() extracts MP_FUNC1.EN_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.EN_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__EN_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC1__EN_PPEN__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC1.EN_PU_N ------------------------ */

/**
<pre>
  COMMON.MP_FUNC1.EN_PU_N:

    Pin EN weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__EN_PU_N__Pos                           16                                                                     /*!< Right-most bit position of en_pu_n in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__EN_PU_N__Msk                           (0x00000001UL << COMMON_MP_FUNC1__EN_PU_N__Pos)                        /*!< Mask for en_pu_n in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__EN_PU_N__Shift(v)                      (((v) << COMMON_MP_FUNC1__EN_PU_N__Pos) & COMMON_MP_FUNC1__EN_PU_N__Msk) /*!< Shift value 'v' into en_pu_n and mask 'v' to fit it into en_pu_n field */

/** COMMON_MP_FUNC1__EN_PU_N__SET() sets MP_FUNC1.EN_PU_N to given value.
 *
 * When writing to MP_FUNC1.EN_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.EN_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC1__EN_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__EN_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC1__EN_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__EN_PU_N__GET() gets MP_FUNC1.EN_PU_N's current value.
 *
 * When reading from MP_FUNC1.EN_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC1.EN_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__EN_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC1__EN_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__EN_PU_N__MODIFY() modifies MP_FUNC1.EN_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.EN_PU_N
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__EN_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC1__EN_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__EN_PU_N__EXTRACT() extracts MP_FUNC1.EN_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.EN_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__EN_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC1__EN_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.MP_FUNC1.EN_PD ------------------------- */

/**
<pre>
  COMMON.MP_FUNC1.EN_PD:

    Pin EN weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__EN_PD__Pos                             15                                                                     /*!< Right-most bit position of en_pd in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__EN_PD__Msk                             (0x00000001UL << COMMON_MP_FUNC1__EN_PD__Pos)                          /*!< Mask for en_pd in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__EN_PD__Shift(v)                        (((v) << COMMON_MP_FUNC1__EN_PD__Pos) & COMMON_MP_FUNC1__EN_PD__Msk)   /*!< Shift value 'v' into en_pd and mask 'v' to fit it into en_pd field */

/** COMMON_MP_FUNC1__EN_PD__SET() sets MP_FUNC1.EN_PD to given value.
 *
 * When writing to MP_FUNC1.EN_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.EN_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC1__EN_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__EN_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC1__EN_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__EN_PD__GET() gets MP_FUNC1.EN_PD's current value.
 *
 * When reading from MP_FUNC1.EN_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC1.EN_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__EN_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC1__EN_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__EN_PD__MODIFY() modifies MP_FUNC1.EN_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.EN_PD
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__EN_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC1__EN_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__EN_PD__EXTRACT() extracts MP_FUNC1.EN_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.EN_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__EN_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC1__EN_PD__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC1.EN_FUNC ------------------------ */

/**
<pre>
  COMMON.MP_FUNC1.EN_FUNC:

    Pin EN function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "IO" "EN (GPIO0[0])" "4" "na" "na"
    1 "IO" "GPIO0[0]" "5" "na" "na"
    2 "IO" "GPIO1[0]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__EN_FUNC__Pos                           12                                                                     /*!< Right-most bit position of en_func in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__EN_FUNC__Msk                           (0x00000007UL << COMMON_MP_FUNC1__EN_FUNC__Pos)                        /*!< Mask for en_func in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__EN_FUNC__Shift(v)                      (((v) << COMMON_MP_FUNC1__EN_FUNC__Pos) & COMMON_MP_FUNC1__EN_FUNC__Msk) /*!< Shift value 'v' into en_func and mask 'v' to fit it into en_func field */

/** COMMON_MP_FUNC1__EN_FUNC__SET() sets MP_FUNC1.EN_FUNC to given value.
 *
 * When writing to MP_FUNC1.EN_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.EN_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC1__EN_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__EN_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC1__EN_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__EN_FUNC__GET() gets MP_FUNC1.EN_FUNC's current value.
 *
 * When reading from MP_FUNC1.EN_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC1.EN_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__EN_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC1__EN_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__EN_FUNC__MODIFY() modifies MP_FUNC1.EN_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.EN_FUNC
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__EN_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC1__EN_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__EN_FUNC__EXTRACT() extracts MP_FUNC1.EN_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.EN_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__EN_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__EN_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC1__EN_FUNC__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC1.BPWRGD_PPEN ---------------------- */

/**
<pre>
  COMMON.MP_FUNC1.BPWRGD_PPEN:

    Pin BPWRGD output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__BPWRGD_PPEN__Pos                       11                                                                     /*!< Right-most bit position of bpwrgd_ppen in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BPWRGD_PPEN__Msk                       (0x00000001UL << COMMON_MP_FUNC1__BPWRGD_PPEN__Pos)                    /*!< Mask for bpwrgd_ppen in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BPWRGD_PPEN__Shift(v)                  (((v) << COMMON_MP_FUNC1__BPWRGD_PPEN__Pos) & COMMON_MP_FUNC1__BPWRGD_PPEN__Msk) /*!< Shift value 'v' into bpwrgd_ppen and mask 'v' to fit it into bpwrgd_ppen field */

/** COMMON_MP_FUNC1__BPWRGD_PPEN__SET() sets MP_FUNC1.BPWRGD_PPEN to given value.
 *
 * When writing to MP_FUNC1.BPWRGD_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.BPWRGD_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC1__BPWRGD_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__BPWRGD_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BPWRGD_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__BPWRGD_PPEN__GET() gets MP_FUNC1.BPWRGD_PPEN's current value.
 *
 * When reading from MP_FUNC1.BPWRGD_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC1.BPWRGD_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__BPWRGD_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BPWRGD_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__BPWRGD_PPEN__MODIFY() modifies MP_FUNC1.BPWRGD_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.BPWRGD_PPEN
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__BPWRGD_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BPWRGD_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__BPWRGD_PPEN__EXTRACT() extracts MP_FUNC1.BPWRGD_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.BPWRGD_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__BPWRGD_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BPWRGD_PPEN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC1.BPWRGD_PU_N ---------------------- */

/**
<pre>
  COMMON.MP_FUNC1.BPWRGD_PU_N:

    Pin BPWRGD weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__BPWRGD_PU_N__Pos                       10                                                                     /*!< Right-most bit position of bpwrgd_pu_n in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BPWRGD_PU_N__Msk                       (0x00000001UL << COMMON_MP_FUNC1__BPWRGD_PU_N__Pos)                    /*!< Mask for bpwrgd_pu_n in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BPWRGD_PU_N__Shift(v)                  (((v) << COMMON_MP_FUNC1__BPWRGD_PU_N__Pos) & COMMON_MP_FUNC1__BPWRGD_PU_N__Msk) /*!< Shift value 'v' into bpwrgd_pu_n and mask 'v' to fit it into bpwrgd_pu_n field */

/** COMMON_MP_FUNC1__BPWRGD_PU_N__SET() sets MP_FUNC1.BPWRGD_PU_N to given value.
 *
 * When writing to MP_FUNC1.BPWRGD_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.BPWRGD_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC1__BPWRGD_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__BPWRGD_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BPWRGD_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__BPWRGD_PU_N__GET() gets MP_FUNC1.BPWRGD_PU_N's current value.
 *
 * When reading from MP_FUNC1.BPWRGD_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC1.BPWRGD_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__BPWRGD_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BPWRGD_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__BPWRGD_PU_N__MODIFY() modifies MP_FUNC1.BPWRGD_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.BPWRGD_PU_N
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__BPWRGD_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BPWRGD_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__BPWRGD_PU_N__EXTRACT() extracts MP_FUNC1.BPWRGD_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.BPWRGD_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__BPWRGD_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BPWRGD_PU_N__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC1.BPWRGD_PD ----------------------- */

/**
<pre>
  COMMON.MP_FUNC1.BPWRGD_PD:

    Pin BPWRGD weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__BPWRGD_PD__Pos                         9                                                                      /*!< Right-most bit position of bpwrgd_pd in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BPWRGD_PD__Msk                         (0x00000001UL << COMMON_MP_FUNC1__BPWRGD_PD__Pos)                      /*!< Mask for bpwrgd_pd in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BPWRGD_PD__Shift(v)                    (((v) << COMMON_MP_FUNC1__BPWRGD_PD__Pos) & COMMON_MP_FUNC1__BPWRGD_PD__Msk) /*!< Shift value 'v' into bpwrgd_pd and mask 'v' to fit it into bpwrgd_pd field */

/** COMMON_MP_FUNC1__BPWRGD_PD__SET() sets MP_FUNC1.BPWRGD_PD to given value.
 *
 * When writing to MP_FUNC1.BPWRGD_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.BPWRGD_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC1__BPWRGD_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__BPWRGD_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BPWRGD_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__BPWRGD_PD__GET() gets MP_FUNC1.BPWRGD_PD's current value.
 *
 * When reading from MP_FUNC1.BPWRGD_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC1.BPWRGD_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__BPWRGD_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BPWRGD_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__BPWRGD_PD__MODIFY() modifies MP_FUNC1.BPWRGD_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.BPWRGD_PD
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__BPWRGD_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BPWRGD_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__BPWRGD_PD__EXTRACT() extracts MP_FUNC1.BPWRGD_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.BPWRGD_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__BPWRGD_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BPWRGD_PD__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC1.BPWRGD_FUNC ---------------------- */

/**
<pre>
  COMMON.MP_FUNC1.BPWRGD_FUNC:

    Pin BPWRGD function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "IO" "BPWRGD (GPIO1[1])" "4" "O" "UARTTXD"
    1 "IO" "GPIO0[1]" "5" "IO" "SCL2"
    2 "IO" "GPIO1[1]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__BPWRGD_FUNC__Pos                       6                                                                      /*!< Right-most bit position of bpwrgd_func in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BPWRGD_FUNC__Msk                       (0x00000007UL << COMMON_MP_FUNC1__BPWRGD_FUNC__Pos)                    /*!< Mask for bpwrgd_func in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BPWRGD_FUNC__Shift(v)                  (((v) << COMMON_MP_FUNC1__BPWRGD_FUNC__Pos) & COMMON_MP_FUNC1__BPWRGD_FUNC__Msk) /*!< Shift value 'v' into bpwrgd_func and mask 'v' to fit it into bpwrgd_func field */

/** COMMON_MP_FUNC1__BPWRGD_FUNC__SET() sets MP_FUNC1.BPWRGD_FUNC to given value.
 *
 * When writing to MP_FUNC1.BPWRGD_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.BPWRGD_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC1__BPWRGD_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__BPWRGD_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BPWRGD_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__BPWRGD_FUNC__GET() gets MP_FUNC1.BPWRGD_FUNC's current value.
 *
 * When reading from MP_FUNC1.BPWRGD_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC1.BPWRGD_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__BPWRGD_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BPWRGD_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__BPWRGD_FUNC__MODIFY() modifies MP_FUNC1.BPWRGD_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.BPWRGD_FUNC
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__BPWRGD_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BPWRGD_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__BPWRGD_FUNC__EXTRACT() extracts MP_FUNC1.BPWRGD_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.BPWRGD_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BPWRGD_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__BPWRGD_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BPWRGD_FUNC__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC1.BEN_PPEN ------------------------ */

/**
<pre>
  COMMON.MP_FUNC1.BEN_PPEN:

    Pin BEN output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__BEN_PPEN__Pos                          5                                                                      /*!< Right-most bit position of ben_ppen in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BEN_PPEN__Msk                          (0x00000001UL << COMMON_MP_FUNC1__BEN_PPEN__Pos)                       /*!< Mask for ben_ppen in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BEN_PPEN__Shift(v)                     (((v) << COMMON_MP_FUNC1__BEN_PPEN__Pos) & COMMON_MP_FUNC1__BEN_PPEN__Msk) /*!< Shift value 'v' into ben_ppen and mask 'v' to fit it into ben_ppen field */

/** COMMON_MP_FUNC1__BEN_PPEN__SET() sets MP_FUNC1.BEN_PPEN to given value.
 *
 * When writing to MP_FUNC1.BEN_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.BEN_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC1__BEN_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__BEN_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BEN_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__BEN_PPEN__GET() gets MP_FUNC1.BEN_PPEN's current value.
 *
 * When reading from MP_FUNC1.BEN_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC1.BEN_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__BEN_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BEN_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__BEN_PPEN__MODIFY() modifies MP_FUNC1.BEN_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.BEN_PPEN
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__BEN_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BEN_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__BEN_PPEN__EXTRACT() extracts MP_FUNC1.BEN_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.BEN_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__BEN_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BEN_PPEN__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC1.BEN_PU_N ------------------------ */

/**
<pre>
  COMMON.MP_FUNC1.BEN_PU_N:

    Pin BEN weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__BEN_PU_N__Pos                          4                                                                      /*!< Right-most bit position of ben_pu_n in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BEN_PU_N__Msk                          (0x00000001UL << COMMON_MP_FUNC1__BEN_PU_N__Pos)                       /*!< Mask for ben_pu_n in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BEN_PU_N__Shift(v)                     (((v) << COMMON_MP_FUNC1__BEN_PU_N__Pos) & COMMON_MP_FUNC1__BEN_PU_N__Msk) /*!< Shift value 'v' into ben_pu_n and mask 'v' to fit it into ben_pu_n field */

/** COMMON_MP_FUNC1__BEN_PU_N__SET() sets MP_FUNC1.BEN_PU_N to given value.
 *
 * When writing to MP_FUNC1.BEN_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.BEN_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC1__BEN_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__BEN_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BEN_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__BEN_PU_N__GET() gets MP_FUNC1.BEN_PU_N's current value.
 *
 * When reading from MP_FUNC1.BEN_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC1.BEN_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__BEN_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BEN_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__BEN_PU_N__MODIFY() modifies MP_FUNC1.BEN_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.BEN_PU_N
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__BEN_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BEN_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__BEN_PU_N__EXTRACT() extracts MP_FUNC1.BEN_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.BEN_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__BEN_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BEN_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.MP_FUNC1.BEN_PD ------------------------- */

/**
<pre>
  COMMON.MP_FUNC1.BEN_PD:

    Pin BEN weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__BEN_PD__Pos                            3                                                                      /*!< Right-most bit position of ben_pd in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BEN_PD__Msk                            (0x00000001UL << COMMON_MP_FUNC1__BEN_PD__Pos)                         /*!< Mask for ben_pd in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BEN_PD__Shift(v)                       (((v) << COMMON_MP_FUNC1__BEN_PD__Pos) & COMMON_MP_FUNC1__BEN_PD__Msk) /*!< Shift value 'v' into ben_pd and mask 'v' to fit it into ben_pd field */

/** COMMON_MP_FUNC1__BEN_PD__SET() sets MP_FUNC1.BEN_PD to given value.
 *
 * When writing to MP_FUNC1.BEN_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.BEN_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC1__BEN_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__BEN_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BEN_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__BEN_PD__GET() gets MP_FUNC1.BEN_PD's current value.
 *
 * When reading from MP_FUNC1.BEN_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC1.BEN_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__BEN_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BEN_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__BEN_PD__MODIFY() modifies MP_FUNC1.BEN_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.BEN_PD
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__BEN_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BEN_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__BEN_PD__EXTRACT() extracts MP_FUNC1.BEN_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.BEN_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__BEN_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BEN_PD__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC1.BEN_FUNC ------------------------ */

/**
<pre>
  COMMON.MP_FUNC1.BEN_FUNC:

    Pin BEN function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "IO" "BEN (GPIO1[0])" "4" "I" "UARTRXD"
    1 "IO" "GPIO0[0]" "5" "IO" "SDA2"
    2 "IO" "GPIO1[0]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC1__BEN_FUNC__Pos                          0                                                                      /*!< Right-most bit position of ben_func in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BEN_FUNC__Msk                          (0x00000007UL << COMMON_MP_FUNC1__BEN_FUNC__Pos)                       /*!< Mask for ben_func in COMMON.MP_FUNC1 */
#define COMMON_MP_FUNC1__BEN_FUNC__Shift(v)                     (((v) << COMMON_MP_FUNC1__BEN_FUNC__Pos) & COMMON_MP_FUNC1__BEN_FUNC__Msk) /*!< Shift value 'v' into ben_func and mask 'v' to fit it into ben_func field */

/** COMMON_MP_FUNC1__BEN_FUNC__SET() sets MP_FUNC1.BEN_FUNC to given value.
 *
 * When writing to MP_FUNC1.BEN_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC1.BEN_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC1__BEN_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & ~COMMON_MP_FUNC1__BEN_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BEN_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC1__SET(reg);
}

/** COMMON_MP_FUNC1__BEN_FUNC__GET() gets MP_FUNC1.BEN_FUNC's current value.
 *
 * When reading from MP_FUNC1.BEN_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC1.BEN_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC1__GET();
    reg = (reg & COMMON_MP_FUNC1__BEN_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BEN_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC1__BEN_FUNC__MODIFY() modifies MP_FUNC1.BEN_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @param bf_value new value for MP_FUNC1.BEN_FUNC
 * @return new value of COMMON.MP_FUNC1
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC1__BEN_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC1__BEN_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC1__BEN_FUNC__EXTRACT() extracts MP_FUNC1.BEN_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC1
 * @return current value of MP_FUNC1.BEN_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC1__BEN_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC1__BEN_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC1__BEN_FUNC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        MP_FUNC2 member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_MP_FUNC2__ADDRESS returns the address of member MP_FUNC2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MP_FUNC2
 */
__COMMON_INLINE uint32_t* __COMMON_MP_FUNC2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, MP_FUNC2)));
}

/** COMMON_MP_FUNC2__SET() sets MP_FUNC2 to given value.
 *
 * When writing to MP_FUNC2, this is mandatory to use.
 *
 * @param value new value for MP_FUNC2
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SET(uint32_t value)
{
    HAL_SET32(__COMMON_MP_FUNC2__ADDRESS(), value);
}

/** COMMON_MP_FUNC2__GET() gets MP_FUNC2's current value.
 *
 * When reading from MP_FUNC2, this is mandatory to use.
 *
 * @return current value of MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__GET(void)
{
    return HAL_GET32(__COMMON_MP_FUNC2__ADDRESS());
}

/* -------------------- COMMON.MP_FUNC2.SYNC_DEGLITCH_EN -------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SYNC_DEGLITCH_EN:

    Deglitch enable for digital sync function when used as an input.
    <start table>
    0 "Sync deglitch disabled"
    1 "Sync deglitch enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Pos                  28                                                                     /*!< Right-most bit position of sync_deglitch_en in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Msk                  (0x00000001UL << COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Pos)               /*!< Mask for sync_deglitch_en in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Shift(v)             (((v) << COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Pos) & COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Msk) /*!< Shift value 'v' into sync_deglitch_en and mask 'v' to fit it into sync_deglitch_en field */

/** COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__SET() sets MP_FUNC2.SYNC_DEGLITCH_EN to given value.
 *
 * When writing to MP_FUNC2.SYNC_DEGLITCH_EN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SYNC_DEGLITCH_EN
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__GET() gets MP_FUNC2.SYNC_DEGLITCH_EN's current value.
 *
 * When reading from MP_FUNC2.SYNC_DEGLITCH_EN, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SYNC_DEGLITCH_EN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__MODIFY() modifies MP_FUNC2.SYNC_DEGLITCH_EN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SYNC_DEGLITCH_EN
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__EXTRACT() extracts MP_FUNC2.SYNC_DEGLITCH_EN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SYNC_DEGLITCH_EN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SYNC_DEGLITCH_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.SDA_EN_3V3 ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SDA_EN_3V3:

    Pin SDA 1.8V / 3.3V input threshold select
    <start table>
    0 "1.8V CMOS input"
    1 "3.3V CMOS input"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SDA_EN_3V3__Pos                        27                                                                     /*!< Right-most bit position of sda_en_3v3 in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SDA_EN_3V3__Msk                        (0x00000001UL << COMMON_MP_FUNC2__SDA_EN_3V3__Pos)                     /*!< Mask for sda_en_3v3 in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SDA_EN_3V3__Shift(v)                   (((v) << COMMON_MP_FUNC2__SDA_EN_3V3__Pos) & COMMON_MP_FUNC2__SDA_EN_3V3__Msk) /*!< Shift value 'v' into sda_en_3v3 and mask 'v' to fit it into sda_en_3v3 field */

/** COMMON_MP_FUNC2__SDA_EN_3V3__SET() sets MP_FUNC2.SDA_EN_3V3 to given value.
 *
 * When writing to MP_FUNC2.SDA_EN_3V3, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SDA_EN_3V3
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SDA_EN_3V3__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SDA_EN_3V3__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SDA_EN_3V3__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SDA_EN_3V3__GET() gets MP_FUNC2.SDA_EN_3V3's current value.
 *
 * When reading from MP_FUNC2.SDA_EN_3V3, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SDA_EN_3V3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SDA_EN_3V3__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SDA_EN_3V3__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SDA_EN_3V3__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SDA_EN_3V3__MODIFY() modifies MP_FUNC2.SDA_EN_3V3.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SDA_EN_3V3
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SDA_EN_3V3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SDA_EN_3V3__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SDA_EN_3V3__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SDA_EN_3V3__EXTRACT() extracts MP_FUNC2.SDA_EN_3V3.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SDA_EN_3V3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SDA_EN_3V3__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SDA_EN_3V3__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SDA_EN_3V3__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.MP_FUNC2.SDA_PD ------------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SDA_PD:

    Pin SDA weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SDA_PD__Pos                            26                                                                     /*!< Right-most bit position of sda_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SDA_PD__Msk                            (0x00000001UL << COMMON_MP_FUNC2__SDA_PD__Pos)                         /*!< Mask for sda_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SDA_PD__Shift(v)                       (((v) << COMMON_MP_FUNC2__SDA_PD__Pos) & COMMON_MP_FUNC2__SDA_PD__Msk) /*!< Shift value 'v' into sda_pd and mask 'v' to fit it into sda_pd field */

/** COMMON_MP_FUNC2__SDA_PD__SET() sets MP_FUNC2.SDA_PD to given value.
 *
 * When writing to MP_FUNC2.SDA_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SDA_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SDA_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SDA_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SDA_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SDA_PD__GET() gets MP_FUNC2.SDA_PD's current value.
 *
 * When reading from MP_FUNC2.SDA_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SDA_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SDA_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SDA_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SDA_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SDA_PD__MODIFY() modifies MP_FUNC2.SDA_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SDA_PD
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SDA_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SDA_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SDA_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SDA_PD__EXTRACT() extracts MP_FUNC2.SDA_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SDA_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SDA_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SDA_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SDA_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.SCL_EN_3V3 ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SCL_EN_3V3:

    Pin SCL 1.8V / 3.3V input threshold select
    <start table>
    0 "1.8V CMOS input"
    1 "3.3V CMOS input"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SCL_EN_3V3__Pos                        25                                                                     /*!< Right-most bit position of scl_en_3v3 in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SCL_EN_3V3__Msk                        (0x00000001UL << COMMON_MP_FUNC2__SCL_EN_3V3__Pos)                     /*!< Mask for scl_en_3v3 in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SCL_EN_3V3__Shift(v)                   (((v) << COMMON_MP_FUNC2__SCL_EN_3V3__Pos) & COMMON_MP_FUNC2__SCL_EN_3V3__Msk) /*!< Shift value 'v' into scl_en_3v3 and mask 'v' to fit it into scl_en_3v3 field */

/** COMMON_MP_FUNC2__SCL_EN_3V3__SET() sets MP_FUNC2.SCL_EN_3V3 to given value.
 *
 * When writing to MP_FUNC2.SCL_EN_3V3, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SCL_EN_3V3
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SCL_EN_3V3__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SCL_EN_3V3__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SCL_EN_3V3__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SCL_EN_3V3__GET() gets MP_FUNC2.SCL_EN_3V3's current value.
 *
 * When reading from MP_FUNC2.SCL_EN_3V3, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SCL_EN_3V3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SCL_EN_3V3__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SCL_EN_3V3__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SCL_EN_3V3__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SCL_EN_3V3__MODIFY() modifies MP_FUNC2.SCL_EN_3V3.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SCL_EN_3V3
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SCL_EN_3V3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SCL_EN_3V3__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SCL_EN_3V3__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SCL_EN_3V3__EXTRACT() extracts MP_FUNC2.SCL_EN_3V3.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SCL_EN_3V3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SCL_EN_3V3__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SCL_EN_3V3__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SCL_EN_3V3__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.MP_FUNC2.SCL_PD ------------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SCL_PD:

    Pin SCL weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SCL_PD__Pos                            24                                                                     /*!< Right-most bit position of scl_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SCL_PD__Msk                            (0x00000001UL << COMMON_MP_FUNC2__SCL_PD__Pos)                         /*!< Mask for scl_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SCL_PD__Shift(v)                       (((v) << COMMON_MP_FUNC2__SCL_PD__Pos) & COMMON_MP_FUNC2__SCL_PD__Msk) /*!< Shift value 'v' into scl_pd and mask 'v' to fit it into scl_pd field */

/** COMMON_MP_FUNC2__SCL_PD__SET() sets MP_FUNC2.SCL_PD to given value.
 *
 * When writing to MP_FUNC2.SCL_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SCL_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SCL_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SCL_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SCL_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SCL_PD__GET() gets MP_FUNC2.SCL_PD's current value.
 *
 * When reading from MP_FUNC2.SCL_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SCL_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SCL_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SCL_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SCL_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SCL_PD__MODIFY() modifies MP_FUNC2.SCL_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SCL_PD
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SCL_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SCL_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SCL_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SCL_PD__EXTRACT() extracts MP_FUNC2.SCL_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SCL_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SCL_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SCL_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SCL_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.SYNC_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SYNC_PPEN:

    Pin SYNC output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SYNC_PPEN__Pos                         23                                                                     /*!< Right-most bit position of sync_ppen in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SYNC_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC2__SYNC_PPEN__Pos)                      /*!< Mask for sync_ppen in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SYNC_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC2__SYNC_PPEN__Pos) & COMMON_MP_FUNC2__SYNC_PPEN__Msk) /*!< Shift value 'v' into sync_ppen and mask 'v' to fit it into sync_ppen field */

/** COMMON_MP_FUNC2__SYNC_PPEN__SET() sets MP_FUNC2.SYNC_PPEN to given value.
 *
 * When writing to MP_FUNC2.SYNC_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SYNC_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SYNC_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SYNC_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SYNC_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SYNC_PPEN__GET() gets MP_FUNC2.SYNC_PPEN's current value.
 *
 * When reading from MP_FUNC2.SYNC_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SYNC_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SYNC_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SYNC_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SYNC_PPEN__MODIFY() modifies MP_FUNC2.SYNC_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SYNC_PPEN
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SYNC_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SYNC_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SYNC_PPEN__EXTRACT() extracts MP_FUNC2.SYNC_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SYNC_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SYNC_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SYNC_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.SYNC_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SYNC_PU_N:

    Pin SYNC weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SYNC_PU_N__Pos                         22                                                                     /*!< Right-most bit position of sync_pu_n in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SYNC_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC2__SYNC_PU_N__Pos)                      /*!< Mask for sync_pu_n in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SYNC_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC2__SYNC_PU_N__Pos) & COMMON_MP_FUNC2__SYNC_PU_N__Msk) /*!< Shift value 'v' into sync_pu_n and mask 'v' to fit it into sync_pu_n field */

/** COMMON_MP_FUNC2__SYNC_PU_N__SET() sets MP_FUNC2.SYNC_PU_N to given value.
 *
 * When writing to MP_FUNC2.SYNC_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SYNC_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SYNC_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SYNC_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SYNC_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SYNC_PU_N__GET() gets MP_FUNC2.SYNC_PU_N's current value.
 *
 * When reading from MP_FUNC2.SYNC_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SYNC_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SYNC_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SYNC_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SYNC_PU_N__MODIFY() modifies MP_FUNC2.SYNC_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SYNC_PU_N
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SYNC_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SYNC_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SYNC_PU_N__EXTRACT() extracts MP_FUNC2.SYNC_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SYNC_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SYNC_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SYNC_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC2.SYNC_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC2.SYNC_PD:

    Pin SYNC weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SYNC_PD__Pos                           21                                                                     /*!< Right-most bit position of sync_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SYNC_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC2__SYNC_PD__Pos)                        /*!< Mask for sync_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SYNC_PD__Shift(v)                      (((v) << COMMON_MP_FUNC2__SYNC_PD__Pos) & COMMON_MP_FUNC2__SYNC_PD__Msk) /*!< Shift value 'v' into sync_pd and mask 'v' to fit it into sync_pd field */

/** COMMON_MP_FUNC2__SYNC_PD__SET() sets MP_FUNC2.SYNC_PD to given value.
 *
 * When writing to MP_FUNC2.SYNC_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SYNC_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SYNC_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SYNC_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SYNC_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SYNC_PD__GET() gets MP_FUNC2.SYNC_PD's current value.
 *
 * When reading from MP_FUNC2.SYNC_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SYNC_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SYNC_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SYNC_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SYNC_PD__MODIFY() modifies MP_FUNC2.SYNC_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SYNC_PD
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SYNC_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SYNC_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SYNC_PD__EXTRACT() extracts MP_FUNC2.SYNC_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SYNC_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SYNC_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SYNC_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.SYNC_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SYNC_FUNC:

    Pin SYNC function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "na" "na" "4" "O" "FAN1_PWM"
    1 "IO" "GPIO0[7]" "5" "na" "na"
    2 "IO" "GPIO1[7]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SYNC_FUNC__Pos                         18                                                                     /*!< Right-most bit position of sync_func in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SYNC_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC2__SYNC_FUNC__Pos)                      /*!< Mask for sync_func in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SYNC_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC2__SYNC_FUNC__Pos) & COMMON_MP_FUNC2__SYNC_FUNC__Msk) /*!< Shift value 'v' into sync_func and mask 'v' to fit it into sync_func field */

/** COMMON_MP_FUNC2__SYNC_FUNC__SET() sets MP_FUNC2.SYNC_FUNC to given value.
 *
 * When writing to MP_FUNC2.SYNC_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SYNC_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SYNC_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SYNC_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SYNC_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SYNC_FUNC__GET() gets MP_FUNC2.SYNC_FUNC's current value.
 *
 * When reading from MP_FUNC2.SYNC_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SYNC_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SYNC_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SYNC_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SYNC_FUNC__MODIFY() modifies MP_FUNC2.SYNC_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SYNC_FUNC
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SYNC_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SYNC_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SYNC_FUNC__EXTRACT() extracts MP_FUNC2.SYNC_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SYNC_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SYNC_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SYNC_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SYNC_FUNC__Pos);
    return (uint32_t)reg;
}

/* -------------------- COMMON.MP_FUNC2.SMBALERT_EN_3V3 -------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SMBALERT_EN_3V3:

    Pin SMBALERT 1.8V / 3.3V input threshold select
    <start table>
    0 "1.8V CMOS input"
    1 "3.3V CMOS input"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SMBALERT_EN_3V3__Pos                   17                                                                     /*!< Right-most bit position of smbalert_en_3v3 in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SMBALERT_EN_3V3__Msk                   (0x00000001UL << COMMON_MP_FUNC2__SMBALERT_EN_3V3__Pos)                /*!< Mask for smbalert_en_3v3 in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SMBALERT_EN_3V3__Shift(v)              (((v) << COMMON_MP_FUNC2__SMBALERT_EN_3V3__Pos) & COMMON_MP_FUNC2__SMBALERT_EN_3V3__Msk) /*!< Shift value 'v' into smbalert_en_3v3 and mask 'v' to fit it into smbalert_en_3v3 field */

/** COMMON_MP_FUNC2__SMBALERT_EN_3V3__SET() sets MP_FUNC2.SMBALERT_EN_3V3 to given value.
 *
 * When writing to MP_FUNC2.SMBALERT_EN_3V3, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SMBALERT_EN_3V3
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SMBALERT_EN_3V3__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SMBALERT_EN_3V3__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SMBALERT_EN_3V3__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SMBALERT_EN_3V3__GET() gets MP_FUNC2.SMBALERT_EN_3V3's current value.
 *
 * When reading from MP_FUNC2.SMBALERT_EN_3V3, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SMBALERT_EN_3V3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_EN_3V3__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SMBALERT_EN_3V3__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SMBALERT_EN_3V3__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SMBALERT_EN_3V3__MODIFY() modifies MP_FUNC2.SMBALERT_EN_3V3.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SMBALERT_EN_3V3
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_EN_3V3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SMBALERT_EN_3V3__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SMBALERT_EN_3V3__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SMBALERT_EN_3V3__EXTRACT() extracts MP_FUNC2.SMBALERT_EN_3V3.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SMBALERT_EN_3V3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_EN_3V3__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SMBALERT_EN_3V3__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SMBALERT_EN_3V3__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.MP_FUNC2.SMBALERT_PU_N --------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SMBALERT_PU_N:

    Function not in use.

</pre> */

#define COMMON_MP_FUNC2__SMBALERT_PU_N__Pos                     16                                                                     /*!< Right-most bit position of smbalert_pu_n in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SMBALERT_PU_N__Msk                     (0x00000001UL << COMMON_MP_FUNC2__SMBALERT_PU_N__Pos)                  /*!< Mask for smbalert_pu_n in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SMBALERT_PU_N__Shift(v)                (((v) << COMMON_MP_FUNC2__SMBALERT_PU_N__Pos) & COMMON_MP_FUNC2__SMBALERT_PU_N__Msk) /*!< Shift value 'v' into smbalert_pu_n and mask 'v' to fit it into smbalert_pu_n field */

/** COMMON_MP_FUNC2__SMBALERT_PU_N__SET() sets MP_FUNC2.SMBALERT_PU_N to given value.
 *
 * When writing to MP_FUNC2.SMBALERT_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SMBALERT_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SMBALERT_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SMBALERT_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SMBALERT_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SMBALERT_PU_N__GET() gets MP_FUNC2.SMBALERT_PU_N's current value.
 *
 * When reading from MP_FUNC2.SMBALERT_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SMBALERT_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SMBALERT_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SMBALERT_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SMBALERT_PU_N__MODIFY() modifies MP_FUNC2.SMBALERT_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SMBALERT_PU_N
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SMBALERT_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SMBALERT_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SMBALERT_PU_N__EXTRACT() extracts MP_FUNC2.SMBALERT_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SMBALERT_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SMBALERT_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SMBALERT_PU_N__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC2.SMBALERT_PD ---------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SMBALERT_PD:

    Pin SMBALERT weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SMBALERT_PD__Pos                       15                                                                     /*!< Right-most bit position of smbalert_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SMBALERT_PD__Msk                       (0x00000001UL << COMMON_MP_FUNC2__SMBALERT_PD__Pos)                    /*!< Mask for smbalert_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SMBALERT_PD__Shift(v)                  (((v) << COMMON_MP_FUNC2__SMBALERT_PD__Pos) & COMMON_MP_FUNC2__SMBALERT_PD__Msk) /*!< Shift value 'v' into smbalert_pd and mask 'v' to fit it into smbalert_pd field */

/** COMMON_MP_FUNC2__SMBALERT_PD__SET() sets MP_FUNC2.SMBALERT_PD to given value.
 *
 * When writing to MP_FUNC2.SMBALERT_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SMBALERT_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SMBALERT_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SMBALERT_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SMBALERT_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SMBALERT_PD__GET() gets MP_FUNC2.SMBALERT_PD's current value.
 *
 * When reading from MP_FUNC2.SMBALERT_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SMBALERT_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SMBALERT_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SMBALERT_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SMBALERT_PD__MODIFY() modifies MP_FUNC2.SMBALERT_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SMBALERT_PD
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SMBALERT_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SMBALERT_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SMBALERT_PD__EXTRACT() extracts MP_FUNC2.SMBALERT_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SMBALERT_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SMBALERT_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SMBALERT_PD__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.MP_FUNC2.SMBALERT_FUNC --------------------- */

/**
<pre>
  COMMON.MP_FUNC2.SMBALERT_FUNC:

    Pin SMBALERT function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "IO" "SMBALERT" "4" "IO" "GPIO0[7]"
    1 "IO" "GPIO0[6]" "5" "IO" "GPIO1[7]"
    2 "IO" "GPIO1[6]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__SMBALERT_FUNC__Pos                     12                                                                     /*!< Right-most bit position of smbalert_func in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SMBALERT_FUNC__Msk                     (0x00000007UL << COMMON_MP_FUNC2__SMBALERT_FUNC__Pos)                  /*!< Mask for smbalert_func in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__SMBALERT_FUNC__Shift(v)                (((v) << COMMON_MP_FUNC2__SMBALERT_FUNC__Pos) & COMMON_MP_FUNC2__SMBALERT_FUNC__Msk) /*!< Shift value 'v' into smbalert_func and mask 'v' to fit it into smbalert_func field */

/** COMMON_MP_FUNC2__SMBALERT_FUNC__SET() sets MP_FUNC2.SMBALERT_FUNC to given value.
 *
 * When writing to MP_FUNC2.SMBALERT_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.SMBALERT_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC2__SMBALERT_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__SMBALERT_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SMBALERT_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__SMBALERT_FUNC__GET() gets MP_FUNC2.SMBALERT_FUNC's current value.
 *
 * When reading from MP_FUNC2.SMBALERT_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC2.SMBALERT_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__SMBALERT_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SMBALERT_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__SMBALERT_FUNC__MODIFY() modifies MP_FUNC2.SMBALERT_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.SMBALERT_FUNC
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__SMBALERT_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC2__SMBALERT_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__SMBALERT_FUNC__EXTRACT() extracts MP_FUNC2.SMBALERT_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.SMBALERT_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__SMBALERT_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__SMBALERT_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC2__SMBALERT_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.PWRGD_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.PWRGD_PPEN:

    Pin PWRGD output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__PWRGD_PPEN__Pos                        11                                                                     /*!< Right-most bit position of pwrgd_ppen in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__PWRGD_PPEN__Msk                        (0x00000001UL << COMMON_MP_FUNC2__PWRGD_PPEN__Pos)                     /*!< Mask for pwrgd_ppen in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__PWRGD_PPEN__Shift(v)                   (((v) << COMMON_MP_FUNC2__PWRGD_PPEN__Pos) & COMMON_MP_FUNC2__PWRGD_PPEN__Msk) /*!< Shift value 'v' into pwrgd_ppen and mask 'v' to fit it into pwrgd_ppen field */

/** COMMON_MP_FUNC2__PWRGD_PPEN__SET() sets MP_FUNC2.PWRGD_PPEN to given value.
 *
 * When writing to MP_FUNC2.PWRGD_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.PWRGD_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC2__PWRGD_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__PWRGD_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC2__PWRGD_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__PWRGD_PPEN__GET() gets MP_FUNC2.PWRGD_PPEN's current value.
 *
 * When reading from MP_FUNC2.PWRGD_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC2.PWRGD_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__PWRGD_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC2__PWRGD_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__PWRGD_PPEN__MODIFY() modifies MP_FUNC2.PWRGD_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.PWRGD_PPEN
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__PWRGD_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC2__PWRGD_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__PWRGD_PPEN__EXTRACT() extracts MP_FUNC2.PWRGD_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.PWRGD_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__PWRGD_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC2__PWRGD_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.PWRGD_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.PWRGD_PU_N:

    Pin PWRGD weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__PWRGD_PU_N__Pos                        10                                                                     /*!< Right-most bit position of pwrgd_pu_n in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__PWRGD_PU_N__Msk                        (0x00000001UL << COMMON_MP_FUNC2__PWRGD_PU_N__Pos)                     /*!< Mask for pwrgd_pu_n in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__PWRGD_PU_N__Shift(v)                   (((v) << COMMON_MP_FUNC2__PWRGD_PU_N__Pos) & COMMON_MP_FUNC2__PWRGD_PU_N__Msk) /*!< Shift value 'v' into pwrgd_pu_n and mask 'v' to fit it into pwrgd_pu_n field */

/** COMMON_MP_FUNC2__PWRGD_PU_N__SET() sets MP_FUNC2.PWRGD_PU_N to given value.
 *
 * When writing to MP_FUNC2.PWRGD_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.PWRGD_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC2__PWRGD_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__PWRGD_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC2__PWRGD_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__PWRGD_PU_N__GET() gets MP_FUNC2.PWRGD_PU_N's current value.
 *
 * When reading from MP_FUNC2.PWRGD_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC2.PWRGD_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__PWRGD_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC2__PWRGD_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__PWRGD_PU_N__MODIFY() modifies MP_FUNC2.PWRGD_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.PWRGD_PU_N
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__PWRGD_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC2__PWRGD_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__PWRGD_PU_N__EXTRACT() extracts MP_FUNC2.PWRGD_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.PWRGD_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__PWRGD_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC2__PWRGD_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC2.PWRGD_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC2.PWRGD_PD:

    Pin PWRGD weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__PWRGD_PD__Pos                          9                                                                      /*!< Right-most bit position of pwrgd_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__PWRGD_PD__Msk                          (0x00000001UL << COMMON_MP_FUNC2__PWRGD_PD__Pos)                       /*!< Mask for pwrgd_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__PWRGD_PD__Shift(v)                     (((v) << COMMON_MP_FUNC2__PWRGD_PD__Pos) & COMMON_MP_FUNC2__PWRGD_PD__Msk) /*!< Shift value 'v' into pwrgd_pd and mask 'v' to fit it into pwrgd_pd field */

/** COMMON_MP_FUNC2__PWRGD_PD__SET() sets MP_FUNC2.PWRGD_PD to given value.
 *
 * When writing to MP_FUNC2.PWRGD_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.PWRGD_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC2__PWRGD_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__PWRGD_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__PWRGD_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__PWRGD_PD__GET() gets MP_FUNC2.PWRGD_PD's current value.
 *
 * When reading from MP_FUNC2.PWRGD_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC2.PWRGD_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__PWRGD_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__PWRGD_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__PWRGD_PD__MODIFY() modifies MP_FUNC2.PWRGD_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.PWRGD_PD
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__PWRGD_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__PWRGD_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__PWRGD_PD__EXTRACT() extracts MP_FUNC2.PWRGD_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.PWRGD_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__PWRGD_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__PWRGD_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.PWRGD_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.PWRGD_FUNC:

    Pin PWRGD function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "IO" "PWRGD (GPIO0[1])" "4" "na" "na"
    1 "IO" "GPIO0[1]" "5" "na" "na"
    2 "IO" "GPIO1[1]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__PWRGD_FUNC__Pos                        6                                                                      /*!< Right-most bit position of pwrgd_func in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__PWRGD_FUNC__Msk                        (0x00000007UL << COMMON_MP_FUNC2__PWRGD_FUNC__Pos)                     /*!< Mask for pwrgd_func in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__PWRGD_FUNC__Shift(v)                   (((v) << COMMON_MP_FUNC2__PWRGD_FUNC__Pos) & COMMON_MP_FUNC2__PWRGD_FUNC__Msk) /*!< Shift value 'v' into pwrgd_func and mask 'v' to fit it into pwrgd_func field */

/** COMMON_MP_FUNC2__PWRGD_FUNC__SET() sets MP_FUNC2.PWRGD_FUNC to given value.
 *
 * When writing to MP_FUNC2.PWRGD_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.PWRGD_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC2__PWRGD_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__PWRGD_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC2__PWRGD_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__PWRGD_FUNC__GET() gets MP_FUNC2.PWRGD_FUNC's current value.
 *
 * When reading from MP_FUNC2.PWRGD_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC2.PWRGD_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__PWRGD_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC2__PWRGD_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__PWRGD_FUNC__MODIFY() modifies MP_FUNC2.PWRGD_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.PWRGD_FUNC
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__PWRGD_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC2__PWRGD_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__PWRGD_FUNC__EXTRACT() extracts MP_FUNC2.PWRGD_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.PWRGD_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__PWRGD_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__PWRGD_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC2__PWRGD_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.IMON_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.IMON_PPEN:

    Pin IMON output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__IMON_PPEN__Pos                         5                                                                      /*!< Right-most bit position of imon_ppen in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__IMON_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC2__IMON_PPEN__Pos)                      /*!< Mask for imon_ppen in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__IMON_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC2__IMON_PPEN__Pos) & COMMON_MP_FUNC2__IMON_PPEN__Msk) /*!< Shift value 'v' into imon_ppen and mask 'v' to fit it into imon_ppen field */

/** COMMON_MP_FUNC2__IMON_PPEN__SET() sets MP_FUNC2.IMON_PPEN to given value.
 *
 * When writing to MP_FUNC2.IMON_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.IMON_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC2__IMON_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__IMON_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC2__IMON_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__IMON_PPEN__GET() gets MP_FUNC2.IMON_PPEN's current value.
 *
 * When reading from MP_FUNC2.IMON_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC2.IMON_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__IMON_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC2__IMON_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__IMON_PPEN__MODIFY() modifies MP_FUNC2.IMON_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.IMON_PPEN
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__IMON_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC2__IMON_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__IMON_PPEN__EXTRACT() extracts MP_FUNC2.IMON_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.IMON_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__IMON_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC2__IMON_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.IMON_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.IMON_PU_N:

    Pin IMON weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__IMON_PU_N__Pos                         4                                                                      /*!< Right-most bit position of imon_pu_n in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__IMON_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC2__IMON_PU_N__Pos)                      /*!< Mask for imon_pu_n in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__IMON_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC2__IMON_PU_N__Pos) & COMMON_MP_FUNC2__IMON_PU_N__Msk) /*!< Shift value 'v' into imon_pu_n and mask 'v' to fit it into imon_pu_n field */

/** COMMON_MP_FUNC2__IMON_PU_N__SET() sets MP_FUNC2.IMON_PU_N to given value.
 *
 * When writing to MP_FUNC2.IMON_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.IMON_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC2__IMON_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__IMON_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC2__IMON_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__IMON_PU_N__GET() gets MP_FUNC2.IMON_PU_N's current value.
 *
 * When reading from MP_FUNC2.IMON_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC2.IMON_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__IMON_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC2__IMON_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__IMON_PU_N__MODIFY() modifies MP_FUNC2.IMON_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.IMON_PU_N
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__IMON_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC2__IMON_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__IMON_PU_N__EXTRACT() extracts MP_FUNC2.IMON_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.IMON_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__IMON_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC2__IMON_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC2.IMON_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC2.IMON_PD:

    Pin IMON weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__IMON_PD__Pos                           3                                                                      /*!< Right-most bit position of imon_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__IMON_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC2__IMON_PD__Pos)                        /*!< Mask for imon_pd in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__IMON_PD__Shift(v)                      (((v) << COMMON_MP_FUNC2__IMON_PD__Pos) & COMMON_MP_FUNC2__IMON_PD__Msk) /*!< Shift value 'v' into imon_pd and mask 'v' to fit it into imon_pd field */

/** COMMON_MP_FUNC2__IMON_PD__SET() sets MP_FUNC2.IMON_PD to given value.
 *
 * When writing to MP_FUNC2.IMON_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.IMON_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC2__IMON_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__IMON_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__IMON_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__IMON_PD__GET() gets MP_FUNC2.IMON_PD's current value.
 *
 * When reading from MP_FUNC2.IMON_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC2.IMON_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__IMON_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__IMON_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__IMON_PD__MODIFY() modifies MP_FUNC2.IMON_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.IMON_PD
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__IMON_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC2__IMON_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__IMON_PD__EXTRACT() extracts MP_FUNC2.IMON_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.IMON_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__IMON_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC2__IMON_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC2.IMON_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC2.IMON_FUNC:

    Pin IMON function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "Analog" "IMON" "4" "I" "FAN1_TACH"
    1 "IO" "GPIO0[3]" "5" "na" "na"
    2 "IO" "GPIO1[3]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC2__IMON_FUNC__Pos                         0                                                                      /*!< Right-most bit position of imon_func in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__IMON_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC2__IMON_FUNC__Pos)                      /*!< Mask for imon_func in COMMON.MP_FUNC2 */
#define COMMON_MP_FUNC2__IMON_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC2__IMON_FUNC__Pos) & COMMON_MP_FUNC2__IMON_FUNC__Msk) /*!< Shift value 'v' into imon_func and mask 'v' to fit it into imon_func field */

/** COMMON_MP_FUNC2__IMON_FUNC__SET() sets MP_FUNC2.IMON_FUNC to given value.
 *
 * When writing to MP_FUNC2.IMON_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC2.IMON_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC2__IMON_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & ~COMMON_MP_FUNC2__IMON_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC2__IMON_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC2__SET(reg);
}

/** COMMON_MP_FUNC2__IMON_FUNC__GET() gets MP_FUNC2.IMON_FUNC's current value.
 *
 * When reading from MP_FUNC2.IMON_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC2.IMON_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC2__GET();
    reg = (reg & COMMON_MP_FUNC2__IMON_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC2__IMON_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC2__IMON_FUNC__MODIFY() modifies MP_FUNC2.IMON_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @param bf_value new value for MP_FUNC2.IMON_FUNC
 * @return new value of COMMON.MP_FUNC2
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC2__IMON_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC2__IMON_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC2__IMON_FUNC__EXTRACT() extracts MP_FUNC2.IMON_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC2
 * @return current value of MP_FUNC2.IMON_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC2__IMON_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC2__IMON_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC2__IMON_FUNC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        MP_FUNC3 member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_MP_FUNC3__ADDRESS returns the address of member MP_FUNC3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MP_FUNC3
 */
__COMMON_INLINE uint32_t* __COMMON_MP_FUNC3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, MP_FUNC3)));
}

/** COMMON_MP_FUNC3__SET() sets MP_FUNC3 to given value.
 *
 * When writing to MP_FUNC3, this is mandatory to use.
 *
 * @param value new value for MP_FUNC3
 */
__COMMON_INLINE void COMMON_MP_FUNC3__SET(uint32_t value)
{
    HAL_SET32(__COMMON_MP_FUNC3__ADDRESS(), value);
}

/** COMMON_MP_FUNC3__GET() gets MP_FUNC3's current value.
 *
 * When reading from MP_FUNC3, this is mandatory to use.
 *
 * @return current value of MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__GET(void)
{
    return HAL_GET32(__COMMON_MP_FUNC3__ADDRESS());
}

/* ----------------------- COMMON.MP_FUNC3.PWM5_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM5_PPEN:

    Pin PWM5 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM5_PPEN__Pos                         29                                                                     /*!< Right-most bit position of pwm5_ppen in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM5_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC3__PWM5_PPEN__Pos)                      /*!< Mask for pwm5_ppen in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM5_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM5_PPEN__Pos) & COMMON_MP_FUNC3__PWM5_PPEN__Msk) /*!< Shift value 'v' into pwm5_ppen and mask 'v' to fit it into pwm5_ppen field */

/** COMMON_MP_FUNC3__PWM5_PPEN__SET() sets MP_FUNC3.PWM5_PPEN to given value.
 *
 * When writing to MP_FUNC3.PWM5_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM5_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM5_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM5_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM5_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM5_PPEN__GET() gets MP_FUNC3.PWM5_PPEN's current value.
 *
 * When reading from MP_FUNC3.PWM5_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM5_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM5_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM5_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM5_PPEN__MODIFY() modifies MP_FUNC3.PWM5_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM5_PPEN
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM5_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM5_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM5_PPEN__EXTRACT() extracts MP_FUNC3.PWM5_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM5_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM5_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM5_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM5_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM5_PU_N:

    Pin PWM5 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM5_PU_N__Pos                         28                                                                     /*!< Right-most bit position of pwm5_pu_n in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM5_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC3__PWM5_PU_N__Pos)                      /*!< Mask for pwm5_pu_n in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM5_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM5_PU_N__Pos) & COMMON_MP_FUNC3__PWM5_PU_N__Msk) /*!< Shift value 'v' into pwm5_pu_n and mask 'v' to fit it into pwm5_pu_n field */

/** COMMON_MP_FUNC3__PWM5_PU_N__SET() sets MP_FUNC3.PWM5_PU_N to given value.
 *
 * When writing to MP_FUNC3.PWM5_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM5_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM5_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM5_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM5_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM5_PU_N__GET() gets MP_FUNC3.PWM5_PU_N's current value.
 *
 * When reading from MP_FUNC3.PWM5_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM5_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM5_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM5_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM5_PU_N__MODIFY() modifies MP_FUNC3.PWM5_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM5_PU_N
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM5_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM5_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM5_PU_N__EXTRACT() extracts MP_FUNC3.PWM5_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM5_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM5_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM5_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC3.PWM5_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC3.PWM5_PD:

    Pin PWM5 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM5_PD__Pos                           27                                                                     /*!< Right-most bit position of pwm5_pd in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM5_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC3__PWM5_PD__Pos)                        /*!< Mask for pwm5_pd in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM5_PD__Shift(v)                      (((v) << COMMON_MP_FUNC3__PWM5_PD__Pos) & COMMON_MP_FUNC3__PWM5_PD__Msk) /*!< Shift value 'v' into pwm5_pd and mask 'v' to fit it into pwm5_pd field */

/** COMMON_MP_FUNC3__PWM5_PD__SET() sets MP_FUNC3.PWM5_PD to given value.
 *
 * When writing to MP_FUNC3.PWM5_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM5_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM5_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM5_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM5_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM5_PD__GET() gets MP_FUNC3.PWM5_PD's current value.
 *
 * When reading from MP_FUNC3.PWM5_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM5_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM5_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM5_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM5_PD__MODIFY() modifies MP_FUNC3.PWM5_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM5_PD
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM5_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM5_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM5_PD__EXTRACT() extracts MP_FUNC3.PWM5_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM5_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM5_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM5_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM5_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM5_FUNC:

    Pin PWM5 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM5" "4" "I" "UARTRXD"
    1 "IO" "GPIO0[3]" "5" "na" "na"
    2 "IO" "GPIO1[3]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM5_FUNC__Pos                         24                                                                     /*!< Right-most bit position of pwm5_func in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM5_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC3__PWM5_FUNC__Pos)                      /*!< Mask for pwm5_func in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM5_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM5_FUNC__Pos) & COMMON_MP_FUNC3__PWM5_FUNC__Msk) /*!< Shift value 'v' into pwm5_func and mask 'v' to fit it into pwm5_func field */

/** COMMON_MP_FUNC3__PWM5_FUNC__SET() sets MP_FUNC3.PWM5_FUNC to given value.
 *
 * When writing to MP_FUNC3.PWM5_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM5_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM5_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM5_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM5_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM5_FUNC__GET() gets MP_FUNC3.PWM5_FUNC's current value.
 *
 * When reading from MP_FUNC3.PWM5_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM5_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM5_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM5_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM5_FUNC__MODIFY() modifies MP_FUNC3.PWM5_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM5_FUNC
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM5_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM5_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM5_FUNC__EXTRACT() extracts MP_FUNC3.PWM5_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM5_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM5_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM5_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM5_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM4_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM4_PPEN:

    Pin PWM4 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM4_PPEN__Pos                         23                                                                     /*!< Right-most bit position of pwm4_ppen in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM4_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC3__PWM4_PPEN__Pos)                      /*!< Mask for pwm4_ppen in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM4_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM4_PPEN__Pos) & COMMON_MP_FUNC3__PWM4_PPEN__Msk) /*!< Shift value 'v' into pwm4_ppen and mask 'v' to fit it into pwm4_ppen field */

/** COMMON_MP_FUNC3__PWM4_PPEN__SET() sets MP_FUNC3.PWM4_PPEN to given value.
 *
 * When writing to MP_FUNC3.PWM4_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM4_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM4_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM4_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM4_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM4_PPEN__GET() gets MP_FUNC3.PWM4_PPEN's current value.
 *
 * When reading from MP_FUNC3.PWM4_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM4_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM4_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM4_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM4_PPEN__MODIFY() modifies MP_FUNC3.PWM4_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM4_PPEN
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM4_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM4_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM4_PPEN__EXTRACT() extracts MP_FUNC3.PWM4_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM4_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM4_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM4_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM4_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM4_PU_N:

    Pin PWM4 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM4_PU_N__Pos                         22                                                                     /*!< Right-most bit position of pwm4_pu_n in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM4_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC3__PWM4_PU_N__Pos)                      /*!< Mask for pwm4_pu_n in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM4_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM4_PU_N__Pos) & COMMON_MP_FUNC3__PWM4_PU_N__Msk) /*!< Shift value 'v' into pwm4_pu_n and mask 'v' to fit it into pwm4_pu_n field */

/** COMMON_MP_FUNC3__PWM4_PU_N__SET() sets MP_FUNC3.PWM4_PU_N to given value.
 *
 * When writing to MP_FUNC3.PWM4_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM4_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM4_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM4_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM4_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM4_PU_N__GET() gets MP_FUNC3.PWM4_PU_N's current value.
 *
 * When reading from MP_FUNC3.PWM4_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM4_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM4_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM4_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM4_PU_N__MODIFY() modifies MP_FUNC3.PWM4_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM4_PU_N
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM4_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM4_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM4_PU_N__EXTRACT() extracts MP_FUNC3.PWM4_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM4_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM4_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM4_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC3.PWM4_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC3.PWM4_PD:

    Pin PWM4 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM4_PD__Pos                           21                                                                     /*!< Right-most bit position of pwm4_pd in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM4_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC3__PWM4_PD__Pos)                        /*!< Mask for pwm4_pd in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM4_PD__Shift(v)                      (((v) << COMMON_MP_FUNC3__PWM4_PD__Pos) & COMMON_MP_FUNC3__PWM4_PD__Msk) /*!< Shift value 'v' into pwm4_pd and mask 'v' to fit it into pwm4_pd field */

/** COMMON_MP_FUNC3__PWM4_PD__SET() sets MP_FUNC3.PWM4_PD to given value.
 *
 * When writing to MP_FUNC3.PWM4_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM4_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM4_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM4_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM4_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM4_PD__GET() gets MP_FUNC3.PWM4_PD's current value.
 *
 * When reading from MP_FUNC3.PWM4_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM4_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM4_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM4_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM4_PD__MODIFY() modifies MP_FUNC3.PWM4_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM4_PD
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM4_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM4_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM4_PD__EXTRACT() extracts MP_FUNC3.PWM4_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM4_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM4_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM4_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM4_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM4_FUNC:

    Pin PWM4 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM4" "4" "na" "na"
    1 "IO" "GPIO0[2]" "5" "na" "na"
    2 "IO" "GPIO1[2]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM4_FUNC__Pos                         18                                                                     /*!< Right-most bit position of pwm4_func in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM4_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC3__PWM4_FUNC__Pos)                      /*!< Mask for pwm4_func in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM4_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM4_FUNC__Pos) & COMMON_MP_FUNC3__PWM4_FUNC__Msk) /*!< Shift value 'v' into pwm4_func and mask 'v' to fit it into pwm4_func field */

/** COMMON_MP_FUNC3__PWM4_FUNC__SET() sets MP_FUNC3.PWM4_FUNC to given value.
 *
 * When writing to MP_FUNC3.PWM4_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM4_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM4_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM4_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM4_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM4_FUNC__GET() gets MP_FUNC3.PWM4_FUNC's current value.
 *
 * When reading from MP_FUNC3.PWM4_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM4_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM4_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM4_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM4_FUNC__MODIFY() modifies MP_FUNC3.PWM4_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM4_FUNC
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM4_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM4_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM4_FUNC__EXTRACT() extracts MP_FUNC3.PWM4_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM4_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM4_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM4_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM4_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM3_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM3_PPEN:

    Pin PWM3 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM3_PPEN__Pos                         17                                                                     /*!< Right-most bit position of pwm3_ppen in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM3_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC3__PWM3_PPEN__Pos)                      /*!< Mask for pwm3_ppen in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM3_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM3_PPEN__Pos) & COMMON_MP_FUNC3__PWM3_PPEN__Msk) /*!< Shift value 'v' into pwm3_ppen and mask 'v' to fit it into pwm3_ppen field */

/** COMMON_MP_FUNC3__PWM3_PPEN__SET() sets MP_FUNC3.PWM3_PPEN to given value.
 *
 * When writing to MP_FUNC3.PWM3_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM3_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM3_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM3_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM3_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM3_PPEN__GET() gets MP_FUNC3.PWM3_PPEN's current value.
 *
 * When reading from MP_FUNC3.PWM3_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM3_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM3_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM3_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM3_PPEN__MODIFY() modifies MP_FUNC3.PWM3_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM3_PPEN
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM3_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM3_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM3_PPEN__EXTRACT() extracts MP_FUNC3.PWM3_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM3_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM3_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM3_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM3_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM3_PU_N:

    Pin PWM3 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM3_PU_N__Pos                         16                                                                     /*!< Right-most bit position of pwm3_pu_n in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM3_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC3__PWM3_PU_N__Pos)                      /*!< Mask for pwm3_pu_n in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM3_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM3_PU_N__Pos) & COMMON_MP_FUNC3__PWM3_PU_N__Msk) /*!< Shift value 'v' into pwm3_pu_n and mask 'v' to fit it into pwm3_pu_n field */

/** COMMON_MP_FUNC3__PWM3_PU_N__SET() sets MP_FUNC3.PWM3_PU_N to given value.
 *
 * When writing to MP_FUNC3.PWM3_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM3_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM3_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM3_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM3_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM3_PU_N__GET() gets MP_FUNC3.PWM3_PU_N's current value.
 *
 * When reading from MP_FUNC3.PWM3_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM3_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM3_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM3_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM3_PU_N__MODIFY() modifies MP_FUNC3.PWM3_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM3_PU_N
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM3_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM3_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM3_PU_N__EXTRACT() extracts MP_FUNC3.PWM3_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM3_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM3_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM3_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC3.PWM3_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC3.PWM3_PD:

    Pin PWM3 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM3_PD__Pos                           15                                                                     /*!< Right-most bit position of pwm3_pd in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM3_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC3__PWM3_PD__Pos)                        /*!< Mask for pwm3_pd in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM3_PD__Shift(v)                      (((v) << COMMON_MP_FUNC3__PWM3_PD__Pos) & COMMON_MP_FUNC3__PWM3_PD__Msk) /*!< Shift value 'v' into pwm3_pd and mask 'v' to fit it into pwm3_pd field */

/** COMMON_MP_FUNC3__PWM3_PD__SET() sets MP_FUNC3.PWM3_PD to given value.
 *
 * When writing to MP_FUNC3.PWM3_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM3_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM3_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM3_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM3_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM3_PD__GET() gets MP_FUNC3.PWM3_PD's current value.
 *
 * When reading from MP_FUNC3.PWM3_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM3_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM3_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM3_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM3_PD__MODIFY() modifies MP_FUNC3.PWM3_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM3_PD
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM3_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM3_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM3_PD__EXTRACT() extracts MP_FUNC3.PWM3_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM3_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM3_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM3_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM3_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM3_FUNC:

    Pin PWM3 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM3" "4" "na" "na"
    1 "IO" "GPIO0[1]" "5" "na" "na"
    2 "IO" "GPIO1[1]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM3_FUNC__Pos                         12                                                                     /*!< Right-most bit position of pwm3_func in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM3_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC3__PWM3_FUNC__Pos)                      /*!< Mask for pwm3_func in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM3_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM3_FUNC__Pos) & COMMON_MP_FUNC3__PWM3_FUNC__Msk) /*!< Shift value 'v' into pwm3_func and mask 'v' to fit it into pwm3_func field */

/** COMMON_MP_FUNC3__PWM3_FUNC__SET() sets MP_FUNC3.PWM3_FUNC to given value.
 *
 * When writing to MP_FUNC3.PWM3_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM3_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM3_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM3_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM3_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM3_FUNC__GET() gets MP_FUNC3.PWM3_FUNC's current value.
 *
 * When reading from MP_FUNC3.PWM3_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM3_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM3_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM3_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM3_FUNC__MODIFY() modifies MP_FUNC3.PWM3_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM3_FUNC
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM3_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM3_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM3_FUNC__EXTRACT() extracts MP_FUNC3.PWM3_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM3_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM3_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM3_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM3_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM2_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM2_PPEN:

    Pin PWM2 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM2_PPEN__Pos                         11                                                                     /*!< Right-most bit position of pwm2_ppen in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM2_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC3__PWM2_PPEN__Pos)                      /*!< Mask for pwm2_ppen in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM2_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM2_PPEN__Pos) & COMMON_MP_FUNC3__PWM2_PPEN__Msk) /*!< Shift value 'v' into pwm2_ppen and mask 'v' to fit it into pwm2_ppen field */

/** COMMON_MP_FUNC3__PWM2_PPEN__SET() sets MP_FUNC3.PWM2_PPEN to given value.
 *
 * When writing to MP_FUNC3.PWM2_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM2_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM2_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM2_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM2_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM2_PPEN__GET() gets MP_FUNC3.PWM2_PPEN's current value.
 *
 * When reading from MP_FUNC3.PWM2_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM2_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM2_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM2_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM2_PPEN__MODIFY() modifies MP_FUNC3.PWM2_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM2_PPEN
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM2_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM2_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM2_PPEN__EXTRACT() extracts MP_FUNC3.PWM2_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM2_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM2_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM2_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM2_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM2_PU_N:

    Pin PWM2 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM2_PU_N__Pos                         10                                                                     /*!< Right-most bit position of pwm2_pu_n in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM2_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC3__PWM2_PU_N__Pos)                      /*!< Mask for pwm2_pu_n in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM2_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM2_PU_N__Pos) & COMMON_MP_FUNC3__PWM2_PU_N__Msk) /*!< Shift value 'v' into pwm2_pu_n and mask 'v' to fit it into pwm2_pu_n field */

/** COMMON_MP_FUNC3__PWM2_PU_N__SET() sets MP_FUNC3.PWM2_PU_N to given value.
 *
 * When writing to MP_FUNC3.PWM2_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM2_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM2_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM2_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM2_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM2_PU_N__GET() gets MP_FUNC3.PWM2_PU_N's current value.
 *
 * When reading from MP_FUNC3.PWM2_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM2_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM2_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM2_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM2_PU_N__MODIFY() modifies MP_FUNC3.PWM2_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM2_PU_N
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM2_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM2_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM2_PU_N__EXTRACT() extracts MP_FUNC3.PWM2_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM2_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM2_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM2_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC3.PWM2_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC3.PWM2_PD:

    Pin PWM2 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM2_PD__Pos                           9                                                                      /*!< Right-most bit position of pwm2_pd in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM2_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC3__PWM2_PD__Pos)                        /*!< Mask for pwm2_pd in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM2_PD__Shift(v)                      (((v) << COMMON_MP_FUNC3__PWM2_PD__Pos) & COMMON_MP_FUNC3__PWM2_PD__Msk) /*!< Shift value 'v' into pwm2_pd and mask 'v' to fit it into pwm2_pd field */

/** COMMON_MP_FUNC3__PWM2_PD__SET() sets MP_FUNC3.PWM2_PD to given value.
 *
 * When writing to MP_FUNC3.PWM2_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM2_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM2_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM2_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM2_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM2_PD__GET() gets MP_FUNC3.PWM2_PD's current value.
 *
 * When reading from MP_FUNC3.PWM2_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM2_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM2_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM2_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM2_PD__MODIFY() modifies MP_FUNC3.PWM2_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM2_PD
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM2_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM2_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM2_PD__EXTRACT() extracts MP_FUNC3.PWM2_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM2_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM2_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM2_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM2_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM2_FUNC:

    Pin PWM2 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM2" "4" "na" "na"
    1 "IO" "GPIO0[7]" "5" "na" "na"
    2 "IO" "GPIO1[7]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM2_FUNC__Pos                         6                                                                      /*!< Right-most bit position of pwm2_func in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM2_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC3__PWM2_FUNC__Pos)                      /*!< Mask for pwm2_func in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM2_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM2_FUNC__Pos) & COMMON_MP_FUNC3__PWM2_FUNC__Msk) /*!< Shift value 'v' into pwm2_func and mask 'v' to fit it into pwm2_func field */

/** COMMON_MP_FUNC3__PWM2_FUNC__SET() sets MP_FUNC3.PWM2_FUNC to given value.
 *
 * When writing to MP_FUNC3.PWM2_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM2_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM2_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM2_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM2_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM2_FUNC__GET() gets MP_FUNC3.PWM2_FUNC's current value.
 *
 * When reading from MP_FUNC3.PWM2_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM2_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM2_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM2_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM2_FUNC__MODIFY() modifies MP_FUNC3.PWM2_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM2_FUNC
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM2_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM2_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM2_FUNC__EXTRACT() extracts MP_FUNC3.PWM2_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM2_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM2_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM2_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM2_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM1_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM1_PPEN:

    Pin PWM1 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM1_PPEN__Pos                         5                                                                      /*!< Right-most bit position of pwm1_ppen in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM1_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC3__PWM1_PPEN__Pos)                      /*!< Mask for pwm1_ppen in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM1_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM1_PPEN__Pos) & COMMON_MP_FUNC3__PWM1_PPEN__Msk) /*!< Shift value 'v' into pwm1_ppen and mask 'v' to fit it into pwm1_ppen field */

/** COMMON_MP_FUNC3__PWM1_PPEN__SET() sets MP_FUNC3.PWM1_PPEN to given value.
 *
 * When writing to MP_FUNC3.PWM1_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM1_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM1_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM1_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM1_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM1_PPEN__GET() gets MP_FUNC3.PWM1_PPEN's current value.
 *
 * When reading from MP_FUNC3.PWM1_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM1_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM1_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM1_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM1_PPEN__MODIFY() modifies MP_FUNC3.PWM1_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM1_PPEN
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM1_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM1_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM1_PPEN__EXTRACT() extracts MP_FUNC3.PWM1_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM1_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM1_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM1_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM1_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM1_PU_N:

    Pin PWM1 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM1_PU_N__Pos                         4                                                                      /*!< Right-most bit position of pwm1_pu_n in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM1_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC3__PWM1_PU_N__Pos)                      /*!< Mask for pwm1_pu_n in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM1_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM1_PU_N__Pos) & COMMON_MP_FUNC3__PWM1_PU_N__Msk) /*!< Shift value 'v' into pwm1_pu_n and mask 'v' to fit it into pwm1_pu_n field */

/** COMMON_MP_FUNC3__PWM1_PU_N__SET() sets MP_FUNC3.PWM1_PU_N to given value.
 *
 * When writing to MP_FUNC3.PWM1_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM1_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM1_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM1_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM1_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM1_PU_N__GET() gets MP_FUNC3.PWM1_PU_N's current value.
 *
 * When reading from MP_FUNC3.PWM1_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM1_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM1_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM1_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM1_PU_N__MODIFY() modifies MP_FUNC3.PWM1_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM1_PU_N
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM1_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM1_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM1_PU_N__EXTRACT() extracts MP_FUNC3.PWM1_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM1_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM1_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM1_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC3.PWM1_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC3.PWM1_PD:

    Pin PWM1 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM1_PD__Pos                           3                                                                      /*!< Right-most bit position of pwm1_pd in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM1_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC3__PWM1_PD__Pos)                        /*!< Mask for pwm1_pd in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM1_PD__Shift(v)                      (((v) << COMMON_MP_FUNC3__PWM1_PD__Pos) & COMMON_MP_FUNC3__PWM1_PD__Msk) /*!< Shift value 'v' into pwm1_pd and mask 'v' to fit it into pwm1_pd field */

/** COMMON_MP_FUNC3__PWM1_PD__SET() sets MP_FUNC3.PWM1_PD to given value.
 *
 * When writing to MP_FUNC3.PWM1_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM1_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM1_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM1_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM1_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM1_PD__GET() gets MP_FUNC3.PWM1_PD's current value.
 *
 * When reading from MP_FUNC3.PWM1_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM1_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM1_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM1_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM1_PD__MODIFY() modifies MP_FUNC3.PWM1_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM1_PD
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM1_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM1_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM1_PD__EXTRACT() extracts MP_FUNC3.PWM1_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM1_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM1_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM1_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC3.PWM1_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC3.PWM1_FUNC:

    Pin PWM1 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM1" "4" "na" "na"
    1 "IO" "GPIO0[5]" "5" "na" "na"
    2 "IO" "GPIO1[5]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC3__PWM1_FUNC__Pos                         0                                                                      /*!< Right-most bit position of pwm1_func in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM1_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC3__PWM1_FUNC__Pos)                      /*!< Mask for pwm1_func in COMMON.MP_FUNC3 */
#define COMMON_MP_FUNC3__PWM1_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC3__PWM1_FUNC__Pos) & COMMON_MP_FUNC3__PWM1_FUNC__Msk) /*!< Shift value 'v' into pwm1_func and mask 'v' to fit it into pwm1_func field */

/** COMMON_MP_FUNC3__PWM1_FUNC__SET() sets MP_FUNC3.PWM1_FUNC to given value.
 *
 * When writing to MP_FUNC3.PWM1_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC3.PWM1_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC3__PWM1_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & ~COMMON_MP_FUNC3__PWM1_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM1_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC3__SET(reg);
}

/** COMMON_MP_FUNC3__PWM1_FUNC__GET() gets MP_FUNC3.PWM1_FUNC's current value.
 *
 * When reading from MP_FUNC3.PWM1_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC3.PWM1_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC3__GET();
    reg = (reg & COMMON_MP_FUNC3__PWM1_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM1_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC3__PWM1_FUNC__MODIFY() modifies MP_FUNC3.PWM1_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @param bf_value new value for MP_FUNC3.PWM1_FUNC
 * @return new value of COMMON.MP_FUNC3
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC3__PWM1_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC3__PWM1_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC3__PWM1_FUNC__EXTRACT() extracts MP_FUNC3.PWM1_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC3
 * @return current value of MP_FUNC3.PWM1_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC3__PWM1_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC3__PWM1_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC3__PWM1_FUNC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        MP_FUNC4 member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_MP_FUNC4__ADDRESS returns the address of member MP_FUNC4.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MP_FUNC4
 */
__COMMON_INLINE uint32_t* __COMMON_MP_FUNC4__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, MP_FUNC4)));
}

/** COMMON_MP_FUNC4__SET() sets MP_FUNC4 to given value.
 *
 * When writing to MP_FUNC4, this is mandatory to use.
 *
 * @param value new value for MP_FUNC4
 */
__COMMON_INLINE void COMMON_MP_FUNC4__SET(uint32_t value)
{
    HAL_SET32(__COMMON_MP_FUNC4__ADDRESS(), value);
}

/** COMMON_MP_FUNC4__GET() gets MP_FUNC4's current value.
 *
 * When reading from MP_FUNC4, this is mandatory to use.
 *
 * @return current value of MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__GET(void)
{
    return HAL_GET32(__COMMON_MP_FUNC4__ADDRESS());
}

/* ------------------ COMMON.MP_FUNC4.FORCE_PWM56_IN_EN_N ------------------ */

/**
<pre>
  COMMON.MP_FUNC4.FORCE_PWM56_IN_EN_N:

    For test use only.  Set to 1 for normal operation.
    <start table>
    0 "Force enables the inputs buffers on PWM5, PWM6"
    1 "PWM5, PWM6 input buffer enable controlled by functional logic"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Pos               31                                                                     /*!< Right-most bit position of force_pwm56_in_en_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Msk               (0x00000001UL << COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Pos)            /*!< Mask for force_pwm56_in_en_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Shift(v)          (((v) << COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Pos) & COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Msk) /*!< Shift value 'v' into force_pwm56_in_en_n and mask 'v' to fit it into force_pwm56_in_en_n field */

/** COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__SET() sets MP_FUNC4.FORCE_PWM56_IN_EN_N to given value.
 *
 * When writing to MP_FUNC4.FORCE_PWM56_IN_EN_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.FORCE_PWM56_IN_EN_N
 */
__COMMON_INLINE void COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__GET() gets MP_FUNC4.FORCE_PWM56_IN_EN_N's current value.
 *
 * When reading from MP_FUNC4.FORCE_PWM56_IN_EN_N, this is recommended to use.
 *
 * @return current value of MP_FUNC4.FORCE_PWM56_IN_EN_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__MODIFY() modifies MP_FUNC4.FORCE_PWM56_IN_EN_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.FORCE_PWM56_IN_EN_N
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__EXTRACT() extracts MP_FUNC4.FORCE_PWM56_IN_EN_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.FORCE_PWM56_IN_EN_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__FORCE_PWM56_IN_EN_N__Pos);
    return (uint32_t)reg;
}

/* -------------------- COMMON.MP_FUNC4.PWM6_STATIC_HIZ -------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM6_STATIC_HIZ:

    Pin PWM6 Static HiZ control.  Pin PWM6 has a special otput buffer with Tri-state bias resistors for use with integrated power stage drivers.
    <start table>
    0 "tri-state biasing disabled (typical usage)"
    1 "tri-state biasing enabled (integrated power stage useage)"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Pos                   30                                                                     /*!< Right-most bit position of pwm6_static_hiz in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Msk                   (0x00000001UL << COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Pos)                /*!< Mask for pwm6_static_hiz in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Shift(v)              (((v) << COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Pos) & COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Msk) /*!< Shift value 'v' into pwm6_static_hiz and mask 'v' to fit it into pwm6_static_hiz field */

/** COMMON_MP_FUNC4__PWM6_STATIC_HIZ__SET() sets MP_FUNC4.PWM6_STATIC_HIZ to given value.
 *
 * When writing to MP_FUNC4.PWM6_STATIC_HIZ, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM6_STATIC_HIZ
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM6_STATIC_HIZ__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM6_STATIC_HIZ__GET() gets MP_FUNC4.PWM6_STATIC_HIZ's current value.
 *
 * When reading from MP_FUNC4.PWM6_STATIC_HIZ, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM6_STATIC_HIZ
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_STATIC_HIZ__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM6_STATIC_HIZ__MODIFY() modifies MP_FUNC4.PWM6_STATIC_HIZ.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM6_STATIC_HIZ
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_STATIC_HIZ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM6_STATIC_HIZ__EXTRACT() extracts MP_FUNC4.PWM6_STATIC_HIZ.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM6_STATIC_HIZ
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_STATIC_HIZ__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM6_STATIC_HIZ__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM10_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM10_PPEN:

    Pin PWM10 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM10_PPEN__Pos                        29                                                                     /*!< Right-most bit position of pwm10_ppen in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM10_PPEN__Msk                        (0x00000001UL << COMMON_MP_FUNC4__PWM10_PPEN__Pos)                     /*!< Mask for pwm10_ppen in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM10_PPEN__Shift(v)                   (((v) << COMMON_MP_FUNC4__PWM10_PPEN__Pos) & COMMON_MP_FUNC4__PWM10_PPEN__Msk) /*!< Shift value 'v' into pwm10_ppen and mask 'v' to fit it into pwm10_ppen field */

/** COMMON_MP_FUNC4__PWM10_PPEN__SET() sets MP_FUNC4.PWM10_PPEN to given value.
 *
 * When writing to MP_FUNC4.PWM10_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM10_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM10_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM10_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM10_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM10_PPEN__GET() gets MP_FUNC4.PWM10_PPEN's current value.
 *
 * When reading from MP_FUNC4.PWM10_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM10_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM10_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM10_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM10_PPEN__MODIFY() modifies MP_FUNC4.PWM10_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM10_PPEN
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM10_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM10_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM10_PPEN__EXTRACT() extracts MP_FUNC4.PWM10_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM10_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM10_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM10_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM10_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM10_PU_N:

    Pin PWM10 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM10_PU_N__Pos                        28                                                                     /*!< Right-most bit position of pwm10_pu_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM10_PU_N__Msk                        (0x00000001UL << COMMON_MP_FUNC4__PWM10_PU_N__Pos)                     /*!< Mask for pwm10_pu_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM10_PU_N__Shift(v)                   (((v) << COMMON_MP_FUNC4__PWM10_PU_N__Pos) & COMMON_MP_FUNC4__PWM10_PU_N__Msk) /*!< Shift value 'v' into pwm10_pu_n and mask 'v' to fit it into pwm10_pu_n field */

/** COMMON_MP_FUNC4__PWM10_PU_N__SET() sets MP_FUNC4.PWM10_PU_N to given value.
 *
 * When writing to MP_FUNC4.PWM10_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM10_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM10_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM10_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM10_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM10_PU_N__GET() gets MP_FUNC4.PWM10_PU_N's current value.
 *
 * When reading from MP_FUNC4.PWM10_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM10_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM10_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM10_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM10_PU_N__MODIFY() modifies MP_FUNC4.PWM10_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM10_PU_N
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM10_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM10_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM10_PU_N__EXTRACT() extracts MP_FUNC4.PWM10_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM10_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM10_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM10_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC4.PWM10_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC4.PWM10_PD:

    Pin PWM10 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM10_PD__Pos                          27                                                                     /*!< Right-most bit position of pwm10_pd in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM10_PD__Msk                          (0x00000001UL << COMMON_MP_FUNC4__PWM10_PD__Pos)                       /*!< Mask for pwm10_pd in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM10_PD__Shift(v)                     (((v) << COMMON_MP_FUNC4__PWM10_PD__Pos) & COMMON_MP_FUNC4__PWM10_PD__Msk) /*!< Shift value 'v' into pwm10_pd and mask 'v' to fit it into pwm10_pd field */

/** COMMON_MP_FUNC4__PWM10_PD__SET() sets MP_FUNC4.PWM10_PD to given value.
 *
 * When writing to MP_FUNC4.PWM10_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM10_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM10_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM10_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM10_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM10_PD__GET() gets MP_FUNC4.PWM10_PD's current value.
 *
 * When reading from MP_FUNC4.PWM10_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM10_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM10_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM10_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM10_PD__MODIFY() modifies MP_FUNC4.PWM10_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM10_PD
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM10_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM10_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM10_PD__EXTRACT() extracts MP_FUNC4.PWM10_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM10_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM10_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM10_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM10_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM10_FUNC:

    Pin PWM10 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM10" "4" "na" "na"
    1 "IO" "GPIO0[5]" "5" "na" "na"
    2 "IO" "GPIO1[5]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM10_FUNC__Pos                        24                                                                     /*!< Right-most bit position of pwm10_func in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM10_FUNC__Msk                        (0x00000007UL << COMMON_MP_FUNC4__PWM10_FUNC__Pos)                     /*!< Mask for pwm10_func in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM10_FUNC__Shift(v)                   (((v) << COMMON_MP_FUNC4__PWM10_FUNC__Pos) & COMMON_MP_FUNC4__PWM10_FUNC__Msk) /*!< Shift value 'v' into pwm10_func and mask 'v' to fit it into pwm10_func field */

/** COMMON_MP_FUNC4__PWM10_FUNC__SET() sets MP_FUNC4.PWM10_FUNC to given value.
 *
 * When writing to MP_FUNC4.PWM10_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM10_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM10_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM10_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM10_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM10_FUNC__GET() gets MP_FUNC4.PWM10_FUNC's current value.
 *
 * When reading from MP_FUNC4.PWM10_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM10_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM10_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM10_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM10_FUNC__MODIFY() modifies MP_FUNC4.PWM10_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM10_FUNC
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM10_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM10_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM10_FUNC__EXTRACT() extracts MP_FUNC4.PWM10_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM10_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM10_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM10_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM10_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM9_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM9_PPEN:

    Pin PWM9 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM9_PPEN__Pos                         23                                                                     /*!< Right-most bit position of pwm9_ppen in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM9_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC4__PWM9_PPEN__Pos)                      /*!< Mask for pwm9_ppen in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM9_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM9_PPEN__Pos) & COMMON_MP_FUNC4__PWM9_PPEN__Msk) /*!< Shift value 'v' into pwm9_ppen and mask 'v' to fit it into pwm9_ppen field */

/** COMMON_MP_FUNC4__PWM9_PPEN__SET() sets MP_FUNC4.PWM9_PPEN to given value.
 *
 * When writing to MP_FUNC4.PWM9_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM9_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM9_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM9_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM9_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM9_PPEN__GET() gets MP_FUNC4.PWM9_PPEN's current value.
 *
 * When reading from MP_FUNC4.PWM9_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM9_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM9_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM9_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM9_PPEN__MODIFY() modifies MP_FUNC4.PWM9_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM9_PPEN
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM9_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM9_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM9_PPEN__EXTRACT() extracts MP_FUNC4.PWM9_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM9_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM9_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM9_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM9_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM9_PU_N:

    Pin PWM9 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM9_PU_N__Pos                         22                                                                     /*!< Right-most bit position of pwm9_pu_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM9_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC4__PWM9_PU_N__Pos)                      /*!< Mask for pwm9_pu_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM9_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM9_PU_N__Pos) & COMMON_MP_FUNC4__PWM9_PU_N__Msk) /*!< Shift value 'v' into pwm9_pu_n and mask 'v' to fit it into pwm9_pu_n field */

/** COMMON_MP_FUNC4__PWM9_PU_N__SET() sets MP_FUNC4.PWM9_PU_N to given value.
 *
 * When writing to MP_FUNC4.PWM9_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM9_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM9_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM9_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM9_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM9_PU_N__GET() gets MP_FUNC4.PWM9_PU_N's current value.
 *
 * When reading from MP_FUNC4.PWM9_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM9_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM9_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM9_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM9_PU_N__MODIFY() modifies MP_FUNC4.PWM9_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM9_PU_N
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM9_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM9_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM9_PU_N__EXTRACT() extracts MP_FUNC4.PWM9_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM9_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM9_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM9_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC4.PWM9_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC4.PWM9_PD:

    Pin PWM9 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM9_PD__Pos                           21                                                                     /*!< Right-most bit position of pwm9_pd in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM9_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC4__PWM9_PD__Pos)                        /*!< Mask for pwm9_pd in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM9_PD__Shift(v)                      (((v) << COMMON_MP_FUNC4__PWM9_PD__Pos) & COMMON_MP_FUNC4__PWM9_PD__Msk) /*!< Shift value 'v' into pwm9_pd and mask 'v' to fit it into pwm9_pd field */

/** COMMON_MP_FUNC4__PWM9_PD__SET() sets MP_FUNC4.PWM9_PD to given value.
 *
 * When writing to MP_FUNC4.PWM9_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM9_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM9_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM9_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM9_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM9_PD__GET() gets MP_FUNC4.PWM9_PD's current value.
 *
 * When reading from MP_FUNC4.PWM9_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM9_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM9_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM9_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM9_PD__MODIFY() modifies MP_FUNC4.PWM9_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM9_PD
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM9_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM9_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM9_PD__EXTRACT() extracts MP_FUNC4.PWM9_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM9_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM9_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM9_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM9_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM9_FUNC:

    Pin PWM9 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM9" "4" "na" "na"
    1 "IO" "GPIO0[4]" "5" "na" "na"
    2 "IO" "GPIO1[4]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM9_FUNC__Pos                         18                                                                     /*!< Right-most bit position of pwm9_func in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM9_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC4__PWM9_FUNC__Pos)                      /*!< Mask for pwm9_func in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM9_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM9_FUNC__Pos) & COMMON_MP_FUNC4__PWM9_FUNC__Msk) /*!< Shift value 'v' into pwm9_func and mask 'v' to fit it into pwm9_func field */

/** COMMON_MP_FUNC4__PWM9_FUNC__SET() sets MP_FUNC4.PWM9_FUNC to given value.
 *
 * When writing to MP_FUNC4.PWM9_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM9_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM9_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM9_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM9_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM9_FUNC__GET() gets MP_FUNC4.PWM9_FUNC's current value.
 *
 * When reading from MP_FUNC4.PWM9_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM9_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM9_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM9_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM9_FUNC__MODIFY() modifies MP_FUNC4.PWM9_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM9_FUNC
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM9_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM9_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM9_FUNC__EXTRACT() extracts MP_FUNC4.PWM9_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM9_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM9_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM9_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM9_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM8_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM8_PPEN:

    Pin PWM8 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM8_PPEN__Pos                         17                                                                     /*!< Right-most bit position of pwm8_ppen in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM8_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC4__PWM8_PPEN__Pos)                      /*!< Mask for pwm8_ppen in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM8_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM8_PPEN__Pos) & COMMON_MP_FUNC4__PWM8_PPEN__Msk) /*!< Shift value 'v' into pwm8_ppen and mask 'v' to fit it into pwm8_ppen field */

/** COMMON_MP_FUNC4__PWM8_PPEN__SET() sets MP_FUNC4.PWM8_PPEN to given value.
 *
 * When writing to MP_FUNC4.PWM8_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM8_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM8_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM8_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM8_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM8_PPEN__GET() gets MP_FUNC4.PWM8_PPEN's current value.
 *
 * When reading from MP_FUNC4.PWM8_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM8_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM8_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM8_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM8_PPEN__MODIFY() modifies MP_FUNC4.PWM8_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM8_PPEN
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM8_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM8_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM8_PPEN__EXTRACT() extracts MP_FUNC4.PWM8_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM8_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM8_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM8_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM8_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM8_PU_N:

    Pin PWM8 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM8_PU_N__Pos                         16                                                                     /*!< Right-most bit position of pwm8_pu_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM8_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC4__PWM8_PU_N__Pos)                      /*!< Mask for pwm8_pu_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM8_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM8_PU_N__Pos) & COMMON_MP_FUNC4__PWM8_PU_N__Msk) /*!< Shift value 'v' into pwm8_pu_n and mask 'v' to fit it into pwm8_pu_n field */

/** COMMON_MP_FUNC4__PWM8_PU_N__SET() sets MP_FUNC4.PWM8_PU_N to given value.
 *
 * When writing to MP_FUNC4.PWM8_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM8_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM8_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM8_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM8_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM8_PU_N__GET() gets MP_FUNC4.PWM8_PU_N's current value.
 *
 * When reading from MP_FUNC4.PWM8_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM8_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM8_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM8_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM8_PU_N__MODIFY() modifies MP_FUNC4.PWM8_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM8_PU_N
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM8_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM8_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM8_PU_N__EXTRACT() extracts MP_FUNC4.PWM8_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM8_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM8_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM8_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC4.PWM8_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC4.PWM8_PD:

    Pin PWM8 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM8_PD__Pos                           15                                                                     /*!< Right-most bit position of pwm8_pd in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM8_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC4__PWM8_PD__Pos)                        /*!< Mask for pwm8_pd in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM8_PD__Shift(v)                      (((v) << COMMON_MP_FUNC4__PWM8_PD__Pos) & COMMON_MP_FUNC4__PWM8_PD__Msk) /*!< Shift value 'v' into pwm8_pd and mask 'v' to fit it into pwm8_pd field */

/** COMMON_MP_FUNC4__PWM8_PD__SET() sets MP_FUNC4.PWM8_PD to given value.
 *
 * When writing to MP_FUNC4.PWM8_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM8_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM8_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM8_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM8_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM8_PD__GET() gets MP_FUNC4.PWM8_PD's current value.
 *
 * When reading from MP_FUNC4.PWM8_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM8_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM8_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM8_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM8_PD__MODIFY() modifies MP_FUNC4.PWM8_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM8_PD
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM8_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM8_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM8_PD__EXTRACT() extracts MP_FUNC4.PWM8_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM8_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM8_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM8_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM8_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM8_FUNC:

    Pin PWM8 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM8" "4" "I" "FAN2_TACH"
    1 "IO" "GPIO0[6]" "5" "na" "na"
    2 "IO" "GPIO1[6]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM8_FUNC__Pos                         12                                                                     /*!< Right-most bit position of pwm8_func in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM8_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC4__PWM8_FUNC__Pos)                      /*!< Mask for pwm8_func in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM8_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM8_FUNC__Pos) & COMMON_MP_FUNC4__PWM8_FUNC__Msk) /*!< Shift value 'v' into pwm8_func and mask 'v' to fit it into pwm8_func field */

/** COMMON_MP_FUNC4__PWM8_FUNC__SET() sets MP_FUNC4.PWM8_FUNC to given value.
 *
 * When writing to MP_FUNC4.PWM8_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM8_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM8_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM8_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM8_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM8_FUNC__GET() gets MP_FUNC4.PWM8_FUNC's current value.
 *
 * When reading from MP_FUNC4.PWM8_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM8_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM8_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM8_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM8_FUNC__MODIFY() modifies MP_FUNC4.PWM8_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM8_FUNC
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM8_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM8_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM8_FUNC__EXTRACT() extracts MP_FUNC4.PWM8_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM8_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM8_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM8_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM8_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM7_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM7_PPEN:

    Pin PWM7 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM7_PPEN__Pos                         11                                                                     /*!< Right-most bit position of pwm7_ppen in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM7_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC4__PWM7_PPEN__Pos)                      /*!< Mask for pwm7_ppen in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM7_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM7_PPEN__Pos) & COMMON_MP_FUNC4__PWM7_PPEN__Msk) /*!< Shift value 'v' into pwm7_ppen and mask 'v' to fit it into pwm7_ppen field */

/** COMMON_MP_FUNC4__PWM7_PPEN__SET() sets MP_FUNC4.PWM7_PPEN to given value.
 *
 * When writing to MP_FUNC4.PWM7_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM7_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM7_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM7_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM7_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM7_PPEN__GET() gets MP_FUNC4.PWM7_PPEN's current value.
 *
 * When reading from MP_FUNC4.PWM7_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM7_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM7_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM7_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM7_PPEN__MODIFY() modifies MP_FUNC4.PWM7_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM7_PPEN
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM7_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM7_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM7_PPEN__EXTRACT() extracts MP_FUNC4.PWM7_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM7_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM7_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM7_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM7_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM7_PU_N:

    Pin PWM7 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM7_PU_N__Pos                         10                                                                     /*!< Right-most bit position of pwm7_pu_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM7_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC4__PWM7_PU_N__Pos)                      /*!< Mask for pwm7_pu_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM7_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM7_PU_N__Pos) & COMMON_MP_FUNC4__PWM7_PU_N__Msk) /*!< Shift value 'v' into pwm7_pu_n and mask 'v' to fit it into pwm7_pu_n field */

/** COMMON_MP_FUNC4__PWM7_PU_N__SET() sets MP_FUNC4.PWM7_PU_N to given value.
 *
 * When writing to MP_FUNC4.PWM7_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM7_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM7_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM7_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM7_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM7_PU_N__GET() gets MP_FUNC4.PWM7_PU_N's current value.
 *
 * When reading from MP_FUNC4.PWM7_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM7_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM7_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM7_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM7_PU_N__MODIFY() modifies MP_FUNC4.PWM7_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM7_PU_N
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM7_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM7_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM7_PU_N__EXTRACT() extracts MP_FUNC4.PWM7_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM7_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM7_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM7_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC4.PWM7_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC4.PWM7_PD:

    Pin PWM7 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM7_PD__Pos                           9                                                                      /*!< Right-most bit position of pwm7_pd in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM7_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC4__PWM7_PD__Pos)                        /*!< Mask for pwm7_pd in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM7_PD__Shift(v)                      (((v) << COMMON_MP_FUNC4__PWM7_PD__Pos) & COMMON_MP_FUNC4__PWM7_PD__Msk) /*!< Shift value 'v' into pwm7_pd and mask 'v' to fit it into pwm7_pd field */

/** COMMON_MP_FUNC4__PWM7_PD__SET() sets MP_FUNC4.PWM7_PD to given value.
 *
 * When writing to MP_FUNC4.PWM7_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM7_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM7_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM7_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM7_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM7_PD__GET() gets MP_FUNC4.PWM7_PD's current value.
 *
 * When reading from MP_FUNC4.PWM7_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM7_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM7_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM7_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM7_PD__MODIFY() modifies MP_FUNC4.PWM7_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM7_PD
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM7_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM7_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM7_PD__EXTRACT() extracts MP_FUNC4.PWM7_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM7_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM7_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM7_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM7_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM7_FUNC:

    Pin PWM7 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM7" "4" "O" "FAN2_PWM"
    1 "IO" "GPIO0[5]" "5" "na" "na"
    2 "IO" "GPIO1[5]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM7_FUNC__Pos                         6                                                                      /*!< Right-most bit position of pwm7_func in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM7_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC4__PWM7_FUNC__Pos)                      /*!< Mask for pwm7_func in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM7_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM7_FUNC__Pos) & COMMON_MP_FUNC4__PWM7_FUNC__Msk) /*!< Shift value 'v' into pwm7_func and mask 'v' to fit it into pwm7_func field */

/** COMMON_MP_FUNC4__PWM7_FUNC__SET() sets MP_FUNC4.PWM7_FUNC to given value.
 *
 * When writing to MP_FUNC4.PWM7_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM7_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM7_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM7_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM7_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM7_FUNC__GET() gets MP_FUNC4.PWM7_FUNC's current value.
 *
 * When reading from MP_FUNC4.PWM7_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM7_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM7_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM7_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM7_FUNC__MODIFY() modifies MP_FUNC4.PWM7_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM7_FUNC
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM7_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM7_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM7_FUNC__EXTRACT() extracts MP_FUNC4.PWM7_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM7_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM7_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM7_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM7_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM6_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM6_PPEN:

    Pin PWM6 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM6_PPEN__Pos                         5                                                                      /*!< Right-most bit position of pwm6_ppen in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM6_PPEN__Msk                         (0x00000001UL << COMMON_MP_FUNC4__PWM6_PPEN__Pos)                      /*!< Mask for pwm6_ppen in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM6_PPEN__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM6_PPEN__Pos) & COMMON_MP_FUNC4__PWM6_PPEN__Msk) /*!< Shift value 'v' into pwm6_ppen and mask 'v' to fit it into pwm6_ppen field */

/** COMMON_MP_FUNC4__PWM6_PPEN__SET() sets MP_FUNC4.PWM6_PPEN to given value.
 *
 * When writing to MP_FUNC4.PWM6_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM6_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM6_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM6_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM6_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM6_PPEN__GET() gets MP_FUNC4.PWM6_PPEN's current value.
 *
 * When reading from MP_FUNC4.PWM6_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM6_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM6_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM6_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM6_PPEN__MODIFY() modifies MP_FUNC4.PWM6_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM6_PPEN
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM6_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM6_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM6_PPEN__EXTRACT() extracts MP_FUNC4.PWM6_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM6_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM6_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM6_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM6_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM6_PU_N:

    Pin PWM6 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM6_PU_N__Pos                         4                                                                      /*!< Right-most bit position of pwm6_pu_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM6_PU_N__Msk                         (0x00000001UL << COMMON_MP_FUNC4__PWM6_PU_N__Pos)                      /*!< Mask for pwm6_pu_n in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM6_PU_N__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM6_PU_N__Pos) & COMMON_MP_FUNC4__PWM6_PU_N__Msk) /*!< Shift value 'v' into pwm6_pu_n and mask 'v' to fit it into pwm6_pu_n field */

/** COMMON_MP_FUNC4__PWM6_PU_N__SET() sets MP_FUNC4.PWM6_PU_N to given value.
 *
 * When writing to MP_FUNC4.PWM6_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM6_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM6_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM6_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM6_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM6_PU_N__GET() gets MP_FUNC4.PWM6_PU_N's current value.
 *
 * When reading from MP_FUNC4.PWM6_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM6_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM6_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM6_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM6_PU_N__MODIFY() modifies MP_FUNC4.PWM6_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM6_PU_N
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM6_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM6_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM6_PU_N__EXTRACT() extracts MP_FUNC4.PWM6_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM6_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM6_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM6_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC4.PWM6_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC4.PWM6_PD:

    Pin PWM6 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM6_PD__Pos                           3                                                                      /*!< Right-most bit position of pwm6_pd in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM6_PD__Msk                           (0x00000001UL << COMMON_MP_FUNC4__PWM6_PD__Pos)                        /*!< Mask for pwm6_pd in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM6_PD__Shift(v)                      (((v) << COMMON_MP_FUNC4__PWM6_PD__Pos) & COMMON_MP_FUNC4__PWM6_PD__Msk) /*!< Shift value 'v' into pwm6_pd and mask 'v' to fit it into pwm6_pd field */

/** COMMON_MP_FUNC4__PWM6_PD__SET() sets MP_FUNC4.PWM6_PD to given value.
 *
 * When writing to MP_FUNC4.PWM6_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM6_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM6_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM6_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM6_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM6_PD__GET() gets MP_FUNC4.PWM6_PD's current value.
 *
 * When reading from MP_FUNC4.PWM6_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM6_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM6_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM6_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM6_PD__MODIFY() modifies MP_FUNC4.PWM6_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM6_PD
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM6_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM6_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM6_PD__EXTRACT() extracts MP_FUNC4.PWM6_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM6_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM6_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM6_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC4.PWM6_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC4.PWM6_FUNC:

    Pin PWM6 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM6" "4" "O" "UARTTXD"
    1 "IO" "GPIO0[4]" "5" "na" "na"
    2 "IO" "GPIO1[4]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC4__PWM6_FUNC__Pos                         0                                                                      /*!< Right-most bit position of pwm6_func in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM6_FUNC__Msk                         (0x00000007UL << COMMON_MP_FUNC4__PWM6_FUNC__Pos)                      /*!< Mask for pwm6_func in COMMON.MP_FUNC4 */
#define COMMON_MP_FUNC4__PWM6_FUNC__Shift(v)                    (((v) << COMMON_MP_FUNC4__PWM6_FUNC__Pos) & COMMON_MP_FUNC4__PWM6_FUNC__Msk) /*!< Shift value 'v' into pwm6_func and mask 'v' to fit it into pwm6_func field */

/** COMMON_MP_FUNC4__PWM6_FUNC__SET() sets MP_FUNC4.PWM6_FUNC to given value.
 *
 * When writing to MP_FUNC4.PWM6_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC4.PWM6_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC4__PWM6_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & ~COMMON_MP_FUNC4__PWM6_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM6_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC4__SET(reg);
}

/** COMMON_MP_FUNC4__PWM6_FUNC__GET() gets MP_FUNC4.PWM6_FUNC's current value.
 *
 * When reading from MP_FUNC4.PWM6_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC4.PWM6_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC4__GET();
    reg = (reg & COMMON_MP_FUNC4__PWM6_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM6_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC4__PWM6_FUNC__MODIFY() modifies MP_FUNC4.PWM6_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @param bf_value new value for MP_FUNC4.PWM6_FUNC
 * @return new value of COMMON.MP_FUNC4
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC4__PWM6_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC4__PWM6_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC4__PWM6_FUNC__EXTRACT() extracts MP_FUNC4.PWM6_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC4
 * @return current value of MP_FUNC4.PWM6_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC4__PWM6_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC4__PWM6_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC4__PWM6_FUNC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        MP_FUNC5 member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_MP_FUNC5__ADDRESS returns the address of member MP_FUNC5.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MP_FUNC5
 */
__COMMON_INLINE uint32_t* __COMMON_MP_FUNC5__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, MP_FUNC5)));
}

/** COMMON_MP_FUNC5__SET() sets MP_FUNC5 to given value.
 *
 * When writing to MP_FUNC5, this is mandatory to use.
 *
 * @param value new value for MP_FUNC5
 */
__COMMON_INLINE void COMMON_MP_FUNC5__SET(uint32_t value)
{
    HAL_SET32(__COMMON_MP_FUNC5__ADDRESS(), value);
}

/** COMMON_MP_FUNC5__GET() gets MP_FUNC5's current value.
 *
 * When reading from MP_FUNC5, this is mandatory to use.
 *
 * @return current value of MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GET(void)
{
    return HAL_GET32(__COMMON_MP_FUNC5__ADDRESS());
}

/* ------------------------ COMMON.MP_FUNC5.FBAL_MAX ------------------------ */

/**
<pre>
  COMMON.MP_FUNC5.FBAL_MAX:

    Flux / Voltage balance max correction.  This register limits the maximum duty cycle correction applied by the flux balance filter.
    LSB = 0.09766 %, Range = 0.0 to 24.90234 %

</pre> */

#define COMMON_MP_FUNC5__FBAL_MAX__Pos                          23                                                                     /*!< Right-most bit position of fbal_max in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__FBAL_MAX__Msk                          (0x000000FFUL << COMMON_MP_FUNC5__FBAL_MAX__Pos)                       /*!< Mask for fbal_max in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__FBAL_MAX__Shift(v)                     (((v) << COMMON_MP_FUNC5__FBAL_MAX__Pos) & COMMON_MP_FUNC5__FBAL_MAX__Msk) /*!< Shift value 'v' into fbal_max and mask 'v' to fit it into fbal_max field */

/** COMMON_MP_FUNC5__FBAL_MAX__SET() sets MP_FUNC5.FBAL_MAX to given value.
 *
 * When writing to MP_FUNC5.FBAL_MAX, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.FBAL_MAX
 */
__COMMON_INLINE void COMMON_MP_FUNC5__FBAL_MAX__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__FBAL_MAX__Msk);
    reg = (reg | (COMMON_MP_FUNC5__FBAL_MAX__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__FBAL_MAX__GET() gets MP_FUNC5.FBAL_MAX's current value.
 *
 * When reading from MP_FUNC5.FBAL_MAX, this is recommended to use.
 *
 * @return current value of MP_FUNC5.FBAL_MAX
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__FBAL_MAX__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__FBAL_MAX__Msk);
    reg = (reg >> COMMON_MP_FUNC5__FBAL_MAX__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__FBAL_MAX__MODIFY() modifies MP_FUNC5.FBAL_MAX.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.FBAL_MAX
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__FBAL_MAX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__FBAL_MAX__Msk);
    reg = (reg | (COMMON_MP_FUNC5__FBAL_MAX__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__FBAL_MAX__EXTRACT() extracts MP_FUNC5.FBAL_MAX.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.FBAL_MAX
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__FBAL_MAX__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__FBAL_MAX__Msk);
    reg = (reg >> COMMON_MP_FUNC5__FBAL_MAX__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC5.GPIO_DLY ------------------------ */

/**
<pre>
  COMMON.MP_FUNC5.GPIO_DLY:

    Defines deglitch time on GPIO input buffers.  The GPIO input must be stable for the defined time (clocked at 25MHz) to be passed through the deglitcher.  A setting of 0 disables the deglitch function.  This register applies to all GPIO inputs.
    LSB = 40ns, Range = 0.0 to 280ns

</pre> */

#define COMMON_MP_FUNC5__GPIO_DLY__Pos                          20                                                                     /*!< Right-most bit position of gpio_dly in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO_DLY__Msk                          (0x00000007UL << COMMON_MP_FUNC5__GPIO_DLY__Pos)                       /*!< Mask for gpio_dly in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO_DLY__Shift(v)                     (((v) << COMMON_MP_FUNC5__GPIO_DLY__Pos) & COMMON_MP_FUNC5__GPIO_DLY__Msk) /*!< Shift value 'v' into gpio_dly and mask 'v' to fit it into gpio_dly field */

/** COMMON_MP_FUNC5__GPIO_DLY__SET() sets MP_FUNC5.GPIO_DLY to given value.
 *
 * When writing to MP_FUNC5.GPIO_DLY, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.GPIO_DLY
 */
__COMMON_INLINE void COMMON_MP_FUNC5__GPIO_DLY__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__GPIO_DLY__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO_DLY__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__GPIO_DLY__GET() gets MP_FUNC5.GPIO_DLY's current value.
 *
 * When reading from MP_FUNC5.GPIO_DLY, this is recommended to use.
 *
 * @return current value of MP_FUNC5.GPIO_DLY
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO_DLY__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__GPIO_DLY__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO_DLY__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__GPIO_DLY__MODIFY() modifies MP_FUNC5.GPIO_DLY.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.GPIO_DLY
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO_DLY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__GPIO_DLY__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO_DLY__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__GPIO_DLY__EXTRACT() extracts MP_FUNC5.GPIO_DLY.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.GPIO_DLY
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO_DLY__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__GPIO_DLY__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO_DLY__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC5.GPIO1_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC5.GPIO1_PPEN:

    Function not in use.

</pre> */

#define COMMON_MP_FUNC5__GPIO1_PPEN__Pos                        19                                                                     /*!< Right-most bit position of gpio1_ppen in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_PPEN__Msk                        (0x00000001UL << COMMON_MP_FUNC5__GPIO1_PPEN__Pos)                     /*!< Mask for gpio1_ppen in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_PPEN__Shift(v)                   (((v) << COMMON_MP_FUNC5__GPIO1_PPEN__Pos) & COMMON_MP_FUNC5__GPIO1_PPEN__Msk) /*!< Shift value 'v' into gpio1_ppen and mask 'v' to fit it into gpio1_ppen field */

/** COMMON_MP_FUNC5__GPIO1_PPEN__SET() sets MP_FUNC5.GPIO1_PPEN to given value.
 *
 * When writing to MP_FUNC5.GPIO1_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.GPIO1_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC5__GPIO1_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__GPIO1_PPEN__GET() gets MP_FUNC5.GPIO1_PPEN's current value.
 *
 * When reading from MP_FUNC5.GPIO1_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC5.GPIO1_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__GPIO1_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__GPIO1_PPEN__MODIFY() modifies MP_FUNC5.GPIO1_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.GPIO1_PPEN
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__GPIO1_PPEN__EXTRACT() extracts MP_FUNC5.GPIO1_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.GPIO1_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__GPIO1_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_PPEN__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC5.GPIO1_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC5.GPIO1_PD:

    Function not in use.

</pre> */

#define COMMON_MP_FUNC5__GPIO1_PD__Pos                          18                                                                     /*!< Right-most bit position of gpio1_pd in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_PD__Msk                          (0x00000001UL << COMMON_MP_FUNC5__GPIO1_PD__Pos)                       /*!< Mask for gpio1_pd in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_PD__Shift(v)                     (((v) << COMMON_MP_FUNC5__GPIO1_PD__Pos) & COMMON_MP_FUNC5__GPIO1_PD__Msk) /*!< Shift value 'v' into gpio1_pd and mask 'v' to fit it into gpio1_pd field */

/** COMMON_MP_FUNC5__GPIO1_PD__SET() sets MP_FUNC5.GPIO1_PD to given value.
 *
 * When writing to MP_FUNC5.GPIO1_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.GPIO1_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC5__GPIO1_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__GPIO1_PD__GET() gets MP_FUNC5.GPIO1_PD's current value.
 *
 * When reading from MP_FUNC5.GPIO1_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC5.GPIO1_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__GPIO1_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__GPIO1_PD__MODIFY() modifies MP_FUNC5.GPIO1_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.GPIO1_PD
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__GPIO1_PD__EXTRACT() extracts MP_FUNC5.GPIO1_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.GPIO1_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__GPIO1_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_PD__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.MP_FUNC5.GPIO1_PULLUP_N --------------------- */

/**
<pre>
  COMMON.MP_FUNC5.GPIO1_PULLUP_N:

    Function not in use.

</pre> */

#define COMMON_MP_FUNC5__GPIO1_PULLUP_N__Pos                    17                                                                     /*!< Right-most bit position of gpio1_pullup_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_PULLUP_N__Msk                    (0x00000001UL << COMMON_MP_FUNC5__GPIO1_PULLUP_N__Pos)                 /*!< Mask for gpio1_pullup_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_PULLUP_N__Shift(v)               (((v) << COMMON_MP_FUNC5__GPIO1_PULLUP_N__Pos) & COMMON_MP_FUNC5__GPIO1_PULLUP_N__Msk) /*!< Shift value 'v' into gpio1_pullup_n and mask 'v' to fit it into gpio1_pullup_n field */

/** COMMON_MP_FUNC5__GPIO1_PULLUP_N__SET() sets MP_FUNC5.GPIO1_PULLUP_N to given value.
 *
 * When writing to MP_FUNC5.GPIO1_PULLUP_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.GPIO1_PULLUP_N
 */
__COMMON_INLINE void COMMON_MP_FUNC5__GPIO1_PULLUP_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_PULLUP_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_PULLUP_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__GPIO1_PULLUP_N__GET() gets MP_FUNC5.GPIO1_PULLUP_N's current value.
 *
 * When reading from MP_FUNC5.GPIO1_PULLUP_N, this is recommended to use.
 *
 * @return current value of MP_FUNC5.GPIO1_PULLUP_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_PULLUP_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__GPIO1_PULLUP_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_PULLUP_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__GPIO1_PULLUP_N__MODIFY() modifies MP_FUNC5.GPIO1_PULLUP_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.GPIO1_PULLUP_N
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_PULLUP_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_PULLUP_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_PULLUP_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__GPIO1_PULLUP_N__EXTRACT() extracts MP_FUNC5.GPIO1_PULLUP_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.GPIO1_PULLUP_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_PULLUP_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__GPIO1_PULLUP_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_PULLUP_N__Pos);
    return (uint32_t)reg;
}

/* -------------------- COMMON.MP_FUNC5.GPIO1_OBUF_EN_N -------------------- */

/**
<pre>
  COMMON.MP_FUNC5.GPIO1_OBUF_EN_N:

    Function not in use.

</pre> */

#define COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Pos                   16                                                                     /*!< Right-most bit position of gpio1_obuf_en_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Msk                   (0x00000001UL << COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Pos)                /*!< Mask for gpio1_obuf_en_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Shift(v)              (((v) << COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Pos) & COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Msk) /*!< Shift value 'v' into gpio1_obuf_en_n and mask 'v' to fit it into gpio1_obuf_en_n field */

/** COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__SET() sets MP_FUNC5.GPIO1_OBUF_EN_N to given value.
 *
 * When writing to MP_FUNC5.GPIO1_OBUF_EN_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.GPIO1_OBUF_EN_N
 */
__COMMON_INLINE void COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__GET() gets MP_FUNC5.GPIO1_OBUF_EN_N's current value.
 *
 * When reading from MP_FUNC5.GPIO1_OBUF_EN_N, this is recommended to use.
 *
 * @return current value of MP_FUNC5.GPIO1_OBUF_EN_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__MODIFY() modifies MP_FUNC5.GPIO1_OBUF_EN_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.GPIO1_OBUF_EN_N
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__EXTRACT() extracts MP_FUNC5.GPIO1_OBUF_EN_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.GPIO1_OBUF_EN_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_OBUF_EN_N__Pos);
    return (uint32_t)reg;
}

/* -------------------- COMMON.MP_FUNC5.GPIO1_IBUF_EN_N -------------------- */

/**
<pre>
  COMMON.MP_FUNC5.GPIO1_IBUF_EN_N:

    Function not in use.

</pre> */

#define COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Pos                   15                                                                     /*!< Right-most bit position of gpio1_ibuf_en_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Msk                   (0x00000001UL << COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Pos)                /*!< Mask for gpio1_ibuf_en_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Shift(v)              (((v) << COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Pos) & COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Msk) /*!< Shift value 'v' into gpio1_ibuf_en_n and mask 'v' to fit it into gpio1_ibuf_en_n field */

/** COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__SET() sets MP_FUNC5.GPIO1_IBUF_EN_N to given value.
 *
 * When writing to MP_FUNC5.GPIO1_IBUF_EN_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.GPIO1_IBUF_EN_N
 */
__COMMON_INLINE void COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__GET() gets MP_FUNC5.GPIO1_IBUF_EN_N's current value.
 *
 * When reading from MP_FUNC5.GPIO1_IBUF_EN_N, this is recommended to use.
 *
 * @return current value of MP_FUNC5.GPIO1_IBUF_EN_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__MODIFY() modifies MP_FUNC5.GPIO1_IBUF_EN_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.GPIO1_IBUF_EN_N
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__EXTRACT() extracts MP_FUNC5.GPIO1_IBUF_EN_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.GPIO1_IBUF_EN_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_IBUF_EN_N__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC5.GPIO1_DAT_N ---------------------- */

/**
<pre>
  COMMON.MP_FUNC5.GPIO1_DAT_N:

    Function not in use.

</pre> */

#define COMMON_MP_FUNC5__GPIO1_DAT_N__Pos                       14                                                                     /*!< Right-most bit position of gpio1_dat_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_DAT_N__Msk                       (0x00000001UL << COMMON_MP_FUNC5__GPIO1_DAT_N__Pos)                    /*!< Mask for gpio1_dat_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__GPIO1_DAT_N__Shift(v)                  (((v) << COMMON_MP_FUNC5__GPIO1_DAT_N__Pos) & COMMON_MP_FUNC5__GPIO1_DAT_N__Msk) /*!< Shift value 'v' into gpio1_dat_n and mask 'v' to fit it into gpio1_dat_n field */

/** COMMON_MP_FUNC5__GPIO1_DAT_N__SET() sets MP_FUNC5.GPIO1_DAT_N to given value.
 *
 * When writing to MP_FUNC5.GPIO1_DAT_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.GPIO1_DAT_N
 */
__COMMON_INLINE void COMMON_MP_FUNC5__GPIO1_DAT_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_DAT_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_DAT_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__GPIO1_DAT_N__GET() gets MP_FUNC5.GPIO1_DAT_N's current value.
 *
 * When reading from MP_FUNC5.GPIO1_DAT_N, this is recommended to use.
 *
 * @return current value of MP_FUNC5.GPIO1_DAT_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_DAT_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__GPIO1_DAT_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_DAT_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__GPIO1_DAT_N__MODIFY() modifies MP_FUNC5.GPIO1_DAT_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.GPIO1_DAT_N
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_DAT_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__GPIO1_DAT_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__GPIO1_DAT_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__GPIO1_DAT_N__EXTRACT() extracts MP_FUNC5.GPIO1_DAT_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.GPIO1_DAT_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__GPIO1_DAT_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__GPIO1_DAT_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__GPIO1_DAT_N__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.MP_FUNC5.SYNC_DIR_OUT ---------------------- */

/**
<pre>
  COMMON.MP_FUNC5.SYNC_DIR_OUT:

    Defines direction of pin mapped to SYNC function
    <start table>
    0 "SYNC mapped pin is input"
    1 "SYNC mapped pin is output"
    <end table>

</pre> */

#define COMMON_MP_FUNC5__SYNC_DIR_OUT__Pos                      13                                                                     /*!< Right-most bit position of sync_dir_out in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__SYNC_DIR_OUT__Msk                      (0x00000001UL << COMMON_MP_FUNC5__SYNC_DIR_OUT__Pos)                   /*!< Mask for sync_dir_out in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__SYNC_DIR_OUT__Shift(v)                 (((v) << COMMON_MP_FUNC5__SYNC_DIR_OUT__Pos) & COMMON_MP_FUNC5__SYNC_DIR_OUT__Msk) /*!< Shift value 'v' into sync_dir_out and mask 'v' to fit it into sync_dir_out field */

/** COMMON_MP_FUNC5__SYNC_DIR_OUT__SET() sets MP_FUNC5.SYNC_DIR_OUT to given value.
 *
 * When writing to MP_FUNC5.SYNC_DIR_OUT, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.SYNC_DIR_OUT
 */
__COMMON_INLINE void COMMON_MP_FUNC5__SYNC_DIR_OUT__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__SYNC_DIR_OUT__Msk);
    reg = (reg | (COMMON_MP_FUNC5__SYNC_DIR_OUT__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__SYNC_DIR_OUT__GET() gets MP_FUNC5.SYNC_DIR_OUT's current value.
 *
 * When reading from MP_FUNC5.SYNC_DIR_OUT, this is recommended to use.
 *
 * @return current value of MP_FUNC5.SYNC_DIR_OUT
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__SYNC_DIR_OUT__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__SYNC_DIR_OUT__Msk);
    reg = (reg >> COMMON_MP_FUNC5__SYNC_DIR_OUT__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__SYNC_DIR_OUT__MODIFY() modifies MP_FUNC5.SYNC_DIR_OUT.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.SYNC_DIR_OUT
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__SYNC_DIR_OUT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__SYNC_DIR_OUT__Msk);
    reg = (reg | (COMMON_MP_FUNC5__SYNC_DIR_OUT__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__SYNC_DIR_OUT__EXTRACT() extracts MP_FUNC5.SYNC_DIR_OUT.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.SYNC_DIR_OUT
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__SYNC_DIR_OUT__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__SYNC_DIR_OUT__Msk);
    reg = (reg >> COMMON_MP_FUNC5__SYNC_DIR_OUT__Pos);
    return (uint32_t)reg;
}

/* -------------------- COMMON.MP_FUNC5.PWM11_STATIC_HIZ -------------------- */

/**
<pre>
  COMMON.MP_FUNC5.PWM11_STATIC_HIZ:

    Pin PWM11 Static HiZ control.  Pin PWM11 has a special otput buffer with Tri-state bias resistors for use with integrated power stage drivers.
    <start table>
    0 "tri-state biasing disabled (typical usage)"
    1 "tri-state biasing enabled (integrated power stage useage)"
    <end table>

</pre> */

#define COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Pos                  12                                                                     /*!< Right-most bit position of pwm11_static_hiz in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Msk                  (0x00000001UL << COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Pos)               /*!< Mask for pwm11_static_hiz in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Shift(v)             (((v) << COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Pos) & COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Msk) /*!< Shift value 'v' into pwm11_static_hiz and mask 'v' to fit it into pwm11_static_hiz field */

/** COMMON_MP_FUNC5__PWM11_STATIC_HIZ__SET() sets MP_FUNC5.PWM11_STATIC_HIZ to given value.
 *
 * When writing to MP_FUNC5.PWM11_STATIC_HIZ, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.PWM11_STATIC_HIZ
 */
__COMMON_INLINE void COMMON_MP_FUNC5__PWM11_STATIC_HIZ__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__PWM11_STATIC_HIZ__GET() gets MP_FUNC5.PWM11_STATIC_HIZ's current value.
 *
 * When reading from MP_FUNC5.PWM11_STATIC_HIZ, this is recommended to use.
 *
 * @return current value of MP_FUNC5.PWM11_STATIC_HIZ
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_STATIC_HIZ__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__PWM11_STATIC_HIZ__MODIFY() modifies MP_FUNC5.PWM11_STATIC_HIZ.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.PWM11_STATIC_HIZ
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_STATIC_HIZ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__PWM11_STATIC_HIZ__EXTRACT() extracts MP_FUNC5.PWM11_STATIC_HIZ.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.PWM11_STATIC_HIZ
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_STATIC_HIZ__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM11_STATIC_HIZ__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC5.PWM12_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC5.PWM12_PPEN:

    Pin PWM12 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC5__PWM12_PPEN__Pos                        11                                                                     /*!< Right-most bit position of pwm12_ppen in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM12_PPEN__Msk                        (0x00000001UL << COMMON_MP_FUNC5__PWM12_PPEN__Pos)                     /*!< Mask for pwm12_ppen in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM12_PPEN__Shift(v)                   (((v) << COMMON_MP_FUNC5__PWM12_PPEN__Pos) & COMMON_MP_FUNC5__PWM12_PPEN__Msk) /*!< Shift value 'v' into pwm12_ppen and mask 'v' to fit it into pwm12_ppen field */

/** COMMON_MP_FUNC5__PWM12_PPEN__SET() sets MP_FUNC5.PWM12_PPEN to given value.
 *
 * When writing to MP_FUNC5.PWM12_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.PWM12_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC5__PWM12_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__PWM12_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM12_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__PWM12_PPEN__GET() gets MP_FUNC5.PWM12_PPEN's current value.
 *
 * When reading from MP_FUNC5.PWM12_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC5.PWM12_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__PWM12_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM12_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__PWM12_PPEN__MODIFY() modifies MP_FUNC5.PWM12_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.PWM12_PPEN
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__PWM12_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM12_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__PWM12_PPEN__EXTRACT() extracts MP_FUNC5.PWM12_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.PWM12_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__PWM12_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM12_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC5.PWM12_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC5.PWM12_PU_N:

    Pin PWM12 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC5__PWM12_PU_N__Pos                        10                                                                     /*!< Right-most bit position of pwm12_pu_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM12_PU_N__Msk                        (0x00000001UL << COMMON_MP_FUNC5__PWM12_PU_N__Pos)                     /*!< Mask for pwm12_pu_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM12_PU_N__Shift(v)                   (((v) << COMMON_MP_FUNC5__PWM12_PU_N__Pos) & COMMON_MP_FUNC5__PWM12_PU_N__Msk) /*!< Shift value 'v' into pwm12_pu_n and mask 'v' to fit it into pwm12_pu_n field */

/** COMMON_MP_FUNC5__PWM12_PU_N__SET() sets MP_FUNC5.PWM12_PU_N to given value.
 *
 * When writing to MP_FUNC5.PWM12_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.PWM12_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC5__PWM12_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__PWM12_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM12_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__PWM12_PU_N__GET() gets MP_FUNC5.PWM12_PU_N's current value.
 *
 * When reading from MP_FUNC5.PWM12_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC5.PWM12_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__PWM12_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM12_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__PWM12_PU_N__MODIFY() modifies MP_FUNC5.PWM12_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.PWM12_PU_N
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__PWM12_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM12_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__PWM12_PU_N__EXTRACT() extracts MP_FUNC5.PWM12_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.PWM12_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__PWM12_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM12_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC5.PWM12_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC5.PWM12_PD:

    Pin PWM12 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC5__PWM12_PD__Pos                          9                                                                      /*!< Right-most bit position of pwm12_pd in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM12_PD__Msk                          (0x00000001UL << COMMON_MP_FUNC5__PWM12_PD__Pos)                       /*!< Mask for pwm12_pd in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM12_PD__Shift(v)                     (((v) << COMMON_MP_FUNC5__PWM12_PD__Pos) & COMMON_MP_FUNC5__PWM12_PD__Msk) /*!< Shift value 'v' into pwm12_pd and mask 'v' to fit it into pwm12_pd field */

/** COMMON_MP_FUNC5__PWM12_PD__SET() sets MP_FUNC5.PWM12_PD to given value.
 *
 * When writing to MP_FUNC5.PWM12_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.PWM12_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC5__PWM12_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__PWM12_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM12_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__PWM12_PD__GET() gets MP_FUNC5.PWM12_PD's current value.
 *
 * When reading from MP_FUNC5.PWM12_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC5.PWM12_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__PWM12_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM12_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__PWM12_PD__MODIFY() modifies MP_FUNC5.PWM12_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.PWM12_PD
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__PWM12_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM12_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__PWM12_PD__EXTRACT() extracts MP_FUNC5.PWM12_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.PWM12_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__PWM12_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM12_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC5.PWM12_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC5.PWM12_FUNC:

    Pin PWM12 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM12" "4" "I" "FAN1_TACH"
    1 "IO" "GPIO0[7]" "5" "na" "na"
    2 "IO" "GPIO1[7]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC5__PWM12_FUNC__Pos                        6                                                                      /*!< Right-most bit position of pwm12_func in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM12_FUNC__Msk                        (0x00000007UL << COMMON_MP_FUNC5__PWM12_FUNC__Pos)                     /*!< Mask for pwm12_func in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM12_FUNC__Shift(v)                   (((v) << COMMON_MP_FUNC5__PWM12_FUNC__Pos) & COMMON_MP_FUNC5__PWM12_FUNC__Msk) /*!< Shift value 'v' into pwm12_func and mask 'v' to fit it into pwm12_func field */

/** COMMON_MP_FUNC5__PWM12_FUNC__SET() sets MP_FUNC5.PWM12_FUNC to given value.
 *
 * When writing to MP_FUNC5.PWM12_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.PWM12_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC5__PWM12_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__PWM12_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM12_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__PWM12_FUNC__GET() gets MP_FUNC5.PWM12_FUNC's current value.
 *
 * When reading from MP_FUNC5.PWM12_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC5.PWM12_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__PWM12_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM12_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__PWM12_FUNC__MODIFY() modifies MP_FUNC5.PWM12_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.PWM12_FUNC
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__PWM12_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM12_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__PWM12_FUNC__EXTRACT() extracts MP_FUNC5.PWM12_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.PWM12_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM12_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__PWM12_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM12_FUNC__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC5.PWM11_PPEN ----------------------- */

/**
<pre>
  COMMON.MP_FUNC5.PWM11_PPEN:

    Pin PWM11 output buffer CMOS / Open Drain select
    <start table>
    0 "open drain output"
    1 "CMOS output"
    <end table>

</pre> */

#define COMMON_MP_FUNC5__PWM11_PPEN__Pos                        5                                                                      /*!< Right-most bit position of pwm11_ppen in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM11_PPEN__Msk                        (0x00000001UL << COMMON_MP_FUNC5__PWM11_PPEN__Pos)                     /*!< Mask for pwm11_ppen in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM11_PPEN__Shift(v)                   (((v) << COMMON_MP_FUNC5__PWM11_PPEN__Pos) & COMMON_MP_FUNC5__PWM11_PPEN__Msk) /*!< Shift value 'v' into pwm11_ppen and mask 'v' to fit it into pwm11_ppen field */

/** COMMON_MP_FUNC5__PWM11_PPEN__SET() sets MP_FUNC5.PWM11_PPEN to given value.
 *
 * When writing to MP_FUNC5.PWM11_PPEN, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.PWM11_PPEN
 */
__COMMON_INLINE void COMMON_MP_FUNC5__PWM11_PPEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__PWM11_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM11_PPEN__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__PWM11_PPEN__GET() gets MP_FUNC5.PWM11_PPEN's current value.
 *
 * When reading from MP_FUNC5.PWM11_PPEN, this is recommended to use.
 *
 * @return current value of MP_FUNC5.PWM11_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_PPEN__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__PWM11_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM11_PPEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__PWM11_PPEN__MODIFY() modifies MP_FUNC5.PWM11_PPEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.PWM11_PPEN
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_PPEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__PWM11_PPEN__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM11_PPEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__PWM11_PPEN__EXTRACT() extracts MP_FUNC5.PWM11_PPEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.PWM11_PPEN
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_PPEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__PWM11_PPEN__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM11_PPEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC5.PWM11_PU_N ----------------------- */

/**
<pre>
  COMMON.MP_FUNC5.PWM11_PU_N:

    Pin PWM11 weak pullup enable
    <start table>
    0 "pullup enabled"
    1 "pullup disabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC5__PWM11_PU_N__Pos                        4                                                                      /*!< Right-most bit position of pwm11_pu_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM11_PU_N__Msk                        (0x00000001UL << COMMON_MP_FUNC5__PWM11_PU_N__Pos)                     /*!< Mask for pwm11_pu_n in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM11_PU_N__Shift(v)                   (((v) << COMMON_MP_FUNC5__PWM11_PU_N__Pos) & COMMON_MP_FUNC5__PWM11_PU_N__Msk) /*!< Shift value 'v' into pwm11_pu_n and mask 'v' to fit it into pwm11_pu_n field */

/** COMMON_MP_FUNC5__PWM11_PU_N__SET() sets MP_FUNC5.PWM11_PU_N to given value.
 *
 * When writing to MP_FUNC5.PWM11_PU_N, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.PWM11_PU_N
 */
__COMMON_INLINE void COMMON_MP_FUNC5__PWM11_PU_N__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__PWM11_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM11_PU_N__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__PWM11_PU_N__GET() gets MP_FUNC5.PWM11_PU_N's current value.
 *
 * When reading from MP_FUNC5.PWM11_PU_N, this is recommended to use.
 *
 * @return current value of MP_FUNC5.PWM11_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_PU_N__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__PWM11_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM11_PU_N__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__PWM11_PU_N__MODIFY() modifies MP_FUNC5.PWM11_PU_N.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.PWM11_PU_N
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_PU_N__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__PWM11_PU_N__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM11_PU_N__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__PWM11_PU_N__EXTRACT() extracts MP_FUNC5.PWM11_PU_N.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.PWM11_PU_N
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_PU_N__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__PWM11_PU_N__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM11_PU_N__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.MP_FUNC5.PWM11_PD ------------------------ */

/**
<pre>
  COMMON.MP_FUNC5.PWM11_PD:

    Pin PWM11 weak pulldown enable
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled"
    <end table>

</pre> */

#define COMMON_MP_FUNC5__PWM11_PD__Pos                          3                                                                      /*!< Right-most bit position of pwm11_pd in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM11_PD__Msk                          (0x00000001UL << COMMON_MP_FUNC5__PWM11_PD__Pos)                       /*!< Mask for pwm11_pd in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM11_PD__Shift(v)                     (((v) << COMMON_MP_FUNC5__PWM11_PD__Pos) & COMMON_MP_FUNC5__PWM11_PD__Msk) /*!< Shift value 'v' into pwm11_pd and mask 'v' to fit it into pwm11_pd field */

/** COMMON_MP_FUNC5__PWM11_PD__SET() sets MP_FUNC5.PWM11_PD to given value.
 *
 * When writing to MP_FUNC5.PWM11_PD, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.PWM11_PD
 */
__COMMON_INLINE void COMMON_MP_FUNC5__PWM11_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__PWM11_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM11_PD__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__PWM11_PD__GET() gets MP_FUNC5.PWM11_PD's current value.
 *
 * When reading from MP_FUNC5.PWM11_PD, this is recommended to use.
 *
 * @return current value of MP_FUNC5.PWM11_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_PD__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__PWM11_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM11_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__PWM11_PD__MODIFY() modifies MP_FUNC5.PWM11_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.PWM11_PD
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__PWM11_PD__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM11_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__PWM11_PD__EXTRACT() extracts MP_FUNC5.PWM11_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.PWM11_PD
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__PWM11_PD__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM11_PD__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.MP_FUNC5.PWM11_FUNC ----------------------- */

/**
<pre>
  COMMON.MP_FUNC5.PWM11_FUNC:

    Pin PWM11 function definition
    <start table_with_header>
    [2:0] "Direction" "Function" "[2:0]" "Direction" "Function"
    0 "O" "PWM11" "4" "O" "FAN1_PWM"
    1 "IO" "GPIO0[6]" "5" "na" "na"
    2 "IO" "GPIO1[6]" "6" "na" "na"
    3 "IO" "SYNC" "7" "na" "na"
    <end table>

</pre> */

#define COMMON_MP_FUNC5__PWM11_FUNC__Pos                        0                                                                      /*!< Right-most bit position of pwm11_func in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM11_FUNC__Msk                        (0x00000007UL << COMMON_MP_FUNC5__PWM11_FUNC__Pos)                     /*!< Mask for pwm11_func in COMMON.MP_FUNC5 */
#define COMMON_MP_FUNC5__PWM11_FUNC__Shift(v)                   (((v) << COMMON_MP_FUNC5__PWM11_FUNC__Pos) & COMMON_MP_FUNC5__PWM11_FUNC__Msk) /*!< Shift value 'v' into pwm11_func and mask 'v' to fit it into pwm11_func field */

/** COMMON_MP_FUNC5__PWM11_FUNC__SET() sets MP_FUNC5.PWM11_FUNC to given value.
 *
 * When writing to MP_FUNC5.PWM11_FUNC, this is recommended to use.
 *
 * @param bf_value new value for MP_FUNC5.PWM11_FUNC
 */
__COMMON_INLINE void COMMON_MP_FUNC5__PWM11_FUNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & ~COMMON_MP_FUNC5__PWM11_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM11_FUNC__Shift((uint32_t)bf_value)));
    COMMON_MP_FUNC5__SET(reg);
}

/** COMMON_MP_FUNC5__PWM11_FUNC__GET() gets MP_FUNC5.PWM11_FUNC's current value.
 *
 * When reading from MP_FUNC5.PWM11_FUNC, this is recommended to use.
 *
 * @return current value of MP_FUNC5.PWM11_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_FUNC__GET(void)
{
    uint32_t reg = COMMON_MP_FUNC5__GET();
    reg = (reg & COMMON_MP_FUNC5__PWM11_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM11_FUNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_MP_FUNC5__PWM11_FUNC__MODIFY() modifies MP_FUNC5.PWM11_FUNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.MP_FUNC5.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @param bf_value new value for MP_FUNC5.PWM11_FUNC
 * @return new value of COMMON.MP_FUNC5
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_FUNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_MP_FUNC5__PWM11_FUNC__Msk);
    reg = (reg | (COMMON_MP_FUNC5__PWM11_FUNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_MP_FUNC5__PWM11_FUNC__EXTRACT() extracts MP_FUNC5.PWM11_FUNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.MP_FUNC5.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.MP_FUNC5
 * @return current value of MP_FUNC5.PWM11_FUNC
 */
__COMMON_INLINE uint32_t COMMON_MP_FUNC5__PWM11_FUNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_MP_FUNC5__PWM11_FUNC__Msk);
    reg = (reg >> COMMON_MP_FUNC5__PWM11_FUNC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         VRS_CFG member of COMMON_t                         */
/* -------------------------------------------------------------------------- */

/** __COMMON_VRS_CFG__ADDRESS returns the address of member VRS_CFG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VRS_CFG
 */
__COMMON_INLINE uint32_t* __COMMON_VRS_CFG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VRS_CFG)));
}

/** COMMON_VRS_CFG__SET() sets VRS_CFG to given value.
 *
 * When writing to VRS_CFG, this is mandatory to use.
 *
 * @param value new value for VRS_CFG
 */
__COMMON_INLINE void COMMON_VRS_CFG__SET(uint32_t value)
{
    HAL_SET32(__COMMON_VRS_CFG__ADDRESS(), value);
}

/** COMMON_VRS_CFG__GET() gets VRS_CFG's current value.
 *
 * When reading from VRS_CFG, this is mandatory to use.
 *
 * @return current value of VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__GET(void)
{
    return HAL_GET32(__COMMON_VRS_CFG__ADDRESS());
}

/* ------------------- COMMON.VRS_CFG.VRS_BYPASS_FAST_LPF ------------------- */

/**
<pre>
  COMMON.VRS_CFG.VRS_BYPASS_FAST_LPF:

    VRS fast filter bypass control.  Shared by VRS1 and VRS2.
    <start table>
    0 "filter not bypassed"
    1 "filter bypassed"
    <end table>

</pre> */

#define COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Pos                30                                                                     /*!< Right-most bit position of vrs_bypass_fast_lpf in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Msk                (0x00000001UL << COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Pos)             /*!< Mask for vrs_bypass_fast_lpf in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Shift(v)           (((v) << COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Pos) & COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Msk) /*!< Shift value 'v' into vrs_bypass_fast_lpf and mask 'v' to fit it into vrs_bypass_fast_lpf field */

/** COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__SET() sets VRS_CFG.VRS_BYPASS_FAST_LPF to given value.
 *
 * When writing to VRS_CFG.VRS_BYPASS_FAST_LPF, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VRS_BYPASS_FAST_LPF
 */
__COMMON_INLINE void COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__GET() gets VRS_CFG.VRS_BYPASS_FAST_LPF's current value.
 *
 * When reading from VRS_CFG.VRS_BYPASS_FAST_LPF, this is recommended to use.
 *
 * @return current value of VRS_CFG.VRS_BYPASS_FAST_LPF
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__MODIFY() modifies VRS_CFG.VRS_BYPASS_FAST_LPF.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VRS_BYPASS_FAST_LPF
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__EXTRACT() extracts VRS_CFG.VRS_BYPASS_FAST_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VRS_BYPASS_FAST_LPF
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_BYPASS_FAST_LPF__Pos);
    return (uint32_t)reg;
}

/* ------------------- COMMON.VRS_CFG.VRS_BYPASS_SLOW_LPF ------------------- */

/**
<pre>
  COMMON.VRS_CFG.VRS_BYPASS_SLOW_LPF:

    VRS slow filter bypass control.  Shared by VRS1 and VRS2.
    <start table>
    0 "filter not bypassed"
    1 "filter bypassed"
    <end table>

</pre> */

#define COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Pos                29                                                                     /*!< Right-most bit position of vrs_bypass_slow_lpf in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Msk                (0x00000001UL << COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Pos)             /*!< Mask for vrs_bypass_slow_lpf in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Shift(v)           (((v) << COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Pos) & COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Msk) /*!< Shift value 'v' into vrs_bypass_slow_lpf and mask 'v' to fit it into vrs_bypass_slow_lpf field */

/** COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__SET() sets VRS_CFG.VRS_BYPASS_SLOW_LPF to given value.
 *
 * When writing to VRS_CFG.VRS_BYPASS_SLOW_LPF, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VRS_BYPASS_SLOW_LPF
 */
__COMMON_INLINE void COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__GET() gets VRS_CFG.VRS_BYPASS_SLOW_LPF's current value.
 *
 * When reading from VRS_CFG.VRS_BYPASS_SLOW_LPF, this is recommended to use.
 *
 * @return current value of VRS_CFG.VRS_BYPASS_SLOW_LPF
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__MODIFY() modifies VRS_CFG.VRS_BYPASS_SLOW_LPF.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VRS_BYPASS_SLOW_LPF
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__EXTRACT() extracts VRS_CFG.VRS_BYPASS_SLOW_LPF.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VRS_BYPASS_SLOW_LPF
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_BYPASS_SLOW_LPF__Pos);
    return (uint32_t)reg;
}

/* ------------------- COMMON.VRS_CFG.VRS_DELTA_VSUM_SEL ------------------- */

/**
<pre>
  COMMON.VRS_CFG.VRS_DELTA_VSUM_SEL:

    In the VRS tracking phase, the ADC output is filtered by both a fast (higher bandwidth) LPF and a slow (lower bandwidth) LPF.  When the difference between the two LPF outputs is greater than the threshold selected by vrs_delta_vsum_sel, the fast filter output is selected, otherwise the slow filter output is selected.
    <start table>
    0 "8 ADC codes"
    1 "16 ADC codes"
    <end table>

</pre> */

#define COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Pos                 28                                                                     /*!< Right-most bit position of vrs_delta_vsum_sel in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Msk                 (0x00000001UL << COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Pos)              /*!< Mask for vrs_delta_vsum_sel in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Shift(v)            (((v) << COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Pos) & COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Msk) /*!< Shift value 'v' into vrs_delta_vsum_sel and mask 'v' to fit it into vrs_delta_vsum_sel field */

/** COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__SET() sets VRS_CFG.VRS_DELTA_VSUM_SEL to given value.
 *
 * When writing to VRS_CFG.VRS_DELTA_VSUM_SEL, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VRS_DELTA_VSUM_SEL
 */
__COMMON_INLINE void COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__GET() gets VRS_CFG.VRS_DELTA_VSUM_SEL's current value.
 *
 * When reading from VRS_CFG.VRS_DELTA_VSUM_SEL, this is recommended to use.
 *
 * @return current value of VRS_CFG.VRS_DELTA_VSUM_SEL
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__MODIFY() modifies VRS_CFG.VRS_DELTA_VSUM_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VRS_DELTA_VSUM_SEL
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__EXTRACT() extracts VRS_CFG.VRS_DELTA_VSUM_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VRS_DELTA_VSUM_SEL
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_DELTA_VSUM_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.VRS_CFG.VRS_CMP_REF_SEL --------------------- */

/**
<pre>
  COMMON.VRS_CFG.VRS_CMP_REF_SEL:

    Rectification voltage sense (VRS) comparator threshold select.  This threshold is shared by the VRSEN and BVRSEN sense paths.  When the rectification voltage exceeds this threshold the VRS enters its hold phase of operation.
    <start table>
    0 500mV
    1 300mV
    <end table>

</pre> */

#define COMMON_VRS_CFG__VRS_CMP_REF_SEL__Pos                    27                                                                     /*!< Right-most bit position of vrs_cmp_ref_sel in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_CMP_REF_SEL__Msk                    (0x00000001UL << COMMON_VRS_CFG__VRS_CMP_REF_SEL__Pos)                 /*!< Mask for vrs_cmp_ref_sel in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_CMP_REF_SEL__Shift(v)               (((v) << COMMON_VRS_CFG__VRS_CMP_REF_SEL__Pos) & COMMON_VRS_CFG__VRS_CMP_REF_SEL__Msk) /*!< Shift value 'v' into vrs_cmp_ref_sel and mask 'v' to fit it into vrs_cmp_ref_sel field */

/** COMMON_VRS_CFG__VRS_CMP_REF_SEL__SET() sets VRS_CFG.VRS_CMP_REF_SEL to given value.
 *
 * When writing to VRS_CFG.VRS_CMP_REF_SEL, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VRS_CMP_REF_SEL
 */
__COMMON_INLINE void COMMON_VRS_CFG__VRS_CMP_REF_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VRS_CMP_REF_SEL__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_CMP_REF_SEL__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VRS_CMP_REF_SEL__GET() gets VRS_CFG.VRS_CMP_REF_SEL's current value.
 *
 * When reading from VRS_CFG.VRS_CMP_REF_SEL, this is recommended to use.
 *
 * @return current value of VRS_CFG.VRS_CMP_REF_SEL
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_CMP_REF_SEL__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VRS_CMP_REF_SEL__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_CMP_REF_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VRS_CMP_REF_SEL__MODIFY() modifies VRS_CFG.VRS_CMP_REF_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VRS_CMP_REF_SEL
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_CMP_REF_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VRS_CMP_REF_SEL__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_CMP_REF_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VRS_CMP_REF_SEL__EXTRACT() extracts VRS_CFG.VRS_CMP_REF_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VRS_CMP_REF_SEL
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_CMP_REF_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VRS_CMP_REF_SEL__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_CMP_REF_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.VRS_CFG.VSP2_VRS_CNT_NUM_AVG ------------------ */

/**
<pre>
  COMMON.VRS_CFG.VSP2_VRS_CNT_NUM_AVG:

    Defines the number of samples in the BVRSEN dead time measurement block averagers.  The dead time measurements inlcude SR FET falling edge to VRS Comp rising edge and VRS Comp falling edge to SR FET rising edge.
    <start table_with_header>
    [1:0] "# samples averaged"
    0 "4"
    1 "8"
    2 "16"
    3 "32"
    <end table>

</pre> */

#define COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Pos               25                                                                     /*!< Right-most bit position of vsp2_vrs_cnt_num_avg in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Msk               (0x00000003UL << COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Pos)            /*!< Mask for vsp2_vrs_cnt_num_avg in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Shift(v)          (((v) << COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Pos) & COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Msk) /*!< Shift value 'v' into vsp2_vrs_cnt_num_avg and mask 'v' to fit it into vsp2_vrs_cnt_num_avg field */

/** COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__SET() sets VRS_CFG.VSP2_VRS_CNT_NUM_AVG to given value.
 *
 * When writing to VRS_CFG.VSP2_VRS_CNT_NUM_AVG, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VSP2_VRS_CNT_NUM_AVG
 */
__COMMON_INLINE void COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Msk);
    reg = (reg | (COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__GET() gets VRS_CFG.VSP2_VRS_CNT_NUM_AVG's current value.
 *
 * When reading from VRS_CFG.VSP2_VRS_CNT_NUM_AVG, this is recommended to use.
 *
 * @return current value of VRS_CFG.VSP2_VRS_CNT_NUM_AVG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Msk);
    reg = (reg >> COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__MODIFY() modifies VRS_CFG.VSP2_VRS_CNT_NUM_AVG.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VSP2_VRS_CNT_NUM_AVG
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Msk);
    reg = (reg | (COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__EXTRACT() extracts VRS_CFG.VSP2_VRS_CNT_NUM_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VSP2_VRS_CNT_NUM_AVG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Msk);
    reg = (reg >> COMMON_VRS_CFG__VSP2_VRS_CNT_NUM_AVG__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.VRS_CFG.VSP1_VRS_CNT_NUM_AVG ------------------ */

/**
<pre>
  COMMON.VRS_CFG.VSP1_VRS_CNT_NUM_AVG:

    Defines the number of samples in the VRSEN dead time measurement block averagers.  The dead time measurements inlcude SR FET falling edge to VRS Comp rising edge and VRS Comp falling edge to SR FET rising edge.
    <start table_with_header>
    [1:0] "# samples averaged"
    0 "4"
    1 "8"
    2 "16"
    3 "32"
    <end table>

</pre> */

#define COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Pos               23                                                                     /*!< Right-most bit position of vsp1_vrs_cnt_num_avg in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Msk               (0x00000003UL << COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Pos)            /*!< Mask for vsp1_vrs_cnt_num_avg in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Shift(v)          (((v) << COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Pos) & COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Msk) /*!< Shift value 'v' into vsp1_vrs_cnt_num_avg and mask 'v' to fit it into vsp1_vrs_cnt_num_avg field */

/** COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__SET() sets VRS_CFG.VSP1_VRS_CNT_NUM_AVG to given value.
 *
 * When writing to VRS_CFG.VSP1_VRS_CNT_NUM_AVG, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VSP1_VRS_CNT_NUM_AVG
 */
__COMMON_INLINE void COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Msk);
    reg = (reg | (COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__GET() gets VRS_CFG.VSP1_VRS_CNT_NUM_AVG's current value.
 *
 * When reading from VRS_CFG.VSP1_VRS_CNT_NUM_AVG, this is recommended to use.
 *
 * @return current value of VRS_CFG.VSP1_VRS_CNT_NUM_AVG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Msk);
    reg = (reg >> COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__MODIFY() modifies VRS_CFG.VSP1_VRS_CNT_NUM_AVG.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VSP1_VRS_CNT_NUM_AVG
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Msk);
    reg = (reg | (COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__EXTRACT() extracts VRS_CFG.VSP1_VRS_CNT_NUM_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VSP1_VRS_CNT_NUM_AVG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Msk);
    reg = (reg >> COMMON_VRS_CFG__VSP1_VRS_CNT_NUM_AVG__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.VRS_CFG.VSP2_VRS_SEL ---------------------- */

/**
<pre>
  COMMON.VRS_CFG.VSP2_VRS_SEL:

    BVSEN_BVRSEN ADC rectification voltage sense (VRS) mode select.
    <start table>
    0 "Vout Sense (VS) mode"
    1 "Vrect Sense (VRS) mode"
    <end table>

</pre> */

#define COMMON_VRS_CFG__VSP2_VRS_SEL__Pos                       22                                                                     /*!< Right-most bit position of vsp2_vrs_sel in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VSP2_VRS_SEL__Msk                       (0x00000001UL << COMMON_VRS_CFG__VSP2_VRS_SEL__Pos)                    /*!< Mask for vsp2_vrs_sel in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VSP2_VRS_SEL__Shift(v)                  (((v) << COMMON_VRS_CFG__VSP2_VRS_SEL__Pos) & COMMON_VRS_CFG__VSP2_VRS_SEL__Msk) /*!< Shift value 'v' into vsp2_vrs_sel and mask 'v' to fit it into vsp2_vrs_sel field */

/** COMMON_VRS_CFG__VSP2_VRS_SEL__SET() sets VRS_CFG.VSP2_VRS_SEL to given value.
 *
 * When writing to VRS_CFG.VSP2_VRS_SEL, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VSP2_VRS_SEL
 */
__COMMON_INLINE void COMMON_VRS_CFG__VSP2_VRS_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VSP2_VRS_SEL__Msk);
    reg = (reg | (COMMON_VRS_CFG__VSP2_VRS_SEL__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VSP2_VRS_SEL__GET() gets VRS_CFG.VSP2_VRS_SEL's current value.
 *
 * When reading from VRS_CFG.VSP2_VRS_SEL, this is recommended to use.
 *
 * @return current value of VRS_CFG.VSP2_VRS_SEL
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP2_VRS_SEL__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VSP2_VRS_SEL__Msk);
    reg = (reg >> COMMON_VRS_CFG__VSP2_VRS_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VSP2_VRS_SEL__MODIFY() modifies VRS_CFG.VSP2_VRS_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VSP2_VRS_SEL
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP2_VRS_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VSP2_VRS_SEL__Msk);
    reg = (reg | (COMMON_VRS_CFG__VSP2_VRS_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VSP2_VRS_SEL__EXTRACT() extracts VRS_CFG.VSP2_VRS_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VSP2_VRS_SEL
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP2_VRS_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VSP2_VRS_SEL__Msk);
    reg = (reg >> COMMON_VRS_CFG__VSP2_VRS_SEL__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.VRS_CFG.VSP1_VRS_SEL ---------------------- */

/**
<pre>
  COMMON.VRS_CFG.VSP1_VRS_SEL:

    VRSEN input ADC rectification voltage sense (VRS) mode select.
    <start table>
    0 "General purpose ADC mode"
    1 "Vrect Sense (VRS) mode"
    <end table>

</pre> */

#define COMMON_VRS_CFG__VSP1_VRS_SEL__Pos                       21                                                                     /*!< Right-most bit position of vsp1_vrs_sel in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VSP1_VRS_SEL__Msk                       (0x00000001UL << COMMON_VRS_CFG__VSP1_VRS_SEL__Pos)                    /*!< Mask for vsp1_vrs_sel in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VSP1_VRS_SEL__Shift(v)                  (((v) << COMMON_VRS_CFG__VSP1_VRS_SEL__Pos) & COMMON_VRS_CFG__VSP1_VRS_SEL__Msk) /*!< Shift value 'v' into vsp1_vrs_sel and mask 'v' to fit it into vsp1_vrs_sel field */

/** COMMON_VRS_CFG__VSP1_VRS_SEL__SET() sets VRS_CFG.VSP1_VRS_SEL to given value.
 *
 * When writing to VRS_CFG.VSP1_VRS_SEL, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VSP1_VRS_SEL
 */
__COMMON_INLINE void COMMON_VRS_CFG__VSP1_VRS_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VSP1_VRS_SEL__Msk);
    reg = (reg | (COMMON_VRS_CFG__VSP1_VRS_SEL__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VSP1_VRS_SEL__GET() gets VRS_CFG.VSP1_VRS_SEL's current value.
 *
 * When reading from VRS_CFG.VSP1_VRS_SEL, this is recommended to use.
 *
 * @return current value of VRS_CFG.VSP1_VRS_SEL
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP1_VRS_SEL__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VSP1_VRS_SEL__Msk);
    reg = (reg >> COMMON_VRS_CFG__VSP1_VRS_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VSP1_VRS_SEL__MODIFY() modifies VRS_CFG.VSP1_VRS_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VSP1_VRS_SEL
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP1_VRS_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VSP1_VRS_SEL__Msk);
    reg = (reg | (COMMON_VRS_CFG__VSP1_VRS_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VSP1_VRS_SEL__EXTRACT() extracts VRS_CFG.VSP1_VRS_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VSP1_VRS_SEL
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VSP1_VRS_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VSP1_VRS_SEL__Msk);
    reg = (reg >> COMMON_VRS_CFG__VSP1_VRS_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.VRS_CFG.VRECT_DIV_2_SEL --------------------- */

/**
<pre>
  COMMON.VRS_CFG.VRECT_DIV_2_SEL:

    Defines equation used for rectification voltage (Vrect) measurement.
    <start table_with_header>
    vrect_div_2_sel Equation Topologies
    0 "vrect_even + vrect_odd" "Non-bridge topologies"
    1 "(vrect_even + vrect_odd) / 2" "Bridge topologies"
    <end table>

</pre> */

#define COMMON_VRS_CFG__VRECT_DIV_2_SEL__Pos                    20                                                                     /*!< Right-most bit position of vrect_div_2_sel in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRECT_DIV_2_SEL__Msk                    (0x00000001UL << COMMON_VRS_CFG__VRECT_DIV_2_SEL__Pos)                 /*!< Mask for vrect_div_2_sel in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRECT_DIV_2_SEL__Shift(v)               (((v) << COMMON_VRS_CFG__VRECT_DIV_2_SEL__Pos) & COMMON_VRS_CFG__VRECT_DIV_2_SEL__Msk) /*!< Shift value 'v' into vrect_div_2_sel and mask 'v' to fit it into vrect_div_2_sel field */

/** COMMON_VRS_CFG__VRECT_DIV_2_SEL__SET() sets VRS_CFG.VRECT_DIV_2_SEL to given value.
 *
 * When writing to VRS_CFG.VRECT_DIV_2_SEL, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VRECT_DIV_2_SEL
 */
__COMMON_INLINE void COMMON_VRS_CFG__VRECT_DIV_2_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VRECT_DIV_2_SEL__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRECT_DIV_2_SEL__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VRECT_DIV_2_SEL__GET() gets VRS_CFG.VRECT_DIV_2_SEL's current value.
 *
 * When reading from VRS_CFG.VRECT_DIV_2_SEL, this is recommended to use.
 *
 * @return current value of VRS_CFG.VRECT_DIV_2_SEL
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRECT_DIV_2_SEL__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VRECT_DIV_2_SEL__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRECT_DIV_2_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VRECT_DIV_2_SEL__MODIFY() modifies VRS_CFG.VRECT_DIV_2_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VRECT_DIV_2_SEL
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRECT_DIV_2_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VRECT_DIV_2_SEL__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRECT_DIV_2_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VRECT_DIV_2_SEL__EXTRACT() extracts VRS_CFG.VRECT_DIV_2_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VRECT_DIV_2_SEL
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRECT_DIV_2_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VRECT_DIV_2_SEL__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRECT_DIV_2_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------- COMMON.VRS_CFG.VRS_TRACK_START_THR ------------------- */

/**
<pre>
  COMMON.VRS_CFG.VRS_TRACK_START_THR:

    Vrect tracking start time threshold.  This threshold is compared against the same timer used by vrs_cmp_wdt_thr which is started on the rising edge of the PWM's indicated in ceX_on_mask0 and ceX_on_mask1 (where X = 0,1).  When the timer exceeds this threshold the Vrect sense moves from its hold phase to its tracking phase.  This threshold should be set approximately 250ns above the expected time of arrival of the Vrect rising edge to insure adequate settling of the analog front end.  This threshold is shared by VRSEN and BVRSEN sense paths.
    LSB = 10ns, Range = 0.0 to 10.23us

</pre> */

#define COMMON_VRS_CFG__VRS_TRACK_START_THR__Pos                10                                                                     /*!< Right-most bit position of vrs_track_start_thr in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_TRACK_START_THR__Msk                (0x000003FFUL << COMMON_VRS_CFG__VRS_TRACK_START_THR__Pos)             /*!< Mask for vrs_track_start_thr in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_TRACK_START_THR__Shift(v)           (((v) << COMMON_VRS_CFG__VRS_TRACK_START_THR__Pos) & COMMON_VRS_CFG__VRS_TRACK_START_THR__Msk) /*!< Shift value 'v' into vrs_track_start_thr and mask 'v' to fit it into vrs_track_start_thr field */

/** COMMON_VRS_CFG__VRS_TRACK_START_THR__SET() sets VRS_CFG.VRS_TRACK_START_THR to given value.
 *
 * When writing to VRS_CFG.VRS_TRACK_START_THR, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VRS_TRACK_START_THR
 */
__COMMON_INLINE void COMMON_VRS_CFG__VRS_TRACK_START_THR__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VRS_TRACK_START_THR__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_TRACK_START_THR__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VRS_TRACK_START_THR__GET() gets VRS_CFG.VRS_TRACK_START_THR's current value.
 *
 * When reading from VRS_CFG.VRS_TRACK_START_THR, this is recommended to use.
 *
 * @return current value of VRS_CFG.VRS_TRACK_START_THR
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_TRACK_START_THR__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VRS_TRACK_START_THR__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_TRACK_START_THR__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VRS_TRACK_START_THR__MODIFY() modifies VRS_CFG.VRS_TRACK_START_THR.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VRS_TRACK_START_THR
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_TRACK_START_THR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VRS_TRACK_START_THR__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_TRACK_START_THR__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VRS_TRACK_START_THR__EXTRACT() extracts VRS_CFG.VRS_TRACK_START_THR.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VRS_TRACK_START_THR
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_TRACK_START_THR__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VRS_TRACK_START_THR__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_TRACK_START_THR__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.VRS_CFG.VRS_CMP_WDT_THR --------------------- */

/**
<pre>
  COMMON.VRS_CFG.VRS_CMP_WDT_THR:

    Vrect comparator watchdog timeout threshold.  The watchdog timer measures from the rising edge of the PWM's indicated in ceX_on_mask0 and ceX_on_mask1 (where X = 0,1).  If Vrect has not tripped the comparator by the time the timeout threshold is reached, it is assumed Vrect is below the comparator threshold and the Vrect sense will enter its hold phase.  This threshold should be set to a value greater than the expected time for Vrect to go high but less than the tracking start threshold defined by vrs_track_start_thr.  This threshold is shared by the VRSEN and BVRSEN sense paths.
    LSB = 10ns, Range = 0.0 to 10.23us

</pre> */

#define COMMON_VRS_CFG__VRS_CMP_WDT_THR__Pos                    0                                                                      /*!< Right-most bit position of vrs_cmp_wdt_thr in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_CMP_WDT_THR__Msk                    (0x000003FFUL << COMMON_VRS_CFG__VRS_CMP_WDT_THR__Pos)                 /*!< Mask for vrs_cmp_wdt_thr in COMMON.VRS_CFG */
#define COMMON_VRS_CFG__VRS_CMP_WDT_THR__Shift(v)               (((v) << COMMON_VRS_CFG__VRS_CMP_WDT_THR__Pos) & COMMON_VRS_CFG__VRS_CMP_WDT_THR__Msk) /*!< Shift value 'v' into vrs_cmp_wdt_thr and mask 'v' to fit it into vrs_cmp_wdt_thr field */

/** COMMON_VRS_CFG__VRS_CMP_WDT_THR__SET() sets VRS_CFG.VRS_CMP_WDT_THR to given value.
 *
 * When writing to VRS_CFG.VRS_CMP_WDT_THR, this is recommended to use.
 *
 * @param bf_value new value for VRS_CFG.VRS_CMP_WDT_THR
 */
__COMMON_INLINE void COMMON_VRS_CFG__VRS_CMP_WDT_THR__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & ~COMMON_VRS_CFG__VRS_CMP_WDT_THR__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_CMP_WDT_THR__Shift((uint32_t)bf_value)));
    COMMON_VRS_CFG__SET(reg);
}

/** COMMON_VRS_CFG__VRS_CMP_WDT_THR__GET() gets VRS_CFG.VRS_CMP_WDT_THR's current value.
 *
 * When reading from VRS_CFG.VRS_CMP_WDT_THR, this is recommended to use.
 *
 * @return current value of VRS_CFG.VRS_CMP_WDT_THR
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_CMP_WDT_THR__GET(void)
{
    uint32_t reg = COMMON_VRS_CFG__GET();
    reg = (reg & COMMON_VRS_CFG__VRS_CMP_WDT_THR__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_CMP_WDT_THR__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_CFG__VRS_CMP_WDT_THR__MODIFY() modifies VRS_CFG.VRS_CMP_WDT_THR.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @param bf_value new value for VRS_CFG.VRS_CMP_WDT_THR
 * @return new value of COMMON.VRS_CFG
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_CMP_WDT_THR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_CFG__VRS_CMP_WDT_THR__Msk);
    reg = (reg | (COMMON_VRS_CFG__VRS_CMP_WDT_THR__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_CFG__VRS_CMP_WDT_THR__EXTRACT() extracts VRS_CFG.VRS_CMP_WDT_THR.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_CFG
 * @return current value of VRS_CFG.VRS_CMP_WDT_THR
 */
__COMMON_INLINE uint32_t COMMON_VRS_CFG__VRS_CMP_WDT_THR__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_CFG__VRS_CMP_WDT_THR__Msk);
    reg = (reg >> COMMON_VRS_CFG__VRS_CMP_WDT_THR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                    VRS_VOLTAGE_INIT member of COMMON_t                    */
/* -------------------------------------------------------------------------- */

/** __COMMON_VRS_VOLTAGE_INIT__ADDRESS returns the address of member VRS_VOLTAGE_INIT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VRS_VOLTAGE_INIT
 */
__COMMON_INLINE uint32_t* __COMMON_VRS_VOLTAGE_INIT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VRS_VOLTAGE_INIT)));
}

/** COMMON_VRS_VOLTAGE_INIT__SET() sets VRS_VOLTAGE_INIT to given value.
 *
 * When writing to VRS_VOLTAGE_INIT, this is mandatory to use.
 *
 * @param value new value for VRS_VOLTAGE_INIT
 */
__COMMON_INLINE void COMMON_VRS_VOLTAGE_INIT__SET(uint32_t value)
{
    HAL_SET32(__COMMON_VRS_VOLTAGE_INIT__ADDRESS(), value);
}

/** COMMON_VRS_VOLTAGE_INIT__GET() gets VRS_VOLTAGE_INIT's current value.
 *
 * When reading from VRS_VOLTAGE_INIT, this is mandatory to use.
 *
 * @return current value of VRS_VOLTAGE_INIT
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__GET(void)
{
    return HAL_GET32(__COMMON_VRS_VOLTAGE_INIT__ADDRESS());
}

/* --------------- COMMON.VRS_VOLTAGE_INIT.VRS_MEAS_START_THR --------------- */

/**
<pre>
  COMMON.VRS_VOLTAGE_INIT.VRS_MEAS_START_THR:

    When Vrect same cycle measurement is enabled by vrs_same_cycle_en, this parameter defines the number of samples after vrs_track_start_thr before live updates are enabled.
    LSB = 40 ns, Range = 0 to 1240 ns

</pre> */

#define COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Pos        12                                                                     /*!< Right-most bit position of vrs_meas_start_thr in COMMON.VRS_VOLTAGE_INIT */
#define COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Msk        (0x0000001FUL << COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Pos)     /*!< Mask for vrs_meas_start_thr in COMMON.VRS_VOLTAGE_INIT */
#define COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Shift(v)   (((v) << COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Pos) & COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Msk) /*!< Shift value 'v' into vrs_meas_start_thr and mask 'v' to fit it into vrs_meas_start_thr field */

/** COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__SET() sets VRS_VOLTAGE_INIT.VRS_MEAS_START_THR to given value.
 *
 * When writing to VRS_VOLTAGE_INIT.VRS_MEAS_START_THR, this is recommended to use.
 *
 * @param bf_value new value for VRS_VOLTAGE_INIT.VRS_MEAS_START_THR
 */
__COMMON_INLINE void COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_VOLTAGE_INIT__GET();
    reg = (reg & ~COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Msk);
    reg = (reg | (COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Shift((uint32_t)bf_value)));
    COMMON_VRS_VOLTAGE_INIT__SET(reg);
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__GET() gets VRS_VOLTAGE_INIT.VRS_MEAS_START_THR's current value.
 *
 * When reading from VRS_VOLTAGE_INIT.VRS_MEAS_START_THR, this is recommended to use.
 *
 * @return current value of VRS_VOLTAGE_INIT.VRS_MEAS_START_THR
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__GET(void)
{
    uint32_t reg = COMMON_VRS_VOLTAGE_INIT__GET();
    reg = (reg & COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Msk);
    reg = (reg >> COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__MODIFY() modifies VRS_VOLTAGE_INIT.VRS_MEAS_START_THR.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_VOLTAGE_INIT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_VOLTAGE_INIT
 * @param bf_value new value for VRS_VOLTAGE_INIT.VRS_MEAS_START_THR
 * @return new value of COMMON.VRS_VOLTAGE_INIT
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Msk);
    reg = (reg | (COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__EXTRACT() extracts VRS_VOLTAGE_INIT.VRS_MEAS_START_THR.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_VOLTAGE_INIT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_VOLTAGE_INIT
 * @return current value of VRS_VOLTAGE_INIT.VRS_MEAS_START_THR
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Msk);
    reg = (reg >> COMMON_VRS_VOLTAGE_INIT__VRS_MEAS_START_THR__Pos);
    return (uint32_t)reg;
}

/* ------------------- COMMON.VRS_VOLTAGE_INIT.VRS_MIN_PW ------------------- */

/**
<pre>
  COMMON.VRS_VOLTAGE_INIT.VRS_MIN_PW:

    Vrect pulse width counter minimum pulse width.  Pulses less than this width are considered glitches and are ignored.
    LSB = 20ns, Range = 0 to 140ns

</pre> */

#define COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Pos                9                                                                      /*!< Right-most bit position of vrs_min_pw in COMMON.VRS_VOLTAGE_INIT */
#define COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Msk                (0x00000007UL << COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Pos)             /*!< Mask for vrs_min_pw in COMMON.VRS_VOLTAGE_INIT */
#define COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Shift(v)           (((v) << COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Pos) & COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Msk) /*!< Shift value 'v' into vrs_min_pw and mask 'v' to fit it into vrs_min_pw field */

/** COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__SET() sets VRS_VOLTAGE_INIT.VRS_MIN_PW to given value.
 *
 * When writing to VRS_VOLTAGE_INIT.VRS_MIN_PW, this is recommended to use.
 *
 * @param bf_value new value for VRS_VOLTAGE_INIT.VRS_MIN_PW
 */
__COMMON_INLINE void COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_VOLTAGE_INIT__GET();
    reg = (reg & ~COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Msk);
    reg = (reg | (COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Shift((uint32_t)bf_value)));
    COMMON_VRS_VOLTAGE_INIT__SET(reg);
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__GET() gets VRS_VOLTAGE_INIT.VRS_MIN_PW's current value.
 *
 * When reading from VRS_VOLTAGE_INIT.VRS_MIN_PW, this is recommended to use.
 *
 * @return current value of VRS_VOLTAGE_INIT.VRS_MIN_PW
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__GET(void)
{
    uint32_t reg = COMMON_VRS_VOLTAGE_INIT__GET();
    reg = (reg & COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Msk);
    reg = (reg >> COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__MODIFY() modifies VRS_VOLTAGE_INIT.VRS_MIN_PW.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_VOLTAGE_INIT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_VOLTAGE_INIT
 * @param bf_value new value for VRS_VOLTAGE_INIT.VRS_MIN_PW
 * @return new value of COMMON.VRS_VOLTAGE_INIT
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Msk);
    reg = (reg | (COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__EXTRACT() extracts VRS_VOLTAGE_INIT.VRS_MIN_PW.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_VOLTAGE_INIT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_VOLTAGE_INIT
 * @return current value of VRS_VOLTAGE_INIT.VRS_MIN_PW
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Msk);
    reg = (reg >> COMMON_VRS_VOLTAGE_INIT__VRS_MIN_PW__Pos);
    return (uint32_t)reg;
}

/* --------------- COMMON.VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN --------------- */

/**
<pre>
  COMMON.VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN:

    Vrect same cycle mode enable.  When enabled, live Vrect updates will begin vrs_meas_start_thr samples after entering tracking mode for faster feed forward response.  Otherwise Vrect will only be updated on the falling PWM edge.
    <start table>
    0 "Same cycle mode disabled"
    1 "Same cycle mode enabled"
    <end table>

</pre> */

#define COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Pos         8                                                                      /*!< Right-most bit position of vrs_same_cycle_en in COMMON.VRS_VOLTAGE_INIT */
#define COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Msk         (0x00000001UL << COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Pos)      /*!< Mask for vrs_same_cycle_en in COMMON.VRS_VOLTAGE_INIT */
#define COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Shift(v)    (((v) << COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Pos) & COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Msk) /*!< Shift value 'v' into vrs_same_cycle_en and mask 'v' to fit it into vrs_same_cycle_en field */

/** COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__SET() sets VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN to given value.
 *
 * When writing to VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN, this is recommended to use.
 *
 * @param bf_value new value for VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN
 */
__COMMON_INLINE void COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_VOLTAGE_INIT__GET();
    reg = (reg & ~COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Msk);
    reg = (reg | (COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Shift((uint32_t)bf_value)));
    COMMON_VRS_VOLTAGE_INIT__SET(reg);
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__GET() gets VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN's current value.
 *
 * When reading from VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN, this is recommended to use.
 *
 * @return current value of VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__GET(void)
{
    uint32_t reg = COMMON_VRS_VOLTAGE_INIT__GET();
    reg = (reg & COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Msk);
    reg = (reg >> COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__MODIFY() modifies VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_VOLTAGE_INIT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_VOLTAGE_INIT
 * @param bf_value new value for VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN
 * @return new value of COMMON.VRS_VOLTAGE_INIT
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Msk);
    reg = (reg | (COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__EXTRACT() extracts VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_VOLTAGE_INIT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_VOLTAGE_INIT
 * @return current value of VRS_VOLTAGE_INIT.VRS_SAME_CYCLE_EN
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Msk);
    reg = (reg >> COMMON_VRS_VOLTAGE_INIT__VRS_SAME_CYCLE_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------- COMMON.VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT ---------------- */

/**
<pre>
  COMMON.VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT:

    Initial voltage for VRSEN and BVRSEN tracking integrators when operating in VRS mode as observed at the VRSEN/BVRSEN inputs (i.e., after the sense resistor divider).  This setting must be greater than the rectification voltage corresponding to VIN_ON for controller startup when a rectification voltage is selcted for the input voltage telemetry input source by tlm_vin_src_sel.
    LSB = 20mV, Range = 0.0 to 2.1V

</pre> */

#define COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Pos          0                                                                      /*!< Right-most bit position of vrs_voltage_init in COMMON.VRS_VOLTAGE_INIT */
#define COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Msk          (0x000000FFUL << COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Pos)       /*!< Mask for vrs_voltage_init in COMMON.VRS_VOLTAGE_INIT */
#define COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Shift(v)     (((v) << COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Pos) & COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Msk) /*!< Shift value 'v' into vrs_voltage_init and mask 'v' to fit it into vrs_voltage_init field */

/** COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__SET() sets VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT to given value.
 *
 * When writing to VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT, this is recommended to use.
 *
 * @param bf_value new value for VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT
 */
__COMMON_INLINE void COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VRS_VOLTAGE_INIT__GET();
    reg = (reg & ~COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Msk);
    reg = (reg | (COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Shift((uint32_t)bf_value)));
    COMMON_VRS_VOLTAGE_INIT__SET(reg);
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__GET() gets VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT's current value.
 *
 * When reading from VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT, this is recommended to use.
 *
 * @return current value of VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__GET(void)
{
    uint32_t reg = COMMON_VRS_VOLTAGE_INIT__GET();
    reg = (reg & COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Msk);
    reg = (reg >> COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Pos);
    return (uint32_t)reg;
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__MODIFY() modifies VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VRS_VOLTAGE_INIT.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VRS_VOLTAGE_INIT
 * @param bf_value new value for VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT
 * @return new value of COMMON.VRS_VOLTAGE_INIT
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Msk);
    reg = (reg | (COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__EXTRACT() extracts VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VRS_VOLTAGE_INIT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VRS_VOLTAGE_INIT
 * @return current value of VRS_VOLTAGE_INIT.VRS_VOLTAGE_INIT
 */
__COMMON_INLINE uint32_t COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Msk);
    reg = (reg >> COMMON_VRS_VOLTAGE_INIT__VRS_VOLTAGE_INIT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         ISHARE member of COMMON_t                         */
/* -------------------------------------------------------------------------- */

/** __COMMON_ISHARE__ADDRESS returns the address of member ISHARE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ISHARE
 */
__COMMON_INLINE uint32_t* __COMMON_ISHARE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, ISHARE)));
}

/** COMMON_ISHARE__SET() sets ISHARE to given value.
 *
 * When writing to ISHARE, this is mandatory to use.
 *
 * @param value new value for ISHARE
 */
__COMMON_INLINE void COMMON_ISHARE__SET(uint32_t value)
{
    HAL_SET32(__COMMON_ISHARE__ADDRESS(), value);
}

/** COMMON_ISHARE__GET() gets ISHARE's current value.
 *
 * When reading from ISHARE, this is mandatory to use.
 *
 * @return current value of ISHARE
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__GET(void)
{
    return HAL_GET32(__COMMON_ISHARE__ADDRESS());
}

/* ------------------- COMMON.ISHARE.VRECT_OFFSET_BCK_BST ------------------- */

/**
<pre>
  COMMON.ISHARE.VRECT_OFFSET_BCK_BST:

    Rectification voltage offset for Buck-Boost topology.  Set to 0 for all other topologies.  When non-zero, the VRS computed Vrect output is modified as follows:
    <start table>
    "vrect_bck_bst(codes) = vrect_meas(codes) - vrect_offset_bck_bst(codes)"
    <end table>

</pre> */

#define COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Pos                17                                                                     /*!< Right-most bit position of vrect_offset_bck_bst in COMMON.ISHARE */
#define COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Msk                (0x000000FFUL << COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Pos)             /*!< Mask for vrect_offset_bck_bst in COMMON.ISHARE */
#define COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Shift(v)           (((v) << COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Pos) & COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Msk) /*!< Shift value 'v' into vrect_offset_bck_bst and mask 'v' to fit it into vrect_offset_bck_bst field */

/** COMMON_ISHARE__VRECT_OFFSET_BCK_BST__SET() sets ISHARE.VRECT_OFFSET_BCK_BST to given value.
 *
 * When writing to ISHARE.VRECT_OFFSET_BCK_BST, this is recommended to use.
 *
 * @param bf_value new value for ISHARE.VRECT_OFFSET_BCK_BST
 */
__COMMON_INLINE void COMMON_ISHARE__VRECT_OFFSET_BCK_BST__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_ISHARE__GET();
    reg = (reg & ~COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Msk);
    reg = (reg | (COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Shift((uint32_t)bf_value)));
    COMMON_ISHARE__SET(reg);
}

/** COMMON_ISHARE__VRECT_OFFSET_BCK_BST__GET() gets ISHARE.VRECT_OFFSET_BCK_BST's current value.
 *
 * When reading from ISHARE.VRECT_OFFSET_BCK_BST, this is recommended to use.
 *
 * @return current value of ISHARE.VRECT_OFFSET_BCK_BST
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__VRECT_OFFSET_BCK_BST__GET(void)
{
    uint32_t reg = COMMON_ISHARE__GET();
    reg = (reg & COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Msk);
    reg = (reg >> COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Pos);
    return (uint32_t)reg;
}

/** COMMON_ISHARE__VRECT_OFFSET_BCK_BST__MODIFY() modifies ISHARE.VRECT_OFFSET_BCK_BST.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.ISHARE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.ISHARE
 * @param bf_value new value for ISHARE.VRECT_OFFSET_BCK_BST
 * @return new value of COMMON.ISHARE
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__VRECT_OFFSET_BCK_BST__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Msk);
    reg = (reg | (COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_ISHARE__VRECT_OFFSET_BCK_BST__EXTRACT() extracts ISHARE.VRECT_OFFSET_BCK_BST.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.ISHARE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.ISHARE
 * @return current value of ISHARE.VRECT_OFFSET_BCK_BST
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__VRECT_OFFSET_BCK_BST__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Msk);
    reg = (reg >> COMMON_ISHARE__VRECT_OFFSET_BCK_BST__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.ISHARE.ISHR_KI ------------------------- */

/**
<pre>
  COMMON.ISHARE.ISHR_KI:

    Current sharing PI filter integral coefficient index.  Set to 0 to disable the integral component of the filter.  Note that index settings greater than 55 are clamped to 55.
    <start table>
    "ki_exp = ishr_ki[5:3]"
    "ki_man = 8 + ishr_ki[2:0]"
    "ki = kp_man * 2^ki_exp * 2^-12"
    <end table>

</pre> */

#define COMMON_ISHARE__ISHR_KI__Pos                             11                                                                     /*!< Right-most bit position of ishr_ki in COMMON.ISHARE */
#define COMMON_ISHARE__ISHR_KI__Msk                             (0x0000003FUL << COMMON_ISHARE__ISHR_KI__Pos)                          /*!< Mask for ishr_ki in COMMON.ISHARE */
#define COMMON_ISHARE__ISHR_KI__Shift(v)                        (((v) << COMMON_ISHARE__ISHR_KI__Pos) & COMMON_ISHARE__ISHR_KI__Msk)   /*!< Shift value 'v' into ishr_ki and mask 'v' to fit it into ishr_ki field */

/** COMMON_ISHARE__ISHR_KI__SET() sets ISHARE.ISHR_KI to given value.
 *
 * When writing to ISHARE.ISHR_KI, this is recommended to use.
 *
 * @param bf_value new value for ISHARE.ISHR_KI
 */
__COMMON_INLINE void COMMON_ISHARE__ISHR_KI__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_ISHARE__GET();
    reg = (reg & ~COMMON_ISHARE__ISHR_KI__Msk);
    reg = (reg | (COMMON_ISHARE__ISHR_KI__Shift((uint32_t)bf_value)));
    COMMON_ISHARE__SET(reg);
}

/** COMMON_ISHARE__ISHR_KI__GET() gets ISHARE.ISHR_KI's current value.
 *
 * When reading from ISHARE.ISHR_KI, this is recommended to use.
 *
 * @return current value of ISHARE.ISHR_KI
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__ISHR_KI__GET(void)
{
    uint32_t reg = COMMON_ISHARE__GET();
    reg = (reg & COMMON_ISHARE__ISHR_KI__Msk);
    reg = (reg >> COMMON_ISHARE__ISHR_KI__Pos);
    return (uint32_t)reg;
}

/** COMMON_ISHARE__ISHR_KI__MODIFY() modifies ISHARE.ISHR_KI.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.ISHARE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.ISHARE
 * @param bf_value new value for ISHARE.ISHR_KI
 * @return new value of COMMON.ISHARE
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__ISHR_KI__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_ISHARE__ISHR_KI__Msk);
    reg = (reg | (COMMON_ISHARE__ISHR_KI__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_ISHARE__ISHR_KI__EXTRACT() extracts ISHARE.ISHR_KI.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.ISHARE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.ISHARE
 * @return current value of ISHARE.ISHR_KI
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__ISHR_KI__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_ISHARE__ISHR_KI__Msk);
    reg = (reg >> COMMON_ISHARE__ISHR_KI__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.ISHARE.ISHR_KP ------------------------- */

/**
<pre>
  COMMON.ISHARE.ISHR_KP:

    Current sharing PI filter proportional coefficient index.  Set to 0 to disable the proportional component of the filter.  Note that index settings greater than 55 are clamped to 55.
    <start table>
    "kp_exp =ishr_kp[5:3]"
    "kp_man = 8 + ishr_kp[2:0]"
    "kp = kp_man * 2^kp_exp * 2^-10"
    <end table>

</pre> */

#define COMMON_ISHARE__ISHR_KP__Pos                             5                                                                      /*!< Right-most bit position of ishr_kp in COMMON.ISHARE */
#define COMMON_ISHARE__ISHR_KP__Msk                             (0x0000003FUL << COMMON_ISHARE__ISHR_KP__Pos)                          /*!< Mask for ishr_kp in COMMON.ISHARE */
#define COMMON_ISHARE__ISHR_KP__Shift(v)                        (((v) << COMMON_ISHARE__ISHR_KP__Pos) & COMMON_ISHARE__ISHR_KP__Msk)   /*!< Shift value 'v' into ishr_kp and mask 'v' to fit it into ishr_kp field */

/** COMMON_ISHARE__ISHR_KP__SET() sets ISHARE.ISHR_KP to given value.
 *
 * When writing to ISHARE.ISHR_KP, this is recommended to use.
 *
 * @param bf_value new value for ISHARE.ISHR_KP
 */
__COMMON_INLINE void COMMON_ISHARE__ISHR_KP__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_ISHARE__GET();
    reg = (reg & ~COMMON_ISHARE__ISHR_KP__Msk);
    reg = (reg | (COMMON_ISHARE__ISHR_KP__Shift((uint32_t)bf_value)));
    COMMON_ISHARE__SET(reg);
}

/** COMMON_ISHARE__ISHR_KP__GET() gets ISHARE.ISHR_KP's current value.
 *
 * When reading from ISHARE.ISHR_KP, this is recommended to use.
 *
 * @return current value of ISHARE.ISHR_KP
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__ISHR_KP__GET(void)
{
    uint32_t reg = COMMON_ISHARE__GET();
    reg = (reg & COMMON_ISHARE__ISHR_KP__Msk);
    reg = (reg >> COMMON_ISHARE__ISHR_KP__Pos);
    return (uint32_t)reg;
}

/** COMMON_ISHARE__ISHR_KP__MODIFY() modifies ISHARE.ISHR_KP.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.ISHARE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.ISHARE
 * @param bf_value new value for ISHARE.ISHR_KP
 * @return new value of COMMON.ISHARE
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__ISHR_KP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_ISHARE__ISHR_KP__Msk);
    reg = (reg | (COMMON_ISHARE__ISHR_KP__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_ISHARE__ISHR_KP__EXTRACT() extracts ISHARE.ISHR_KP.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.ISHARE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.ISHARE
 * @return current value of ISHARE.ISHR_KP
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__ISHR_KP__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_ISHARE__ISHR_KP__Msk);
    reg = (reg >> COMMON_ISHARE__ISHR_KP__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.ISHARE.ISHR_SCALE ------------------------ */

/**
<pre>
  COMMON.ISHARE.ISHR_SCALE:

    Used for current sharing, this register defines a pre-scale gain applied to the internal current telemetry before sending to the current output DAC on the IMON pin.  It setting should be computed as follows:
    <start table>
    "ishr_scale(U1.4) = integer(16 * (32 / max current))"
    <end table>

</pre> */

#define COMMON_ISHARE__ISHR_SCALE__Pos                          0                                                                      /*!< Right-most bit position of ishr_scale in COMMON.ISHARE */
#define COMMON_ISHARE__ISHR_SCALE__Msk                          (0x0000001FUL << COMMON_ISHARE__ISHR_SCALE__Pos)                       /*!< Mask for ishr_scale in COMMON.ISHARE */
#define COMMON_ISHARE__ISHR_SCALE__Shift(v)                     (((v) << COMMON_ISHARE__ISHR_SCALE__Pos) & COMMON_ISHARE__ISHR_SCALE__Msk) /*!< Shift value 'v' into ishr_scale and mask 'v' to fit it into ishr_scale field */

/** COMMON_ISHARE__ISHR_SCALE__SET() sets ISHARE.ISHR_SCALE to given value.
 *
 * When writing to ISHARE.ISHR_SCALE, this is recommended to use.
 *
 * @param bf_value new value for ISHARE.ISHR_SCALE
 */
__COMMON_INLINE void COMMON_ISHARE__ISHR_SCALE__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_ISHARE__GET();
    reg = (reg & ~COMMON_ISHARE__ISHR_SCALE__Msk);
    reg = (reg | (COMMON_ISHARE__ISHR_SCALE__Shift((uint32_t)bf_value)));
    COMMON_ISHARE__SET(reg);
}

/** COMMON_ISHARE__ISHR_SCALE__GET() gets ISHARE.ISHR_SCALE's current value.
 *
 * When reading from ISHARE.ISHR_SCALE, this is recommended to use.
 *
 * @return current value of ISHARE.ISHR_SCALE
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__ISHR_SCALE__GET(void)
{
    uint32_t reg = COMMON_ISHARE__GET();
    reg = (reg & COMMON_ISHARE__ISHR_SCALE__Msk);
    reg = (reg >> COMMON_ISHARE__ISHR_SCALE__Pos);
    return (uint32_t)reg;
}

/** COMMON_ISHARE__ISHR_SCALE__MODIFY() modifies ISHARE.ISHR_SCALE.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.ISHARE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.ISHARE
 * @param bf_value new value for ISHARE.ISHR_SCALE
 * @return new value of COMMON.ISHARE
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__ISHR_SCALE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_ISHARE__ISHR_SCALE__Msk);
    reg = (reg | (COMMON_ISHARE__ISHR_SCALE__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_ISHARE__ISHR_SCALE__EXTRACT() extracts ISHARE.ISHR_SCALE.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.ISHARE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.ISHARE
 * @return current value of ISHARE.ISHR_SCALE
 */
__COMMON_INLINE uint32_t COMMON_ISHARE__ISHR_SCALE__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_ISHARE__ISHR_SCALE__Msk);
    reg = (reg >> COMMON_ISHARE__ISHR_SCALE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         ISHARE1 member of COMMON_t                         */
/* -------------------------------------------------------------------------- */

/** __COMMON_ISHARE1__ADDRESS returns the address of member ISHARE1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ISHARE1
 */
__COMMON_INLINE uint32_t* __COMMON_ISHARE1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, ISHARE1)));
}

/** COMMON_ISHARE1__SET() sets ISHARE1 to given value.
 *
 * When writing to ISHARE1, this is mandatory to use.
 *
 * @param value new value for ISHARE1
 */
__COMMON_INLINE void COMMON_ISHARE1__SET(uint32_t value)
{
    HAL_SET32(__COMMON_ISHARE1__ADDRESS(), value);
}

/** COMMON_ISHARE1__GET() gets ISHARE1's current value.
 *
 * When reading from ISHARE1, this is mandatory to use.
 *
 * @return current value of ISHARE1
 */
__COMMON_INLINE uint32_t COMMON_ISHARE1__GET(void)
{
    return HAL_GET32(__COMMON_ISHARE1__ADDRESS());
}

/* -------------------- COMMON.ISHARE1.ISHARE_CLAMP_POS -------------------- */

/**
<pre>
  COMMON.ISHARE1.ISHARE_CLAMP_POS:

    Positive clamp applied to active current sharing voltage adjustment.  This value reflects the voltage at the VSEN input.  To convert to Vout divide by VOUT_SCALE_LOOP.
    LSB = 1.25mV, Range = 0.0 to 318.75mV

</pre> */

#define COMMON_ISHARE1__ISHARE_CLAMP_POS__Pos                   8                                                                      /*!< Right-most bit position of ishare_clamp_pos in COMMON.ISHARE1 */
#define COMMON_ISHARE1__ISHARE_CLAMP_POS__Msk                   (0x000000FFUL << COMMON_ISHARE1__ISHARE_CLAMP_POS__Pos)                /*!< Mask for ishare_clamp_pos in COMMON.ISHARE1 */
#define COMMON_ISHARE1__ISHARE_CLAMP_POS__Shift(v)              (((v) << COMMON_ISHARE1__ISHARE_CLAMP_POS__Pos) & COMMON_ISHARE1__ISHARE_CLAMP_POS__Msk) /*!< Shift value 'v' into ishare_clamp_pos and mask 'v' to fit it into ishare_clamp_pos field */

/** COMMON_ISHARE1__ISHARE_CLAMP_POS__SET() sets ISHARE1.ISHARE_CLAMP_POS to given value.
 *
 * When writing to ISHARE1.ISHARE_CLAMP_POS, this is recommended to use.
 *
 * @param bf_value new value for ISHARE1.ISHARE_CLAMP_POS
 */
__COMMON_INLINE void COMMON_ISHARE1__ISHARE_CLAMP_POS__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_ISHARE1__GET();
    reg = (reg & ~COMMON_ISHARE1__ISHARE_CLAMP_POS__Msk);
    reg = (reg | (COMMON_ISHARE1__ISHARE_CLAMP_POS__Shift((uint32_t)bf_value)));
    COMMON_ISHARE1__SET(reg);
}

/** COMMON_ISHARE1__ISHARE_CLAMP_POS__GET() gets ISHARE1.ISHARE_CLAMP_POS's current value.
 *
 * When reading from ISHARE1.ISHARE_CLAMP_POS, this is recommended to use.
 *
 * @return current value of ISHARE1.ISHARE_CLAMP_POS
 */
__COMMON_INLINE uint32_t COMMON_ISHARE1__ISHARE_CLAMP_POS__GET(void)
{
    uint32_t reg = COMMON_ISHARE1__GET();
    reg = (reg & COMMON_ISHARE1__ISHARE_CLAMP_POS__Msk);
    reg = (reg >> COMMON_ISHARE1__ISHARE_CLAMP_POS__Pos);
    return (uint32_t)reg;
}

/** COMMON_ISHARE1__ISHARE_CLAMP_POS__MODIFY() modifies ISHARE1.ISHARE_CLAMP_POS.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.ISHARE1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.ISHARE1
 * @param bf_value new value for ISHARE1.ISHARE_CLAMP_POS
 * @return new value of COMMON.ISHARE1
 */
__COMMON_INLINE uint32_t COMMON_ISHARE1__ISHARE_CLAMP_POS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_ISHARE1__ISHARE_CLAMP_POS__Msk);
    reg = (reg | (COMMON_ISHARE1__ISHARE_CLAMP_POS__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_ISHARE1__ISHARE_CLAMP_POS__EXTRACT() extracts ISHARE1.ISHARE_CLAMP_POS.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.ISHARE1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.ISHARE1
 * @return current value of ISHARE1.ISHARE_CLAMP_POS
 */
__COMMON_INLINE uint32_t COMMON_ISHARE1__ISHARE_CLAMP_POS__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_ISHARE1__ISHARE_CLAMP_POS__Msk);
    reg = (reg >> COMMON_ISHARE1__ISHARE_CLAMP_POS__Pos);
    return (uint32_t)reg;
}

/* -------------------- COMMON.ISHARE1.ISHARE_CLAMP_NEG -------------------- */

/**
<pre>
  COMMON.ISHARE1.ISHARE_CLAMP_NEG:

    Negative clamp applied to active current sharing voltage adjustment.  This value reflects the voltage at the VSEN input.  To convert to Vout divide by VOUT_SCALE_LOOP.
    LSB = -1.25mV, Range = 0.0 to -318.75mV

</pre> */

#define COMMON_ISHARE1__ISHARE_CLAMP_NEG__Pos                   0                                                                      /*!< Right-most bit position of ishare_clamp_neg in COMMON.ISHARE1 */
#define COMMON_ISHARE1__ISHARE_CLAMP_NEG__Msk                   (0x000000FFUL << COMMON_ISHARE1__ISHARE_CLAMP_NEG__Pos)                /*!< Mask for ishare_clamp_neg in COMMON.ISHARE1 */
#define COMMON_ISHARE1__ISHARE_CLAMP_NEG__Shift(v)              (((v) << COMMON_ISHARE1__ISHARE_CLAMP_NEG__Pos) & COMMON_ISHARE1__ISHARE_CLAMP_NEG__Msk) /*!< Shift value 'v' into ishare_clamp_neg and mask 'v' to fit it into ishare_clamp_neg field */

/** COMMON_ISHARE1__ISHARE_CLAMP_NEG__SET() sets ISHARE1.ISHARE_CLAMP_NEG to given value.
 *
 * When writing to ISHARE1.ISHARE_CLAMP_NEG, this is recommended to use.
 *
 * @param bf_value new value for ISHARE1.ISHARE_CLAMP_NEG
 */
__COMMON_INLINE void COMMON_ISHARE1__ISHARE_CLAMP_NEG__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_ISHARE1__GET();
    reg = (reg & ~COMMON_ISHARE1__ISHARE_CLAMP_NEG__Msk);
    reg = (reg | (COMMON_ISHARE1__ISHARE_CLAMP_NEG__Shift((uint32_t)bf_value)));
    COMMON_ISHARE1__SET(reg);
}

/** COMMON_ISHARE1__ISHARE_CLAMP_NEG__GET() gets ISHARE1.ISHARE_CLAMP_NEG's current value.
 *
 * When reading from ISHARE1.ISHARE_CLAMP_NEG, this is recommended to use.
 *
 * @return current value of ISHARE1.ISHARE_CLAMP_NEG
 */
__COMMON_INLINE uint32_t COMMON_ISHARE1__ISHARE_CLAMP_NEG__GET(void)
{
    uint32_t reg = COMMON_ISHARE1__GET();
    reg = (reg & COMMON_ISHARE1__ISHARE_CLAMP_NEG__Msk);
    reg = (reg >> COMMON_ISHARE1__ISHARE_CLAMP_NEG__Pos);
    return (uint32_t)reg;
}

/** COMMON_ISHARE1__ISHARE_CLAMP_NEG__MODIFY() modifies ISHARE1.ISHARE_CLAMP_NEG.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.ISHARE1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.ISHARE1
 * @param bf_value new value for ISHARE1.ISHARE_CLAMP_NEG
 * @return new value of COMMON.ISHARE1
 */
__COMMON_INLINE uint32_t COMMON_ISHARE1__ISHARE_CLAMP_NEG__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_ISHARE1__ISHARE_CLAMP_NEG__Msk);
    reg = (reg | (COMMON_ISHARE1__ISHARE_CLAMP_NEG__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_ISHARE1__ISHARE_CLAMP_NEG__EXTRACT() extracts ISHARE1.ISHARE_CLAMP_NEG.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.ISHARE1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.ISHARE1
 * @return current value of ISHARE1.ISHARE_CLAMP_NEG
 */
__COMMON_INLINE uint32_t COMMON_ISHARE1__ISHARE_CLAMP_NEG__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_ISHARE1__ISHARE_CLAMP_NEG__Msk);
    reg = (reg >> COMMON_ISHARE1__ISHARE_CLAMP_NEG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        GPIO_DBEN member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_GPIO_DBEN__ADDRESS returns the address of member GPIO_DBEN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of GPIO_DBEN
 */
__COMMON_INLINE uint32_t* __COMMON_GPIO_DBEN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, GPIO_DBEN)));
}

/** COMMON_GPIO_DBEN__SET() sets GPIO_DBEN to given value.
 *
 * When writing to GPIO_DBEN, this is mandatory to use.
 *
 * @param value new value for GPIO_DBEN
 */
__COMMON_INLINE void COMMON_GPIO_DBEN__SET(uint32_t value)
{
    HAL_SET32(__COMMON_GPIO_DBEN__ADDRESS(), value);
}

/** COMMON_GPIO_DBEN__GET() gets GPIO_DBEN's current value.
 *
 * When reading from GPIO_DBEN, this is mandatory to use.
 *
 * @return current value of GPIO_DBEN
 */
__COMMON_INLINE uint32_t COMMON_GPIO_DBEN__GET(void)
{
    return HAL_GET32(__COMMON_GPIO_DBEN__ADDRESS());
}

/* ---------------------- COMMON.GPIO_DBEN.GPIO1_DBEN ---------------------- */

/**
<pre>
  COMMON.GPIO_DBEN.GPIO1_DBEN:

    GPIO1 bus input deglitch enable
    <start table>
    0 "deglitch disabled"
    1 "deglitch enabled"
    <end table>

</pre> */

#define COMMON_GPIO_DBEN__GPIO1_DBEN__Pos                       24                                                                     /*!< Right-most bit position of gpio1_dben in COMMON.GPIO_DBEN */
#define COMMON_GPIO_DBEN__GPIO1_DBEN__Msk                       (0x000000FFUL << COMMON_GPIO_DBEN__GPIO1_DBEN__Pos)                    /*!< Mask for gpio1_dben in COMMON.GPIO_DBEN */
#define COMMON_GPIO_DBEN__GPIO1_DBEN__Shift(v)                  (((v) << COMMON_GPIO_DBEN__GPIO1_DBEN__Pos) & COMMON_GPIO_DBEN__GPIO1_DBEN__Msk) /*!< Shift value 'v' into gpio1_dben and mask 'v' to fit it into gpio1_dben field */

/** COMMON_GPIO_DBEN__GPIO1_DBEN__SET() sets GPIO_DBEN.GPIO1_DBEN to given value.
 *
 * When writing to GPIO_DBEN.GPIO1_DBEN, this is recommended to use.
 *
 * @param bf_value new value for GPIO_DBEN.GPIO1_DBEN
 */
__COMMON_INLINE void COMMON_GPIO_DBEN__GPIO1_DBEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_GPIO_DBEN__GET();
    reg = (reg & ~COMMON_GPIO_DBEN__GPIO1_DBEN__Msk);
    reg = (reg | (COMMON_GPIO_DBEN__GPIO1_DBEN__Shift((uint32_t)bf_value)));
    COMMON_GPIO_DBEN__SET(reg);
}

/** COMMON_GPIO_DBEN__GPIO1_DBEN__GET() gets GPIO_DBEN.GPIO1_DBEN's current value.
 *
 * When reading from GPIO_DBEN.GPIO1_DBEN, this is recommended to use.
 *
 * @return current value of GPIO_DBEN.GPIO1_DBEN
 */
__COMMON_INLINE uint32_t COMMON_GPIO_DBEN__GPIO1_DBEN__GET(void)
{
    uint32_t reg = COMMON_GPIO_DBEN__GET();
    reg = (reg & COMMON_GPIO_DBEN__GPIO1_DBEN__Msk);
    reg = (reg >> COMMON_GPIO_DBEN__GPIO1_DBEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_GPIO_DBEN__GPIO1_DBEN__MODIFY() modifies GPIO_DBEN.GPIO1_DBEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.GPIO_DBEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.GPIO_DBEN
 * @param bf_value new value for GPIO_DBEN.GPIO1_DBEN
 * @return new value of COMMON.GPIO_DBEN
 */
__COMMON_INLINE uint32_t COMMON_GPIO_DBEN__GPIO1_DBEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_GPIO_DBEN__GPIO1_DBEN__Msk);
    reg = (reg | (COMMON_GPIO_DBEN__GPIO1_DBEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_GPIO_DBEN__GPIO1_DBEN__EXTRACT() extracts GPIO_DBEN.GPIO1_DBEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.GPIO_DBEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.GPIO_DBEN
 * @return current value of GPIO_DBEN.GPIO1_DBEN
 */
__COMMON_INLINE uint32_t COMMON_GPIO_DBEN__GPIO1_DBEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_GPIO_DBEN__GPIO1_DBEN__Msk);
    reg = (reg >> COMMON_GPIO_DBEN__GPIO1_DBEN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.GPIO_DBEN.GPIO0_DBEN ---------------------- */

/**
<pre>
  COMMON.GPIO_DBEN.GPIO0_DBEN:

    GPIO0 bus input deglitch enable
    <start table>
    0 "deglitch disabled"
    1 "deglitch enabled"
    <end table>

</pre> */

#define COMMON_GPIO_DBEN__GPIO0_DBEN__Pos                       16                                                                     /*!< Right-most bit position of gpio0_dben in COMMON.GPIO_DBEN */
#define COMMON_GPIO_DBEN__GPIO0_DBEN__Msk                       (0x000000FFUL << COMMON_GPIO_DBEN__GPIO0_DBEN__Pos)                    /*!< Mask for gpio0_dben in COMMON.GPIO_DBEN */
#define COMMON_GPIO_DBEN__GPIO0_DBEN__Shift(v)                  (((v) << COMMON_GPIO_DBEN__GPIO0_DBEN__Pos) & COMMON_GPIO_DBEN__GPIO0_DBEN__Msk) /*!< Shift value 'v' into gpio0_dben and mask 'v' to fit it into gpio0_dben field */

/** COMMON_GPIO_DBEN__GPIO0_DBEN__SET() sets GPIO_DBEN.GPIO0_DBEN to given value.
 *
 * When writing to GPIO_DBEN.GPIO0_DBEN, this is recommended to use.
 *
 * @param bf_value new value for GPIO_DBEN.GPIO0_DBEN
 */
__COMMON_INLINE void COMMON_GPIO_DBEN__GPIO0_DBEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_GPIO_DBEN__GET();
    reg = (reg & ~COMMON_GPIO_DBEN__GPIO0_DBEN__Msk);
    reg = (reg | (COMMON_GPIO_DBEN__GPIO0_DBEN__Shift((uint32_t)bf_value)));
    COMMON_GPIO_DBEN__SET(reg);
}

/** COMMON_GPIO_DBEN__GPIO0_DBEN__GET() gets GPIO_DBEN.GPIO0_DBEN's current value.
 *
 * When reading from GPIO_DBEN.GPIO0_DBEN, this is recommended to use.
 *
 * @return current value of GPIO_DBEN.GPIO0_DBEN
 */
__COMMON_INLINE uint32_t COMMON_GPIO_DBEN__GPIO0_DBEN__GET(void)
{
    uint32_t reg = COMMON_GPIO_DBEN__GET();
    reg = (reg & COMMON_GPIO_DBEN__GPIO0_DBEN__Msk);
    reg = (reg >> COMMON_GPIO_DBEN__GPIO0_DBEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_GPIO_DBEN__GPIO0_DBEN__MODIFY() modifies GPIO_DBEN.GPIO0_DBEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.GPIO_DBEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.GPIO_DBEN
 * @param bf_value new value for GPIO_DBEN.GPIO0_DBEN
 * @return new value of COMMON.GPIO_DBEN
 */
__COMMON_INLINE uint32_t COMMON_GPIO_DBEN__GPIO0_DBEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_GPIO_DBEN__GPIO0_DBEN__Msk);
    reg = (reg | (COMMON_GPIO_DBEN__GPIO0_DBEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_GPIO_DBEN__GPIO0_DBEN__EXTRACT() extracts GPIO_DBEN.GPIO0_DBEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.GPIO_DBEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.GPIO_DBEN
 * @return current value of GPIO_DBEN.GPIO0_DBEN
 */
__COMMON_INLINE uint32_t COMMON_GPIO_DBEN__GPIO0_DBEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_GPIO_DBEN__GPIO0_DBEN__Msk);
    reg = (reg >> COMMON_GPIO_DBEN__GPIO0_DBEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.GPIO_DBEN.SPARE_CFG ----------------------- */

/**
<pre>
  COMMON.GPIO_DBEN.SPARE_CFG:

    Spare configuration register space

</pre> */

#define COMMON_GPIO_DBEN__SPARE_CFG__Pos                        0                                                                      /*!< Right-most bit position of spare_cfg in COMMON.GPIO_DBEN */
#define COMMON_GPIO_DBEN__SPARE_CFG__Msk                        (0x0000FFFFUL << COMMON_GPIO_DBEN__SPARE_CFG__Pos)                     /*!< Mask for spare_cfg in COMMON.GPIO_DBEN */
#define COMMON_GPIO_DBEN__SPARE_CFG__Shift(v)                   (((v) << COMMON_GPIO_DBEN__SPARE_CFG__Pos) & COMMON_GPIO_DBEN__SPARE_CFG__Msk) /*!< Shift value 'v' into spare_cfg and mask 'v' to fit it into spare_cfg field */

/** COMMON_GPIO_DBEN__SPARE_CFG__SET() sets GPIO_DBEN.SPARE_CFG to given value.
 *
 * When writing to GPIO_DBEN.SPARE_CFG, this is recommended to use.
 *
 * @param bf_value new value for GPIO_DBEN.SPARE_CFG
 */
__COMMON_INLINE void COMMON_GPIO_DBEN__SPARE_CFG__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_GPIO_DBEN__GET();
    reg = (reg & ~COMMON_GPIO_DBEN__SPARE_CFG__Msk);
    reg = (reg | (COMMON_GPIO_DBEN__SPARE_CFG__Shift((uint32_t)bf_value)));
    COMMON_GPIO_DBEN__SET(reg);
}

/** COMMON_GPIO_DBEN__SPARE_CFG__GET() gets GPIO_DBEN.SPARE_CFG's current value.
 *
 * When reading from GPIO_DBEN.SPARE_CFG, this is recommended to use.
 *
 * @return current value of GPIO_DBEN.SPARE_CFG
 */
__COMMON_INLINE uint32_t COMMON_GPIO_DBEN__SPARE_CFG__GET(void)
{
    uint32_t reg = COMMON_GPIO_DBEN__GET();
    reg = (reg & COMMON_GPIO_DBEN__SPARE_CFG__Msk);
    reg = (reg >> COMMON_GPIO_DBEN__SPARE_CFG__Pos);
    return (uint32_t)reg;
}

/** COMMON_GPIO_DBEN__SPARE_CFG__MODIFY() modifies GPIO_DBEN.SPARE_CFG.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.GPIO_DBEN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.GPIO_DBEN
 * @param bf_value new value for GPIO_DBEN.SPARE_CFG
 * @return new value of COMMON.GPIO_DBEN
 */
__COMMON_INLINE uint32_t COMMON_GPIO_DBEN__SPARE_CFG__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_GPIO_DBEN__SPARE_CFG__Msk);
    reg = (reg | (COMMON_GPIO_DBEN__SPARE_CFG__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_GPIO_DBEN__SPARE_CFG__EXTRACT() extracts GPIO_DBEN.SPARE_CFG.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.GPIO_DBEN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.GPIO_DBEN
 * @return current value of GPIO_DBEN.SPARE_CFG
 */
__COMMON_INLINE uint32_t COMMON_GPIO_DBEN__SPARE_CFG__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_GPIO_DBEN__SPARE_CFG__Msk);
    reg = (reg >> COMMON_GPIO_DBEN__SPARE_CFG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          CGATE member of COMMON_t                          */
/* -------------------------------------------------------------------------- */

/** __COMMON_CGATE__ADDRESS returns the address of member CGATE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CGATE
 */
__COMMON_INLINE uint32_t* __COMMON_CGATE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, CGATE)));
}

/** COMMON_CGATE__SET() sets CGATE to given value.
 *
 * When writing to CGATE, this is mandatory to use.
 *
 * @param value new value for CGATE
 */
__COMMON_INLINE void COMMON_CGATE__SET(uint32_t value)
{
    HAL_SET32(__COMMON_CGATE__ADDRESS(), value);
}

/** COMMON_CGATE__GET() gets CGATE's current value.
 *
 * When reading from CGATE, this is mandatory to use.
 *
 * @return current value of CGATE
 */
__COMMON_INLINE uint32_t COMMON_CGATE__GET(void)
{
    return HAL_GET32(__COMMON_CGATE__ADDRESS());
}

/* ----------------------- COMMON.CGATE.CGATE_BYPASS ----------------------- */

/**
<pre>
  COMMON.CGATE.CGATE_BYPASS:

    HW block clock gating bypassed when bit is high.  In general, since the HW block enables are FW controlled, these bits should all be set to 0.
    <start table>
    0 "PWM excluding RAMPS" 12 "Telemetry"
    1 " PWM Ramp 0" 13 "Faults"
    2 "PWM Ramp 1" 14 "CE / Digital L 0"
    3 "VSP0" 15 "CE / Digital L 1"
    4 "VSP1" 16 "IS1"
    5 "VSP2" 17 "IS2"
    6 "VS0" 18 "IS3"
    7 "VS1" 19 "Vcontrol0, PID0"
    8 "VS2" 20 "Vcontrol1, PID1"
    9 "VRS1" 21 "Ishare"
    10 "VRS2" 22 "Balance"
    11 "TSA, TSD, TSP" 23 "Fan"
    <end table>

</pre> */

#define COMMON_CGATE__CGATE_BYPASS__Pos                         0                                                                      /*!< Right-most bit position of cgate_bypass in COMMON.CGATE */
#define COMMON_CGATE__CGATE_BYPASS__Msk                         (0x00FFFFFFUL << COMMON_CGATE__CGATE_BYPASS__Pos)                      /*!< Mask for cgate_bypass in COMMON.CGATE */
#define COMMON_CGATE__CGATE_BYPASS__Shift(v)                    (((v) << COMMON_CGATE__CGATE_BYPASS__Pos) & COMMON_CGATE__CGATE_BYPASS__Msk) /*!< Shift value 'v' into cgate_bypass and mask 'v' to fit it into cgate_bypass field */

/** COMMON_CGATE__CGATE_BYPASS__SET() sets CGATE.CGATE_BYPASS to given value.
 *
 * When writing to CGATE.CGATE_BYPASS, this is recommended to use.
 *
 * @param bf_value new value for CGATE.CGATE_BYPASS
 */
__COMMON_INLINE void COMMON_CGATE__CGATE_BYPASS__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_CGATE__GET();
    reg = (reg & ~COMMON_CGATE__CGATE_BYPASS__Msk);
    reg = (reg | (COMMON_CGATE__CGATE_BYPASS__Shift((uint32_t)bf_value)));
    COMMON_CGATE__SET(reg);
}

/** COMMON_CGATE__CGATE_BYPASS__GET() gets CGATE.CGATE_BYPASS's current value.
 *
 * When reading from CGATE.CGATE_BYPASS, this is recommended to use.
 *
 * @return current value of CGATE.CGATE_BYPASS
 */
__COMMON_INLINE uint32_t COMMON_CGATE__CGATE_BYPASS__GET(void)
{
    uint32_t reg = COMMON_CGATE__GET();
    reg = (reg & COMMON_CGATE__CGATE_BYPASS__Msk);
    reg = (reg >> COMMON_CGATE__CGATE_BYPASS__Pos);
    return (uint32_t)reg;
}

/** COMMON_CGATE__CGATE_BYPASS__MODIFY() modifies CGATE.CGATE_BYPASS.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.CGATE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.CGATE
 * @param bf_value new value for CGATE.CGATE_BYPASS
 * @return new value of COMMON.CGATE
 */
__COMMON_INLINE uint32_t COMMON_CGATE__CGATE_BYPASS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_CGATE__CGATE_BYPASS__Msk);
    reg = (reg | (COMMON_CGATE__CGATE_BYPASS__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_CGATE__CGATE_BYPASS__EXTRACT() extracts CGATE.CGATE_BYPASS.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.CGATE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.CGATE
 * @return current value of CGATE.CGATE_BYPASS
 */
__COMMON_INLINE uint32_t COMMON_CGATE__CGATE_BYPASS__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_CGATE__CGATE_BYPASS__Msk);
    reg = (reg >> COMMON_CGATE__CGATE_BYPASS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       FBAL_THRESH member of COMMON_t                       */
/* -------------------------------------------------------------------------- */

/** __COMMON_FBAL_THRESH__ADDRESS returns the address of member FBAL_THRESH.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FBAL_THRESH
 */
__COMMON_INLINE uint32_t* __COMMON_FBAL_THRESH__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, FBAL_THRESH)));
}

/** COMMON_FBAL_THRESH__SET() sets FBAL_THRESH to given value.
 *
 * When writing to FBAL_THRESH, this is mandatory to use.
 *
 * @param value new value for FBAL_THRESH
 */
__COMMON_INLINE void COMMON_FBAL_THRESH__SET(uint32_t value)
{
    HAL_SET32(__COMMON_FBAL_THRESH__ADDRESS(), value);
}

/** COMMON_FBAL_THRESH__GET() gets FBAL_THRESH's current value.
 *
 * When reading from FBAL_THRESH, this is mandatory to use.
 *
 * @return current value of FBAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__GET(void)
{
    return HAL_GET32(__COMMON_FBAL_THRESH__ADDRESS());
}

/* --------------- COMMON.FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ --------------- */

/**
<pre>
  COMMON.FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ:

    When flux balancing is disabled due to low current, this paramter determines whether to zero out the flux balance duty cycle correction or to freeze the duty cycle correction at its current value.
    <start table>
    0 "freeze the flux balance correction"
    1 "zero out the flux balance correction (recommended)"
    <end table>

</pre> */

#define COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Pos         24                                                                     /*!< Right-most bit position of fbal_dcm_0out_duty_adj in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Msk         (0x00000001UL << COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Pos)      /*!< Mask for fbal_dcm_0out_duty_adj in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Shift(v)    (((v) << COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Pos) & COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Msk) /*!< Shift value 'v' into fbal_dcm_0out_duty_adj and mask 'v' to fit it into fbal_dcm_0out_duty_adj field */

/** COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__SET() sets FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ to given value.
 *
 * When writing to FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ, this is recommended to use.
 *
 * @param bf_value new value for FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ
 */
__COMMON_INLINE void COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Shift((uint32_t)bf_value)));
    COMMON_FBAL_THRESH__SET(reg);
}

/** COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__GET() gets FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ's current value.
 *
 * When reading from FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ, this is recommended to use.
 *
 * @return current value of FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__GET(void)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__MODIFY() modifies FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL_THRESH.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @param bf_value new value for FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ
 * @return new value of COMMON.FBAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__EXTRACT() extracts FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL_THRESH.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @return current value of FBAL_THRESH.FBAL_DCM_0OUT_DUTY_ADJ
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_DCM_0OUT_DUTY_ADJ__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.FBAL_THRESH.FBAL_DCM_ENA_CNT ------------------ */

/**
<pre>
  COMMON.FBAL_THRESH.FBAL_DCM_ENA_CNT:

    Defines the number of consectutive current samples above fbal_dcm_thresh required to re-enable flux balancing.
    LSB = 1 Tsw, Range = 1 to 4 Tsw

</pre> */

#define COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Pos               22                                                                     /*!< Right-most bit position of fbal_dcm_ena_cnt in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Msk               (0x00000003UL << COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Pos)            /*!< Mask for fbal_dcm_ena_cnt in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Shift(v)          (((v) << COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Pos) & COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Msk) /*!< Shift value 'v' into fbal_dcm_ena_cnt and mask 'v' to fit it into fbal_dcm_ena_cnt field */

/** COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__SET() sets FBAL_THRESH.FBAL_DCM_ENA_CNT to given value.
 *
 * When writing to FBAL_THRESH.FBAL_DCM_ENA_CNT, this is recommended to use.
 *
 * @param bf_value new value for FBAL_THRESH.FBAL_DCM_ENA_CNT
 */
__COMMON_INLINE void COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Shift((uint32_t)bf_value)));
    COMMON_FBAL_THRESH__SET(reg);
}

/** COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__GET() gets FBAL_THRESH.FBAL_DCM_ENA_CNT's current value.
 *
 * When reading from FBAL_THRESH.FBAL_DCM_ENA_CNT, this is recommended to use.
 *
 * @return current value of FBAL_THRESH.FBAL_DCM_ENA_CNT
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__GET(void)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__MODIFY() modifies FBAL_THRESH.FBAL_DCM_ENA_CNT.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL_THRESH.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @param bf_value new value for FBAL_THRESH.FBAL_DCM_ENA_CNT
 * @return new value of COMMON.FBAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__EXTRACT() extracts FBAL_THRESH.FBAL_DCM_ENA_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL_THRESH.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @return current value of FBAL_THRESH.FBAL_DCM_ENA_CNT
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_DCM_ENA_CNT__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.FBAL_THRESH.FBAL_DCM_DIS_CNT ------------------ */

/**
<pre>
  COMMON.FBAL_THRESH.FBAL_DCM_DIS_CNT:

    Defines the number of consectutive current samples below fbal_dcm_thresh required to disable flux balancing.
    LSB = 1 Tsw, Range = 1 to 4 Tsw

</pre> */

#define COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Pos               20                                                                     /*!< Right-most bit position of fbal_dcm_dis_cnt in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Msk               (0x00000003UL << COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Pos)            /*!< Mask for fbal_dcm_dis_cnt in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Shift(v)          (((v) << COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Pos) & COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Msk) /*!< Shift value 'v' into fbal_dcm_dis_cnt and mask 'v' to fit it into fbal_dcm_dis_cnt field */

/** COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__SET() sets FBAL_THRESH.FBAL_DCM_DIS_CNT to given value.
 *
 * When writing to FBAL_THRESH.FBAL_DCM_DIS_CNT, this is recommended to use.
 *
 * @param bf_value new value for FBAL_THRESH.FBAL_DCM_DIS_CNT
 */
__COMMON_INLINE void COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Shift((uint32_t)bf_value)));
    COMMON_FBAL_THRESH__SET(reg);
}

/** COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__GET() gets FBAL_THRESH.FBAL_DCM_DIS_CNT's current value.
 *
 * When reading from FBAL_THRESH.FBAL_DCM_DIS_CNT, this is recommended to use.
 *
 * @return current value of FBAL_THRESH.FBAL_DCM_DIS_CNT
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__GET(void)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__MODIFY() modifies FBAL_THRESH.FBAL_DCM_DIS_CNT.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL_THRESH.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @param bf_value new value for FBAL_THRESH.FBAL_DCM_DIS_CNT
 * @return new value of COMMON.FBAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__EXTRACT() extracts FBAL_THRESH.FBAL_DCM_DIS_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL_THRESH.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @return current value of FBAL_THRESH.FBAL_DCM_DIS_CNT
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_DCM_DIS_CNT__Pos);
    return (uint32_t)reg;
}

/* ------------------- COMMON.FBAL_THRESH.FBAL_DCM_THRESH ------------------- */

/**
<pre>
  COMMON.FBAL_THRESH.FBAL_DCM_THRESH:

    When the inductor current goes negative the flux balance Vrect pulse width measurement may become inaccurate.  It is recommented to disable flux balancing at low current levels to prevent incorrect flux balance correction from occuring.  This parameter defines the output current level below which the flux balance correction is disabled.  At setting of 63 disables this feature.
    LSB = 0.5A, Range = 0.0 to 31.5A

</pre> */

#define COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Pos                14                                                                     /*!< Right-most bit position of fbal_dcm_thresh in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Msk                (0x0000003FUL << COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Pos)             /*!< Mask for fbal_dcm_thresh in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Shift(v)           (((v) << COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Pos) & COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Msk) /*!< Shift value 'v' into fbal_dcm_thresh and mask 'v' to fit it into fbal_dcm_thresh field */

/** COMMON_FBAL_THRESH__FBAL_DCM_THRESH__SET() sets FBAL_THRESH.FBAL_DCM_THRESH to given value.
 *
 * When writing to FBAL_THRESH.FBAL_DCM_THRESH, this is recommended to use.
 *
 * @param bf_value new value for FBAL_THRESH.FBAL_DCM_THRESH
 */
__COMMON_INLINE void COMMON_FBAL_THRESH__FBAL_DCM_THRESH__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Shift((uint32_t)bf_value)));
    COMMON_FBAL_THRESH__SET(reg);
}

/** COMMON_FBAL_THRESH__FBAL_DCM_THRESH__GET() gets FBAL_THRESH.FBAL_DCM_THRESH's current value.
 *
 * When reading from FBAL_THRESH.FBAL_DCM_THRESH, this is recommended to use.
 *
 * @return current value of FBAL_THRESH.FBAL_DCM_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_THRESH__GET(void)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL_THRESH__FBAL_DCM_THRESH__MODIFY() modifies FBAL_THRESH.FBAL_DCM_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL_THRESH.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @param bf_value new value for FBAL_THRESH.FBAL_DCM_THRESH
 * @return new value of COMMON.FBAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL_THRESH__FBAL_DCM_THRESH__EXTRACT() extracts FBAL_THRESH.FBAL_DCM_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL_THRESH.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @return current value of FBAL_THRESH.FBAL_DCM_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DCM_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_DCM_THRESH__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.FBAL_THRESH.FBAL_DELTA_ABS_EN ------------------ */

/**
<pre>
  COMMON.FBAL_THRESH.FBAL_DELTA_ABS_EN:

    In flux balance computation, determines whether absolute value applied to the error before or after the low pass filter.
    <start table>
    0 "convert to abs value after lpf"
    1 "convert to abs value before lpf"
    <end table>

</pre> */

#define COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Pos              13                                                                     /*!< Right-most bit position of fbal_delta_abs_en in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Msk              (0x00000001UL << COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Pos)           /*!< Mask for fbal_delta_abs_en in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Shift(v)         (((v) << COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Pos) & COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Msk) /*!< Shift value 'v' into fbal_delta_abs_en and mask 'v' to fit it into fbal_delta_abs_en field */

/** COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__SET() sets FBAL_THRESH.FBAL_DELTA_ABS_EN to given value.
 *
 * When writing to FBAL_THRESH.FBAL_DELTA_ABS_EN, this is recommended to use.
 *
 * @param bf_value new value for FBAL_THRESH.FBAL_DELTA_ABS_EN
 */
__COMMON_INLINE void COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Shift((uint32_t)bf_value)));
    COMMON_FBAL_THRESH__SET(reg);
}

/** COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__GET() gets FBAL_THRESH.FBAL_DELTA_ABS_EN's current value.
 *
 * When reading from FBAL_THRESH.FBAL_DELTA_ABS_EN, this is recommended to use.
 *
 * @return current value of FBAL_THRESH.FBAL_DELTA_ABS_EN
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__GET(void)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__MODIFY() modifies FBAL_THRESH.FBAL_DELTA_ABS_EN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL_THRESH.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @param bf_value new value for FBAL_THRESH.FBAL_DELTA_ABS_EN
 * @return new value of COMMON.FBAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__EXTRACT() extracts FBAL_THRESH.FBAL_DELTA_ABS_EN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL_THRESH.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @return current value of FBAL_THRESH.FBAL_DELTA_ABS_EN
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_DELTA_ABS_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.FBAL_THRESH.FBAL_LPF_KPSHIFT ------------------ */

/**
<pre>
  COMMON.FBAL_THRESH.FBAL_LPF_KPSHIFT:

    Flux balance error filter coefficient used in flux balance fault computation.  Set to 0 to bypass filter.
    Kp = 2^-Kpshift
    F3db = [kp/(1-kp)] * 50MHz / 2pi

</pre> */

#define COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Pos               10                                                                     /*!< Right-most bit position of fbal_lpf_kpshift in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Msk               (0x00000007UL << COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Pos)            /*!< Mask for fbal_lpf_kpshift in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Shift(v)          (((v) << COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Pos) & COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Msk) /*!< Shift value 'v' into fbal_lpf_kpshift and mask 'v' to fit it into fbal_lpf_kpshift field */

/** COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__SET() sets FBAL_THRESH.FBAL_LPF_KPSHIFT to given value.
 *
 * When writing to FBAL_THRESH.FBAL_LPF_KPSHIFT, this is recommended to use.
 *
 * @param bf_value new value for FBAL_THRESH.FBAL_LPF_KPSHIFT
 */
__COMMON_INLINE void COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Shift((uint32_t)bf_value)));
    COMMON_FBAL_THRESH__SET(reg);
}

/** COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__GET() gets FBAL_THRESH.FBAL_LPF_KPSHIFT's current value.
 *
 * When reading from FBAL_THRESH.FBAL_LPF_KPSHIFT, this is recommended to use.
 *
 * @return current value of FBAL_THRESH.FBAL_LPF_KPSHIFT
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__GET(void)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__MODIFY() modifies FBAL_THRESH.FBAL_LPF_KPSHIFT.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL_THRESH.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @param bf_value new value for FBAL_THRESH.FBAL_LPF_KPSHIFT
 * @return new value of COMMON.FBAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__EXTRACT() extracts FBAL_THRESH.FBAL_LPF_KPSHIFT.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL_THRESH.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @return current value of FBAL_THRESH.FBAL_LPF_KPSHIFT
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_LPF_KPSHIFT__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.FBAL_THRESH.FBAL_INTEG_THRESH ------------------ */

/**
<pre>
  COMMON.FBAL_THRESH.FBAL_INTEG_THRESH:

    Flux balance integrator fault threshold defined with respect to max integrator range.
    <start table>
    0 "disable"
    1 "25% or greater (railed)"
    2 "12.5% or greater"
    3 "6.25% or  greater"
    <end table>

</pre> */

#define COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Pos              8                                                                      /*!< Right-most bit position of fbal_integ_thresh in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Msk              (0x00000003UL << COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Pos)           /*!< Mask for fbal_integ_thresh in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Shift(v)         (((v) << COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Pos) & COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Msk) /*!< Shift value 'v' into fbal_integ_thresh and mask 'v' to fit it into fbal_integ_thresh field */

/** COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__SET() sets FBAL_THRESH.FBAL_INTEG_THRESH to given value.
 *
 * When writing to FBAL_THRESH.FBAL_INTEG_THRESH, this is recommended to use.
 *
 * @param bf_value new value for FBAL_THRESH.FBAL_INTEG_THRESH
 */
__COMMON_INLINE void COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Shift((uint32_t)bf_value)));
    COMMON_FBAL_THRESH__SET(reg);
}

/** COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__GET() gets FBAL_THRESH.FBAL_INTEG_THRESH's current value.
 *
 * When reading from FBAL_THRESH.FBAL_INTEG_THRESH, this is recommended to use.
 *
 * @return current value of FBAL_THRESH.FBAL_INTEG_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__GET(void)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__MODIFY() modifies FBAL_THRESH.FBAL_INTEG_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL_THRESH.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @param bf_value new value for FBAL_THRESH.FBAL_INTEG_THRESH
 * @return new value of COMMON.FBAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__EXTRACT() extracts FBAL_THRESH.FBAL_INTEG_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL_THRESH.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @return current value of FBAL_THRESH.FBAL_INTEG_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FBAL_INTEG_THRESH__Pos);
    return (uint32_t)reg;
}

/* ------------------- COMMON.FBAL_THRESH.FLUX_BAL_THRESH ------------------- */

/**
<pre>
  COMMON.FBAL_THRESH.FLUX_BAL_THRESH:

    Flux balance error fault threshold.
    LSB = 2 V-us, Range = 0 to 510 V-us

</pre> */

#define COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Pos                0                                                                      /*!< Right-most bit position of flux_bal_thresh in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Msk                (0x000000FFUL << COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Pos)             /*!< Mask for flux_bal_thresh in COMMON.FBAL_THRESH */
#define COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Shift(v)           (((v) << COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Pos) & COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Msk) /*!< Shift value 'v' into flux_bal_thresh and mask 'v' to fit it into flux_bal_thresh field */

/** COMMON_FBAL_THRESH__FLUX_BAL_THRESH__SET() sets FBAL_THRESH.FLUX_BAL_THRESH to given value.
 *
 * When writing to FBAL_THRESH.FLUX_BAL_THRESH, this is recommended to use.
 *
 * @param bf_value new value for FBAL_THRESH.FLUX_BAL_THRESH
 */
__COMMON_INLINE void COMMON_FBAL_THRESH__FLUX_BAL_THRESH__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & ~COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Shift((uint32_t)bf_value)));
    COMMON_FBAL_THRESH__SET(reg);
}

/** COMMON_FBAL_THRESH__FLUX_BAL_THRESH__GET() gets FBAL_THRESH.FLUX_BAL_THRESH's current value.
 *
 * When reading from FBAL_THRESH.FLUX_BAL_THRESH, this is recommended to use.
 *
 * @return current value of FBAL_THRESH.FLUX_BAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FLUX_BAL_THRESH__GET(void)
{
    uint32_t reg = COMMON_FBAL_THRESH__GET();
    reg = (reg & COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL_THRESH__FLUX_BAL_THRESH__MODIFY() modifies FBAL_THRESH.FLUX_BAL_THRESH.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL_THRESH.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @param bf_value new value for FBAL_THRESH.FLUX_BAL_THRESH
 * @return new value of COMMON.FBAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FLUX_BAL_THRESH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Msk);
    reg = (reg | (COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL_THRESH__FLUX_BAL_THRESH__EXTRACT() extracts FBAL_THRESH.FLUX_BAL_THRESH.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL_THRESH.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL_THRESH
 * @return current value of FBAL_THRESH.FLUX_BAL_THRESH
 */
__COMMON_INLINE uint32_t COMMON_FBAL_THRESH__FLUX_BAL_THRESH__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Msk);
    reg = (reg >> COMMON_FBAL_THRESH__FLUX_BAL_THRESH__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     VSP1_VRS_VRECTE member of COMMON_t                     */
/* -------------------------------------------------------------------------- */

/** __COMMON_VSP1_VRS_VRECTE__ADDRESS returns the address of member VSP1_VRS_VRECTE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP1_VRS_VRECTE
 */
__COMMON_INLINE uint32_t* __COMMON_VSP1_VRS_VRECTE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VSP1_VRS_VRECTE)));
}

/** COMMON_VSP1_VRS_VRECTE__GET() gets VSP1_VRS_VRECTE's current value.
 *
 * When reading from VSP1_VRS_VRECTE, this is mandatory to use.
 *
 * @return current value of VSP1_VRS_VRECTE
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_VRECTE__GET(void)
{
    return HAL_GET32(__COMMON_VSP1_VRS_VRECTE__ADDRESS());
}

/* --------------- COMMON.VSP1_VRS_VRECTE.VSP1_VRS_VRECT_EVEN --------------- */

/**
<pre>
  COMMON.VSP1_VRS_VRECTE.VSP1_VRS_VRECT_EVEN:

    Measured VRSEN rectification voltage on the even half cycle.
    LSB = 1.25mV, Range = 0.0 to 2.1V

</pre> */

#define COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__Pos        0                                                                      /*!< Right-most bit position of vsp1_vrs_vrect_even in COMMON.VSP1_VRS_VRECTE */
#define COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__Msk        (0x00000FFFUL << COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__Pos)     /*!< Mask for vsp1_vrs_vrect_even in COMMON.VSP1_VRS_VRECTE */
#define COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__Shift(v)   (((v) << COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__Pos) & COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__Msk) /*!< Shift value 'v' into vsp1_vrs_vrect_even and mask 'v' to fit it into vsp1_vrs_vrect_even field */

/** COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__GET() gets VSP1_VRS_VRECTE.VSP1_VRS_VRECT_EVEN's current value.
 *
 * When reading from VSP1_VRS_VRECTE.VSP1_VRS_VRECT_EVEN, this is recommended to use.
 *
 * @return current value of VSP1_VRS_VRECTE.VSP1_VRS_VRECT_EVEN
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__GET(void)
{
    uint32_t reg = COMMON_VSP1_VRS_VRECTE__GET();
    reg = (reg & COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__Msk);
    reg = (reg >> COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__EXTRACT() extracts VSP1_VRS_VRECTE.VSP1_VRS_VRECT_EVEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_VRS_VRECTE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_VRS_VRECTE
 * @return current value of VSP1_VRS_VRECTE.VSP1_VRS_VRECT_EVEN
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__Msk);
    reg = (reg >> COMMON_VSP1_VRS_VRECTE__VSP1_VRS_VRECT_EVEN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     VSP1_VRS_VRECTO member of COMMON_t                     */
/* -------------------------------------------------------------------------- */

/** __COMMON_VSP1_VRS_VRECTO__ADDRESS returns the address of member VSP1_VRS_VRECTO.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP1_VRS_VRECTO
 */
__COMMON_INLINE uint32_t* __COMMON_VSP1_VRS_VRECTO__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VSP1_VRS_VRECTO)));
}

/** COMMON_VSP1_VRS_VRECTO__GET() gets VSP1_VRS_VRECTO's current value.
 *
 * When reading from VSP1_VRS_VRECTO, this is mandatory to use.
 *
 * @return current value of VSP1_VRS_VRECTO
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_VRECTO__GET(void)
{
    return HAL_GET32(__COMMON_VSP1_VRS_VRECTO__ADDRESS());
}

/* --------------- COMMON.VSP1_VRS_VRECTO.VSP1_VRS_VRECT_ODD --------------- */

/**
<pre>
  COMMON.VSP1_VRS_VRECTO.VSP1_VRS_VRECT_ODD:

    Measured VRSEN rectification voltage on the odd half cycle.
    LSB = 1.25mV, Range = 0.0 to 2.1V

</pre> */

#define COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__Pos         0                                                                      /*!< Right-most bit position of vsp1_vrs_vrect_odd in COMMON.VSP1_VRS_VRECTO */
#define COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__Msk         (0x00000FFFUL << COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__Pos)      /*!< Mask for vsp1_vrs_vrect_odd in COMMON.VSP1_VRS_VRECTO */
#define COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__Shift(v)    (((v) << COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__Pos) & COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__Msk) /*!< Shift value 'v' into vsp1_vrs_vrect_odd and mask 'v' to fit it into vsp1_vrs_vrect_odd field */

/** COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__GET() gets VSP1_VRS_VRECTO.VSP1_VRS_VRECT_ODD's current value.
 *
 * When reading from VSP1_VRS_VRECTO.VSP1_VRS_VRECT_ODD, this is recommended to use.
 *
 * @return current value of VSP1_VRS_VRECTO.VSP1_VRS_VRECT_ODD
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__GET(void)
{
    uint32_t reg = COMMON_VSP1_VRS_VRECTO__GET();
    reg = (reg & COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__Msk);
    reg = (reg >> COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__EXTRACT() extracts VSP1_VRS_VRECTO.VSP1_VRS_VRECT_ODD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_VRS_VRECTO.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_VRS_VRECTO
 * @return current value of VSP1_VRS_VRECTO.VSP1_VRS_VRECT_ODD
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__Msk);
    reg = (reg >> COMMON_VSP1_VRS_VRECTO__VSP1_VRS_VRECT_ODD__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   VSP1_VRS_VRECT_AVG member of COMMON_t                   */
/* -------------------------------------------------------------------------- */

/** __COMMON_VSP1_VRS_VRECT_AVG__ADDRESS returns the address of member VSP1_VRS_VRECT_AVG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP1_VRS_VRECT_AVG
 */
__COMMON_INLINE uint32_t* __COMMON_VSP1_VRS_VRECT_AVG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VSP1_VRS_VRECT_AVG)));
}

/** COMMON_VSP1_VRS_VRECT_AVG__GET() gets VSP1_VRS_VRECT_AVG's current value.
 *
 * When reading from VSP1_VRS_VRECT_AVG, this is mandatory to use.
 *
 * @return current value of VSP1_VRS_VRECT_AVG
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_VRECT_AVG__GET(void)
{
    return HAL_GET32(__COMMON_VSP1_VRS_VRECT_AVG__ADDRESS());
}

/* ---------------- COMMON.VSP1_VRS_VRECT_AVG.VSP1_VRS_VRECT ---------------- */

/**
<pre>
  COMMON.VSP1_VRS_VRECT_AVG.VSP1_VRS_VRECT:

    Average of measured VRSEN even and odd half cycle rectification voltages.
    LSB = 1.25mV, Range = 0.0 to 2.1V

</pre> */

#define COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__Pos          0                                                                      /*!< Right-most bit position of vsp1_vrs_vrect in COMMON.VSP1_VRS_VRECT_AVG */
#define COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__Msk          (0x00000FFFUL << COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__Pos)       /*!< Mask for vsp1_vrs_vrect in COMMON.VSP1_VRS_VRECT_AVG */
#define COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__Shift(v)     (((v) << COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__Pos) & COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__Msk) /*!< Shift value 'v' into vsp1_vrs_vrect and mask 'v' to fit it into vsp1_vrs_vrect field */

/** COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__GET() gets VSP1_VRS_VRECT_AVG.VSP1_VRS_VRECT's current value.
 *
 * When reading from VSP1_VRS_VRECT_AVG.VSP1_VRS_VRECT, this is recommended to use.
 *
 * @return current value of VSP1_VRS_VRECT_AVG.VSP1_VRS_VRECT
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__GET(void)
{
    uint32_t reg = COMMON_VSP1_VRS_VRECT_AVG__GET();
    reg = (reg & COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__Msk);
    reg = (reg >> COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__EXTRACT() extracts VSP1_VRS_VRECT_AVG.VSP1_VRS_VRECT.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_VRS_VRECT_AVG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_VRS_VRECT_AVG
 * @return current value of VSP1_VRS_VRECT_AVG.VSP1_VRS_VRECT
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__Msk);
    reg = (reg >> COMMON_VSP1_VRS_VRECT_AVG__VSP1_VRS_VRECT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     VSP2_VRS_VRECTE member of COMMON_t                     */
/* -------------------------------------------------------------------------- */

/** __COMMON_VSP2_VRS_VRECTE__ADDRESS returns the address of member VSP2_VRS_VRECTE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP2_VRS_VRECTE
 */
__COMMON_INLINE uint32_t* __COMMON_VSP2_VRS_VRECTE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VSP2_VRS_VRECTE)));
}

/** COMMON_VSP2_VRS_VRECTE__GET() gets VSP2_VRS_VRECTE's current value.
 *
 * When reading from VSP2_VRS_VRECTE, this is mandatory to use.
 *
 * @return current value of VSP2_VRS_VRECTE
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_VRECTE__GET(void)
{
    return HAL_GET32(__COMMON_VSP2_VRS_VRECTE__ADDRESS());
}

/* --------------- COMMON.VSP2_VRS_VRECTE.VSP2_VRS_VRECT_EVEN --------------- */

/**
<pre>
  COMMON.VSP2_VRS_VRECTE.VSP2_VRS_VRECT_EVEN:

    Measured BVRSEN rectification voltage on the even half cycle.
    LSB = 1.25mV, Range = 0.0 to 2.1V

</pre> */

#define COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__Pos        0                                                                      /*!< Right-most bit position of vsp2_vrs_vrect_even in COMMON.VSP2_VRS_VRECTE */
#define COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__Msk        (0x00000FFFUL << COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__Pos)     /*!< Mask for vsp2_vrs_vrect_even in COMMON.VSP2_VRS_VRECTE */
#define COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__Shift(v)   (((v) << COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__Pos) & COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__Msk) /*!< Shift value 'v' into vsp2_vrs_vrect_even and mask 'v' to fit it into vsp2_vrs_vrect_even field */

/** COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__GET() gets VSP2_VRS_VRECTE.VSP2_VRS_VRECT_EVEN's current value.
 *
 * When reading from VSP2_VRS_VRECTE.VSP2_VRS_VRECT_EVEN, this is recommended to use.
 *
 * @return current value of VSP2_VRS_VRECTE.VSP2_VRS_VRECT_EVEN
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__GET(void)
{
    uint32_t reg = COMMON_VSP2_VRS_VRECTE__GET();
    reg = (reg & COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__Msk);
    reg = (reg >> COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__EXTRACT() extracts VSP2_VRS_VRECTE.VSP2_VRS_VRECT_EVEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_VRS_VRECTE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_VRS_VRECTE
 * @return current value of VSP2_VRS_VRECTE.VSP2_VRS_VRECT_EVEN
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__Msk);
    reg = (reg >> COMMON_VSP2_VRS_VRECTE__VSP2_VRS_VRECT_EVEN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     VSP2_VRS_VRECTO member of COMMON_t                     */
/* -------------------------------------------------------------------------- */

/** __COMMON_VSP2_VRS_VRECTO__ADDRESS returns the address of member VSP2_VRS_VRECTO.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP2_VRS_VRECTO
 */
__COMMON_INLINE uint32_t* __COMMON_VSP2_VRS_VRECTO__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VSP2_VRS_VRECTO)));
}

/** COMMON_VSP2_VRS_VRECTO__GET() gets VSP2_VRS_VRECTO's current value.
 *
 * When reading from VSP2_VRS_VRECTO, this is mandatory to use.
 *
 * @return current value of VSP2_VRS_VRECTO
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_VRECTO__GET(void)
{
    return HAL_GET32(__COMMON_VSP2_VRS_VRECTO__ADDRESS());
}

/* --------------- COMMON.VSP2_VRS_VRECTO.VSP2_VRS_VRECT_ODD --------------- */

/**
<pre>
  COMMON.VSP2_VRS_VRECTO.VSP2_VRS_VRECT_ODD:

    Measured BVRSEN rectification voltage on the odd half cycle.
    LSB = 1.25mV, Range = 0.0 to 2.1V

</pre> */

#define COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__Pos         0                                                                      /*!< Right-most bit position of vsp2_vrs_vrect_odd in COMMON.VSP2_VRS_VRECTO */
#define COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__Msk         (0x00000FFFUL << COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__Pos)      /*!< Mask for vsp2_vrs_vrect_odd in COMMON.VSP2_VRS_VRECTO */
#define COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__Shift(v)    (((v) << COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__Pos) & COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__Msk) /*!< Shift value 'v' into vsp2_vrs_vrect_odd and mask 'v' to fit it into vsp2_vrs_vrect_odd field */

/** COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__GET() gets VSP2_VRS_VRECTO.VSP2_VRS_VRECT_ODD's current value.
 *
 * When reading from VSP2_VRS_VRECTO.VSP2_VRS_VRECT_ODD, this is recommended to use.
 *
 * @return current value of VSP2_VRS_VRECTO.VSP2_VRS_VRECT_ODD
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__GET(void)
{
    uint32_t reg = COMMON_VSP2_VRS_VRECTO__GET();
    reg = (reg & COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__Msk);
    reg = (reg >> COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__EXTRACT() extracts VSP2_VRS_VRECTO.VSP2_VRS_VRECT_ODD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_VRS_VRECTO.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_VRS_VRECTO
 * @return current value of VSP2_VRS_VRECTO.VSP2_VRS_VRECT_ODD
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__Msk);
    reg = (reg >> COMMON_VSP2_VRS_VRECTO__VSP2_VRS_VRECT_ODD__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   VSP2_VRS_VRECT_AVG member of COMMON_t                   */
/* -------------------------------------------------------------------------- */

/** __COMMON_VSP2_VRS_VRECT_AVG__ADDRESS returns the address of member VSP2_VRS_VRECT_AVG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP2_VRS_VRECT_AVG
 */
__COMMON_INLINE uint32_t* __COMMON_VSP2_VRS_VRECT_AVG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VSP2_VRS_VRECT_AVG)));
}

/** COMMON_VSP2_VRS_VRECT_AVG__GET() gets VSP2_VRS_VRECT_AVG's current value.
 *
 * When reading from VSP2_VRS_VRECT_AVG, this is mandatory to use.
 *
 * @return current value of VSP2_VRS_VRECT_AVG
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_VRECT_AVG__GET(void)
{
    return HAL_GET32(__COMMON_VSP2_VRS_VRECT_AVG__ADDRESS());
}

/* ---------------- COMMON.VSP2_VRS_VRECT_AVG.VSP2_VRS_VRECT ---------------- */

/**
<pre>
  COMMON.VSP2_VRS_VRECT_AVG.VSP2_VRS_VRECT:

    Average of measured BVRSEN even and odd half cycle rectification voltages.
    LSB = 1.25mV, Range = 0.0 to 2.1V

</pre> */

#define COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__Pos          0                                                                      /*!< Right-most bit position of vsp2_vrs_vrect in COMMON.VSP2_VRS_VRECT_AVG */
#define COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__Msk          (0x00000FFFUL << COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__Pos)       /*!< Mask for vsp2_vrs_vrect in COMMON.VSP2_VRS_VRECT_AVG */
#define COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__Shift(v)     (((v) << COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__Pos) & COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__Msk) /*!< Shift value 'v' into vsp2_vrs_vrect and mask 'v' to fit it into vsp2_vrs_vrect field */

/** COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__GET() gets VSP2_VRS_VRECT_AVG.VSP2_VRS_VRECT's current value.
 *
 * When reading from VSP2_VRS_VRECT_AVG.VSP2_VRS_VRECT, this is recommended to use.
 *
 * @return current value of VSP2_VRS_VRECT_AVG.VSP2_VRS_VRECT
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__GET(void)
{
    uint32_t reg = COMMON_VSP2_VRS_VRECT_AVG__GET();
    reg = (reg & COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__Msk);
    reg = (reg >> COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__EXTRACT() extracts VSP2_VRS_VRECT_AVG.VSP2_VRS_VRECT.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_VRS_VRECT_AVG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_VRS_VRECT_AVG
 * @return current value of VSP2_VRS_VRECT_AVG.VSP2_VRS_VRECT
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__Msk);
    reg = (reg >> COMMON_VSP2_VRS_VRECT_AVG__VSP2_VRS_VRECT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         EN_REG1 member of COMMON_t                         */
/* -------------------------------------------------------------------------- */

/** __COMMON_EN_REG1__ADDRESS returns the address of member EN_REG1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of EN_REG1
 */
__COMMON_INLINE uint32_t* __COMMON_EN_REG1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, EN_REG1)));
}

/** COMMON_EN_REG1__SET() sets EN_REG1 to given value.
 *
 * When writing to EN_REG1, this is mandatory to use.
 *
 * @param value new value for EN_REG1
 */
__COMMON_INLINE void COMMON_EN_REG1__SET(uint32_t value)
{
    HAL_SET32(__COMMON_EN_REG1__ADDRESS(), value);
}

/** COMMON_EN_REG1__GET() gets EN_REG1's current value.
 *
 * When reading from EN_REG1, this is mandatory to use.
 *
 * @return current value of EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__GET(void)
{
    return HAL_GET32(__COMMON_EN_REG1__ADDRESS());
}

/* ------------------------- COMMON.EN_REG1.EN_VS1 ------------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_VS1:

    FW driven HW block enable for VS1 (VRSEN) ADC
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_VS1__Pos                             14                                                                     /*!< Right-most bit position of en_vs1 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_VS1__Msk                             (0x00000001UL << COMMON_EN_REG1__EN_VS1__Pos)                          /*!< Mask for en_vs1 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_VS1__Shift(v)                        (((v) << COMMON_EN_REG1__EN_VS1__Pos) & COMMON_EN_REG1__EN_VS1__Msk)   /*!< Shift value 'v' into en_vs1 and mask 'v' to fit it into en_vs1 field */

/** COMMON_EN_REG1__EN_VS1__SET() sets EN_REG1.EN_VS1 to given value.
 *
 * When writing to EN_REG1.EN_VS1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_VS1
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_VS1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_VS1__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_VS1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_VS1__GET() gets EN_REG1.EN_VS1's current value.
 *
 * When reading from EN_REG1.EN_VS1, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_VS1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VS1__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_VS1__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_VS1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_VS1__MODIFY() modifies EN_REG1.EN_VS1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_VS1
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VS1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_VS1__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_VS1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_VS1__EXTRACT() extracts EN_REG1.EN_VS1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_VS1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VS1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_VS1__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_VS1__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG1.EN_VSP1 ------------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_VSP1:

    FW driven HW block enable for VS1 (VRSEN) ADC digital processing (VSP) function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_VSP1__Pos                            13                                                                     /*!< Right-most bit position of en_vsp1 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_VSP1__Msk                            (0x00000001UL << COMMON_EN_REG1__EN_VSP1__Pos)                         /*!< Mask for en_vsp1 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_VSP1__Shift(v)                       (((v) << COMMON_EN_REG1__EN_VSP1__Pos) & COMMON_EN_REG1__EN_VSP1__Msk) /*!< Shift value 'v' into en_vsp1 and mask 'v' to fit it into en_vsp1 field */

/** COMMON_EN_REG1__EN_VSP1__SET() sets EN_REG1.EN_VSP1 to given value.
 *
 * When writing to EN_REG1.EN_VSP1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_VSP1
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_VSP1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_VSP1__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_VSP1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_VSP1__GET() gets EN_REG1.EN_VSP1's current value.
 *
 * When reading from EN_REG1.EN_VSP1, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_VSP1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VSP1__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_VSP1__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_VSP1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_VSP1__MODIFY() modifies EN_REG1.EN_VSP1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_VSP1
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VSP1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_VSP1__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_VSP1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_VSP1__EXTRACT() extracts EN_REG1.EN_VSP1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_VSP1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VSP1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_VSP1__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_VSP1__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.EN_REG1.EN_PID_OSP0 ----------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_PID_OSP0:

    FW driven, state based HW block enable for PID0 open sense protection function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_PID_OSP0__Pos                        12                                                                     /*!< Right-most bit position of en_pid_osp0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_PID_OSP0__Msk                        (0x00000001UL << COMMON_EN_REG1__EN_PID_OSP0__Pos)                     /*!< Mask for en_pid_osp0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_PID_OSP0__Shift(v)                   (((v) << COMMON_EN_REG1__EN_PID_OSP0__Pos) & COMMON_EN_REG1__EN_PID_OSP0__Msk) /*!< Shift value 'v' into en_pid_osp0 and mask 'v' to fit it into en_pid_osp0 field */

/** COMMON_EN_REG1__EN_PID_OSP0__SET() sets EN_REG1.EN_PID_OSP0 to given value.
 *
 * When writing to EN_REG1.EN_PID_OSP0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_PID_OSP0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_PID_OSP0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_PID_OSP0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_PID_OSP0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_PID_OSP0__GET() gets EN_REG1.EN_PID_OSP0's current value.
 *
 * When reading from EN_REG1.EN_PID_OSP0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_PID_OSP0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_PID_OSP0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_PID_OSP0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_PID_OSP0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_PID_OSP0__MODIFY() modifies EN_REG1.EN_PID_OSP0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_PID_OSP0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_PID_OSP0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_PID_OSP0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_PID_OSP0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_PID_OSP0__EXTRACT() extracts EN_REG1.EN_PID_OSP0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_PID_OSP0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_PID_OSP0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_PID_OSP0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_PID_OSP0__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG1.EN_BURST0 ------------------------ */

/**
<pre>
  COMMON.EN_REG1.EN_BURST0:

    FW driven, state based HW block enable for Loop 0 Burst Mode function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_BURST0__Pos                          11                                                                     /*!< Right-most bit position of en_burst0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_BURST0__Msk                          (0x00000001UL << COMMON_EN_REG1__EN_BURST0__Pos)                       /*!< Mask for en_burst0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_BURST0__Shift(v)                     (((v) << COMMON_EN_REG1__EN_BURST0__Pos) & COMMON_EN_REG1__EN_BURST0__Msk) /*!< Shift value 'v' into en_burst0 and mask 'v' to fit it into en_burst0 field */

/** COMMON_EN_REG1__EN_BURST0__SET() sets EN_REG1.EN_BURST0 to given value.
 *
 * When writing to EN_REG1.EN_BURST0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_BURST0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_BURST0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_BURST0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_BURST0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_BURST0__GET() gets EN_REG1.EN_BURST0's current value.
 *
 * When reading from EN_REG1.EN_BURST0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_BURST0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_BURST0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_BURST0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_BURST0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_BURST0__MODIFY() modifies EN_REG1.EN_BURST0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_BURST0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_BURST0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_BURST0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_BURST0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_BURST0__EXTRACT() extracts EN_REG1.EN_BURST0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_BURST0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_BURST0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_BURST0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_BURST0__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG1.EN_PWM0 ------------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_PWM0:

    FW driven HW block enable for Loop 0 PWM function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_PWM0__Pos                            10                                                                     /*!< Right-most bit position of en_pwm0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_PWM0__Msk                            (0x00000001UL << COMMON_EN_REG1__EN_PWM0__Pos)                         /*!< Mask for en_pwm0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_PWM0__Shift(v)                       (((v) << COMMON_EN_REG1__EN_PWM0__Pos) & COMMON_EN_REG1__EN_PWM0__Msk) /*!< Shift value 'v' into en_pwm0 and mask 'v' to fit it into en_pwm0 field */

/** COMMON_EN_REG1__EN_PWM0__SET() sets EN_REG1.EN_PWM0 to given value.
 *
 * When writing to EN_REG1.EN_PWM0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_PWM0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_PWM0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_PWM0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_PWM0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_PWM0__GET() gets EN_REG1.EN_PWM0's current value.
 *
 * When reading from EN_REG1.EN_PWM0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_PWM0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_PWM0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_PWM0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_PWM0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_PWM0__MODIFY() modifies EN_REG1.EN_PWM0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_PWM0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_PWM0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_PWM0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_PWM0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_PWM0__EXTRACT() extracts EN_REG1.EN_PWM0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_PWM0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_PWM0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_PWM0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_PWM0__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG1.EN_RAMP0 ------------------------ */

/**
<pre>
  COMMON.EN_REG1.EN_RAMP0:

    FW driven HW block enable for PWM Ramp 0
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_RAMP0__Pos                           9                                                                      /*!< Right-most bit position of en_ramp0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_RAMP0__Msk                           (0x00000001UL << COMMON_EN_REG1__EN_RAMP0__Pos)                        /*!< Mask for en_ramp0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_RAMP0__Shift(v)                      (((v) << COMMON_EN_REG1__EN_RAMP0__Pos) & COMMON_EN_REG1__EN_RAMP0__Msk) /*!< Shift value 'v' into en_ramp0 and mask 'v' to fit it into en_ramp0 field */

/** COMMON_EN_REG1__EN_RAMP0__SET() sets EN_REG1.EN_RAMP0 to given value.
 *
 * When writing to EN_REG1.EN_RAMP0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_RAMP0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_RAMP0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_RAMP0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_RAMP0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_RAMP0__GET() gets EN_REG1.EN_RAMP0's current value.
 *
 * When reading from EN_REG1.EN_RAMP0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_RAMP0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_RAMP0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_RAMP0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_RAMP0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_RAMP0__MODIFY() modifies EN_REG1.EN_RAMP0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_RAMP0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_RAMP0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_RAMP0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_RAMP0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_RAMP0__EXTRACT() extracts EN_REG1.EN_RAMP0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_RAMP0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_RAMP0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_RAMP0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_RAMP0__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG1.EN_FAULT0 ------------------------ */

/**
<pre>
  COMMON.EN_REG1.EN_FAULT0:

    FW driven HW block enable for Loop 0 FAULT function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_FAULT0__Pos                          8                                                                      /*!< Right-most bit position of en_fault0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_FAULT0__Msk                          (0x00000001UL << COMMON_EN_REG1__EN_FAULT0__Pos)                       /*!< Mask for en_fault0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_FAULT0__Shift(v)                     (((v) << COMMON_EN_REG1__EN_FAULT0__Pos) & COMMON_EN_REG1__EN_FAULT0__Msk) /*!< Shift value 'v' into en_fault0 and mask 'v' to fit it into en_fault0 field */

/** COMMON_EN_REG1__EN_FAULT0__SET() sets EN_REG1.EN_FAULT0 to given value.
 *
 * When writing to EN_REG1.EN_FAULT0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_FAULT0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_FAULT0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_FAULT0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_FAULT0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_FAULT0__GET() gets EN_REG1.EN_FAULT0's current value.
 *
 * When reading from EN_REG1.EN_FAULT0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_FAULT0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_FAULT0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_FAULT0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_FAULT0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_FAULT0__MODIFY() modifies EN_REG1.EN_FAULT0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_FAULT0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_FAULT0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_FAULT0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_FAULT0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_FAULT0__EXTRACT() extracts EN_REG1.EN_FAULT0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_FAULT0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_FAULT0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_FAULT0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_FAULT0__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG1.EN_TELEM0 ------------------------ */

/**
<pre>
  COMMON.EN_REG1.EN_TELEM0:

    FW driven HW block enable for Loop 0 TELEMETRY function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_TELEM0__Pos                          7                                                                      /*!< Right-most bit position of en_telem0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_TELEM0__Msk                          (0x00000001UL << COMMON_EN_REG1__EN_TELEM0__Pos)                       /*!< Mask for en_telem0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_TELEM0__Shift(v)                     (((v) << COMMON_EN_REG1__EN_TELEM0__Pos) & COMMON_EN_REG1__EN_TELEM0__Msk) /*!< Shift value 'v' into en_telem0 and mask 'v' to fit it into en_telem0 field */

/** COMMON_EN_REG1__EN_TELEM0__SET() sets EN_REG1.EN_TELEM0 to given value.
 *
 * When writing to EN_REG1.EN_TELEM0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_TELEM0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_TELEM0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_TELEM0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_TELEM0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_TELEM0__GET() gets EN_REG1.EN_TELEM0's current value.
 *
 * When reading from EN_REG1.EN_TELEM0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_TELEM0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_TELEM0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_TELEM0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_TELEM0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_TELEM0__MODIFY() modifies EN_REG1.EN_TELEM0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_TELEM0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_TELEM0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_TELEM0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_TELEM0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_TELEM0__EXTRACT() extracts EN_REG1.EN_TELEM0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_TELEM0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_TELEM0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_TELEM0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_TELEM0__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG1.EN_ISP1 ------------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_ISP1:

    FW driven HW block enable for IS1 (ISEN) ADC digital processing (ISP) function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_ISP1__Pos                            6                                                                      /*!< Right-most bit position of en_isp1 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_ISP1__Msk                            (0x00000001UL << COMMON_EN_REG1__EN_ISP1__Pos)                         /*!< Mask for en_isp1 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_ISP1__Shift(v)                       (((v) << COMMON_EN_REG1__EN_ISP1__Pos) & COMMON_EN_REG1__EN_ISP1__Msk) /*!< Shift value 'v' into en_isp1 and mask 'v' to fit it into en_isp1 field */

/** COMMON_EN_REG1__EN_ISP1__SET() sets EN_REG1.EN_ISP1 to given value.
 *
 * When writing to EN_REG1.EN_ISP1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_ISP1
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_ISP1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_ISP1__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_ISP1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_ISP1__GET() gets EN_REG1.EN_ISP1's current value.
 *
 * When reading from EN_REG1.EN_ISP1, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_ISP1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_ISP1__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_ISP1__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_ISP1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_ISP1__MODIFY() modifies EN_REG1.EN_ISP1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_ISP1
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_ISP1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_ISP1__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_ISP1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_ISP1__EXTRACT() extracts EN_REG1.EN_ISP1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_ISP1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_ISP1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_ISP1__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_ISP1__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG1.EN_IS0 ------------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_IS0:

    FW driven HW block enable for IS1 (ISEN) ADC
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_IS0__Pos                             5                                                                      /*!< Right-most bit position of en_is0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_IS0__Msk                             (0x00000001UL << COMMON_EN_REG1__EN_IS0__Pos)                          /*!< Mask for en_is0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_IS0__Shift(v)                        (((v) << COMMON_EN_REG1__EN_IS0__Pos) & COMMON_EN_REG1__EN_IS0__Msk)   /*!< Shift value 'v' into en_is0 and mask 'v' to fit it into en_is0 field */

/** COMMON_EN_REG1__EN_IS0__SET() sets EN_REG1.EN_IS0 to given value.
 *
 * When writing to EN_REG1.EN_IS0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_IS0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_IS0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_IS0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_IS0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_IS0__GET() gets EN_REG1.EN_IS0's current value.
 *
 * When reading from EN_REG1.EN_IS0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_IS0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_IS0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_IS0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_IS0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_IS0__MODIFY() modifies EN_REG1.EN_IS0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_IS0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_IS0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_IS0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_IS0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_IS0__EXTRACT() extracts EN_REG1.EN_IS0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_IS0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_IS0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_IS0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_IS0__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG1.EN_CE0 ------------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_CE0:

    FW driven HW block enable for CE0 (ISEN) current emulator function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_CE0__Pos                             4                                                                      /*!< Right-most bit position of en_ce0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_CE0__Msk                             (0x00000001UL << COMMON_EN_REG1__EN_CE0__Pos)                          /*!< Mask for en_ce0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_CE0__Shift(v)                        (((v) << COMMON_EN_REG1__EN_CE0__Pos) & COMMON_EN_REG1__EN_CE0__Msk)   /*!< Shift value 'v' into en_ce0 and mask 'v' to fit it into en_ce0 field */

/** COMMON_EN_REG1__EN_CE0__SET() sets EN_REG1.EN_CE0 to given value.
 *
 * When writing to EN_REG1.EN_CE0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_CE0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_CE0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_CE0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_CE0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_CE0__GET() gets EN_REG1.EN_CE0's current value.
 *
 * When reading from EN_REG1.EN_CE0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_CE0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_CE0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_CE0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_CE0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_CE0__MODIFY() modifies EN_REG1.EN_CE0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_CE0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_CE0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_CE0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_CE0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_CE0__EXTRACT() extracts EN_REG1.EN_CE0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_CE0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_CE0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_CE0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_CE0__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG1.EN_PID0 ------------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_PID0:

    FW driven HW block enable for Loop 0 PID function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_PID0__Pos                            3                                                                      /*!< Right-most bit position of en_pid0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_PID0__Msk                            (0x00000001UL << COMMON_EN_REG1__EN_PID0__Pos)                         /*!< Mask for en_pid0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_PID0__Shift(v)                       (((v) << COMMON_EN_REG1__EN_PID0__Pos) & COMMON_EN_REG1__EN_PID0__Msk) /*!< Shift value 'v' into en_pid0 and mask 'v' to fit it into en_pid0 field */

/** COMMON_EN_REG1__EN_PID0__SET() sets EN_REG1.EN_PID0 to given value.
 *
 * When writing to EN_REG1.EN_PID0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_PID0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_PID0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_PID0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_PID0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_PID0__GET() gets EN_REG1.EN_PID0's current value.
 *
 * When reading from EN_REG1.EN_PID0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_PID0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_PID0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_PID0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_PID0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_PID0__MODIFY() modifies EN_REG1.EN_PID0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_PID0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_PID0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_PID0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_PID0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_PID0__EXTRACT() extracts EN_REG1.EN_PID0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_PID0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_PID0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_PID0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_PID0__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG1.EN_VS0 ------------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_VS0:

    FW driven HW block enable for VS0 (VSEN) ADC
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_VS0__Pos                             2                                                                      /*!< Right-most bit position of en_vs0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_VS0__Msk                             (0x00000001UL << COMMON_EN_REG1__EN_VS0__Pos)                          /*!< Mask for en_vs0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_VS0__Shift(v)                        (((v) << COMMON_EN_REG1__EN_VS0__Pos) & COMMON_EN_REG1__EN_VS0__Msk)   /*!< Shift value 'v' into en_vs0 and mask 'v' to fit it into en_vs0 field */

/** COMMON_EN_REG1__EN_VS0__SET() sets EN_REG1.EN_VS0 to given value.
 *
 * When writing to EN_REG1.EN_VS0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_VS0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_VS0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_VS0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_VS0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_VS0__GET() gets EN_REG1.EN_VS0's current value.
 *
 * When reading from EN_REG1.EN_VS0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_VS0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VS0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_VS0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_VS0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_VS0__MODIFY() modifies EN_REG1.EN_VS0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_VS0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VS0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_VS0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_VS0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_VS0__EXTRACT() extracts EN_REG1.EN_VS0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_VS0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VS0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_VS0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_VS0__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG1.EN_VSP0 ------------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_VSP0:

    FW driven HW block enable for VS0 (VSEN) ADC digital processing (VSP) function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_VSP0__Pos                            1                                                                      /*!< Right-most bit position of en_vsp0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_VSP0__Msk                            (0x00000001UL << COMMON_EN_REG1__EN_VSP0__Pos)                         /*!< Mask for en_vsp0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_VSP0__Shift(v)                       (((v) << COMMON_EN_REG1__EN_VSP0__Pos) & COMMON_EN_REG1__EN_VSP0__Msk) /*!< Shift value 'v' into en_vsp0 and mask 'v' to fit it into en_vsp0 field */

/** COMMON_EN_REG1__EN_VSP0__SET() sets EN_REG1.EN_VSP0 to given value.
 *
 * When writing to EN_REG1.EN_VSP0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_VSP0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_VSP0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_VSP0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_VSP0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_VSP0__GET() gets EN_REG1.EN_VSP0's current value.
 *
 * When reading from EN_REG1.EN_VSP0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_VSP0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VSP0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_VSP0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_VSP0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_VSP0__MODIFY() modifies EN_REG1.EN_VSP0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_VSP0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VSP0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_VSP0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_VSP0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_VSP0__EXTRACT() extracts EN_REG1.EN_VSP0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_VSP0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VSP0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_VSP0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_VSP0__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.EN_REG1.EN_VCONTROL0 ---------------------- */

/**
<pre>
  COMMON.EN_REG1.EN_VCONTROL0:

    FW driven HW block enable for Loop 0 VCONTROL function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG1__EN_VCONTROL0__Pos                       0                                                                      /*!< Right-most bit position of en_vcontrol0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_VCONTROL0__Msk                       (0x00000001UL << COMMON_EN_REG1__EN_VCONTROL0__Pos)                    /*!< Mask for en_vcontrol0 in COMMON.EN_REG1 */
#define COMMON_EN_REG1__EN_VCONTROL0__Shift(v)                  (((v) << COMMON_EN_REG1__EN_VCONTROL0__Pos) & COMMON_EN_REG1__EN_VCONTROL0__Msk) /*!< Shift value 'v' into en_vcontrol0 and mask 'v' to fit it into en_vcontrol0 field */

/** COMMON_EN_REG1__EN_VCONTROL0__SET() sets EN_REG1.EN_VCONTROL0 to given value.
 *
 * When writing to EN_REG1.EN_VCONTROL0, this is recommended to use.
 *
 * @param bf_value new value for EN_REG1.EN_VCONTROL0
 */
__COMMON_INLINE void COMMON_EN_REG1__EN_VCONTROL0__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & ~COMMON_EN_REG1__EN_VCONTROL0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_VCONTROL0__Shift((uint32_t)bf_value)));
    COMMON_EN_REG1__SET(reg);
}

/** COMMON_EN_REG1__EN_VCONTROL0__GET() gets EN_REG1.EN_VCONTROL0's current value.
 *
 * When reading from EN_REG1.EN_VCONTROL0, this is recommended to use.
 *
 * @return current value of EN_REG1.EN_VCONTROL0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VCONTROL0__GET(void)
{
    uint32_t reg = COMMON_EN_REG1__GET();
    reg = (reg & COMMON_EN_REG1__EN_VCONTROL0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_VCONTROL0__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG1__EN_VCONTROL0__MODIFY() modifies EN_REG1.EN_VCONTROL0.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG1
 * @param bf_value new value for EN_REG1.EN_VCONTROL0
 * @return new value of COMMON.EN_REG1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VCONTROL0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG1__EN_VCONTROL0__Msk);
    reg = (reg | (COMMON_EN_REG1__EN_VCONTROL0__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG1__EN_VCONTROL0__EXTRACT() extracts EN_REG1.EN_VCONTROL0.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG1
 * @return current value of EN_REG1.EN_VCONTROL0
 */
__COMMON_INLINE uint32_t COMMON_EN_REG1__EN_VCONTROL0__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG1__EN_VCONTROL0__Msk);
    reg = (reg >> COMMON_EN_REG1__EN_VCONTROL0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         EN_REG2 member of COMMON_t                         */
/* -------------------------------------------------------------------------- */

/** __COMMON_EN_REG2__ADDRESS returns the address of member EN_REG2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of EN_REG2
 */
__COMMON_INLINE uint32_t* __COMMON_EN_REG2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, EN_REG2)));
}

/** COMMON_EN_REG2__SET() sets EN_REG2 to given value.
 *
 * When writing to EN_REG2, this is mandatory to use.
 *
 * @param value new value for EN_REG2
 */
__COMMON_INLINE void COMMON_EN_REG2__SET(uint32_t value)
{
    HAL_SET32(__COMMON_EN_REG2__ADDRESS(), value);
}

/** COMMON_EN_REG2__GET() gets EN_REG2's current value.
 *
 * When reading from EN_REG2, this is mandatory to use.
 *
 * @return current value of EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__GET(void)
{
    return HAL_GET32(__COMMON_EN_REG2__ADDRESS());
}

/* ----------------------- COMMON.EN_REG2.EN_PID_OSP1 ----------------------- */

/**
<pre>
  COMMON.EN_REG2.EN_PID_OSP1:

    FW driven, state based HW block enable for PID1 open sense protection function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_PID_OSP1__Pos                        12                                                                     /*!< Right-most bit position of en_pid_osp1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_PID_OSP1__Msk                        (0x00000001UL << COMMON_EN_REG2__EN_PID_OSP1__Pos)                     /*!< Mask for en_pid_osp1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_PID_OSP1__Shift(v)                   (((v) << COMMON_EN_REG2__EN_PID_OSP1__Pos) & COMMON_EN_REG2__EN_PID_OSP1__Msk) /*!< Shift value 'v' into en_pid_osp1 and mask 'v' to fit it into en_pid_osp1 field */

/** COMMON_EN_REG2__EN_PID_OSP1__SET() sets EN_REG2.EN_PID_OSP1 to given value.
 *
 * When writing to EN_REG2.EN_PID_OSP1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_PID_OSP1
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_PID_OSP1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_PID_OSP1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_PID_OSP1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_PID_OSP1__GET() gets EN_REG2.EN_PID_OSP1's current value.
 *
 * When reading from EN_REG2.EN_PID_OSP1, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_PID_OSP1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_PID_OSP1__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_PID_OSP1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_PID_OSP1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_PID_OSP1__MODIFY() modifies EN_REG2.EN_PID_OSP1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_PID_OSP1
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_PID_OSP1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_PID_OSP1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_PID_OSP1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_PID_OSP1__EXTRACT() extracts EN_REG2.EN_PID_OSP1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_PID_OSP1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_PID_OSP1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_PID_OSP1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_PID_OSP1__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG2.EN_BURST1 ------------------------ */

/**
<pre>
  COMMON.EN_REG2.EN_BURST1:

    FW driven, state based HW block enable for Loop 1 Burst Mode function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_BURST1__Pos                          11                                                                     /*!< Right-most bit position of en_burst1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_BURST1__Msk                          (0x00000001UL << COMMON_EN_REG2__EN_BURST1__Pos)                       /*!< Mask for en_burst1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_BURST1__Shift(v)                     (((v) << COMMON_EN_REG2__EN_BURST1__Pos) & COMMON_EN_REG2__EN_BURST1__Msk) /*!< Shift value 'v' into en_burst1 and mask 'v' to fit it into en_burst1 field */

/** COMMON_EN_REG2__EN_BURST1__SET() sets EN_REG2.EN_BURST1 to given value.
 *
 * When writing to EN_REG2.EN_BURST1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_BURST1
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_BURST1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_BURST1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_BURST1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_BURST1__GET() gets EN_REG2.EN_BURST1's current value.
 *
 * When reading from EN_REG2.EN_BURST1, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_BURST1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_BURST1__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_BURST1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_BURST1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_BURST1__MODIFY() modifies EN_REG2.EN_BURST1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_BURST1
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_BURST1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_BURST1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_BURST1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_BURST1__EXTRACT() extracts EN_REG2.EN_BURST1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_BURST1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_BURST1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_BURST1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_BURST1__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG2.EN_PWM1 ------------------------- */

/**
<pre>
  COMMON.EN_REG2.EN_PWM1:

    FW driven HW block enable for Loop 1 PWM function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_PWM1__Pos                            10                                                                     /*!< Right-most bit position of en_pwm1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_PWM1__Msk                            (0x00000001UL << COMMON_EN_REG2__EN_PWM1__Pos)                         /*!< Mask for en_pwm1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_PWM1__Shift(v)                       (((v) << COMMON_EN_REG2__EN_PWM1__Pos) & COMMON_EN_REG2__EN_PWM1__Msk) /*!< Shift value 'v' into en_pwm1 and mask 'v' to fit it into en_pwm1 field */

/** COMMON_EN_REG2__EN_PWM1__SET() sets EN_REG2.EN_PWM1 to given value.
 *
 * When writing to EN_REG2.EN_PWM1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_PWM1
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_PWM1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_PWM1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_PWM1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_PWM1__GET() gets EN_REG2.EN_PWM1's current value.
 *
 * When reading from EN_REG2.EN_PWM1, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_PWM1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_PWM1__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_PWM1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_PWM1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_PWM1__MODIFY() modifies EN_REG2.EN_PWM1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_PWM1
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_PWM1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_PWM1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_PWM1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_PWM1__EXTRACT() extracts EN_REG2.EN_PWM1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_PWM1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_PWM1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_PWM1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_PWM1__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG2.EN_RAMP1 ------------------------ */

/**
<pre>
  COMMON.EN_REG2.EN_RAMP1:

    FW driven HW block enable for PWM Ramp 1
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_RAMP1__Pos                           9                                                                      /*!< Right-most bit position of en_ramp1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_RAMP1__Msk                           (0x00000001UL << COMMON_EN_REG2__EN_RAMP1__Pos)                        /*!< Mask for en_ramp1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_RAMP1__Shift(v)                      (((v) << COMMON_EN_REG2__EN_RAMP1__Pos) & COMMON_EN_REG2__EN_RAMP1__Msk) /*!< Shift value 'v' into en_ramp1 and mask 'v' to fit it into en_ramp1 field */

/** COMMON_EN_REG2__EN_RAMP1__SET() sets EN_REG2.EN_RAMP1 to given value.
 *
 * When writing to EN_REG2.EN_RAMP1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_RAMP1
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_RAMP1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_RAMP1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_RAMP1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_RAMP1__GET() gets EN_REG2.EN_RAMP1's current value.
 *
 * When reading from EN_REG2.EN_RAMP1, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_RAMP1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_RAMP1__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_RAMP1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_RAMP1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_RAMP1__MODIFY() modifies EN_REG2.EN_RAMP1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_RAMP1
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_RAMP1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_RAMP1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_RAMP1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_RAMP1__EXTRACT() extracts EN_REG2.EN_RAMP1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_RAMP1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_RAMP1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_RAMP1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_RAMP1__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG2.EN_FAULT1 ------------------------ */

/**
<pre>
  COMMON.EN_REG2.EN_FAULT1:

    FW driven HW block enable for Loop 1 FAULT function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_FAULT1__Pos                          8                                                                      /*!< Right-most bit position of en_fault1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_FAULT1__Msk                          (0x00000001UL << COMMON_EN_REG2__EN_FAULT1__Pos)                       /*!< Mask for en_fault1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_FAULT1__Shift(v)                     (((v) << COMMON_EN_REG2__EN_FAULT1__Pos) & COMMON_EN_REG2__EN_FAULT1__Msk) /*!< Shift value 'v' into en_fault1 and mask 'v' to fit it into en_fault1 field */

/** COMMON_EN_REG2__EN_FAULT1__SET() sets EN_REG2.EN_FAULT1 to given value.
 *
 * When writing to EN_REG2.EN_FAULT1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_FAULT1
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_FAULT1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_FAULT1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_FAULT1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_FAULT1__GET() gets EN_REG2.EN_FAULT1's current value.
 *
 * When reading from EN_REG2.EN_FAULT1, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_FAULT1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_FAULT1__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_FAULT1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_FAULT1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_FAULT1__MODIFY() modifies EN_REG2.EN_FAULT1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_FAULT1
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_FAULT1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_FAULT1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_FAULT1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_FAULT1__EXTRACT() extracts EN_REG2.EN_FAULT1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_FAULT1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_FAULT1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_FAULT1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_FAULT1__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG2.EN_TELEM1 ------------------------ */

/**
<pre>
  COMMON.EN_REG2.EN_TELEM1:

    FW driven HW block enable for Loop 1 TELEMETRY function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_TELEM1__Pos                          7                                                                      /*!< Right-most bit position of en_telem1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_TELEM1__Msk                          (0x00000001UL << COMMON_EN_REG2__EN_TELEM1__Pos)                       /*!< Mask for en_telem1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_TELEM1__Shift(v)                     (((v) << COMMON_EN_REG2__EN_TELEM1__Pos) & COMMON_EN_REG2__EN_TELEM1__Msk) /*!< Shift value 'v' into en_telem1 and mask 'v' to fit it into en_telem1 field */

/** COMMON_EN_REG2__EN_TELEM1__SET() sets EN_REG2.EN_TELEM1 to given value.
 *
 * When writing to EN_REG2.EN_TELEM1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_TELEM1
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_TELEM1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_TELEM1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_TELEM1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_TELEM1__GET() gets EN_REG2.EN_TELEM1's current value.
 *
 * When reading from EN_REG2.EN_TELEM1, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_TELEM1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_TELEM1__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_TELEM1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_TELEM1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_TELEM1__MODIFY() modifies EN_REG2.EN_TELEM1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_TELEM1
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_TELEM1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_TELEM1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_TELEM1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_TELEM1__EXTRACT() extracts EN_REG2.EN_TELEM1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_TELEM1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_TELEM1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_TELEM1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_TELEM1__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG2.EN_ISP2 ------------------------- */

/**
<pre>
  COMMON.EN_REG2.EN_ISP2:

    FW driven HW block enable for IS3 (BISEN) ADC digital processing (ISP) function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_ISP2__Pos                            6                                                                      /*!< Right-most bit position of en_isp2 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_ISP2__Msk                            (0x00000001UL << COMMON_EN_REG2__EN_ISP2__Pos)                         /*!< Mask for en_isp2 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_ISP2__Shift(v)                       (((v) << COMMON_EN_REG2__EN_ISP2__Pos) & COMMON_EN_REG2__EN_ISP2__Msk) /*!< Shift value 'v' into en_isp2 and mask 'v' to fit it into en_isp2 field */

/** COMMON_EN_REG2__EN_ISP2__SET() sets EN_REG2.EN_ISP2 to given value.
 *
 * When writing to EN_REG2.EN_ISP2, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_ISP2
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_ISP2__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_ISP2__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_ISP2__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_ISP2__GET() gets EN_REG2.EN_ISP2's current value.
 *
 * When reading from EN_REG2.EN_ISP2, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_ISP2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_ISP2__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_ISP2__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_ISP2__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_ISP2__MODIFY() modifies EN_REG2.EN_ISP2.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_ISP2
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_ISP2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_ISP2__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_ISP2__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_ISP2__EXTRACT() extracts EN_REG2.EN_ISP2.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_ISP2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_ISP2__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_ISP2__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_ISP2__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG2.EN_IS1 ------------------------- */

/**
<pre>
  COMMON.EN_REG2.EN_IS1:

    FW driven HW block enable for IS3 (BISEN) ADC
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_IS1__Pos                             5                                                                      /*!< Right-most bit position of en_is1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_IS1__Msk                             (0x00000001UL << COMMON_EN_REG2__EN_IS1__Pos)                          /*!< Mask for en_is1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_IS1__Shift(v)                        (((v) << COMMON_EN_REG2__EN_IS1__Pos) & COMMON_EN_REG2__EN_IS1__Msk)   /*!< Shift value 'v' into en_is1 and mask 'v' to fit it into en_is1 field */

/** COMMON_EN_REG2__EN_IS1__SET() sets EN_REG2.EN_IS1 to given value.
 *
 * When writing to EN_REG2.EN_IS1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_IS1
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_IS1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_IS1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_IS1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_IS1__GET() gets EN_REG2.EN_IS1's current value.
 *
 * When reading from EN_REG2.EN_IS1, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_IS1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_IS1__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_IS1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_IS1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_IS1__MODIFY() modifies EN_REG2.EN_IS1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_IS1
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_IS1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_IS1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_IS1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_IS1__EXTRACT() extracts EN_REG2.EN_IS1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_IS1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_IS1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_IS1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_IS1__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG2.EN_CE1 ------------------------- */

/**
<pre>
  COMMON.EN_REG2.EN_CE1:

    FW driven HW block enable for CE1 (BISEN) current emulator function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_CE1__Pos                             4                                                                      /*!< Right-most bit position of en_ce1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_CE1__Msk                             (0x00000001UL << COMMON_EN_REG2__EN_CE1__Pos)                          /*!< Mask for en_ce1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_CE1__Shift(v)                        (((v) << COMMON_EN_REG2__EN_CE1__Pos) & COMMON_EN_REG2__EN_CE1__Msk)   /*!< Shift value 'v' into en_ce1 and mask 'v' to fit it into en_ce1 field */

/** COMMON_EN_REG2__EN_CE1__SET() sets EN_REG2.EN_CE1 to given value.
 *
 * When writing to EN_REG2.EN_CE1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_CE1
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_CE1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_CE1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_CE1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_CE1__GET() gets EN_REG2.EN_CE1's current value.
 *
 * When reading from EN_REG2.EN_CE1, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_CE1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_CE1__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_CE1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_CE1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_CE1__MODIFY() modifies EN_REG2.EN_CE1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_CE1
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_CE1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_CE1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_CE1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_CE1__EXTRACT() extracts EN_REG2.EN_CE1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_CE1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_CE1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_CE1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_CE1__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG2.EN_PID1 ------------------------- */

/**
<pre>
  COMMON.EN_REG2.EN_PID1:

    FW driven HW block enable for Loop 1 PID function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_PID1__Pos                            3                                                                      /*!< Right-most bit position of en_pid1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_PID1__Msk                            (0x00000001UL << COMMON_EN_REG2__EN_PID1__Pos)                         /*!< Mask for en_pid1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_PID1__Shift(v)                       (((v) << COMMON_EN_REG2__EN_PID1__Pos) & COMMON_EN_REG2__EN_PID1__Msk) /*!< Shift value 'v' into en_pid1 and mask 'v' to fit it into en_pid1 field */

/** COMMON_EN_REG2__EN_PID1__SET() sets EN_REG2.EN_PID1 to given value.
 *
 * When writing to EN_REG2.EN_PID1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_PID1
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_PID1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_PID1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_PID1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_PID1__GET() gets EN_REG2.EN_PID1's current value.
 *
 * When reading from EN_REG2.EN_PID1, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_PID1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_PID1__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_PID1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_PID1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_PID1__MODIFY() modifies EN_REG2.EN_PID1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_PID1
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_PID1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_PID1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_PID1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_PID1__EXTRACT() extracts EN_REG2.EN_PID1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_PID1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_PID1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_PID1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_PID1__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG2.EN_VS2 ------------------------- */

/**
<pre>
  COMMON.EN_REG2.EN_VS2:

    FW driven HW block enable for VS2 (BVSEN_BVRSEN) ADC
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_VS2__Pos                             2                                                                      /*!< Right-most bit position of en_vs2 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_VS2__Msk                             (0x00000001UL << COMMON_EN_REG2__EN_VS2__Pos)                          /*!< Mask for en_vs2 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_VS2__Shift(v)                        (((v) << COMMON_EN_REG2__EN_VS2__Pos) & COMMON_EN_REG2__EN_VS2__Msk)   /*!< Shift value 'v' into en_vs2 and mask 'v' to fit it into en_vs2 field */

/** COMMON_EN_REG2__EN_VS2__SET() sets EN_REG2.EN_VS2 to given value.
 *
 * When writing to EN_REG2.EN_VS2, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_VS2
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_VS2__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_VS2__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_VS2__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_VS2__GET() gets EN_REG2.EN_VS2's current value.
 *
 * When reading from EN_REG2.EN_VS2, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_VS2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_VS2__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_VS2__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_VS2__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_VS2__MODIFY() modifies EN_REG2.EN_VS2.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_VS2
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_VS2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_VS2__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_VS2__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_VS2__EXTRACT() extracts EN_REG2.EN_VS2.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_VS2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_VS2__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_VS2__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_VS2__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG2.EN_VSP2 ------------------------- */

/**
<pre>
  COMMON.EN_REG2.EN_VSP2:

    FW driven HW block enable for VS2 (BVSEN_BVRSEN) ADC digital processing (VSP) function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_VSP2__Pos                            1                                                                      /*!< Right-most bit position of en_vsp2 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_VSP2__Msk                            (0x00000001UL << COMMON_EN_REG2__EN_VSP2__Pos)                         /*!< Mask for en_vsp2 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_VSP2__Shift(v)                       (((v) << COMMON_EN_REG2__EN_VSP2__Pos) & COMMON_EN_REG2__EN_VSP2__Msk) /*!< Shift value 'v' into en_vsp2 and mask 'v' to fit it into en_vsp2 field */

/** COMMON_EN_REG2__EN_VSP2__SET() sets EN_REG2.EN_VSP2 to given value.
 *
 * When writing to EN_REG2.EN_VSP2, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_VSP2
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_VSP2__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_VSP2__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_VSP2__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_VSP2__GET() gets EN_REG2.EN_VSP2's current value.
 *
 * When reading from EN_REG2.EN_VSP2, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_VSP2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_VSP2__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_VSP2__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_VSP2__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_VSP2__MODIFY() modifies EN_REG2.EN_VSP2.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_VSP2
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_VSP2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_VSP2__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_VSP2__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_VSP2__EXTRACT() extracts EN_REG2.EN_VSP2.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_VSP2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_VSP2__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_VSP2__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_VSP2__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.EN_REG2.EN_VCONTROL1 ---------------------- */

/**
<pre>
  COMMON.EN_REG2.EN_VCONTROL1:

    FW driven HW block enable for Loop 1 VCONTROL function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG2__EN_VCONTROL1__Pos                       0                                                                      /*!< Right-most bit position of en_vcontrol1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_VCONTROL1__Msk                       (0x00000001UL << COMMON_EN_REG2__EN_VCONTROL1__Pos)                    /*!< Mask for en_vcontrol1 in COMMON.EN_REG2 */
#define COMMON_EN_REG2__EN_VCONTROL1__Shift(v)                  (((v) << COMMON_EN_REG2__EN_VCONTROL1__Pos) & COMMON_EN_REG2__EN_VCONTROL1__Msk) /*!< Shift value 'v' into en_vcontrol1 and mask 'v' to fit it into en_vcontrol1 field */

/** COMMON_EN_REG2__EN_VCONTROL1__SET() sets EN_REG2.EN_VCONTROL1 to given value.
 *
 * When writing to EN_REG2.EN_VCONTROL1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG2.EN_VCONTROL1
 */
__COMMON_INLINE void COMMON_EN_REG2__EN_VCONTROL1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & ~COMMON_EN_REG2__EN_VCONTROL1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_VCONTROL1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG2__SET(reg);
}

/** COMMON_EN_REG2__EN_VCONTROL1__GET() gets EN_REG2.EN_VCONTROL1's current value.
 *
 * When reading from EN_REG2.EN_VCONTROL1, this is recommended to use.
 *
 * @return current value of EN_REG2.EN_VCONTROL1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_VCONTROL1__GET(void)
{
    uint32_t reg = COMMON_EN_REG2__GET();
    reg = (reg & COMMON_EN_REG2__EN_VCONTROL1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_VCONTROL1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG2__EN_VCONTROL1__MODIFY() modifies EN_REG2.EN_VCONTROL1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG2
 * @param bf_value new value for EN_REG2.EN_VCONTROL1
 * @return new value of COMMON.EN_REG2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_VCONTROL1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG2__EN_VCONTROL1__Msk);
    reg = (reg | (COMMON_EN_REG2__EN_VCONTROL1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG2__EN_VCONTROL1__EXTRACT() extracts EN_REG2.EN_VCONTROL1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG2
 * @return current value of EN_REG2.EN_VCONTROL1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG2__EN_VCONTROL1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG2__EN_VCONTROL1__Msk);
    reg = (reg >> COMMON_EN_REG2__EN_VCONTROL1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         EN_REG3 member of COMMON_t                         */
/* -------------------------------------------------------------------------- */

/** __COMMON_EN_REG3__ADDRESS returns the address of member EN_REG3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of EN_REG3
 */
__COMMON_INLINE uint32_t* __COMMON_EN_REG3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, EN_REG3)));
}

/** COMMON_EN_REG3__SET() sets EN_REG3 to given value.
 *
 * When writing to EN_REG3, this is mandatory to use.
 *
 * @param value new value for EN_REG3
 */
__COMMON_INLINE void COMMON_EN_REG3__SET(uint32_t value)
{
    HAL_SET32(__COMMON_EN_REG3__ADDRESS(), value);
}

/** COMMON_EN_REG3__GET() gets EN_REG3's current value.
 *
 * When reading from EN_REG3, this is mandatory to use.
 *
 * @return current value of EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__GET(void)
{
    return HAL_GET32(__COMMON_EN_REG3__ADDRESS());
}

/* ------------------------ COMMON.EN_REG3.EN_ISHARE ------------------------ */

/**
<pre>
  COMMON.EN_REG3.EN_ISHARE:

    FW driven HW block enable for IMON based current sharing function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG3__EN_ISHARE__Pos                          12                                                                     /*!< Right-most bit position of en_ishare in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_ISHARE__Msk                          (0x00000001UL << COMMON_EN_REG3__EN_ISHARE__Pos)                       /*!< Mask for en_ishare in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_ISHARE__Shift(v)                     (((v) << COMMON_EN_REG3__EN_ISHARE__Pos) & COMMON_EN_REG3__EN_ISHARE__Msk) /*!< Shift value 'v' into en_ishare and mask 'v' to fit it into en_ishare field */

/** COMMON_EN_REG3__EN_ISHARE__SET() sets EN_REG3.EN_ISHARE to given value.
 *
 * When writing to EN_REG3.EN_ISHARE, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_ISHARE
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_ISHARE__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_ISHARE__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_ISHARE__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_ISHARE__GET() gets EN_REG3.EN_ISHARE's current value.
 *
 * When reading from EN_REG3.EN_ISHARE, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_ISHARE
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_ISHARE__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_ISHARE__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_ISHARE__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_ISHARE__MODIFY() modifies EN_REG3.EN_ISHARE.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_ISHARE
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_ISHARE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_ISHARE__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_ISHARE__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_ISHARE__EXTRACT() extracts EN_REG3.EN_ISHARE.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_ISHARE
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_ISHARE__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_ISHARE__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_ISHARE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG3.EN_FBAL2 ------------------------ */

/**
<pre>
  COMMON.EN_REG3.EN_FBAL2:

    FW driven HW block enable for Loop 0, Phase 2 Flux / Voltage Balance function.  The parameter is only applicable to bridge topologies.
    <b>Note:</b> Flux balance only functional when corresponding rampX_dutyc_lock also enabled.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG3__EN_FBAL2__Pos                           11                                                                     /*!< Right-most bit position of en_fbal2 in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_FBAL2__Msk                           (0x00000001UL << COMMON_EN_REG3__EN_FBAL2__Pos)                        /*!< Mask for en_fbal2 in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_FBAL2__Shift(v)                      (((v) << COMMON_EN_REG3__EN_FBAL2__Pos) & COMMON_EN_REG3__EN_FBAL2__Msk) /*!< Shift value 'v' into en_fbal2 and mask 'v' to fit it into en_fbal2 field */

/** COMMON_EN_REG3__EN_FBAL2__SET() sets EN_REG3.EN_FBAL2 to given value.
 *
 * When writing to EN_REG3.EN_FBAL2, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_FBAL2
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_FBAL2__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_FBAL2__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_FBAL2__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_FBAL2__GET() gets EN_REG3.EN_FBAL2's current value.
 *
 * When reading from EN_REG3.EN_FBAL2, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_FBAL2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FBAL2__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_FBAL2__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_FBAL2__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_FBAL2__MODIFY() modifies EN_REG3.EN_FBAL2.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_FBAL2
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FBAL2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_FBAL2__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_FBAL2__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_FBAL2__EXTRACT() extracts EN_REG3.EN_FBAL2.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_FBAL2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FBAL2__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_FBAL2__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_FBAL2__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG3.EN_FAN2 ------------------------- */

/**
<pre>
  COMMON.EN_REG3.EN_FAN2:

    FW driven HW block enable for FAN2 function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG3__EN_FAN2__Pos                            10                                                                     /*!< Right-most bit position of en_fan2 in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_FAN2__Msk                            (0x00000001UL << COMMON_EN_REG3__EN_FAN2__Pos)                         /*!< Mask for en_fan2 in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_FAN2__Shift(v)                       (((v) << COMMON_EN_REG3__EN_FAN2__Pos) & COMMON_EN_REG3__EN_FAN2__Msk) /*!< Shift value 'v' into en_fan2 and mask 'v' to fit it into en_fan2 field */

/** COMMON_EN_REG3__EN_FAN2__SET() sets EN_REG3.EN_FAN2 to given value.
 *
 * When writing to EN_REG3.EN_FAN2, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_FAN2
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_FAN2__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_FAN2__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_FAN2__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_FAN2__GET() gets EN_REG3.EN_FAN2's current value.
 *
 * When reading from EN_REG3.EN_FAN2, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_FAN2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FAN2__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_FAN2__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_FAN2__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_FAN2__MODIFY() modifies EN_REG3.EN_FAN2.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_FAN2
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FAN2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_FAN2__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_FAN2__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_FAN2__EXTRACT() extracts EN_REG3.EN_FAN2.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_FAN2
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FAN2__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_FAN2__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_FAN2__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG3.EN_FAN1 ------------------------- */

/**
<pre>
  COMMON.EN_REG3.EN_FAN1:

    FW driven HW block enable for FAN1 function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG3__EN_FAN1__Pos                            9                                                                      /*!< Right-most bit position of en_fan1 in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_FAN1__Msk                            (0x00000001UL << COMMON_EN_REG3__EN_FAN1__Pos)                         /*!< Mask for en_fan1 in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_FAN1__Shift(v)                       (((v) << COMMON_EN_REG3__EN_FAN1__Pos) & COMMON_EN_REG3__EN_FAN1__Msk) /*!< Shift value 'v' into en_fan1 and mask 'v' to fit it into en_fan1 field */

/** COMMON_EN_REG3__EN_FAN1__SET() sets EN_REG3.EN_FAN1 to given value.
 *
 * When writing to EN_REG3.EN_FAN1, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_FAN1
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_FAN1__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_FAN1__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_FAN1__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_FAN1__GET() gets EN_REG3.EN_FAN1's current value.
 *
 * When reading from EN_REG3.EN_FAN1, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_FAN1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FAN1__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_FAN1__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_FAN1__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_FAN1__MODIFY() modifies EN_REG3.EN_FAN1.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_FAN1
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FAN1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_FAN1__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_FAN1__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_FAN1__EXTRACT() extracts EN_REG3.EN_FAN1.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_FAN1
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FAN1__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_FAN1__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_FAN1__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG3.EN_FAULTC ------------------------ */

/**
<pre>
  COMMON.EN_REG3.EN_FAULTC:

    FW driven HW block enable for Common FAULT functions
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG3__EN_FAULTC__Pos                          7                                                                      /*!< Right-most bit position of en_faultc in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_FAULTC__Msk                          (0x00000001UL << COMMON_EN_REG3__EN_FAULTC__Pos)                       /*!< Mask for en_faultc in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_FAULTC__Shift(v)                     (((v) << COMMON_EN_REG3__EN_FAULTC__Pos) & COMMON_EN_REG3__EN_FAULTC__Msk) /*!< Shift value 'v' into en_faultc and mask 'v' to fit it into en_faultc field */

/** COMMON_EN_REG3__EN_FAULTC__SET() sets EN_REG3.EN_FAULTC to given value.
 *
 * When writing to EN_REG3.EN_FAULTC, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_FAULTC
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_FAULTC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_FAULTC__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_FAULTC__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_FAULTC__GET() gets EN_REG3.EN_FAULTC's current value.
 *
 * When reading from EN_REG3.EN_FAULTC, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_FAULTC
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FAULTC__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_FAULTC__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_FAULTC__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_FAULTC__MODIFY() modifies EN_REG3.EN_FAULTC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_FAULTC
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FAULTC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_FAULTC__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_FAULTC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_FAULTC__EXTRACT() extracts EN_REG3.EN_FAULTC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_FAULTC
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FAULTC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_FAULTC__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_FAULTC__Pos);
    return (uint32_t)reg;
}

/* ------------------------ COMMON.EN_REG3.EN_TELEMC ------------------------ */

/**
<pre>
  COMMON.EN_REG3.EN_TELEMC:

    FW driven HW block enable for Common TELEMETRY functions (ATSEN, BTSEN, etc.)
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG3__EN_TELEMC__Pos                          6                                                                      /*!< Right-most bit position of en_telemc in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_TELEMC__Msk                          (0x00000001UL << COMMON_EN_REG3__EN_TELEMC__Pos)                       /*!< Mask for en_telemc in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_TELEMC__Shift(v)                     (((v) << COMMON_EN_REG3__EN_TELEMC__Pos) & COMMON_EN_REG3__EN_TELEMC__Msk) /*!< Shift value 'v' into en_telemc and mask 'v' to fit it into en_telemc field */

/** COMMON_EN_REG3__EN_TELEMC__SET() sets EN_REG3.EN_TELEMC to given value.
 *
 * When writing to EN_REG3.EN_TELEMC, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_TELEMC
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_TELEMC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_TELEMC__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_TELEMC__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_TELEMC__GET() gets EN_REG3.EN_TELEMC's current value.
 *
 * When reading from EN_REG3.EN_TELEMC, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_TELEMC
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TELEMC__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_TELEMC__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_TELEMC__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_TELEMC__MODIFY() modifies EN_REG3.EN_TELEMC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_TELEMC
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TELEMC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_TELEMC__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_TELEMC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_TELEMC__EXTRACT() extracts EN_REG3.EN_TELEMC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_TELEMC
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TELEMC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_TELEMC__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_TELEMC__Pos);
    return (uint32_t)reg;
}

/* -------------------------- COMMON.EN_REG3.EN_TS -------------------------- */

/**
<pre>
  COMMON.EN_REG3.EN_TS:

    Function not in use.

</pre> */

#define COMMON_EN_REG3__EN_TS__Pos                              5                                                                      /*!< Right-most bit position of en_ts in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_TS__Msk                              (0x00000001UL << COMMON_EN_REG3__EN_TS__Pos)                           /*!< Mask for en_ts in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_TS__Shift(v)                         (((v) << COMMON_EN_REG3__EN_TS__Pos) & COMMON_EN_REG3__EN_TS__Msk)     /*!< Shift value 'v' into en_ts and mask 'v' to fit it into en_ts field */

/** COMMON_EN_REG3__EN_TS__SET() sets EN_REG3.EN_TS to given value.
 *
 * When writing to EN_REG3.EN_TS, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_TS
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_TS__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_TS__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_TS__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_TS__GET() gets EN_REG3.EN_TS's current value.
 *
 * When reading from EN_REG3.EN_TS, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_TS
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TS__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_TS__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_TS__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_TS__MODIFY() modifies EN_REG3.EN_TS.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_TS
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_TS__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_TS__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_TS__EXTRACT() extracts EN_REG3.EN_TS.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_TS
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TS__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_TS__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_TS__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG3.EN_TSP ------------------------- */

/**
<pre>
  COMMON.EN_REG3.EN_TSP:

    Function not in use.

</pre> */

#define COMMON_EN_REG3__EN_TSP__Pos                             4                                                                      /*!< Right-most bit position of en_tsp in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_TSP__Msk                             (0x00000001UL << COMMON_EN_REG3__EN_TSP__Pos)                          /*!< Mask for en_tsp in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_TSP__Shift(v)                        (((v) << COMMON_EN_REG3__EN_TSP__Pos) & COMMON_EN_REG3__EN_TSP__Msk)   /*!< Shift value 'v' into en_tsp and mask 'v' to fit it into en_tsp field */

/** COMMON_EN_REG3__EN_TSP__SET() sets EN_REG3.EN_TSP to given value.
 *
 * When writing to EN_REG3.EN_TSP, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_TSP
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_TSP__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_TSP__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_TSP__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_TSP__GET() gets EN_REG3.EN_TSP's current value.
 *
 * When reading from EN_REG3.EN_TSP, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_TSP
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TSP__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_TSP__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_TSP__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_TSP__MODIFY() modifies EN_REG3.EN_TSP.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_TSP
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TSP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_TSP__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_TSP__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_TSP__EXTRACT() extracts EN_REG3.EN_TSP.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_TSP
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TSP__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_TSP__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_TSP__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG3.EN_FBAL ------------------------- */

/**
<pre>
  COMMON.EN_REG3.EN_FBAL:

    FW driven HW block enable for Loop 0, Phase 1 Flux / Voltage Balance function.  The parameter is only applicable to bridge topologies.
    <b>Note:</b> Flux balance only functional when corresponding rampX_dutyc_lock also enabled.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG3__EN_FBAL__Pos                            3                                                                      /*!< Right-most bit position of en_fbal in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_FBAL__Msk                            (0x00000001UL << COMMON_EN_REG3__EN_FBAL__Pos)                         /*!< Mask for en_fbal in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_FBAL__Shift(v)                       (((v) << COMMON_EN_REG3__EN_FBAL__Pos) & COMMON_EN_REG3__EN_FBAL__Msk) /*!< Shift value 'v' into en_fbal and mask 'v' to fit it into en_fbal field */

/** COMMON_EN_REG3__EN_FBAL__SET() sets EN_REG3.EN_FBAL to given value.
 *
 * When writing to EN_REG3.EN_FBAL, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_FBAL
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_FBAL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_FBAL__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_FBAL__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_FBAL__GET() gets EN_REG3.EN_FBAL's current value.
 *
 * When reading from EN_REG3.EN_FBAL, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_FBAL
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FBAL__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_FBAL__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_FBAL__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_FBAL__MODIFY() modifies EN_REG3.EN_FBAL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_FBAL
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FBAL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_FBAL__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_FBAL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_FBAL__EXTRACT() extracts EN_REG3.EN_FBAL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_FBAL
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_FBAL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_FBAL__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_FBAL__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG3.EN_IBAL ------------------------- */

/**
<pre>
  COMMON.EN_REG3.EN_IBAL:

    FW driven HW block enable for Current Balance function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG3__EN_IBAL__Pos                            2                                                                      /*!< Right-most bit position of en_ibal in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_IBAL__Msk                            (0x00000001UL << COMMON_EN_REG3__EN_IBAL__Pos)                         /*!< Mask for en_ibal in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_IBAL__Shift(v)                       (((v) << COMMON_EN_REG3__EN_IBAL__Pos) & COMMON_EN_REG3__EN_IBAL__Msk) /*!< Shift value 'v' into en_ibal and mask 'v' to fit it into en_ibal field */

/** COMMON_EN_REG3__EN_IBAL__SET() sets EN_REG3.EN_IBAL to given value.
 *
 * When writing to EN_REG3.EN_IBAL, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_IBAL
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_IBAL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_IBAL__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_IBAL__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_IBAL__GET() gets EN_REG3.EN_IBAL's current value.
 *
 * When reading from EN_REG3.EN_IBAL, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_IBAL
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_IBAL__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_IBAL__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_IBAL__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_IBAL__MODIFY() modifies EN_REG3.EN_IBAL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_IBAL
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_IBAL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_IBAL__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_IBAL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_IBAL__EXTRACT() extracts EN_REG3.EN_IBAL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_IBAL
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_IBAL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_IBAL__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_IBAL__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG3.EN_SYNC ------------------------- */

/**
<pre>
  COMMON.EN_REG3.EN_SYNC:

    FW driven HW block enable for SYNC function
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG3__EN_SYNC__Pos                            1                                                                      /*!< Right-most bit position of en_sync in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_SYNC__Msk                            (0x00000001UL << COMMON_EN_REG3__EN_SYNC__Pos)                         /*!< Mask for en_sync in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_SYNC__Shift(v)                       (((v) << COMMON_EN_REG3__EN_SYNC__Pos) & COMMON_EN_REG3__EN_SYNC__Msk) /*!< Shift value 'v' into en_sync and mask 'v' to fit it into en_sync field */

/** COMMON_EN_REG3__EN_SYNC__SET() sets EN_REG3.EN_SYNC to given value.
 *
 * When writing to EN_REG3.EN_SYNC, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_SYNC
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_SYNC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_SYNC__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_SYNC__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_SYNC__GET() gets EN_REG3.EN_SYNC's current value.
 *
 * When reading from EN_REG3.EN_SYNC, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_SYNC
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_SYNC__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_SYNC__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_SYNC__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_SYNC__MODIFY() modifies EN_REG3.EN_SYNC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_SYNC
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_SYNC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_SYNC__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_SYNC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_SYNC__EXTRACT() extracts EN_REG3.EN_SYNC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_SYNC
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_SYNC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_SYNC__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_SYNC__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.EN_REG3.EN_TSEN ------------------------- */

/**
<pre>
  COMMON.EN_REG3.EN_TSEN:

    FW driven HW block enable for TS ADC
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_EN_REG3__EN_TSEN__Pos                            0                                                                      /*!< Right-most bit position of en_tsen in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_TSEN__Msk                            (0x00000001UL << COMMON_EN_REG3__EN_TSEN__Pos)                         /*!< Mask for en_tsen in COMMON.EN_REG3 */
#define COMMON_EN_REG3__EN_TSEN__Shift(v)                       (((v) << COMMON_EN_REG3__EN_TSEN__Pos) & COMMON_EN_REG3__EN_TSEN__Msk) /*!< Shift value 'v' into en_tsen and mask 'v' to fit it into en_tsen field */

/** COMMON_EN_REG3__EN_TSEN__SET() sets EN_REG3.EN_TSEN to given value.
 *
 * When writing to EN_REG3.EN_TSEN, this is recommended to use.
 *
 * @param bf_value new value for EN_REG3.EN_TSEN
 */
__COMMON_INLINE void COMMON_EN_REG3__EN_TSEN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & ~COMMON_EN_REG3__EN_TSEN__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_TSEN__Shift((uint32_t)bf_value)));
    COMMON_EN_REG3__SET(reg);
}

/** COMMON_EN_REG3__EN_TSEN__GET() gets EN_REG3.EN_TSEN's current value.
 *
 * When reading from EN_REG3.EN_TSEN, this is recommended to use.
 *
 * @return current value of EN_REG3.EN_TSEN
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TSEN__GET(void)
{
    uint32_t reg = COMMON_EN_REG3__GET();
    reg = (reg & COMMON_EN_REG3__EN_TSEN__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_TSEN__Pos);
    return (uint32_t)reg;
}

/** COMMON_EN_REG3__EN_TSEN__MODIFY() modifies EN_REG3.EN_TSEN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.EN_REG3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.EN_REG3
 * @param bf_value new value for EN_REG3.EN_TSEN
 * @return new value of COMMON.EN_REG3
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TSEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_EN_REG3__EN_TSEN__Msk);
    reg = (reg | (COMMON_EN_REG3__EN_TSEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_EN_REG3__EN_TSEN__EXTRACT() extracts EN_REG3.EN_TSEN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.EN_REG3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.EN_REG3
 * @return current value of EN_REG3.EN_TSEN
 */
__COMMON_INLINE uint32_t COMMON_EN_REG3__EN_TSEN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_EN_REG3__EN_TSEN__Msk);
    reg = (reg >> COMMON_EN_REG3__EN_TSEN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       FPGA_STATUS member of COMMON_t                       */
/* -------------------------------------------------------------------------- */

/** __COMMON_FPGA_STATUS__ADDRESS returns the address of member FPGA_STATUS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FPGA_STATUS
 */
__COMMON_INLINE uint32_t* __COMMON_FPGA_STATUS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, FPGA_STATUS)));
}

/** COMMON_FPGA_STATUS__GET() gets FPGA_STATUS's current value.
 *
 * When reading from FPGA_STATUS, this is mandatory to use.
 *
 * @return current value of FPGA_STATUS
 */
__COMMON_INLINE uint32_t COMMON_FPGA_STATUS__GET(void)
{
    return HAL_GET32(__COMMON_FPGA_STATUS__ADDRESS());
}

/* --------------------- COMMON.FPGA_STATUS.FPGA_STATUS --------------------- */

/**
<pre>
  COMMON.FPGA_STATUS.FPGA_STATUS:

    FPGA Status register.  See bitfile release notes for description.

</pre> */

#define COMMON_FPGA_STATUS__FPGA_STATUS__Pos                    0                                                                      /*!< Right-most bit position of fpga_status in COMMON.FPGA_STATUS */
#define COMMON_FPGA_STATUS__FPGA_STATUS__Msk                    (0xFFFFFFFFUL << COMMON_FPGA_STATUS__FPGA_STATUS__Pos)                 /*!< Mask for fpga_status in COMMON.FPGA_STATUS */
#define COMMON_FPGA_STATUS__FPGA_STATUS__Shift(v)               (((v) << COMMON_FPGA_STATUS__FPGA_STATUS__Pos) & COMMON_FPGA_STATUS__FPGA_STATUS__Msk) /*!< Shift value 'v' into fpga_status and mask 'v' to fit it into fpga_status field */

/** COMMON_FPGA_STATUS__FPGA_STATUS__GET() gets FPGA_STATUS.FPGA_STATUS's current value.
 *
 * When reading from FPGA_STATUS.FPGA_STATUS, this is recommended to use.
 *
 * @return current value of FPGA_STATUS.FPGA_STATUS
 */
__COMMON_INLINE uint32_t COMMON_FPGA_STATUS__FPGA_STATUS__GET(void)
{
    uint32_t reg = COMMON_FPGA_STATUS__GET();
    reg = (reg & COMMON_FPGA_STATUS__FPGA_STATUS__Msk);
    reg = (reg >> COMMON_FPGA_STATUS__FPGA_STATUS__Pos);
    return (uint32_t)reg;
}

/** COMMON_FPGA_STATUS__FPGA_STATUS__EXTRACT() extracts FPGA_STATUS.FPGA_STATUS.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FPGA_STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FPGA_STATUS
 * @return current value of FPGA_STATUS.FPGA_STATUS
 */
__COMMON_INLINE uint32_t COMMON_FPGA_STATUS__FPGA_STATUS__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FPGA_STATUS__FPGA_STATUS__Msk);
    reg = (reg >> COMMON_FPGA_STATUS__FPGA_STATUS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       FPGA_CONFIG member of COMMON_t                       */
/* -------------------------------------------------------------------------- */

/** __COMMON_FPGA_CONFIG__ADDRESS returns the address of member FPGA_CONFIG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FPGA_CONFIG
 */
__COMMON_INLINE uint32_t* __COMMON_FPGA_CONFIG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, FPGA_CONFIG)));
}

/** COMMON_FPGA_CONFIG__SET() sets FPGA_CONFIG to given value.
 *
 * When writing to FPGA_CONFIG, this is mandatory to use.
 *
 * @param value new value for FPGA_CONFIG
 */
__COMMON_INLINE void COMMON_FPGA_CONFIG__SET(uint32_t value)
{
    HAL_SET32(__COMMON_FPGA_CONFIG__ADDRESS(), value);
}

/** COMMON_FPGA_CONFIG__GET() gets FPGA_CONFIG's current value.
 *
 * When reading from FPGA_CONFIG, this is mandatory to use.
 *
 * @return current value of FPGA_CONFIG
 */
__COMMON_INLINE uint32_t COMMON_FPGA_CONFIG__GET(void)
{
    return HAL_GET32(__COMMON_FPGA_CONFIG__ADDRESS());
}

/* --------------------- COMMON.FPGA_CONFIG.FPGA_CONFIG --------------------- */

/**
<pre>
  COMMON.FPGA_CONFIG.FPGA_CONFIG:

    FPGA Configuration Register:
    <start table_with_header>
    Bits Function
    [2:0] "ISEN Mapping (e.g., [2:0]=0, ISEN mapped to ISEN1)"
    [5:3] "BISEN Mapping (e.g., [5:3]=1, BISEN mapped to ISEN2)"
    [7:6] "fpga_vrs_comp_dly; delays wrapper generated vrs_comp, 0=no delay, 1 =40ns delay, 2=80ns, 3=120ns delay"
    <end table>

</pre> */

#define COMMON_FPGA_CONFIG__FPGA_CONFIG__Pos                    0                                                                      /*!< Right-most bit position of fpga_config in COMMON.FPGA_CONFIG */
#define COMMON_FPGA_CONFIG__FPGA_CONFIG__Msk                    (0xFFFFFFFFUL << COMMON_FPGA_CONFIG__FPGA_CONFIG__Pos)                 /*!< Mask for fpga_config in COMMON.FPGA_CONFIG */
#define COMMON_FPGA_CONFIG__FPGA_CONFIG__Shift(v)               (((v) << COMMON_FPGA_CONFIG__FPGA_CONFIG__Pos) & COMMON_FPGA_CONFIG__FPGA_CONFIG__Msk) /*!< Shift value 'v' into fpga_config and mask 'v' to fit it into fpga_config field */

/** COMMON_FPGA_CONFIG__FPGA_CONFIG__SET() sets FPGA_CONFIG.FPGA_CONFIG to given value.
 *
 * When writing to FPGA_CONFIG.FPGA_CONFIG, this is recommended to use.
 *
 * @param bf_value new value for FPGA_CONFIG.FPGA_CONFIG
 */
__COMMON_INLINE void COMMON_FPGA_CONFIG__FPGA_CONFIG__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FPGA_CONFIG__GET();
    reg = (reg & ~COMMON_FPGA_CONFIG__FPGA_CONFIG__Msk);
    reg = (reg | (COMMON_FPGA_CONFIG__FPGA_CONFIG__Shift((uint32_t)bf_value)));
    COMMON_FPGA_CONFIG__SET(reg);
}

/** COMMON_FPGA_CONFIG__FPGA_CONFIG__GET() gets FPGA_CONFIG.FPGA_CONFIG's current value.
 *
 * When reading from FPGA_CONFIG.FPGA_CONFIG, this is recommended to use.
 *
 * @return current value of FPGA_CONFIG.FPGA_CONFIG
 */
__COMMON_INLINE uint32_t COMMON_FPGA_CONFIG__FPGA_CONFIG__GET(void)
{
    uint32_t reg = COMMON_FPGA_CONFIG__GET();
    reg = (reg & COMMON_FPGA_CONFIG__FPGA_CONFIG__Msk);
    reg = (reg >> COMMON_FPGA_CONFIG__FPGA_CONFIG__Pos);
    return (uint32_t)reg;
}

/** COMMON_FPGA_CONFIG__FPGA_CONFIG__MODIFY() modifies FPGA_CONFIG.FPGA_CONFIG.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FPGA_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FPGA_CONFIG
 * @param bf_value new value for FPGA_CONFIG.FPGA_CONFIG
 * @return new value of COMMON.FPGA_CONFIG
 */
__COMMON_INLINE uint32_t COMMON_FPGA_CONFIG__FPGA_CONFIG__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FPGA_CONFIG__FPGA_CONFIG__Msk);
    reg = (reg | (COMMON_FPGA_CONFIG__FPGA_CONFIG__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FPGA_CONFIG__FPGA_CONFIG__EXTRACT() extracts FPGA_CONFIG.FPGA_CONFIG.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FPGA_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FPGA_CONFIG
 * @return current value of FPGA_CONFIG.FPGA_CONFIG
 */
__COMMON_INLINE uint32_t COMMON_FPGA_CONFIG__FPGA_CONFIG__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FPGA_CONFIG__FPGA_CONFIG__Msk);
    reg = (reg >> COMMON_FPGA_CONFIG__FPGA_CONFIG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VSP1_SR_CNT member of COMMON_t                       */
/* -------------------------------------------------------------------------- */

/** __COMMON_VSP1_SR_CNT__ADDRESS returns the address of member VSP1_SR_CNT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP1_SR_CNT
 */
__COMMON_INLINE uint32_t* __COMMON_VSP1_SR_CNT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VSP1_SR_CNT)));
}

/** COMMON_VSP1_SR_CNT__GET() gets VSP1_SR_CNT's current value.
 *
 * When reading from VSP1_SR_CNT, this is mandatory to use.
 *
 * @return current value of VSP1_SR_CNT
 */
__COMMON_INLINE uint32_t COMMON_VSP1_SR_CNT__GET(void)
{
    return HAL_GET32(__COMMON_VSP1_SR_CNT__ADDRESS());
}

/* ------------------ COMMON.VSP1_SR_CNT.VSP1_CNT_VRSF2SRR ------------------ */

/**
<pre>
  COMMON.VSP1_SR_CNT.VSP1_CNT_VRSF2SRR:

    Non-averaged VRSEN VRS Comp falling edge to SR FET rising edge measurement result.
    LSB = 5ns, Range = 0 to 1275ns

</pre> */

#define COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__Pos              24                                                                     /*!< Right-most bit position of vsp1_cnt_vrsf2srr in COMMON.VSP1_SR_CNT */
#define COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__Msk              (0x000000FFUL << COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__Pos)           /*!< Mask for vsp1_cnt_vrsf2srr in COMMON.VSP1_SR_CNT */
#define COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__Shift(v)         (((v) << COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__Pos) & COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__Msk) /*!< Shift value 'v' into vsp1_cnt_vrsf2srr and mask 'v' to fit it into vsp1_cnt_vrsf2srr field */

/** COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__GET() gets VSP1_SR_CNT.VSP1_CNT_VRSF2SRR's current value.
 *
 * When reading from VSP1_SR_CNT.VSP1_CNT_VRSF2SRR, this is recommended to use.
 *
 * @return current value of VSP1_SR_CNT.VSP1_CNT_VRSF2SRR
 */
__COMMON_INLINE uint32_t COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__GET(void)
{
    uint32_t reg = COMMON_VSP1_SR_CNT__GET();
    reg = (reg & COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__Msk);
    reg = (reg >> COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__EXTRACT() extracts VSP1_SR_CNT.VSP1_CNT_VRSF2SRR.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_SR_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_SR_CNT
 * @return current value of VSP1_SR_CNT.VSP1_CNT_VRSF2SRR
 */
__COMMON_INLINE uint32_t COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__Msk);
    reg = (reg >> COMMON_VSP1_SR_CNT__VSP1_CNT_VRSF2SRR__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.VSP1_SR_CNT.VSP1_CNT_SRF2VRSR ------------------ */

/**
<pre>
  COMMON.VSP1_SR_CNT.VSP1_CNT_SRF2VRSR:

    Non-averaged VRSEN SR FET falling edge to VRS Comp rising edge measurement result.
    LSB = 5ns, Range = 0 to 1275ns

</pre> */

#define COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__Pos              16                                                                     /*!< Right-most bit position of vsp1_cnt_srf2vrsr in COMMON.VSP1_SR_CNT */
#define COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__Msk              (0x000000FFUL << COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__Pos)           /*!< Mask for vsp1_cnt_srf2vrsr in COMMON.VSP1_SR_CNT */
#define COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__Shift(v)         (((v) << COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__Pos) & COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__Msk) /*!< Shift value 'v' into vsp1_cnt_srf2vrsr and mask 'v' to fit it into vsp1_cnt_srf2vrsr field */

/** COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__GET() gets VSP1_SR_CNT.VSP1_CNT_SRF2VRSR's current value.
 *
 * When reading from VSP1_SR_CNT.VSP1_CNT_SRF2VRSR, this is recommended to use.
 *
 * @return current value of VSP1_SR_CNT.VSP1_CNT_SRF2VRSR
 */
__COMMON_INLINE uint32_t COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__GET(void)
{
    uint32_t reg = COMMON_VSP1_SR_CNT__GET();
    reg = (reg & COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__Msk);
    reg = (reg >> COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__EXTRACT() extracts VSP1_SR_CNT.VSP1_CNT_SRF2VRSR.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_SR_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_SR_CNT
 * @return current value of VSP1_SR_CNT.VSP1_CNT_SRF2VRSR
 */
__COMMON_INLINE uint32_t COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__Msk);
    reg = (reg >> COMMON_VSP1_SR_CNT__VSP1_CNT_SRF2VRSR__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.VSP1_SR_CNT.VSP1_CNT_SRR_AVG ------------------ */

/**
<pre>
  COMMON.VSP1_SR_CNT.VSP1_CNT_SRR_AVG:

    Block averaged VRSEN VRS Comp falling edge to SR FET rising edge measurement result.
    LSB = 5ns, Range = 0 to 1275ns

</pre> */

#define COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__Pos               8                                                                      /*!< Right-most bit position of vsp1_cnt_srr_avg in COMMON.VSP1_SR_CNT */
#define COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__Msk               (0x000000FFUL << COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__Pos)            /*!< Mask for vsp1_cnt_srr_avg in COMMON.VSP1_SR_CNT */
#define COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__Shift(v)          (((v) << COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__Pos) & COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__Msk) /*!< Shift value 'v' into vsp1_cnt_srr_avg and mask 'v' to fit it into vsp1_cnt_srr_avg field */

/** COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__GET() gets VSP1_SR_CNT.VSP1_CNT_SRR_AVG's current value.
 *
 * When reading from VSP1_SR_CNT.VSP1_CNT_SRR_AVG, this is recommended to use.
 *
 * @return current value of VSP1_SR_CNT.VSP1_CNT_SRR_AVG
 */
__COMMON_INLINE uint32_t COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__GET(void)
{
    uint32_t reg = COMMON_VSP1_SR_CNT__GET();
    reg = (reg & COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__Msk);
    reg = (reg >> COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__EXTRACT() extracts VSP1_SR_CNT.VSP1_CNT_SRR_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_SR_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_SR_CNT
 * @return current value of VSP1_SR_CNT.VSP1_CNT_SRR_AVG
 */
__COMMON_INLINE uint32_t COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__Msk);
    reg = (reg >> COMMON_VSP1_SR_CNT__VSP1_CNT_SRR_AVG__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.VSP1_SR_CNT.VSP1_CNT_SRF_AVG ------------------ */

/**
<pre>
  COMMON.VSP1_SR_CNT.VSP1_CNT_SRF_AVG:

    Block averaged VRSEN SR FET falling edge to VRS Comp rising edge measurement result.
    LSB = 5ns, Range = 0 to 1275ns

</pre> */

#define COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__Pos               0                                                                      /*!< Right-most bit position of vsp1_cnt_srf_avg in COMMON.VSP1_SR_CNT */
#define COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__Msk               (0x000000FFUL << COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__Pos)            /*!< Mask for vsp1_cnt_srf_avg in COMMON.VSP1_SR_CNT */
#define COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__Shift(v)          (((v) << COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__Pos) & COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__Msk) /*!< Shift value 'v' into vsp1_cnt_srf_avg and mask 'v' to fit it into vsp1_cnt_srf_avg field */

/** COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__GET() gets VSP1_SR_CNT.VSP1_CNT_SRF_AVG's current value.
 *
 * When reading from VSP1_SR_CNT.VSP1_CNT_SRF_AVG, this is recommended to use.
 *
 * @return current value of VSP1_SR_CNT.VSP1_CNT_SRF_AVG
 */
__COMMON_INLINE uint32_t COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__GET(void)
{
    uint32_t reg = COMMON_VSP1_SR_CNT__GET();
    reg = (reg & COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__Msk);
    reg = (reg >> COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__EXTRACT() extracts VSP1_SR_CNT.VSP1_CNT_SRF_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_SR_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_SR_CNT
 * @return current value of VSP1_SR_CNT.VSP1_CNT_SRF_AVG
 */
__COMMON_INLINE uint32_t COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__Msk);
    reg = (reg >> COMMON_VSP1_SR_CNT__VSP1_CNT_SRF_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      VSP1_VRS_CNT member of COMMON_t                      */
/* -------------------------------------------------------------------------- */

/** __COMMON_VSP1_VRS_CNT__ADDRESS returns the address of member VSP1_VRS_CNT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP1_VRS_CNT
 */
__COMMON_INLINE uint32_t* __COMMON_VSP1_VRS_CNT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VSP1_VRS_CNT)));
}

/** COMMON_VSP1_VRS_CNT__GET() gets VSP1_VRS_CNT's current value.
 *
 * When reading from VSP1_VRS_CNT, this is mandatory to use.
 *
 * @return current value of VSP1_VRS_CNT
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_CNT__GET(void)
{
    return HAL_GET32(__COMMON_VSP1_VRS_CNT__ADDRESS());
}

/* ------------------ COMMON.VSP1_VRS_CNT.VSP1_VRSR_B4_SRF ------------------ */

/**
<pre>
  COMMON.VSP1_VRS_CNT.VSP1_VRSR_B4_SRF:

    Status flag indicating VRSEN detected VRS Comp rising edge before SR FET falling edge (i.e., no dead time on PWM rising edge) on previous cycle.
    <start table>
    0 "VRS Comp rising edge after SR FET falling edge"
    1 "VRS Comp rising edge before SR FET falling edge"
    <end table>

</pre> */

#define COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__Pos              23                                                                     /*!< Right-most bit position of vsp1_vrsr_b4_srf in COMMON.VSP1_VRS_CNT */
#define COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__Msk              (0x00000001UL << COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__Pos)           /*!< Mask for vsp1_vrsr_b4_srf in COMMON.VSP1_VRS_CNT */
#define COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__Shift(v)         (((v) << COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__Pos) & COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__Msk) /*!< Shift value 'v' into vsp1_vrsr_b4_srf and mask 'v' to fit it into vsp1_vrsr_b4_srf field */

/** COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__GET() gets VSP1_VRS_CNT.VSP1_VRSR_B4_SRF's current value.
 *
 * When reading from VSP1_VRS_CNT.VSP1_VRSR_B4_SRF, this is recommended to use.
 *
 * @return current value of VSP1_VRS_CNT.VSP1_VRSR_B4_SRF
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__GET(void)
{
    uint32_t reg = COMMON_VSP1_VRS_CNT__GET();
    reg = (reg & COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__Msk);
    reg = (reg >> COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__EXTRACT() extracts VSP1_VRS_CNT.VSP1_VRSR_B4_SRF.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_VRS_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_VRS_CNT
 * @return current value of VSP1_VRS_CNT.VSP1_VRSR_B4_SRF
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__Msk);
    reg = (reg >> COMMON_VSP1_VRS_CNT__VSP1_VRSR_B4_SRF__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.VSP1_VRS_CNT.VSP1_SRR_B4_VRSF ------------------ */

/**
<pre>
  COMMON.VSP1_VRS_CNT.VSP1_SRR_B4_VRSF:

    Status flag indicating VRSEN detected SR FET rising edge before VRS Comp falling edge (i.e., no dead time on PWM falling edge) on previous cycle.
    <start table>
    0 "SR FET rising edge after VRS Comp falling edge"
    1 "SR FET rising edge before VRS Comp falling edge"
    <end table>

</pre> */

#define COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__Pos              22                                                                     /*!< Right-most bit position of vsp1_srr_b4_vrsf in COMMON.VSP1_VRS_CNT */
#define COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__Msk              (0x00000001UL << COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__Pos)           /*!< Mask for vsp1_srr_b4_vrsf in COMMON.VSP1_VRS_CNT */
#define COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__Shift(v)         (((v) << COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__Pos) & COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__Msk) /*!< Shift value 'v' into vsp1_srr_b4_vrsf and mask 'v' to fit it into vsp1_srr_b4_vrsf field */

/** COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__GET() gets VSP1_VRS_CNT.VSP1_SRR_B4_VRSF's current value.
 *
 * When reading from VSP1_VRS_CNT.VSP1_SRR_B4_VRSF, this is recommended to use.
 *
 * @return current value of VSP1_VRS_CNT.VSP1_SRR_B4_VRSF
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__GET(void)
{
    uint32_t reg = COMMON_VSP1_VRS_CNT__GET();
    reg = (reg & COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__Msk);
    reg = (reg >> COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__EXTRACT() extracts VSP1_VRS_CNT.VSP1_SRR_B4_VRSF.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_VRS_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_VRS_CNT
 * @return current value of VSP1_VRS_CNT.VSP1_SRR_B4_VRSF
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__Msk);
    reg = (reg >> COMMON_VSP1_VRS_CNT__VSP1_SRR_B4_VRSF__Pos);
    return (uint32_t)reg;
}

/* ----------------- COMMON.VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_O ----------------- */

/**
<pre>
  COMMON.VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_O:

    Non-averaged VRSEN VRS Comp pulse width measurement result for the odd half cycle of bridge topologies.
    LSB = 5ns, Range = 0 to 1025ns

</pre> */

#define COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__Pos            11                                                                     /*!< Right-most bit position of vsp1_cnt_vrscomp_o in COMMON.VSP1_VRS_CNT */
#define COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__Msk            (0x000007FFUL << COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__Pos)         /*!< Mask for vsp1_cnt_vrscomp_o in COMMON.VSP1_VRS_CNT */
#define COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__Shift(v)       (((v) << COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__Pos) & COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__Msk) /*!< Shift value 'v' into vsp1_cnt_vrscomp_o and mask 'v' to fit it into vsp1_cnt_vrscomp_o field */

/** COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__GET() gets VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_O's current value.
 *
 * When reading from VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_O, this is recommended to use.
 *
 * @return current value of VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_O
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__GET(void)
{
    uint32_t reg = COMMON_VSP1_VRS_CNT__GET();
    reg = (reg & COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__Msk);
    reg = (reg >> COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__EXTRACT() extracts VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_O.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_VRS_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_VRS_CNT
 * @return current value of VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_O
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__Msk);
    reg = (reg >> COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_O__Pos);
    return (uint32_t)reg;
}

/* ----------------- COMMON.VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_E ----------------- */

/**
<pre>
  COMMON.VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_E:

    Non-averaged VRSEN VRS Comp pulse width measurement result for ACF topology or the even half cycle of bridge topologies.
    LSB = 5ns, Range = 0 to 1025ns

</pre> */

#define COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__Pos            0                                                                      /*!< Right-most bit position of vsp1_cnt_vrscomp_e in COMMON.VSP1_VRS_CNT */
#define COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__Msk            (0x000007FFUL << COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__Pos)         /*!< Mask for vsp1_cnt_vrscomp_e in COMMON.VSP1_VRS_CNT */
#define COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__Shift(v)       (((v) << COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__Pos) & COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__Msk) /*!< Shift value 'v' into vsp1_cnt_vrscomp_e and mask 'v' to fit it into vsp1_cnt_vrscomp_e field */

/** COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__GET() gets VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_E's current value.
 *
 * When reading from VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_E, this is recommended to use.
 *
 * @return current value of VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_E
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__GET(void)
{
    uint32_t reg = COMMON_VSP1_VRS_CNT__GET();
    reg = (reg & COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__Msk);
    reg = (reg >> COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__EXTRACT() extracts VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_E.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP1_VRS_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP1_VRS_CNT
 * @return current value of VSP1_VRS_CNT.VSP1_CNT_VRSCOMP_E
 */
__COMMON_INLINE uint32_t COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__Msk);
    reg = (reg >> COMMON_VSP1_VRS_CNT__VSP1_CNT_VRSCOMP_E__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VSP2_SR_CNT member of COMMON_t                       */
/* -------------------------------------------------------------------------- */

/** __COMMON_VSP2_SR_CNT__ADDRESS returns the address of member VSP2_SR_CNT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP2_SR_CNT
 */
__COMMON_INLINE uint32_t* __COMMON_VSP2_SR_CNT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VSP2_SR_CNT)));
}

/** COMMON_VSP2_SR_CNT__GET() gets VSP2_SR_CNT's current value.
 *
 * When reading from VSP2_SR_CNT, this is mandatory to use.
 *
 * @return current value of VSP2_SR_CNT
 */
__COMMON_INLINE uint32_t COMMON_VSP2_SR_CNT__GET(void)
{
    return HAL_GET32(__COMMON_VSP2_SR_CNT__ADDRESS());
}

/* ------------------ COMMON.VSP2_SR_CNT.VSP2_CNT_VRSF2SRR ------------------ */

/**
<pre>
  COMMON.VSP2_SR_CNT.VSP2_CNT_VRSF2SRR:

    Non-averaged BVRSEN VRS Comp falling edge to SR FET rising edge measurement result.
    LSB = 5ns, Range = 0 to 1275ns

</pre> */

#define COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__Pos              24                                                                     /*!< Right-most bit position of vsp2_cnt_vrsf2srr in COMMON.VSP2_SR_CNT */
#define COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__Msk              (0x000000FFUL << COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__Pos)           /*!< Mask for vsp2_cnt_vrsf2srr in COMMON.VSP2_SR_CNT */
#define COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__Shift(v)         (((v) << COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__Pos) & COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__Msk) /*!< Shift value 'v' into vsp2_cnt_vrsf2srr and mask 'v' to fit it into vsp2_cnt_vrsf2srr field */

/** COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__GET() gets VSP2_SR_CNT.VSP2_CNT_VRSF2SRR's current value.
 *
 * When reading from VSP2_SR_CNT.VSP2_CNT_VRSF2SRR, this is recommended to use.
 *
 * @return current value of VSP2_SR_CNT.VSP2_CNT_VRSF2SRR
 */
__COMMON_INLINE uint32_t COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__GET(void)
{
    uint32_t reg = COMMON_VSP2_SR_CNT__GET();
    reg = (reg & COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__Msk);
    reg = (reg >> COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__EXTRACT() extracts VSP2_SR_CNT.VSP2_CNT_VRSF2SRR.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_SR_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_SR_CNT
 * @return current value of VSP2_SR_CNT.VSP2_CNT_VRSF2SRR
 */
__COMMON_INLINE uint32_t COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__Msk);
    reg = (reg >> COMMON_VSP2_SR_CNT__VSP2_CNT_VRSF2SRR__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.VSP2_SR_CNT.VSP2_CNT_SRF2VRSR ------------------ */

/**
<pre>
  COMMON.VSP2_SR_CNT.VSP2_CNT_SRF2VRSR:

    Non-averaged BVRSEN SR FET falling edge to VRS Comp rising edge measurement result.
    LSB = 5ns, Range = 0 to 1275ns

</pre> */

#define COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__Pos              16                                                                     /*!< Right-most bit position of vsp2_cnt_srf2vrsr in COMMON.VSP2_SR_CNT */
#define COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__Msk              (0x000000FFUL << COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__Pos)           /*!< Mask for vsp2_cnt_srf2vrsr in COMMON.VSP2_SR_CNT */
#define COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__Shift(v)         (((v) << COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__Pos) & COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__Msk) /*!< Shift value 'v' into vsp2_cnt_srf2vrsr and mask 'v' to fit it into vsp2_cnt_srf2vrsr field */

/** COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__GET() gets VSP2_SR_CNT.VSP2_CNT_SRF2VRSR's current value.
 *
 * When reading from VSP2_SR_CNT.VSP2_CNT_SRF2VRSR, this is recommended to use.
 *
 * @return current value of VSP2_SR_CNT.VSP2_CNT_SRF2VRSR
 */
__COMMON_INLINE uint32_t COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__GET(void)
{
    uint32_t reg = COMMON_VSP2_SR_CNT__GET();
    reg = (reg & COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__Msk);
    reg = (reg >> COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__EXTRACT() extracts VSP2_SR_CNT.VSP2_CNT_SRF2VRSR.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_SR_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_SR_CNT
 * @return current value of VSP2_SR_CNT.VSP2_CNT_SRF2VRSR
 */
__COMMON_INLINE uint32_t COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__Msk);
    reg = (reg >> COMMON_VSP2_SR_CNT__VSP2_CNT_SRF2VRSR__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.VSP2_SR_CNT.VSP2_CNT_SRR_AVG ------------------ */

/**
<pre>
  COMMON.VSP2_SR_CNT.VSP2_CNT_SRR_AVG:

    Block averaged BVRSEN VRS Comp falling edge to SR FET rising edge measurement result.
    LSB = 5ns, Range = 0 to 1275ns

</pre> */

#define COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__Pos               8                                                                      /*!< Right-most bit position of vsp2_cnt_srr_avg in COMMON.VSP2_SR_CNT */
#define COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__Msk               (0x000000FFUL << COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__Pos)            /*!< Mask for vsp2_cnt_srr_avg in COMMON.VSP2_SR_CNT */
#define COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__Shift(v)          (((v) << COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__Pos) & COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__Msk) /*!< Shift value 'v' into vsp2_cnt_srr_avg and mask 'v' to fit it into vsp2_cnt_srr_avg field */

/** COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__GET() gets VSP2_SR_CNT.VSP2_CNT_SRR_AVG's current value.
 *
 * When reading from VSP2_SR_CNT.VSP2_CNT_SRR_AVG, this is recommended to use.
 *
 * @return current value of VSP2_SR_CNT.VSP2_CNT_SRR_AVG
 */
__COMMON_INLINE uint32_t COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__GET(void)
{
    uint32_t reg = COMMON_VSP2_SR_CNT__GET();
    reg = (reg & COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__Msk);
    reg = (reg >> COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__EXTRACT() extracts VSP2_SR_CNT.VSP2_CNT_SRR_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_SR_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_SR_CNT
 * @return current value of VSP2_SR_CNT.VSP2_CNT_SRR_AVG
 */
__COMMON_INLINE uint32_t COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__Msk);
    reg = (reg >> COMMON_VSP2_SR_CNT__VSP2_CNT_SRR_AVG__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.VSP2_SR_CNT.VSP2_CNT_SRF_AVG ------------------ */

/**
<pre>
  COMMON.VSP2_SR_CNT.VSP2_CNT_SRF_AVG:

    Block averaged BVRSEN SR FET falling edge to VRS Comp rising edge measurement result.
    LSB = 5ns, Range = 0 to 1275ns

</pre> */

#define COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__Pos               0                                                                      /*!< Right-most bit position of vsp2_cnt_srf_avg in COMMON.VSP2_SR_CNT */
#define COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__Msk               (0x000000FFUL << COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__Pos)            /*!< Mask for vsp2_cnt_srf_avg in COMMON.VSP2_SR_CNT */
#define COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__Shift(v)          (((v) << COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__Pos) & COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__Msk) /*!< Shift value 'v' into vsp2_cnt_srf_avg and mask 'v' to fit it into vsp2_cnt_srf_avg field */

/** COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__GET() gets VSP2_SR_CNT.VSP2_CNT_SRF_AVG's current value.
 *
 * When reading from VSP2_SR_CNT.VSP2_CNT_SRF_AVG, this is recommended to use.
 *
 * @return current value of VSP2_SR_CNT.VSP2_CNT_SRF_AVG
 */
__COMMON_INLINE uint32_t COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__GET(void)
{
    uint32_t reg = COMMON_VSP2_SR_CNT__GET();
    reg = (reg & COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__Msk);
    reg = (reg >> COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__EXTRACT() extracts VSP2_SR_CNT.VSP2_CNT_SRF_AVG.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_SR_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_SR_CNT
 * @return current value of VSP2_SR_CNT.VSP2_CNT_SRF_AVG
 */
__COMMON_INLINE uint32_t COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__Msk);
    reg = (reg >> COMMON_VSP2_SR_CNT__VSP2_CNT_SRF_AVG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      VSP2_VRS_CNT member of COMMON_t                      */
/* -------------------------------------------------------------------------- */

/** __COMMON_VSP2_VRS_CNT__ADDRESS returns the address of member VSP2_VRS_CNT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP2_VRS_CNT
 */
__COMMON_INLINE uint32_t* __COMMON_VSP2_VRS_CNT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VSP2_VRS_CNT)));
}

/** COMMON_VSP2_VRS_CNT__GET() gets VSP2_VRS_CNT's current value.
 *
 * When reading from VSP2_VRS_CNT, this is mandatory to use.
 *
 * @return current value of VSP2_VRS_CNT
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_CNT__GET(void)
{
    return HAL_GET32(__COMMON_VSP2_VRS_CNT__ADDRESS());
}

/* ------------------ COMMON.VSP2_VRS_CNT.VSP2_VRSR_B4_SRF ------------------ */

/**
<pre>
  COMMON.VSP2_VRS_CNT.VSP2_VRSR_B4_SRF:

    Status flag indicating BVRSEN detected VRS Comp rising edge before SR FET falling edge (i.e., no dead time on PWM rising edge) on previous cycle.
    <start table>
    0 "VRS Comp rising edge after SR FET falling edge"
    1 "VRS Comp rising edge before SR FET falling edge"
    <end table>

</pre> */

#define COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__Pos              23                                                                     /*!< Right-most bit position of vsp2_vrsr_b4_srf in COMMON.VSP2_VRS_CNT */
#define COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__Msk              (0x00000001UL << COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__Pos)           /*!< Mask for vsp2_vrsr_b4_srf in COMMON.VSP2_VRS_CNT */
#define COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__Shift(v)         (((v) << COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__Pos) & COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__Msk) /*!< Shift value 'v' into vsp2_vrsr_b4_srf and mask 'v' to fit it into vsp2_vrsr_b4_srf field */

/** COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__GET() gets VSP2_VRS_CNT.VSP2_VRSR_B4_SRF's current value.
 *
 * When reading from VSP2_VRS_CNT.VSP2_VRSR_B4_SRF, this is recommended to use.
 *
 * @return current value of VSP2_VRS_CNT.VSP2_VRSR_B4_SRF
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__GET(void)
{
    uint32_t reg = COMMON_VSP2_VRS_CNT__GET();
    reg = (reg & COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__Msk);
    reg = (reg >> COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__EXTRACT() extracts VSP2_VRS_CNT.VSP2_VRSR_B4_SRF.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_VRS_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_VRS_CNT
 * @return current value of VSP2_VRS_CNT.VSP2_VRSR_B4_SRF
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__Msk);
    reg = (reg >> COMMON_VSP2_VRS_CNT__VSP2_VRSR_B4_SRF__Pos);
    return (uint32_t)reg;
}

/* ------------------ COMMON.VSP2_VRS_CNT.VSP2_SRR_B4_VRSF ------------------ */

/**
<pre>
  COMMON.VSP2_VRS_CNT.VSP2_SRR_B4_VRSF:

    Status flag indicating BVRSEN detected SR FET rising edge before VRS Comp falling edge (i.e., no dead time on PWM falling edge) on previous cycle.
    <start table>
    0 "SR FET rising edge after VRS Comp falling edge"
    1 "SR FET rising edge before VRS Comp falling edge"
    <end table>

</pre> */

#define COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__Pos              22                                                                     /*!< Right-most bit position of vsp2_srr_b4_vrsf in COMMON.VSP2_VRS_CNT */
#define COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__Msk              (0x00000001UL << COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__Pos)           /*!< Mask for vsp2_srr_b4_vrsf in COMMON.VSP2_VRS_CNT */
#define COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__Shift(v)         (((v) << COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__Pos) & COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__Msk) /*!< Shift value 'v' into vsp2_srr_b4_vrsf and mask 'v' to fit it into vsp2_srr_b4_vrsf field */

/** COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__GET() gets VSP2_VRS_CNT.VSP2_SRR_B4_VRSF's current value.
 *
 * When reading from VSP2_VRS_CNT.VSP2_SRR_B4_VRSF, this is recommended to use.
 *
 * @return current value of VSP2_VRS_CNT.VSP2_SRR_B4_VRSF
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__GET(void)
{
    uint32_t reg = COMMON_VSP2_VRS_CNT__GET();
    reg = (reg & COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__Msk);
    reg = (reg >> COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__EXTRACT() extracts VSP2_VRS_CNT.VSP2_SRR_B4_VRSF.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_VRS_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_VRS_CNT
 * @return current value of VSP2_VRS_CNT.VSP2_SRR_B4_VRSF
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__Msk);
    reg = (reg >> COMMON_VSP2_VRS_CNT__VSP2_SRR_B4_VRSF__Pos);
    return (uint32_t)reg;
}

/* ----------------- COMMON.VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_O ----------------- */

/**
<pre>
  COMMON.VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_O:

    Non-averaged BVRSEN VRS Comp pulse width measurement result for the odd half cycle of bridge topologies.
    LSB = 5ns, Range = 0 to 1025ns

</pre> */

#define COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__Pos            11                                                                     /*!< Right-most bit position of vsp2_cnt_vrscomp_o in COMMON.VSP2_VRS_CNT */
#define COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__Msk            (0x000007FFUL << COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__Pos)         /*!< Mask for vsp2_cnt_vrscomp_o in COMMON.VSP2_VRS_CNT */
#define COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__Shift(v)       (((v) << COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__Pos) & COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__Msk) /*!< Shift value 'v' into vsp2_cnt_vrscomp_o and mask 'v' to fit it into vsp2_cnt_vrscomp_o field */

/** COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__GET() gets VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_O's current value.
 *
 * When reading from VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_O, this is recommended to use.
 *
 * @return current value of VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_O
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__GET(void)
{
    uint32_t reg = COMMON_VSP2_VRS_CNT__GET();
    reg = (reg & COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__Msk);
    reg = (reg >> COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__EXTRACT() extracts VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_O.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_VRS_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_VRS_CNT
 * @return current value of VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_O
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__Msk);
    reg = (reg >> COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_O__Pos);
    return (uint32_t)reg;
}

/* ----------------- COMMON.VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_E ----------------- */

/**
<pre>
  COMMON.VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_E:

    Non-averaged BVRSEN VRS Comp pulse width measurement result for ACF topology or the even half cycle of bridge topologies.
    LSB = 5ns, Range = 0 to 1025ns

</pre> */

#define COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__Pos            0                                                                      /*!< Right-most bit position of vsp2_cnt_vrscomp_e in COMMON.VSP2_VRS_CNT */
#define COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__Msk            (0x000007FFUL << COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__Pos)         /*!< Mask for vsp2_cnt_vrscomp_e in COMMON.VSP2_VRS_CNT */
#define COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__Shift(v)       (((v) << COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__Pos) & COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__Msk) /*!< Shift value 'v' into vsp2_cnt_vrscomp_e and mask 'v' to fit it into vsp2_cnt_vrscomp_e field */

/** COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__GET() gets VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_E's current value.
 *
 * When reading from VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_E, this is recommended to use.
 *
 * @return current value of VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_E
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__GET(void)
{
    uint32_t reg = COMMON_VSP2_VRS_CNT__GET();
    reg = (reg & COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__Msk);
    reg = (reg >> COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__Pos);
    return (uint32_t)reg;
}

/** COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__EXTRACT() extracts VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_E.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VSP2_VRS_CNT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VSP2_VRS_CNT
 * @return current value of VSP2_VRS_CNT.VSP2_CNT_VRSCOMP_E
 */
__COMMON_INLINE uint32_t COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__Msk);
    reg = (reg >> COMMON_VSP2_VRS_CNT__VSP2_CNT_VRSCOMP_E__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        FSW_IRQ0 member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_FSW_IRQ0__ADDRESS returns the address of member FSW_IRQ0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FSW_IRQ0
 */
__COMMON_INLINE uint32_t* __COMMON_FSW_IRQ0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, FSW_IRQ0)));
}

/** COMMON_FSW_IRQ0__SET() sets FSW_IRQ0 to given value.
 *
 * When writing to FSW_IRQ0, this is mandatory to use.
 *
 * @param value new value for FSW_IRQ0
 */
__COMMON_INLINE void COMMON_FSW_IRQ0__SET(uint32_t value)
{
    HAL_SET32(__COMMON_FSW_IRQ0__ADDRESS(), value);
}

/** COMMON_FSW_IRQ0__GET() gets FSW_IRQ0's current value.
 *
 * When reading from FSW_IRQ0, this is mandatory to use.
 *
 * @return current value of FSW_IRQ0
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__GET(void)
{
    return HAL_GET32(__COMMON_FSW_IRQ0__ADDRESS());
}

/* --------------------- COMMON.FSW_IRQ0.FSW0_IRQ7_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ0.FSW0_IRQ7_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch0.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc0_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Pos                     28                                                                     /*!< Right-most bit position of fsw0_irq7_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Pos)                  /*!< Mask for fsw0_irq7_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Pos) & COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Msk) /*!< Shift value 'v' into fsw0_irq7_sel and mask 'v' to fit it into fsw0_irq7_sel field */

/** COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__SET() sets FSW_IRQ0.FSW0_IRQ7_SEL to given value.
 *
 * When writing to FSW_IRQ0.FSW0_IRQ7_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ7_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ0__SET(reg);
}

/** COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__GET() gets FSW_IRQ0.FSW0_IRQ7_SEL's current value.
 *
 * When reading from FSW_IRQ0.FSW0_IRQ7_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ0.FSW0_IRQ7_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__MODIFY() modifies FSW_IRQ0.FSW0_IRQ7_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ7_SEL
 * @return new value of COMMON.FSW_IRQ0
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__EXTRACT() extracts FSW_IRQ0.FSW0_IRQ7_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @return current value of FSW_IRQ0.FSW0_IRQ7_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ7_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ0.FSW0_IRQ6_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ0.FSW0_IRQ6_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch0.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc0_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Pos                     24                                                                     /*!< Right-most bit position of fsw0_irq6_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Pos)                  /*!< Mask for fsw0_irq6_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Pos) & COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Msk) /*!< Shift value 'v' into fsw0_irq6_sel and mask 'v' to fit it into fsw0_irq6_sel field */

/** COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__SET() sets FSW_IRQ0.FSW0_IRQ6_SEL to given value.
 *
 * When writing to FSW_IRQ0.FSW0_IRQ6_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ6_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ0__SET(reg);
}

/** COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__GET() gets FSW_IRQ0.FSW0_IRQ6_SEL's current value.
 *
 * When reading from FSW_IRQ0.FSW0_IRQ6_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ0.FSW0_IRQ6_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__MODIFY() modifies FSW_IRQ0.FSW0_IRQ6_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ6_SEL
 * @return new value of COMMON.FSW_IRQ0
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__EXTRACT() extracts FSW_IRQ0.FSW0_IRQ6_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @return current value of FSW_IRQ0.FSW0_IRQ6_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ6_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ0.FSW0_IRQ5_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ0.FSW0_IRQ5_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch0.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc0_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Pos                     20                                                                     /*!< Right-most bit position of fsw0_irq5_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Pos)                  /*!< Mask for fsw0_irq5_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Pos) & COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Msk) /*!< Shift value 'v' into fsw0_irq5_sel and mask 'v' to fit it into fsw0_irq5_sel field */

/** COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__SET() sets FSW_IRQ0.FSW0_IRQ5_SEL to given value.
 *
 * When writing to FSW_IRQ0.FSW0_IRQ5_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ5_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ0__SET(reg);
}

/** COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__GET() gets FSW_IRQ0.FSW0_IRQ5_SEL's current value.
 *
 * When reading from FSW_IRQ0.FSW0_IRQ5_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ0.FSW0_IRQ5_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__MODIFY() modifies FSW_IRQ0.FSW0_IRQ5_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ5_SEL
 * @return new value of COMMON.FSW_IRQ0
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__EXTRACT() extracts FSW_IRQ0.FSW0_IRQ5_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @return current value of FSW_IRQ0.FSW0_IRQ5_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ5_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ0.FSW0_IRQ4_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ0.FSW0_IRQ4_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch0.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc0_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Pos                     16                                                                     /*!< Right-most bit position of fsw0_irq4_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Pos)                  /*!< Mask for fsw0_irq4_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Pos) & COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Msk) /*!< Shift value 'v' into fsw0_irq4_sel and mask 'v' to fit it into fsw0_irq4_sel field */

/** COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__SET() sets FSW_IRQ0.FSW0_IRQ4_SEL to given value.
 *
 * When writing to FSW_IRQ0.FSW0_IRQ4_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ4_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ0__SET(reg);
}

/** COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__GET() gets FSW_IRQ0.FSW0_IRQ4_SEL's current value.
 *
 * When reading from FSW_IRQ0.FSW0_IRQ4_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ0.FSW0_IRQ4_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__MODIFY() modifies FSW_IRQ0.FSW0_IRQ4_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ4_SEL
 * @return new value of COMMON.FSW_IRQ0
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__EXTRACT() extracts FSW_IRQ0.FSW0_IRQ4_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @return current value of FSW_IRQ0.FSW0_IRQ4_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ4_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ0.FSW0_IRQ3_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ0.FSW0_IRQ3_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch0.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc0_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Pos                     12                                                                     /*!< Right-most bit position of fsw0_irq3_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Pos)                  /*!< Mask for fsw0_irq3_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Pos) & COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Msk) /*!< Shift value 'v' into fsw0_irq3_sel and mask 'v' to fit it into fsw0_irq3_sel field */

/** COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__SET() sets FSW_IRQ0.FSW0_IRQ3_SEL to given value.
 *
 * When writing to FSW_IRQ0.FSW0_IRQ3_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ3_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ0__SET(reg);
}

/** COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__GET() gets FSW_IRQ0.FSW0_IRQ3_SEL's current value.
 *
 * When reading from FSW_IRQ0.FSW0_IRQ3_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ0.FSW0_IRQ3_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__MODIFY() modifies FSW_IRQ0.FSW0_IRQ3_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ3_SEL
 * @return new value of COMMON.FSW_IRQ0
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__EXTRACT() extracts FSW_IRQ0.FSW0_IRQ3_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @return current value of FSW_IRQ0.FSW0_IRQ3_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ3_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ0.FSW0_IRQ2_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ0.FSW0_IRQ2_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch0.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc0_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Pos                     8                                                                      /*!< Right-most bit position of fsw0_irq2_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Pos)                  /*!< Mask for fsw0_irq2_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Pos) & COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Msk) /*!< Shift value 'v' into fsw0_irq2_sel and mask 'v' to fit it into fsw0_irq2_sel field */

/** COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__SET() sets FSW_IRQ0.FSW0_IRQ2_SEL to given value.
 *
 * When writing to FSW_IRQ0.FSW0_IRQ2_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ2_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ0__SET(reg);
}

/** COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__GET() gets FSW_IRQ0.FSW0_IRQ2_SEL's current value.
 *
 * When reading from FSW_IRQ0.FSW0_IRQ2_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ0.FSW0_IRQ2_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__MODIFY() modifies FSW_IRQ0.FSW0_IRQ2_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ2_SEL
 * @return new value of COMMON.FSW_IRQ0
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__EXTRACT() extracts FSW_IRQ0.FSW0_IRQ2_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @return current value of FSW_IRQ0.FSW0_IRQ2_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ2_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ0.FSW0_IRQ1_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ0.FSW0_IRQ1_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch0.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc0_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Pos                     4                                                                      /*!< Right-most bit position of fsw0_irq1_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Pos)                  /*!< Mask for fsw0_irq1_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Pos) & COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Msk) /*!< Shift value 'v' into fsw0_irq1_sel and mask 'v' to fit it into fsw0_irq1_sel field */

/** COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__SET() sets FSW_IRQ0.FSW0_IRQ1_SEL to given value.
 *
 * When writing to FSW_IRQ0.FSW0_IRQ1_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ1_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ0__SET(reg);
}

/** COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__GET() gets FSW_IRQ0.FSW0_IRQ1_SEL's current value.
 *
 * When reading from FSW_IRQ0.FSW0_IRQ1_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ0.FSW0_IRQ1_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__MODIFY() modifies FSW_IRQ0.FSW0_IRQ1_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ1_SEL
 * @return new value of COMMON.FSW_IRQ0
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__EXTRACT() extracts FSW_IRQ0.FSW0_IRQ1_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @return current value of FSW_IRQ0.FSW0_IRQ1_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ1_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ0.FSW0_IRQ0_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ0.FSW0_IRQ0_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch0.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc0_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Pos                     0                                                                      /*!< Right-most bit position of fsw0_irq0_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Pos)                  /*!< Mask for fsw0_irq0_sel in COMMON.FSW_IRQ0 */
#define COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Pos) & COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Msk) /*!< Shift value 'v' into fsw0_irq0_sel and mask 'v' to fit it into fsw0_irq0_sel field */

/** COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__SET() sets FSW_IRQ0.FSW0_IRQ0_SEL to given value.
 *
 * When writing to FSW_IRQ0.FSW0_IRQ0_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ0_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ0__SET(reg);
}

/** COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__GET() gets FSW_IRQ0.FSW0_IRQ0_SEL's current value.
 *
 * When reading from FSW_IRQ0.FSW0_IRQ0_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ0.FSW0_IRQ0_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ0__GET();
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__MODIFY() modifies FSW_IRQ0.FSW0_IRQ0_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @param bf_value new value for FSW_IRQ0.FSW0_IRQ0_SEL
 * @return new value of COMMON.FSW_IRQ0
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__EXTRACT() extracts FSW_IRQ0.FSW0_IRQ0_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ0
 * @return current value of FSW_IRQ0.FSW0_IRQ0_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ0__FSW0_IRQ0_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        FSW_IRQ1 member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_FSW_IRQ1__ADDRESS returns the address of member FSW_IRQ1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FSW_IRQ1
 */
__COMMON_INLINE uint32_t* __COMMON_FSW_IRQ1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, FSW_IRQ1)));
}

/** COMMON_FSW_IRQ1__SET() sets FSW_IRQ1 to given value.
 *
 * When writing to FSW_IRQ1, this is mandatory to use.
 *
 * @param value new value for FSW_IRQ1
 */
__COMMON_INLINE void COMMON_FSW_IRQ1__SET(uint32_t value)
{
    HAL_SET32(__COMMON_FSW_IRQ1__ADDRESS(), value);
}

/** COMMON_FSW_IRQ1__GET() gets FSW_IRQ1's current value.
 *
 * When reading from FSW_IRQ1, this is mandatory to use.
 *
 * @return current value of FSW_IRQ1
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__GET(void)
{
    return HAL_GET32(__COMMON_FSW_IRQ1__ADDRESS());
}

/* --------------------- COMMON.FSW_IRQ1.FSW1_IRQ7_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ1.FSW1_IRQ7_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch1.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc1_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Pos                     28                                                                     /*!< Right-most bit position of fsw1_irq7_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Pos)                  /*!< Mask for fsw1_irq7_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Pos) & COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Msk) /*!< Shift value 'v' into fsw1_irq7_sel and mask 'v' to fit it into fsw1_irq7_sel field */

/** COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__SET() sets FSW_IRQ1.FSW1_IRQ7_SEL to given value.
 *
 * When writing to FSW_IRQ1.FSW1_IRQ7_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ7_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ1__SET(reg);
}

/** COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__GET() gets FSW_IRQ1.FSW1_IRQ7_SEL's current value.
 *
 * When reading from FSW_IRQ1.FSW1_IRQ7_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ1.FSW1_IRQ7_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__MODIFY() modifies FSW_IRQ1.FSW1_IRQ7_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ7_SEL
 * @return new value of COMMON.FSW_IRQ1
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__EXTRACT() extracts FSW_IRQ1.FSW1_IRQ7_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @return current value of FSW_IRQ1.FSW1_IRQ7_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ7_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ1.FSW1_IRQ6_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ1.FSW1_IRQ6_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch1.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc1_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Pos                     24                                                                     /*!< Right-most bit position of fsw1_irq6_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Pos)                  /*!< Mask for fsw1_irq6_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Pos) & COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Msk) /*!< Shift value 'v' into fsw1_irq6_sel and mask 'v' to fit it into fsw1_irq6_sel field */

/** COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__SET() sets FSW_IRQ1.FSW1_IRQ6_SEL to given value.
 *
 * When writing to FSW_IRQ1.FSW1_IRQ6_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ6_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ1__SET(reg);
}

/** COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__GET() gets FSW_IRQ1.FSW1_IRQ6_SEL's current value.
 *
 * When reading from FSW_IRQ1.FSW1_IRQ6_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ1.FSW1_IRQ6_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__MODIFY() modifies FSW_IRQ1.FSW1_IRQ6_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ6_SEL
 * @return new value of COMMON.FSW_IRQ1
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__EXTRACT() extracts FSW_IRQ1.FSW1_IRQ6_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @return current value of FSW_IRQ1.FSW1_IRQ6_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ6_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ1.FSW1_IRQ5_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ1.FSW1_IRQ5_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch1.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc1_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Pos                     20                                                                     /*!< Right-most bit position of fsw1_irq5_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Pos)                  /*!< Mask for fsw1_irq5_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Pos) & COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Msk) /*!< Shift value 'v' into fsw1_irq5_sel and mask 'v' to fit it into fsw1_irq5_sel field */

/** COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__SET() sets FSW_IRQ1.FSW1_IRQ5_SEL to given value.
 *
 * When writing to FSW_IRQ1.FSW1_IRQ5_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ5_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ1__SET(reg);
}

/** COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__GET() gets FSW_IRQ1.FSW1_IRQ5_SEL's current value.
 *
 * When reading from FSW_IRQ1.FSW1_IRQ5_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ1.FSW1_IRQ5_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__MODIFY() modifies FSW_IRQ1.FSW1_IRQ5_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ5_SEL
 * @return new value of COMMON.FSW_IRQ1
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__EXTRACT() extracts FSW_IRQ1.FSW1_IRQ5_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @return current value of FSW_IRQ1.FSW1_IRQ5_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ5_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ1.FSW1_IRQ4_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ1.FSW1_IRQ4_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch1.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc1_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Pos                     16                                                                     /*!< Right-most bit position of fsw1_irq4_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Pos)                  /*!< Mask for fsw1_irq4_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Pos) & COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Msk) /*!< Shift value 'v' into fsw1_irq4_sel and mask 'v' to fit it into fsw1_irq4_sel field */

/** COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__SET() sets FSW_IRQ1.FSW1_IRQ4_SEL to given value.
 *
 * When writing to FSW_IRQ1.FSW1_IRQ4_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ4_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ1__SET(reg);
}

/** COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__GET() gets FSW_IRQ1.FSW1_IRQ4_SEL's current value.
 *
 * When reading from FSW_IRQ1.FSW1_IRQ4_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ1.FSW1_IRQ4_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__MODIFY() modifies FSW_IRQ1.FSW1_IRQ4_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ4_SEL
 * @return new value of COMMON.FSW_IRQ1
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__EXTRACT() extracts FSW_IRQ1.FSW1_IRQ4_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @return current value of FSW_IRQ1.FSW1_IRQ4_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ4_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ1.FSW1_IRQ3_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ1.FSW1_IRQ3_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch1.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc1_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Pos                     12                                                                     /*!< Right-most bit position of fsw1_irq3_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Pos)                  /*!< Mask for fsw1_irq3_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Pos) & COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Msk) /*!< Shift value 'v' into fsw1_irq3_sel and mask 'v' to fit it into fsw1_irq3_sel field */

/** COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__SET() sets FSW_IRQ1.FSW1_IRQ3_SEL to given value.
 *
 * When writing to FSW_IRQ1.FSW1_IRQ3_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ3_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ1__SET(reg);
}

/** COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__GET() gets FSW_IRQ1.FSW1_IRQ3_SEL's current value.
 *
 * When reading from FSW_IRQ1.FSW1_IRQ3_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ1.FSW1_IRQ3_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__MODIFY() modifies FSW_IRQ1.FSW1_IRQ3_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ3_SEL
 * @return new value of COMMON.FSW_IRQ1
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__EXTRACT() extracts FSW_IRQ1.FSW1_IRQ3_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @return current value of FSW_IRQ1.FSW1_IRQ3_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ3_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ1.FSW1_IRQ2_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ1.FSW1_IRQ2_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch1.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc1_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Pos                     8                                                                      /*!< Right-most bit position of fsw1_irq2_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Pos)                  /*!< Mask for fsw1_irq2_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Pos) & COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Msk) /*!< Shift value 'v' into fsw1_irq2_sel and mask 'v' to fit it into fsw1_irq2_sel field */

/** COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__SET() sets FSW_IRQ1.FSW1_IRQ2_SEL to given value.
 *
 * When writing to FSW_IRQ1.FSW1_IRQ2_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ2_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ1__SET(reg);
}

/** COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__GET() gets FSW_IRQ1.FSW1_IRQ2_SEL's current value.
 *
 * When reading from FSW_IRQ1.FSW1_IRQ2_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ1.FSW1_IRQ2_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__MODIFY() modifies FSW_IRQ1.FSW1_IRQ2_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ2_SEL
 * @return new value of COMMON.FSW_IRQ1
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__EXTRACT() extracts FSW_IRQ1.FSW1_IRQ2_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @return current value of FSW_IRQ1.FSW1_IRQ2_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ2_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ1.FSW1_IRQ1_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ1.FSW1_IRQ1_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch1.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc1_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Pos                     4                                                                      /*!< Right-most bit position of fsw1_irq1_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Pos)                  /*!< Mask for fsw1_irq1_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Pos) & COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Msk) /*!< Shift value 'v' into fsw1_irq1_sel and mask 'v' to fit it into fsw1_irq1_sel field */

/** COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__SET() sets FSW_IRQ1.FSW1_IRQ1_SEL to given value.
 *
 * When writing to FSW_IRQ1.FSW1_IRQ1_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ1_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ1__SET(reg);
}

/** COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__GET() gets FSW_IRQ1.FSW1_IRQ1_SEL's current value.
 *
 * When reading from FSW_IRQ1.FSW1_IRQ1_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ1.FSW1_IRQ1_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__MODIFY() modifies FSW_IRQ1.FSW1_IRQ1_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ1_SEL
 * @return new value of COMMON.FSW_IRQ1
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__EXTRACT() extracts FSW_IRQ1.FSW1_IRQ1_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @return current value of FSW_IRQ1.FSW1_IRQ1_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ1_SEL__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.FSW_IRQ1.FSW1_IRQ0_SEL --------------------- */

/**
<pre>
  COMMON.FSW_IRQ1.FSW1_IRQ0_SEL:

    Defines the Fswitch based interrupt rate in number of switching periods, tswitch1.  Bit [3] controls when the IRQ's occur.  If 0, IRQ's only occur in active regulation (vc1_vramp_on=1), otherwise IRQ's are continuous and independent of regulation.
    <start table_with_header>
    [2:0] "IRQ Rate" "[2:0]" "IRQ Rate"
    0 "disabled" "4" "8 Tswitch"
    1 "1 Tswitch" "5" "16 Tswitch"
    2 "2 Tswitch" "6" "32 Tswitch"
    3 "4 Tswitch" "7" "64 Tswitch"
    <end table>

</pre> */

#define COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Pos                     0                                                                      /*!< Right-most bit position of fsw1_irq0_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Msk                     (0x0000000FUL << COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Pos)                  /*!< Mask for fsw1_irq0_sel in COMMON.FSW_IRQ1 */
#define COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Shift(v)                (((v) << COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Pos) & COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Msk) /*!< Shift value 'v' into fsw1_irq0_sel and mask 'v' to fit it into fsw1_irq0_sel field */

/** COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__SET() sets FSW_IRQ1.FSW1_IRQ0_SEL to given value.
 *
 * When writing to FSW_IRQ1.FSW1_IRQ0_SEL, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ0_SEL
 */
__COMMON_INLINE void COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Shift((uint32_t)bf_value)));
    COMMON_FSW_IRQ1__SET(reg);
}

/** COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__GET() gets FSW_IRQ1.FSW1_IRQ0_SEL's current value.
 *
 * When reading from FSW_IRQ1.FSW1_IRQ0_SEL, this is recommended to use.
 *
 * @return current value of FSW_IRQ1.FSW1_IRQ0_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__GET(void)
{
    uint32_t reg = COMMON_FSW_IRQ1__GET();
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__MODIFY() modifies FSW_IRQ1.FSW1_IRQ0_SEL.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @param bf_value new value for FSW_IRQ1.FSW1_IRQ0_SEL
 * @return new value of COMMON.FSW_IRQ1
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Msk);
    reg = (reg | (COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__EXTRACT() extracts FSW_IRQ1.FSW1_IRQ0_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ1
 * @return current value of FSW_IRQ1.FSW1_IRQ0_SEL
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Msk);
    reg = (reg >> COMMON_FSW_IRQ1__FSW1_IRQ0_SEL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         IBAL_FW member of COMMON_t                         */
/* -------------------------------------------------------------------------- */

/** __COMMON_IBAL_FW__ADDRESS returns the address of member IBAL_FW.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IBAL_FW
 */
__COMMON_INLINE uint32_t* __COMMON_IBAL_FW__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, IBAL_FW)));
}

/** COMMON_IBAL_FW__SET() sets IBAL_FW to given value.
 *
 * When writing to IBAL_FW, this is mandatory to use.
 *
 * @param value new value for IBAL_FW
 */
__COMMON_INLINE void COMMON_IBAL_FW__SET(uint32_t value)
{
    HAL_SET32(__COMMON_IBAL_FW__ADDRESS(), value);
}

/** COMMON_IBAL_FW__GET() gets IBAL_FW's current value.
 *
 * When reading from IBAL_FW, this is mandatory to use.
 *
 * @return current value of IBAL_FW
 */
__COMMON_INLINE uint32_t COMMON_IBAL_FW__GET(void)
{
    return HAL_GET32(__COMMON_IBAL_FW__ADDRESS());
}

/* ----------------------- COMMON.IBAL_FW.IBAL_FW_EN ----------------------- */

/**
<pre>
  COMMON.IBAL_FW.IBAL_FW_EN:

    Enables FW controlled current balance loop via ibal_fw_adj.
    <start table>
    0 "use HW computed current balance adjust"
    1 "use ibal_fw_adj"
    <end table>

</pre> */

#define COMMON_IBAL_FW__IBAL_FW_EN__Pos                         8                                                                      /*!< Right-most bit position of ibal_fw_en in COMMON.IBAL_FW */
#define COMMON_IBAL_FW__IBAL_FW_EN__Msk                         (0x00000001UL << COMMON_IBAL_FW__IBAL_FW_EN__Pos)                      /*!< Mask for ibal_fw_en in COMMON.IBAL_FW */
#define COMMON_IBAL_FW__IBAL_FW_EN__Shift(v)                    (((v) << COMMON_IBAL_FW__IBAL_FW_EN__Pos) & COMMON_IBAL_FW__IBAL_FW_EN__Msk) /*!< Shift value 'v' into ibal_fw_en and mask 'v' to fit it into ibal_fw_en field */

/** COMMON_IBAL_FW__IBAL_FW_EN__SET() sets IBAL_FW.IBAL_FW_EN to given value.
 *
 * When writing to IBAL_FW.IBAL_FW_EN, this is recommended to use.
 *
 * @param bf_value new value for IBAL_FW.IBAL_FW_EN
 */
__COMMON_INLINE void COMMON_IBAL_FW__IBAL_FW_EN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_IBAL_FW__GET();
    reg = (reg & ~COMMON_IBAL_FW__IBAL_FW_EN__Msk);
    reg = (reg | (COMMON_IBAL_FW__IBAL_FW_EN__Shift((uint32_t)bf_value)));
    COMMON_IBAL_FW__SET(reg);
}

/** COMMON_IBAL_FW__IBAL_FW_EN__GET() gets IBAL_FW.IBAL_FW_EN's current value.
 *
 * When reading from IBAL_FW.IBAL_FW_EN, this is recommended to use.
 *
 * @return current value of IBAL_FW.IBAL_FW_EN
 */
__COMMON_INLINE uint32_t COMMON_IBAL_FW__IBAL_FW_EN__GET(void)
{
    uint32_t reg = COMMON_IBAL_FW__GET();
    reg = (reg & COMMON_IBAL_FW__IBAL_FW_EN__Msk);
    reg = (reg >> COMMON_IBAL_FW__IBAL_FW_EN__Pos);
    return (uint32_t)reg;
}

/** COMMON_IBAL_FW__IBAL_FW_EN__MODIFY() modifies IBAL_FW.IBAL_FW_EN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.IBAL_FW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.IBAL_FW
 * @param bf_value new value for IBAL_FW.IBAL_FW_EN
 * @return new value of COMMON.IBAL_FW
 */
__COMMON_INLINE uint32_t COMMON_IBAL_FW__IBAL_FW_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_IBAL_FW__IBAL_FW_EN__Msk);
    reg = (reg | (COMMON_IBAL_FW__IBAL_FW_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_IBAL_FW__IBAL_FW_EN__EXTRACT() extracts IBAL_FW.IBAL_FW_EN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.IBAL_FW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.IBAL_FW
 * @return current value of IBAL_FW.IBAL_FW_EN
 */
__COMMON_INLINE uint32_t COMMON_IBAL_FW__IBAL_FW_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_IBAL_FW__IBAL_FW_EN__Msk);
    reg = (reg >> COMMON_IBAL_FW__IBAL_FW_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.IBAL_FW.IBAL_FW_ADJ ----------------------- */

/**
<pre>
  COMMON.IBAL_FW.IBAL_FW_ADJ:

    When ibal_fw_en is high, this register overrides the HW current balance duty cycle adjust output with a FW controlled setting.
    LSB = 0.195 %, Range = 0.0 to 24.805%

</pre> */

#define COMMON_IBAL_FW__IBAL_FW_ADJ__Pos                        0                                                                      /*!< Right-most bit position of ibal_fw_adj in COMMON.IBAL_FW */
#define COMMON_IBAL_FW__IBAL_FW_ADJ__Msk                        (0x000000FFUL << COMMON_IBAL_FW__IBAL_FW_ADJ__Pos)                     /*!< Mask for ibal_fw_adj in COMMON.IBAL_FW */
#define COMMON_IBAL_FW__IBAL_FW_ADJ__Shift(v)                   (((v) << COMMON_IBAL_FW__IBAL_FW_ADJ__Pos) & COMMON_IBAL_FW__IBAL_FW_ADJ__Msk) /*!< Shift value 'v' into ibal_fw_adj and mask 'v' to fit it into ibal_fw_adj field */

/** COMMON_IBAL_FW__IBAL_FW_ADJ__SET() sets IBAL_FW.IBAL_FW_ADJ to given value.
 *
 * When writing to IBAL_FW.IBAL_FW_ADJ, this is recommended to use.
 *
 * @param bf_value new value for IBAL_FW.IBAL_FW_ADJ
 */
__COMMON_INLINE void COMMON_IBAL_FW__IBAL_FW_ADJ__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_IBAL_FW__GET();
    reg = (reg & ~COMMON_IBAL_FW__IBAL_FW_ADJ__Msk);
    reg = (reg | (COMMON_IBAL_FW__IBAL_FW_ADJ__Shift((uint32_t)bf_value)));
    COMMON_IBAL_FW__SET(reg);
}

/** COMMON_IBAL_FW__IBAL_FW_ADJ__GET() gets IBAL_FW.IBAL_FW_ADJ's current value.
 *
 * When reading from IBAL_FW.IBAL_FW_ADJ, this is recommended to use.
 *
 * @return current value of IBAL_FW.IBAL_FW_ADJ
 */
__COMMON_INLINE uint32_t COMMON_IBAL_FW__IBAL_FW_ADJ__GET(void)
{
    uint32_t reg = COMMON_IBAL_FW__GET();
    reg = (reg & COMMON_IBAL_FW__IBAL_FW_ADJ__Msk);
    reg = (reg >> COMMON_IBAL_FW__IBAL_FW_ADJ__Pos);
    return (uint32_t)reg;
}

/** COMMON_IBAL_FW__IBAL_FW_ADJ__MODIFY() modifies IBAL_FW.IBAL_FW_ADJ.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.IBAL_FW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.IBAL_FW
 * @param bf_value new value for IBAL_FW.IBAL_FW_ADJ
 * @return new value of COMMON.IBAL_FW
 */
__COMMON_INLINE uint32_t COMMON_IBAL_FW__IBAL_FW_ADJ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_IBAL_FW__IBAL_FW_ADJ__Msk);
    reg = (reg | (COMMON_IBAL_FW__IBAL_FW_ADJ__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_IBAL_FW__IBAL_FW_ADJ__EXTRACT() extracts IBAL_FW.IBAL_FW_ADJ.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.IBAL_FW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.IBAL_FW
 * @return current value of IBAL_FW.IBAL_FW_ADJ
 */
__COMMON_INLINE uint32_t COMMON_IBAL_FW__IBAL_FW_ADJ__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_IBAL_FW__IBAL_FW_ADJ__Msk);
    reg = (reg >> COMMON_IBAL_FW__IBAL_FW_ADJ__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        FBAL1_FW member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_FBAL1_FW__ADDRESS returns the address of member FBAL1_FW.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FBAL1_FW
 */
__COMMON_INLINE uint32_t* __COMMON_FBAL1_FW__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, FBAL1_FW)));
}

/** COMMON_FBAL1_FW__SET() sets FBAL1_FW to given value.
 *
 * When writing to FBAL1_FW, this is mandatory to use.
 *
 * @param value new value for FBAL1_FW
 */
__COMMON_INLINE void COMMON_FBAL1_FW__SET(uint32_t value)
{
    HAL_SET32(__COMMON_FBAL1_FW__ADDRESS(), value);
}

/** COMMON_FBAL1_FW__GET() gets FBAL1_FW's current value.
 *
 * When reading from FBAL1_FW, this is mandatory to use.
 *
 * @return current value of FBAL1_FW
 */
__COMMON_INLINE uint32_t COMMON_FBAL1_FW__GET(void)
{
    return HAL_GET32(__COMMON_FBAL1_FW__ADDRESS());
}

/* ---------------------- COMMON.FBAL1_FW.FBAL1_FW_EN ---------------------- */

/**
<pre>
  COMMON.FBAL1_FW.FBAL1_FW_EN:

    Enables FW controlled flux / voltage balance loop via fbal1_fw_adj.
    <start table>
    0 "use HW computed flux / voltage balance adjust"
    1 "use fbal1_fw_adj"
    <end table>

</pre> */

#define COMMON_FBAL1_FW__FBAL1_FW_EN__Pos                       8                                                                      /*!< Right-most bit position of fbal1_fw_en in COMMON.FBAL1_FW */
#define COMMON_FBAL1_FW__FBAL1_FW_EN__Msk                       (0x00000001UL << COMMON_FBAL1_FW__FBAL1_FW_EN__Pos)                    /*!< Mask for fbal1_fw_en in COMMON.FBAL1_FW */
#define COMMON_FBAL1_FW__FBAL1_FW_EN__Shift(v)                  (((v) << COMMON_FBAL1_FW__FBAL1_FW_EN__Pos) & COMMON_FBAL1_FW__FBAL1_FW_EN__Msk) /*!< Shift value 'v' into fbal1_fw_en and mask 'v' to fit it into fbal1_fw_en field */

/** COMMON_FBAL1_FW__FBAL1_FW_EN__SET() sets FBAL1_FW.FBAL1_FW_EN to given value.
 *
 * When writing to FBAL1_FW.FBAL1_FW_EN, this is recommended to use.
 *
 * @param bf_value new value for FBAL1_FW.FBAL1_FW_EN
 */
__COMMON_INLINE void COMMON_FBAL1_FW__FBAL1_FW_EN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL1_FW__GET();
    reg = (reg & ~COMMON_FBAL1_FW__FBAL1_FW_EN__Msk);
    reg = (reg | (COMMON_FBAL1_FW__FBAL1_FW_EN__Shift((uint32_t)bf_value)));
    COMMON_FBAL1_FW__SET(reg);
}

/** COMMON_FBAL1_FW__FBAL1_FW_EN__GET() gets FBAL1_FW.FBAL1_FW_EN's current value.
 *
 * When reading from FBAL1_FW.FBAL1_FW_EN, this is recommended to use.
 *
 * @return current value of FBAL1_FW.FBAL1_FW_EN
 */
__COMMON_INLINE uint32_t COMMON_FBAL1_FW__FBAL1_FW_EN__GET(void)
{
    uint32_t reg = COMMON_FBAL1_FW__GET();
    reg = (reg & COMMON_FBAL1_FW__FBAL1_FW_EN__Msk);
    reg = (reg >> COMMON_FBAL1_FW__FBAL1_FW_EN__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL1_FW__FBAL1_FW_EN__MODIFY() modifies FBAL1_FW.FBAL1_FW_EN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL1_FW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL1_FW
 * @param bf_value new value for FBAL1_FW.FBAL1_FW_EN
 * @return new value of COMMON.FBAL1_FW
 */
__COMMON_INLINE uint32_t COMMON_FBAL1_FW__FBAL1_FW_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL1_FW__FBAL1_FW_EN__Msk);
    reg = (reg | (COMMON_FBAL1_FW__FBAL1_FW_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL1_FW__FBAL1_FW_EN__EXTRACT() extracts FBAL1_FW.FBAL1_FW_EN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL1_FW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL1_FW
 * @return current value of FBAL1_FW.FBAL1_FW_EN
 */
__COMMON_INLINE uint32_t COMMON_FBAL1_FW__FBAL1_FW_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL1_FW__FBAL1_FW_EN__Msk);
    reg = (reg >> COMMON_FBAL1_FW__FBAL1_FW_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.FBAL1_FW.FBAL1_FW_ADJ ---------------------- */

/**
<pre>
  COMMON.FBAL1_FW.FBAL1_FW_ADJ:

    When fbal1_fw_en is high, this register overrides the Loop 0, Phase 1 HW flux / voltage balance duty cycle adjust output with a FW controlled setting.
    LSB = 0.195 %, Range = 0.0 to 24.805%

</pre> */

#define COMMON_FBAL1_FW__FBAL1_FW_ADJ__Pos                      0                                                                      /*!< Right-most bit position of fbal1_fw_adj in COMMON.FBAL1_FW */
#define COMMON_FBAL1_FW__FBAL1_FW_ADJ__Msk                      (0x000000FFUL << COMMON_FBAL1_FW__FBAL1_FW_ADJ__Pos)                   /*!< Mask for fbal1_fw_adj in COMMON.FBAL1_FW */
#define COMMON_FBAL1_FW__FBAL1_FW_ADJ__Shift(v)                 (((v) << COMMON_FBAL1_FW__FBAL1_FW_ADJ__Pos) & COMMON_FBAL1_FW__FBAL1_FW_ADJ__Msk) /*!< Shift value 'v' into fbal1_fw_adj and mask 'v' to fit it into fbal1_fw_adj field */

/** COMMON_FBAL1_FW__FBAL1_FW_ADJ__SET() sets FBAL1_FW.FBAL1_FW_ADJ to given value.
 *
 * When writing to FBAL1_FW.FBAL1_FW_ADJ, this is recommended to use.
 *
 * @param bf_value new value for FBAL1_FW.FBAL1_FW_ADJ
 */
__COMMON_INLINE void COMMON_FBAL1_FW__FBAL1_FW_ADJ__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL1_FW__GET();
    reg = (reg & ~COMMON_FBAL1_FW__FBAL1_FW_ADJ__Msk);
    reg = (reg | (COMMON_FBAL1_FW__FBAL1_FW_ADJ__Shift((uint32_t)bf_value)));
    COMMON_FBAL1_FW__SET(reg);
}

/** COMMON_FBAL1_FW__FBAL1_FW_ADJ__GET() gets FBAL1_FW.FBAL1_FW_ADJ's current value.
 *
 * When reading from FBAL1_FW.FBAL1_FW_ADJ, this is recommended to use.
 *
 * @return current value of FBAL1_FW.FBAL1_FW_ADJ
 */
__COMMON_INLINE uint32_t COMMON_FBAL1_FW__FBAL1_FW_ADJ__GET(void)
{
    uint32_t reg = COMMON_FBAL1_FW__GET();
    reg = (reg & COMMON_FBAL1_FW__FBAL1_FW_ADJ__Msk);
    reg = (reg >> COMMON_FBAL1_FW__FBAL1_FW_ADJ__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL1_FW__FBAL1_FW_ADJ__MODIFY() modifies FBAL1_FW.FBAL1_FW_ADJ.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL1_FW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL1_FW
 * @param bf_value new value for FBAL1_FW.FBAL1_FW_ADJ
 * @return new value of COMMON.FBAL1_FW
 */
__COMMON_INLINE uint32_t COMMON_FBAL1_FW__FBAL1_FW_ADJ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL1_FW__FBAL1_FW_ADJ__Msk);
    reg = (reg | (COMMON_FBAL1_FW__FBAL1_FW_ADJ__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL1_FW__FBAL1_FW_ADJ__EXTRACT() extracts FBAL1_FW.FBAL1_FW_ADJ.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL1_FW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL1_FW
 * @return current value of FBAL1_FW.FBAL1_FW_ADJ
 */
__COMMON_INLINE uint32_t COMMON_FBAL1_FW__FBAL1_FW_ADJ__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL1_FW__FBAL1_FW_ADJ__Msk);
    reg = (reg >> COMMON_FBAL1_FW__FBAL1_FW_ADJ__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        FBAL2_FW member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_FBAL2_FW__ADDRESS returns the address of member FBAL2_FW.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FBAL2_FW
 */
__COMMON_INLINE uint32_t* __COMMON_FBAL2_FW__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, FBAL2_FW)));
}

/** COMMON_FBAL2_FW__SET() sets FBAL2_FW to given value.
 *
 * When writing to FBAL2_FW, this is mandatory to use.
 *
 * @param value new value for FBAL2_FW
 */
__COMMON_INLINE void COMMON_FBAL2_FW__SET(uint32_t value)
{
    HAL_SET32(__COMMON_FBAL2_FW__ADDRESS(), value);
}

/** COMMON_FBAL2_FW__GET() gets FBAL2_FW's current value.
 *
 * When reading from FBAL2_FW, this is mandatory to use.
 *
 * @return current value of FBAL2_FW
 */
__COMMON_INLINE uint32_t COMMON_FBAL2_FW__GET(void)
{
    return HAL_GET32(__COMMON_FBAL2_FW__ADDRESS());
}

/* ---------------------- COMMON.FBAL2_FW.FBAL2_FW_EN ---------------------- */

/**
<pre>
  COMMON.FBAL2_FW.FBAL2_FW_EN:

    Enables FW controlled flux / voltage balance loop via fbal2_fw_adj.
    <start table>
    0 "use HW computed flux / voltage balance adjust"
    1 "use fbal2_fw_adj"
    <end table>

</pre> */

#define COMMON_FBAL2_FW__FBAL2_FW_EN__Pos                       8                                                                      /*!< Right-most bit position of fbal2_fw_en in COMMON.FBAL2_FW */
#define COMMON_FBAL2_FW__FBAL2_FW_EN__Msk                       (0x00000001UL << COMMON_FBAL2_FW__FBAL2_FW_EN__Pos)                    /*!< Mask for fbal2_fw_en in COMMON.FBAL2_FW */
#define COMMON_FBAL2_FW__FBAL2_FW_EN__Shift(v)                  (((v) << COMMON_FBAL2_FW__FBAL2_FW_EN__Pos) & COMMON_FBAL2_FW__FBAL2_FW_EN__Msk) /*!< Shift value 'v' into fbal2_fw_en and mask 'v' to fit it into fbal2_fw_en field */

/** COMMON_FBAL2_FW__FBAL2_FW_EN__SET() sets FBAL2_FW.FBAL2_FW_EN to given value.
 *
 * When writing to FBAL2_FW.FBAL2_FW_EN, this is recommended to use.
 *
 * @param bf_value new value for FBAL2_FW.FBAL2_FW_EN
 */
__COMMON_INLINE void COMMON_FBAL2_FW__FBAL2_FW_EN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL2_FW__GET();
    reg = (reg & ~COMMON_FBAL2_FW__FBAL2_FW_EN__Msk);
    reg = (reg | (COMMON_FBAL2_FW__FBAL2_FW_EN__Shift((uint32_t)bf_value)));
    COMMON_FBAL2_FW__SET(reg);
}

/** COMMON_FBAL2_FW__FBAL2_FW_EN__GET() gets FBAL2_FW.FBAL2_FW_EN's current value.
 *
 * When reading from FBAL2_FW.FBAL2_FW_EN, this is recommended to use.
 *
 * @return current value of FBAL2_FW.FBAL2_FW_EN
 */
__COMMON_INLINE uint32_t COMMON_FBAL2_FW__FBAL2_FW_EN__GET(void)
{
    uint32_t reg = COMMON_FBAL2_FW__GET();
    reg = (reg & COMMON_FBAL2_FW__FBAL2_FW_EN__Msk);
    reg = (reg >> COMMON_FBAL2_FW__FBAL2_FW_EN__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL2_FW__FBAL2_FW_EN__MODIFY() modifies FBAL2_FW.FBAL2_FW_EN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL2_FW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL2_FW
 * @param bf_value new value for FBAL2_FW.FBAL2_FW_EN
 * @return new value of COMMON.FBAL2_FW
 */
__COMMON_INLINE uint32_t COMMON_FBAL2_FW__FBAL2_FW_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL2_FW__FBAL2_FW_EN__Msk);
    reg = (reg | (COMMON_FBAL2_FW__FBAL2_FW_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL2_FW__FBAL2_FW_EN__EXTRACT() extracts FBAL2_FW.FBAL2_FW_EN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL2_FW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL2_FW
 * @return current value of FBAL2_FW.FBAL2_FW_EN
 */
__COMMON_INLINE uint32_t COMMON_FBAL2_FW__FBAL2_FW_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL2_FW__FBAL2_FW_EN__Msk);
    reg = (reg >> COMMON_FBAL2_FW__FBAL2_FW_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.FBAL2_FW.FBAL2_FW_ADJ ---------------------- */

/**
<pre>
  COMMON.FBAL2_FW.FBAL2_FW_ADJ:

    When fbal2_fw_en is high, this register overrides the Loop 0, Phase 2 or Loop 1 HW flux / voltage balance duty cycle adjust output with a FW controlled setting.
    LSB = 0.195 %, Range = 0.0 to 24.805%

</pre> */

#define COMMON_FBAL2_FW__FBAL2_FW_ADJ__Pos                      0                                                                      /*!< Right-most bit position of fbal2_fw_adj in COMMON.FBAL2_FW */
#define COMMON_FBAL2_FW__FBAL2_FW_ADJ__Msk                      (0x000000FFUL << COMMON_FBAL2_FW__FBAL2_FW_ADJ__Pos)                   /*!< Mask for fbal2_fw_adj in COMMON.FBAL2_FW */
#define COMMON_FBAL2_FW__FBAL2_FW_ADJ__Shift(v)                 (((v) << COMMON_FBAL2_FW__FBAL2_FW_ADJ__Pos) & COMMON_FBAL2_FW__FBAL2_FW_ADJ__Msk) /*!< Shift value 'v' into fbal2_fw_adj and mask 'v' to fit it into fbal2_fw_adj field */

/** COMMON_FBAL2_FW__FBAL2_FW_ADJ__SET() sets FBAL2_FW.FBAL2_FW_ADJ to given value.
 *
 * When writing to FBAL2_FW.FBAL2_FW_ADJ, this is recommended to use.
 *
 * @param bf_value new value for FBAL2_FW.FBAL2_FW_ADJ
 */
__COMMON_INLINE void COMMON_FBAL2_FW__FBAL2_FW_ADJ__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FBAL2_FW__GET();
    reg = (reg & ~COMMON_FBAL2_FW__FBAL2_FW_ADJ__Msk);
    reg = (reg | (COMMON_FBAL2_FW__FBAL2_FW_ADJ__Shift((uint32_t)bf_value)));
    COMMON_FBAL2_FW__SET(reg);
}

/** COMMON_FBAL2_FW__FBAL2_FW_ADJ__GET() gets FBAL2_FW.FBAL2_FW_ADJ's current value.
 *
 * When reading from FBAL2_FW.FBAL2_FW_ADJ, this is recommended to use.
 *
 * @return current value of FBAL2_FW.FBAL2_FW_ADJ
 */
__COMMON_INLINE uint32_t COMMON_FBAL2_FW__FBAL2_FW_ADJ__GET(void)
{
    uint32_t reg = COMMON_FBAL2_FW__GET();
    reg = (reg & COMMON_FBAL2_FW__FBAL2_FW_ADJ__Msk);
    reg = (reg >> COMMON_FBAL2_FW__FBAL2_FW_ADJ__Pos);
    return (uint32_t)reg;
}

/** COMMON_FBAL2_FW__FBAL2_FW_ADJ__MODIFY() modifies FBAL2_FW.FBAL2_FW_ADJ.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FBAL2_FW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FBAL2_FW
 * @param bf_value new value for FBAL2_FW.FBAL2_FW_ADJ
 * @return new value of COMMON.FBAL2_FW
 */
__COMMON_INLINE uint32_t COMMON_FBAL2_FW__FBAL2_FW_ADJ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FBAL2_FW__FBAL2_FW_ADJ__Msk);
    reg = (reg | (COMMON_FBAL2_FW__FBAL2_FW_ADJ__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FBAL2_FW__FBAL2_FW_ADJ__EXTRACT() extracts FBAL2_FW.FBAL2_FW_ADJ.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FBAL2_FW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FBAL2_FW
 * @return current value of FBAL2_FW.FBAL2_FW_ADJ
 */
__COMMON_INLINE uint32_t COMMON_FBAL2_FW__FBAL2_FW_ADJ__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FBAL2_FW__FBAL2_FW_ADJ__Msk);
    reg = (reg >> COMMON_FBAL2_FW__FBAL2_FW_ADJ__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        ISHARE_FW member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_ISHARE_FW__ADDRESS returns the address of member ISHARE_FW.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ISHARE_FW
 */
__COMMON_INLINE uint32_t* __COMMON_ISHARE_FW__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, ISHARE_FW)));
}

/** COMMON_ISHARE_FW__SET() sets ISHARE_FW to given value.
 *
 * When writing to ISHARE_FW, this is mandatory to use.
 *
 * @param value new value for ISHARE_FW
 */
__COMMON_INLINE void COMMON_ISHARE_FW__SET(uint32_t value)
{
    HAL_SET32(__COMMON_ISHARE_FW__ADDRESS(), value);
}

/** COMMON_ISHARE_FW__GET() gets ISHARE_FW's current value.
 *
 * When reading from ISHARE_FW, this is mandatory to use.
 *
 * @return current value of ISHARE_FW
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_FW__GET(void)
{
    return HAL_GET32(__COMMON_ISHARE_FW__ADDRESS());
}

/* ---------------------- COMMON.ISHARE_FW.ISHR_FW_EN ---------------------- */

/**
<pre>
  COMMON.ISHARE_FW.ISHR_FW_EN:

    Enables FW controlled current share loop via ishr_fw_adj.
    <start table>
    0 "use HW computed current share adjust"
    1 "use ishr_fw_adj"
    <end table>

</pre> */

#define COMMON_ISHARE_FW__ISHR_FW_EN__Pos                       12                                                                     /*!< Right-most bit position of ishr_fw_en in COMMON.ISHARE_FW */
#define COMMON_ISHARE_FW__ISHR_FW_EN__Msk                       (0x00000001UL << COMMON_ISHARE_FW__ISHR_FW_EN__Pos)                    /*!< Mask for ishr_fw_en in COMMON.ISHARE_FW */
#define COMMON_ISHARE_FW__ISHR_FW_EN__Shift(v)                  (((v) << COMMON_ISHARE_FW__ISHR_FW_EN__Pos) & COMMON_ISHARE_FW__ISHR_FW_EN__Msk) /*!< Shift value 'v' into ishr_fw_en and mask 'v' to fit it into ishr_fw_en field */

/** COMMON_ISHARE_FW__ISHR_FW_EN__SET() sets ISHARE_FW.ISHR_FW_EN to given value.
 *
 * When writing to ISHARE_FW.ISHR_FW_EN, this is recommended to use.
 *
 * @param bf_value new value for ISHARE_FW.ISHR_FW_EN
 */
__COMMON_INLINE void COMMON_ISHARE_FW__ISHR_FW_EN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_ISHARE_FW__GET();
    reg = (reg & ~COMMON_ISHARE_FW__ISHR_FW_EN__Msk);
    reg = (reg | (COMMON_ISHARE_FW__ISHR_FW_EN__Shift((uint32_t)bf_value)));
    COMMON_ISHARE_FW__SET(reg);
}

/** COMMON_ISHARE_FW__ISHR_FW_EN__GET() gets ISHARE_FW.ISHR_FW_EN's current value.
 *
 * When reading from ISHARE_FW.ISHR_FW_EN, this is recommended to use.
 *
 * @return current value of ISHARE_FW.ISHR_FW_EN
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_FW__ISHR_FW_EN__GET(void)
{
    uint32_t reg = COMMON_ISHARE_FW__GET();
    reg = (reg & COMMON_ISHARE_FW__ISHR_FW_EN__Msk);
    reg = (reg >> COMMON_ISHARE_FW__ISHR_FW_EN__Pos);
    return (uint32_t)reg;
}

/** COMMON_ISHARE_FW__ISHR_FW_EN__MODIFY() modifies ISHARE_FW.ISHR_FW_EN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.ISHARE_FW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.ISHARE_FW
 * @param bf_value new value for ISHARE_FW.ISHR_FW_EN
 * @return new value of COMMON.ISHARE_FW
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_FW__ISHR_FW_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_ISHARE_FW__ISHR_FW_EN__Msk);
    reg = (reg | (COMMON_ISHARE_FW__ISHR_FW_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_ISHARE_FW__ISHR_FW_EN__EXTRACT() extracts ISHARE_FW.ISHR_FW_EN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.ISHARE_FW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.ISHARE_FW
 * @return current value of ISHARE_FW.ISHR_FW_EN
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_FW__ISHR_FW_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_ISHARE_FW__ISHR_FW_EN__Msk);
    reg = (reg >> COMMON_ISHARE_FW__ISHR_FW_EN__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.ISHARE_FW.ISHR_FW_ADJ ---------------------- */

/**
<pre>
  COMMON.ISHARE_FW.ISHR_FW_ADJ:

    When ishr_fw_en is high, this register overrides the HW current share voltage adjust output with a FW controlled setting.
    LSB = 156.25uV, Range = -320 to +319.84375mV

</pre> */

#define COMMON_ISHARE_FW__ISHR_FW_ADJ__Pos                      0                                                                      /*!< Right-most bit position of ishr_fw_adj in COMMON.ISHARE_FW */
#define COMMON_ISHARE_FW__ISHR_FW_ADJ__Msk                      (0x00000FFFUL << COMMON_ISHARE_FW__ISHR_FW_ADJ__Pos)                   /*!< Mask for ishr_fw_adj in COMMON.ISHARE_FW */
#define COMMON_ISHARE_FW__ISHR_FW_ADJ__Shift(v)                 (((v) << COMMON_ISHARE_FW__ISHR_FW_ADJ__Pos) & COMMON_ISHARE_FW__ISHR_FW_ADJ__Msk) /*!< Shift value 'v' into ishr_fw_adj and mask 'v' to fit it into ishr_fw_adj field */

/** COMMON_ISHARE_FW__ISHR_FW_ADJ__SET() sets ISHARE_FW.ISHR_FW_ADJ to given value.
 *
 * When writing to ISHARE_FW.ISHR_FW_ADJ, this is recommended to use.
 *
 * @param bf_value new value for ISHARE_FW.ISHR_FW_ADJ
 */
__COMMON_INLINE void COMMON_ISHARE_FW__ISHR_FW_ADJ__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_ISHARE_FW__GET();
    reg = (reg & ~COMMON_ISHARE_FW__ISHR_FW_ADJ__Msk);
    reg = (reg | (COMMON_ISHARE_FW__ISHR_FW_ADJ__Shift((uint32_t)bf_value)));
    COMMON_ISHARE_FW__SET(reg);
}

/** COMMON_ISHARE_FW__ISHR_FW_ADJ__GET() gets ISHARE_FW.ISHR_FW_ADJ's current value.
 *
 * When reading from ISHARE_FW.ISHR_FW_ADJ, this is recommended to use.
 *
 * @return current value of ISHARE_FW.ISHR_FW_ADJ
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_FW__ISHR_FW_ADJ__GET(void)
{
    uint32_t reg = COMMON_ISHARE_FW__GET();
    reg = (reg & COMMON_ISHARE_FW__ISHR_FW_ADJ__Msk);
    reg = (reg >> COMMON_ISHARE_FW__ISHR_FW_ADJ__Pos);
    return (uint32_t)reg;
}

/** COMMON_ISHARE_FW__ISHR_FW_ADJ__MODIFY() modifies ISHARE_FW.ISHR_FW_ADJ.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.ISHARE_FW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.ISHARE_FW
 * @param bf_value new value for ISHARE_FW.ISHR_FW_ADJ
 * @return new value of COMMON.ISHARE_FW
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_FW__ISHR_FW_ADJ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_ISHARE_FW__ISHR_FW_ADJ__Msk);
    reg = (reg | (COMMON_ISHARE_FW__ISHR_FW_ADJ__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_ISHARE_FW__ISHR_FW_ADJ__EXTRACT() extracts ISHARE_FW.ISHR_FW_ADJ.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.ISHARE_FW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.ISHARE_FW
 * @return current value of ISHARE_FW.ISHR_FW_ADJ
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_FW__ISHR_FW_ADJ__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_ISHARE_FW__ISHR_FW_ADJ__Msk);
    reg = (reg >> COMMON_ISHARE_FW__ISHR_FW_ADJ__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         IDAC_FW member of COMMON_t                         */
/* -------------------------------------------------------------------------- */

/** __COMMON_IDAC_FW__ADDRESS returns the address of member IDAC_FW.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IDAC_FW
 */
__COMMON_INLINE uint32_t* __COMMON_IDAC_FW__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, IDAC_FW)));
}

/** COMMON_IDAC_FW__SET() sets IDAC_FW to given value.
 *
 * When writing to IDAC_FW, this is mandatory to use.
 *
 * @param value new value for IDAC_FW
 */
__COMMON_INLINE void COMMON_IDAC_FW__SET(uint32_t value)
{
    HAL_SET32(__COMMON_IDAC_FW__ADDRESS(), value);
}

/** COMMON_IDAC_FW__GET() gets IDAC_FW's current value.
 *
 * When reading from IDAC_FW, this is mandatory to use.
 *
 * @return current value of IDAC_FW
 */
__COMMON_INLINE uint32_t COMMON_IDAC_FW__GET(void)
{
    return HAL_GET32(__COMMON_IDAC_FW__ADDRESS());
}

/* ----------------------- COMMON.IDAC_FW.IDAC_FW_EN ----------------------- */

/**
<pre>
  COMMON.IDAC_FW.IDAC_FW_EN:

    Enables FW controlled current DAC output via idac_fw_frc.
    <start table>
    0 "use HW determined current DAC output"
    1 "use idac_fw_frc"
    <end table>

</pre> */

#define COMMON_IDAC_FW__IDAC_FW_EN__Pos                         10                                                                     /*!< Right-most bit position of idac_fw_en in COMMON.IDAC_FW */
#define COMMON_IDAC_FW__IDAC_FW_EN__Msk                         (0x00000001UL << COMMON_IDAC_FW__IDAC_FW_EN__Pos)                      /*!< Mask for idac_fw_en in COMMON.IDAC_FW */
#define COMMON_IDAC_FW__IDAC_FW_EN__Shift(v)                    (((v) << COMMON_IDAC_FW__IDAC_FW_EN__Pos) & COMMON_IDAC_FW__IDAC_FW_EN__Msk) /*!< Shift value 'v' into idac_fw_en and mask 'v' to fit it into idac_fw_en field */

/** COMMON_IDAC_FW__IDAC_FW_EN__SET() sets IDAC_FW.IDAC_FW_EN to given value.
 *
 * When writing to IDAC_FW.IDAC_FW_EN, this is recommended to use.
 *
 * @param bf_value new value for IDAC_FW.IDAC_FW_EN
 */
__COMMON_INLINE void COMMON_IDAC_FW__IDAC_FW_EN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_IDAC_FW__GET();
    reg = (reg & ~COMMON_IDAC_FW__IDAC_FW_EN__Msk);
    reg = (reg | (COMMON_IDAC_FW__IDAC_FW_EN__Shift((uint32_t)bf_value)));
    COMMON_IDAC_FW__SET(reg);
}

/** COMMON_IDAC_FW__IDAC_FW_EN__GET() gets IDAC_FW.IDAC_FW_EN's current value.
 *
 * When reading from IDAC_FW.IDAC_FW_EN, this is recommended to use.
 *
 * @return current value of IDAC_FW.IDAC_FW_EN
 */
__COMMON_INLINE uint32_t COMMON_IDAC_FW__IDAC_FW_EN__GET(void)
{
    uint32_t reg = COMMON_IDAC_FW__GET();
    reg = (reg & COMMON_IDAC_FW__IDAC_FW_EN__Msk);
    reg = (reg >> COMMON_IDAC_FW__IDAC_FW_EN__Pos);
    return (uint32_t)reg;
}

/** COMMON_IDAC_FW__IDAC_FW_EN__MODIFY() modifies IDAC_FW.IDAC_FW_EN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.IDAC_FW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.IDAC_FW
 * @param bf_value new value for IDAC_FW.IDAC_FW_EN
 * @return new value of COMMON.IDAC_FW
 */
__COMMON_INLINE uint32_t COMMON_IDAC_FW__IDAC_FW_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_IDAC_FW__IDAC_FW_EN__Msk);
    reg = (reg | (COMMON_IDAC_FW__IDAC_FW_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_IDAC_FW__IDAC_FW_EN__EXTRACT() extracts IDAC_FW.IDAC_FW_EN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.IDAC_FW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.IDAC_FW
 * @return current value of IDAC_FW.IDAC_FW_EN
 */
__COMMON_INLINE uint32_t COMMON_IDAC_FW__IDAC_FW_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_IDAC_FW__IDAC_FW_EN__Msk);
    reg = (reg >> COMMON_IDAC_FW__IDAC_FW_EN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.IDAC_FW.IDAC_FW_FRC ----------------------- */

/**
<pre>
  COMMON.IDAC_FW.IDAC_FW_FRC:

    When idac_fw_en is high, this register overrides the HW current DAC output with a FW controlled setting.
    LSB = 0.625uA, Range = 0.0 to 639.375uA

</pre> */

#define COMMON_IDAC_FW__IDAC_FW_FRC__Pos                        0                                                                      /*!< Right-most bit position of idac_fw_frc in COMMON.IDAC_FW */
#define COMMON_IDAC_FW__IDAC_FW_FRC__Msk                        (0x000003FFUL << COMMON_IDAC_FW__IDAC_FW_FRC__Pos)                     /*!< Mask for idac_fw_frc in COMMON.IDAC_FW */
#define COMMON_IDAC_FW__IDAC_FW_FRC__Shift(v)                   (((v) << COMMON_IDAC_FW__IDAC_FW_FRC__Pos) & COMMON_IDAC_FW__IDAC_FW_FRC__Msk) /*!< Shift value 'v' into idac_fw_frc and mask 'v' to fit it into idac_fw_frc field */

/** COMMON_IDAC_FW__IDAC_FW_FRC__SET() sets IDAC_FW.IDAC_FW_FRC to given value.
 *
 * When writing to IDAC_FW.IDAC_FW_FRC, this is recommended to use.
 *
 * @param bf_value new value for IDAC_FW.IDAC_FW_FRC
 */
__COMMON_INLINE void COMMON_IDAC_FW__IDAC_FW_FRC__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_IDAC_FW__GET();
    reg = (reg & ~COMMON_IDAC_FW__IDAC_FW_FRC__Msk);
    reg = (reg | (COMMON_IDAC_FW__IDAC_FW_FRC__Shift((uint32_t)bf_value)));
    COMMON_IDAC_FW__SET(reg);
}

/** COMMON_IDAC_FW__IDAC_FW_FRC__GET() gets IDAC_FW.IDAC_FW_FRC's current value.
 *
 * When reading from IDAC_FW.IDAC_FW_FRC, this is recommended to use.
 *
 * @return current value of IDAC_FW.IDAC_FW_FRC
 */
__COMMON_INLINE uint32_t COMMON_IDAC_FW__IDAC_FW_FRC__GET(void)
{
    uint32_t reg = COMMON_IDAC_FW__GET();
    reg = (reg & COMMON_IDAC_FW__IDAC_FW_FRC__Msk);
    reg = (reg >> COMMON_IDAC_FW__IDAC_FW_FRC__Pos);
    return (uint32_t)reg;
}

/** COMMON_IDAC_FW__IDAC_FW_FRC__MODIFY() modifies IDAC_FW.IDAC_FW_FRC.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.IDAC_FW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.IDAC_FW
 * @param bf_value new value for IDAC_FW.IDAC_FW_FRC
 * @return new value of COMMON.IDAC_FW
 */
__COMMON_INLINE uint32_t COMMON_IDAC_FW__IDAC_FW_FRC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_IDAC_FW__IDAC_FW_FRC__Msk);
    reg = (reg | (COMMON_IDAC_FW__IDAC_FW_FRC__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_IDAC_FW__IDAC_FW_FRC__EXTRACT() extracts IDAC_FW.IDAC_FW_FRC.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.IDAC_FW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.IDAC_FW
 * @return current value of IDAC_FW.IDAC_FW_FRC
 */
__COMMON_INLINE uint32_t COMMON_IDAC_FW__IDAC_FW_FRC__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_IDAC_FW__IDAC_FW_FRC__Msk);
    reg = (reg >> COMMON_IDAC_FW__IDAC_FW_FRC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         XADDR1 member of COMMON_t                         */
/* -------------------------------------------------------------------------- */

/** __COMMON_XADDR1__ADDRESS returns the address of member XADDR1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of XADDR1
 */
__COMMON_INLINE uint32_t* __COMMON_XADDR1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, XADDR1)));
}

/** COMMON_XADDR1__SET() sets XADDR1 to given value.
 *
 * When writing to XADDR1, this is mandatory to use.
 *
 * @param value new value for XADDR1
 */
__COMMON_INLINE void COMMON_XADDR1__SET(uint32_t value)
{
    HAL_SET32(__COMMON_XADDR1__ADDRESS(), value);
}

/** COMMON_XADDR1__GET() gets XADDR1's current value.
 *
 * When reading from XADDR1, this is mandatory to use.
 *
 * @return current value of XADDR1
 */
__COMMON_INLINE uint32_t COMMON_XADDR1__GET(void)
{
    return HAL_GET32(__COMMON_XADDR1__ADDRESS());
}

/* ------------------------ COMMON.XADDR1.XADDR1_PD ------------------------ */

/**
<pre>
  COMMON.XADDR1.XADDR1_PD:

    XADDR1 weak pulldown control
    <start table>
    0 "pulldown disabled"
    1 "pulldown enabled except when xv_pinset1_meas=1"
    <end table>

</pre> */

#define COMMON_XADDR1__XADDR1_PD__Pos                           0                                                                      /*!< Right-most bit position of xaddr1_pd in COMMON.XADDR1 */
#define COMMON_XADDR1__XADDR1_PD__Msk                           (0x00000001UL << COMMON_XADDR1__XADDR1_PD__Pos)                        /*!< Mask for xaddr1_pd in COMMON.XADDR1 */
#define COMMON_XADDR1__XADDR1_PD__Shift(v)                      (((v) << COMMON_XADDR1__XADDR1_PD__Pos) & COMMON_XADDR1__XADDR1_PD__Msk) /*!< Shift value 'v' into xaddr1_pd and mask 'v' to fit it into xaddr1_pd field */

/** COMMON_XADDR1__XADDR1_PD__SET() sets XADDR1.XADDR1_PD to given value.
 *
 * When writing to XADDR1.XADDR1_PD, this is recommended to use.
 *
 * @param bf_value new value for XADDR1.XADDR1_PD
 */
__COMMON_INLINE void COMMON_XADDR1__XADDR1_PD__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_XADDR1__GET();
    reg = (reg & ~COMMON_XADDR1__XADDR1_PD__Msk);
    reg = (reg | (COMMON_XADDR1__XADDR1_PD__Shift((uint32_t)bf_value)));
    COMMON_XADDR1__SET(reg);
}

/** COMMON_XADDR1__XADDR1_PD__GET() gets XADDR1.XADDR1_PD's current value.
 *
 * When reading from XADDR1.XADDR1_PD, this is recommended to use.
 *
 * @return current value of XADDR1.XADDR1_PD
 */
__COMMON_INLINE uint32_t COMMON_XADDR1__XADDR1_PD__GET(void)
{
    uint32_t reg = COMMON_XADDR1__GET();
    reg = (reg & COMMON_XADDR1__XADDR1_PD__Msk);
    reg = (reg >> COMMON_XADDR1__XADDR1_PD__Pos);
    return (uint32_t)reg;
}

/** COMMON_XADDR1__XADDR1_PD__MODIFY() modifies XADDR1.XADDR1_PD.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.XADDR1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.XADDR1
 * @param bf_value new value for XADDR1.XADDR1_PD
 * @return new value of COMMON.XADDR1
 */
__COMMON_INLINE uint32_t COMMON_XADDR1__XADDR1_PD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_XADDR1__XADDR1_PD__Msk);
    reg = (reg | (COMMON_XADDR1__XADDR1_PD__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_XADDR1__XADDR1_PD__EXTRACT() extracts XADDR1.XADDR1_PD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.XADDR1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.XADDR1
 * @return current value of XADDR1.XADDR1_PD
 */
__COMMON_INLINE uint32_t COMMON_XADDR1__XADDR1_PD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_XADDR1__XADDR1_PD__Msk);
    reg = (reg >> COMMON_XADDR1__XADDR1_PD__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          IO_IN member of COMMON_t                          */
/* -------------------------------------------------------------------------- */

/** __COMMON_IO_IN__ADDRESS returns the address of member IO_IN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IO_IN
 */
__COMMON_INLINE uint32_t* __COMMON_IO_IN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, IO_IN)));
}

/** COMMON_IO_IN__GET() gets IO_IN's current value.
 *
 * When reading from IO_IN, this is mandatory to use.
 *
 * @return current value of IO_IN
 */
__COMMON_INLINE uint32_t COMMON_IO_IN__GET(void)
{
    return HAL_GET32(__COMMON_IO_IN__ADDRESS());
}

/* ------------------------- COMMON.IO_IN.IO_INPUTS ------------------------- */

/**
<pre>
  COMMON.IO_IN.IO_INPUTS:

    IO inputs for test.  Only active when force_all_in=1.
    <start table_with_header>
    Bit Pin Bit Pin Bit Pin Bit Pin
    0 EN 1 PWRGD 2 BEN 3 BPRWGD
    4 SCL 5 SDA 6 SMBALERT 7 SYNC
    8 PWM1 9 PWM2 10 PWM3 11 PWM4
    12 PWM5 13 PWM6 14 PWM7 15 PWM8
    16 PWM9 17 PWM10 18 PWM11 19 PWM12
    20 IMON 21 FAULT2 22 FAULT1 23 "Spare GPIO1"
    <end table>

</pre> */

#define COMMON_IO_IN__IO_INPUTS__Pos                            0                                                                      /*!< Right-most bit position of io_inputs in COMMON.IO_IN */
#define COMMON_IO_IN__IO_INPUTS__Msk                            (0x00FFFFFFUL << COMMON_IO_IN__IO_INPUTS__Pos)                         /*!< Mask for io_inputs in COMMON.IO_IN */
#define COMMON_IO_IN__IO_INPUTS__Shift(v)                       (((v) << COMMON_IO_IN__IO_INPUTS__Pos) & COMMON_IO_IN__IO_INPUTS__Msk) /*!< Shift value 'v' into io_inputs and mask 'v' to fit it into io_inputs field */

/** COMMON_IO_IN__IO_INPUTS__GET() gets IO_IN.IO_INPUTS's current value.
 *
 * When reading from IO_IN.IO_INPUTS, this is recommended to use.
 *
 * @return current value of IO_IN.IO_INPUTS
 */
__COMMON_INLINE uint32_t COMMON_IO_IN__IO_INPUTS__GET(void)
{
    uint32_t reg = COMMON_IO_IN__GET();
    reg = (reg & COMMON_IO_IN__IO_INPUTS__Msk);
    reg = (reg >> COMMON_IO_IN__IO_INPUTS__Pos);
    return (uint32_t)reg;
}

/** COMMON_IO_IN__IO_INPUTS__EXTRACT() extracts IO_IN.IO_INPUTS.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.IO_IN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.IO_IN
 * @return current value of IO_IN.IO_INPUTS
 */
__COMMON_INLINE uint32_t COMMON_IO_IN__IO_INPUTS__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_IO_IN__IO_INPUTS__Msk);
    reg = (reg >> COMMON_IO_IN__IO_INPUTS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       CE0_IOFFSET member of COMMON_t                       */
/* -------------------------------------------------------------------------- */

/** __COMMON_CE0_IOFFSET__ADDRESS returns the address of member CE0_IOFFSET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CE0_IOFFSET
 */
__COMMON_INLINE uint32_t* __COMMON_CE0_IOFFSET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, CE0_IOFFSET)));
}

/** COMMON_CE0_IOFFSET__GET() gets CE0_IOFFSET's current value.
 *
 * When reading from CE0_IOFFSET, this is mandatory to use.
 *
 * @return current value of CE0_IOFFSET
 */
__COMMON_INLINE uint32_t COMMON_CE0_IOFFSET__GET(void)
{
    return HAL_GET32(__COMMON_CE0_IOFFSET__ADDRESS());
}

/* --------------------- COMMON.CE0_IOFFSET.CE0_IOFFSET --------------------- */

/**
<pre>
  COMMON.CE0_IOFFSET.CE0_IOFFSET:

    CE0 / IS1 (ISEN) calibrated offset status register.
    LSB = 0.0625 Codes, Range = -256 to +255.9375 Codes

</pre> */

#define COMMON_CE0_IOFFSET__CE0_IOFFSET__Pos                    0                                                                      /*!< Right-most bit position of ce0_ioffset in COMMON.CE0_IOFFSET */
#define COMMON_CE0_IOFFSET__CE0_IOFFSET__Msk                    (0x00001FFFUL << COMMON_CE0_IOFFSET__CE0_IOFFSET__Pos)                 /*!< Mask for ce0_ioffset in COMMON.CE0_IOFFSET */
#define COMMON_CE0_IOFFSET__CE0_IOFFSET__Shift(v)               (((v) << COMMON_CE0_IOFFSET__CE0_IOFFSET__Pos) & COMMON_CE0_IOFFSET__CE0_IOFFSET__Msk) /*!< Shift value 'v' into ce0_ioffset and mask 'v' to fit it into ce0_ioffset field */

/** COMMON_CE0_IOFFSET__CE0_IOFFSET__GET() gets CE0_IOFFSET.CE0_IOFFSET's current value.
 *
 * When reading from CE0_IOFFSET.CE0_IOFFSET, this is recommended to use.
 *
 * @return current value of CE0_IOFFSET.CE0_IOFFSET
 */
__COMMON_INLINE uint32_t COMMON_CE0_IOFFSET__CE0_IOFFSET__GET(void)
{
    uint32_t reg = COMMON_CE0_IOFFSET__GET();
    reg = (reg & COMMON_CE0_IOFFSET__CE0_IOFFSET__Msk);
    reg = (reg >> COMMON_CE0_IOFFSET__CE0_IOFFSET__Pos);
    return (uint32_t)reg;
}

/** COMMON_CE0_IOFFSET__CE0_IOFFSET__EXTRACT() extracts CE0_IOFFSET.CE0_IOFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.CE0_IOFFSET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.CE0_IOFFSET
 * @return current value of CE0_IOFFSET.CE0_IOFFSET
 */
__COMMON_INLINE uint32_t COMMON_CE0_IOFFSET__CE0_IOFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_CE0_IOFFSET__CE0_IOFFSET__Msk);
    reg = (reg >> COMMON_CE0_IOFFSET__CE0_IOFFSET__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       CE1_IOFFSET member of COMMON_t                       */
/* -------------------------------------------------------------------------- */

/** __COMMON_CE1_IOFFSET__ADDRESS returns the address of member CE1_IOFFSET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CE1_IOFFSET
 */
__COMMON_INLINE uint32_t* __COMMON_CE1_IOFFSET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, CE1_IOFFSET)));
}

/** COMMON_CE1_IOFFSET__GET() gets CE1_IOFFSET's current value.
 *
 * When reading from CE1_IOFFSET, this is mandatory to use.
 *
 * @return current value of CE1_IOFFSET
 */
__COMMON_INLINE uint32_t COMMON_CE1_IOFFSET__GET(void)
{
    return HAL_GET32(__COMMON_CE1_IOFFSET__ADDRESS());
}

/* --------------------- COMMON.CE1_IOFFSET.CE1_IOFFSET --------------------- */

/**
<pre>
  COMMON.CE1_IOFFSET.CE1_IOFFSET:

    CE1 / IS2 calibrated offset status register.
    LSB = 0.0625 Codes, Range = -256 to +255.9375 Codes

</pre> */

#define COMMON_CE1_IOFFSET__CE1_IOFFSET__Pos                    0                                                                      /*!< Right-most bit position of ce1_ioffset in COMMON.CE1_IOFFSET */
#define COMMON_CE1_IOFFSET__CE1_IOFFSET__Msk                    (0x00001FFFUL << COMMON_CE1_IOFFSET__CE1_IOFFSET__Pos)                 /*!< Mask for ce1_ioffset in COMMON.CE1_IOFFSET */
#define COMMON_CE1_IOFFSET__CE1_IOFFSET__Shift(v)               (((v) << COMMON_CE1_IOFFSET__CE1_IOFFSET__Pos) & COMMON_CE1_IOFFSET__CE1_IOFFSET__Msk) /*!< Shift value 'v' into ce1_ioffset and mask 'v' to fit it into ce1_ioffset field */

/** COMMON_CE1_IOFFSET__CE1_IOFFSET__GET() gets CE1_IOFFSET.CE1_IOFFSET's current value.
 *
 * When reading from CE1_IOFFSET.CE1_IOFFSET, this is recommended to use.
 *
 * @return current value of CE1_IOFFSET.CE1_IOFFSET
 */
__COMMON_INLINE uint32_t COMMON_CE1_IOFFSET__CE1_IOFFSET__GET(void)
{
    uint32_t reg = COMMON_CE1_IOFFSET__GET();
    reg = (reg & COMMON_CE1_IOFFSET__CE1_IOFFSET__Msk);
    reg = (reg >> COMMON_CE1_IOFFSET__CE1_IOFFSET__Pos);
    return (uint32_t)reg;
}

/** COMMON_CE1_IOFFSET__CE1_IOFFSET__EXTRACT() extracts CE1_IOFFSET.CE1_IOFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.CE1_IOFFSET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.CE1_IOFFSET
 * @return current value of CE1_IOFFSET.CE1_IOFFSET
 */
__COMMON_INLINE uint32_t COMMON_CE1_IOFFSET__CE1_IOFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_CE1_IOFFSET__CE1_IOFFSET__Msk);
    reg = (reg >> COMMON_CE1_IOFFSET__CE1_IOFFSET__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       CE2_IOFFSET member of COMMON_t                       */
/* -------------------------------------------------------------------------- */

/** __COMMON_CE2_IOFFSET__ADDRESS returns the address of member CE2_IOFFSET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CE2_IOFFSET
 */
__COMMON_INLINE uint32_t* __COMMON_CE2_IOFFSET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, CE2_IOFFSET)));
}

/** COMMON_CE2_IOFFSET__GET() gets CE2_IOFFSET's current value.
 *
 * When reading from CE2_IOFFSET, this is mandatory to use.
 *
 * @return current value of CE2_IOFFSET
 */
__COMMON_INLINE uint32_t COMMON_CE2_IOFFSET__GET(void)
{
    return HAL_GET32(__COMMON_CE2_IOFFSET__ADDRESS());
}

/* --------------------- COMMON.CE2_IOFFSET.CE2_IOFFSET --------------------- */

/**
<pre>
  COMMON.CE2_IOFFSET.CE2_IOFFSET:

    CE2 / IS3 (BISEN) calibrated offset status register.
    LSB = 0.0625 Codes, Range = -256 to +255.9375 Codes

</pre> */

#define COMMON_CE2_IOFFSET__CE2_IOFFSET__Pos                    0                                                                      /*!< Right-most bit position of ce2_ioffset in COMMON.CE2_IOFFSET */
#define COMMON_CE2_IOFFSET__CE2_IOFFSET__Msk                    (0x00001FFFUL << COMMON_CE2_IOFFSET__CE2_IOFFSET__Pos)                 /*!< Mask for ce2_ioffset in COMMON.CE2_IOFFSET */
#define COMMON_CE2_IOFFSET__CE2_IOFFSET__Shift(v)               (((v) << COMMON_CE2_IOFFSET__CE2_IOFFSET__Pos) & COMMON_CE2_IOFFSET__CE2_IOFFSET__Msk) /*!< Shift value 'v' into ce2_ioffset and mask 'v' to fit it into ce2_ioffset field */

/** COMMON_CE2_IOFFSET__CE2_IOFFSET__GET() gets CE2_IOFFSET.CE2_IOFFSET's current value.
 *
 * When reading from CE2_IOFFSET.CE2_IOFFSET, this is recommended to use.
 *
 * @return current value of CE2_IOFFSET.CE2_IOFFSET
 */
__COMMON_INLINE uint32_t COMMON_CE2_IOFFSET__CE2_IOFFSET__GET(void)
{
    uint32_t reg = COMMON_CE2_IOFFSET__GET();
    reg = (reg & COMMON_CE2_IOFFSET__CE2_IOFFSET__Msk);
    reg = (reg >> COMMON_CE2_IOFFSET__CE2_IOFFSET__Pos);
    return (uint32_t)reg;
}

/** COMMON_CE2_IOFFSET__CE2_IOFFSET__EXTRACT() extracts CE2_IOFFSET.CE2_IOFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.CE2_IOFFSET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.CE2_IOFFSET
 * @return current value of CE2_IOFFSET.CE2_IOFFSET
 */
__COMMON_INLINE uint32_t COMMON_CE2_IOFFSET__CE2_IOFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_CE2_IOFFSET__CE2_IOFFSET__Msk);
    reg = (reg >> COMMON_CE2_IOFFSET__CE2_IOFFSET__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        ISHARE_DZ member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_ISHARE_DZ__ADDRESS returns the address of member ISHARE_DZ.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ISHARE_DZ
 */
__COMMON_INLINE uint32_t* __COMMON_ISHARE_DZ__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, ISHARE_DZ)));
}

/** COMMON_ISHARE_DZ__SET() sets ISHARE_DZ to given value.
 *
 * When writing to ISHARE_DZ, this is mandatory to use.
 *
 * @param value new value for ISHARE_DZ
 */
__COMMON_INLINE void COMMON_ISHARE_DZ__SET(uint32_t value)
{
    HAL_SET32(__COMMON_ISHARE_DZ__ADDRESS(), value);
}

/** COMMON_ISHARE_DZ__GET() gets ISHARE_DZ's current value.
 *
 * When reading from ISHARE_DZ, this is mandatory to use.
 *
 * @return current value of ISHARE_DZ
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_DZ__GET(void)
{
    return HAL_GET32(__COMMON_ISHARE_DZ__ADDRESS());
}

/* ------------------- COMMON.ISHARE_DZ.ISHARE_DEAD_ZONE ------------------- */

/**
<pre>
  COMMON.ISHARE_DZ.ISHARE_DEAD_ZONE:

    Ishare dead zone below which current sharing is not attempted. To convert to Amps divide by ishr_scale.
    LSB = 1 Code, Range = 0 to 255 Codes

</pre> */

#define COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Pos                 0                                                                      /*!< Right-most bit position of ishare_dead_zone in COMMON.ISHARE_DZ */
#define COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Msk                 (0x000000FFUL << COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Pos)              /*!< Mask for ishare_dead_zone in COMMON.ISHARE_DZ */
#define COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Shift(v)            (((v) << COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Pos) & COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Msk) /*!< Shift value 'v' into ishare_dead_zone and mask 'v' to fit it into ishare_dead_zone field */

/** COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__SET() sets ISHARE_DZ.ISHARE_DEAD_ZONE to given value.
 *
 * When writing to ISHARE_DZ.ISHARE_DEAD_ZONE, this is recommended to use.
 *
 * @param bf_value new value for ISHARE_DZ.ISHARE_DEAD_ZONE
 */
__COMMON_INLINE void COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_ISHARE_DZ__GET();
    reg = (reg & ~COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Msk);
    reg = (reg | (COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Shift((uint32_t)bf_value)));
    COMMON_ISHARE_DZ__SET(reg);
}

/** COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__GET() gets ISHARE_DZ.ISHARE_DEAD_ZONE's current value.
 *
 * When reading from ISHARE_DZ.ISHARE_DEAD_ZONE, this is recommended to use.
 *
 * @return current value of ISHARE_DZ.ISHARE_DEAD_ZONE
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__GET(void)
{
    uint32_t reg = COMMON_ISHARE_DZ__GET();
    reg = (reg & COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Msk);
    reg = (reg >> COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Pos);
    return (uint32_t)reg;
}

/** COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__MODIFY() modifies ISHARE_DZ.ISHARE_DEAD_ZONE.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.ISHARE_DZ.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.ISHARE_DZ
 * @param bf_value new value for ISHARE_DZ.ISHARE_DEAD_ZONE
 * @return new value of COMMON.ISHARE_DZ
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Msk);
    reg = (reg | (COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__EXTRACT() extracts ISHARE_DZ.ISHARE_DEAD_ZONE.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.ISHARE_DZ.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.ISHARE_DZ
 * @return current value of ISHARE_DZ.ISHARE_DEAD_ZONE
 */
__COMMON_INLINE uint32_t COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Msk);
    reg = (reg >> COMMON_ISHARE_DZ__ISHARE_DEAD_ZONE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        LO_SLEEP member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_LO_SLEEP__ADDRESS returns the address of member LO_SLEEP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of LO_SLEEP
 */
__COMMON_INLINE uint32_t* __COMMON_LO_SLEEP__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, LO_SLEEP)));
}

/** COMMON_LO_SLEEP__SET() sets LO_SLEEP to given value.
 *
 * When writing to LO_SLEEP, this is mandatory to use.
 *
 * @param value new value for LO_SLEEP
 */
__COMMON_INLINE void COMMON_LO_SLEEP__SET(uint32_t value)
{
    HAL_SET32(__COMMON_LO_SLEEP__ADDRESS(), value);
}

/** COMMON_LO_SLEEP__GET() gets LO_SLEEP's current value.
 *
 * When reading from LO_SLEEP, this is mandatory to use.
 *
 * @return current value of LO_SLEEP
 */
__COMMON_INLINE uint32_t COMMON_LO_SLEEP__GET(void)
{
    return HAL_GET32(__COMMON_LO_SLEEP__ADDRESS());
}

/* --------------------- COMMON.LO_SLEEP.LO_SLEEP_MODE --------------------- */

/**
<pre>
  COMMON.LO_SLEEP.LO_SLEEP_MODE:

    Function not in use.

</pre> */

#define COMMON_LO_SLEEP__LO_SLEEP_MODE__Pos                     0                                                                      /*!< Right-most bit position of lo_sleep_mode in COMMON.LO_SLEEP */
#define COMMON_LO_SLEEP__LO_SLEEP_MODE__Msk                     (0x00000001UL << COMMON_LO_SLEEP__LO_SLEEP_MODE__Pos)                  /*!< Mask for lo_sleep_mode in COMMON.LO_SLEEP */
#define COMMON_LO_SLEEP__LO_SLEEP_MODE__Shift(v)                (((v) << COMMON_LO_SLEEP__LO_SLEEP_MODE__Pos) & COMMON_LO_SLEEP__LO_SLEEP_MODE__Msk) /*!< Shift value 'v' into lo_sleep_mode and mask 'v' to fit it into lo_sleep_mode field */

/** COMMON_LO_SLEEP__LO_SLEEP_MODE__SET() sets LO_SLEEP.LO_SLEEP_MODE to given value.
 *
 * When writing to LO_SLEEP.LO_SLEEP_MODE, this is recommended to use.
 *
 * @param bf_value new value for LO_SLEEP.LO_SLEEP_MODE
 */
__COMMON_INLINE void COMMON_LO_SLEEP__LO_SLEEP_MODE__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_LO_SLEEP__GET();
    reg = (reg & ~COMMON_LO_SLEEP__LO_SLEEP_MODE__Msk);
    reg = (reg | (COMMON_LO_SLEEP__LO_SLEEP_MODE__Shift((uint32_t)bf_value)));
    COMMON_LO_SLEEP__SET(reg);
}

/** COMMON_LO_SLEEP__LO_SLEEP_MODE__GET() gets LO_SLEEP.LO_SLEEP_MODE's current value.
 *
 * When reading from LO_SLEEP.LO_SLEEP_MODE, this is recommended to use.
 *
 * @return current value of LO_SLEEP.LO_SLEEP_MODE
 */
__COMMON_INLINE uint32_t COMMON_LO_SLEEP__LO_SLEEP_MODE__GET(void)
{
    uint32_t reg = COMMON_LO_SLEEP__GET();
    reg = (reg & COMMON_LO_SLEEP__LO_SLEEP_MODE__Msk);
    reg = (reg >> COMMON_LO_SLEEP__LO_SLEEP_MODE__Pos);
    return (uint32_t)reg;
}

/** COMMON_LO_SLEEP__LO_SLEEP_MODE__MODIFY() modifies LO_SLEEP.LO_SLEEP_MODE.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.LO_SLEEP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.LO_SLEEP
 * @param bf_value new value for LO_SLEEP.LO_SLEEP_MODE
 * @return new value of COMMON.LO_SLEEP
 */
__COMMON_INLINE uint32_t COMMON_LO_SLEEP__LO_SLEEP_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_LO_SLEEP__LO_SLEEP_MODE__Msk);
    reg = (reg | (COMMON_LO_SLEEP__LO_SLEEP_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_LO_SLEEP__LO_SLEEP_MODE__EXTRACT() extracts LO_SLEEP.LO_SLEEP_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.LO_SLEEP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.LO_SLEEP
 * @return current value of LO_SLEEP.LO_SLEEP_MODE
 */
__COMMON_INLINE uint32_t COMMON_LO_SLEEP__LO_SLEEP_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_LO_SLEEP__LO_SLEEP_MODE__Msk);
    reg = (reg >> COMMON_LO_SLEEP__LO_SLEEP_MODE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        DIG_SYNC member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_DIG_SYNC__ADDRESS returns the address of member DIG_SYNC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DIG_SYNC
 */
__COMMON_INLINE uint32_t* __COMMON_DIG_SYNC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, DIG_SYNC)));
}

/** COMMON_DIG_SYNC__GET() gets DIG_SYNC's current value.
 *
 * When reading from DIG_SYNC, this is mandatory to use.
 *
 * @return current value of DIG_SYNC
 */
__COMMON_INLINE uint32_t COMMON_DIG_SYNC__GET(void)
{
    return HAL_GET32(__COMMON_DIG_SYNC__ADDRESS());
}

/* --------------------- COMMON.DIG_SYNC.SYNC_IN_RANGE --------------------- */

/**
<pre>
  COMMON.DIG_SYNC.SYNC_IN_RANGE:

    Digital SYNC "in range" status.  The SYNC input can make initial lock to an incoming signal within +/-6.25% of the internal clock frequency.  Once locked, the SYNC function can maintain lock within a +/-12.5% deviation of the internal clock frequency.
    <start table>
    0 "SYNC not locked"
    1 "SYNC locked"
    <end table>

</pre> */

#define COMMON_DIG_SYNC__SYNC_IN_RANGE__Pos                     24                                                                     /*!< Right-most bit position of sync_in_range in COMMON.DIG_SYNC */
#define COMMON_DIG_SYNC__SYNC_IN_RANGE__Msk                     (0x00000001UL << COMMON_DIG_SYNC__SYNC_IN_RANGE__Pos)                  /*!< Mask for sync_in_range in COMMON.DIG_SYNC */
#define COMMON_DIG_SYNC__SYNC_IN_RANGE__Shift(v)                (((v) << COMMON_DIG_SYNC__SYNC_IN_RANGE__Pos) & COMMON_DIG_SYNC__SYNC_IN_RANGE__Msk) /*!< Shift value 'v' into sync_in_range and mask 'v' to fit it into sync_in_range field */

/** COMMON_DIG_SYNC__SYNC_IN_RANGE__GET() gets DIG_SYNC.SYNC_IN_RANGE's current value.
 *
 * When reading from DIG_SYNC.SYNC_IN_RANGE, this is recommended to use.
 *
 * @return current value of DIG_SYNC.SYNC_IN_RANGE
 */
__COMMON_INLINE uint32_t COMMON_DIG_SYNC__SYNC_IN_RANGE__GET(void)
{
    uint32_t reg = COMMON_DIG_SYNC__GET();
    reg = (reg & COMMON_DIG_SYNC__SYNC_IN_RANGE__Msk);
    reg = (reg >> COMMON_DIG_SYNC__SYNC_IN_RANGE__Pos);
    return (uint32_t)reg;
}

/** COMMON_DIG_SYNC__SYNC_IN_RANGE__EXTRACT() extracts DIG_SYNC.SYNC_IN_RANGE.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.DIG_SYNC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.DIG_SYNC
 * @return current value of DIG_SYNC.SYNC_IN_RANGE
 */
__COMMON_INLINE uint32_t COMMON_DIG_SYNC__SYNC_IN_RANGE__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_DIG_SYNC__SYNC_IN_RANGE__Msk);
    reg = (reg >> COMMON_DIG_SYNC__SYNC_IN_RANGE__Pos);
    return (uint32_t)reg;
}

/* ----------------------- COMMON.DIG_SYNC.SYNC_STATE ----------------------- */

/**
<pre>
  COMMON.DIG_SYNC.SYNC_STATE:

    Digital SYNC state
    <start table>
    0 "using internal sync clock"
    1 " phase locking to external sync clock"
    2 "using external sync clock"
    3 "phase locking to internal sync clock"
    <end table>

</pre> */

#define COMMON_DIG_SYNC__SYNC_STATE__Pos                        22                                                                     /*!< Right-most bit position of sync_state in COMMON.DIG_SYNC */
#define COMMON_DIG_SYNC__SYNC_STATE__Msk                        (0x00000003UL << COMMON_DIG_SYNC__SYNC_STATE__Pos)                     /*!< Mask for sync_state in COMMON.DIG_SYNC */
#define COMMON_DIG_SYNC__SYNC_STATE__Shift(v)                   (((v) << COMMON_DIG_SYNC__SYNC_STATE__Pos) & COMMON_DIG_SYNC__SYNC_STATE__Msk) /*!< Shift value 'v' into sync_state and mask 'v' to fit it into sync_state field */

/** COMMON_DIG_SYNC__SYNC_STATE__GET() gets DIG_SYNC.SYNC_STATE's current value.
 *
 * When reading from DIG_SYNC.SYNC_STATE, this is recommended to use.
 *
 * @return current value of DIG_SYNC.SYNC_STATE
 */
__COMMON_INLINE uint32_t COMMON_DIG_SYNC__SYNC_STATE__GET(void)
{
    uint32_t reg = COMMON_DIG_SYNC__GET();
    reg = (reg & COMMON_DIG_SYNC__SYNC_STATE__Msk);
    reg = (reg >> COMMON_DIG_SYNC__SYNC_STATE__Pos);
    return (uint32_t)reg;
}

/** COMMON_DIG_SYNC__SYNC_STATE__EXTRACT() extracts DIG_SYNC.SYNC_STATE.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.DIG_SYNC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.DIG_SYNC
 * @return current value of DIG_SYNC.SYNC_STATE
 */
__COMMON_INLINE uint32_t COMMON_DIG_SYNC__SYNC_STATE__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_DIG_SYNC__SYNC_STATE__Msk);
    reg = (reg >> COMMON_DIG_SYNC__SYNC_STATE__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.DIG_SYNC.SYNC_IN_PERIOD --------------------- */

/**
<pre>
  COMMON.DIG_SYNC.SYNC_IN_PERIOD:

    Measured incoming period on SYNC input.
    LSB = 5ns, Range = 0 to 10.235us

</pre> */

#define COMMON_DIG_SYNC__SYNC_IN_PERIOD__Pos                    11                                                                     /*!< Right-most bit position of sync_in_period in COMMON.DIG_SYNC */
#define COMMON_DIG_SYNC__SYNC_IN_PERIOD__Msk                    (0x000007FFUL << COMMON_DIG_SYNC__SYNC_IN_PERIOD__Pos)                 /*!< Mask for sync_in_period in COMMON.DIG_SYNC */
#define COMMON_DIG_SYNC__SYNC_IN_PERIOD__Shift(v)               (((v) << COMMON_DIG_SYNC__SYNC_IN_PERIOD__Pos) & COMMON_DIG_SYNC__SYNC_IN_PERIOD__Msk) /*!< Shift value 'v' into sync_in_period and mask 'v' to fit it into sync_in_period field */

/** COMMON_DIG_SYNC__SYNC_IN_PERIOD__GET() gets DIG_SYNC.SYNC_IN_PERIOD's current value.
 *
 * When reading from DIG_SYNC.SYNC_IN_PERIOD, this is recommended to use.
 *
 * @return current value of DIG_SYNC.SYNC_IN_PERIOD
 */
__COMMON_INLINE uint32_t COMMON_DIG_SYNC__SYNC_IN_PERIOD__GET(void)
{
    uint32_t reg = COMMON_DIG_SYNC__GET();
    reg = (reg & COMMON_DIG_SYNC__SYNC_IN_PERIOD__Msk);
    reg = (reg >> COMMON_DIG_SYNC__SYNC_IN_PERIOD__Pos);
    return (uint32_t)reg;
}

/** COMMON_DIG_SYNC__SYNC_IN_PERIOD__EXTRACT() extracts DIG_SYNC.SYNC_IN_PERIOD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.DIG_SYNC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.DIG_SYNC
 * @return current value of DIG_SYNC.SYNC_IN_PERIOD
 */
__COMMON_INLINE uint32_t COMMON_DIG_SYNC__SYNC_IN_PERIOD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_DIG_SYNC__SYNC_IN_PERIOD__Msk);
    reg = (reg >> COMMON_DIG_SYNC__SYNC_IN_PERIOD__Pos);
    return (uint32_t)reg;
}

/* -------------------- COMMON.DIG_SYNC.SYNC_FLY_PERIOD -------------------- */

/**
<pre>
  COMMON.DIG_SYNC.SYNC_FLY_PERIOD:

    Current SYNC flywheel period, will match incoming period when lock achieved.
    LSB = 5ns, Range = 0 to 10.235us

</pre> */

#define COMMON_DIG_SYNC__SYNC_FLY_PERIOD__Pos                   0                                                                      /*!< Right-most bit position of sync_fly_period in COMMON.DIG_SYNC */
#define COMMON_DIG_SYNC__SYNC_FLY_PERIOD__Msk                   (0x000007FFUL << COMMON_DIG_SYNC__SYNC_FLY_PERIOD__Pos)                /*!< Mask for sync_fly_period in COMMON.DIG_SYNC */
#define COMMON_DIG_SYNC__SYNC_FLY_PERIOD__Shift(v)              (((v) << COMMON_DIG_SYNC__SYNC_FLY_PERIOD__Pos) & COMMON_DIG_SYNC__SYNC_FLY_PERIOD__Msk) /*!< Shift value 'v' into sync_fly_period and mask 'v' to fit it into sync_fly_period field */

/** COMMON_DIG_SYNC__SYNC_FLY_PERIOD__GET() gets DIG_SYNC.SYNC_FLY_PERIOD's current value.
 *
 * When reading from DIG_SYNC.SYNC_FLY_PERIOD, this is recommended to use.
 *
 * @return current value of DIG_SYNC.SYNC_FLY_PERIOD
 */
__COMMON_INLINE uint32_t COMMON_DIG_SYNC__SYNC_FLY_PERIOD__GET(void)
{
    uint32_t reg = COMMON_DIG_SYNC__GET();
    reg = (reg & COMMON_DIG_SYNC__SYNC_FLY_PERIOD__Msk);
    reg = (reg >> COMMON_DIG_SYNC__SYNC_FLY_PERIOD__Pos);
    return (uint32_t)reg;
}

/** COMMON_DIG_SYNC__SYNC_FLY_PERIOD__EXTRACT() extracts DIG_SYNC.SYNC_FLY_PERIOD.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.DIG_SYNC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.DIG_SYNC
 * @return current value of DIG_SYNC.SYNC_FLY_PERIOD
 */
__COMMON_INLINE uint32_t COMMON_DIG_SYNC__SYNC_FLY_PERIOD__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_DIG_SYNC__SYNC_FLY_PERIOD__Msk);
    reg = (reg >> COMMON_DIG_SYNC__SYNC_FLY_PERIOD__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        VDAC_CFG member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_VDAC_CFG__ADDRESS returns the address of member VDAC_CFG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VDAC_CFG
 */
__COMMON_INLINE uint32_t* __COMMON_VDAC_CFG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VDAC_CFG)));
}

/** COMMON_VDAC_CFG__SET() sets VDAC_CFG to given value.
 *
 * When writing to VDAC_CFG, this is mandatory to use.
 *
 * @param value new value for VDAC_CFG
 */
__COMMON_INLINE void COMMON_VDAC_CFG__SET(uint32_t value)
{
    HAL_SET32(__COMMON_VDAC_CFG__ADDRESS(), value);
}

/** COMMON_VDAC_CFG__GET() gets VDAC_CFG's current value.
 *
 * When reading from VDAC_CFG, this is mandatory to use.
 *
 * @return current value of VDAC_CFG
 */
__COMMON_INLINE uint32_t COMMON_VDAC_CFG__GET(void)
{
    return HAL_GET32(__COMMON_VDAC_CFG__ADDRESS());
}

/* ----------------------- COMMON.VDAC_CFG.VDAC_SHIFT ----------------------- */

/**
<pre>
  COMMON.VDAC_CFG.VDAC_SHIFT:

    Left shift applied to Voltage DAC 16-bit input word after application of vdac_mask but before any other operations.  During the shift, right-side bits are filled with 0's.  Note that ultimately only the upper 8 bits of the 16-bit word are used to control the DAC output.

</pre> */

#define COMMON_VDAC_CFG__VDAC_SHIFT__Pos                        15                                                                     /*!< Right-most bit position of vdac_shift in COMMON.VDAC_CFG */
#define COMMON_VDAC_CFG__VDAC_SHIFT__Msk                        (0x0000000FUL << COMMON_VDAC_CFG__VDAC_SHIFT__Pos)                     /*!< Mask for vdac_shift in COMMON.VDAC_CFG */
#define COMMON_VDAC_CFG__VDAC_SHIFT__Shift(v)                   (((v) << COMMON_VDAC_CFG__VDAC_SHIFT__Pos) & COMMON_VDAC_CFG__VDAC_SHIFT__Msk) /*!< Shift value 'v' into vdac_shift and mask 'v' to fit it into vdac_shift field */

/** COMMON_VDAC_CFG__VDAC_SHIFT__SET() sets VDAC_CFG.VDAC_SHIFT to given value.
 *
 * When writing to VDAC_CFG.VDAC_SHIFT, this is recommended to use.
 *
 * @param bf_value new value for VDAC_CFG.VDAC_SHIFT
 */
__COMMON_INLINE void COMMON_VDAC_CFG__VDAC_SHIFT__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VDAC_CFG__GET();
    reg = (reg & ~COMMON_VDAC_CFG__VDAC_SHIFT__Msk);
    reg = (reg | (COMMON_VDAC_CFG__VDAC_SHIFT__Shift((uint32_t)bf_value)));
    COMMON_VDAC_CFG__SET(reg);
}

/** COMMON_VDAC_CFG__VDAC_SHIFT__GET() gets VDAC_CFG.VDAC_SHIFT's current value.
 *
 * When reading from VDAC_CFG.VDAC_SHIFT, this is recommended to use.
 *
 * @return current value of VDAC_CFG.VDAC_SHIFT
 */
__COMMON_INLINE uint32_t COMMON_VDAC_CFG__VDAC_SHIFT__GET(void)
{
    uint32_t reg = COMMON_VDAC_CFG__GET();
    reg = (reg & COMMON_VDAC_CFG__VDAC_SHIFT__Msk);
    reg = (reg >> COMMON_VDAC_CFG__VDAC_SHIFT__Pos);
    return (uint32_t)reg;
}

/** COMMON_VDAC_CFG__VDAC_SHIFT__MODIFY() modifies VDAC_CFG.VDAC_SHIFT.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VDAC_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VDAC_CFG
 * @param bf_value new value for VDAC_CFG.VDAC_SHIFT
 * @return new value of COMMON.VDAC_CFG
 */
__COMMON_INLINE uint32_t COMMON_VDAC_CFG__VDAC_SHIFT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VDAC_CFG__VDAC_SHIFT__Msk);
    reg = (reg | (COMMON_VDAC_CFG__VDAC_SHIFT__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VDAC_CFG__VDAC_SHIFT__EXTRACT() extracts VDAC_CFG.VDAC_SHIFT.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VDAC_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VDAC_CFG
 * @return current value of VDAC_CFG.VDAC_SHIFT
 */
__COMMON_INLINE uint32_t COMMON_VDAC_CFG__VDAC_SHIFT__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VDAC_CFG__VDAC_SHIFT__Msk);
    reg = (reg >> COMMON_VDAC_CFG__VDAC_SHIFT__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.VDAC_CFG.VDAC_OFFSET ---------------------- */

/**
<pre>
  COMMON.VDAC_CFG.VDAC_OFFSET:

    Offset added to Voltage DAC 16-bit input word.

</pre> */

#define COMMON_VDAC_CFG__VDAC_OFFSET__Pos                       0                                                                      /*!< Right-most bit position of vdac_offset in COMMON.VDAC_CFG */
#define COMMON_VDAC_CFG__VDAC_OFFSET__Msk                       (0x00007FFFUL << COMMON_VDAC_CFG__VDAC_OFFSET__Pos)                    /*!< Mask for vdac_offset in COMMON.VDAC_CFG */
#define COMMON_VDAC_CFG__VDAC_OFFSET__Shift(v)                  (((v) << COMMON_VDAC_CFG__VDAC_OFFSET__Pos) & COMMON_VDAC_CFG__VDAC_OFFSET__Msk) /*!< Shift value 'v' into vdac_offset and mask 'v' to fit it into vdac_offset field */

/** COMMON_VDAC_CFG__VDAC_OFFSET__SET() sets VDAC_CFG.VDAC_OFFSET to given value.
 *
 * When writing to VDAC_CFG.VDAC_OFFSET, this is recommended to use.
 *
 * @param bf_value new value for VDAC_CFG.VDAC_OFFSET
 */
__COMMON_INLINE void COMMON_VDAC_CFG__VDAC_OFFSET__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VDAC_CFG__GET();
    reg = (reg & ~COMMON_VDAC_CFG__VDAC_OFFSET__Msk);
    reg = (reg | (COMMON_VDAC_CFG__VDAC_OFFSET__Shift((uint32_t)bf_value)));
    COMMON_VDAC_CFG__SET(reg);
}

/** COMMON_VDAC_CFG__VDAC_OFFSET__GET() gets VDAC_CFG.VDAC_OFFSET's current value.
 *
 * When reading from VDAC_CFG.VDAC_OFFSET, this is recommended to use.
 *
 * @return current value of VDAC_CFG.VDAC_OFFSET
 */
__COMMON_INLINE uint32_t COMMON_VDAC_CFG__VDAC_OFFSET__GET(void)
{
    uint32_t reg = COMMON_VDAC_CFG__GET();
    reg = (reg & COMMON_VDAC_CFG__VDAC_OFFSET__Msk);
    reg = (reg >> COMMON_VDAC_CFG__VDAC_OFFSET__Pos);
    return (uint32_t)reg;
}

/** COMMON_VDAC_CFG__VDAC_OFFSET__MODIFY() modifies VDAC_CFG.VDAC_OFFSET.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VDAC_CFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VDAC_CFG
 * @param bf_value new value for VDAC_CFG.VDAC_OFFSET
 * @return new value of COMMON.VDAC_CFG
 */
__COMMON_INLINE uint32_t COMMON_VDAC_CFG__VDAC_OFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VDAC_CFG__VDAC_OFFSET__Msk);
    reg = (reg | (COMMON_VDAC_CFG__VDAC_OFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VDAC_CFG__VDAC_OFFSET__EXTRACT() extracts VDAC_CFG.VDAC_OFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VDAC_CFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VDAC_CFG
 * @return current value of VDAC_CFG.VDAC_OFFSET
 */
__COMMON_INLINE uint32_t COMMON_VDAC_CFG__VDAC_OFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VDAC_CFG__VDAC_OFFSET__Msk);
    reg = (reg >> COMMON_VDAC_CFG__VDAC_OFFSET__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         VDAC_EN member of COMMON_t                         */
/* -------------------------------------------------------------------------- */

/** __COMMON_VDAC_EN__ADDRESS returns the address of member VDAC_EN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VDAC_EN
 */
__COMMON_INLINE uint32_t* __COMMON_VDAC_EN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VDAC_EN)));
}

/** COMMON_VDAC_EN__SET() sets VDAC_EN to given value.
 *
 * When writing to VDAC_EN, this is mandatory to use.
 *
 * @param value new value for VDAC_EN
 */
__COMMON_INLINE void COMMON_VDAC_EN__SET(uint32_t value)
{
    HAL_SET32(__COMMON_VDAC_EN__ADDRESS(), value);
}

/** COMMON_VDAC_EN__GET() gets VDAC_EN's current value.
 *
 * When reading from VDAC_EN, this is mandatory to use.
 *
 * @return current value of VDAC_EN
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__GET(void)
{
    return HAL_GET32(__COMMON_VDAC_EN__ADDRESS());
}

/* ---------------------- COMMON.VDAC_EN.VDAC_OUT_SIGN ---------------------- */

/**
<pre>
  COMMON.VDAC_EN.VDAC_OUT_SIGN:

    Voltage DAC output word format
    <start table>
    0 unsigned
    1 signed
    <end table>

</pre> */

#define COMMON_VDAC_EN__VDAC_OUT_SIGN__Pos                      3                                                                      /*!< Right-most bit position of vdac_out_sign in COMMON.VDAC_EN */
#define COMMON_VDAC_EN__VDAC_OUT_SIGN__Msk                      (0x00000001UL << COMMON_VDAC_EN__VDAC_OUT_SIGN__Pos)                   /*!< Mask for vdac_out_sign in COMMON.VDAC_EN */
#define COMMON_VDAC_EN__VDAC_OUT_SIGN__Shift(v)                 (((v) << COMMON_VDAC_EN__VDAC_OUT_SIGN__Pos) & COMMON_VDAC_EN__VDAC_OUT_SIGN__Msk) /*!< Shift value 'v' into vdac_out_sign and mask 'v' to fit it into vdac_out_sign field */

/** COMMON_VDAC_EN__VDAC_OUT_SIGN__SET() sets VDAC_EN.VDAC_OUT_SIGN to given value.
 *
 * When writing to VDAC_EN.VDAC_OUT_SIGN, this is recommended to use.
 *
 * @param bf_value new value for VDAC_EN.VDAC_OUT_SIGN
 */
__COMMON_INLINE void COMMON_VDAC_EN__VDAC_OUT_SIGN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VDAC_EN__GET();
    reg = (reg & ~COMMON_VDAC_EN__VDAC_OUT_SIGN__Msk);
    reg = (reg | (COMMON_VDAC_EN__VDAC_OUT_SIGN__Shift((uint32_t)bf_value)));
    COMMON_VDAC_EN__SET(reg);
}

/** COMMON_VDAC_EN__VDAC_OUT_SIGN__GET() gets VDAC_EN.VDAC_OUT_SIGN's current value.
 *
 * When reading from VDAC_EN.VDAC_OUT_SIGN, this is recommended to use.
 *
 * @return current value of VDAC_EN.VDAC_OUT_SIGN
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_OUT_SIGN__GET(void)
{
    uint32_t reg = COMMON_VDAC_EN__GET();
    reg = (reg & COMMON_VDAC_EN__VDAC_OUT_SIGN__Msk);
    reg = (reg >> COMMON_VDAC_EN__VDAC_OUT_SIGN__Pos);
    return (uint32_t)reg;
}

/** COMMON_VDAC_EN__VDAC_OUT_SIGN__MODIFY() modifies VDAC_EN.VDAC_OUT_SIGN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VDAC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VDAC_EN
 * @param bf_value new value for VDAC_EN.VDAC_OUT_SIGN
 * @return new value of COMMON.VDAC_EN
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_OUT_SIGN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VDAC_EN__VDAC_OUT_SIGN__Msk);
    reg = (reg | (COMMON_VDAC_EN__VDAC_OUT_SIGN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VDAC_EN__VDAC_OUT_SIGN__EXTRACT() extracts VDAC_EN.VDAC_OUT_SIGN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VDAC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VDAC_EN
 * @return current value of VDAC_EN.VDAC_OUT_SIGN
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_OUT_SIGN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VDAC_EN__VDAC_OUT_SIGN__Msk);
    reg = (reg >> COMMON_VDAC_EN__VDAC_OUT_SIGN__Pos);
    return (uint32_t)reg;
}

/* -------------------- COMMON.VDAC_EN.VDAC_IN_UNSIGNED -------------------- */

/**
<pre>
  COMMON.VDAC_EN.VDAC_IN_UNSIGNED:

    Voltage DAC input word format
    <start table>
    0 signed
    1 unsigned
    <end table>

</pre> */

#define COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Pos                   2                                                                      /*!< Right-most bit position of vdac_in_unsigned in COMMON.VDAC_EN */
#define COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Msk                   (0x00000001UL << COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Pos)                /*!< Mask for vdac_in_unsigned in COMMON.VDAC_EN */
#define COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Shift(v)              (((v) << COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Pos) & COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Msk) /*!< Shift value 'v' into vdac_in_unsigned and mask 'v' to fit it into vdac_in_unsigned field */

/** COMMON_VDAC_EN__VDAC_IN_UNSIGNED__SET() sets VDAC_EN.VDAC_IN_UNSIGNED to given value.
 *
 * When writing to VDAC_EN.VDAC_IN_UNSIGNED, this is recommended to use.
 *
 * @param bf_value new value for VDAC_EN.VDAC_IN_UNSIGNED
 */
__COMMON_INLINE void COMMON_VDAC_EN__VDAC_IN_UNSIGNED__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VDAC_EN__GET();
    reg = (reg & ~COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Msk);
    reg = (reg | (COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Shift((uint32_t)bf_value)));
    COMMON_VDAC_EN__SET(reg);
}

/** COMMON_VDAC_EN__VDAC_IN_UNSIGNED__GET() gets VDAC_EN.VDAC_IN_UNSIGNED's current value.
 *
 * When reading from VDAC_EN.VDAC_IN_UNSIGNED, this is recommended to use.
 *
 * @return current value of VDAC_EN.VDAC_IN_UNSIGNED
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_IN_UNSIGNED__GET(void)
{
    uint32_t reg = COMMON_VDAC_EN__GET();
    reg = (reg & COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Msk);
    reg = (reg >> COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Pos);
    return (uint32_t)reg;
}

/** COMMON_VDAC_EN__VDAC_IN_UNSIGNED__MODIFY() modifies VDAC_EN.VDAC_IN_UNSIGNED.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VDAC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VDAC_EN
 * @param bf_value new value for VDAC_EN.VDAC_IN_UNSIGNED
 * @return new value of COMMON.VDAC_EN
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_IN_UNSIGNED__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Msk);
    reg = (reg | (COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VDAC_EN__VDAC_IN_UNSIGNED__EXTRACT() extracts VDAC_EN.VDAC_IN_UNSIGNED.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VDAC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VDAC_EN
 * @return current value of VDAC_EN.VDAC_IN_UNSIGNED
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_IN_UNSIGNED__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Msk);
    reg = (reg >> COMMON_VDAC_EN__VDAC_IN_UNSIGNED__Pos);
    return (uint32_t)reg;
}

/* --------------------- COMMON.VDAC_EN.VDAC_NEG_IGNORE --------------------- */

/**
<pre>
  COMMON.VDAC_EN.VDAC_NEG_IGNORE:

    Voltage DAC negative input clamp enable.  Applied to shifted data word.
    <start table>
    0 "Allow negative input word"
    1 "Clamp negative input to 0"
    <end table>

</pre> */

#define COMMON_VDAC_EN__VDAC_NEG_IGNORE__Pos                    1                                                                      /*!< Right-most bit position of vdac_neg_ignore in COMMON.VDAC_EN */
#define COMMON_VDAC_EN__VDAC_NEG_IGNORE__Msk                    (0x00000001UL << COMMON_VDAC_EN__VDAC_NEG_IGNORE__Pos)                 /*!< Mask for vdac_neg_ignore in COMMON.VDAC_EN */
#define COMMON_VDAC_EN__VDAC_NEG_IGNORE__Shift(v)               (((v) << COMMON_VDAC_EN__VDAC_NEG_IGNORE__Pos) & COMMON_VDAC_EN__VDAC_NEG_IGNORE__Msk) /*!< Shift value 'v' into vdac_neg_ignore and mask 'v' to fit it into vdac_neg_ignore field */

/** COMMON_VDAC_EN__VDAC_NEG_IGNORE__SET() sets VDAC_EN.VDAC_NEG_IGNORE to given value.
 *
 * When writing to VDAC_EN.VDAC_NEG_IGNORE, this is recommended to use.
 *
 * @param bf_value new value for VDAC_EN.VDAC_NEG_IGNORE
 */
__COMMON_INLINE void COMMON_VDAC_EN__VDAC_NEG_IGNORE__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VDAC_EN__GET();
    reg = (reg & ~COMMON_VDAC_EN__VDAC_NEG_IGNORE__Msk);
    reg = (reg | (COMMON_VDAC_EN__VDAC_NEG_IGNORE__Shift((uint32_t)bf_value)));
    COMMON_VDAC_EN__SET(reg);
}

/** COMMON_VDAC_EN__VDAC_NEG_IGNORE__GET() gets VDAC_EN.VDAC_NEG_IGNORE's current value.
 *
 * When reading from VDAC_EN.VDAC_NEG_IGNORE, this is recommended to use.
 *
 * @return current value of VDAC_EN.VDAC_NEG_IGNORE
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_NEG_IGNORE__GET(void)
{
    uint32_t reg = COMMON_VDAC_EN__GET();
    reg = (reg & COMMON_VDAC_EN__VDAC_NEG_IGNORE__Msk);
    reg = (reg >> COMMON_VDAC_EN__VDAC_NEG_IGNORE__Pos);
    return (uint32_t)reg;
}

/** COMMON_VDAC_EN__VDAC_NEG_IGNORE__MODIFY() modifies VDAC_EN.VDAC_NEG_IGNORE.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VDAC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VDAC_EN
 * @param bf_value new value for VDAC_EN.VDAC_NEG_IGNORE
 * @return new value of COMMON.VDAC_EN
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_NEG_IGNORE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VDAC_EN__VDAC_NEG_IGNORE__Msk);
    reg = (reg | (COMMON_VDAC_EN__VDAC_NEG_IGNORE__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VDAC_EN__VDAC_NEG_IGNORE__EXTRACT() extracts VDAC_EN.VDAC_NEG_IGNORE.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VDAC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VDAC_EN
 * @return current value of VDAC_EN.VDAC_NEG_IGNORE
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_NEG_IGNORE__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VDAC_EN__VDAC_NEG_IGNORE__Msk);
    reg = (reg >> COMMON_VDAC_EN__VDAC_NEG_IGNORE__Pos);
    return (uint32_t)reg;
}

/* ------------------------- COMMON.VDAC_EN.VDAC_EN ------------------------- */

/**
<pre>
  COMMON.VDAC_EN.VDAC_EN:

    Voltage DAC analog block enable
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define COMMON_VDAC_EN__VDAC_EN__Pos                            0                                                                      /*!< Right-most bit position of vdac_en in COMMON.VDAC_EN */
#define COMMON_VDAC_EN__VDAC_EN__Msk                            (0x00000001UL << COMMON_VDAC_EN__VDAC_EN__Pos)                         /*!< Mask for vdac_en in COMMON.VDAC_EN */
#define COMMON_VDAC_EN__VDAC_EN__Shift(v)                       (((v) << COMMON_VDAC_EN__VDAC_EN__Pos) & COMMON_VDAC_EN__VDAC_EN__Msk) /*!< Shift value 'v' into vdac_en and mask 'v' to fit it into vdac_en field */

/** COMMON_VDAC_EN__VDAC_EN__SET() sets VDAC_EN.VDAC_EN to given value.
 *
 * When writing to VDAC_EN.VDAC_EN, this is recommended to use.
 *
 * @param bf_value new value for VDAC_EN.VDAC_EN
 */
__COMMON_INLINE void COMMON_VDAC_EN__VDAC_EN__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VDAC_EN__GET();
    reg = (reg & ~COMMON_VDAC_EN__VDAC_EN__Msk);
    reg = (reg | (COMMON_VDAC_EN__VDAC_EN__Shift((uint32_t)bf_value)));
    COMMON_VDAC_EN__SET(reg);
}

/** COMMON_VDAC_EN__VDAC_EN__GET() gets VDAC_EN.VDAC_EN's current value.
 *
 * When reading from VDAC_EN.VDAC_EN, this is recommended to use.
 *
 * @return current value of VDAC_EN.VDAC_EN
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_EN__GET(void)
{
    uint32_t reg = COMMON_VDAC_EN__GET();
    reg = (reg & COMMON_VDAC_EN__VDAC_EN__Msk);
    reg = (reg >> COMMON_VDAC_EN__VDAC_EN__Pos);
    return (uint32_t)reg;
}

/** COMMON_VDAC_EN__VDAC_EN__MODIFY() modifies VDAC_EN.VDAC_EN.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VDAC_EN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VDAC_EN
 * @param bf_value new value for VDAC_EN.VDAC_EN
 * @return new value of COMMON.VDAC_EN
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VDAC_EN__VDAC_EN__Msk);
    reg = (reg | (COMMON_VDAC_EN__VDAC_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VDAC_EN__VDAC_EN__EXTRACT() extracts VDAC_EN.VDAC_EN.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VDAC_EN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VDAC_EN
 * @return current value of VDAC_EN.VDAC_EN
 */
__COMMON_INLINE uint32_t COMMON_VDAC_EN__VDAC_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VDAC_EN__VDAC_EN__Msk);
    reg = (reg >> COMMON_VDAC_EN__VDAC_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        VDAC_MASK member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_VDAC_MASK__ADDRESS returns the address of member VDAC_MASK.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VDAC_MASK
 */
__COMMON_INLINE uint32_t* __COMMON_VDAC_MASK__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VDAC_MASK)));
}

/** COMMON_VDAC_MASK__SET() sets VDAC_MASK to given value.
 *
 * When writing to VDAC_MASK, this is mandatory to use.
 *
 * @param value new value for VDAC_MASK
 */
__COMMON_INLINE void COMMON_VDAC_MASK__SET(uint32_t value)
{
    HAL_SET32(__COMMON_VDAC_MASK__ADDRESS(), value);
}

/** COMMON_VDAC_MASK__GET() gets VDAC_MASK's current value.
 *
 * When reading from VDAC_MASK, this is mandatory to use.
 *
 * @return current value of VDAC_MASK
 */
__COMMON_INLINE uint32_t COMMON_VDAC_MASK__GET(void)
{
    return HAL_GET32(__COMMON_VDAC_MASK__ADDRESS());
}

/* ----------------------- COMMON.VDAC_MASK.VDAC_MASK ----------------------- */

/**
<pre>
  COMMON.VDAC_MASK.VDAC_MASK:

    Active high mask applied to the Voltage DAC 16-bit input word to zero out selected bits.  Applied as,
    <start table>
    "vdac_in_masked[15:0] = vdac_in[15:0] & ~vdac_mask[15:0]"
    <end table>

</pre> */

#define COMMON_VDAC_MASK__VDAC_MASK__Pos                        0                                                                      /*!< Right-most bit position of vdac_mask in COMMON.VDAC_MASK */
#define COMMON_VDAC_MASK__VDAC_MASK__Msk                        (0x0000FFFFUL << COMMON_VDAC_MASK__VDAC_MASK__Pos)                     /*!< Mask for vdac_mask in COMMON.VDAC_MASK */
#define COMMON_VDAC_MASK__VDAC_MASK__Shift(v)                   (((v) << COMMON_VDAC_MASK__VDAC_MASK__Pos) & COMMON_VDAC_MASK__VDAC_MASK__Msk) /*!< Shift value 'v' into vdac_mask and mask 'v' to fit it into vdac_mask field */

/** COMMON_VDAC_MASK__VDAC_MASK__SET() sets VDAC_MASK.VDAC_MASK to given value.
 *
 * When writing to VDAC_MASK.VDAC_MASK, this is recommended to use.
 *
 * @param bf_value new value for VDAC_MASK.VDAC_MASK
 */
__COMMON_INLINE void COMMON_VDAC_MASK__VDAC_MASK__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_VDAC_MASK__GET();
    reg = (reg & ~COMMON_VDAC_MASK__VDAC_MASK__Msk);
    reg = (reg | (COMMON_VDAC_MASK__VDAC_MASK__Shift((uint32_t)bf_value)));
    COMMON_VDAC_MASK__SET(reg);
}

/** COMMON_VDAC_MASK__VDAC_MASK__GET() gets VDAC_MASK.VDAC_MASK's current value.
 *
 * When reading from VDAC_MASK.VDAC_MASK, this is recommended to use.
 *
 * @return current value of VDAC_MASK.VDAC_MASK
 */
__COMMON_INLINE uint32_t COMMON_VDAC_MASK__VDAC_MASK__GET(void)
{
    uint32_t reg = COMMON_VDAC_MASK__GET();
    reg = (reg & COMMON_VDAC_MASK__VDAC_MASK__Msk);
    reg = (reg >> COMMON_VDAC_MASK__VDAC_MASK__Pos);
    return (uint32_t)reg;
}

/** COMMON_VDAC_MASK__VDAC_MASK__MODIFY() modifies VDAC_MASK.VDAC_MASK.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.VDAC_MASK.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.VDAC_MASK
 * @param bf_value new value for VDAC_MASK.VDAC_MASK
 * @return new value of COMMON.VDAC_MASK
 */
__COMMON_INLINE uint32_t COMMON_VDAC_MASK__VDAC_MASK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_VDAC_MASK__VDAC_MASK__Msk);
    reg = (reg | (COMMON_VDAC_MASK__VDAC_MASK__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_VDAC_MASK__VDAC_MASK__EXTRACT() extracts VDAC_MASK.VDAC_MASK.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VDAC_MASK.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VDAC_MASK
 * @return current value of VDAC_MASK.VDAC_MASK
 */
__COMMON_INLINE uint32_t COMMON_VDAC_MASK__VDAC_MASK__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VDAC_MASK__VDAC_MASK__Msk);
    reg = (reg >> COMMON_VDAC_MASK__VDAC_MASK__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        VDAC_DIG member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_VDAC_DIG__ADDRESS returns the address of member VDAC_DIG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VDAC_DIG
 */
__COMMON_INLINE uint32_t* __COMMON_VDAC_DIG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, VDAC_DIG)));
}

/** COMMON_VDAC_DIG__GET() gets VDAC_DIG's current value.
 *
 * When reading from VDAC_DIG, this is mandatory to use.
 *
 * @return current value of VDAC_DIG
 */
__COMMON_INLINE uint32_t COMMON_VDAC_DIG__GET(void)
{
    return HAL_GET32(__COMMON_VDAC_DIG__ADDRESS());
}

/* ------------------------ COMMON.VDAC_DIG.VDAC_DIG ------------------------ */

/**
<pre>
  COMMON.VDAC_DIG.VDAC_DIG:

    Voltage DAC output word.

</pre> */

#define COMMON_VDAC_DIG__VDAC_DIG__Pos                          0                                                                      /*!< Right-most bit position of vdac_dig in COMMON.VDAC_DIG */
#define COMMON_VDAC_DIG__VDAC_DIG__Msk                          (0x000000FFUL << COMMON_VDAC_DIG__VDAC_DIG__Pos)                       /*!< Mask for vdac_dig in COMMON.VDAC_DIG */
#define COMMON_VDAC_DIG__VDAC_DIG__Shift(v)                     (((v) << COMMON_VDAC_DIG__VDAC_DIG__Pos) & COMMON_VDAC_DIG__VDAC_DIG__Msk) /*!< Shift value 'v' into vdac_dig and mask 'v' to fit it into vdac_dig field */

/** COMMON_VDAC_DIG__VDAC_DIG__GET() gets VDAC_DIG.VDAC_DIG's current value.
 *
 * When reading from VDAC_DIG.VDAC_DIG, this is recommended to use.
 *
 * @return current value of VDAC_DIG.VDAC_DIG
 */
__COMMON_INLINE uint32_t COMMON_VDAC_DIG__VDAC_DIG__GET(void)
{
    uint32_t reg = COMMON_VDAC_DIG__GET();
    reg = (reg & COMMON_VDAC_DIG__VDAC_DIG__Msk);
    reg = (reg >> COMMON_VDAC_DIG__VDAC_DIG__Pos);
    return (uint32_t)reg;
}

/** COMMON_VDAC_DIG__VDAC_DIG__EXTRACT() extracts VDAC_DIG.VDAC_DIG.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.VDAC_DIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.VDAC_DIG
 * @return current value of VDAC_DIG.VDAC_DIG
 */
__COMMON_INLINE uint32_t COMMON_VDAC_DIG__VDAC_DIG__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_VDAC_DIG__VDAC_DIG__Msk);
    reg = (reg >> COMMON_VDAC_DIG__VDAC_DIG__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        FW_RESET member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_FW_RESET__ADDRESS returns the address of member FW_RESET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FW_RESET
 */
__COMMON_INLINE uint32_t* __COMMON_FW_RESET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, FW_RESET)));
}

/** COMMON_FW_RESET__SET() sets FW_RESET to given value.
 *
 * When writing to FW_RESET, this is mandatory to use.
 *
 * @param value new value for FW_RESET
 */
__COMMON_INLINE void COMMON_FW_RESET__SET(uint32_t value)
{
    HAL_SET32(__COMMON_FW_RESET__ADDRESS(), value);
}

/** COMMON_FW_RESET__GET() gets FW_RESET's current value.
 *
 * When reading from FW_RESET, this is mandatory to use.
 *
 * @return current value of FW_RESET
 */
__COMMON_INLINE uint32_t COMMON_FW_RESET__GET(void)
{
    return HAL_GET32(__COMMON_FW_RESET__ADDRESS());
}

/* ------------------------ COMMON.FW_RESET.FW_RESET ------------------------ */

/**
<pre>
  COMMON.FW_RESET.FW_RESET:

    Controller reset.  Setting this register high initiates the equivalent of a power on reset to all controller functions except the CPU debugger access port when the debugger port has been enabled via the XADDR1 pin at powerup.
    <start table>
    0 "normal operation"
    1 "reset chip"
    <end table>

</pre> */

#define COMMON_FW_RESET__FW_RESET__Pos                          0                                                                      /*!< Right-most bit position of fw_reset in COMMON.FW_RESET */
#define COMMON_FW_RESET__FW_RESET__Msk                          (0x00000001UL << COMMON_FW_RESET__FW_RESET__Pos)                       /*!< Mask for fw_reset in COMMON.FW_RESET */
#define COMMON_FW_RESET__FW_RESET__Shift(v)                     (((v) << COMMON_FW_RESET__FW_RESET__Pos) & COMMON_FW_RESET__FW_RESET__Msk) /*!< Shift value 'v' into fw_reset and mask 'v' to fit it into fw_reset field */

/** COMMON_FW_RESET__FW_RESET__SET() sets FW_RESET.FW_RESET to given value.
 *
 * When writing to FW_RESET.FW_RESET, this is recommended to use.
 *
 * @param bf_value new value for FW_RESET.FW_RESET
 */
__COMMON_INLINE void COMMON_FW_RESET__FW_RESET__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FW_RESET__GET();
    reg = (reg & ~COMMON_FW_RESET__FW_RESET__Msk);
    reg = (reg | (COMMON_FW_RESET__FW_RESET__Shift((uint32_t)bf_value)));
    COMMON_FW_RESET__SET(reg);
}

/** COMMON_FW_RESET__FW_RESET__GET() gets FW_RESET.FW_RESET's current value.
 *
 * When reading from FW_RESET.FW_RESET, this is recommended to use.
 *
 * @return current value of FW_RESET.FW_RESET
 */
__COMMON_INLINE uint32_t COMMON_FW_RESET__FW_RESET__GET(void)
{
    uint32_t reg = COMMON_FW_RESET__GET();
    reg = (reg & COMMON_FW_RESET__FW_RESET__Msk);
    reg = (reg >> COMMON_FW_RESET__FW_RESET__Pos);
    return (uint32_t)reg;
}

/** COMMON_FW_RESET__FW_RESET__MODIFY() modifies FW_RESET.FW_RESET.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FW_RESET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FW_RESET
 * @param bf_value new value for FW_RESET.FW_RESET
 * @return new value of COMMON.FW_RESET
 */
__COMMON_INLINE uint32_t COMMON_FW_RESET__FW_RESET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FW_RESET__FW_RESET__Msk);
    reg = (reg | (COMMON_FW_RESET__FW_RESET__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FW_RESET__FW_RESET__EXTRACT() extracts FW_RESET.FW_RESET.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FW_RESET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FW_RESET
 * @return current value of FW_RESET.FW_RESET
 */
__COMMON_INLINE uint32_t COMMON_FW_RESET__FW_RESET__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FW_RESET__FW_RESET__Msk);
    reg = (reg >> COMMON_FW_RESET__FW_RESET__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       FSW_IRQ_CLR member of COMMON_t                       */
/* -------------------------------------------------------------------------- */

/** __COMMON_FSW_IRQ_CLR__ADDRESS returns the address of member FSW_IRQ_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FSW_IRQ_CLR
 */
__COMMON_INLINE uint32_t* __COMMON_FSW_IRQ_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, FSW_IRQ_CLR)));
}

/** COMMON_FSW_IRQ_CLR__SET() sets FSW_IRQ_CLR to given value.
 *
 * When writing to FSW_IRQ_CLR, this is mandatory to use.
 *
 * @param value new value for FSW_IRQ_CLR
 */
__COMMON_INLINE void COMMON_FSW_IRQ_CLR__SET(uint32_t value)
{
    HAL_SET32(__COMMON_FSW_IRQ_CLR__ADDRESS(), value);
}


/* -------------------- COMMON.FSW_IRQ_CLR.FSW1_IRQ_CLR -------------------- */

/**
<pre>
  COMMON.FSW_IRQ_CLR.FSW1_IRQ_CLR:

    FSW1_IRQ CLEAR
    <start table>
    0 "fsw1_irq0 clear"
    1 "fsw1_irq1 clear"
    2 "fsw1_irq2 clear"
    3 "fsw1_irq3 clear"
    4 "fsw1_irq4 clear"
    5 "fsw1_irq5 clear"
    6 "fsw1_irq6 clear"
    7 "fsw1_irq7 clear"
    <end table>

</pre> */

#define COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Pos                   8                                                                      /*!< Right-most bit position of fsw1_irq_clr in COMMON.FSW_IRQ_CLR */
#define COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Msk                   (0x000000FFUL << COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Pos)                /*!< Mask for fsw1_irq_clr in COMMON.FSW_IRQ_CLR */
#define COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Shift(v)              (((v) << COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Pos) & COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Msk) /*!< Shift value 'v' into fsw1_irq_clr and mask 'v' to fit it into fsw1_irq_clr field */

/** COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__SET() sets FSW_IRQ_CLR.FSW1_IRQ_CLR to given value.
 *
 * When writing to FSW_IRQ_CLR.FSW1_IRQ_CLR, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ_CLR.FSW1_IRQ_CLR
 */
__COMMON_INLINE void COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Shift((uint32_t)bf_value);
    COMMON_FSW_IRQ_CLR__SET(reg);
}


/** COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__MODIFY() modifies FSW_IRQ_CLR.FSW1_IRQ_CLR.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ_CLR
 * @param bf_value new value for FSW_IRQ_CLR.FSW1_IRQ_CLR
 * @return new value of COMMON.FSW_IRQ_CLR
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Msk);
    reg = (reg | (COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__EXTRACT() extracts FSW_IRQ_CLR.FSW1_IRQ_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ_CLR
 * @return current value of FSW_IRQ_CLR.FSW1_IRQ_CLR
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Msk);
    reg = (reg >> COMMON_FSW_IRQ_CLR__FSW1_IRQ_CLR__Pos);
    return (uint32_t)reg;
}

/* -------------------- COMMON.FSW_IRQ_CLR.FSW0_IRQ_CLR -------------------- */

/**
<pre>
  COMMON.FSW_IRQ_CLR.FSW0_IRQ_CLR:

    FSW0_IRQ CLEAR
    <start table>
    0 "fsw0_irq0 clear"
    1 "fsw0_irq1 clear"
    2 "fsw0_irq2 clear"
    3 "fsw0_irq3 clear"
    4 "fsw0_irq4 clear"
    5 "fsw0_irq5 clear"
    6 "fsw0_irq6 clear"
    7 "fsw0_irq7 clear"
    <end table>

</pre> */

#define COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Pos                   0                                                                      /*!< Right-most bit position of fsw0_irq_clr in COMMON.FSW_IRQ_CLR */
#define COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Msk                   (0x000000FFUL << COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Pos)                /*!< Mask for fsw0_irq_clr in COMMON.FSW_IRQ_CLR */
#define COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Shift(v)              (((v) << COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Pos) & COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Msk) /*!< Shift value 'v' into fsw0_irq_clr and mask 'v' to fit it into fsw0_irq_clr field */

/** COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__SET() sets FSW_IRQ_CLR.FSW0_IRQ_CLR to given value.
 *
 * When writing to FSW_IRQ_CLR.FSW0_IRQ_CLR, this is recommended to use.
 *
 * @param bf_value new value for FSW_IRQ_CLR.FSW0_IRQ_CLR
 */
__COMMON_INLINE void COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__SET(uint32_t bf_value)
{
    uint32_t reg = COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Shift((uint32_t)bf_value);
    COMMON_FSW_IRQ_CLR__SET(reg);
}


/** COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__MODIFY() modifies FSW_IRQ_CLR.FSW0_IRQ_CLR.
 *
 * This is recommended to use when setting more than one bitfield of COMMON.FSW_IRQ_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of COMMON.FSW_IRQ_CLR
 * @param bf_value new value for FSW_IRQ_CLR.FSW0_IRQ_CLR
 * @return new value of COMMON.FSW_IRQ_CLR
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Msk);
    reg = (reg | (COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__EXTRACT() extracts FSW_IRQ_CLR.FSW0_IRQ_CLR.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_IRQ_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_IRQ_CLR
 * @return current value of FSW_IRQ_CLR.FSW0_IRQ_CLR
 */
__COMMON_INLINE uint32_t COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Msk);
    reg = (reg >> COMMON_FSW_IRQ_CLR__FSW0_IRQ_CLR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        FSW_STAT member of COMMON_t                        */
/* -------------------------------------------------------------------------- */

/** __COMMON_FSW_STAT__ADDRESS returns the address of member FSW_STAT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of FSW_STAT
 */
__COMMON_INLINE uint32_t* __COMMON_FSW_STAT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__COMMON_BASE_PTR() + (uint32_t)(offsetof(COMMON_t, FSW_STAT)));
}

/** COMMON_FSW_STAT__GET() gets FSW_STAT's current value.
 *
 * When reading from FSW_STAT, this is mandatory to use.
 *
 * @return current value of FSW_STAT
 */
__COMMON_INLINE uint32_t COMMON_FSW_STAT__GET(void)
{
    return HAL_GET32(__COMMON_FSW_STAT__ADDRESS());
}

/* ---------------------- COMMON.FSW_STAT.FSW1_STATUS ---------------------- */

/**
<pre>
  COMMON.FSW_STAT.FSW1_STATUS:

    FSW1_IRQ STATUS
    <start table>
    0 "fsw1_irq0 status"
    1 "fsw1_irq1 status"
    2 "fsw1_irq2  status"
    3 "fsw1_irq3  status"
    4 "fsw1_irq4  status"
    5 "fsw1_irq5  status"
    6 "fsw1_irq6  status"
    7 "fsw1_irq7  status"
    <end table>

</pre> */

#define COMMON_FSW_STAT__FSW1_STATUS__Pos                       8                                                                      /*!< Right-most bit position of fsw1_status in COMMON.FSW_STAT */
#define COMMON_FSW_STAT__FSW1_STATUS__Msk                       (0x000000FFUL << COMMON_FSW_STAT__FSW1_STATUS__Pos)                    /*!< Mask for fsw1_status in COMMON.FSW_STAT */
#define COMMON_FSW_STAT__FSW1_STATUS__Shift(v)                  (((v) << COMMON_FSW_STAT__FSW1_STATUS__Pos) & COMMON_FSW_STAT__FSW1_STATUS__Msk) /*!< Shift value 'v' into fsw1_status and mask 'v' to fit it into fsw1_status field */

/** COMMON_FSW_STAT__FSW1_STATUS__GET() gets FSW_STAT.FSW1_STATUS's current value.
 *
 * When reading from FSW_STAT.FSW1_STATUS, this is recommended to use.
 *
 * @return current value of FSW_STAT.FSW1_STATUS
 */
__COMMON_INLINE uint32_t COMMON_FSW_STAT__FSW1_STATUS__GET(void)
{
    uint32_t reg = COMMON_FSW_STAT__GET();
    reg = (reg & COMMON_FSW_STAT__FSW1_STATUS__Msk);
    reg = (reg >> COMMON_FSW_STAT__FSW1_STATUS__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_STAT__FSW1_STATUS__EXTRACT() extracts FSW_STAT.FSW1_STATUS.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_STAT
 * @return current value of FSW_STAT.FSW1_STATUS
 */
__COMMON_INLINE uint32_t COMMON_FSW_STAT__FSW1_STATUS__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_STAT__FSW1_STATUS__Msk);
    reg = (reg >> COMMON_FSW_STAT__FSW1_STATUS__Pos);
    return (uint32_t)reg;
}

/* ---------------------- COMMON.FSW_STAT.FSW0_STATUS ---------------------- */

/**
<pre>
  COMMON.FSW_STAT.FSW0_STATUS:

    FSW0_IRQ STATUS
    <start table>
    0 "fsw0_irq0 status"
    1 "fsw0_irq1 status"
    2 "fsw0_irq2  status"
    3 "fsw0_irq3  status"
    4 "fsw0_irq4  status"
    5 "fsw0_irq5  status"
    6 "fsw0_irq6  status"
    7 "fsw0_irq7  status"
    <end table>

</pre> */

#define COMMON_FSW_STAT__FSW0_STATUS__Pos                       0                                                                      /*!< Right-most bit position of fsw0_status in COMMON.FSW_STAT */
#define COMMON_FSW_STAT__FSW0_STATUS__Msk                       (0x000000FFUL << COMMON_FSW_STAT__FSW0_STATUS__Pos)                    /*!< Mask for fsw0_status in COMMON.FSW_STAT */
#define COMMON_FSW_STAT__FSW0_STATUS__Shift(v)                  (((v) << COMMON_FSW_STAT__FSW0_STATUS__Pos) & COMMON_FSW_STAT__FSW0_STATUS__Msk) /*!< Shift value 'v' into fsw0_status and mask 'v' to fit it into fsw0_status field */

/** COMMON_FSW_STAT__FSW0_STATUS__GET() gets FSW_STAT.FSW0_STATUS's current value.
 *
 * When reading from FSW_STAT.FSW0_STATUS, this is recommended to use.
 *
 * @return current value of FSW_STAT.FSW0_STATUS
 */
__COMMON_INLINE uint32_t COMMON_FSW_STAT__FSW0_STATUS__GET(void)
{
    uint32_t reg = COMMON_FSW_STAT__GET();
    reg = (reg & COMMON_FSW_STAT__FSW0_STATUS__Msk);
    reg = (reg >> COMMON_FSW_STAT__FSW0_STATUS__Pos);
    return (uint32_t)reg;
}

/** COMMON_FSW_STAT__FSW0_STATUS__EXTRACT() extracts FSW_STAT.FSW0_STATUS.
 *
 * This is recommended to use when extracting more than one bitfield from COMMON.FSW_STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of COMMON.FSW_STAT
 * @return current value of FSW_STAT.FSW0_STATUS
 */
__COMMON_INLINE uint32_t COMMON_FSW_STAT__FSW0_STATUS__EXTRACT(uint32_t reg)
{
    reg = (reg & COMMON_FSW_STAT__FSW0_STATUS__Msk);
    reg = (reg >> COMMON_FSW_STAT__FSW0_STATUS__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group common block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_COMMON_H_ */
