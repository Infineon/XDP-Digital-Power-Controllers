/**
 * @file     shasta_hal_trim.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_TRIM_H_
#define _SHASTA_HAL_TRIM_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup trim
 * @{
 */

#if defined ( __CC_ARM )
#define __TRIM_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __TRIM_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __TRIM_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __TRIM_INLINE  static inline
#endif

/** register file of the trim block.
 */
typedef struct _TRIM_s
{
    volatile        uint32_t        BG_TRIM                     ; /*!< (@0x00000000) Bandgap notch filter enable signal.  Should be enabled during normal operation.  Disable only for test. <start table> 0 "disabled" 1 "enabled" <end table> */
    volatile        uint32_t        LO_TRIM                     ; /*!< (@0x00000004) Oscillator coarse trim code, 200MHz mode.  Nominal setting is 64.  Nominal LO frequency given by equation, <start table> "Flo(MHz) = 97.5MHz + lo_clk_trim_c...(more) */
    volatile        uint32_t        VSP_GAIN_TRIM               ; /*!< (@0x00000008) VS0 (VSEN) ADC gain trim. */
    volatile        uint32_t        VSP_OFF_TRIM                ; /*!< (@0x0000000C) VS0 (VSEN) digital offset trim */
    volatile        uint32_t        VS_OS_TRIM                  ; /*!< (@0x00000010) VS0 (VSEN) analog offset trim */
    volatile        uint32_t        IS1_GAIN_TRIM               ; /*!< (@0x00000014) IS1 (ISEN) ADC gain trim when isen1_gain_mode=0. */
    volatile        uint32_t        IS2_GAIN_TRIM               ; /*!< (@0x00000018) IS2 (calibration) ADC gain trim when isen1/2_gain_mode=0. */
    volatile        uint32_t        IS3_GAIN_TRIM               ; /*!< (@0x0000001C) IS3 (BISEN) ADC gain trim when isen2_gain_mode=0. */
    volatile        uint32_t        TS_TRIM1                    ; /*!< (@0x00000020) Telemetry ADC, PRISEN input gain trim. */
    volatile        uint32_t        TS_TRIM2                    ; /*!< (@0x00000024) Telemetry ADC, ATSEN input gain trim. */
    volatile        uint32_t        TS_TRIM3                    ; /*!< (@0x00000028) Telemetry ADC, ITSEN input gain trim. */
    volatile        uint32_t        TS_TRIM4                    ; /*!< (@0x0000002C) Trim code for the 10uA Telemetry Sense IDAC current reference.  Nominal current is 10uA for trim code = 31.  In the nominal corner the range is 8.03 to 12.4...(more) */
    volatile        uint32_t        IC_SERIAL                   ; /*!< (@0x00000030) IC serial number within test lot, programmed at ATE */
    volatile        uint32_t        CFG_NUM                     ; /*!< (@0x00000034) ATE programmed configuration number */
    volatile        uint32_t        IS1_OFF_TRIM1               ; /*!< (@0x00000038) IS1 (ISEN) ADC offset trim when isen1_gain_mode=0.  Used only when auto calibration is disabled. */
    volatile        uint32_t        IS1_OFF_TRIM2               ; /*!< (@0x0000003C) IS1 (ISEN) ADC offset trim when isen1_gain_mode=2.  Used only when auto calibration is disabled. */
    volatile        uint32_t        IS2_OFF_TRIM1               ; /*!< (@0x00000040) IS2 (calibration) ADC offset trim when isen2_gain_mode=0.  Used only when auto calibration is disabled. */
    volatile        uint32_t        IS2_OFF_TRIM2               ; /*!< (@0x00000044) IS2 (calibration) ADC offset trim when isen2_gain_mode=2.  Used only when auto calibration is disabled. */
    volatile        uint32_t        IS3_OFF_TRIM1               ; /*!< (@0x00000048) IS3 (BISEN) ADC offset trim when isen3_gain_mode=0.  Used only when auto calibration is disabled. */
    volatile        uint32_t        IS3_OFF_TRIM2               ; /*!< (@0x0000004C) IS3 (BISEN) ADC offset trim when isen3_gain_mode=2.  Used only when auto calibration is disabled. */
    volatile        uint32_t        SPARE_TRIM                  ; /*!< (@0x00000050) Spare trim register location.  Not currently in use */
    volatile        uint32_t        PROD_ID                     ; /*!< (@0x00000054) This register indicates the device part number and revision if applicable. Bits [15:8] indicate the device part number (different packages have different pa...(more) */
    volatile        uint32_t        IC_VERSION                  ; /*!< (@0x00000058) Read only, metal programmed indicator of silicon device ID and revision. Bits [15:4] indicate the product type with 0x010 assigned to Shasta. Bits [3:0] ind...(more) */
} TRIM_t;


#define TRIM_BASE (0x70000000u)                                                          /*!< trim base address */

/** __TRIM_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__TRIM_INLINE uint32_t* __TRIM_BASE_PTR(void)
{
    return (uint32_t*)(TRIM_BASE);
}


/* -------------------------------------------------------------------------- */
/*                          BG_TRIM member of TRIM_t                          */
/* -------------------------------------------------------------------------- */

/** __TRIM_BG_TRIM__ADDRESS returns the address of member BG_TRIM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of BG_TRIM
 */
__TRIM_INLINE uint32_t* __TRIM_BG_TRIM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, BG_TRIM)));
}

/** TRIM_BG_TRIM__SET() sets BG_TRIM to given value.
 *
 * When writing to BG_TRIM, this is mandatory to use.
 *
 * @param value new value for BG_TRIM
 */
__TRIM_INLINE void TRIM_BG_TRIM__SET(uint32_t value)
{
    HAL_SET32(__TRIM_BG_TRIM__ADDRESS(), value);
}

/** TRIM_BG_TRIM__GET() gets BG_TRIM's current value.
 *
 * When reading from BG_TRIM, this is mandatory to use.
 *
 * @return current value of BG_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__GET(void)
{
    return HAL_GET32(__TRIM_BG_TRIM__ADDRESS());
}

/* ----------------------- TRIM.BG_TRIM.SP_REGA_TRIM ----------------------- */

/**
<pre>
  TRIM.BG_TRIM.SP_REGA_TRIM:

    Analog 1.2V linear regulator trim code.

</pre> */

#define TRIM_BG_TRIM__SP_REGA_TRIM__Pos                         24                                                                     /*!< Right-most bit position of sp_rega_trim in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__SP_REGA_TRIM__Msk                         (0x0000001FUL << TRIM_BG_TRIM__SP_REGA_TRIM__Pos)                      /*!< Mask for sp_rega_trim in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__SP_REGA_TRIM__Shift(v)                    (((v) << TRIM_BG_TRIM__SP_REGA_TRIM__Pos) & TRIM_BG_TRIM__SP_REGA_TRIM__Msk) /*!< Shift value 'v' into sp_rega_trim and mask 'v' to fit it into sp_rega_trim field */

/** TRIM_BG_TRIM__SP_REGA_TRIM__SET() sets BG_TRIM.SP_REGA_TRIM to given value.
 *
 * When writing to BG_TRIM.SP_REGA_TRIM, this is recommended to use.
 *
 * @param bf_value new value for BG_TRIM.SP_REGA_TRIM
 */
__TRIM_INLINE void TRIM_BG_TRIM__SP_REGA_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & ~TRIM_BG_TRIM__SP_REGA_TRIM__Msk);
    reg = (reg | (TRIM_BG_TRIM__SP_REGA_TRIM__Shift((uint32_t)bf_value)));
    TRIM_BG_TRIM__SET(reg);
}

/** TRIM_BG_TRIM__SP_REGA_TRIM__GET() gets BG_TRIM.SP_REGA_TRIM's current value.
 *
 * When reading from BG_TRIM.SP_REGA_TRIM, this is recommended to use.
 *
 * @return current value of BG_TRIM.SP_REGA_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__SP_REGA_TRIM__GET(void)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & TRIM_BG_TRIM__SP_REGA_TRIM__Msk);
    reg = (reg >> TRIM_BG_TRIM__SP_REGA_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_BG_TRIM__SP_REGA_TRIM__MODIFY() modifies BG_TRIM.SP_REGA_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.BG_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @param bf_value new value for BG_TRIM.SP_REGA_TRIM
 * @return new value of TRIM.BG_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__SP_REGA_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_BG_TRIM__SP_REGA_TRIM__Msk);
    reg = (reg | (TRIM_BG_TRIM__SP_REGA_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_BG_TRIM__SP_REGA_TRIM__EXTRACT() extracts BG_TRIM.SP_REGA_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.BG_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @return current value of BG_TRIM.SP_REGA_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__SP_REGA_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_BG_TRIM__SP_REGA_TRIM__Msk);
    reg = (reg >> TRIM_BG_TRIM__SP_REGA_TRIM__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.BG_TRIM.SP_REG_VDD_LR_TRIM -------------------- */

/**
<pre>
  TRIM.BG_TRIM.SP_REG_VDD_LR_TRIM:

    Digital 1.2V linear regulator trim code.

</pre> */

#define TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Pos                   19                                                                     /*!< Right-most bit position of sp_reg_vdd_lr_trim in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Msk                   (0x0000001FUL << TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Pos)                /*!< Mask for sp_reg_vdd_lr_trim in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Shift(v)              (((v) << TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Pos) & TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Msk) /*!< Shift value 'v' into sp_reg_vdd_lr_trim and mask 'v' to fit it into sp_reg_vdd_lr_trim field */

/** TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__SET() sets BG_TRIM.SP_REG_VDD_LR_TRIM to given value.
 *
 * When writing to BG_TRIM.SP_REG_VDD_LR_TRIM, this is recommended to use.
 *
 * @param bf_value new value for BG_TRIM.SP_REG_VDD_LR_TRIM
 */
__TRIM_INLINE void TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & ~TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Msk);
    reg = (reg | (TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Shift((uint32_t)bf_value)));
    TRIM_BG_TRIM__SET(reg);
}

/** TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__GET() gets BG_TRIM.SP_REG_VDD_LR_TRIM's current value.
 *
 * When reading from BG_TRIM.SP_REG_VDD_LR_TRIM, this is recommended to use.
 *
 * @return current value of BG_TRIM.SP_REG_VDD_LR_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__GET(void)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Msk);
    reg = (reg >> TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__MODIFY() modifies BG_TRIM.SP_REG_VDD_LR_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.BG_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @param bf_value new value for BG_TRIM.SP_REG_VDD_LR_TRIM
 * @return new value of TRIM.BG_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Msk);
    reg = (reg | (TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__EXTRACT() extracts BG_TRIM.SP_REG_VDD_LR_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.BG_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @return current value of BG_TRIM.SP_REG_VDD_LR_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Msk);
    reg = (reg >> TRIM_BG_TRIM__SP_REG_VDD_LR_TRIM__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TRIM.BG_TRIM.SP_REG_LO_TRIM ---------------------- */

/**
<pre>
  TRIM.BG_TRIM.SP_REG_LO_TRIM:

    Oscillator 1.2V linear regulator trim code.

</pre> */

#define TRIM_BG_TRIM__SP_REG_LO_TRIM__Pos                       14                                                                     /*!< Right-most bit position of sp_reg_lo_trim in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__SP_REG_LO_TRIM__Msk                       (0x0000001FUL << TRIM_BG_TRIM__SP_REG_LO_TRIM__Pos)                    /*!< Mask for sp_reg_lo_trim in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__SP_REG_LO_TRIM__Shift(v)                  (((v) << TRIM_BG_TRIM__SP_REG_LO_TRIM__Pos) & TRIM_BG_TRIM__SP_REG_LO_TRIM__Msk) /*!< Shift value 'v' into sp_reg_lo_trim and mask 'v' to fit it into sp_reg_lo_trim field */

/** TRIM_BG_TRIM__SP_REG_LO_TRIM__SET() sets BG_TRIM.SP_REG_LO_TRIM to given value.
 *
 * When writing to BG_TRIM.SP_REG_LO_TRIM, this is recommended to use.
 *
 * @param bf_value new value for BG_TRIM.SP_REG_LO_TRIM
 */
__TRIM_INLINE void TRIM_BG_TRIM__SP_REG_LO_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & ~TRIM_BG_TRIM__SP_REG_LO_TRIM__Msk);
    reg = (reg | (TRIM_BG_TRIM__SP_REG_LO_TRIM__Shift((uint32_t)bf_value)));
    TRIM_BG_TRIM__SET(reg);
}

/** TRIM_BG_TRIM__SP_REG_LO_TRIM__GET() gets BG_TRIM.SP_REG_LO_TRIM's current value.
 *
 * When reading from BG_TRIM.SP_REG_LO_TRIM, this is recommended to use.
 *
 * @return current value of BG_TRIM.SP_REG_LO_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__SP_REG_LO_TRIM__GET(void)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & TRIM_BG_TRIM__SP_REG_LO_TRIM__Msk);
    reg = (reg >> TRIM_BG_TRIM__SP_REG_LO_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_BG_TRIM__SP_REG_LO_TRIM__MODIFY() modifies BG_TRIM.SP_REG_LO_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.BG_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @param bf_value new value for BG_TRIM.SP_REG_LO_TRIM
 * @return new value of TRIM.BG_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__SP_REG_LO_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_BG_TRIM__SP_REG_LO_TRIM__Msk);
    reg = (reg | (TRIM_BG_TRIM__SP_REG_LO_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_BG_TRIM__SP_REG_LO_TRIM__EXTRACT() extracts BG_TRIM.SP_REG_LO_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.BG_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @return current value of BG_TRIM.SP_REG_LO_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__SP_REG_LO_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_BG_TRIM__SP_REG_LO_TRIM__Msk);
    reg = (reg >> TRIM_BG_TRIM__SP_REG_LO_TRIM__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TRIM.BG_TRIM.BG_VPTAT_TRIM ----------------------- */

/**
<pre>
  TRIM.BG_TRIM.BG_VPTAT_TRIM:

    Internal temperature sensor voltage trim code.  With the default trim value of 32 the VPTAT voltage is nominally 647.7 mV at 25C with a slope of 2.7mV/C.

</pre> */

#define TRIM_BG_TRIM__BG_VPTAT_TRIM__Pos                        8                                                                      /*!< Right-most bit position of bg_vptat_trim in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__BG_VPTAT_TRIM__Msk                        (0x0000003FUL << TRIM_BG_TRIM__BG_VPTAT_TRIM__Pos)                     /*!< Mask for bg_vptat_trim in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__BG_VPTAT_TRIM__Shift(v)                   (((v) << TRIM_BG_TRIM__BG_VPTAT_TRIM__Pos) & TRIM_BG_TRIM__BG_VPTAT_TRIM__Msk) /*!< Shift value 'v' into bg_vptat_trim and mask 'v' to fit it into bg_vptat_trim field */

/** TRIM_BG_TRIM__BG_VPTAT_TRIM__SET() sets BG_TRIM.BG_VPTAT_TRIM to given value.
 *
 * When writing to BG_TRIM.BG_VPTAT_TRIM, this is recommended to use.
 *
 * @param bf_value new value for BG_TRIM.BG_VPTAT_TRIM
 */
__TRIM_INLINE void TRIM_BG_TRIM__BG_VPTAT_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & ~TRIM_BG_TRIM__BG_VPTAT_TRIM__Msk);
    reg = (reg | (TRIM_BG_TRIM__BG_VPTAT_TRIM__Shift((uint32_t)bf_value)));
    TRIM_BG_TRIM__SET(reg);
}

/** TRIM_BG_TRIM__BG_VPTAT_TRIM__GET() gets BG_TRIM.BG_VPTAT_TRIM's current value.
 *
 * When reading from BG_TRIM.BG_VPTAT_TRIM, this is recommended to use.
 *
 * @return current value of BG_TRIM.BG_VPTAT_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__BG_VPTAT_TRIM__GET(void)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & TRIM_BG_TRIM__BG_VPTAT_TRIM__Msk);
    reg = (reg >> TRIM_BG_TRIM__BG_VPTAT_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_BG_TRIM__BG_VPTAT_TRIM__MODIFY() modifies BG_TRIM.BG_VPTAT_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.BG_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @param bf_value new value for BG_TRIM.BG_VPTAT_TRIM
 * @return new value of TRIM.BG_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__BG_VPTAT_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_BG_TRIM__BG_VPTAT_TRIM__Msk);
    reg = (reg | (TRIM_BG_TRIM__BG_VPTAT_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_BG_TRIM__BG_VPTAT_TRIM__EXTRACT() extracts BG_TRIM.BG_VPTAT_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.BG_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @return current value of BG_TRIM.BG_VPTAT_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__BG_VPTAT_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_BG_TRIM__BG_VPTAT_TRIM__Msk);
    reg = (reg >> TRIM_BG_TRIM__BG_VPTAT_TRIM__Pos);
    return (uint32_t)reg;
}

/* -------------------------- TRIM.BG_TRIM.BG_TRIM -------------------------- */

/**
<pre>
  TRIM.BG_TRIM.BG_TRIM:

    Voltage sense reference bandgap trim code.  The nominal setting is 64.  The adjustment is non-linear and given by the equation,
    <start table>
    "Trim(V) = bg_trim / (1440 + bg_trim^1.4)"
    <end table>

</pre> */

#define TRIM_BG_TRIM__BG_TRIM__Pos                              1                                                                      /*!< Right-most bit position of bg_trim in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__BG_TRIM__Msk                              (0x0000007FUL << TRIM_BG_TRIM__BG_TRIM__Pos)                           /*!< Mask for bg_trim in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__BG_TRIM__Shift(v)                         (((v) << TRIM_BG_TRIM__BG_TRIM__Pos) & TRIM_BG_TRIM__BG_TRIM__Msk)     /*!< Shift value 'v' into bg_trim and mask 'v' to fit it into bg_trim field */

/** TRIM_BG_TRIM__BG_TRIM__SET() sets BG_TRIM.BG_TRIM to given value.
 *
 * When writing to BG_TRIM.BG_TRIM, this is recommended to use.
 *
 * @param bf_value new value for BG_TRIM.BG_TRIM
 */
__TRIM_INLINE void TRIM_BG_TRIM__BG_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & ~TRIM_BG_TRIM__BG_TRIM__Msk);
    reg = (reg | (TRIM_BG_TRIM__BG_TRIM__Shift((uint32_t)bf_value)));
    TRIM_BG_TRIM__SET(reg);
}

/** TRIM_BG_TRIM__BG_TRIM__GET() gets BG_TRIM.BG_TRIM's current value.
 *
 * When reading from BG_TRIM.BG_TRIM, this is recommended to use.
 *
 * @return current value of BG_TRIM.BG_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__BG_TRIM__GET(void)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & TRIM_BG_TRIM__BG_TRIM__Msk);
    reg = (reg >> TRIM_BG_TRIM__BG_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_BG_TRIM__BG_TRIM__MODIFY() modifies BG_TRIM.BG_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.BG_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @param bf_value new value for BG_TRIM.BG_TRIM
 * @return new value of TRIM.BG_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__BG_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_BG_TRIM__BG_TRIM__Msk);
    reg = (reg | (TRIM_BG_TRIM__BG_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_BG_TRIM__BG_TRIM__EXTRACT() extracts BG_TRIM.BG_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.BG_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @return current value of BG_TRIM.BG_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__BG_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_BG_TRIM__BG_TRIM__Msk);
    reg = (reg >> TRIM_BG_TRIM__BG_TRIM__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TRIM.BG_TRIM.BG_NOTCH_EN ------------------------ */

/**
<pre>
  TRIM.BG_TRIM.BG_NOTCH_EN:

    Bandgap notch filter enable signal.  Should be enabled during normal operation.  Disable only for test.
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TRIM_BG_TRIM__BG_NOTCH_EN__Pos                          0                                                                      /*!< Right-most bit position of bg_notch_en in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__BG_NOTCH_EN__Msk                          (0x00000001UL << TRIM_BG_TRIM__BG_NOTCH_EN__Pos)                       /*!< Mask for bg_notch_en in TRIM.BG_TRIM */
#define TRIM_BG_TRIM__BG_NOTCH_EN__Shift(v)                     (((v) << TRIM_BG_TRIM__BG_NOTCH_EN__Pos) & TRIM_BG_TRIM__BG_NOTCH_EN__Msk) /*!< Shift value 'v' into bg_notch_en and mask 'v' to fit it into bg_notch_en field */

/** TRIM_BG_TRIM__BG_NOTCH_EN__SET() sets BG_TRIM.BG_NOTCH_EN to given value.
 *
 * When writing to BG_TRIM.BG_NOTCH_EN, this is recommended to use.
 *
 * @param bf_value new value for BG_TRIM.BG_NOTCH_EN
 */
__TRIM_INLINE void TRIM_BG_TRIM__BG_NOTCH_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & ~TRIM_BG_TRIM__BG_NOTCH_EN__Msk);
    reg = (reg | (TRIM_BG_TRIM__BG_NOTCH_EN__Shift((uint32_t)bf_value)));
    TRIM_BG_TRIM__SET(reg);
}

/** TRIM_BG_TRIM__BG_NOTCH_EN__GET() gets BG_TRIM.BG_NOTCH_EN's current value.
 *
 * When reading from BG_TRIM.BG_NOTCH_EN, this is recommended to use.
 *
 * @return current value of BG_TRIM.BG_NOTCH_EN
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__BG_NOTCH_EN__GET(void)
{
    uint32_t reg = TRIM_BG_TRIM__GET();
    reg = (reg & TRIM_BG_TRIM__BG_NOTCH_EN__Msk);
    reg = (reg >> TRIM_BG_TRIM__BG_NOTCH_EN__Pos);
    return (uint32_t)reg;
}

/** TRIM_BG_TRIM__BG_NOTCH_EN__MODIFY() modifies BG_TRIM.BG_NOTCH_EN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.BG_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @param bf_value new value for BG_TRIM.BG_NOTCH_EN
 * @return new value of TRIM.BG_TRIM
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__BG_NOTCH_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_BG_TRIM__BG_NOTCH_EN__Msk);
    reg = (reg | (TRIM_BG_TRIM__BG_NOTCH_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_BG_TRIM__BG_NOTCH_EN__EXTRACT() extracts BG_TRIM.BG_NOTCH_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.BG_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.BG_TRIM
 * @return current value of BG_TRIM.BG_NOTCH_EN
 */
__TRIM_INLINE uint32_t TRIM_BG_TRIM__BG_NOTCH_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_BG_TRIM__BG_NOTCH_EN__Msk);
    reg = (reg >> TRIM_BG_TRIM__BG_NOTCH_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          LO_TRIM member of TRIM_t                          */
/* -------------------------------------------------------------------------- */

/** __TRIM_LO_TRIM__ADDRESS returns the address of member LO_TRIM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of LO_TRIM
 */
__TRIM_INLINE uint32_t* __TRIM_LO_TRIM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, LO_TRIM)));
}

/** TRIM_LO_TRIM__SET() sets LO_TRIM to given value.
 *
 * When writing to LO_TRIM, this is mandatory to use.
 *
 * @param value new value for LO_TRIM
 */
__TRIM_INLINE void TRIM_LO_TRIM__SET(uint32_t value)
{
    HAL_SET32(__TRIM_LO_TRIM__ADDRESS(), value);
}

/** TRIM_LO_TRIM__GET() gets LO_TRIM's current value.
 *
 * When reading from LO_TRIM, this is mandatory to use.
 *
 * @return current value of LO_TRIM
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__GET(void)
{
    return HAL_GET32(__TRIM_LO_TRIM__ADDRESS());
}

/* ----------------------- TRIM.LO_TRIM.LO_PTAT_TRIM ----------------------- */

/**
<pre>
  TRIM.LO_TRIM.LO_PTAT_TRIM:

    Oscillator PTAT trim code used to set 0TC for LO frequency.  Nominal setting is 8.

</pre> */

#define TRIM_LO_TRIM__LO_PTAT_TRIM__Pos                         19                                                                     /*!< Right-most bit position of lo_ptat_trim in TRIM.LO_TRIM */
#define TRIM_LO_TRIM__LO_PTAT_TRIM__Msk                         (0x0000000FUL << TRIM_LO_TRIM__LO_PTAT_TRIM__Pos)                      /*!< Mask for lo_ptat_trim in TRIM.LO_TRIM */
#define TRIM_LO_TRIM__LO_PTAT_TRIM__Shift(v)                    (((v) << TRIM_LO_TRIM__LO_PTAT_TRIM__Pos) & TRIM_LO_TRIM__LO_PTAT_TRIM__Msk) /*!< Shift value 'v' into lo_ptat_trim and mask 'v' to fit it into lo_ptat_trim field */

/** TRIM_LO_TRIM__LO_PTAT_TRIM__SET() sets LO_TRIM.LO_PTAT_TRIM to given value.
 *
 * When writing to LO_TRIM.LO_PTAT_TRIM, this is recommended to use.
 *
 * @param bf_value new value for LO_TRIM.LO_PTAT_TRIM
 */
__TRIM_INLINE void TRIM_LO_TRIM__LO_PTAT_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_LO_TRIM__GET();
    reg = (reg & ~TRIM_LO_TRIM__LO_PTAT_TRIM__Msk);
    reg = (reg | (TRIM_LO_TRIM__LO_PTAT_TRIM__Shift((uint32_t)bf_value)));
    TRIM_LO_TRIM__SET(reg);
}

/** TRIM_LO_TRIM__LO_PTAT_TRIM__GET() gets LO_TRIM.LO_PTAT_TRIM's current value.
 *
 * When reading from LO_TRIM.LO_PTAT_TRIM, this is recommended to use.
 *
 * @return current value of LO_TRIM.LO_PTAT_TRIM
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_PTAT_TRIM__GET(void)
{
    uint32_t reg = TRIM_LO_TRIM__GET();
    reg = (reg & TRIM_LO_TRIM__LO_PTAT_TRIM__Msk);
    reg = (reg >> TRIM_LO_TRIM__LO_PTAT_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_LO_TRIM__LO_PTAT_TRIM__MODIFY() modifies LO_TRIM.LO_PTAT_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.LO_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.LO_TRIM
 * @param bf_value new value for LO_TRIM.LO_PTAT_TRIM
 * @return new value of TRIM.LO_TRIM
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_PTAT_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_LO_TRIM__LO_PTAT_TRIM__Msk);
    reg = (reg | (TRIM_LO_TRIM__LO_PTAT_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_LO_TRIM__LO_PTAT_TRIM__EXTRACT() extracts LO_TRIM.LO_PTAT_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.LO_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.LO_TRIM
 * @return current value of LO_TRIM.LO_PTAT_TRIM
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_PTAT_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_LO_TRIM__LO_PTAT_TRIM__Msk);
    reg = (reg >> TRIM_LO_TRIM__LO_PTAT_TRIM__Pos);
    return (uint32_t)reg;
}

/* --------------------- TRIM.LO_TRIM.LO_CLK_TRIM_FINE --------------------- */

/**
<pre>
  TRIM.LO_TRIM.LO_CLK_TRIM_FINE:

    Oscillator fine trim code.  Nominal setting is 16.  See lo_clk_coarse_trim description for equation.

</pre> */

#define TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Pos                     14                                                                     /*!< Right-most bit position of lo_clk_trim_fine in TRIM.LO_TRIM */
#define TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Msk                     (0x0000001FUL << TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Pos)                  /*!< Mask for lo_clk_trim_fine in TRIM.LO_TRIM */
#define TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Shift(v)                (((v) << TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Pos) & TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Msk) /*!< Shift value 'v' into lo_clk_trim_fine and mask 'v' to fit it into lo_clk_trim_fine field */

/** TRIM_LO_TRIM__LO_CLK_TRIM_FINE__SET() sets LO_TRIM.LO_CLK_TRIM_FINE to given value.
 *
 * When writing to LO_TRIM.LO_CLK_TRIM_FINE, this is recommended to use.
 *
 * @param bf_value new value for LO_TRIM.LO_CLK_TRIM_FINE
 */
__TRIM_INLINE void TRIM_LO_TRIM__LO_CLK_TRIM_FINE__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_LO_TRIM__GET();
    reg = (reg & ~TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Msk);
    reg = (reg | (TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Shift((uint32_t)bf_value)));
    TRIM_LO_TRIM__SET(reg);
}

/** TRIM_LO_TRIM__LO_CLK_TRIM_FINE__GET() gets LO_TRIM.LO_CLK_TRIM_FINE's current value.
 *
 * When reading from LO_TRIM.LO_CLK_TRIM_FINE, this is recommended to use.
 *
 * @return current value of LO_TRIM.LO_CLK_TRIM_FINE
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_CLK_TRIM_FINE__GET(void)
{
    uint32_t reg = TRIM_LO_TRIM__GET();
    reg = (reg & TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Msk);
    reg = (reg >> TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Pos);
    return (uint32_t)reg;
}

/** TRIM_LO_TRIM__LO_CLK_TRIM_FINE__MODIFY() modifies LO_TRIM.LO_CLK_TRIM_FINE.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.LO_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.LO_TRIM
 * @param bf_value new value for LO_TRIM.LO_CLK_TRIM_FINE
 * @return new value of TRIM.LO_TRIM
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_CLK_TRIM_FINE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Msk);
    reg = (reg | (TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_LO_TRIM__LO_CLK_TRIM_FINE__EXTRACT() extracts LO_TRIM.LO_CLK_TRIM_FINE.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.LO_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.LO_TRIM
 * @return current value of LO_TRIM.LO_CLK_TRIM_FINE
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_CLK_TRIM_FINE__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Msk);
    reg = (reg >> TRIM_LO_TRIM__LO_CLK_TRIM_FINE__Pos);
    return (uint32_t)reg;
}

/* ----------------- TRIM.LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ ----------------- */

/**
<pre>
  TRIM.LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ:

    Oscillator coarse trim code, 20MHz mode.

</pre> */

#define TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Pos             7                                                                      /*!< Right-most bit position of lo_clk_trim_coarse_20mhz in TRIM.LO_TRIM */
#define TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Msk             (0x0000007FUL << TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Pos)          /*!< Mask for lo_clk_trim_coarse_20mhz in TRIM.LO_TRIM */
#define TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Shift(v)        (((v) << TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Pos) & TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Msk) /*!< Shift value 'v' into lo_clk_trim_coarse_20mhz and mask 'v' to fit it into lo_clk_trim_coarse_20mhz field */

/** TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__SET() sets LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ to given value.
 *
 * When writing to LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ, this is recommended to use.
 *
 * @param bf_value new value for LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ
 */
__TRIM_INLINE void TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_LO_TRIM__GET();
    reg = (reg & ~TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Msk);
    reg = (reg | (TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Shift((uint32_t)bf_value)));
    TRIM_LO_TRIM__SET(reg);
}

/** TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__GET() gets LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ's current value.
 *
 * When reading from LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ, this is recommended to use.
 *
 * @return current value of LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__GET(void)
{
    uint32_t reg = TRIM_LO_TRIM__GET();
    reg = (reg & TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Msk);
    reg = (reg >> TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Pos);
    return (uint32_t)reg;
}

/** TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__MODIFY() modifies LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.LO_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.LO_TRIM
 * @param bf_value new value for LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ
 * @return new value of TRIM.LO_TRIM
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Msk);
    reg = (reg | (TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__EXTRACT() extracts LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.LO_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.LO_TRIM
 * @return current value of LO_TRIM.LO_CLK_TRIM_COARSE_20MHZ
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Msk);
    reg = (reg >> TRIM_LO_TRIM__LO_CLK_TRIM_COARSE_20MHZ__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.LO_TRIM.LO_CLK_TRIM_COARSE -------------------- */

/**
<pre>
  TRIM.LO_TRIM.LO_CLK_TRIM_COARSE:

    Oscillator coarse trim code, 200MHz mode.  Nominal setting is 64.  Nominal LO frequency given by equation,
    <start table>
    "Flo(MHz) = 97.5MHz + lo_clk_trim_coarse*1.53MHz + lo_clk_trim_fine*0.286MHz"
    <end table>

</pre> */

#define TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Pos                   0                                                                      /*!< Right-most bit position of lo_clk_trim_coarse in TRIM.LO_TRIM */
#define TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Msk                   (0x0000007FUL << TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Pos)                /*!< Mask for lo_clk_trim_coarse in TRIM.LO_TRIM */
#define TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Shift(v)              (((v) << TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Pos) & TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Msk) /*!< Shift value 'v' into lo_clk_trim_coarse and mask 'v' to fit it into lo_clk_trim_coarse field */

/** TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__SET() sets LO_TRIM.LO_CLK_TRIM_COARSE to given value.
 *
 * When writing to LO_TRIM.LO_CLK_TRIM_COARSE, this is recommended to use.
 *
 * @param bf_value new value for LO_TRIM.LO_CLK_TRIM_COARSE
 */
__TRIM_INLINE void TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_LO_TRIM__GET();
    reg = (reg & ~TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Msk);
    reg = (reg | (TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Shift((uint32_t)bf_value)));
    TRIM_LO_TRIM__SET(reg);
}

/** TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__GET() gets LO_TRIM.LO_CLK_TRIM_COARSE's current value.
 *
 * When reading from LO_TRIM.LO_CLK_TRIM_COARSE, this is recommended to use.
 *
 * @return current value of LO_TRIM.LO_CLK_TRIM_COARSE
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__GET(void)
{
    uint32_t reg = TRIM_LO_TRIM__GET();
    reg = (reg & TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Msk);
    reg = (reg >> TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Pos);
    return (uint32_t)reg;
}

/** TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__MODIFY() modifies LO_TRIM.LO_CLK_TRIM_COARSE.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.LO_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.LO_TRIM
 * @param bf_value new value for LO_TRIM.LO_CLK_TRIM_COARSE
 * @return new value of TRIM.LO_TRIM
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Msk);
    reg = (reg | (TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__EXTRACT() extracts LO_TRIM.LO_CLK_TRIM_COARSE.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.LO_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.LO_TRIM
 * @return current value of LO_TRIM.LO_CLK_TRIM_COARSE
 */
__TRIM_INLINE uint32_t TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Msk);
    reg = (reg >> TRIM_LO_TRIM__LO_CLK_TRIM_COARSE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VSP_GAIN_TRIM member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_VSP_GAIN_TRIM__ADDRESS returns the address of member VSP_GAIN_TRIM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP_GAIN_TRIM
 */
__TRIM_INLINE uint32_t* __TRIM_VSP_GAIN_TRIM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, VSP_GAIN_TRIM)));
}

/** TRIM_VSP_GAIN_TRIM__SET() sets VSP_GAIN_TRIM to given value.
 *
 * When writing to VSP_GAIN_TRIM, this is mandatory to use.
 *
 * @param value new value for VSP_GAIN_TRIM
 */
__TRIM_INLINE void TRIM_VSP_GAIN_TRIM__SET(uint32_t value)
{
    HAL_SET32(__TRIM_VSP_GAIN_TRIM__ADDRESS(), value);
}

/** TRIM_VSP_GAIN_TRIM__GET() gets VSP_GAIN_TRIM's current value.
 *
 * When reading from VSP_GAIN_TRIM, this is mandatory to use.
 *
 * @return current value of VSP_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VSP_GAIN_TRIM__GET(void)
{
    return HAL_GET32(__TRIM_VSP_GAIN_TRIM__ADDRESS());
}

/* -------------------- TRIM.VSP_GAIN_TRIM.VSP2_ADC_GAIN -------------------- */

/**
<pre>
  TRIM.VSP_GAIN_TRIM.VSP2_ADC_GAIN:

    VS2 (BVSEN_BVRSEN) ADC gain trim.

</pre> */

#define TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Pos                  24                                                                     /*!< Right-most bit position of vsp2_adc_gain in TRIM.VSP_GAIN_TRIM */
#define TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Msk                  (0x000000FFUL << TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Pos)               /*!< Mask for vsp2_adc_gain in TRIM.VSP_GAIN_TRIM */
#define TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Shift(v)             (((v) << TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Pos) & TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Msk) /*!< Shift value 'v' into vsp2_adc_gain and mask 'v' to fit it into vsp2_adc_gain field */

/** TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__SET() sets VSP_GAIN_TRIM.VSP2_ADC_GAIN to given value.
 *
 * When writing to VSP_GAIN_TRIM.VSP2_ADC_GAIN, this is recommended to use.
 *
 * @param bf_value new value for VSP_GAIN_TRIM.VSP2_ADC_GAIN
 */
__TRIM_INLINE void TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_VSP_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Msk);
    reg = (reg | (TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Shift((uint32_t)bf_value)));
    TRIM_VSP_GAIN_TRIM__SET(reg);
}

/** TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__GET() gets VSP_GAIN_TRIM.VSP2_ADC_GAIN's current value.
 *
 * When reading from VSP_GAIN_TRIM.VSP2_ADC_GAIN, this is recommended to use.
 *
 * @return current value of VSP_GAIN_TRIM.VSP2_ADC_GAIN
 */
__TRIM_INLINE uint32_t TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__GET(void)
{
    uint32_t reg = TRIM_VSP_GAIN_TRIM__GET();
    reg = (reg & TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Msk);
    reg = (reg >> TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Pos);
    return (uint32_t)reg;
}

/** TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__MODIFY() modifies VSP_GAIN_TRIM.VSP2_ADC_GAIN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.VSP_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.VSP_GAIN_TRIM
 * @param bf_value new value for VSP_GAIN_TRIM.VSP2_ADC_GAIN
 * @return new value of TRIM.VSP_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Msk);
    reg = (reg | (TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__EXTRACT() extracts VSP_GAIN_TRIM.VSP2_ADC_GAIN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.VSP_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.VSP_GAIN_TRIM
 * @return current value of VSP_GAIN_TRIM.VSP2_ADC_GAIN
 */
__TRIM_INLINE uint32_t TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Msk);
    reg = (reg >> TRIM_VSP_GAIN_TRIM__VSP2_ADC_GAIN__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.VSP_GAIN_TRIM.VSP1_ADC_GAIN -------------------- */

/**
<pre>
  TRIM.VSP_GAIN_TRIM.VSP1_ADC_GAIN:

    VS1 (VRSEN) ADC gain trim.

</pre> */

#define TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Pos                  16                                                                     /*!< Right-most bit position of vsp1_adc_gain in TRIM.VSP_GAIN_TRIM */
#define TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Msk                  (0x000000FFUL << TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Pos)               /*!< Mask for vsp1_adc_gain in TRIM.VSP_GAIN_TRIM */
#define TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Shift(v)             (((v) << TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Pos) & TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Msk) /*!< Shift value 'v' into vsp1_adc_gain and mask 'v' to fit it into vsp1_adc_gain field */

/** TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__SET() sets VSP_GAIN_TRIM.VSP1_ADC_GAIN to given value.
 *
 * When writing to VSP_GAIN_TRIM.VSP1_ADC_GAIN, this is recommended to use.
 *
 * @param bf_value new value for VSP_GAIN_TRIM.VSP1_ADC_GAIN
 */
__TRIM_INLINE void TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_VSP_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Msk);
    reg = (reg | (TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Shift((uint32_t)bf_value)));
    TRIM_VSP_GAIN_TRIM__SET(reg);
}

/** TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__GET() gets VSP_GAIN_TRIM.VSP1_ADC_GAIN's current value.
 *
 * When reading from VSP_GAIN_TRIM.VSP1_ADC_GAIN, this is recommended to use.
 *
 * @return current value of VSP_GAIN_TRIM.VSP1_ADC_GAIN
 */
__TRIM_INLINE uint32_t TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__GET(void)
{
    uint32_t reg = TRIM_VSP_GAIN_TRIM__GET();
    reg = (reg & TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Msk);
    reg = (reg >> TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Pos);
    return (uint32_t)reg;
}

/** TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__MODIFY() modifies VSP_GAIN_TRIM.VSP1_ADC_GAIN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.VSP_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.VSP_GAIN_TRIM
 * @param bf_value new value for VSP_GAIN_TRIM.VSP1_ADC_GAIN
 * @return new value of TRIM.VSP_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Msk);
    reg = (reg | (TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__EXTRACT() extracts VSP_GAIN_TRIM.VSP1_ADC_GAIN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.VSP_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.VSP_GAIN_TRIM
 * @return current value of VSP_GAIN_TRIM.VSP1_ADC_GAIN
 */
__TRIM_INLINE uint32_t TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Msk);
    reg = (reg >> TRIM_VSP_GAIN_TRIM__VSP1_ADC_GAIN__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.VSP_GAIN_TRIM.VSP0_ADC_GAIN -------------------- */

/**
<pre>
  TRIM.VSP_GAIN_TRIM.VSP0_ADC_GAIN:

    VS0 (VSEN) ADC gain trim.

</pre> */

#define TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Pos                  0                                                                      /*!< Right-most bit position of vsp0_adc_gain in TRIM.VSP_GAIN_TRIM */
#define TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Msk                  (0x000000FFUL << TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Pos)               /*!< Mask for vsp0_adc_gain in TRIM.VSP_GAIN_TRIM */
#define TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Shift(v)             (((v) << TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Pos) & TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Msk) /*!< Shift value 'v' into vsp0_adc_gain and mask 'v' to fit it into vsp0_adc_gain field */

/** TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__SET() sets VSP_GAIN_TRIM.VSP0_ADC_GAIN to given value.
 *
 * When writing to VSP_GAIN_TRIM.VSP0_ADC_GAIN, this is recommended to use.
 *
 * @param bf_value new value for VSP_GAIN_TRIM.VSP0_ADC_GAIN
 */
__TRIM_INLINE void TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_VSP_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Msk);
    reg = (reg | (TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Shift((uint32_t)bf_value)));
    TRIM_VSP_GAIN_TRIM__SET(reg);
}

/** TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__GET() gets VSP_GAIN_TRIM.VSP0_ADC_GAIN's current value.
 *
 * When reading from VSP_GAIN_TRIM.VSP0_ADC_GAIN, this is recommended to use.
 *
 * @return current value of VSP_GAIN_TRIM.VSP0_ADC_GAIN
 */
__TRIM_INLINE uint32_t TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__GET(void)
{
    uint32_t reg = TRIM_VSP_GAIN_TRIM__GET();
    reg = (reg & TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Msk);
    reg = (reg >> TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Pos);
    return (uint32_t)reg;
}

/** TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__MODIFY() modifies VSP_GAIN_TRIM.VSP0_ADC_GAIN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.VSP_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.VSP_GAIN_TRIM
 * @param bf_value new value for VSP_GAIN_TRIM.VSP0_ADC_GAIN
 * @return new value of TRIM.VSP_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Msk);
    reg = (reg | (TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__EXTRACT() extracts VSP_GAIN_TRIM.VSP0_ADC_GAIN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.VSP_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.VSP_GAIN_TRIM
 * @return current value of VSP_GAIN_TRIM.VSP0_ADC_GAIN
 */
__TRIM_INLINE uint32_t TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Msk);
    reg = (reg >> TRIM_VSP_GAIN_TRIM__VSP0_ADC_GAIN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VSP_OFF_TRIM member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_VSP_OFF_TRIM__ADDRESS returns the address of member VSP_OFF_TRIM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VSP_OFF_TRIM
 */
__TRIM_INLINE uint32_t* __TRIM_VSP_OFF_TRIM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, VSP_OFF_TRIM)));
}

/** TRIM_VSP_OFF_TRIM__SET() sets VSP_OFF_TRIM to given value.
 *
 * When writing to VSP_OFF_TRIM, this is mandatory to use.
 *
 * @param value new value for VSP_OFF_TRIM
 */
__TRIM_INLINE void TRIM_VSP_OFF_TRIM__SET(uint32_t value)
{
    HAL_SET32(__TRIM_VSP_OFF_TRIM__ADDRESS(), value);
}

/** TRIM_VSP_OFF_TRIM__GET() gets VSP_OFF_TRIM's current value.
 *
 * When reading from VSP_OFF_TRIM, this is mandatory to use.
 *
 * @return current value of VSP_OFF_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VSP_OFF_TRIM__GET(void)
{
    return HAL_GET32(__TRIM_VSP_OFF_TRIM__ADDRESS());
}

/* ------------------- TRIM.VSP_OFF_TRIM.VSP2_ADC_OFFSET ------------------- */

/**
<pre>
  TRIM.VSP_OFF_TRIM.VSP2_ADC_OFFSET:

    VS2 (BVSEN_BVRSEN) digital offset trim

</pre> */

#define TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Pos                 14                                                                     /*!< Right-most bit position of vsp2_adc_offset in TRIM.VSP_OFF_TRIM */
#define TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Msk                 (0x0000007FUL << TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Pos)              /*!< Mask for vsp2_adc_offset in TRIM.VSP_OFF_TRIM */
#define TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Shift(v)            (((v) << TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Pos) & TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Msk) /*!< Shift value 'v' into vsp2_adc_offset and mask 'v' to fit it into vsp2_adc_offset field */

/** TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__SET() sets VSP_OFF_TRIM.VSP2_ADC_OFFSET to given value.
 *
 * When writing to VSP_OFF_TRIM.VSP2_ADC_OFFSET, this is recommended to use.
 *
 * @param bf_value new value for VSP_OFF_TRIM.VSP2_ADC_OFFSET
 */
__TRIM_INLINE void TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_VSP_OFF_TRIM__GET();
    reg = (reg & ~TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Msk);
    reg = (reg | (TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Shift((uint32_t)bf_value)));
    TRIM_VSP_OFF_TRIM__SET(reg);
}

/** TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__GET() gets VSP_OFF_TRIM.VSP2_ADC_OFFSET's current value.
 *
 * When reading from VSP_OFF_TRIM.VSP2_ADC_OFFSET, this is recommended to use.
 *
 * @return current value of VSP_OFF_TRIM.VSP2_ADC_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__GET(void)
{
    uint32_t reg = TRIM_VSP_OFF_TRIM__GET();
    reg = (reg & TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Msk);
    reg = (reg >> TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Pos);
    return (uint32_t)reg;
}

/** TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__MODIFY() modifies VSP_OFF_TRIM.VSP2_ADC_OFFSET.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.VSP_OFF_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.VSP_OFF_TRIM
 * @param bf_value new value for VSP_OFF_TRIM.VSP2_ADC_OFFSET
 * @return new value of TRIM.VSP_OFF_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Msk);
    reg = (reg | (TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__EXTRACT() extracts VSP_OFF_TRIM.VSP2_ADC_OFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.VSP_OFF_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.VSP_OFF_TRIM
 * @return current value of VSP_OFF_TRIM.VSP2_ADC_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Msk);
    reg = (reg >> TRIM_VSP_OFF_TRIM__VSP2_ADC_OFFSET__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.VSP_OFF_TRIM.VSP1_ADC_OFFSET ------------------- */

/**
<pre>
  TRIM.VSP_OFF_TRIM.VSP1_ADC_OFFSET:

    VS1 (VRSEN) digital offset trim

</pre> */

#define TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Pos                 7                                                                      /*!< Right-most bit position of vsp1_adc_offset in TRIM.VSP_OFF_TRIM */
#define TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Msk                 (0x0000007FUL << TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Pos)              /*!< Mask for vsp1_adc_offset in TRIM.VSP_OFF_TRIM */
#define TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Shift(v)            (((v) << TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Pos) & TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Msk) /*!< Shift value 'v' into vsp1_adc_offset and mask 'v' to fit it into vsp1_adc_offset field */

/** TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__SET() sets VSP_OFF_TRIM.VSP1_ADC_OFFSET to given value.
 *
 * When writing to VSP_OFF_TRIM.VSP1_ADC_OFFSET, this is recommended to use.
 *
 * @param bf_value new value for VSP_OFF_TRIM.VSP1_ADC_OFFSET
 */
__TRIM_INLINE void TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_VSP_OFF_TRIM__GET();
    reg = (reg & ~TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Msk);
    reg = (reg | (TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Shift((uint32_t)bf_value)));
    TRIM_VSP_OFF_TRIM__SET(reg);
}

/** TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__GET() gets VSP_OFF_TRIM.VSP1_ADC_OFFSET's current value.
 *
 * When reading from VSP_OFF_TRIM.VSP1_ADC_OFFSET, this is recommended to use.
 *
 * @return current value of VSP_OFF_TRIM.VSP1_ADC_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__GET(void)
{
    uint32_t reg = TRIM_VSP_OFF_TRIM__GET();
    reg = (reg & TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Msk);
    reg = (reg >> TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Pos);
    return (uint32_t)reg;
}

/** TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__MODIFY() modifies VSP_OFF_TRIM.VSP1_ADC_OFFSET.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.VSP_OFF_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.VSP_OFF_TRIM
 * @param bf_value new value for VSP_OFF_TRIM.VSP1_ADC_OFFSET
 * @return new value of TRIM.VSP_OFF_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Msk);
    reg = (reg | (TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__EXTRACT() extracts VSP_OFF_TRIM.VSP1_ADC_OFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.VSP_OFF_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.VSP_OFF_TRIM
 * @return current value of VSP_OFF_TRIM.VSP1_ADC_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Msk);
    reg = (reg >> TRIM_VSP_OFF_TRIM__VSP1_ADC_OFFSET__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.VSP_OFF_TRIM.VSP0_ADC_OFFSET ------------------- */

/**
<pre>
  TRIM.VSP_OFF_TRIM.VSP0_ADC_OFFSET:

    VS0 (VSEN) digital offset trim

</pre> */

#define TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Pos                 0                                                                      /*!< Right-most bit position of vsp0_adc_offset in TRIM.VSP_OFF_TRIM */
#define TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Msk                 (0x0000007FUL << TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Pos)              /*!< Mask for vsp0_adc_offset in TRIM.VSP_OFF_TRIM */
#define TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Shift(v)            (((v) << TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Pos) & TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Msk) /*!< Shift value 'v' into vsp0_adc_offset and mask 'v' to fit it into vsp0_adc_offset field */

/** TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__SET() sets VSP_OFF_TRIM.VSP0_ADC_OFFSET to given value.
 *
 * When writing to VSP_OFF_TRIM.VSP0_ADC_OFFSET, this is recommended to use.
 *
 * @param bf_value new value for VSP_OFF_TRIM.VSP0_ADC_OFFSET
 */
__TRIM_INLINE void TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_VSP_OFF_TRIM__GET();
    reg = (reg & ~TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Msk);
    reg = (reg | (TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Shift((uint32_t)bf_value)));
    TRIM_VSP_OFF_TRIM__SET(reg);
}

/** TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__GET() gets VSP_OFF_TRIM.VSP0_ADC_OFFSET's current value.
 *
 * When reading from VSP_OFF_TRIM.VSP0_ADC_OFFSET, this is recommended to use.
 *
 * @return current value of VSP_OFF_TRIM.VSP0_ADC_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__GET(void)
{
    uint32_t reg = TRIM_VSP_OFF_TRIM__GET();
    reg = (reg & TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Msk);
    reg = (reg >> TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Pos);
    return (uint32_t)reg;
}

/** TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__MODIFY() modifies VSP_OFF_TRIM.VSP0_ADC_OFFSET.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.VSP_OFF_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.VSP_OFF_TRIM
 * @param bf_value new value for VSP_OFF_TRIM.VSP0_ADC_OFFSET
 * @return new value of TRIM.VSP_OFF_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Msk);
    reg = (reg | (TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__EXTRACT() extracts VSP_OFF_TRIM.VSP0_ADC_OFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.VSP_OFF_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.VSP_OFF_TRIM
 * @return current value of VSP_OFF_TRIM.VSP0_ADC_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Msk);
    reg = (reg >> TRIM_VSP_OFF_TRIM__VSP0_ADC_OFFSET__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        VS_OS_TRIM member of TRIM_t                        */
/* -------------------------------------------------------------------------- */

/** __TRIM_VS_OS_TRIM__ADDRESS returns the address of member VS_OS_TRIM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VS_OS_TRIM
 */
__TRIM_INLINE uint32_t* __TRIM_VS_OS_TRIM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, VS_OS_TRIM)));
}

/** TRIM_VS_OS_TRIM__SET() sets VS_OS_TRIM to given value.
 *
 * When writing to VS_OS_TRIM, this is mandatory to use.
 *
 * @param value new value for VS_OS_TRIM
 */
__TRIM_INLINE void TRIM_VS_OS_TRIM__SET(uint32_t value)
{
    HAL_SET32(__TRIM_VS_OS_TRIM__ADDRESS(), value);
}

/** TRIM_VS_OS_TRIM__GET() gets VS_OS_TRIM's current value.
 *
 * When reading from VS_OS_TRIM, this is mandatory to use.
 *
 * @return current value of VS_OS_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VS_OS_TRIM__GET(void)
{
    return HAL_GET32(__TRIM_VS_OS_TRIM__ADDRESS());
}

/* -------------------- TRIM.VS_OS_TRIM.VS2_OS_TRIM_BIF -------------------- */

/**
<pre>
  TRIM.VS_OS_TRIM.VS2_OS_TRIM_BIF:

    VS2 (BVSEN_BVRSEN) analog offset trim

</pre> */

#define TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Pos                   14                                                                     /*!< Right-most bit position of vs2_os_trim_bif in TRIM.VS_OS_TRIM */
#define TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Msk                   (0x0000007FUL << TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Pos)                /*!< Mask for vs2_os_trim_bif in TRIM.VS_OS_TRIM */
#define TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Shift(v)              (((v) << TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Pos) & TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Msk) /*!< Shift value 'v' into vs2_os_trim_bif and mask 'v' to fit it into vs2_os_trim_bif field */

/** TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__SET() sets VS_OS_TRIM.VS2_OS_TRIM_BIF to given value.
 *
 * When writing to VS_OS_TRIM.VS2_OS_TRIM_BIF, this is recommended to use.
 *
 * @param bf_value new value for VS_OS_TRIM.VS2_OS_TRIM_BIF
 */
__TRIM_INLINE void TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_VS_OS_TRIM__GET();
    reg = (reg & ~TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Msk);
    reg = (reg | (TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Shift((uint32_t)bf_value)));
    TRIM_VS_OS_TRIM__SET(reg);
}

/** TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__GET() gets VS_OS_TRIM.VS2_OS_TRIM_BIF's current value.
 *
 * When reading from VS_OS_TRIM.VS2_OS_TRIM_BIF, this is recommended to use.
 *
 * @return current value of VS_OS_TRIM.VS2_OS_TRIM_BIF
 */
__TRIM_INLINE uint32_t TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__GET(void)
{
    uint32_t reg = TRIM_VS_OS_TRIM__GET();
    reg = (reg & TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Msk);
    reg = (reg >> TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Pos);
    return (uint32_t)reg;
}

/** TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__MODIFY() modifies VS_OS_TRIM.VS2_OS_TRIM_BIF.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.VS_OS_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.VS_OS_TRIM
 * @param bf_value new value for VS_OS_TRIM.VS2_OS_TRIM_BIF
 * @return new value of TRIM.VS_OS_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Msk);
    reg = (reg | (TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__EXTRACT() extracts VS_OS_TRIM.VS2_OS_TRIM_BIF.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.VS_OS_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.VS_OS_TRIM
 * @return current value of VS_OS_TRIM.VS2_OS_TRIM_BIF
 */
__TRIM_INLINE uint32_t TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Msk);
    reg = (reg >> TRIM_VS_OS_TRIM__VS2_OS_TRIM_BIF__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.VS_OS_TRIM.VS1_OS_TRIM_BIF -------------------- */

/**
<pre>
  TRIM.VS_OS_TRIM.VS1_OS_TRIM_BIF:

    VS1 (VRSEN) analog offset trim

</pre> */

#define TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Pos                   7                                                                      /*!< Right-most bit position of vs1_os_trim_bif in TRIM.VS_OS_TRIM */
#define TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Msk                   (0x0000007FUL << TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Pos)                /*!< Mask for vs1_os_trim_bif in TRIM.VS_OS_TRIM */
#define TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Shift(v)              (((v) << TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Pos) & TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Msk) /*!< Shift value 'v' into vs1_os_trim_bif and mask 'v' to fit it into vs1_os_trim_bif field */

/** TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__SET() sets VS_OS_TRIM.VS1_OS_TRIM_BIF to given value.
 *
 * When writing to VS_OS_TRIM.VS1_OS_TRIM_BIF, this is recommended to use.
 *
 * @param bf_value new value for VS_OS_TRIM.VS1_OS_TRIM_BIF
 */
__TRIM_INLINE void TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_VS_OS_TRIM__GET();
    reg = (reg & ~TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Msk);
    reg = (reg | (TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Shift((uint32_t)bf_value)));
    TRIM_VS_OS_TRIM__SET(reg);
}

/** TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__GET() gets VS_OS_TRIM.VS1_OS_TRIM_BIF's current value.
 *
 * When reading from VS_OS_TRIM.VS1_OS_TRIM_BIF, this is recommended to use.
 *
 * @return current value of VS_OS_TRIM.VS1_OS_TRIM_BIF
 */
__TRIM_INLINE uint32_t TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__GET(void)
{
    uint32_t reg = TRIM_VS_OS_TRIM__GET();
    reg = (reg & TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Msk);
    reg = (reg >> TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Pos);
    return (uint32_t)reg;
}

/** TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__MODIFY() modifies VS_OS_TRIM.VS1_OS_TRIM_BIF.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.VS_OS_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.VS_OS_TRIM
 * @param bf_value new value for VS_OS_TRIM.VS1_OS_TRIM_BIF
 * @return new value of TRIM.VS_OS_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Msk);
    reg = (reg | (TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__EXTRACT() extracts VS_OS_TRIM.VS1_OS_TRIM_BIF.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.VS_OS_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.VS_OS_TRIM
 * @return current value of VS_OS_TRIM.VS1_OS_TRIM_BIF
 */
__TRIM_INLINE uint32_t TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Msk);
    reg = (reg >> TRIM_VS_OS_TRIM__VS1_OS_TRIM_BIF__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.VS_OS_TRIM.VS0_OS_TRIM_BIF -------------------- */

/**
<pre>
  TRIM.VS_OS_TRIM.VS0_OS_TRIM_BIF:

    VS0 (VSEN) analog offset trim

</pre> */

#define TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Pos                   0                                                                      /*!< Right-most bit position of vs0_os_trim_bif in TRIM.VS_OS_TRIM */
#define TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Msk                   (0x0000007FUL << TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Pos)                /*!< Mask for vs0_os_trim_bif in TRIM.VS_OS_TRIM */
#define TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Shift(v)              (((v) << TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Pos) & TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Msk) /*!< Shift value 'v' into vs0_os_trim_bif and mask 'v' to fit it into vs0_os_trim_bif field */

/** TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__SET() sets VS_OS_TRIM.VS0_OS_TRIM_BIF to given value.
 *
 * When writing to VS_OS_TRIM.VS0_OS_TRIM_BIF, this is recommended to use.
 *
 * @param bf_value new value for VS_OS_TRIM.VS0_OS_TRIM_BIF
 */
__TRIM_INLINE void TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_VS_OS_TRIM__GET();
    reg = (reg & ~TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Msk);
    reg = (reg | (TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Shift((uint32_t)bf_value)));
    TRIM_VS_OS_TRIM__SET(reg);
}

/** TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__GET() gets VS_OS_TRIM.VS0_OS_TRIM_BIF's current value.
 *
 * When reading from VS_OS_TRIM.VS0_OS_TRIM_BIF, this is recommended to use.
 *
 * @return current value of VS_OS_TRIM.VS0_OS_TRIM_BIF
 */
__TRIM_INLINE uint32_t TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__GET(void)
{
    uint32_t reg = TRIM_VS_OS_TRIM__GET();
    reg = (reg & TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Msk);
    reg = (reg >> TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Pos);
    return (uint32_t)reg;
}

/** TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__MODIFY() modifies VS_OS_TRIM.VS0_OS_TRIM_BIF.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.VS_OS_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.VS_OS_TRIM
 * @param bf_value new value for VS_OS_TRIM.VS0_OS_TRIM_BIF
 * @return new value of TRIM.VS_OS_TRIM
 */
__TRIM_INLINE uint32_t TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Msk);
    reg = (reg | (TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__EXTRACT() extracts VS_OS_TRIM.VS0_OS_TRIM_BIF.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.VS_OS_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.VS_OS_TRIM
 * @return current value of VS_OS_TRIM.VS0_OS_TRIM_BIF
 */
__TRIM_INLINE uint32_t TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Msk);
    reg = (reg >> TRIM_VS_OS_TRIM__VS0_OS_TRIM_BIF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       IS1_GAIN_TRIM member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_IS1_GAIN_TRIM__ADDRESS returns the address of member IS1_GAIN_TRIM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IS1_GAIN_TRIM
 */
__TRIM_INLINE uint32_t* __TRIM_IS1_GAIN_TRIM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IS1_GAIN_TRIM)));
}

/** TRIM_IS1_GAIN_TRIM__SET() sets IS1_GAIN_TRIM to given value.
 *
 * When writing to IS1_GAIN_TRIM, this is mandatory to use.
 *
 * @param value new value for IS1_GAIN_TRIM
 */
__TRIM_INLINE void TRIM_IS1_GAIN_TRIM__SET(uint32_t value)
{
    HAL_SET32(__TRIM_IS1_GAIN_TRIM__ADDRESS(), value);
}

/** TRIM_IS1_GAIN_TRIM__GET() gets IS1_GAIN_TRIM's current value.
 *
 * When reading from IS1_GAIN_TRIM, this is mandatory to use.
 *
 * @return current value of IS1_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__GET(void)
{
    return HAL_GET32(__TRIM_IS1_GAIN_TRIM__ADDRESS());
}

/* -------------------- TRIM.IS1_GAIN_TRIM.IS1_ATE_GAIN3 -------------------- */

/**
<pre>
  TRIM.IS1_GAIN_TRIM.IS1_ATE_GAIN3:

    IS1 (ISEN) ADC gain trim when isen1_gain_mode=3.

</pre> */

#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Pos                  24                                                                     /*!< Right-most bit position of is1_ate_gain3 in TRIM.IS1_GAIN_TRIM */
#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Msk                  (0x000000FFUL << TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Pos)               /*!< Mask for is1_ate_gain3 in TRIM.IS1_GAIN_TRIM */
#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Shift(v)             (((v) << TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Pos) & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Msk) /*!< Shift value 'v' into is1_ate_gain3 and mask 'v' to fit it into is1_ate_gain3 field */

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__SET() sets IS1_GAIN_TRIM.IS1_ATE_GAIN3 to given value.
 *
 * When writing to IS1_GAIN_TRIM.IS1_ATE_GAIN3, this is recommended to use.
 *
 * @param bf_value new value for IS1_GAIN_TRIM.IS1_ATE_GAIN3
 */
__TRIM_INLINE void TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS1_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Msk);
    reg = (reg | (TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Shift((uint32_t)bf_value)));
    TRIM_IS1_GAIN_TRIM__SET(reg);
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__GET() gets IS1_GAIN_TRIM.IS1_ATE_GAIN3's current value.
 *
 * When reading from IS1_GAIN_TRIM.IS1_ATE_GAIN3, this is recommended to use.
 *
 * @return current value of IS1_GAIN_TRIM.IS1_ATE_GAIN3
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__GET(void)
{
    uint32_t reg = TRIM_IS1_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Msk);
    reg = (reg >> TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__MODIFY() modifies IS1_GAIN_TRIM.IS1_ATE_GAIN3.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS1_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS1_GAIN_TRIM
 * @param bf_value new value for IS1_GAIN_TRIM.IS1_ATE_GAIN3
 * @return new value of TRIM.IS1_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Msk);
    reg = (reg | (TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__EXTRACT() extracts IS1_GAIN_TRIM.IS1_ATE_GAIN3.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS1_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS1_GAIN_TRIM
 * @return current value of IS1_GAIN_TRIM.IS1_ATE_GAIN3
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Msk);
    reg = (reg >> TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN3__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.IS1_GAIN_TRIM.IS1_ATE_GAIN2 -------------------- */

/**
<pre>
  TRIM.IS1_GAIN_TRIM.IS1_ATE_GAIN2:

    IS1 (ISEN) ADC gain trim when isen1_gain_mode=2.

</pre> */

#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Pos                  16                                                                     /*!< Right-most bit position of is1_ate_gain2 in TRIM.IS1_GAIN_TRIM */
#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Msk                  (0x000000FFUL << TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Pos)               /*!< Mask for is1_ate_gain2 in TRIM.IS1_GAIN_TRIM */
#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Shift(v)             (((v) << TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Pos) & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Msk) /*!< Shift value 'v' into is1_ate_gain2 and mask 'v' to fit it into is1_ate_gain2 field */

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__SET() sets IS1_GAIN_TRIM.IS1_ATE_GAIN2 to given value.
 *
 * When writing to IS1_GAIN_TRIM.IS1_ATE_GAIN2, this is recommended to use.
 *
 * @param bf_value new value for IS1_GAIN_TRIM.IS1_ATE_GAIN2
 */
__TRIM_INLINE void TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS1_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Msk);
    reg = (reg | (TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Shift((uint32_t)bf_value)));
    TRIM_IS1_GAIN_TRIM__SET(reg);
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__GET() gets IS1_GAIN_TRIM.IS1_ATE_GAIN2's current value.
 *
 * When reading from IS1_GAIN_TRIM.IS1_ATE_GAIN2, this is recommended to use.
 *
 * @return current value of IS1_GAIN_TRIM.IS1_ATE_GAIN2
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__GET(void)
{
    uint32_t reg = TRIM_IS1_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Msk);
    reg = (reg >> TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__MODIFY() modifies IS1_GAIN_TRIM.IS1_ATE_GAIN2.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS1_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS1_GAIN_TRIM
 * @param bf_value new value for IS1_GAIN_TRIM.IS1_ATE_GAIN2
 * @return new value of TRIM.IS1_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Msk);
    reg = (reg | (TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__EXTRACT() extracts IS1_GAIN_TRIM.IS1_ATE_GAIN2.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS1_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS1_GAIN_TRIM
 * @return current value of IS1_GAIN_TRIM.IS1_ATE_GAIN2
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Msk);
    reg = (reg >> TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN2__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.IS1_GAIN_TRIM.IS1_ATE_GAIN1 -------------------- */

/**
<pre>
  TRIM.IS1_GAIN_TRIM.IS1_ATE_GAIN1:

    IS1 (ISEN) ADC gain trim when isen1_gain_mode=1.

</pre> */

#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Pos                  8                                                                      /*!< Right-most bit position of is1_ate_gain1 in TRIM.IS1_GAIN_TRIM */
#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Msk                  (0x000000FFUL << TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Pos)               /*!< Mask for is1_ate_gain1 in TRIM.IS1_GAIN_TRIM */
#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Shift(v)             (((v) << TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Pos) & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Msk) /*!< Shift value 'v' into is1_ate_gain1 and mask 'v' to fit it into is1_ate_gain1 field */

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__SET() sets IS1_GAIN_TRIM.IS1_ATE_GAIN1 to given value.
 *
 * When writing to IS1_GAIN_TRIM.IS1_ATE_GAIN1, this is recommended to use.
 *
 * @param bf_value new value for IS1_GAIN_TRIM.IS1_ATE_GAIN1
 */
__TRIM_INLINE void TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS1_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Msk);
    reg = (reg | (TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Shift((uint32_t)bf_value)));
    TRIM_IS1_GAIN_TRIM__SET(reg);
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__GET() gets IS1_GAIN_TRIM.IS1_ATE_GAIN1's current value.
 *
 * When reading from IS1_GAIN_TRIM.IS1_ATE_GAIN1, this is recommended to use.
 *
 * @return current value of IS1_GAIN_TRIM.IS1_ATE_GAIN1
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__GET(void)
{
    uint32_t reg = TRIM_IS1_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Msk);
    reg = (reg >> TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__MODIFY() modifies IS1_GAIN_TRIM.IS1_ATE_GAIN1.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS1_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS1_GAIN_TRIM
 * @param bf_value new value for IS1_GAIN_TRIM.IS1_ATE_GAIN1
 * @return new value of TRIM.IS1_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Msk);
    reg = (reg | (TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__EXTRACT() extracts IS1_GAIN_TRIM.IS1_ATE_GAIN1.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS1_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS1_GAIN_TRIM
 * @return current value of IS1_GAIN_TRIM.IS1_ATE_GAIN1
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Msk);
    reg = (reg >> TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN1__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.IS1_GAIN_TRIM.IS1_ATE_GAIN0 -------------------- */

/**
<pre>
  TRIM.IS1_GAIN_TRIM.IS1_ATE_GAIN0:

    IS1 (ISEN) ADC gain trim when isen1_gain_mode=0.

</pre> */

#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Pos                  0                                                                      /*!< Right-most bit position of is1_ate_gain0 in TRIM.IS1_GAIN_TRIM */
#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Msk                  (0x000000FFUL << TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Pos)               /*!< Mask for is1_ate_gain0 in TRIM.IS1_GAIN_TRIM */
#define TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Shift(v)             (((v) << TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Pos) & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Msk) /*!< Shift value 'v' into is1_ate_gain0 and mask 'v' to fit it into is1_ate_gain0 field */

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__SET() sets IS1_GAIN_TRIM.IS1_ATE_GAIN0 to given value.
 *
 * When writing to IS1_GAIN_TRIM.IS1_ATE_GAIN0, this is recommended to use.
 *
 * @param bf_value new value for IS1_GAIN_TRIM.IS1_ATE_GAIN0
 */
__TRIM_INLINE void TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS1_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Msk);
    reg = (reg | (TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Shift((uint32_t)bf_value)));
    TRIM_IS1_GAIN_TRIM__SET(reg);
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__GET() gets IS1_GAIN_TRIM.IS1_ATE_GAIN0's current value.
 *
 * When reading from IS1_GAIN_TRIM.IS1_ATE_GAIN0, this is recommended to use.
 *
 * @return current value of IS1_GAIN_TRIM.IS1_ATE_GAIN0
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__GET(void)
{
    uint32_t reg = TRIM_IS1_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Msk);
    reg = (reg >> TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__MODIFY() modifies IS1_GAIN_TRIM.IS1_ATE_GAIN0.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS1_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS1_GAIN_TRIM
 * @param bf_value new value for IS1_GAIN_TRIM.IS1_ATE_GAIN0
 * @return new value of TRIM.IS1_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Msk);
    reg = (reg | (TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__EXTRACT() extracts IS1_GAIN_TRIM.IS1_ATE_GAIN0.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS1_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS1_GAIN_TRIM
 * @return current value of IS1_GAIN_TRIM.IS1_ATE_GAIN0
 */
__TRIM_INLINE uint32_t TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Msk);
    reg = (reg >> TRIM_IS1_GAIN_TRIM__IS1_ATE_GAIN0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       IS2_GAIN_TRIM member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_IS2_GAIN_TRIM__ADDRESS returns the address of member IS2_GAIN_TRIM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IS2_GAIN_TRIM
 */
__TRIM_INLINE uint32_t* __TRIM_IS2_GAIN_TRIM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IS2_GAIN_TRIM)));
}

/** TRIM_IS2_GAIN_TRIM__SET() sets IS2_GAIN_TRIM to given value.
 *
 * When writing to IS2_GAIN_TRIM, this is mandatory to use.
 *
 * @param value new value for IS2_GAIN_TRIM
 */
__TRIM_INLINE void TRIM_IS2_GAIN_TRIM__SET(uint32_t value)
{
    HAL_SET32(__TRIM_IS2_GAIN_TRIM__ADDRESS(), value);
}

/** TRIM_IS2_GAIN_TRIM__GET() gets IS2_GAIN_TRIM's current value.
 *
 * When reading from IS2_GAIN_TRIM, this is mandatory to use.
 *
 * @return current value of IS2_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__GET(void)
{
    return HAL_GET32(__TRIM_IS2_GAIN_TRIM__ADDRESS());
}

/* -------------------- TRIM.IS2_GAIN_TRIM.IS2_ATE_GAIN3 -------------------- */

/**
<pre>
  TRIM.IS2_GAIN_TRIM.IS2_ATE_GAIN3:

    IS2 (calibration) ADC gain trim when isen1/2_gain_mode=3.

</pre> */

#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Pos                  24                                                                     /*!< Right-most bit position of is2_ate_gain3 in TRIM.IS2_GAIN_TRIM */
#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Msk                  (0x000000FFUL << TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Pos)               /*!< Mask for is2_ate_gain3 in TRIM.IS2_GAIN_TRIM */
#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Shift(v)             (((v) << TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Pos) & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Msk) /*!< Shift value 'v' into is2_ate_gain3 and mask 'v' to fit it into is2_ate_gain3 field */

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__SET() sets IS2_GAIN_TRIM.IS2_ATE_GAIN3 to given value.
 *
 * When writing to IS2_GAIN_TRIM.IS2_ATE_GAIN3, this is recommended to use.
 *
 * @param bf_value new value for IS2_GAIN_TRIM.IS2_ATE_GAIN3
 */
__TRIM_INLINE void TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS2_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Msk);
    reg = (reg | (TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Shift((uint32_t)bf_value)));
    TRIM_IS2_GAIN_TRIM__SET(reg);
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__GET() gets IS2_GAIN_TRIM.IS2_ATE_GAIN3's current value.
 *
 * When reading from IS2_GAIN_TRIM.IS2_ATE_GAIN3, this is recommended to use.
 *
 * @return current value of IS2_GAIN_TRIM.IS2_ATE_GAIN3
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__GET(void)
{
    uint32_t reg = TRIM_IS2_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Msk);
    reg = (reg >> TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__MODIFY() modifies IS2_GAIN_TRIM.IS2_ATE_GAIN3.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS2_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS2_GAIN_TRIM
 * @param bf_value new value for IS2_GAIN_TRIM.IS2_ATE_GAIN3
 * @return new value of TRIM.IS2_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Msk);
    reg = (reg | (TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__EXTRACT() extracts IS2_GAIN_TRIM.IS2_ATE_GAIN3.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS2_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS2_GAIN_TRIM
 * @return current value of IS2_GAIN_TRIM.IS2_ATE_GAIN3
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Msk);
    reg = (reg >> TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN3__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.IS2_GAIN_TRIM.IS2_ATE_GAIN2 -------------------- */

/**
<pre>
  TRIM.IS2_GAIN_TRIM.IS2_ATE_GAIN2:

    IS2 (calibration) ADC gain trim when isen1/2_gain_mode=2.

</pre> */

#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Pos                  16                                                                     /*!< Right-most bit position of is2_ate_gain2 in TRIM.IS2_GAIN_TRIM */
#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Msk                  (0x000000FFUL << TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Pos)               /*!< Mask for is2_ate_gain2 in TRIM.IS2_GAIN_TRIM */
#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Shift(v)             (((v) << TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Pos) & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Msk) /*!< Shift value 'v' into is2_ate_gain2 and mask 'v' to fit it into is2_ate_gain2 field */

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__SET() sets IS2_GAIN_TRIM.IS2_ATE_GAIN2 to given value.
 *
 * When writing to IS2_GAIN_TRIM.IS2_ATE_GAIN2, this is recommended to use.
 *
 * @param bf_value new value for IS2_GAIN_TRIM.IS2_ATE_GAIN2
 */
__TRIM_INLINE void TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS2_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Msk);
    reg = (reg | (TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Shift((uint32_t)bf_value)));
    TRIM_IS2_GAIN_TRIM__SET(reg);
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__GET() gets IS2_GAIN_TRIM.IS2_ATE_GAIN2's current value.
 *
 * When reading from IS2_GAIN_TRIM.IS2_ATE_GAIN2, this is recommended to use.
 *
 * @return current value of IS2_GAIN_TRIM.IS2_ATE_GAIN2
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__GET(void)
{
    uint32_t reg = TRIM_IS2_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Msk);
    reg = (reg >> TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__MODIFY() modifies IS2_GAIN_TRIM.IS2_ATE_GAIN2.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS2_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS2_GAIN_TRIM
 * @param bf_value new value for IS2_GAIN_TRIM.IS2_ATE_GAIN2
 * @return new value of TRIM.IS2_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Msk);
    reg = (reg | (TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__EXTRACT() extracts IS2_GAIN_TRIM.IS2_ATE_GAIN2.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS2_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS2_GAIN_TRIM
 * @return current value of IS2_GAIN_TRIM.IS2_ATE_GAIN2
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Msk);
    reg = (reg >> TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN2__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.IS2_GAIN_TRIM.IS2_ATE_GAIN1 -------------------- */

/**
<pre>
  TRIM.IS2_GAIN_TRIM.IS2_ATE_GAIN1:

    IS2 (calibration) ADC gain trim when isen1/2_gain_mode=1.

</pre> */

#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Pos                  8                                                                      /*!< Right-most bit position of is2_ate_gain1 in TRIM.IS2_GAIN_TRIM */
#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Msk                  (0x000000FFUL << TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Pos)               /*!< Mask for is2_ate_gain1 in TRIM.IS2_GAIN_TRIM */
#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Shift(v)             (((v) << TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Pos) & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Msk) /*!< Shift value 'v' into is2_ate_gain1 and mask 'v' to fit it into is2_ate_gain1 field */

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__SET() sets IS2_GAIN_TRIM.IS2_ATE_GAIN1 to given value.
 *
 * When writing to IS2_GAIN_TRIM.IS2_ATE_GAIN1, this is recommended to use.
 *
 * @param bf_value new value for IS2_GAIN_TRIM.IS2_ATE_GAIN1
 */
__TRIM_INLINE void TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS2_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Msk);
    reg = (reg | (TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Shift((uint32_t)bf_value)));
    TRIM_IS2_GAIN_TRIM__SET(reg);
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__GET() gets IS2_GAIN_TRIM.IS2_ATE_GAIN1's current value.
 *
 * When reading from IS2_GAIN_TRIM.IS2_ATE_GAIN1, this is recommended to use.
 *
 * @return current value of IS2_GAIN_TRIM.IS2_ATE_GAIN1
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__GET(void)
{
    uint32_t reg = TRIM_IS2_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Msk);
    reg = (reg >> TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__MODIFY() modifies IS2_GAIN_TRIM.IS2_ATE_GAIN1.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS2_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS2_GAIN_TRIM
 * @param bf_value new value for IS2_GAIN_TRIM.IS2_ATE_GAIN1
 * @return new value of TRIM.IS2_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Msk);
    reg = (reg | (TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__EXTRACT() extracts IS2_GAIN_TRIM.IS2_ATE_GAIN1.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS2_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS2_GAIN_TRIM
 * @return current value of IS2_GAIN_TRIM.IS2_ATE_GAIN1
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Msk);
    reg = (reg >> TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN1__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.IS2_GAIN_TRIM.IS2_ATE_GAIN0 -------------------- */

/**
<pre>
  TRIM.IS2_GAIN_TRIM.IS2_ATE_GAIN0:

    IS2 (calibration) ADC gain trim when isen1/2_gain_mode=0.

</pre> */

#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Pos                  0                                                                      /*!< Right-most bit position of is2_ate_gain0 in TRIM.IS2_GAIN_TRIM */
#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Msk                  (0x000000FFUL << TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Pos)               /*!< Mask for is2_ate_gain0 in TRIM.IS2_GAIN_TRIM */
#define TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Shift(v)             (((v) << TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Pos) & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Msk) /*!< Shift value 'v' into is2_ate_gain0 and mask 'v' to fit it into is2_ate_gain0 field */

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__SET() sets IS2_GAIN_TRIM.IS2_ATE_GAIN0 to given value.
 *
 * When writing to IS2_GAIN_TRIM.IS2_ATE_GAIN0, this is recommended to use.
 *
 * @param bf_value new value for IS2_GAIN_TRIM.IS2_ATE_GAIN0
 */
__TRIM_INLINE void TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS2_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Msk);
    reg = (reg | (TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Shift((uint32_t)bf_value)));
    TRIM_IS2_GAIN_TRIM__SET(reg);
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__GET() gets IS2_GAIN_TRIM.IS2_ATE_GAIN0's current value.
 *
 * When reading from IS2_GAIN_TRIM.IS2_ATE_GAIN0, this is recommended to use.
 *
 * @return current value of IS2_GAIN_TRIM.IS2_ATE_GAIN0
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__GET(void)
{
    uint32_t reg = TRIM_IS2_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Msk);
    reg = (reg >> TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__MODIFY() modifies IS2_GAIN_TRIM.IS2_ATE_GAIN0.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS2_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS2_GAIN_TRIM
 * @param bf_value new value for IS2_GAIN_TRIM.IS2_ATE_GAIN0
 * @return new value of TRIM.IS2_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Msk);
    reg = (reg | (TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__EXTRACT() extracts IS2_GAIN_TRIM.IS2_ATE_GAIN0.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS2_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS2_GAIN_TRIM
 * @return current value of IS2_GAIN_TRIM.IS2_ATE_GAIN0
 */
__TRIM_INLINE uint32_t TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Msk);
    reg = (reg >> TRIM_IS2_GAIN_TRIM__IS2_ATE_GAIN0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       IS3_GAIN_TRIM member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_IS3_GAIN_TRIM__ADDRESS returns the address of member IS3_GAIN_TRIM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IS3_GAIN_TRIM
 */
__TRIM_INLINE uint32_t* __TRIM_IS3_GAIN_TRIM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IS3_GAIN_TRIM)));
}

/** TRIM_IS3_GAIN_TRIM__SET() sets IS3_GAIN_TRIM to given value.
 *
 * When writing to IS3_GAIN_TRIM, this is mandatory to use.
 *
 * @param value new value for IS3_GAIN_TRIM
 */
__TRIM_INLINE void TRIM_IS3_GAIN_TRIM__SET(uint32_t value)
{
    HAL_SET32(__TRIM_IS3_GAIN_TRIM__ADDRESS(), value);
}

/** TRIM_IS3_GAIN_TRIM__GET() gets IS3_GAIN_TRIM's current value.
 *
 * When reading from IS3_GAIN_TRIM, this is mandatory to use.
 *
 * @return current value of IS3_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__GET(void)
{
    return HAL_GET32(__TRIM_IS3_GAIN_TRIM__ADDRESS());
}

/* -------------------- TRIM.IS3_GAIN_TRIM.IS3_ATE_GAIN3 -------------------- */

/**
<pre>
  TRIM.IS3_GAIN_TRIM.IS3_ATE_GAIN3:

    IS3 (BISEN) ADC gain trim when isen2_gain_mode=3.

</pre> */

#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Pos                  24                                                                     /*!< Right-most bit position of is3_ate_gain3 in TRIM.IS3_GAIN_TRIM */
#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Msk                  (0x000000FFUL << TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Pos)               /*!< Mask for is3_ate_gain3 in TRIM.IS3_GAIN_TRIM */
#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Shift(v)             (((v) << TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Pos) & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Msk) /*!< Shift value 'v' into is3_ate_gain3 and mask 'v' to fit it into is3_ate_gain3 field */

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__SET() sets IS3_GAIN_TRIM.IS3_ATE_GAIN3 to given value.
 *
 * When writing to IS3_GAIN_TRIM.IS3_ATE_GAIN3, this is recommended to use.
 *
 * @param bf_value new value for IS3_GAIN_TRIM.IS3_ATE_GAIN3
 */
__TRIM_INLINE void TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS3_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Msk);
    reg = (reg | (TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Shift((uint32_t)bf_value)));
    TRIM_IS3_GAIN_TRIM__SET(reg);
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__GET() gets IS3_GAIN_TRIM.IS3_ATE_GAIN3's current value.
 *
 * When reading from IS3_GAIN_TRIM.IS3_ATE_GAIN3, this is recommended to use.
 *
 * @return current value of IS3_GAIN_TRIM.IS3_ATE_GAIN3
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__GET(void)
{
    uint32_t reg = TRIM_IS3_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Msk);
    reg = (reg >> TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__MODIFY() modifies IS3_GAIN_TRIM.IS3_ATE_GAIN3.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS3_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS3_GAIN_TRIM
 * @param bf_value new value for IS3_GAIN_TRIM.IS3_ATE_GAIN3
 * @return new value of TRIM.IS3_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Msk);
    reg = (reg | (TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__EXTRACT() extracts IS3_GAIN_TRIM.IS3_ATE_GAIN3.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS3_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS3_GAIN_TRIM
 * @return current value of IS3_GAIN_TRIM.IS3_ATE_GAIN3
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Msk);
    reg = (reg >> TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN3__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.IS3_GAIN_TRIM.IS3_ATE_GAIN2 -------------------- */

/**
<pre>
  TRIM.IS3_GAIN_TRIM.IS3_ATE_GAIN2:

    IS3 (BISEN) ADC gain trim when isen2_gain_mode=2.

</pre> */

#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Pos                  16                                                                     /*!< Right-most bit position of is3_ate_gain2 in TRIM.IS3_GAIN_TRIM */
#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Msk                  (0x000000FFUL << TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Pos)               /*!< Mask for is3_ate_gain2 in TRIM.IS3_GAIN_TRIM */
#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Shift(v)             (((v) << TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Pos) & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Msk) /*!< Shift value 'v' into is3_ate_gain2 and mask 'v' to fit it into is3_ate_gain2 field */

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__SET() sets IS3_GAIN_TRIM.IS3_ATE_GAIN2 to given value.
 *
 * When writing to IS3_GAIN_TRIM.IS3_ATE_GAIN2, this is recommended to use.
 *
 * @param bf_value new value for IS3_GAIN_TRIM.IS3_ATE_GAIN2
 */
__TRIM_INLINE void TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS3_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Msk);
    reg = (reg | (TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Shift((uint32_t)bf_value)));
    TRIM_IS3_GAIN_TRIM__SET(reg);
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__GET() gets IS3_GAIN_TRIM.IS3_ATE_GAIN2's current value.
 *
 * When reading from IS3_GAIN_TRIM.IS3_ATE_GAIN2, this is recommended to use.
 *
 * @return current value of IS3_GAIN_TRIM.IS3_ATE_GAIN2
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__GET(void)
{
    uint32_t reg = TRIM_IS3_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Msk);
    reg = (reg >> TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__MODIFY() modifies IS3_GAIN_TRIM.IS3_ATE_GAIN2.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS3_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS3_GAIN_TRIM
 * @param bf_value new value for IS3_GAIN_TRIM.IS3_ATE_GAIN2
 * @return new value of TRIM.IS3_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Msk);
    reg = (reg | (TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__EXTRACT() extracts IS3_GAIN_TRIM.IS3_ATE_GAIN2.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS3_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS3_GAIN_TRIM
 * @return current value of IS3_GAIN_TRIM.IS3_ATE_GAIN2
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Msk);
    reg = (reg >> TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN2__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.IS3_GAIN_TRIM.IS3_ATE_GAIN1 -------------------- */

/**
<pre>
  TRIM.IS3_GAIN_TRIM.IS3_ATE_GAIN1:

    IS3 (BISEN) ADC gain trim when isen2_gain_mode=1.

</pre> */

#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Pos                  8                                                                      /*!< Right-most bit position of is3_ate_gain1 in TRIM.IS3_GAIN_TRIM */
#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Msk                  (0x000000FFUL << TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Pos)               /*!< Mask for is3_ate_gain1 in TRIM.IS3_GAIN_TRIM */
#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Shift(v)             (((v) << TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Pos) & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Msk) /*!< Shift value 'v' into is3_ate_gain1 and mask 'v' to fit it into is3_ate_gain1 field */

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__SET() sets IS3_GAIN_TRIM.IS3_ATE_GAIN1 to given value.
 *
 * When writing to IS3_GAIN_TRIM.IS3_ATE_GAIN1, this is recommended to use.
 *
 * @param bf_value new value for IS3_GAIN_TRIM.IS3_ATE_GAIN1
 */
__TRIM_INLINE void TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS3_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Msk);
    reg = (reg | (TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Shift((uint32_t)bf_value)));
    TRIM_IS3_GAIN_TRIM__SET(reg);
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__GET() gets IS3_GAIN_TRIM.IS3_ATE_GAIN1's current value.
 *
 * When reading from IS3_GAIN_TRIM.IS3_ATE_GAIN1, this is recommended to use.
 *
 * @return current value of IS3_GAIN_TRIM.IS3_ATE_GAIN1
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__GET(void)
{
    uint32_t reg = TRIM_IS3_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Msk);
    reg = (reg >> TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__MODIFY() modifies IS3_GAIN_TRIM.IS3_ATE_GAIN1.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS3_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS3_GAIN_TRIM
 * @param bf_value new value for IS3_GAIN_TRIM.IS3_ATE_GAIN1
 * @return new value of TRIM.IS3_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Msk);
    reg = (reg | (TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__EXTRACT() extracts IS3_GAIN_TRIM.IS3_ATE_GAIN1.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS3_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS3_GAIN_TRIM
 * @return current value of IS3_GAIN_TRIM.IS3_ATE_GAIN1
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Msk);
    reg = (reg >> TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN1__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.IS3_GAIN_TRIM.IS3_ATE_GAIN0 -------------------- */

/**
<pre>
  TRIM.IS3_GAIN_TRIM.IS3_ATE_GAIN0:

    IS3 (BISEN) ADC gain trim when isen2_gain_mode=0.

</pre> */

#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Pos                  0                                                                      /*!< Right-most bit position of is3_ate_gain0 in TRIM.IS3_GAIN_TRIM */
#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Msk                  (0x000000FFUL << TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Pos)               /*!< Mask for is3_ate_gain0 in TRIM.IS3_GAIN_TRIM */
#define TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Shift(v)             (((v) << TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Pos) & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Msk) /*!< Shift value 'v' into is3_ate_gain0 and mask 'v' to fit it into is3_ate_gain0 field */

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__SET() sets IS3_GAIN_TRIM.IS3_ATE_GAIN0 to given value.
 *
 * When writing to IS3_GAIN_TRIM.IS3_ATE_GAIN0, this is recommended to use.
 *
 * @param bf_value new value for IS3_GAIN_TRIM.IS3_ATE_GAIN0
 */
__TRIM_INLINE void TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS3_GAIN_TRIM__GET();
    reg = (reg & ~TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Msk);
    reg = (reg | (TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Shift((uint32_t)bf_value)));
    TRIM_IS3_GAIN_TRIM__SET(reg);
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__GET() gets IS3_GAIN_TRIM.IS3_ATE_GAIN0's current value.
 *
 * When reading from IS3_GAIN_TRIM.IS3_ATE_GAIN0, this is recommended to use.
 *
 * @return current value of IS3_GAIN_TRIM.IS3_ATE_GAIN0
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__GET(void)
{
    uint32_t reg = TRIM_IS3_GAIN_TRIM__GET();
    reg = (reg & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Msk);
    reg = (reg >> TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__MODIFY() modifies IS3_GAIN_TRIM.IS3_ATE_GAIN0.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS3_GAIN_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS3_GAIN_TRIM
 * @param bf_value new value for IS3_GAIN_TRIM.IS3_ATE_GAIN0
 * @return new value of TRIM.IS3_GAIN_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Msk);
    reg = (reg | (TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__EXTRACT() extracts IS3_GAIN_TRIM.IS3_ATE_GAIN0.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS3_GAIN_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS3_GAIN_TRIM
 * @return current value of IS3_GAIN_TRIM.IS3_ATE_GAIN0
 */
__TRIM_INLINE uint32_t TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Msk);
    reg = (reg >> TRIM_IS3_GAIN_TRIM__IS3_ATE_GAIN0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TS_TRIM1 member of TRIM_t                         */
/* -------------------------------------------------------------------------- */

/** __TRIM_TS_TRIM1__ADDRESS returns the address of member TS_TRIM1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TS_TRIM1
 */
__TRIM_INLINE uint32_t* __TRIM_TS_TRIM1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, TS_TRIM1)));
}

/** TRIM_TS_TRIM1__SET() sets TS_TRIM1 to given value.
 *
 * When writing to TS_TRIM1, this is mandatory to use.
 *
 * @param value new value for TS_TRIM1
 */
__TRIM_INLINE void TRIM_TS_TRIM1__SET(uint32_t value)
{
    HAL_SET32(__TRIM_TS_TRIM1__ADDRESS(), value);
}

/** TRIM_TS_TRIM1__GET() gets TS_TRIM1's current value.
 *
 * When reading from TS_TRIM1, this is mandatory to use.
 *
 * @return current value of TS_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__GET(void)
{
    return HAL_GET32(__TRIM_TS_TRIM1__ADDRESS());
}

/* --------------------- TRIM.TS_TRIM1.IMON_ATE_OFFSET --------------------- */

/**
<pre>
  TRIM.TS_TRIM1.IMON_ATE_OFFSET:

    Telemetry ADC, IMON input offset trim.

</pre> */

#define TRIM_TS_TRIM1__IMON_ATE_OFFSET__Pos                     24                                                                     /*!< Right-most bit position of imon_ate_offset in TRIM.TS_TRIM1 */
#define TRIM_TS_TRIM1__IMON_ATE_OFFSET__Msk                     (0x000000FFUL << TRIM_TS_TRIM1__IMON_ATE_OFFSET__Pos)                  /*!< Mask for imon_ate_offset in TRIM.TS_TRIM1 */
#define TRIM_TS_TRIM1__IMON_ATE_OFFSET__Shift(v)                (((v) << TRIM_TS_TRIM1__IMON_ATE_OFFSET__Pos) & TRIM_TS_TRIM1__IMON_ATE_OFFSET__Msk) /*!< Shift value 'v' into imon_ate_offset and mask 'v' to fit it into imon_ate_offset field */

/** TRIM_TS_TRIM1__IMON_ATE_OFFSET__SET() sets TS_TRIM1.IMON_ATE_OFFSET to given value.
 *
 * When writing to TS_TRIM1.IMON_ATE_OFFSET, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM1.IMON_ATE_OFFSET
 */
__TRIM_INLINE void TRIM_TS_TRIM1__IMON_ATE_OFFSET__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM1__GET();
    reg = (reg & ~TRIM_TS_TRIM1__IMON_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM1__IMON_ATE_OFFSET__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM1__SET(reg);
}

/** TRIM_TS_TRIM1__IMON_ATE_OFFSET__GET() gets TS_TRIM1.IMON_ATE_OFFSET's current value.
 *
 * When reading from TS_TRIM1.IMON_ATE_OFFSET, this is recommended to use.
 *
 * @return current value of TS_TRIM1.IMON_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__IMON_ATE_OFFSET__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM1__GET();
    reg = (reg & TRIM_TS_TRIM1__IMON_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM1__IMON_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM1__IMON_ATE_OFFSET__MODIFY() modifies TS_TRIM1.IMON_ATE_OFFSET.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM1
 * @param bf_value new value for TS_TRIM1.IMON_ATE_OFFSET
 * @return new value of TRIM.TS_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__IMON_ATE_OFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM1__IMON_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM1__IMON_ATE_OFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM1__IMON_ATE_OFFSET__EXTRACT() extracts TS_TRIM1.IMON_ATE_OFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM1
 * @return current value of TS_TRIM1.IMON_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__IMON_ATE_OFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM1__IMON_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM1__IMON_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TRIM.TS_TRIM1.IMON_ATE_GAIN ---------------------- */

/**
<pre>
  TRIM.TS_TRIM1.IMON_ATE_GAIN:

    Telemetry ADC, IMON input gain trim.

</pre> */

#define TRIM_TS_TRIM1__IMON_ATE_GAIN__Pos                       16                                                                     /*!< Right-most bit position of imon_ate_gain in TRIM.TS_TRIM1 */
#define TRIM_TS_TRIM1__IMON_ATE_GAIN__Msk                       (0x000000FFUL << TRIM_TS_TRIM1__IMON_ATE_GAIN__Pos)                    /*!< Mask for imon_ate_gain in TRIM.TS_TRIM1 */
#define TRIM_TS_TRIM1__IMON_ATE_GAIN__Shift(v)                  (((v) << TRIM_TS_TRIM1__IMON_ATE_GAIN__Pos) & TRIM_TS_TRIM1__IMON_ATE_GAIN__Msk) /*!< Shift value 'v' into imon_ate_gain and mask 'v' to fit it into imon_ate_gain field */

/** TRIM_TS_TRIM1__IMON_ATE_GAIN__SET() sets TS_TRIM1.IMON_ATE_GAIN to given value.
 *
 * When writing to TS_TRIM1.IMON_ATE_GAIN, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM1.IMON_ATE_GAIN
 */
__TRIM_INLINE void TRIM_TS_TRIM1__IMON_ATE_GAIN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM1__GET();
    reg = (reg & ~TRIM_TS_TRIM1__IMON_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM1__IMON_ATE_GAIN__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM1__SET(reg);
}

/** TRIM_TS_TRIM1__IMON_ATE_GAIN__GET() gets TS_TRIM1.IMON_ATE_GAIN's current value.
 *
 * When reading from TS_TRIM1.IMON_ATE_GAIN, this is recommended to use.
 *
 * @return current value of TS_TRIM1.IMON_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__IMON_ATE_GAIN__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM1__GET();
    reg = (reg & TRIM_TS_TRIM1__IMON_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM1__IMON_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM1__IMON_ATE_GAIN__MODIFY() modifies TS_TRIM1.IMON_ATE_GAIN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM1
 * @param bf_value new value for TS_TRIM1.IMON_ATE_GAIN
 * @return new value of TRIM.TS_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__IMON_ATE_GAIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM1__IMON_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM1__IMON_ATE_GAIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM1__IMON_ATE_GAIN__EXTRACT() extracts TS_TRIM1.IMON_ATE_GAIN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM1
 * @return current value of TS_TRIM1.IMON_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__IMON_ATE_GAIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM1__IMON_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM1__IMON_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/* -------------------- TRIM.TS_TRIM1.PRISEN_ATE_OFFSET -------------------- */

/**
<pre>
  TRIM.TS_TRIM1.PRISEN_ATE_OFFSET:

    Telemetry ADC, PRISEN input offset trim.

</pre> */

#define TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Pos                   8                                                                      /*!< Right-most bit position of prisen_ate_offset in TRIM.TS_TRIM1 */
#define TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Msk                   (0x000000FFUL << TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Pos)                /*!< Mask for prisen_ate_offset in TRIM.TS_TRIM1 */
#define TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Shift(v)              (((v) << TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Pos) & TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Msk) /*!< Shift value 'v' into prisen_ate_offset and mask 'v' to fit it into prisen_ate_offset field */

/** TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__SET() sets TS_TRIM1.PRISEN_ATE_OFFSET to given value.
 *
 * When writing to TS_TRIM1.PRISEN_ATE_OFFSET, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM1.PRISEN_ATE_OFFSET
 */
__TRIM_INLINE void TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM1__GET();
    reg = (reg & ~TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM1__SET(reg);
}

/** TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__GET() gets TS_TRIM1.PRISEN_ATE_OFFSET's current value.
 *
 * When reading from TS_TRIM1.PRISEN_ATE_OFFSET, this is recommended to use.
 *
 * @return current value of TS_TRIM1.PRISEN_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM1__GET();
    reg = (reg & TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__MODIFY() modifies TS_TRIM1.PRISEN_ATE_OFFSET.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM1
 * @param bf_value new value for TS_TRIM1.PRISEN_ATE_OFFSET
 * @return new value of TRIM.TS_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__EXTRACT() extracts TS_TRIM1.PRISEN_ATE_OFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM1
 * @return current value of TS_TRIM1.PRISEN_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM1__PRISEN_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/* --------------------- TRIM.TS_TRIM1.PRISEN_ATE_GAIN --------------------- */

/**
<pre>
  TRIM.TS_TRIM1.PRISEN_ATE_GAIN:

    Telemetry ADC, PRISEN input gain trim.

</pre> */

#define TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Pos                     0                                                                      /*!< Right-most bit position of prisen_ate_gain in TRIM.TS_TRIM1 */
#define TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Msk                     (0x000000FFUL << TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Pos)                  /*!< Mask for prisen_ate_gain in TRIM.TS_TRIM1 */
#define TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Shift(v)                (((v) << TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Pos) & TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Msk) /*!< Shift value 'v' into prisen_ate_gain and mask 'v' to fit it into prisen_ate_gain field */

/** TRIM_TS_TRIM1__PRISEN_ATE_GAIN__SET() sets TS_TRIM1.PRISEN_ATE_GAIN to given value.
 *
 * When writing to TS_TRIM1.PRISEN_ATE_GAIN, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM1.PRISEN_ATE_GAIN
 */
__TRIM_INLINE void TRIM_TS_TRIM1__PRISEN_ATE_GAIN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM1__GET();
    reg = (reg & ~TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM1__SET(reg);
}

/** TRIM_TS_TRIM1__PRISEN_ATE_GAIN__GET() gets TS_TRIM1.PRISEN_ATE_GAIN's current value.
 *
 * When reading from TS_TRIM1.PRISEN_ATE_GAIN, this is recommended to use.
 *
 * @return current value of TS_TRIM1.PRISEN_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__PRISEN_ATE_GAIN__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM1__GET();
    reg = (reg & TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM1__PRISEN_ATE_GAIN__MODIFY() modifies TS_TRIM1.PRISEN_ATE_GAIN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM1
 * @param bf_value new value for TS_TRIM1.PRISEN_ATE_GAIN
 * @return new value of TRIM.TS_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__PRISEN_ATE_GAIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM1__PRISEN_ATE_GAIN__EXTRACT() extracts TS_TRIM1.PRISEN_ATE_GAIN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM1
 * @return current value of TS_TRIM1.PRISEN_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM1__PRISEN_ATE_GAIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM1__PRISEN_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TS_TRIM2 member of TRIM_t                         */
/* -------------------------------------------------------------------------- */

/** __TRIM_TS_TRIM2__ADDRESS returns the address of member TS_TRIM2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TS_TRIM2
 */
__TRIM_INLINE uint32_t* __TRIM_TS_TRIM2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, TS_TRIM2)));
}

/** TRIM_TS_TRIM2__SET() sets TS_TRIM2 to given value.
 *
 * When writing to TS_TRIM2, this is mandatory to use.
 *
 * @param value new value for TS_TRIM2
 */
__TRIM_INLINE void TRIM_TS_TRIM2__SET(uint32_t value)
{
    HAL_SET32(__TRIM_TS_TRIM2__ADDRESS(), value);
}

/** TRIM_TS_TRIM2__GET() gets TS_TRIM2's current value.
 *
 * When reading from TS_TRIM2, this is mandatory to use.
 *
 * @return current value of TS_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__GET(void)
{
    return HAL_GET32(__TRIM_TS_TRIM2__ADDRESS());
}

/* --------------------- TRIM.TS_TRIM2.BTSEN_ATE_OFFSET --------------------- */

/**
<pre>
  TRIM.TS_TRIM2.BTSEN_ATE_OFFSET:

    Telemetry ADC, BTSEN input offset trim.

</pre> */

#define TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Pos                    24                                                                     /*!< Right-most bit position of btsen_ate_offset in TRIM.TS_TRIM2 */
#define TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Msk                    (0x000000FFUL << TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Pos)                 /*!< Mask for btsen_ate_offset in TRIM.TS_TRIM2 */
#define TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Shift(v)               (((v) << TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Pos) & TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Msk) /*!< Shift value 'v' into btsen_ate_offset and mask 'v' to fit it into btsen_ate_offset field */

/** TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__SET() sets TS_TRIM2.BTSEN_ATE_OFFSET to given value.
 *
 * When writing to TS_TRIM2.BTSEN_ATE_OFFSET, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM2.BTSEN_ATE_OFFSET
 */
__TRIM_INLINE void TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM2__GET();
    reg = (reg & ~TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM2__SET(reg);
}

/** TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__GET() gets TS_TRIM2.BTSEN_ATE_OFFSET's current value.
 *
 * When reading from TS_TRIM2.BTSEN_ATE_OFFSET, this is recommended to use.
 *
 * @return current value of TS_TRIM2.BTSEN_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM2__GET();
    reg = (reg & TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__MODIFY() modifies TS_TRIM2.BTSEN_ATE_OFFSET.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM2
 * @param bf_value new value for TS_TRIM2.BTSEN_ATE_OFFSET
 * @return new value of TRIM.TS_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__EXTRACT() extracts TS_TRIM2.BTSEN_ATE_OFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM2
 * @return current value of TS_TRIM2.BTSEN_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM2__BTSEN_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TRIM.TS_TRIM2.BTSEN_ATE_GAIN ---------------------- */

/**
<pre>
  TRIM.TS_TRIM2.BTSEN_ATE_GAIN:

    Telemetry ADC, BTSEN input gain trim.

</pre> */

#define TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Pos                      16                                                                     /*!< Right-most bit position of btsen_ate_gain in TRIM.TS_TRIM2 */
#define TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Msk                      (0x000000FFUL << TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Pos)                   /*!< Mask for btsen_ate_gain in TRIM.TS_TRIM2 */
#define TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Shift(v)                 (((v) << TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Pos) & TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Msk) /*!< Shift value 'v' into btsen_ate_gain and mask 'v' to fit it into btsen_ate_gain field */

/** TRIM_TS_TRIM2__BTSEN_ATE_GAIN__SET() sets TS_TRIM2.BTSEN_ATE_GAIN to given value.
 *
 * When writing to TS_TRIM2.BTSEN_ATE_GAIN, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM2.BTSEN_ATE_GAIN
 */
__TRIM_INLINE void TRIM_TS_TRIM2__BTSEN_ATE_GAIN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM2__GET();
    reg = (reg & ~TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM2__SET(reg);
}

/** TRIM_TS_TRIM2__BTSEN_ATE_GAIN__GET() gets TS_TRIM2.BTSEN_ATE_GAIN's current value.
 *
 * When reading from TS_TRIM2.BTSEN_ATE_GAIN, this is recommended to use.
 *
 * @return current value of TS_TRIM2.BTSEN_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__BTSEN_ATE_GAIN__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM2__GET();
    reg = (reg & TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM2__BTSEN_ATE_GAIN__MODIFY() modifies TS_TRIM2.BTSEN_ATE_GAIN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM2
 * @param bf_value new value for TS_TRIM2.BTSEN_ATE_GAIN
 * @return new value of TRIM.TS_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__BTSEN_ATE_GAIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM2__BTSEN_ATE_GAIN__EXTRACT() extracts TS_TRIM2.BTSEN_ATE_GAIN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM2
 * @return current value of TS_TRIM2.BTSEN_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__BTSEN_ATE_GAIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM2__BTSEN_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/* --------------------- TRIM.TS_TRIM2.ATSEN_ATE_OFFSET --------------------- */

/**
<pre>
  TRIM.TS_TRIM2.ATSEN_ATE_OFFSET:

    Telemetry ADC, ATSEN input offset trim.

</pre> */

#define TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Pos                    8                                                                      /*!< Right-most bit position of atsen_ate_offset in TRIM.TS_TRIM2 */
#define TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Msk                    (0x000000FFUL << TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Pos)                 /*!< Mask for atsen_ate_offset in TRIM.TS_TRIM2 */
#define TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Shift(v)               (((v) << TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Pos) & TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Msk) /*!< Shift value 'v' into atsen_ate_offset and mask 'v' to fit it into atsen_ate_offset field */

/** TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__SET() sets TS_TRIM2.ATSEN_ATE_OFFSET to given value.
 *
 * When writing to TS_TRIM2.ATSEN_ATE_OFFSET, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM2.ATSEN_ATE_OFFSET
 */
__TRIM_INLINE void TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM2__GET();
    reg = (reg & ~TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM2__SET(reg);
}

/** TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__GET() gets TS_TRIM2.ATSEN_ATE_OFFSET's current value.
 *
 * When reading from TS_TRIM2.ATSEN_ATE_OFFSET, this is recommended to use.
 *
 * @return current value of TS_TRIM2.ATSEN_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM2__GET();
    reg = (reg & TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__MODIFY() modifies TS_TRIM2.ATSEN_ATE_OFFSET.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM2
 * @param bf_value new value for TS_TRIM2.ATSEN_ATE_OFFSET
 * @return new value of TRIM.TS_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__EXTRACT() extracts TS_TRIM2.ATSEN_ATE_OFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM2
 * @return current value of TS_TRIM2.ATSEN_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM2__ATSEN_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TRIM.TS_TRIM2.ATSEN_ATE_GAIN ---------------------- */

/**
<pre>
  TRIM.TS_TRIM2.ATSEN_ATE_GAIN:

    Telemetry ADC, ATSEN input gain trim.

</pre> */

#define TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Pos                      0                                                                      /*!< Right-most bit position of atsen_ate_gain in TRIM.TS_TRIM2 */
#define TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Msk                      (0x000000FFUL << TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Pos)                   /*!< Mask for atsen_ate_gain in TRIM.TS_TRIM2 */
#define TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Shift(v)                 (((v) << TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Pos) & TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Msk) /*!< Shift value 'v' into atsen_ate_gain and mask 'v' to fit it into atsen_ate_gain field */

/** TRIM_TS_TRIM2__ATSEN_ATE_GAIN__SET() sets TS_TRIM2.ATSEN_ATE_GAIN to given value.
 *
 * When writing to TS_TRIM2.ATSEN_ATE_GAIN, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM2.ATSEN_ATE_GAIN
 */
__TRIM_INLINE void TRIM_TS_TRIM2__ATSEN_ATE_GAIN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM2__GET();
    reg = (reg & ~TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM2__SET(reg);
}

/** TRIM_TS_TRIM2__ATSEN_ATE_GAIN__GET() gets TS_TRIM2.ATSEN_ATE_GAIN's current value.
 *
 * When reading from TS_TRIM2.ATSEN_ATE_GAIN, this is recommended to use.
 *
 * @return current value of TS_TRIM2.ATSEN_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__ATSEN_ATE_GAIN__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM2__GET();
    reg = (reg & TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM2__ATSEN_ATE_GAIN__MODIFY() modifies TS_TRIM2.ATSEN_ATE_GAIN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM2
 * @param bf_value new value for TS_TRIM2.ATSEN_ATE_GAIN
 * @return new value of TRIM.TS_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__ATSEN_ATE_GAIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM2__ATSEN_ATE_GAIN__EXTRACT() extracts TS_TRIM2.ATSEN_ATE_GAIN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM2
 * @return current value of TS_TRIM2.ATSEN_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM2__ATSEN_ATE_GAIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM2__ATSEN_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TS_TRIM3 member of TRIM_t                         */
/* -------------------------------------------------------------------------- */

/** __TRIM_TS_TRIM3__ADDRESS returns the address of member TS_TRIM3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TS_TRIM3
 */
__TRIM_INLINE uint32_t* __TRIM_TS_TRIM3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, TS_TRIM3)));
}

/** TRIM_TS_TRIM3__SET() sets TS_TRIM3 to given value.
 *
 * When writing to TS_TRIM3, this is mandatory to use.
 *
 * @param value new value for TS_TRIM3
 */
__TRIM_INLINE void TRIM_TS_TRIM3__SET(uint32_t value)
{
    HAL_SET32(__TRIM_TS_TRIM3__ADDRESS(), value);
}

/** TRIM_TS_TRIM3__GET() gets TS_TRIM3's current value.
 *
 * When reading from TS_TRIM3, this is mandatory to use.
 *
 * @return current value of TS_TRIM3
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__GET(void)
{
    return HAL_GET32(__TRIM_TS_TRIM3__ADDRESS());
}

/* ---------------------- TRIM.TS_TRIM3.XV_ATE_OFFSET ---------------------- */

/**
<pre>
  TRIM.TS_TRIM3.XV_ATE_OFFSET:

    Telemetry ADC, XADDR input offset trim.

</pre> */

#define TRIM_TS_TRIM3__XV_ATE_OFFSET__Pos                       24                                                                     /*!< Right-most bit position of xv_ate_offset in TRIM.TS_TRIM3 */
#define TRIM_TS_TRIM3__XV_ATE_OFFSET__Msk                       (0x000000FFUL << TRIM_TS_TRIM3__XV_ATE_OFFSET__Pos)                    /*!< Mask for xv_ate_offset in TRIM.TS_TRIM3 */
#define TRIM_TS_TRIM3__XV_ATE_OFFSET__Shift(v)                  (((v) << TRIM_TS_TRIM3__XV_ATE_OFFSET__Pos) & TRIM_TS_TRIM3__XV_ATE_OFFSET__Msk) /*!< Shift value 'v' into xv_ate_offset and mask 'v' to fit it into xv_ate_offset field */

/** TRIM_TS_TRIM3__XV_ATE_OFFSET__SET() sets TS_TRIM3.XV_ATE_OFFSET to given value.
 *
 * When writing to TS_TRIM3.XV_ATE_OFFSET, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM3.XV_ATE_OFFSET
 */
__TRIM_INLINE void TRIM_TS_TRIM3__XV_ATE_OFFSET__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM3__GET();
    reg = (reg & ~TRIM_TS_TRIM3__XV_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM3__XV_ATE_OFFSET__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM3__SET(reg);
}

/** TRIM_TS_TRIM3__XV_ATE_OFFSET__GET() gets TS_TRIM3.XV_ATE_OFFSET's current value.
 *
 * When reading from TS_TRIM3.XV_ATE_OFFSET, this is recommended to use.
 *
 * @return current value of TS_TRIM3.XV_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__XV_ATE_OFFSET__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM3__GET();
    reg = (reg & TRIM_TS_TRIM3__XV_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM3__XV_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM3__XV_ATE_OFFSET__MODIFY() modifies TS_TRIM3.XV_ATE_OFFSET.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM3
 * @param bf_value new value for TS_TRIM3.XV_ATE_OFFSET
 * @return new value of TRIM.TS_TRIM3
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__XV_ATE_OFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM3__XV_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM3__XV_ATE_OFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM3__XV_ATE_OFFSET__EXTRACT() extracts TS_TRIM3.XV_ATE_OFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM3
 * @return current value of TS_TRIM3.XV_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__XV_ATE_OFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM3__XV_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM3__XV_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/* ----------------------- TRIM.TS_TRIM3.XV_ATE_GAIN ----------------------- */

/**
<pre>
  TRIM.TS_TRIM3.XV_ATE_GAIN:

    Telemetry ADC, XADDR input gain trim.

</pre> */

#define TRIM_TS_TRIM3__XV_ATE_GAIN__Pos                         16                                                                     /*!< Right-most bit position of xv_ate_gain in TRIM.TS_TRIM3 */
#define TRIM_TS_TRIM3__XV_ATE_GAIN__Msk                         (0x000000FFUL << TRIM_TS_TRIM3__XV_ATE_GAIN__Pos)                      /*!< Mask for xv_ate_gain in TRIM.TS_TRIM3 */
#define TRIM_TS_TRIM3__XV_ATE_GAIN__Shift(v)                    (((v) << TRIM_TS_TRIM3__XV_ATE_GAIN__Pos) & TRIM_TS_TRIM3__XV_ATE_GAIN__Msk) /*!< Shift value 'v' into xv_ate_gain and mask 'v' to fit it into xv_ate_gain field */

/** TRIM_TS_TRIM3__XV_ATE_GAIN__SET() sets TS_TRIM3.XV_ATE_GAIN to given value.
 *
 * When writing to TS_TRIM3.XV_ATE_GAIN, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM3.XV_ATE_GAIN
 */
__TRIM_INLINE void TRIM_TS_TRIM3__XV_ATE_GAIN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM3__GET();
    reg = (reg & ~TRIM_TS_TRIM3__XV_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM3__XV_ATE_GAIN__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM3__SET(reg);
}

/** TRIM_TS_TRIM3__XV_ATE_GAIN__GET() gets TS_TRIM3.XV_ATE_GAIN's current value.
 *
 * When reading from TS_TRIM3.XV_ATE_GAIN, this is recommended to use.
 *
 * @return current value of TS_TRIM3.XV_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__XV_ATE_GAIN__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM3__GET();
    reg = (reg & TRIM_TS_TRIM3__XV_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM3__XV_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM3__XV_ATE_GAIN__MODIFY() modifies TS_TRIM3.XV_ATE_GAIN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM3
 * @param bf_value new value for TS_TRIM3.XV_ATE_GAIN
 * @return new value of TRIM.TS_TRIM3
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__XV_ATE_GAIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM3__XV_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM3__XV_ATE_GAIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM3__XV_ATE_GAIN__EXTRACT() extracts TS_TRIM3.XV_ATE_GAIN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM3
 * @return current value of TS_TRIM3.XV_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__XV_ATE_GAIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM3__XV_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM3__XV_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/* --------------------- TRIM.TS_TRIM3.ITSEN_ATE_OFFSET --------------------- */

/**
<pre>
  TRIM.TS_TRIM3.ITSEN_ATE_OFFSET:

    Telemetry ADC, ITSEN input offset trim.

</pre> */

#define TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Pos                    8                                                                      /*!< Right-most bit position of itsen_ate_offset in TRIM.TS_TRIM3 */
#define TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Msk                    (0x000000FFUL << TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Pos)                 /*!< Mask for itsen_ate_offset in TRIM.TS_TRIM3 */
#define TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Shift(v)               (((v) << TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Pos) & TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Msk) /*!< Shift value 'v' into itsen_ate_offset and mask 'v' to fit it into itsen_ate_offset field */

/** TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__SET() sets TS_TRIM3.ITSEN_ATE_OFFSET to given value.
 *
 * When writing to TS_TRIM3.ITSEN_ATE_OFFSET, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM3.ITSEN_ATE_OFFSET
 */
__TRIM_INLINE void TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM3__GET();
    reg = (reg & ~TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM3__SET(reg);
}

/** TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__GET() gets TS_TRIM3.ITSEN_ATE_OFFSET's current value.
 *
 * When reading from TS_TRIM3.ITSEN_ATE_OFFSET, this is recommended to use.
 *
 * @return current value of TS_TRIM3.ITSEN_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM3__GET();
    reg = (reg & TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__MODIFY() modifies TS_TRIM3.ITSEN_ATE_OFFSET.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM3
 * @param bf_value new value for TS_TRIM3.ITSEN_ATE_OFFSET
 * @return new value of TRIM.TS_TRIM3
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Msk);
    reg = (reg | (TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__EXTRACT() extracts TS_TRIM3.ITSEN_ATE_OFFSET.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM3
 * @return current value of TS_TRIM3.ITSEN_ATE_OFFSET
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Msk);
    reg = (reg >> TRIM_TS_TRIM3__ITSEN_ATE_OFFSET__Pos);
    return (uint32_t)reg;
}

/* ---------------------- TRIM.TS_TRIM3.ITSEN_ATE_GAIN ---------------------- */

/**
<pre>
  TRIM.TS_TRIM3.ITSEN_ATE_GAIN:

    Telemetry ADC, ITSEN input gain trim.

</pre> */

#define TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Pos                      0                                                                      /*!< Right-most bit position of itsen_ate_gain in TRIM.TS_TRIM3 */
#define TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Msk                      (0x000000FFUL << TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Pos)                   /*!< Mask for itsen_ate_gain in TRIM.TS_TRIM3 */
#define TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Shift(v)                 (((v) << TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Pos) & TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Msk) /*!< Shift value 'v' into itsen_ate_gain and mask 'v' to fit it into itsen_ate_gain field */

/** TRIM_TS_TRIM3__ITSEN_ATE_GAIN__SET() sets TS_TRIM3.ITSEN_ATE_GAIN to given value.
 *
 * When writing to TS_TRIM3.ITSEN_ATE_GAIN, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM3.ITSEN_ATE_GAIN
 */
__TRIM_INLINE void TRIM_TS_TRIM3__ITSEN_ATE_GAIN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM3__GET();
    reg = (reg & ~TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM3__SET(reg);
}

/** TRIM_TS_TRIM3__ITSEN_ATE_GAIN__GET() gets TS_TRIM3.ITSEN_ATE_GAIN's current value.
 *
 * When reading from TS_TRIM3.ITSEN_ATE_GAIN, this is recommended to use.
 *
 * @return current value of TS_TRIM3.ITSEN_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__ITSEN_ATE_GAIN__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM3__GET();
    reg = (reg & TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM3__ITSEN_ATE_GAIN__MODIFY() modifies TS_TRIM3.ITSEN_ATE_GAIN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM3
 * @param bf_value new value for TS_TRIM3.ITSEN_ATE_GAIN
 * @return new value of TRIM.TS_TRIM3
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__ITSEN_ATE_GAIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Msk);
    reg = (reg | (TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM3__ITSEN_ATE_GAIN__EXTRACT() extracts TS_TRIM3.ITSEN_ATE_GAIN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM3
 * @return current value of TS_TRIM3.ITSEN_ATE_GAIN
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM3__ITSEN_ATE_GAIN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Msk);
    reg = (reg >> TRIM_TS_TRIM3__ITSEN_ATE_GAIN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         TS_TRIM4 member of TRIM_t                         */
/* -------------------------------------------------------------------------- */

/** __TRIM_TS_TRIM4__ADDRESS returns the address of member TS_TRIM4.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TS_TRIM4
 */
__TRIM_INLINE uint32_t* __TRIM_TS_TRIM4__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, TS_TRIM4)));
}

/** TRIM_TS_TRIM4__SET() sets TS_TRIM4 to given value.
 *
 * When writing to TS_TRIM4, this is mandatory to use.
 *
 * @param value new value for TS_TRIM4
 */
__TRIM_INLINE void TRIM_TS_TRIM4__SET(uint32_t value)
{
    HAL_SET32(__TRIM_TS_TRIM4__ADDRESS(), value);
}

/** TRIM_TS_TRIM4__GET() gets TS_TRIM4's current value.
 *
 * When reading from TS_TRIM4, this is mandatory to use.
 *
 * @return current value of TS_TRIM4
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM4__GET(void)
{
    return HAL_GET32(__TRIM_TS_TRIM4__ADDRESS());
}

/* -------------------- TRIM.TS_TRIM4.TS_TSIDAC_CUR_TRIM -------------------- */

/**
<pre>
  TRIM.TS_TRIM4.TS_TSIDAC_CUR_TRIM:

    Trim code for the 10uA Telemetry Sense IDAC current reference.  Nominal current is 10uA for trim code = 31.  In the nominal corner the range is 8.03 to 12.46uA over codes 0 to 63 but the steps are not linear.  LSB size shown is an average over the range in the nominal corner.

</pre> */

#define TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Pos                  0                                                                      /*!< Right-most bit position of ts_tsidac_cur_trim in TRIM.TS_TRIM4 */
#define TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Msk                  (0x0000003FUL << TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Pos)               /*!< Mask for ts_tsidac_cur_trim in TRIM.TS_TRIM4 */
#define TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Shift(v)             (((v) << TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Pos) & TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Msk) /*!< Shift value 'v' into ts_tsidac_cur_trim and mask 'v' to fit it into ts_tsidac_cur_trim field */

/** TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__SET() sets TS_TRIM4.TS_TSIDAC_CUR_TRIM to given value.
 *
 * When writing to TS_TRIM4.TS_TSIDAC_CUR_TRIM, this is recommended to use.
 *
 * @param bf_value new value for TS_TRIM4.TS_TSIDAC_CUR_TRIM
 */
__TRIM_INLINE void TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_TS_TRIM4__GET();
    reg = (reg & ~TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Msk);
    reg = (reg | (TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Shift((uint32_t)bf_value)));
    TRIM_TS_TRIM4__SET(reg);
}

/** TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__GET() gets TS_TRIM4.TS_TSIDAC_CUR_TRIM's current value.
 *
 * When reading from TS_TRIM4.TS_TSIDAC_CUR_TRIM, this is recommended to use.
 *
 * @return current value of TS_TRIM4.TS_TSIDAC_CUR_TRIM
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__GET(void)
{
    uint32_t reg = TRIM_TS_TRIM4__GET();
    reg = (reg & TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Msk);
    reg = (reg >> TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__MODIFY() modifies TS_TRIM4.TS_TSIDAC_CUR_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.TS_TRIM4.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.TS_TRIM4
 * @param bf_value new value for TS_TRIM4.TS_TSIDAC_CUR_TRIM
 * @return new value of TRIM.TS_TRIM4
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Msk);
    reg = (reg | (TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__EXTRACT() extracts TS_TRIM4.TS_TSIDAC_CUR_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.TS_TRIM4.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.TS_TRIM4
 * @return current value of TS_TRIM4.TS_TSIDAC_CUR_TRIM
 */
__TRIM_INLINE uint32_t TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Msk);
    reg = (reg >> TRIM_TS_TRIM4__TS_TSIDAC_CUR_TRIM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         IC_SERIAL member of TRIM_t                         */
/* -------------------------------------------------------------------------- */

/** __TRIM_IC_SERIAL__ADDRESS returns the address of member IC_SERIAL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IC_SERIAL
 */
__TRIM_INLINE uint32_t* __TRIM_IC_SERIAL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IC_SERIAL)));
}

/** TRIM_IC_SERIAL__SET() sets IC_SERIAL to given value.
 *
 * When writing to IC_SERIAL, this is mandatory to use.
 *
 * @param value new value for IC_SERIAL
 */
__TRIM_INLINE void TRIM_IC_SERIAL__SET(uint32_t value)
{
    HAL_SET32(__TRIM_IC_SERIAL__ADDRESS(), value);
}

/** TRIM_IC_SERIAL__GET() gets IC_SERIAL's current value.
 *
 * When reading from IC_SERIAL, this is mandatory to use.
 *
 * @return current value of IC_SERIAL
 */
__TRIM_INLINE uint32_t TRIM_IC_SERIAL__GET(void)
{
    return HAL_GET32(__TRIM_IC_SERIAL__ADDRESS());
}

/* ------------------------ TRIM.IC_SERIAL.TIMESTAMP ------------------------ */

/**
<pre>
  TRIM.IC_SERIAL.TIMESTAMP:

    ATE test timestamp

</pre> */

#define TRIM_IC_SERIAL__TIMESTAMP__Pos                          16                                                                     /*!< Right-most bit position of timestamp in TRIM.IC_SERIAL */
#define TRIM_IC_SERIAL__TIMESTAMP__Msk                          (0x0000FFFFUL << TRIM_IC_SERIAL__TIMESTAMP__Pos)                       /*!< Mask for timestamp in TRIM.IC_SERIAL */
#define TRIM_IC_SERIAL__TIMESTAMP__Shift(v)                     (((v) << TRIM_IC_SERIAL__TIMESTAMP__Pos) & TRIM_IC_SERIAL__TIMESTAMP__Msk) /*!< Shift value 'v' into timestamp and mask 'v' to fit it into timestamp field */

/** TRIM_IC_SERIAL__TIMESTAMP__SET() sets IC_SERIAL.TIMESTAMP to given value.
 *
 * When writing to IC_SERIAL.TIMESTAMP, this is recommended to use.
 *
 * @param bf_value new value for IC_SERIAL.TIMESTAMP
 */
__TRIM_INLINE void TRIM_IC_SERIAL__TIMESTAMP__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IC_SERIAL__GET();
    reg = (reg & ~TRIM_IC_SERIAL__TIMESTAMP__Msk);
    reg = (reg | (TRIM_IC_SERIAL__TIMESTAMP__Shift((uint32_t)bf_value)));
    TRIM_IC_SERIAL__SET(reg);
}

/** TRIM_IC_SERIAL__TIMESTAMP__GET() gets IC_SERIAL.TIMESTAMP's current value.
 *
 * When reading from IC_SERIAL.TIMESTAMP, this is recommended to use.
 *
 * @return current value of IC_SERIAL.TIMESTAMP
 */
__TRIM_INLINE uint32_t TRIM_IC_SERIAL__TIMESTAMP__GET(void)
{
    uint32_t reg = TRIM_IC_SERIAL__GET();
    reg = (reg & TRIM_IC_SERIAL__TIMESTAMP__Msk);
    reg = (reg >> TRIM_IC_SERIAL__TIMESTAMP__Pos);
    return (uint32_t)reg;
}

/** TRIM_IC_SERIAL__TIMESTAMP__MODIFY() modifies IC_SERIAL.TIMESTAMP.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IC_SERIAL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IC_SERIAL
 * @param bf_value new value for IC_SERIAL.TIMESTAMP
 * @return new value of TRIM.IC_SERIAL
 */
__TRIM_INLINE uint32_t TRIM_IC_SERIAL__TIMESTAMP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IC_SERIAL__TIMESTAMP__Msk);
    reg = (reg | (TRIM_IC_SERIAL__TIMESTAMP__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IC_SERIAL__TIMESTAMP__EXTRACT() extracts IC_SERIAL.TIMESTAMP.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IC_SERIAL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IC_SERIAL
 * @return current value of IC_SERIAL.TIMESTAMP
 */
__TRIM_INLINE uint32_t TRIM_IC_SERIAL__TIMESTAMP__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IC_SERIAL__TIMESTAMP__Msk);
    reg = (reg >> TRIM_IC_SERIAL__TIMESTAMP__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TRIM.IC_SERIAL.IC_SERIAL ------------------------ */

/**
<pre>
  TRIM.IC_SERIAL.IC_SERIAL:

    IC serial number within test lot, programmed at ATE

</pre> */

#define TRIM_IC_SERIAL__IC_SERIAL__Pos                          0                                                                      /*!< Right-most bit position of ic_serial in TRIM.IC_SERIAL */
#define TRIM_IC_SERIAL__IC_SERIAL__Msk                          (0x0000FFFFUL << TRIM_IC_SERIAL__IC_SERIAL__Pos)                       /*!< Mask for ic_serial in TRIM.IC_SERIAL */
#define TRIM_IC_SERIAL__IC_SERIAL__Shift(v)                     (((v) << TRIM_IC_SERIAL__IC_SERIAL__Pos) & TRIM_IC_SERIAL__IC_SERIAL__Msk) /*!< Shift value 'v' into ic_serial and mask 'v' to fit it into ic_serial field */

/** TRIM_IC_SERIAL__IC_SERIAL__SET() sets IC_SERIAL.IC_SERIAL to given value.
 *
 * When writing to IC_SERIAL.IC_SERIAL, this is recommended to use.
 *
 * @param bf_value new value for IC_SERIAL.IC_SERIAL
 */
__TRIM_INLINE void TRIM_IC_SERIAL__IC_SERIAL__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IC_SERIAL__GET();
    reg = (reg & ~TRIM_IC_SERIAL__IC_SERIAL__Msk);
    reg = (reg | (TRIM_IC_SERIAL__IC_SERIAL__Shift((uint32_t)bf_value)));
    TRIM_IC_SERIAL__SET(reg);
}

/** TRIM_IC_SERIAL__IC_SERIAL__GET() gets IC_SERIAL.IC_SERIAL's current value.
 *
 * When reading from IC_SERIAL.IC_SERIAL, this is recommended to use.
 *
 * @return current value of IC_SERIAL.IC_SERIAL
 */
__TRIM_INLINE uint32_t TRIM_IC_SERIAL__IC_SERIAL__GET(void)
{
    uint32_t reg = TRIM_IC_SERIAL__GET();
    reg = (reg & TRIM_IC_SERIAL__IC_SERIAL__Msk);
    reg = (reg >> TRIM_IC_SERIAL__IC_SERIAL__Pos);
    return (uint32_t)reg;
}

/** TRIM_IC_SERIAL__IC_SERIAL__MODIFY() modifies IC_SERIAL.IC_SERIAL.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IC_SERIAL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IC_SERIAL
 * @param bf_value new value for IC_SERIAL.IC_SERIAL
 * @return new value of TRIM.IC_SERIAL
 */
__TRIM_INLINE uint32_t TRIM_IC_SERIAL__IC_SERIAL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IC_SERIAL__IC_SERIAL__Msk);
    reg = (reg | (TRIM_IC_SERIAL__IC_SERIAL__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IC_SERIAL__IC_SERIAL__EXTRACT() extracts IC_SERIAL.IC_SERIAL.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IC_SERIAL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IC_SERIAL
 * @return current value of IC_SERIAL.IC_SERIAL
 */
__TRIM_INLINE uint32_t TRIM_IC_SERIAL__IC_SERIAL__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IC_SERIAL__IC_SERIAL__Msk);
    reg = (reg >> TRIM_IC_SERIAL__IC_SERIAL__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          CFG_NUM member of TRIM_t                          */
/* -------------------------------------------------------------------------- */

/** __TRIM_CFG_NUM__ADDRESS returns the address of member CFG_NUM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CFG_NUM
 */
__TRIM_INLINE uint32_t* __TRIM_CFG_NUM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, CFG_NUM)));
}

/** TRIM_CFG_NUM__SET() sets CFG_NUM to given value.
 *
 * When writing to CFG_NUM, this is mandatory to use.
 *
 * @param value new value for CFG_NUM
 */
__TRIM_INLINE void TRIM_CFG_NUM__SET(uint32_t value)
{
    HAL_SET32(__TRIM_CFG_NUM__ADDRESS(), value);
}

/** TRIM_CFG_NUM__GET() gets CFG_NUM's current value.
 *
 * When reading from CFG_NUM, this is mandatory to use.
 *
 * @return current value of CFG_NUM
 */
__TRIM_INLINE uint32_t TRIM_CFG_NUM__GET(void)
{
    return HAL_GET32(__TRIM_CFG_NUM__ADDRESS());
}

/* -------------------------- TRIM.CFG_NUM.SW_REV -------------------------- */

/**
<pre>
  TRIM.CFG_NUM.SW_REV:

    ATE software revision

</pre> */

#define TRIM_CFG_NUM__SW_REV__Pos                               16                                                                     /*!< Right-most bit position of sw_rev in TRIM.CFG_NUM */
#define TRIM_CFG_NUM__SW_REV__Msk                               (0x0000FFFFUL << TRIM_CFG_NUM__SW_REV__Pos)                            /*!< Mask for sw_rev in TRIM.CFG_NUM */
#define TRIM_CFG_NUM__SW_REV__Shift(v)                          (((v) << TRIM_CFG_NUM__SW_REV__Pos) & TRIM_CFG_NUM__SW_REV__Msk)       /*!< Shift value 'v' into sw_rev and mask 'v' to fit it into sw_rev field */

/** TRIM_CFG_NUM__SW_REV__SET() sets CFG_NUM.SW_REV to given value.
 *
 * When writing to CFG_NUM.SW_REV, this is recommended to use.
 *
 * @param bf_value new value for CFG_NUM.SW_REV
 */
__TRIM_INLINE void TRIM_CFG_NUM__SW_REV__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_CFG_NUM__GET();
    reg = (reg & ~TRIM_CFG_NUM__SW_REV__Msk);
    reg = (reg | (TRIM_CFG_NUM__SW_REV__Shift((uint32_t)bf_value)));
    TRIM_CFG_NUM__SET(reg);
}

/** TRIM_CFG_NUM__SW_REV__GET() gets CFG_NUM.SW_REV's current value.
 *
 * When reading from CFG_NUM.SW_REV, this is recommended to use.
 *
 * @return current value of CFG_NUM.SW_REV
 */
__TRIM_INLINE uint32_t TRIM_CFG_NUM__SW_REV__GET(void)
{
    uint32_t reg = TRIM_CFG_NUM__GET();
    reg = (reg & TRIM_CFG_NUM__SW_REV__Msk);
    reg = (reg >> TRIM_CFG_NUM__SW_REV__Pos);
    return (uint32_t)reg;
}

/** TRIM_CFG_NUM__SW_REV__MODIFY() modifies CFG_NUM.SW_REV.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.CFG_NUM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.CFG_NUM
 * @param bf_value new value for CFG_NUM.SW_REV
 * @return new value of TRIM.CFG_NUM
 */
__TRIM_INLINE uint32_t TRIM_CFG_NUM__SW_REV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_CFG_NUM__SW_REV__Msk);
    reg = (reg | (TRIM_CFG_NUM__SW_REV__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_CFG_NUM__SW_REV__EXTRACT() extracts CFG_NUM.SW_REV.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.CFG_NUM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.CFG_NUM
 * @return current value of CFG_NUM.SW_REV
 */
__TRIM_INLINE uint32_t TRIM_CFG_NUM__SW_REV__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_CFG_NUM__SW_REV__Msk);
    reg = (reg >> TRIM_CFG_NUM__SW_REV__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TRIM.CFG_NUM.CONFIG_NUM ------------------------ */

/**
<pre>
  TRIM.CFG_NUM.CONFIG_NUM:

    ATE programmed configuration number

</pre> */

#define TRIM_CFG_NUM__CONFIG_NUM__Pos                           0                                                                      /*!< Right-most bit position of config_num in TRIM.CFG_NUM */
#define TRIM_CFG_NUM__CONFIG_NUM__Msk                           (0x0000FFFFUL << TRIM_CFG_NUM__CONFIG_NUM__Pos)                        /*!< Mask for config_num in TRIM.CFG_NUM */
#define TRIM_CFG_NUM__CONFIG_NUM__Shift(v)                      (((v) << TRIM_CFG_NUM__CONFIG_NUM__Pos) & TRIM_CFG_NUM__CONFIG_NUM__Msk) /*!< Shift value 'v' into config_num and mask 'v' to fit it into config_num field */

/** TRIM_CFG_NUM__CONFIG_NUM__SET() sets CFG_NUM.CONFIG_NUM to given value.
 *
 * When writing to CFG_NUM.CONFIG_NUM, this is recommended to use.
 *
 * @param bf_value new value for CFG_NUM.CONFIG_NUM
 */
__TRIM_INLINE void TRIM_CFG_NUM__CONFIG_NUM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_CFG_NUM__GET();
    reg = (reg & ~TRIM_CFG_NUM__CONFIG_NUM__Msk);
    reg = (reg | (TRIM_CFG_NUM__CONFIG_NUM__Shift((uint32_t)bf_value)));
    TRIM_CFG_NUM__SET(reg);
}

/** TRIM_CFG_NUM__CONFIG_NUM__GET() gets CFG_NUM.CONFIG_NUM's current value.
 *
 * When reading from CFG_NUM.CONFIG_NUM, this is recommended to use.
 *
 * @return current value of CFG_NUM.CONFIG_NUM
 */
__TRIM_INLINE uint32_t TRIM_CFG_NUM__CONFIG_NUM__GET(void)
{
    uint32_t reg = TRIM_CFG_NUM__GET();
    reg = (reg & TRIM_CFG_NUM__CONFIG_NUM__Msk);
    reg = (reg >> TRIM_CFG_NUM__CONFIG_NUM__Pos);
    return (uint32_t)reg;
}

/** TRIM_CFG_NUM__CONFIG_NUM__MODIFY() modifies CFG_NUM.CONFIG_NUM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.CFG_NUM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.CFG_NUM
 * @param bf_value new value for CFG_NUM.CONFIG_NUM
 * @return new value of TRIM.CFG_NUM
 */
__TRIM_INLINE uint32_t TRIM_CFG_NUM__CONFIG_NUM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_CFG_NUM__CONFIG_NUM__Msk);
    reg = (reg | (TRIM_CFG_NUM__CONFIG_NUM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_CFG_NUM__CONFIG_NUM__EXTRACT() extracts CFG_NUM.CONFIG_NUM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.CFG_NUM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.CFG_NUM
 * @return current value of CFG_NUM.CONFIG_NUM
 */
__TRIM_INLINE uint32_t TRIM_CFG_NUM__CONFIG_NUM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_CFG_NUM__CONFIG_NUM__Msk);
    reg = (reg >> TRIM_CFG_NUM__CONFIG_NUM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       IS1_OFF_TRIM1 member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_IS1_OFF_TRIM1__ADDRESS returns the address of member IS1_OFF_TRIM1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IS1_OFF_TRIM1
 */
__TRIM_INLINE uint32_t* __TRIM_IS1_OFF_TRIM1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IS1_OFF_TRIM1)));
}

/** TRIM_IS1_OFF_TRIM1__SET() sets IS1_OFF_TRIM1 to given value.
 *
 * When writing to IS1_OFF_TRIM1, this is mandatory to use.
 *
 * @param value new value for IS1_OFF_TRIM1
 */
__TRIM_INLINE void TRIM_IS1_OFF_TRIM1__SET(uint32_t value)
{
    HAL_SET32(__TRIM_IS1_OFF_TRIM1__ADDRESS(), value);
}

/** TRIM_IS1_OFF_TRIM1__GET() gets IS1_OFF_TRIM1's current value.
 *
 * When reading from IS1_OFF_TRIM1, this is mandatory to use.
 *
 * @return current value of IS1_OFF_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM1__GET(void)
{
    return HAL_GET32(__TRIM_IS1_OFF_TRIM1__ADDRESS());
}

/* ------------------- TRIM.IS1_OFF_TRIM1.IS1_ATE_OFFSET1 ------------------- */

/**
<pre>
  TRIM.IS1_OFF_TRIM1.IS1_ATE_OFFSET1:

    IS1 (ISEN) ADC offset trim when isen1_gain_mode=1.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Pos                13                                                                     /*!< Right-most bit position of is1_ate_offset1 in TRIM.IS1_OFF_TRIM1 */
#define TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Msk                (0x00001FFFUL << TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Pos)             /*!< Mask for is1_ate_offset1 in TRIM.IS1_OFF_TRIM1 */
#define TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Shift(v)           (((v) << TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Pos) & TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Msk) /*!< Shift value 'v' into is1_ate_offset1 and mask 'v' to fit it into is1_ate_offset1 field */

/** TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__SET() sets IS1_OFF_TRIM1.IS1_ATE_OFFSET1 to given value.
 *
 * When writing to IS1_OFF_TRIM1.IS1_ATE_OFFSET1, this is recommended to use.
 *
 * @param bf_value new value for IS1_OFF_TRIM1.IS1_ATE_OFFSET1
 */
__TRIM_INLINE void TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM1__GET();
    reg = (reg & ~TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Shift((uint32_t)bf_value)));
    TRIM_IS1_OFF_TRIM1__SET(reg);
}

/** TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__GET() gets IS1_OFF_TRIM1.IS1_ATE_OFFSET1's current value.
 *
 * When reading from IS1_OFF_TRIM1.IS1_ATE_OFFSET1, this is recommended to use.
 *
 * @return current value of IS1_OFF_TRIM1.IS1_ATE_OFFSET1
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__GET(void)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM1__GET();
    reg = (reg & TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__MODIFY() modifies IS1_OFF_TRIM1.IS1_ATE_OFFSET1.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS1_OFF_TRIM1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM1
 * @param bf_value new value for IS1_OFF_TRIM1.IS1_ATE_OFFSET1
 * @return new value of TRIM.IS1_OFF_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__EXTRACT() extracts IS1_OFF_TRIM1.IS1_ATE_OFFSET1.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS1_OFF_TRIM1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM1
 * @return current value of IS1_OFF_TRIM1.IS1_ATE_OFFSET1
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET1__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS1_OFF_TRIM1.IS1_ATE_OFFSET0 ------------------- */

/**
<pre>
  TRIM.IS1_OFF_TRIM1.IS1_ATE_OFFSET0:

    IS1 (ISEN) ADC offset trim when isen1_gain_mode=0.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Pos                0                                                                      /*!< Right-most bit position of is1_ate_offset0 in TRIM.IS1_OFF_TRIM1 */
#define TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Msk                (0x00001FFFUL << TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Pos)             /*!< Mask for is1_ate_offset0 in TRIM.IS1_OFF_TRIM1 */
#define TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Shift(v)           (((v) << TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Pos) & TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Msk) /*!< Shift value 'v' into is1_ate_offset0 and mask 'v' to fit it into is1_ate_offset0 field */

/** TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__SET() sets IS1_OFF_TRIM1.IS1_ATE_OFFSET0 to given value.
 *
 * When writing to IS1_OFF_TRIM1.IS1_ATE_OFFSET0, this is recommended to use.
 *
 * @param bf_value new value for IS1_OFF_TRIM1.IS1_ATE_OFFSET0
 */
__TRIM_INLINE void TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM1__GET();
    reg = (reg & ~TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Shift((uint32_t)bf_value)));
    TRIM_IS1_OFF_TRIM1__SET(reg);
}

/** TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__GET() gets IS1_OFF_TRIM1.IS1_ATE_OFFSET0's current value.
 *
 * When reading from IS1_OFF_TRIM1.IS1_ATE_OFFSET0, this is recommended to use.
 *
 * @return current value of IS1_OFF_TRIM1.IS1_ATE_OFFSET0
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__GET(void)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM1__GET();
    reg = (reg & TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__MODIFY() modifies IS1_OFF_TRIM1.IS1_ATE_OFFSET0.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS1_OFF_TRIM1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM1
 * @param bf_value new value for IS1_OFF_TRIM1.IS1_ATE_OFFSET0
 * @return new value of TRIM.IS1_OFF_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__EXTRACT() extracts IS1_OFF_TRIM1.IS1_ATE_OFFSET0.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS1_OFF_TRIM1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM1
 * @return current value of IS1_OFF_TRIM1.IS1_ATE_OFFSET0
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM1__IS1_ATE_OFFSET0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       IS1_OFF_TRIM2 member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_IS1_OFF_TRIM2__ADDRESS returns the address of member IS1_OFF_TRIM2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IS1_OFF_TRIM2
 */
__TRIM_INLINE uint32_t* __TRIM_IS1_OFF_TRIM2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IS1_OFF_TRIM2)));
}

/** TRIM_IS1_OFF_TRIM2__SET() sets IS1_OFF_TRIM2 to given value.
 *
 * When writing to IS1_OFF_TRIM2, this is mandatory to use.
 *
 * @param value new value for IS1_OFF_TRIM2
 */
__TRIM_INLINE void TRIM_IS1_OFF_TRIM2__SET(uint32_t value)
{
    HAL_SET32(__TRIM_IS1_OFF_TRIM2__ADDRESS(), value);
}

/** TRIM_IS1_OFF_TRIM2__GET() gets IS1_OFF_TRIM2's current value.
 *
 * When reading from IS1_OFF_TRIM2, this is mandatory to use.
 *
 * @return current value of IS1_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__GET(void)
{
    return HAL_GET32(__TRIM_IS1_OFF_TRIM2__ADDRESS());
}

/* -------------------- TRIM.IS1_OFF_TRIM2.IS1_DAC_TRIM -------------------- */

/**
<pre>
  TRIM.IS1_OFF_TRIM2.IS1_DAC_TRIM:

    IS1 (ISEN) coarse offset trim value
    <start table_with_header>
    is1_dac_trim_en is1_dac_trim "Offset Trim Adjust"
    0 xx "0 MSB"
    1 00 "+10 MSB"
    1 01 "+5 MSB"
    1 10 "-5 MSB"
    1 11 "-10 MSB"
    <end table>

</pre> */

#define TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Pos                   27                                                                     /*!< Right-most bit position of is1_dac_trim in TRIM.IS1_OFF_TRIM2 */
#define TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Msk                   (0x00000003UL << TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Pos)                /*!< Mask for is1_dac_trim in TRIM.IS1_OFF_TRIM2 */
#define TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Shift(v)              (((v) << TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Pos) & TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Msk) /*!< Shift value 'v' into is1_dac_trim and mask 'v' to fit it into is1_dac_trim field */

/** TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__SET() sets IS1_OFF_TRIM2.IS1_DAC_TRIM to given value.
 *
 * When writing to IS1_OFF_TRIM2.IS1_DAC_TRIM, this is recommended to use.
 *
 * @param bf_value new value for IS1_OFF_TRIM2.IS1_DAC_TRIM
 */
__TRIM_INLINE void TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Shift((uint32_t)bf_value)));
    TRIM_IS1_OFF_TRIM2__SET(reg);
}

/** TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__GET() gets IS1_OFF_TRIM2.IS1_DAC_TRIM's current value.
 *
 * When reading from IS1_OFF_TRIM2.IS1_DAC_TRIM, this is recommended to use.
 *
 * @return current value of IS1_OFF_TRIM2.IS1_DAC_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__GET(void)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__MODIFY() modifies IS1_OFF_TRIM2.IS1_DAC_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS1_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM2
 * @param bf_value new value for IS1_OFF_TRIM2.IS1_DAC_TRIM
 * @return new value of TRIM.IS1_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__EXTRACT() extracts IS1_OFF_TRIM2.IS1_DAC_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS1_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM2
 * @return current value of IS1_OFF_TRIM2.IS1_DAC_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS1_OFF_TRIM2.IS1_DAC_TRIM_EN ------------------- */

/**
<pre>
  TRIM.IS1_OFF_TRIM2.IS1_DAC_TRIM_EN:

    IS1 (ISEN) ADC coarse offset trim enable
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Pos                26                                                                     /*!< Right-most bit position of is1_dac_trim_en in TRIM.IS1_OFF_TRIM2 */
#define TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Msk                (0x00000001UL << TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Pos)             /*!< Mask for is1_dac_trim_en in TRIM.IS1_OFF_TRIM2 */
#define TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Shift(v)           (((v) << TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Pos) & TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Msk) /*!< Shift value 'v' into is1_dac_trim_en and mask 'v' to fit it into is1_dac_trim_en field */

/** TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__SET() sets IS1_OFF_TRIM2.IS1_DAC_TRIM_EN to given value.
 *
 * When writing to IS1_OFF_TRIM2.IS1_DAC_TRIM_EN, this is recommended to use.
 *
 * @param bf_value new value for IS1_OFF_TRIM2.IS1_DAC_TRIM_EN
 */
__TRIM_INLINE void TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Shift((uint32_t)bf_value)));
    TRIM_IS1_OFF_TRIM2__SET(reg);
}

/** TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__GET() gets IS1_OFF_TRIM2.IS1_DAC_TRIM_EN's current value.
 *
 * When reading from IS1_OFF_TRIM2.IS1_DAC_TRIM_EN, this is recommended to use.
 *
 * @return current value of IS1_OFF_TRIM2.IS1_DAC_TRIM_EN
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__GET(void)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__MODIFY() modifies IS1_OFF_TRIM2.IS1_DAC_TRIM_EN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS1_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM2
 * @param bf_value new value for IS1_OFF_TRIM2.IS1_DAC_TRIM_EN
 * @return new value of TRIM.IS1_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__EXTRACT() extracts IS1_OFF_TRIM2.IS1_DAC_TRIM_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS1_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM2
 * @return current value of IS1_OFF_TRIM2.IS1_DAC_TRIM_EN
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM2__IS1_DAC_TRIM_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS1_OFF_TRIM2.IS1_ATE_OFFSET3 ------------------- */

/**
<pre>
  TRIM.IS1_OFF_TRIM2.IS1_ATE_OFFSET3:

    IS1 (ISEN) ADC offset trim when isen1_gain_mode=3.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Pos                13                                                                     /*!< Right-most bit position of is1_ate_offset3 in TRIM.IS1_OFF_TRIM2 */
#define TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Msk                (0x00001FFFUL << TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Pos)             /*!< Mask for is1_ate_offset3 in TRIM.IS1_OFF_TRIM2 */
#define TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Shift(v)           (((v) << TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Pos) & TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Msk) /*!< Shift value 'v' into is1_ate_offset3 and mask 'v' to fit it into is1_ate_offset3 field */

/** TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__SET() sets IS1_OFF_TRIM2.IS1_ATE_OFFSET3 to given value.
 *
 * When writing to IS1_OFF_TRIM2.IS1_ATE_OFFSET3, this is recommended to use.
 *
 * @param bf_value new value for IS1_OFF_TRIM2.IS1_ATE_OFFSET3
 */
__TRIM_INLINE void TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Shift((uint32_t)bf_value)));
    TRIM_IS1_OFF_TRIM2__SET(reg);
}

/** TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__GET() gets IS1_OFF_TRIM2.IS1_ATE_OFFSET3's current value.
 *
 * When reading from IS1_OFF_TRIM2.IS1_ATE_OFFSET3, this is recommended to use.
 *
 * @return current value of IS1_OFF_TRIM2.IS1_ATE_OFFSET3
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__GET(void)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__MODIFY() modifies IS1_OFF_TRIM2.IS1_ATE_OFFSET3.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS1_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM2
 * @param bf_value new value for IS1_OFF_TRIM2.IS1_ATE_OFFSET3
 * @return new value of TRIM.IS1_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__EXTRACT() extracts IS1_OFF_TRIM2.IS1_ATE_OFFSET3.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS1_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM2
 * @return current value of IS1_OFF_TRIM2.IS1_ATE_OFFSET3
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET3__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS1_OFF_TRIM2.IS1_ATE_OFFSET2 ------------------- */

/**
<pre>
  TRIM.IS1_OFF_TRIM2.IS1_ATE_OFFSET2:

    IS1 (ISEN) ADC offset trim when isen1_gain_mode=2.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Pos                0                                                                      /*!< Right-most bit position of is1_ate_offset2 in TRIM.IS1_OFF_TRIM2 */
#define TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Msk                (0x00001FFFUL << TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Pos)             /*!< Mask for is1_ate_offset2 in TRIM.IS1_OFF_TRIM2 */
#define TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Shift(v)           (((v) << TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Pos) & TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Msk) /*!< Shift value 'v' into is1_ate_offset2 and mask 'v' to fit it into is1_ate_offset2 field */

/** TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__SET() sets IS1_OFF_TRIM2.IS1_ATE_OFFSET2 to given value.
 *
 * When writing to IS1_OFF_TRIM2.IS1_ATE_OFFSET2, this is recommended to use.
 *
 * @param bf_value new value for IS1_OFF_TRIM2.IS1_ATE_OFFSET2
 */
__TRIM_INLINE void TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Shift((uint32_t)bf_value)));
    TRIM_IS1_OFF_TRIM2__SET(reg);
}

/** TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__GET() gets IS1_OFF_TRIM2.IS1_ATE_OFFSET2's current value.
 *
 * When reading from IS1_OFF_TRIM2.IS1_ATE_OFFSET2, this is recommended to use.
 *
 * @return current value of IS1_OFF_TRIM2.IS1_ATE_OFFSET2
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__GET(void)
{
    uint32_t reg = TRIM_IS1_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__MODIFY() modifies IS1_OFF_TRIM2.IS1_ATE_OFFSET2.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS1_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM2
 * @param bf_value new value for IS1_OFF_TRIM2.IS1_ATE_OFFSET2
 * @return new value of TRIM.IS1_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Msk);
    reg = (reg | (TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__EXTRACT() extracts IS1_OFF_TRIM2.IS1_ATE_OFFSET2.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS1_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS1_OFF_TRIM2
 * @return current value of IS1_OFF_TRIM2.IS1_ATE_OFFSET2
 */
__TRIM_INLINE uint32_t TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Msk);
    reg = (reg >> TRIM_IS1_OFF_TRIM2__IS1_ATE_OFFSET2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       IS2_OFF_TRIM1 member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_IS2_OFF_TRIM1__ADDRESS returns the address of member IS2_OFF_TRIM1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IS2_OFF_TRIM1
 */
__TRIM_INLINE uint32_t* __TRIM_IS2_OFF_TRIM1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IS2_OFF_TRIM1)));
}

/** TRIM_IS2_OFF_TRIM1__SET() sets IS2_OFF_TRIM1 to given value.
 *
 * When writing to IS2_OFF_TRIM1, this is mandatory to use.
 *
 * @param value new value for IS2_OFF_TRIM1
 */
__TRIM_INLINE void TRIM_IS2_OFF_TRIM1__SET(uint32_t value)
{
    HAL_SET32(__TRIM_IS2_OFF_TRIM1__ADDRESS(), value);
}

/** TRIM_IS2_OFF_TRIM1__GET() gets IS2_OFF_TRIM1's current value.
 *
 * When reading from IS2_OFF_TRIM1, this is mandatory to use.
 *
 * @return current value of IS2_OFF_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM1__GET(void)
{
    return HAL_GET32(__TRIM_IS2_OFF_TRIM1__ADDRESS());
}

/* ------------------- TRIM.IS2_OFF_TRIM1.IS2_ATE_OFFSET1 ------------------- */

/**
<pre>
  TRIM.IS2_OFF_TRIM1.IS2_ATE_OFFSET1:

    IS2 (calibration) ADC offset trim when isen2_gain_mode=1.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Pos                13                                                                     /*!< Right-most bit position of is2_ate_offset1 in TRIM.IS2_OFF_TRIM1 */
#define TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Msk                (0x00001FFFUL << TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Pos)             /*!< Mask for is2_ate_offset1 in TRIM.IS2_OFF_TRIM1 */
#define TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Shift(v)           (((v) << TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Pos) & TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Msk) /*!< Shift value 'v' into is2_ate_offset1 and mask 'v' to fit it into is2_ate_offset1 field */

/** TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__SET() sets IS2_OFF_TRIM1.IS2_ATE_OFFSET1 to given value.
 *
 * When writing to IS2_OFF_TRIM1.IS2_ATE_OFFSET1, this is recommended to use.
 *
 * @param bf_value new value for IS2_OFF_TRIM1.IS2_ATE_OFFSET1
 */
__TRIM_INLINE void TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM1__GET();
    reg = (reg & ~TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Shift((uint32_t)bf_value)));
    TRIM_IS2_OFF_TRIM1__SET(reg);
}

/** TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__GET() gets IS2_OFF_TRIM1.IS2_ATE_OFFSET1's current value.
 *
 * When reading from IS2_OFF_TRIM1.IS2_ATE_OFFSET1, this is recommended to use.
 *
 * @return current value of IS2_OFF_TRIM1.IS2_ATE_OFFSET1
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__GET(void)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM1__GET();
    reg = (reg & TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__MODIFY() modifies IS2_OFF_TRIM1.IS2_ATE_OFFSET1.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS2_OFF_TRIM1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM1
 * @param bf_value new value for IS2_OFF_TRIM1.IS2_ATE_OFFSET1
 * @return new value of TRIM.IS2_OFF_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__EXTRACT() extracts IS2_OFF_TRIM1.IS2_ATE_OFFSET1.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS2_OFF_TRIM1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM1
 * @return current value of IS2_OFF_TRIM1.IS2_ATE_OFFSET1
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET1__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS2_OFF_TRIM1.IS2_ATE_OFFSET0 ------------------- */

/**
<pre>
  TRIM.IS2_OFF_TRIM1.IS2_ATE_OFFSET0:

    IS2 (calibration) ADC offset trim when isen2_gain_mode=0.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Pos                0                                                                      /*!< Right-most bit position of is2_ate_offset0 in TRIM.IS2_OFF_TRIM1 */
#define TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Msk                (0x00001FFFUL << TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Pos)             /*!< Mask for is2_ate_offset0 in TRIM.IS2_OFF_TRIM1 */
#define TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Shift(v)           (((v) << TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Pos) & TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Msk) /*!< Shift value 'v' into is2_ate_offset0 and mask 'v' to fit it into is2_ate_offset0 field */

/** TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__SET() sets IS2_OFF_TRIM1.IS2_ATE_OFFSET0 to given value.
 *
 * When writing to IS2_OFF_TRIM1.IS2_ATE_OFFSET0, this is recommended to use.
 *
 * @param bf_value new value for IS2_OFF_TRIM1.IS2_ATE_OFFSET0
 */
__TRIM_INLINE void TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM1__GET();
    reg = (reg & ~TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Shift((uint32_t)bf_value)));
    TRIM_IS2_OFF_TRIM1__SET(reg);
}

/** TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__GET() gets IS2_OFF_TRIM1.IS2_ATE_OFFSET0's current value.
 *
 * When reading from IS2_OFF_TRIM1.IS2_ATE_OFFSET0, this is recommended to use.
 *
 * @return current value of IS2_OFF_TRIM1.IS2_ATE_OFFSET0
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__GET(void)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM1__GET();
    reg = (reg & TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__MODIFY() modifies IS2_OFF_TRIM1.IS2_ATE_OFFSET0.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS2_OFF_TRIM1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM1
 * @param bf_value new value for IS2_OFF_TRIM1.IS2_ATE_OFFSET0
 * @return new value of TRIM.IS2_OFF_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__EXTRACT() extracts IS2_OFF_TRIM1.IS2_ATE_OFFSET0.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS2_OFF_TRIM1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM1
 * @return current value of IS2_OFF_TRIM1.IS2_ATE_OFFSET0
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM1__IS2_ATE_OFFSET0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       IS2_OFF_TRIM2 member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_IS2_OFF_TRIM2__ADDRESS returns the address of member IS2_OFF_TRIM2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IS2_OFF_TRIM2
 */
__TRIM_INLINE uint32_t* __TRIM_IS2_OFF_TRIM2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IS2_OFF_TRIM2)));
}

/** TRIM_IS2_OFF_TRIM2__SET() sets IS2_OFF_TRIM2 to given value.
 *
 * When writing to IS2_OFF_TRIM2, this is mandatory to use.
 *
 * @param value new value for IS2_OFF_TRIM2
 */
__TRIM_INLINE void TRIM_IS2_OFF_TRIM2__SET(uint32_t value)
{
    HAL_SET32(__TRIM_IS2_OFF_TRIM2__ADDRESS(), value);
}

/** TRIM_IS2_OFF_TRIM2__GET() gets IS2_OFF_TRIM2's current value.
 *
 * When reading from IS2_OFF_TRIM2, this is mandatory to use.
 *
 * @return current value of IS2_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__GET(void)
{
    return HAL_GET32(__TRIM_IS2_OFF_TRIM2__ADDRESS());
}

/* -------------------- TRIM.IS2_OFF_TRIM2.IS2_DAC_TRIM -------------------- */

/**
<pre>
  TRIM.IS2_OFF_TRIM2.IS2_DAC_TRIM:

    IS2 (calibration) coarse offset trim value
    <start table_with_header>
    is2_dac_trim_en is2_dac_trim "Offset Trim Adjust"
    0 xx "0 MSB"
    1 00 "+10 MSB"
    1 01 "+5 MSB"
    1 10 "-5 MSB"
    1 11 "-10 MSB"
    <end table>

</pre> */

#define TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Pos                   27                                                                     /*!< Right-most bit position of is2_dac_trim in TRIM.IS2_OFF_TRIM2 */
#define TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Msk                   (0x00000003UL << TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Pos)                /*!< Mask for is2_dac_trim in TRIM.IS2_OFF_TRIM2 */
#define TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Shift(v)              (((v) << TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Pos) & TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Msk) /*!< Shift value 'v' into is2_dac_trim and mask 'v' to fit it into is2_dac_trim field */

/** TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__SET() sets IS2_OFF_TRIM2.IS2_DAC_TRIM to given value.
 *
 * When writing to IS2_OFF_TRIM2.IS2_DAC_TRIM, this is recommended to use.
 *
 * @param bf_value new value for IS2_OFF_TRIM2.IS2_DAC_TRIM
 */
__TRIM_INLINE void TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Shift((uint32_t)bf_value)));
    TRIM_IS2_OFF_TRIM2__SET(reg);
}

/** TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__GET() gets IS2_OFF_TRIM2.IS2_DAC_TRIM's current value.
 *
 * When reading from IS2_OFF_TRIM2.IS2_DAC_TRIM, this is recommended to use.
 *
 * @return current value of IS2_OFF_TRIM2.IS2_DAC_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__GET(void)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__MODIFY() modifies IS2_OFF_TRIM2.IS2_DAC_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS2_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM2
 * @param bf_value new value for IS2_OFF_TRIM2.IS2_DAC_TRIM
 * @return new value of TRIM.IS2_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__EXTRACT() extracts IS2_OFF_TRIM2.IS2_DAC_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS2_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM2
 * @return current value of IS2_OFF_TRIM2.IS2_DAC_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS2_OFF_TRIM2.IS2_DAC_TRIM_EN ------------------- */

/**
<pre>
  TRIM.IS2_OFF_TRIM2.IS2_DAC_TRIM_EN:

    IS2 (calibration) ADC coarse offset trim enable
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Pos                26                                                                     /*!< Right-most bit position of is2_dac_trim_en in TRIM.IS2_OFF_TRIM2 */
#define TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Msk                (0x00000001UL << TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Pos)             /*!< Mask for is2_dac_trim_en in TRIM.IS2_OFF_TRIM2 */
#define TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Shift(v)           (((v) << TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Pos) & TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Msk) /*!< Shift value 'v' into is2_dac_trim_en and mask 'v' to fit it into is2_dac_trim_en field */

/** TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__SET() sets IS2_OFF_TRIM2.IS2_DAC_TRIM_EN to given value.
 *
 * When writing to IS2_OFF_TRIM2.IS2_DAC_TRIM_EN, this is recommended to use.
 *
 * @param bf_value new value for IS2_OFF_TRIM2.IS2_DAC_TRIM_EN
 */
__TRIM_INLINE void TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Shift((uint32_t)bf_value)));
    TRIM_IS2_OFF_TRIM2__SET(reg);
}

/** TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__GET() gets IS2_OFF_TRIM2.IS2_DAC_TRIM_EN's current value.
 *
 * When reading from IS2_OFF_TRIM2.IS2_DAC_TRIM_EN, this is recommended to use.
 *
 * @return current value of IS2_OFF_TRIM2.IS2_DAC_TRIM_EN
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__GET(void)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__MODIFY() modifies IS2_OFF_TRIM2.IS2_DAC_TRIM_EN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS2_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM2
 * @param bf_value new value for IS2_OFF_TRIM2.IS2_DAC_TRIM_EN
 * @return new value of TRIM.IS2_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__EXTRACT() extracts IS2_OFF_TRIM2.IS2_DAC_TRIM_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS2_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM2
 * @return current value of IS2_OFF_TRIM2.IS2_DAC_TRIM_EN
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM2__IS2_DAC_TRIM_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS2_OFF_TRIM2.IS2_ATE_OFFSET3 ------------------- */

/**
<pre>
  TRIM.IS2_OFF_TRIM2.IS2_ATE_OFFSET3:

    IS2 (calibration) ADC offset trim when isen2_gain_mode=3.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Pos                13                                                                     /*!< Right-most bit position of is2_ate_offset3 in TRIM.IS2_OFF_TRIM2 */
#define TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Msk                (0x00001FFFUL << TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Pos)             /*!< Mask for is2_ate_offset3 in TRIM.IS2_OFF_TRIM2 */
#define TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Shift(v)           (((v) << TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Pos) & TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Msk) /*!< Shift value 'v' into is2_ate_offset3 and mask 'v' to fit it into is2_ate_offset3 field */

/** TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__SET() sets IS2_OFF_TRIM2.IS2_ATE_OFFSET3 to given value.
 *
 * When writing to IS2_OFF_TRIM2.IS2_ATE_OFFSET3, this is recommended to use.
 *
 * @param bf_value new value for IS2_OFF_TRIM2.IS2_ATE_OFFSET3
 */
__TRIM_INLINE void TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Shift((uint32_t)bf_value)));
    TRIM_IS2_OFF_TRIM2__SET(reg);
}

/** TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__GET() gets IS2_OFF_TRIM2.IS2_ATE_OFFSET3's current value.
 *
 * When reading from IS2_OFF_TRIM2.IS2_ATE_OFFSET3, this is recommended to use.
 *
 * @return current value of IS2_OFF_TRIM2.IS2_ATE_OFFSET3
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__GET(void)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__MODIFY() modifies IS2_OFF_TRIM2.IS2_ATE_OFFSET3.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS2_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM2
 * @param bf_value new value for IS2_OFF_TRIM2.IS2_ATE_OFFSET3
 * @return new value of TRIM.IS2_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__EXTRACT() extracts IS2_OFF_TRIM2.IS2_ATE_OFFSET3.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS2_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM2
 * @return current value of IS2_OFF_TRIM2.IS2_ATE_OFFSET3
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET3__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS2_OFF_TRIM2.IS2_ATE_OFFSET2 ------------------- */

/**
<pre>
  TRIM.IS2_OFF_TRIM2.IS2_ATE_OFFSET2:

    IS2 (calibration) ADC offset trim when isen2_gain_mode=2.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Pos                0                                                                      /*!< Right-most bit position of is2_ate_offset2 in TRIM.IS2_OFF_TRIM2 */
#define TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Msk                (0x00001FFFUL << TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Pos)             /*!< Mask for is2_ate_offset2 in TRIM.IS2_OFF_TRIM2 */
#define TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Shift(v)           (((v) << TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Pos) & TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Msk) /*!< Shift value 'v' into is2_ate_offset2 and mask 'v' to fit it into is2_ate_offset2 field */

/** TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__SET() sets IS2_OFF_TRIM2.IS2_ATE_OFFSET2 to given value.
 *
 * When writing to IS2_OFF_TRIM2.IS2_ATE_OFFSET2, this is recommended to use.
 *
 * @param bf_value new value for IS2_OFF_TRIM2.IS2_ATE_OFFSET2
 */
__TRIM_INLINE void TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Shift((uint32_t)bf_value)));
    TRIM_IS2_OFF_TRIM2__SET(reg);
}

/** TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__GET() gets IS2_OFF_TRIM2.IS2_ATE_OFFSET2's current value.
 *
 * When reading from IS2_OFF_TRIM2.IS2_ATE_OFFSET2, this is recommended to use.
 *
 * @return current value of IS2_OFF_TRIM2.IS2_ATE_OFFSET2
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__GET(void)
{
    uint32_t reg = TRIM_IS2_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__MODIFY() modifies IS2_OFF_TRIM2.IS2_ATE_OFFSET2.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS2_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM2
 * @param bf_value new value for IS2_OFF_TRIM2.IS2_ATE_OFFSET2
 * @return new value of TRIM.IS2_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Msk);
    reg = (reg | (TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__EXTRACT() extracts IS2_OFF_TRIM2.IS2_ATE_OFFSET2.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS2_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS2_OFF_TRIM2
 * @return current value of IS2_OFF_TRIM2.IS2_ATE_OFFSET2
 */
__TRIM_INLINE uint32_t TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Msk);
    reg = (reg >> TRIM_IS2_OFF_TRIM2__IS2_ATE_OFFSET2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       IS3_OFF_TRIM1 member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_IS3_OFF_TRIM1__ADDRESS returns the address of member IS3_OFF_TRIM1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IS3_OFF_TRIM1
 */
__TRIM_INLINE uint32_t* __TRIM_IS3_OFF_TRIM1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IS3_OFF_TRIM1)));
}

/** TRIM_IS3_OFF_TRIM1__SET() sets IS3_OFF_TRIM1 to given value.
 *
 * When writing to IS3_OFF_TRIM1, this is mandatory to use.
 *
 * @param value new value for IS3_OFF_TRIM1
 */
__TRIM_INLINE void TRIM_IS3_OFF_TRIM1__SET(uint32_t value)
{
    HAL_SET32(__TRIM_IS3_OFF_TRIM1__ADDRESS(), value);
}

/** TRIM_IS3_OFF_TRIM1__GET() gets IS3_OFF_TRIM1's current value.
 *
 * When reading from IS3_OFF_TRIM1, this is mandatory to use.
 *
 * @return current value of IS3_OFF_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM1__GET(void)
{
    return HAL_GET32(__TRIM_IS3_OFF_TRIM1__ADDRESS());
}

/* ------------------- TRIM.IS3_OFF_TRIM1.IS3_ATE_OFFSET1 ------------------- */

/**
<pre>
  TRIM.IS3_OFF_TRIM1.IS3_ATE_OFFSET1:

    IS3 (BISEN) ADC offset trim when isen3_gain_mode=1.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Pos                13                                                                     /*!< Right-most bit position of is3_ate_offset1 in TRIM.IS3_OFF_TRIM1 */
#define TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Msk                (0x00001FFFUL << TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Pos)             /*!< Mask for is3_ate_offset1 in TRIM.IS3_OFF_TRIM1 */
#define TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Shift(v)           (((v) << TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Pos) & TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Msk) /*!< Shift value 'v' into is3_ate_offset1 and mask 'v' to fit it into is3_ate_offset1 field */

/** TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__SET() sets IS3_OFF_TRIM1.IS3_ATE_OFFSET1 to given value.
 *
 * When writing to IS3_OFF_TRIM1.IS3_ATE_OFFSET1, this is recommended to use.
 *
 * @param bf_value new value for IS3_OFF_TRIM1.IS3_ATE_OFFSET1
 */
__TRIM_INLINE void TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM1__GET();
    reg = (reg & ~TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Shift((uint32_t)bf_value)));
    TRIM_IS3_OFF_TRIM1__SET(reg);
}

/** TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__GET() gets IS3_OFF_TRIM1.IS3_ATE_OFFSET1's current value.
 *
 * When reading from IS3_OFF_TRIM1.IS3_ATE_OFFSET1, this is recommended to use.
 *
 * @return current value of IS3_OFF_TRIM1.IS3_ATE_OFFSET1
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__GET(void)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM1__GET();
    reg = (reg & TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__MODIFY() modifies IS3_OFF_TRIM1.IS3_ATE_OFFSET1.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS3_OFF_TRIM1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM1
 * @param bf_value new value for IS3_OFF_TRIM1.IS3_ATE_OFFSET1
 * @return new value of TRIM.IS3_OFF_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__EXTRACT() extracts IS3_OFF_TRIM1.IS3_ATE_OFFSET1.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS3_OFF_TRIM1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM1
 * @return current value of IS3_OFF_TRIM1.IS3_ATE_OFFSET1
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET1__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS3_OFF_TRIM1.IS3_ATE_OFFSET0 ------------------- */

/**
<pre>
  TRIM.IS3_OFF_TRIM1.IS3_ATE_OFFSET0:

    IS3 (BISEN) ADC offset trim when isen3_gain_mode=0.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Pos                0                                                                      /*!< Right-most bit position of is3_ate_offset0 in TRIM.IS3_OFF_TRIM1 */
#define TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Msk                (0x00001FFFUL << TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Pos)             /*!< Mask for is3_ate_offset0 in TRIM.IS3_OFF_TRIM1 */
#define TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Shift(v)           (((v) << TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Pos) & TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Msk) /*!< Shift value 'v' into is3_ate_offset0 and mask 'v' to fit it into is3_ate_offset0 field */

/** TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__SET() sets IS3_OFF_TRIM1.IS3_ATE_OFFSET0 to given value.
 *
 * When writing to IS3_OFF_TRIM1.IS3_ATE_OFFSET0, this is recommended to use.
 *
 * @param bf_value new value for IS3_OFF_TRIM1.IS3_ATE_OFFSET0
 */
__TRIM_INLINE void TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM1__GET();
    reg = (reg & ~TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Shift((uint32_t)bf_value)));
    TRIM_IS3_OFF_TRIM1__SET(reg);
}

/** TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__GET() gets IS3_OFF_TRIM1.IS3_ATE_OFFSET0's current value.
 *
 * When reading from IS3_OFF_TRIM1.IS3_ATE_OFFSET0, this is recommended to use.
 *
 * @return current value of IS3_OFF_TRIM1.IS3_ATE_OFFSET0
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__GET(void)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM1__GET();
    reg = (reg & TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__MODIFY() modifies IS3_OFF_TRIM1.IS3_ATE_OFFSET0.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS3_OFF_TRIM1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM1
 * @param bf_value new value for IS3_OFF_TRIM1.IS3_ATE_OFFSET0
 * @return new value of TRIM.IS3_OFF_TRIM1
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__EXTRACT() extracts IS3_OFF_TRIM1.IS3_ATE_OFFSET0.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS3_OFF_TRIM1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM1
 * @return current value of IS3_OFF_TRIM1.IS3_ATE_OFFSET0
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM1__IS3_ATE_OFFSET0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       IS3_OFF_TRIM2 member of TRIM_t                       */
/* -------------------------------------------------------------------------- */

/** __TRIM_IS3_OFF_TRIM2__ADDRESS returns the address of member IS3_OFF_TRIM2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IS3_OFF_TRIM2
 */
__TRIM_INLINE uint32_t* __TRIM_IS3_OFF_TRIM2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IS3_OFF_TRIM2)));
}

/** TRIM_IS3_OFF_TRIM2__SET() sets IS3_OFF_TRIM2 to given value.
 *
 * When writing to IS3_OFF_TRIM2, this is mandatory to use.
 *
 * @param value new value for IS3_OFF_TRIM2
 */
__TRIM_INLINE void TRIM_IS3_OFF_TRIM2__SET(uint32_t value)
{
    HAL_SET32(__TRIM_IS3_OFF_TRIM2__ADDRESS(), value);
}

/** TRIM_IS3_OFF_TRIM2__GET() gets IS3_OFF_TRIM2's current value.
 *
 * When reading from IS3_OFF_TRIM2, this is mandatory to use.
 *
 * @return current value of IS3_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__GET(void)
{
    return HAL_GET32(__TRIM_IS3_OFF_TRIM2__ADDRESS());
}

/* -------------------- TRIM.IS3_OFF_TRIM2.IS3_DAC_TRIM -------------------- */

/**
<pre>
  TRIM.IS3_OFF_TRIM2.IS3_DAC_TRIM:

    IS3 (BISEN) coarse offset trim value
    <start table_with_header>
    is3_dac_trim_en is3_dac_trim "Offset Trim Adjust"
    0 xx "0 MSB"
    1 00 "+10 MSB"
    1 01 "+5 MSB"
    1 10 "-5 MSB"
    1 11 "-10 MSB"
    <end table>

</pre> */

#define TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Pos                   27                                                                     /*!< Right-most bit position of is3_dac_trim in TRIM.IS3_OFF_TRIM2 */
#define TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Msk                   (0x00000003UL << TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Pos)                /*!< Mask for is3_dac_trim in TRIM.IS3_OFF_TRIM2 */
#define TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Shift(v)              (((v) << TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Pos) & TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Msk) /*!< Shift value 'v' into is3_dac_trim and mask 'v' to fit it into is3_dac_trim field */

/** TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__SET() sets IS3_OFF_TRIM2.IS3_DAC_TRIM to given value.
 *
 * When writing to IS3_OFF_TRIM2.IS3_DAC_TRIM, this is recommended to use.
 *
 * @param bf_value new value for IS3_OFF_TRIM2.IS3_DAC_TRIM
 */
__TRIM_INLINE void TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Shift((uint32_t)bf_value)));
    TRIM_IS3_OFF_TRIM2__SET(reg);
}

/** TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__GET() gets IS3_OFF_TRIM2.IS3_DAC_TRIM's current value.
 *
 * When reading from IS3_OFF_TRIM2.IS3_DAC_TRIM, this is recommended to use.
 *
 * @return current value of IS3_OFF_TRIM2.IS3_DAC_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__GET(void)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__MODIFY() modifies IS3_OFF_TRIM2.IS3_DAC_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS3_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM2
 * @param bf_value new value for IS3_OFF_TRIM2.IS3_DAC_TRIM
 * @return new value of TRIM.IS3_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__EXTRACT() extracts IS3_OFF_TRIM2.IS3_DAC_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS3_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM2
 * @return current value of IS3_OFF_TRIM2.IS3_DAC_TRIM
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS3_OFF_TRIM2.IS3_DAC_TRIM_EN ------------------- */

/**
<pre>
  TRIM.IS3_OFF_TRIM2.IS3_DAC_TRIM_EN:

    IS3 (BISEN) ADC coarse offset trim enable
    <start table>
    0 "disabled"
    1 "enabled"
    <end table>

</pre> */

#define TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Pos                26                                                                     /*!< Right-most bit position of is3_dac_trim_en in TRIM.IS3_OFF_TRIM2 */
#define TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Msk                (0x00000001UL << TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Pos)             /*!< Mask for is3_dac_trim_en in TRIM.IS3_OFF_TRIM2 */
#define TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Shift(v)           (((v) << TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Pos) & TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Msk) /*!< Shift value 'v' into is3_dac_trim_en and mask 'v' to fit it into is3_dac_trim_en field */

/** TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__SET() sets IS3_OFF_TRIM2.IS3_DAC_TRIM_EN to given value.
 *
 * When writing to IS3_OFF_TRIM2.IS3_DAC_TRIM_EN, this is recommended to use.
 *
 * @param bf_value new value for IS3_OFF_TRIM2.IS3_DAC_TRIM_EN
 */
__TRIM_INLINE void TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Shift((uint32_t)bf_value)));
    TRIM_IS3_OFF_TRIM2__SET(reg);
}

/** TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__GET() gets IS3_OFF_TRIM2.IS3_DAC_TRIM_EN's current value.
 *
 * When reading from IS3_OFF_TRIM2.IS3_DAC_TRIM_EN, this is recommended to use.
 *
 * @return current value of IS3_OFF_TRIM2.IS3_DAC_TRIM_EN
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__GET(void)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__MODIFY() modifies IS3_OFF_TRIM2.IS3_DAC_TRIM_EN.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS3_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM2
 * @param bf_value new value for IS3_OFF_TRIM2.IS3_DAC_TRIM_EN
 * @return new value of TRIM.IS3_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__EXTRACT() extracts IS3_OFF_TRIM2.IS3_DAC_TRIM_EN.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS3_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM2
 * @return current value of IS3_OFF_TRIM2.IS3_DAC_TRIM_EN
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM2__IS3_DAC_TRIM_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS3_OFF_TRIM2.IS3_ATE_OFFSET3 ------------------- */

/**
<pre>
  TRIM.IS3_OFF_TRIM2.IS3_ATE_OFFSET3:

    IS3 (BISEN) ADC offset trim when isen3_gain_mode=3.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Pos                13                                                                     /*!< Right-most bit position of is3_ate_offset3 in TRIM.IS3_OFF_TRIM2 */
#define TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Msk                (0x00001FFFUL << TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Pos)             /*!< Mask for is3_ate_offset3 in TRIM.IS3_OFF_TRIM2 */
#define TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Shift(v)           (((v) << TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Pos) & TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Msk) /*!< Shift value 'v' into is3_ate_offset3 and mask 'v' to fit it into is3_ate_offset3 field */

/** TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__SET() sets IS3_OFF_TRIM2.IS3_ATE_OFFSET3 to given value.
 *
 * When writing to IS3_OFF_TRIM2.IS3_ATE_OFFSET3, this is recommended to use.
 *
 * @param bf_value new value for IS3_OFF_TRIM2.IS3_ATE_OFFSET3
 */
__TRIM_INLINE void TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Shift((uint32_t)bf_value)));
    TRIM_IS3_OFF_TRIM2__SET(reg);
}

/** TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__GET() gets IS3_OFF_TRIM2.IS3_ATE_OFFSET3's current value.
 *
 * When reading from IS3_OFF_TRIM2.IS3_ATE_OFFSET3, this is recommended to use.
 *
 * @return current value of IS3_OFF_TRIM2.IS3_ATE_OFFSET3
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__GET(void)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__MODIFY() modifies IS3_OFF_TRIM2.IS3_ATE_OFFSET3.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS3_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM2
 * @param bf_value new value for IS3_OFF_TRIM2.IS3_ATE_OFFSET3
 * @return new value of TRIM.IS3_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__EXTRACT() extracts IS3_OFF_TRIM2.IS3_ATE_OFFSET3.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS3_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM2
 * @return current value of IS3_OFF_TRIM2.IS3_ATE_OFFSET3
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET3__Pos);
    return (uint32_t)reg;
}

/* ------------------- TRIM.IS3_OFF_TRIM2.IS3_ATE_OFFSET2 ------------------- */

/**
<pre>
  TRIM.IS3_OFF_TRIM2.IS3_ATE_OFFSET2:

    IS3 (BISEN) ADC offset trim when isen3_gain_mode=2.  Used only when auto calibration is disabled.

</pre> */

#define TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Pos                0                                                                      /*!< Right-most bit position of is3_ate_offset2 in TRIM.IS3_OFF_TRIM2 */
#define TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Msk                (0x00001FFFUL << TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Pos)             /*!< Mask for is3_ate_offset2 in TRIM.IS3_OFF_TRIM2 */
#define TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Shift(v)           (((v) << TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Pos) & TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Msk) /*!< Shift value 'v' into is3_ate_offset2 and mask 'v' to fit it into is3_ate_offset2 field */

/** TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__SET() sets IS3_OFF_TRIM2.IS3_ATE_OFFSET2 to given value.
 *
 * When writing to IS3_OFF_TRIM2.IS3_ATE_OFFSET2, this is recommended to use.
 *
 * @param bf_value new value for IS3_OFF_TRIM2.IS3_ATE_OFFSET2
 */
__TRIM_INLINE void TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM2__GET();
    reg = (reg & ~TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Shift((uint32_t)bf_value)));
    TRIM_IS3_OFF_TRIM2__SET(reg);
}

/** TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__GET() gets IS3_OFF_TRIM2.IS3_ATE_OFFSET2's current value.
 *
 * When reading from IS3_OFF_TRIM2.IS3_ATE_OFFSET2, this is recommended to use.
 *
 * @return current value of IS3_OFF_TRIM2.IS3_ATE_OFFSET2
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__GET(void)
{
    uint32_t reg = TRIM_IS3_OFF_TRIM2__GET();
    reg = (reg & TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Pos);
    return (uint32_t)reg;
}

/** TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__MODIFY() modifies IS3_OFF_TRIM2.IS3_ATE_OFFSET2.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.IS3_OFF_TRIM2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM2
 * @param bf_value new value for IS3_OFF_TRIM2.IS3_ATE_OFFSET2
 * @return new value of TRIM.IS3_OFF_TRIM2
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Msk);
    reg = (reg | (TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__EXTRACT() extracts IS3_OFF_TRIM2.IS3_ATE_OFFSET2.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IS3_OFF_TRIM2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IS3_OFF_TRIM2
 * @return current value of IS3_OFF_TRIM2.IS3_ATE_OFFSET2
 */
__TRIM_INLINE uint32_t TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Msk);
    reg = (reg >> TRIM_IS3_OFF_TRIM2__IS3_ATE_OFFSET2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        SPARE_TRIM member of TRIM_t                        */
/* -------------------------------------------------------------------------- */

/** __TRIM_SPARE_TRIM__ADDRESS returns the address of member SPARE_TRIM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of SPARE_TRIM
 */
__TRIM_INLINE uint32_t* __TRIM_SPARE_TRIM__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, SPARE_TRIM)));
}

/** TRIM_SPARE_TRIM__SET() sets SPARE_TRIM to given value.
 *
 * When writing to SPARE_TRIM, this is mandatory to use.
 *
 * @param value new value for SPARE_TRIM
 */
__TRIM_INLINE void TRIM_SPARE_TRIM__SET(uint32_t value)
{
    HAL_SET32(__TRIM_SPARE_TRIM__ADDRESS(), value);
}

/** TRIM_SPARE_TRIM__GET() gets SPARE_TRIM's current value.
 *
 * When reading from SPARE_TRIM, this is mandatory to use.
 *
 * @return current value of SPARE_TRIM
 */
__TRIM_INLINE uint32_t TRIM_SPARE_TRIM__GET(void)
{
    return HAL_GET32(__TRIM_SPARE_TRIM__ADDRESS());
}

/* ----------------------- TRIM.SPARE_TRIM.SPARE_TRIM ----------------------- */

/**
<pre>
  TRIM.SPARE_TRIM.SPARE_TRIM:

    Spare trim register location.  Not currently in use

</pre> */

#define TRIM_SPARE_TRIM__SPARE_TRIM__Pos                        0                                                                      /*!< Right-most bit position of spare_trim in TRIM.SPARE_TRIM */
#define TRIM_SPARE_TRIM__SPARE_TRIM__Msk                        (0xFFFFFFFFUL << TRIM_SPARE_TRIM__SPARE_TRIM__Pos)                     /*!< Mask for spare_trim in TRIM.SPARE_TRIM */
#define TRIM_SPARE_TRIM__SPARE_TRIM__Shift(v)                   (((v) << TRIM_SPARE_TRIM__SPARE_TRIM__Pos) & TRIM_SPARE_TRIM__SPARE_TRIM__Msk) /*!< Shift value 'v' into spare_trim and mask 'v' to fit it into spare_trim field */

/** TRIM_SPARE_TRIM__SPARE_TRIM__SET() sets SPARE_TRIM.SPARE_TRIM to given value.
 *
 * When writing to SPARE_TRIM.SPARE_TRIM, this is recommended to use.
 *
 * @param bf_value new value for SPARE_TRIM.SPARE_TRIM
 */
__TRIM_INLINE void TRIM_SPARE_TRIM__SPARE_TRIM__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_SPARE_TRIM__GET();
    reg = (reg & ~TRIM_SPARE_TRIM__SPARE_TRIM__Msk);
    reg = (reg | (TRIM_SPARE_TRIM__SPARE_TRIM__Shift((uint32_t)bf_value)));
    TRIM_SPARE_TRIM__SET(reg);
}

/** TRIM_SPARE_TRIM__SPARE_TRIM__GET() gets SPARE_TRIM.SPARE_TRIM's current value.
 *
 * When reading from SPARE_TRIM.SPARE_TRIM, this is recommended to use.
 *
 * @return current value of SPARE_TRIM.SPARE_TRIM
 */
__TRIM_INLINE uint32_t TRIM_SPARE_TRIM__SPARE_TRIM__GET(void)
{
    uint32_t reg = TRIM_SPARE_TRIM__GET();
    reg = (reg & TRIM_SPARE_TRIM__SPARE_TRIM__Msk);
    reg = (reg >> TRIM_SPARE_TRIM__SPARE_TRIM__Pos);
    return (uint32_t)reg;
}

/** TRIM_SPARE_TRIM__SPARE_TRIM__MODIFY() modifies SPARE_TRIM.SPARE_TRIM.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.SPARE_TRIM.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.SPARE_TRIM
 * @param bf_value new value for SPARE_TRIM.SPARE_TRIM
 * @return new value of TRIM.SPARE_TRIM
 */
__TRIM_INLINE uint32_t TRIM_SPARE_TRIM__SPARE_TRIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_SPARE_TRIM__SPARE_TRIM__Msk);
    reg = (reg | (TRIM_SPARE_TRIM__SPARE_TRIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_SPARE_TRIM__SPARE_TRIM__EXTRACT() extracts SPARE_TRIM.SPARE_TRIM.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.SPARE_TRIM.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.SPARE_TRIM
 * @return current value of SPARE_TRIM.SPARE_TRIM
 */
__TRIM_INLINE uint32_t TRIM_SPARE_TRIM__SPARE_TRIM__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_SPARE_TRIM__SPARE_TRIM__Msk);
    reg = (reg >> TRIM_SPARE_TRIM__SPARE_TRIM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          PROD_ID member of TRIM_t                          */
/* -------------------------------------------------------------------------- */

/** __TRIM_PROD_ID__ADDRESS returns the address of member PROD_ID.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of PROD_ID
 */
__TRIM_INLINE uint32_t* __TRIM_PROD_ID__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, PROD_ID)));
}

/** TRIM_PROD_ID__SET() sets PROD_ID to given value.
 *
 * When writing to PROD_ID, this is mandatory to use.
 *
 * @param value new value for PROD_ID
 */
__TRIM_INLINE void TRIM_PROD_ID__SET(uint32_t value)
{
    HAL_SET32(__TRIM_PROD_ID__ADDRESS(), value);
}

/** TRIM_PROD_ID__GET() gets PROD_ID's current value.
 *
 * When reading from PROD_ID, this is mandatory to use.
 *
 * @return current value of PROD_ID
 */
__TRIM_INLINE uint32_t TRIM_PROD_ID__GET(void)
{
    return HAL_GET32(__TRIM_PROD_ID__ADDRESS());
}

/* ----------------------- TRIM.PROD_ID.XY_COORDINATE ----------------------- */

/**
<pre>
  TRIM.PROD_ID.XY_COORDINATE:

    Indicates die location on wafer

</pre> */

#define TRIM_PROD_ID__XY_COORDINATE__Pos                        16                                                                     /*!< Right-most bit position of xy_coordinate in TRIM.PROD_ID */
#define TRIM_PROD_ID__XY_COORDINATE__Msk                        (0x0000FFFFUL << TRIM_PROD_ID__XY_COORDINATE__Pos)                     /*!< Mask for xy_coordinate in TRIM.PROD_ID */
#define TRIM_PROD_ID__XY_COORDINATE__Shift(v)                   (((v) << TRIM_PROD_ID__XY_COORDINATE__Pos) & TRIM_PROD_ID__XY_COORDINATE__Msk) /*!< Shift value 'v' into xy_coordinate and mask 'v' to fit it into xy_coordinate field */

/** TRIM_PROD_ID__XY_COORDINATE__SET() sets PROD_ID.XY_COORDINATE to given value.
 *
 * When writing to PROD_ID.XY_COORDINATE, this is recommended to use.
 *
 * @param bf_value new value for PROD_ID.XY_COORDINATE
 */
__TRIM_INLINE void TRIM_PROD_ID__XY_COORDINATE__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_PROD_ID__GET();
    reg = (reg & ~TRIM_PROD_ID__XY_COORDINATE__Msk);
    reg = (reg | (TRIM_PROD_ID__XY_COORDINATE__Shift((uint32_t)bf_value)));
    TRIM_PROD_ID__SET(reg);
}

/** TRIM_PROD_ID__XY_COORDINATE__GET() gets PROD_ID.XY_COORDINATE's current value.
 *
 * When reading from PROD_ID.XY_COORDINATE, this is recommended to use.
 *
 * @return current value of PROD_ID.XY_COORDINATE
 */
__TRIM_INLINE uint32_t TRIM_PROD_ID__XY_COORDINATE__GET(void)
{
    uint32_t reg = TRIM_PROD_ID__GET();
    reg = (reg & TRIM_PROD_ID__XY_COORDINATE__Msk);
    reg = (reg >> TRIM_PROD_ID__XY_COORDINATE__Pos);
    return (uint32_t)reg;
}

/** TRIM_PROD_ID__XY_COORDINATE__MODIFY() modifies PROD_ID.XY_COORDINATE.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.PROD_ID.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.PROD_ID
 * @param bf_value new value for PROD_ID.XY_COORDINATE
 * @return new value of TRIM.PROD_ID
 */
__TRIM_INLINE uint32_t TRIM_PROD_ID__XY_COORDINATE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_PROD_ID__XY_COORDINATE__Msk);
    reg = (reg | (TRIM_PROD_ID__XY_COORDINATE__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_PROD_ID__XY_COORDINATE__EXTRACT() extracts PROD_ID.XY_COORDINATE.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.PROD_ID.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.PROD_ID
 * @return current value of PROD_ID.XY_COORDINATE
 */
__TRIM_INLINE uint32_t TRIM_PROD_ID__XY_COORDINATE__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_PROD_ID__XY_COORDINATE__Msk);
    reg = (reg >> TRIM_PROD_ID__XY_COORDINATE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ TRIM.PROD_ID.PRODUCT_ID ------------------------ */

/**
<pre>
  TRIM.PROD_ID.PRODUCT_ID:

    This register indicates the device part number and revision if applicable. Bits [15:8] indicate the device part number (different packages have different part numbers). Bits [7:0] indicate the device revision (e.g., A, B, C, etc.).
    <start table_with_header>
    product_id[15:0] "Part Number"
    0x0101 "XDPP1A1L00, Compact, Rev A"
    0x0201 "XDPP1A2N00, Flex, Rev A"
    0x0301 "XDPP1A3N00, Performance, Rev A"
    0x0102 "XDPP1B1L, Compact, Rev B"
    0x0202 "XDPP1B2N, Flex, Rev B"
    0x0302 "XDPP1B3N, Performance, Rev B"
    0x0103 "XDPP1C1L, Compact, Rev C"
    0x0203 "XDPP1C2N, Flex, Rev C"
    0x0303 "XDPP1C3N, Performance, Rev C"
    <end table>

</pre> */

#define TRIM_PROD_ID__PRODUCT_ID__Pos                           0                                                                      /*!< Right-most bit position of product_id in TRIM.PROD_ID */
#define TRIM_PROD_ID__PRODUCT_ID__Msk                           (0x0000FFFFUL << TRIM_PROD_ID__PRODUCT_ID__Pos)                        /*!< Mask for product_id in TRIM.PROD_ID */
#define TRIM_PROD_ID__PRODUCT_ID__Shift(v)                      (((v) << TRIM_PROD_ID__PRODUCT_ID__Pos) & TRIM_PROD_ID__PRODUCT_ID__Msk) /*!< Shift value 'v' into product_id and mask 'v' to fit it into product_id field */

/** TRIM_PROD_ID__PRODUCT_ID__SET() sets PROD_ID.PRODUCT_ID to given value.
 *
 * When writing to PROD_ID.PRODUCT_ID, this is recommended to use.
 *
 * @param bf_value new value for PROD_ID.PRODUCT_ID
 */
__TRIM_INLINE void TRIM_PROD_ID__PRODUCT_ID__SET(uint32_t bf_value)
{
    uint32_t reg = TRIM_PROD_ID__GET();
    reg = (reg & ~TRIM_PROD_ID__PRODUCT_ID__Msk);
    reg = (reg | (TRIM_PROD_ID__PRODUCT_ID__Shift((uint32_t)bf_value)));
    TRIM_PROD_ID__SET(reg);
}

/** TRIM_PROD_ID__PRODUCT_ID__GET() gets PROD_ID.PRODUCT_ID's current value.
 *
 * When reading from PROD_ID.PRODUCT_ID, this is recommended to use.
 *
 * @return current value of PROD_ID.PRODUCT_ID
 */
__TRIM_INLINE uint32_t TRIM_PROD_ID__PRODUCT_ID__GET(void)
{
    uint32_t reg = TRIM_PROD_ID__GET();
    reg = (reg & TRIM_PROD_ID__PRODUCT_ID__Msk);
    reg = (reg >> TRIM_PROD_ID__PRODUCT_ID__Pos);
    return (uint32_t)reg;
}

/** TRIM_PROD_ID__PRODUCT_ID__MODIFY() modifies PROD_ID.PRODUCT_ID.
 *
 * This is recommended to use when setting more than one bitfield of TRIM.PROD_ID.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of TRIM.PROD_ID
 * @param bf_value new value for PROD_ID.PRODUCT_ID
 * @return new value of TRIM.PROD_ID
 */
__TRIM_INLINE uint32_t TRIM_PROD_ID__PRODUCT_ID__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~TRIM_PROD_ID__PRODUCT_ID__Msk);
    reg = (reg | (TRIM_PROD_ID__PRODUCT_ID__Shift((uint32_t)bf_value)));
    return reg;
}

/** TRIM_PROD_ID__PRODUCT_ID__EXTRACT() extracts PROD_ID.PRODUCT_ID.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.PROD_ID.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.PROD_ID
 * @return current value of PROD_ID.PRODUCT_ID
 */
__TRIM_INLINE uint32_t TRIM_PROD_ID__PRODUCT_ID__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_PROD_ID__PRODUCT_ID__Msk);
    reg = (reg >> TRIM_PROD_ID__PRODUCT_ID__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        IC_VERSION member of TRIM_t                        */
/* -------------------------------------------------------------------------- */

/** __TRIM_IC_VERSION__ADDRESS returns the address of member IC_VERSION.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of IC_VERSION
 */
__TRIM_INLINE uint32_t* __TRIM_IC_VERSION__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__TRIM_BASE_PTR() + (uint32_t)(offsetof(TRIM_t, IC_VERSION)));
}

/** TRIM_IC_VERSION__GET() gets IC_VERSION's current value.
 *
 * When reading from IC_VERSION, this is mandatory to use.
 *
 * @return current value of IC_VERSION
 */
__TRIM_INLINE uint32_t TRIM_IC_VERSION__GET(void)
{
    return HAL_GET32(__TRIM_IC_VERSION__ADDRESS());
}

/* ----------------------- TRIM.IC_VERSION.IC_VERSION ----------------------- */

/**
<pre>
  TRIM.IC_VERSION.IC_VERSION:

    Read only, metal programmed indicator of silicon device ID and revision. Bits [15:4] indicate the product type with 0x010 assigned to Shasta. Bits [3:0] indicate the silicon revision (e.g., A11, B12, etc.). The first silicon revision, A11, will be assigned 0x0. The next silicon revision, whether it be A12, A21 or B11, will be assigned 0x1. Each addition silicon revision will increment this field by 1. If more than 16 revisions are required then a new assignment will be made in bits [15:4].
    Current assignments:
    <start table>
    0x0100 A11
    0x0101 A12
    0x0102 A21
    0x0103 A23
    <end table>

</pre> */

#define TRIM_IC_VERSION__IC_VERSION__Pos                        0                                                                      /*!< Right-most bit position of ic_version in TRIM.IC_VERSION */
#define TRIM_IC_VERSION__IC_VERSION__Msk                        (0x0000FFFFUL << TRIM_IC_VERSION__IC_VERSION__Pos)                     /*!< Mask for ic_version in TRIM.IC_VERSION */
#define TRIM_IC_VERSION__IC_VERSION__Shift(v)                   (((v) << TRIM_IC_VERSION__IC_VERSION__Pos) & TRIM_IC_VERSION__IC_VERSION__Msk) /*!< Shift value 'v' into ic_version and mask 'v' to fit it into ic_version field */

/** TRIM_IC_VERSION__IC_VERSION__GET() gets IC_VERSION.IC_VERSION's current value.
 *
 * When reading from IC_VERSION.IC_VERSION, this is recommended to use.
 *
 * @return current value of IC_VERSION.IC_VERSION
 */
__TRIM_INLINE uint32_t TRIM_IC_VERSION__IC_VERSION__GET(void)
{
    uint32_t reg = TRIM_IC_VERSION__GET();
    reg = (reg & TRIM_IC_VERSION__IC_VERSION__Msk);
    reg = (reg >> TRIM_IC_VERSION__IC_VERSION__Pos);
    return (uint32_t)reg;
}

/** TRIM_IC_VERSION__IC_VERSION__EXTRACT() extracts IC_VERSION.IC_VERSION.
 *
 * This is recommended to use when extracting more than one bitfield from TRIM.IC_VERSION.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of TRIM.IC_VERSION
 * @return current value of IC_VERSION.IC_VERSION
 */
__TRIM_INLINE uint32_t TRIM_IC_VERSION__IC_VERSION__EXTRACT(uint32_t reg)
{
    reg = (reg & TRIM_IC_VERSION__IC_VERSION__Msk);
    reg = (reg >> TRIM_IC_VERSION__IC_VERSION__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group trim block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_TRIM_H_ */
