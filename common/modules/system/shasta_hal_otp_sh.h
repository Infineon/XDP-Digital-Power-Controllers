/**
 * @file     shasta_hal_otp_sh.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_OTP_SH_H_
#define _SHASTA_HAL_OTP_SH_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup otp_sh
 * @{
 */

#if defined ( __CC_ARM )
#define __OTP_SH_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __OTP_SH_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __OTP_SH_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __OTP_SH_INLINE  static inline
#endif

/** register file of the otp_sh block.
 */
typedef struct _OTP_SH_s
{
    volatile        uint32_t        STAT                        ; /*!< (@0x00000000) OTP Status regsiter */
    volatile        uint32_t        CONF                        ; /*!< (@0x00000004) OTP Configuration register */
    volatile        uint32_t        INSTR                       ; /*!< (@0x00000008) Instruction Register */
    volatile        uint32_t        EXEC                        ; /*!< (@0x0000000C) Start Command Execution */
    volatile        uint32_t        DATAW0                      ; /*!< (@0x00000010) Write Data Register 0 */
    volatile        uint32_t        DATAW1                      ; /*!< (@0x00000014) Write Data Register 1 */
    volatile        uint32_t        DATAW2                      ; /*!< (@0x00000018) Write Data Register 2 */
    volatile        uint32_t        DATAW3                      ; /*!< (@0x0000001C) Write Data Register 3 */
    volatile        uint32_t        READ_MRAB                   ; /*!< (@0x00000020) MRA-MRB config register */
    volatile        uint32_t        READ_MR                     ; /*!< (@0x00000024) MR config register */
    volatile        uint32_t        READ1_MRAB                  ; /*!< (@0x00000028) MRA-MRB (1) config register */
    volatile        uint32_t        READ1_MR                    ; /*!< (@0x0000002C) MR (1) config register */
    volatile        uint32_t        READ2_MRAB                  ; /*!< (@0x00000030) MRA-MRB (2) config register */
    volatile        uint32_t        READ2_MR                    ; /*!< (@0x00000034) MR (2) config register */
    volatile        uint32_t        OPT_MRAB                    ; /*!< (@0x00000038) MRA-MRB status report */
    volatile        uint32_t        OPT_MR                      ; /*!< (@0x0000003C) MR status report */
    volatile        uint32_t        OTP_Q0                      ; /*!< (@0x00000040) Read Data Register 0 */
    volatile        uint32_t        OTP_Q1                      ; /*!< (@0x00000044) Read Data Register 1 */
    volatile        uint32_t        OTP_Q2                      ; /*!< (@0x00000048) Read Data Register 2 */
    volatile        uint32_t        OTP_Q3                      ; /*!< (@0x0000004C) Read Data Register 3 */
    volatile        uint32_t        INT_RAW                     ; /*!< (@0x00000050) Interrupt Raw register. */
    volatile        uint32_t        INT_MASK                    ; /*!< (@0x00000054) Interrupt Mask register. */
    volatile        uint32_t        INT_ACTIVE                  ; /*!< (@0x00000058) Interrupt Active Register */
    volatile        uint32_t        INT_ACTIVE_CLR              ; /*!< (@0x0000005C) Interrupt Active Clear Register */
    volatile        uint32_t        OTP_PWRUP_C                 ; /*!< (@0x00000060) Powerup configuration register */
    volatile        uint32_t        OTP_PROG_C                  ; /*!< (@0x00000064) Programming configuration register */
    volatile        uint32_t        OTP_CP_C                    ; /*!< (@0x00000068) Charge pump configuration register */
    volatile        uint32_t        OTP_READ_C                  ; /*!< (@0x0000006C) Read configuration register */
    volatile        uint32_t        ERR_RPT                     ; /*!< (@0x00000070) Error Report Register */
    volatile        uint32_t        ERR_RPT_CLR                 ; /*!< (@0x00000074) Error Report Register */
    volatile        uint32_t        OTP_BIST_C                  ; /*!< (@0x00000078) Bist status and control register */
} OTP_SH_t;


#define OTP_SH_BASE (0x50020000u)                                                          /*!< otp_sh base address */

/** __OTP_SH_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_BASE_PTR(void)
{
    return (uint32_t*)(OTP_SH_BASE);
}


/* -------------------------------------------------------------------------- */
/*                          STAT member of OTP_SH_t                          */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_STAT__ADDRESS returns the address of member STAT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of STAT
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_STAT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, STAT)));
}

/** OTP_SH_STAT__GET() gets STAT's current value.
 *
 * When reading from STAT, this is mandatory to use.
 *
 * @return current value of STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__GET(void)
{
    return HAL_GET32(__OTP_SH_STAT__ADDRESS());
}

/* -------------------------- OTP_SH.STAT.SOAK_CNT -------------------------- */


#define OTP_SH_STAT__SOAK_CNT__Pos                              24                                                                     /*!< Right-most bit position of SOAK_CNT in OTP_SH.STAT */
#define OTP_SH_STAT__SOAK_CNT__Msk                              (0x000000FFUL << OTP_SH_STAT__SOAK_CNT__Pos)                           /*!< Mask for SOAK_CNT in OTP_SH.STAT */
#define OTP_SH_STAT__SOAK_CNT__Shift(v)                         (((v) << OTP_SH_STAT__SOAK_CNT__Pos) & OTP_SH_STAT__SOAK_CNT__Msk)     /*!< Shift value 'v' into SOAK_CNT and mask 'v' to fit it into SOAK_CNT field */

/** OTP_SH_STAT__SOAK_CNT__GET() gets STAT.SOAK_CNT's current value.
 *
 * When reading from STAT.SOAK_CNT, this is recommended to use.
 *
 * @return current value of STAT.SOAK_CNT
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__SOAK_CNT__GET(void)
{
    uint32_t reg = OTP_SH_STAT__GET();
    reg = (reg & OTP_SH_STAT__SOAK_CNT__Msk);
    reg = (reg >> OTP_SH_STAT__SOAK_CNT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_STAT__SOAK_CNT__EXTRACT() extracts STAT.SOAK_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.STAT
 * @return current value of STAT.SOAK_CNT
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__SOAK_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_STAT__SOAK_CNT__Msk);
    reg = (reg >> OTP_SH_STAT__SOAK_CNT__Pos);
    return (uint32_t)reg;
}

/* ------------------------- OTP_SH.STAT.SOAK_FAIL ------------------------- */


#define OTP_SH_STAT__SOAK_FAIL__Pos                             18                                                                     /*!< Right-most bit position of SOAK_FAIL in OTP_SH.STAT */
#define OTP_SH_STAT__SOAK_FAIL__Msk                             (0x00000001UL << OTP_SH_STAT__SOAK_FAIL__Pos)                          /*!< Mask for SOAK_FAIL in OTP_SH.STAT */
#define OTP_SH_STAT__SOAK_FAIL__Shift(v)                        (((v) << OTP_SH_STAT__SOAK_FAIL__Pos) & OTP_SH_STAT__SOAK_FAIL__Msk)   /*!< Shift value 'v' into SOAK_FAIL and mask 'v' to fit it into SOAK_FAIL field */

/** OTP_SH_STAT__SOAK_FAIL__GET() gets STAT.SOAK_FAIL's current value.
 *
 * When reading from STAT.SOAK_FAIL, this is recommended to use.
 *
 * @return current value of STAT.SOAK_FAIL
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__SOAK_FAIL__GET(void)
{
    uint32_t reg = OTP_SH_STAT__GET();
    reg = (reg & OTP_SH_STAT__SOAK_FAIL__Msk);
    reg = (reg >> OTP_SH_STAT__SOAK_FAIL__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_STAT__SOAK_FAIL__EXTRACT() extracts STAT.SOAK_FAIL.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.STAT
 * @return current value of STAT.SOAK_FAIL
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__SOAK_FAIL__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_STAT__SOAK_FAIL__Msk);
    reg = (reg >> OTP_SH_STAT__SOAK_FAIL__Pos);
    return (uint32_t)reg;
}

/* --------------------------- OTP_SH.STAT.RD2_FL --------------------------- */


#define OTP_SH_STAT__RD2_FL__Pos                                17                                                                     /*!< Right-most bit position of RD2_FL in OTP_SH.STAT */
#define OTP_SH_STAT__RD2_FL__Msk                                (0x00000001UL << OTP_SH_STAT__RD2_FL__Pos)                             /*!< Mask for RD2_FL in OTP_SH.STAT */
#define OTP_SH_STAT__RD2_FL__Shift(v)                           (((v) << OTP_SH_STAT__RD2_FL__Pos) & OTP_SH_STAT__RD2_FL__Msk)         /*!< Shift value 'v' into RD2_FL and mask 'v' to fit it into RD2_FL field */

/** OTP_SH_STAT__RD2_FL__GET() gets STAT.RD2_FL's current value.
 *
 * When reading from STAT.RD2_FL, this is recommended to use.
 *
 * @return current value of STAT.RD2_FL
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__RD2_FL__GET(void)
{
    uint32_t reg = OTP_SH_STAT__GET();
    reg = (reg & OTP_SH_STAT__RD2_FL__Msk);
    reg = (reg >> OTP_SH_STAT__RD2_FL__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_STAT__RD2_FL__EXTRACT() extracts STAT.RD2_FL.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.STAT
 * @return current value of STAT.RD2_FL
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__RD2_FL__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_STAT__RD2_FL__Msk);
    reg = (reg >> OTP_SH_STAT__RD2_FL__Pos);
    return (uint32_t)reg;
}

/* --------------------------- OTP_SH.STAT.RD1_FL --------------------------- */


#define OTP_SH_STAT__RD1_FL__Pos                                16                                                                     /*!< Right-most bit position of RD1_FL in OTP_SH.STAT */
#define OTP_SH_STAT__RD1_FL__Msk                                (0x00000001UL << OTP_SH_STAT__RD1_FL__Pos)                             /*!< Mask for RD1_FL in OTP_SH.STAT */
#define OTP_SH_STAT__RD1_FL__Shift(v)                           (((v) << OTP_SH_STAT__RD1_FL__Pos) & OTP_SH_STAT__RD1_FL__Msk)         /*!< Shift value 'v' into RD1_FL and mask 'v' to fit it into RD1_FL field */

/** OTP_SH_STAT__RD1_FL__GET() gets STAT.RD1_FL's current value.
 *
 * When reading from STAT.RD1_FL, this is recommended to use.
 *
 * @return current value of STAT.RD1_FL
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__RD1_FL__GET(void)
{
    uint32_t reg = OTP_SH_STAT__GET();
    reg = (reg & OTP_SH_STAT__RD1_FL__Msk);
    reg = (reg >> OTP_SH_STAT__RD1_FL__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_STAT__RD1_FL__EXTRACT() extracts STAT.RD1_FL.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.STAT
 * @return current value of STAT.RD1_FL
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__RD1_FL__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_STAT__RD1_FL__Msk);
    reg = (reg >> OTP_SH_STAT__RD1_FL__Pos);
    return (uint32_t)reg;
}

/* ------------------------- OTP_SH.STAT.PRECH_STAT ------------------------- */


#define OTP_SH_STAT__PRECH_STAT__Pos                            9                                                                      /*!< Right-most bit position of PRECH_STAT in OTP_SH.STAT */
#define OTP_SH_STAT__PRECH_STAT__Msk                            (0x00000001UL << OTP_SH_STAT__PRECH_STAT__Pos)                         /*!< Mask for PRECH_STAT in OTP_SH.STAT */
#define OTP_SH_STAT__PRECH_STAT__Shift(v)                       (((v) << OTP_SH_STAT__PRECH_STAT__Pos) & OTP_SH_STAT__PRECH_STAT__Msk) /*!< Shift value 'v' into PRECH_STAT and mask 'v' to fit it into PRECH_STAT field */

/** OTP_SH_STAT__PRECH_STAT__GET() gets STAT.PRECH_STAT's current value.
 *
 * When reading from STAT.PRECH_STAT, this is recommended to use.
 *
 * @return current value of STAT.PRECH_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__PRECH_STAT__GET(void)
{
    uint32_t reg = OTP_SH_STAT__GET();
    reg = (reg & OTP_SH_STAT__PRECH_STAT__Msk);
    reg = (reg >> OTP_SH_STAT__PRECH_STAT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_STAT__PRECH_STAT__EXTRACT() extracts STAT.PRECH_STAT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.STAT
 * @return current value of STAT.PRECH_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__PRECH_STAT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_STAT__PRECH_STAT__Msk);
    reg = (reg >> OTP_SH_STAT__PRECH_STAT__Pos);
    return (uint32_t)reg;
}

/* -------------------------- OTP_SH.STAT.CMP_STAT -------------------------- */


#define OTP_SH_STAT__CMP_STAT__Pos                              8                                                                      /*!< Right-most bit position of CMP_STAT in OTP_SH.STAT */
#define OTP_SH_STAT__CMP_STAT__Msk                              (0x00000001UL << OTP_SH_STAT__CMP_STAT__Pos)                           /*!< Mask for CMP_STAT in OTP_SH.STAT */
#define OTP_SH_STAT__CMP_STAT__Shift(v)                         (((v) << OTP_SH_STAT__CMP_STAT__Pos) & OTP_SH_STAT__CMP_STAT__Msk)     /*!< Shift value 'v' into CMP_STAT and mask 'v' to fit it into CMP_STAT field */

/** OTP_SH_STAT__CMP_STAT__GET() gets STAT.CMP_STAT's current value.
 *
 * When reading from STAT.CMP_STAT, this is recommended to use.
 *
 * @return current value of STAT.CMP_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__CMP_STAT__GET(void)
{
    uint32_t reg = OTP_SH_STAT__GET();
    reg = (reg & OTP_SH_STAT__CMP_STAT__Msk);
    reg = (reg >> OTP_SH_STAT__CMP_STAT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_STAT__CMP_STAT__EXTRACT() extracts STAT.CMP_STAT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.STAT
 * @return current value of STAT.CMP_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__CMP_STAT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_STAT__CMP_STAT__Msk);
    reg = (reg >> OTP_SH_STAT__CMP_STAT__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- OTP_SH.STAT.BUSY ---------------------------- */


#define OTP_SH_STAT__BUSY__Pos                                  4                                                                      /*!< Right-most bit position of BUSY in OTP_SH.STAT */
#define OTP_SH_STAT__BUSY__Msk                                  (0x00000001UL << OTP_SH_STAT__BUSY__Pos)                               /*!< Mask for BUSY in OTP_SH.STAT */
#define OTP_SH_STAT__BUSY__Shift(v)                             (((v) << OTP_SH_STAT__BUSY__Pos) & OTP_SH_STAT__BUSY__Msk)             /*!< Shift value 'v' into BUSY and mask 'v' to fit it into BUSY field */

/** OTP_SH_STAT__BUSY__GET() gets STAT.BUSY's current value.
 *
 * When reading from STAT.BUSY, this is recommended to use.
 *
 * @return current value of STAT.BUSY
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__BUSY__GET(void)
{
    uint32_t reg = OTP_SH_STAT__GET();
    reg = (reg & OTP_SH_STAT__BUSY__Msk);
    reg = (reg >> OTP_SH_STAT__BUSY__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_STAT__BUSY__EXTRACT() extracts STAT.BUSY.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.STAT
 * @return current value of STAT.BUSY
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__BUSY__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_STAT__BUSY__Msk);
    reg = (reg >> OTP_SH_STAT__BUSY__Pos);
    return (uint32_t)reg;
}

/* -------------------------- OTP_SH.STAT.PWR_STAT -------------------------- */


#define OTP_SH_STAT__PWR_STAT__Pos                              0                                                                      /*!< Right-most bit position of PWR_STAT in OTP_SH.STAT */
#define OTP_SH_STAT__PWR_STAT__Msk                              (0x00000001UL << OTP_SH_STAT__PWR_STAT__Pos)                           /*!< Mask for PWR_STAT in OTP_SH.STAT */
#define OTP_SH_STAT__PWR_STAT__Shift(v)                         (((v) << OTP_SH_STAT__PWR_STAT__Pos) & OTP_SH_STAT__PWR_STAT__Msk)     /*!< Shift value 'v' into PWR_STAT and mask 'v' to fit it into PWR_STAT field */

/** OTP_SH_STAT__PWR_STAT__GET() gets STAT.PWR_STAT's current value.
 *
 * When reading from STAT.PWR_STAT, this is recommended to use.
 *
 * @return current value of STAT.PWR_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__PWR_STAT__GET(void)
{
    uint32_t reg = OTP_SH_STAT__GET();
    reg = (reg & OTP_SH_STAT__PWR_STAT__Msk);
    reg = (reg >> OTP_SH_STAT__PWR_STAT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_STAT__PWR_STAT__EXTRACT() extracts STAT.PWR_STAT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.STAT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.STAT
 * @return current value of STAT.PWR_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_STAT__PWR_STAT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_STAT__PWR_STAT__Msk);
    reg = (reg >> OTP_SH_STAT__PWR_STAT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          CONF member of OTP_SH_t                          */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_CONF__ADDRESS returns the address of member CONF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CONF
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_CONF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, CONF)));
}

/** OTP_SH_CONF__SET() sets CONF to given value.
 *
 * When writing to CONF, this is mandatory to use.
 *
 * @param value new value for CONF
 */
__OTP_SH_INLINE void OTP_SH_CONF__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_CONF__ADDRESS(), value);
}

/** OTP_SH_CONF__GET() gets CONF's current value.
 *
 * When reading from CONF, this is mandatory to use.
 *
 * @return current value of CONF
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__GET(void)
{
    return HAL_GET32(__OTP_SH_CONF__ADDRESS());
}

/* --------------------------- OTP_SH.CONF.RED_EN --------------------------- */

/**
<pre>
  OTP_SH.CONF.RED_EN:

    Enable OTP redundancy

</pre> */

#define OTP_SH_CONF__RED_EN__Pos                                11                                                                     /*!< Right-most bit position of RED_EN in OTP_SH.CONF */
#define OTP_SH_CONF__RED_EN__Msk                                (0x00000001UL << OTP_SH_CONF__RED_EN__Pos)                             /*!< Mask for RED_EN in OTP_SH.CONF */
#define OTP_SH_CONF__RED_EN__Shift(v)                           (((v) << OTP_SH_CONF__RED_EN__Pos) & OTP_SH_CONF__RED_EN__Msk)         /*!< Shift value 'v' into RED_EN and mask 'v' to fit it into RED_EN field */

/** OTP_SH_CONF__RED_EN__SET() sets CONF.RED_EN to given value.
 *
 * When writing to CONF.RED_EN, this is recommended to use.
 *
 * @param bf_value new value for CONF.RED_EN
 */
__OTP_SH_INLINE void OTP_SH_CONF__RED_EN__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & ~OTP_SH_CONF__RED_EN__Msk);
    reg = (reg | (OTP_SH_CONF__RED_EN__Shift((uint32_t)bf_value)));
    OTP_SH_CONF__SET(reg);
}

/** OTP_SH_CONF__RED_EN__GET() gets CONF.RED_EN's current value.
 *
 * When reading from CONF.RED_EN, this is recommended to use.
 *
 * @return current value of CONF.RED_EN
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__RED_EN__GET(void)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & OTP_SH_CONF__RED_EN__Msk);
    reg = (reg >> OTP_SH_CONF__RED_EN__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_CONF__RED_EN__MODIFY() modifies CONF.RED_EN.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.CONF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.CONF
 * @param bf_value new value for CONF.RED_EN
 * @return new value of OTP_SH.CONF
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__RED_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_CONF__RED_EN__Msk);
    reg = (reg | (OTP_SH_CONF__RED_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_CONF__RED_EN__EXTRACT() extracts CONF.RED_EN.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.CONF
 * @return current value of CONF.RED_EN
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__RED_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_CONF__RED_EN__Msk);
    reg = (reg >> OTP_SH_CONF__RED_EN__Pos);
    return (uint32_t)reg;
}

/* --------------------------- OTP_SH.CONF.DIS_PF --------------------------- */


#define OTP_SH_CONF__DIS_PF__Pos                                10                                                                     /*!< Right-most bit position of DIS_PF in OTP_SH.CONF */
#define OTP_SH_CONF__DIS_PF__Msk                                (0x00000001UL << OTP_SH_CONF__DIS_PF__Pos)                             /*!< Mask for DIS_PF in OTP_SH.CONF */
#define OTP_SH_CONF__DIS_PF__Shift(v)                           (((v) << OTP_SH_CONF__DIS_PF__Pos) & OTP_SH_CONF__DIS_PF__Msk)         /*!< Shift value 'v' into DIS_PF and mask 'v' to fit it into DIS_PF field */

/** OTP_SH_CONF__DIS_PF__SET() sets CONF.DIS_PF to given value.
 *
 * When writing to CONF.DIS_PF, this is recommended to use.
 *
 * @param bf_value new value for CONF.DIS_PF
 */
__OTP_SH_INLINE void OTP_SH_CONF__DIS_PF__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & ~OTP_SH_CONF__DIS_PF__Msk);
    reg = (reg | (OTP_SH_CONF__DIS_PF__Shift((uint32_t)bf_value)));
    OTP_SH_CONF__SET(reg);
}

/** OTP_SH_CONF__DIS_PF__GET() gets CONF.DIS_PF's current value.
 *
 * When reading from CONF.DIS_PF, this is recommended to use.
 *
 * @return current value of CONF.DIS_PF
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__DIS_PF__GET(void)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & OTP_SH_CONF__DIS_PF__Msk);
    reg = (reg >> OTP_SH_CONF__DIS_PF__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_CONF__DIS_PF__MODIFY() modifies CONF.DIS_PF.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.CONF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.CONF
 * @param bf_value new value for CONF.DIS_PF
 * @return new value of OTP_SH.CONF
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__DIS_PF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_CONF__DIS_PF__Msk);
    reg = (reg | (OTP_SH_CONF__DIS_PF__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_CONF__DIS_PF__EXTRACT() extracts CONF.DIS_PF.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.CONF
 * @return current value of CONF.DIS_PF
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__DIS_PF__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_CONF__DIS_PF__Msk);
    reg = (reg >> OTP_SH_CONF__DIS_PF__Pos);
    return (uint32_t)reg;
}

/* --------------------------- OTP_SH.CONF.FL_ODD --------------------------- */


#define OTP_SH_CONF__FL_ODD__Pos                                9                                                                      /*!< Right-most bit position of FL_ODD in OTP_SH.CONF */
#define OTP_SH_CONF__FL_ODD__Msk                                (0x00000001UL << OTP_SH_CONF__FL_ODD__Pos)                             /*!< Mask for FL_ODD in OTP_SH.CONF */
#define OTP_SH_CONF__FL_ODD__Shift(v)                           (((v) << OTP_SH_CONF__FL_ODD__Pos) & OTP_SH_CONF__FL_ODD__Msk)         /*!< Shift value 'v' into FL_ODD and mask 'v' to fit it into FL_ODD field */

/** OTP_SH_CONF__FL_ODD__SET() sets CONF.FL_ODD to given value.
 *
 * When writing to CONF.FL_ODD, this is recommended to use.
 *
 * @param bf_value new value for CONF.FL_ODD
 */
__OTP_SH_INLINE void OTP_SH_CONF__FL_ODD__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & ~OTP_SH_CONF__FL_ODD__Msk);
    reg = (reg | (OTP_SH_CONF__FL_ODD__Shift((uint32_t)bf_value)));
    OTP_SH_CONF__SET(reg);
}

/** OTP_SH_CONF__FL_ODD__GET() gets CONF.FL_ODD's current value.
 *
 * When reading from CONF.FL_ODD, this is recommended to use.
 *
 * @return current value of CONF.FL_ODD
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__FL_ODD__GET(void)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & OTP_SH_CONF__FL_ODD__Msk);
    reg = (reg >> OTP_SH_CONF__FL_ODD__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_CONF__FL_ODD__MODIFY() modifies CONF.FL_ODD.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.CONF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.CONF
 * @param bf_value new value for CONF.FL_ODD
 * @return new value of OTP_SH.CONF
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__FL_ODD__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_CONF__FL_ODD__Msk);
    reg = (reg | (OTP_SH_CONF__FL_ODD__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_CONF__FL_ODD__EXTRACT() extracts CONF.FL_ODD.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.CONF
 * @return current value of CONF.FL_ODD
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__FL_ODD__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_CONF__FL_ODD__Msk);
    reg = (reg >> OTP_SH_CONF__FL_ODD__Pos);
    return (uint32_t)reg;
}

/* -------------------------- OTP_SH.CONF.FL_EVEN -------------------------- */


#define OTP_SH_CONF__FL_EVEN__Pos                               8                                                                      /*!< Right-most bit position of FL_EVEN in OTP_SH.CONF */
#define OTP_SH_CONF__FL_EVEN__Msk                               (0x00000001UL << OTP_SH_CONF__FL_EVEN__Pos)                            /*!< Mask for FL_EVEN in OTP_SH.CONF */
#define OTP_SH_CONF__FL_EVEN__Shift(v)                          (((v) << OTP_SH_CONF__FL_EVEN__Pos) & OTP_SH_CONF__FL_EVEN__Msk)       /*!< Shift value 'v' into FL_EVEN and mask 'v' to fit it into FL_EVEN field */

/** OTP_SH_CONF__FL_EVEN__SET() sets CONF.FL_EVEN to given value.
 *
 * When writing to CONF.FL_EVEN, this is recommended to use.
 *
 * @param bf_value new value for CONF.FL_EVEN
 */
__OTP_SH_INLINE void OTP_SH_CONF__FL_EVEN__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & ~OTP_SH_CONF__FL_EVEN__Msk);
    reg = (reg | (OTP_SH_CONF__FL_EVEN__Shift((uint32_t)bf_value)));
    OTP_SH_CONF__SET(reg);
}

/** OTP_SH_CONF__FL_EVEN__GET() gets CONF.FL_EVEN's current value.
 *
 * When reading from CONF.FL_EVEN, this is recommended to use.
 *
 * @return current value of CONF.FL_EVEN
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__FL_EVEN__GET(void)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & OTP_SH_CONF__FL_EVEN__Msk);
    reg = (reg >> OTP_SH_CONF__FL_EVEN__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_CONF__FL_EVEN__MODIFY() modifies CONF.FL_EVEN.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.CONF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.CONF
 * @param bf_value new value for CONF.FL_EVEN
 * @return new value of OTP_SH.CONF
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__FL_EVEN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_CONF__FL_EVEN__Msk);
    reg = (reg | (OTP_SH_CONF__FL_EVEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_CONF__FL_EVEN__EXTRACT() extracts CONF.FL_EVEN.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.CONF
 * @return current value of CONF.FL_EVEN
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__FL_EVEN__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_CONF__FL_EVEN__Msk);
    reg = (reg >> OTP_SH_CONF__FL_EVEN__Pos);
    return (uint32_t)reg;
}

/* ----------------------- OTP_SH.CONF.AHB_CLK_RATIO ----------------------- */


#define OTP_SH_CONF__AHB_CLK_RATIO__Pos                         4                                                                      /*!< Right-most bit position of AHB_CLK_RATIO in OTP_SH.CONF */
#define OTP_SH_CONF__AHB_CLK_RATIO__Msk                         (0x00000003UL << OTP_SH_CONF__AHB_CLK_RATIO__Pos)                      /*!< Mask for AHB_CLK_RATIO in OTP_SH.CONF */
#define OTP_SH_CONF__AHB_CLK_RATIO__Shift(v)                    (((v) << OTP_SH_CONF__AHB_CLK_RATIO__Pos) & OTP_SH_CONF__AHB_CLK_RATIO__Msk) /*!< Shift value 'v' into AHB_CLK_RATIO and mask 'v' to fit it into AHB_CLK_RATIO field */

/** OTP_SH_CONF__AHB_CLK_RATIO__SET() sets CONF.AHB_CLK_RATIO to given value.
 *
 * When writing to CONF.AHB_CLK_RATIO, this is recommended to use.
 *
 * @param bf_value new value for CONF.AHB_CLK_RATIO
 */
__OTP_SH_INLINE void OTP_SH_CONF__AHB_CLK_RATIO__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & ~OTP_SH_CONF__AHB_CLK_RATIO__Msk);
    reg = (reg | (OTP_SH_CONF__AHB_CLK_RATIO__Shift((uint32_t)bf_value)));
    OTP_SH_CONF__SET(reg);
}

/** OTP_SH_CONF__AHB_CLK_RATIO__GET() gets CONF.AHB_CLK_RATIO's current value.
 *
 * When reading from CONF.AHB_CLK_RATIO, this is recommended to use.
 *
 * @return current value of CONF.AHB_CLK_RATIO
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__AHB_CLK_RATIO__GET(void)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & OTP_SH_CONF__AHB_CLK_RATIO__Msk);
    reg = (reg >> OTP_SH_CONF__AHB_CLK_RATIO__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_CONF__AHB_CLK_RATIO__MODIFY() modifies CONF.AHB_CLK_RATIO.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.CONF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.CONF
 * @param bf_value new value for CONF.AHB_CLK_RATIO
 * @return new value of OTP_SH.CONF
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__AHB_CLK_RATIO__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_CONF__AHB_CLK_RATIO__Msk);
    reg = (reg | (OTP_SH_CONF__AHB_CLK_RATIO__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_CONF__AHB_CLK_RATIO__EXTRACT() extracts CONF.AHB_CLK_RATIO.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.CONF
 * @return current value of CONF.AHB_CLK_RATIO
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__AHB_CLK_RATIO__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_CONF__AHB_CLK_RATIO__Msk);
    reg = (reg >> OTP_SH_CONF__AHB_CLK_RATIO__Pos);
    return (uint32_t)reg;
}

/* --------------------------- OTP_SH.CONF.PWRUP --------------------------- */


#define OTP_SH_CONF__PWRUP__Pos                                 0                                                                      /*!< Right-most bit position of PWRUP in OTP_SH.CONF */
#define OTP_SH_CONF__PWRUP__Msk                                 (0x00000001UL << OTP_SH_CONF__PWRUP__Pos)                              /*!< Mask for PWRUP in OTP_SH.CONF */
#define OTP_SH_CONF__PWRUP__Shift(v)                            (((v) << OTP_SH_CONF__PWRUP__Pos) & OTP_SH_CONF__PWRUP__Msk)           /*!< Shift value 'v' into PWRUP and mask 'v' to fit it into PWRUP field */

/** OTP_SH_CONF__PWRUP__SET() sets CONF.PWRUP to given value.
 *
 * When writing to CONF.PWRUP, this is recommended to use.
 *
 * @param bf_value new value for CONF.PWRUP
 */
__OTP_SH_INLINE void OTP_SH_CONF__PWRUP__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & ~OTP_SH_CONF__PWRUP__Msk);
    reg = (reg | (OTP_SH_CONF__PWRUP__Shift((uint32_t)bf_value)));
    OTP_SH_CONF__SET(reg);
}

/** OTP_SH_CONF__PWRUP__GET() gets CONF.PWRUP's current value.
 *
 * When reading from CONF.PWRUP, this is recommended to use.
 *
 * @return current value of CONF.PWRUP
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__PWRUP__GET(void)
{
    uint32_t reg = OTP_SH_CONF__GET();
    reg = (reg & OTP_SH_CONF__PWRUP__Msk);
    reg = (reg >> OTP_SH_CONF__PWRUP__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_CONF__PWRUP__MODIFY() modifies CONF.PWRUP.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.CONF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.CONF
 * @param bf_value new value for CONF.PWRUP
 * @return new value of OTP_SH.CONF
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__PWRUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_CONF__PWRUP__Msk);
    reg = (reg | (OTP_SH_CONF__PWRUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_CONF__PWRUP__EXTRACT() extracts CONF.PWRUP.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.CONF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.CONF
 * @return current value of CONF.PWRUP
 */
__OTP_SH_INLINE uint32_t OTP_SH_CONF__PWRUP__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_CONF__PWRUP__Msk);
    reg = (reg >> OTP_SH_CONF__PWRUP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          INSTR member of OTP_SH_t                          */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_INSTR__ADDRESS returns the address of member INSTR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of INSTR
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_INSTR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, INSTR)));
}

/** OTP_SH_INSTR__SET() sets INSTR to given value.
 *
 * When writing to INSTR, this is mandatory to use.
 *
 * @param value new value for INSTR
 */
__OTP_SH_INLINE void OTP_SH_INSTR__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_INSTR__ADDRESS(), value);
}

/** OTP_SH_INSTR__GET() gets INSTR's current value.
 *
 * When reading from INSTR, this is mandatory to use.
 *
 * @return current value of INSTR
 */
__OTP_SH_INLINE uint32_t OTP_SH_INSTR__GET(void)
{
    return HAL_GET32(__OTP_SH_INSTR__ADDRESS());
}

/* ------------------------- OTP_SH.INSTR.OTP_ADDR ------------------------- */


#define OTP_SH_INSTR__OTP_ADDR__Pos                             16                                                                     /*!< Right-most bit position of OTP_ADDR in OTP_SH.INSTR */
#define OTP_SH_INSTR__OTP_ADDR__Msk                             (0x00001FFFUL << OTP_SH_INSTR__OTP_ADDR__Pos)                          /*!< Mask for OTP_ADDR in OTP_SH.INSTR */
#define OTP_SH_INSTR__OTP_ADDR__Shift(v)                        (((v) << OTP_SH_INSTR__OTP_ADDR__Pos) & OTP_SH_INSTR__OTP_ADDR__Msk)   /*!< Shift value 'v' into OTP_ADDR and mask 'v' to fit it into OTP_ADDR field */

/** OTP_SH_INSTR__OTP_ADDR__SET() sets INSTR.OTP_ADDR to given value.
 *
 * When writing to INSTR.OTP_ADDR, this is recommended to use.
 *
 * @param bf_value new value for INSTR.OTP_ADDR
 */
__OTP_SH_INLINE void OTP_SH_INSTR__OTP_ADDR__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_INSTR__GET();
    reg = (reg & ~OTP_SH_INSTR__OTP_ADDR__Msk);
    reg = (reg | (OTP_SH_INSTR__OTP_ADDR__Shift((uint32_t)bf_value)));
    OTP_SH_INSTR__SET(reg);
}

/** OTP_SH_INSTR__OTP_ADDR__GET() gets INSTR.OTP_ADDR's current value.
 *
 * When reading from INSTR.OTP_ADDR, this is recommended to use.
 *
 * @return current value of INSTR.OTP_ADDR
 */
__OTP_SH_INLINE uint32_t OTP_SH_INSTR__OTP_ADDR__GET(void)
{
    uint32_t reg = OTP_SH_INSTR__GET();
    reg = (reg & OTP_SH_INSTR__OTP_ADDR__Msk);
    reg = (reg >> OTP_SH_INSTR__OTP_ADDR__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INSTR__OTP_ADDR__MODIFY() modifies INSTR.OTP_ADDR.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.INSTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.INSTR
 * @param bf_value new value for INSTR.OTP_ADDR
 * @return new value of OTP_SH.INSTR
 */
__OTP_SH_INLINE uint32_t OTP_SH_INSTR__OTP_ADDR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_INSTR__OTP_ADDR__Msk);
    reg = (reg | (OTP_SH_INSTR__OTP_ADDR__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_INSTR__OTP_ADDR__EXTRACT() extracts INSTR.OTP_ADDR.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INSTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INSTR
 * @return current value of INSTR.OTP_ADDR
 */
__OTP_SH_INLINE uint32_t OTP_SH_INSTR__OTP_ADDR__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INSTR__OTP_ADDR__Msk);
    reg = (reg >> OTP_SH_INSTR__OTP_ADDR__Pos);
    return (uint32_t)reg;
}

/* ------------------------- OTP_SH.INSTR.OTP_INSTR ------------------------- */


/*lint -parent(uint32_t, otp_sh_instr__otp_instr_t) -strong(AJX)*/
typedef enum otp_sh_instr__otp_instr_e                                                                                                 /*!<  */
{
    otp_sh_instr__otp_instr_none = 0x0u,                                                                                               /*!<  */
    otp_sh_instr__otp_instr_prog_and_verify = 0x1u,                                                                                    /*!< OTP programming command */
    otp_sh_instr__otp_instr_read = 0x2u,                                                                                               /*!< OTP read command */
    otp_sh_instr__otp_instr_prog = 0x3u,                                                                                               /*!< OTP low level programming sequence (only for debug) */
    otp_sh_instr__otp_instr_write_otp_data = 0x4u,                                                                                     /*!< Write OTP data register (data from DATAW0-4 registers) */
    otp_sh_instr__otp_instr_setmode_mra = 0x5u,                                                                                        /*!< Setmode MRA (data from READ_MRAB register) */
    otp_sh_instr__otp_instr_cmp = 0x6u,                                                                                                /*!< OTP low level compare sequence (only for debug) */
    otp_sh_instr__otp_instr_pch = 0x7u,                                                                                                /*!< OTP low level precharge sequence (only for debug) */
    otp_sh_instr__otp_instr_bist_reset = 0x8u,                                                                                         /*!< OTP BIST reset (only for test) */
    otp_sh_instr__otp_instr_bist_stress_test = 0x9u,                                                                                   /*!< OTP BIST stress test start (only for test) */
    otp_sh_instr__otp_instr_bist_clean_array_test = 0xau,                                                                              /*!< OTP Clean Array test (only for test) */
    otp_sh_instr__otp_instr_setmode_mrb = 0xbu,                                                                                        /*!< Setmode MRB (data from READ_MRAB register) */
    otp_sh_instr__otp_instr_setmode_mr = 0xcu                                                                                          /*!< Setmode MR (data from READ_MR register) */
} otp_sh_instr__otp_instr_t;

#define OTP_SH_INSTR__OTP_INSTR__Pos                            0                                                                      /*!< Right-most bit position of OTP_INSTR in OTP_SH.INSTR */
#define OTP_SH_INSTR__OTP_INSTR__Msk                            (0x0000001FUL << OTP_SH_INSTR__OTP_INSTR__Pos)                         /*!< Mask for OTP_INSTR in OTP_SH.INSTR */
#define OTP_SH_INSTR__OTP_INSTR__Shift(v)                       (((v) << OTP_SH_INSTR__OTP_INSTR__Pos) & OTP_SH_INSTR__OTP_INSTR__Msk) /*!< Shift value 'v' into OTP_INSTR and mask 'v' to fit it into OTP_INSTR field */

/** OTP_SH_INSTR__OTP_INSTR__SET() sets INSTR.OTP_INSTR to given value.
 *
 * When writing to INSTR.OTP_INSTR, this is recommended to use.
 *
 * @param bf_value new value for INSTR.OTP_INSTR
 */
__OTP_SH_INLINE void OTP_SH_INSTR__OTP_INSTR__SET(otp_sh_instr__otp_instr_t bf_value)
{
    uint32_t reg = OTP_SH_INSTR__GET();
    reg = (reg & ~OTP_SH_INSTR__OTP_INSTR__Msk);
    reg = (reg | (OTP_SH_INSTR__OTP_INSTR__Shift((uint32_t)bf_value)));
    OTP_SH_INSTR__SET(reg);
}

/** OTP_SH_INSTR__OTP_INSTR__GET() gets INSTR.OTP_INSTR's current value.
 *
 * When reading from INSTR.OTP_INSTR, this is recommended to use.
 *
 * @return current value of INSTR.OTP_INSTR
 */
__OTP_SH_INLINE otp_sh_instr__otp_instr_t OTP_SH_INSTR__OTP_INSTR__GET(void)
{
    uint32_t reg = OTP_SH_INSTR__GET();
    reg = (reg & OTP_SH_INSTR__OTP_INSTR__Msk);
    reg = (reg >> OTP_SH_INSTR__OTP_INSTR__Pos);
    return (otp_sh_instr__otp_instr_t)reg;
}

/** OTP_SH_INSTR__OTP_INSTR__MODIFY() modifies INSTR.OTP_INSTR.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.INSTR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.INSTR
 * @param bf_value new value for INSTR.OTP_INSTR
 * @return new value of OTP_SH.INSTR
 */
__OTP_SH_INLINE uint32_t OTP_SH_INSTR__OTP_INSTR__MODIFY(uint32_t reg, otp_sh_instr__otp_instr_t bf_value)
{
    reg = (reg & ~OTP_SH_INSTR__OTP_INSTR__Msk);
    reg = (reg | (OTP_SH_INSTR__OTP_INSTR__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_INSTR__OTP_INSTR__EXTRACT() extracts INSTR.OTP_INSTR.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INSTR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INSTR
 * @return current value of INSTR.OTP_INSTR
 */
__OTP_SH_INLINE otp_sh_instr__otp_instr_t OTP_SH_INSTR__OTP_INSTR__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INSTR__OTP_INSTR__Msk);
    reg = (reg >> OTP_SH_INSTR__OTP_INSTR__Pos);
    return (otp_sh_instr__otp_instr_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          EXEC member of OTP_SH_t                          */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_EXEC__ADDRESS returns the address of member EXEC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of EXEC
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_EXEC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, EXEC)));
}

/** OTP_SH_EXEC__SET() sets EXEC to given value.
 *
 * When writing to EXEC, this is mandatory to use.
 *
 * @param value new value for EXEC
 */
__OTP_SH_INLINE void OTP_SH_EXEC__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_EXEC__ADDRESS(), value);
}


/* ------------------------- OTP_SH.EXEC.START_EXEC ------------------------- */


#define OTP_SH_EXEC__START_EXEC__Pos                            0                                                                      /*!< Right-most bit position of START_EXEC in OTP_SH.EXEC */
#define OTP_SH_EXEC__START_EXEC__Msk                            (0xFFFFFFFFUL << OTP_SH_EXEC__START_EXEC__Pos)                         /*!< Mask for START_EXEC in OTP_SH.EXEC */
#define OTP_SH_EXEC__START_EXEC__Shift(v)                       (((v) << OTP_SH_EXEC__START_EXEC__Pos) & OTP_SH_EXEC__START_EXEC__Msk) /*!< Shift value 'v' into START_EXEC and mask 'v' to fit it into START_EXEC field */

/** OTP_SH_EXEC__START_EXEC__SET() sets EXEC.START_EXEC to given value.
 *
 * When writing to EXEC.START_EXEC, this is recommended to use.
 *
 * @param bf_value new value for EXEC.START_EXEC
 */
__OTP_SH_INLINE void OTP_SH_EXEC__START_EXEC__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_EXEC__START_EXEC__Shift((uint32_t)bf_value);
    OTP_SH_EXEC__SET(reg);
}


/** OTP_SH_EXEC__START_EXEC__MODIFY() modifies EXEC.START_EXEC.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.EXEC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.EXEC
 * @param bf_value new value for EXEC.START_EXEC
 * @return new value of OTP_SH.EXEC
 */
__OTP_SH_INLINE uint32_t OTP_SH_EXEC__START_EXEC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_EXEC__START_EXEC__Msk);
    reg = (reg | (OTP_SH_EXEC__START_EXEC__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_EXEC__START_EXEC__EXTRACT() extracts EXEC.START_EXEC.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.EXEC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.EXEC
 * @return current value of EXEC.START_EXEC
 */
__OTP_SH_INLINE uint32_t OTP_SH_EXEC__START_EXEC__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_EXEC__START_EXEC__Msk);
    reg = (reg >> OTP_SH_EXEC__START_EXEC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         DATAW0 member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_DATAW0__ADDRESS returns the address of member DATAW0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DATAW0
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_DATAW0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, DATAW0)));
}

/** OTP_SH_DATAW0__SET() sets DATAW0 to given value.
 *
 * When writing to DATAW0, this is mandatory to use.
 *
 * @param value new value for DATAW0
 */
__OTP_SH_INLINE void OTP_SH_DATAW0__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_DATAW0__ADDRESS(), value);
}

/** OTP_SH_DATAW0__GET() gets DATAW0's current value.
 *
 * When reading from DATAW0, this is mandatory to use.
 *
 * @return current value of DATAW0
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW0__GET(void)
{
    return HAL_GET32(__OTP_SH_DATAW0__ADDRESS());
}

/* --------------------------- OTP_SH.DATAW0.DATA --------------------------- */

/**
<pre>
  OTP_SH.DATAW0.DATA:

    Data to be written into selected OTP CacheLine word

</pre> */

#define OTP_SH_DATAW0__DATA__Pos                                0                                                                      /*!< Right-most bit position of DATA in OTP_SH.DATAW0 */
#define OTP_SH_DATAW0__DATA__Msk                                (0xFFFFFFFFUL << OTP_SH_DATAW0__DATA__Pos)                             /*!< Mask for DATA in OTP_SH.DATAW0 */
#define OTP_SH_DATAW0__DATA__Shift(v)                           (((v) << OTP_SH_DATAW0__DATA__Pos) & OTP_SH_DATAW0__DATA__Msk)         /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** OTP_SH_DATAW0__DATA__SET() sets DATAW0.DATA to given value.
 *
 * When writing to DATAW0.DATA, this is recommended to use.
 *
 * @param bf_value new value for DATAW0.DATA
 */
__OTP_SH_INLINE void OTP_SH_DATAW0__DATA__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_DATAW0__GET();
    reg = (reg & ~OTP_SH_DATAW0__DATA__Msk);
    reg = (reg | (OTP_SH_DATAW0__DATA__Shift((uint32_t)bf_value)));
    OTP_SH_DATAW0__SET(reg);
}

/** OTP_SH_DATAW0__DATA__GET() gets DATAW0.DATA's current value.
 *
 * When reading from DATAW0.DATA, this is recommended to use.
 *
 * @return current value of DATAW0.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW0__DATA__GET(void)
{
    uint32_t reg = OTP_SH_DATAW0__GET();
    reg = (reg & OTP_SH_DATAW0__DATA__Msk);
    reg = (reg >> OTP_SH_DATAW0__DATA__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_DATAW0__DATA__MODIFY() modifies DATAW0.DATA.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.DATAW0.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.DATAW0
 * @param bf_value new value for DATAW0.DATA
 * @return new value of OTP_SH.DATAW0
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW0__DATA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_DATAW0__DATA__Msk);
    reg = (reg | (OTP_SH_DATAW0__DATA__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_DATAW0__DATA__EXTRACT() extracts DATAW0.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.DATAW0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.DATAW0
 * @return current value of DATAW0.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW0__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_DATAW0__DATA__Msk);
    reg = (reg >> OTP_SH_DATAW0__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         DATAW1 member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_DATAW1__ADDRESS returns the address of member DATAW1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DATAW1
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_DATAW1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, DATAW1)));
}

/** OTP_SH_DATAW1__SET() sets DATAW1 to given value.
 *
 * When writing to DATAW1, this is mandatory to use.
 *
 * @param value new value for DATAW1
 */
__OTP_SH_INLINE void OTP_SH_DATAW1__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_DATAW1__ADDRESS(), value);
}

/** OTP_SH_DATAW1__GET() gets DATAW1's current value.
 *
 * When reading from DATAW1, this is mandatory to use.
 *
 * @return current value of DATAW1
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW1__GET(void)
{
    return HAL_GET32(__OTP_SH_DATAW1__ADDRESS());
}

/* --------------------------- OTP_SH.DATAW1.DATA --------------------------- */

/**
<pre>
  OTP_SH.DATAW1.DATA:

    Data to be written into selected OTP CacheLine word

</pre> */

#define OTP_SH_DATAW1__DATA__Pos                                0                                                                      /*!< Right-most bit position of DATA in OTP_SH.DATAW1 */
#define OTP_SH_DATAW1__DATA__Msk                                (0xFFFFFFFFUL << OTP_SH_DATAW1__DATA__Pos)                             /*!< Mask for DATA in OTP_SH.DATAW1 */
#define OTP_SH_DATAW1__DATA__Shift(v)                           (((v) << OTP_SH_DATAW1__DATA__Pos) & OTP_SH_DATAW1__DATA__Msk)         /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** OTP_SH_DATAW1__DATA__SET() sets DATAW1.DATA to given value.
 *
 * When writing to DATAW1.DATA, this is recommended to use.
 *
 * @param bf_value new value for DATAW1.DATA
 */
__OTP_SH_INLINE void OTP_SH_DATAW1__DATA__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_DATAW1__GET();
    reg = (reg & ~OTP_SH_DATAW1__DATA__Msk);
    reg = (reg | (OTP_SH_DATAW1__DATA__Shift((uint32_t)bf_value)));
    OTP_SH_DATAW1__SET(reg);
}

/** OTP_SH_DATAW1__DATA__GET() gets DATAW1.DATA's current value.
 *
 * When reading from DATAW1.DATA, this is recommended to use.
 *
 * @return current value of DATAW1.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW1__DATA__GET(void)
{
    uint32_t reg = OTP_SH_DATAW1__GET();
    reg = (reg & OTP_SH_DATAW1__DATA__Msk);
    reg = (reg >> OTP_SH_DATAW1__DATA__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_DATAW1__DATA__MODIFY() modifies DATAW1.DATA.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.DATAW1.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.DATAW1
 * @param bf_value new value for DATAW1.DATA
 * @return new value of OTP_SH.DATAW1
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW1__DATA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_DATAW1__DATA__Msk);
    reg = (reg | (OTP_SH_DATAW1__DATA__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_DATAW1__DATA__EXTRACT() extracts DATAW1.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.DATAW1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.DATAW1
 * @return current value of DATAW1.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW1__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_DATAW1__DATA__Msk);
    reg = (reg >> OTP_SH_DATAW1__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         DATAW2 member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_DATAW2__ADDRESS returns the address of member DATAW2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DATAW2
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_DATAW2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, DATAW2)));
}

/** OTP_SH_DATAW2__SET() sets DATAW2 to given value.
 *
 * When writing to DATAW2, this is mandatory to use.
 *
 * @param value new value for DATAW2
 */
__OTP_SH_INLINE void OTP_SH_DATAW2__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_DATAW2__ADDRESS(), value);
}

/** OTP_SH_DATAW2__GET() gets DATAW2's current value.
 *
 * When reading from DATAW2, this is mandatory to use.
 *
 * @return current value of DATAW2
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW2__GET(void)
{
    return HAL_GET32(__OTP_SH_DATAW2__ADDRESS());
}

/* --------------------------- OTP_SH.DATAW2.DATA --------------------------- */

/**
<pre>
  OTP_SH.DATAW2.DATA:

    Data to be written into selected OTP CacheLine word

</pre> */

#define OTP_SH_DATAW2__DATA__Pos                                0                                                                      /*!< Right-most bit position of DATA in OTP_SH.DATAW2 */
#define OTP_SH_DATAW2__DATA__Msk                                (0xFFFFFFFFUL << OTP_SH_DATAW2__DATA__Pos)                             /*!< Mask for DATA in OTP_SH.DATAW2 */
#define OTP_SH_DATAW2__DATA__Shift(v)                           (((v) << OTP_SH_DATAW2__DATA__Pos) & OTP_SH_DATAW2__DATA__Msk)         /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** OTP_SH_DATAW2__DATA__SET() sets DATAW2.DATA to given value.
 *
 * When writing to DATAW2.DATA, this is recommended to use.
 *
 * @param bf_value new value for DATAW2.DATA
 */
__OTP_SH_INLINE void OTP_SH_DATAW2__DATA__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_DATAW2__GET();
    reg = (reg & ~OTP_SH_DATAW2__DATA__Msk);
    reg = (reg | (OTP_SH_DATAW2__DATA__Shift((uint32_t)bf_value)));
    OTP_SH_DATAW2__SET(reg);
}

/** OTP_SH_DATAW2__DATA__GET() gets DATAW2.DATA's current value.
 *
 * When reading from DATAW2.DATA, this is recommended to use.
 *
 * @return current value of DATAW2.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW2__DATA__GET(void)
{
    uint32_t reg = OTP_SH_DATAW2__GET();
    reg = (reg & OTP_SH_DATAW2__DATA__Msk);
    reg = (reg >> OTP_SH_DATAW2__DATA__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_DATAW2__DATA__MODIFY() modifies DATAW2.DATA.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.DATAW2.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.DATAW2
 * @param bf_value new value for DATAW2.DATA
 * @return new value of OTP_SH.DATAW2
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW2__DATA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_DATAW2__DATA__Msk);
    reg = (reg | (OTP_SH_DATAW2__DATA__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_DATAW2__DATA__EXTRACT() extracts DATAW2.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.DATAW2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.DATAW2
 * @return current value of DATAW2.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW2__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_DATAW2__DATA__Msk);
    reg = (reg >> OTP_SH_DATAW2__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         DATAW3 member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_DATAW3__ADDRESS returns the address of member DATAW3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DATAW3
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_DATAW3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, DATAW3)));
}

/** OTP_SH_DATAW3__SET() sets DATAW3 to given value.
 *
 * When writing to DATAW3, this is mandatory to use.
 *
 * @param value new value for DATAW3
 */
__OTP_SH_INLINE void OTP_SH_DATAW3__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_DATAW3__ADDRESS(), value);
}

/** OTP_SH_DATAW3__GET() gets DATAW3's current value.
 *
 * When reading from DATAW3, this is mandatory to use.
 *
 * @return current value of DATAW3
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW3__GET(void)
{
    return HAL_GET32(__OTP_SH_DATAW3__ADDRESS());
}

/* --------------------------- OTP_SH.DATAW3.DATA --------------------------- */

/**
<pre>
  OTP_SH.DATAW3.DATA:

    Data to be written into selected OTP CacheLine word

</pre> */

#define OTP_SH_DATAW3__DATA__Pos                                0                                                                      /*!< Right-most bit position of DATA in OTP_SH.DATAW3 */
#define OTP_SH_DATAW3__DATA__Msk                                (0xFFFFFFFFUL << OTP_SH_DATAW3__DATA__Pos)                             /*!< Mask for DATA in OTP_SH.DATAW3 */
#define OTP_SH_DATAW3__DATA__Shift(v)                           (((v) << OTP_SH_DATAW3__DATA__Pos) & OTP_SH_DATAW3__DATA__Msk)         /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** OTP_SH_DATAW3__DATA__SET() sets DATAW3.DATA to given value.
 *
 * When writing to DATAW3.DATA, this is recommended to use.
 *
 * @param bf_value new value for DATAW3.DATA
 */
__OTP_SH_INLINE void OTP_SH_DATAW3__DATA__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_DATAW3__GET();
    reg = (reg & ~OTP_SH_DATAW3__DATA__Msk);
    reg = (reg | (OTP_SH_DATAW3__DATA__Shift((uint32_t)bf_value)));
    OTP_SH_DATAW3__SET(reg);
}

/** OTP_SH_DATAW3__DATA__GET() gets DATAW3.DATA's current value.
 *
 * When reading from DATAW3.DATA, this is recommended to use.
 *
 * @return current value of DATAW3.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW3__DATA__GET(void)
{
    uint32_t reg = OTP_SH_DATAW3__GET();
    reg = (reg & OTP_SH_DATAW3__DATA__Msk);
    reg = (reg >> OTP_SH_DATAW3__DATA__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_DATAW3__DATA__MODIFY() modifies DATAW3.DATA.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.DATAW3.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.DATAW3
 * @param bf_value new value for DATAW3.DATA
 * @return new value of OTP_SH.DATAW3
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW3__DATA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_DATAW3__DATA__Msk);
    reg = (reg | (OTP_SH_DATAW3__DATA__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_DATAW3__DATA__EXTRACT() extracts DATAW3.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.DATAW3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.DATAW3
 * @return current value of DATAW3.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_DATAW3__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_DATAW3__DATA__Msk);
    reg = (reg >> OTP_SH_DATAW3__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        READ_MRAB member of OTP_SH_t                        */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_READ_MRAB__ADDRESS returns the address of member READ_MRAB.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of READ_MRAB
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_READ_MRAB__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, READ_MRAB)));
}

/** OTP_SH_READ_MRAB__SET() sets READ_MRAB to given value.
 *
 * When writing to READ_MRAB, this is mandatory to use.
 *
 * @param value new value for READ_MRAB
 */
__OTP_SH_INLINE void OTP_SH_READ_MRAB__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_READ_MRAB__ADDRESS(), value);
}

/** OTP_SH_READ_MRAB__GET() gets READ_MRAB's current value.
 *
 * When reading from READ_MRAB, this is mandatory to use.
 *
 * @return current value of READ_MRAB
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MRAB__GET(void)
{
    return HAL_GET32(__OTP_SH_READ_MRAB__ADDRESS());
}

/* ----------------------- OTP_SH.READ_MRAB.MRA_READ ----------------------- */


#define OTP_SH_READ_MRAB__MRA_READ__Pos                         16                                                                     /*!< Right-most bit position of MRA_READ in OTP_SH.READ_MRAB */
#define OTP_SH_READ_MRAB__MRA_READ__Msk                         (0x0000FFFFUL << OTP_SH_READ_MRAB__MRA_READ__Pos)                      /*!< Mask for MRA_READ in OTP_SH.READ_MRAB */
#define OTP_SH_READ_MRAB__MRA_READ__Shift(v)                    (((v) << OTP_SH_READ_MRAB__MRA_READ__Pos) & OTP_SH_READ_MRAB__MRA_READ__Msk) /*!< Shift value 'v' into MRA_READ and mask 'v' to fit it into MRA_READ field */

/** OTP_SH_READ_MRAB__MRA_READ__SET() sets READ_MRAB.MRA_READ to given value.
 *
 * When writing to READ_MRAB.MRA_READ, this is recommended to use.
 *
 * @param bf_value new value for READ_MRAB.MRA_READ
 */
__OTP_SH_INLINE void OTP_SH_READ_MRAB__MRA_READ__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_READ_MRAB__GET();
    reg = (reg & ~OTP_SH_READ_MRAB__MRA_READ__Msk);
    reg = (reg | (OTP_SH_READ_MRAB__MRA_READ__Shift((uint32_t)bf_value)));
    OTP_SH_READ_MRAB__SET(reg);
}

/** OTP_SH_READ_MRAB__MRA_READ__GET() gets READ_MRAB.MRA_READ's current value.
 *
 * When reading from READ_MRAB.MRA_READ, this is recommended to use.
 *
 * @return current value of READ_MRAB.MRA_READ
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MRAB__MRA_READ__GET(void)
{
    uint32_t reg = OTP_SH_READ_MRAB__GET();
    reg = (reg & OTP_SH_READ_MRAB__MRA_READ__Msk);
    reg = (reg >> OTP_SH_READ_MRAB__MRA_READ__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_READ_MRAB__MRA_READ__MODIFY() modifies READ_MRAB.MRA_READ.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.READ_MRAB.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.READ_MRAB
 * @param bf_value new value for READ_MRAB.MRA_READ
 * @return new value of OTP_SH.READ_MRAB
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MRAB__MRA_READ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_READ_MRAB__MRA_READ__Msk);
    reg = (reg | (OTP_SH_READ_MRAB__MRA_READ__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_READ_MRAB__MRA_READ__EXTRACT() extracts READ_MRAB.MRA_READ.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.READ_MRAB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.READ_MRAB
 * @return current value of READ_MRAB.MRA_READ
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MRAB__MRA_READ__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_READ_MRAB__MRA_READ__Msk);
    reg = (reg >> OTP_SH_READ_MRAB__MRA_READ__Pos);
    return (uint32_t)reg;
}

/* ----------------------- OTP_SH.READ_MRAB.MRB_READ ----------------------- */


#define OTP_SH_READ_MRAB__MRB_READ__Pos                         0                                                                      /*!< Right-most bit position of MRB_READ in OTP_SH.READ_MRAB */
#define OTP_SH_READ_MRAB__MRB_READ__Msk                         (0x0000FFFFUL << OTP_SH_READ_MRAB__MRB_READ__Pos)                      /*!< Mask for MRB_READ in OTP_SH.READ_MRAB */
#define OTP_SH_READ_MRAB__MRB_READ__Shift(v)                    (((v) << OTP_SH_READ_MRAB__MRB_READ__Pos) & OTP_SH_READ_MRAB__MRB_READ__Msk) /*!< Shift value 'v' into MRB_READ and mask 'v' to fit it into MRB_READ field */

/** OTP_SH_READ_MRAB__MRB_READ__SET() sets READ_MRAB.MRB_READ to given value.
 *
 * When writing to READ_MRAB.MRB_READ, this is recommended to use.
 *
 * @param bf_value new value for READ_MRAB.MRB_READ
 */
__OTP_SH_INLINE void OTP_SH_READ_MRAB__MRB_READ__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_READ_MRAB__GET();
    reg = (reg & ~OTP_SH_READ_MRAB__MRB_READ__Msk);
    reg = (reg | (OTP_SH_READ_MRAB__MRB_READ__Shift((uint32_t)bf_value)));
    OTP_SH_READ_MRAB__SET(reg);
}

/** OTP_SH_READ_MRAB__MRB_READ__GET() gets READ_MRAB.MRB_READ's current value.
 *
 * When reading from READ_MRAB.MRB_READ, this is recommended to use.
 *
 * @return current value of READ_MRAB.MRB_READ
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MRAB__MRB_READ__GET(void)
{
    uint32_t reg = OTP_SH_READ_MRAB__GET();
    reg = (reg & OTP_SH_READ_MRAB__MRB_READ__Msk);
    reg = (reg >> OTP_SH_READ_MRAB__MRB_READ__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_READ_MRAB__MRB_READ__MODIFY() modifies READ_MRAB.MRB_READ.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.READ_MRAB.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.READ_MRAB
 * @param bf_value new value for READ_MRAB.MRB_READ
 * @return new value of OTP_SH.READ_MRAB
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MRAB__MRB_READ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_READ_MRAB__MRB_READ__Msk);
    reg = (reg | (OTP_SH_READ_MRAB__MRB_READ__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_READ_MRAB__MRB_READ__EXTRACT() extracts READ_MRAB.MRB_READ.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.READ_MRAB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.READ_MRAB
 * @return current value of READ_MRAB.MRB_READ
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MRAB__MRB_READ__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_READ_MRAB__MRB_READ__Msk);
    reg = (reg >> OTP_SH_READ_MRAB__MRB_READ__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         READ_MR member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_READ_MR__ADDRESS returns the address of member READ_MR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of READ_MR
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_READ_MR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, READ_MR)));
}

/** OTP_SH_READ_MR__SET() sets READ_MR to given value.
 *
 * When writing to READ_MR, this is mandatory to use.
 *
 * @param value new value for READ_MR
 */
__OTP_SH_INLINE void OTP_SH_READ_MR__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_READ_MR__ADDRESS(), value);
}

/** OTP_SH_READ_MR__GET() gets READ_MR's current value.
 *
 * When reading from READ_MR, this is mandatory to use.
 *
 * @return current value of READ_MR
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MR__GET(void)
{
    return HAL_GET32(__OTP_SH_READ_MR__ADDRESS());
}

/* ------------------------- OTP_SH.READ_MR.MR_READ ------------------------- */


#define OTP_SH_READ_MR__MR_READ__Pos                            0                                                                      /*!< Right-most bit position of MR_READ in OTP_SH.READ_MR */
#define OTP_SH_READ_MR__MR_READ__Msk                            (0x0000FFFFUL << OTP_SH_READ_MR__MR_READ__Pos)                         /*!< Mask for MR_READ in OTP_SH.READ_MR */
#define OTP_SH_READ_MR__MR_READ__Shift(v)                       (((v) << OTP_SH_READ_MR__MR_READ__Pos) & OTP_SH_READ_MR__MR_READ__Msk) /*!< Shift value 'v' into MR_READ and mask 'v' to fit it into MR_READ field */

/** OTP_SH_READ_MR__MR_READ__SET() sets READ_MR.MR_READ to given value.
 *
 * When writing to READ_MR.MR_READ, this is recommended to use.
 *
 * @param bf_value new value for READ_MR.MR_READ
 */
__OTP_SH_INLINE void OTP_SH_READ_MR__MR_READ__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_READ_MR__GET();
    reg = (reg & ~OTP_SH_READ_MR__MR_READ__Msk);
    reg = (reg | (OTP_SH_READ_MR__MR_READ__Shift((uint32_t)bf_value)));
    OTP_SH_READ_MR__SET(reg);
}

/** OTP_SH_READ_MR__MR_READ__GET() gets READ_MR.MR_READ's current value.
 *
 * When reading from READ_MR.MR_READ, this is recommended to use.
 *
 * @return current value of READ_MR.MR_READ
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MR__MR_READ__GET(void)
{
    uint32_t reg = OTP_SH_READ_MR__GET();
    reg = (reg & OTP_SH_READ_MR__MR_READ__Msk);
    reg = (reg >> OTP_SH_READ_MR__MR_READ__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_READ_MR__MR_READ__MODIFY() modifies READ_MR.MR_READ.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.READ_MR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.READ_MR
 * @param bf_value new value for READ_MR.MR_READ
 * @return new value of OTP_SH.READ_MR
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MR__MR_READ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_READ_MR__MR_READ__Msk);
    reg = (reg | (OTP_SH_READ_MR__MR_READ__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_READ_MR__MR_READ__EXTRACT() extracts READ_MR.MR_READ.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.READ_MR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.READ_MR
 * @return current value of READ_MR.MR_READ
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ_MR__MR_READ__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_READ_MR__MR_READ__Msk);
    reg = (reg >> OTP_SH_READ_MR__MR_READ__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       READ1_MRAB member of OTP_SH_t                       */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_READ1_MRAB__ADDRESS returns the address of member READ1_MRAB.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of READ1_MRAB
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_READ1_MRAB__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, READ1_MRAB)));
}

/** OTP_SH_READ1_MRAB__SET() sets READ1_MRAB to given value.
 *
 * When writing to READ1_MRAB, this is mandatory to use.
 *
 * @param value new value for READ1_MRAB
 */
__OTP_SH_INLINE void OTP_SH_READ1_MRAB__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_READ1_MRAB__ADDRESS(), value);
}

/** OTP_SH_READ1_MRAB__GET() gets READ1_MRAB's current value.
 *
 * When reading from READ1_MRAB, this is mandatory to use.
 *
 * @return current value of READ1_MRAB
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MRAB__GET(void)
{
    return HAL_GET32(__OTP_SH_READ1_MRAB__ADDRESS());
}

/* ---------------------- OTP_SH.READ1_MRAB.MRA_READ1 ---------------------- */


#define OTP_SH_READ1_MRAB__MRA_READ1__Pos                       16                                                                     /*!< Right-most bit position of MRA_READ1 in OTP_SH.READ1_MRAB */
#define OTP_SH_READ1_MRAB__MRA_READ1__Msk                       (0x0000FFFFUL << OTP_SH_READ1_MRAB__MRA_READ1__Pos)                    /*!< Mask for MRA_READ1 in OTP_SH.READ1_MRAB */
#define OTP_SH_READ1_MRAB__MRA_READ1__Shift(v)                  (((v) << OTP_SH_READ1_MRAB__MRA_READ1__Pos) & OTP_SH_READ1_MRAB__MRA_READ1__Msk) /*!< Shift value 'v' into MRA_READ1 and mask 'v' to fit it into MRA_READ1 field */

/** OTP_SH_READ1_MRAB__MRA_READ1__SET() sets READ1_MRAB.MRA_READ1 to given value.
 *
 * When writing to READ1_MRAB.MRA_READ1, this is recommended to use.
 *
 * @param bf_value new value for READ1_MRAB.MRA_READ1
 */
__OTP_SH_INLINE void OTP_SH_READ1_MRAB__MRA_READ1__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_READ1_MRAB__GET();
    reg = (reg & ~OTP_SH_READ1_MRAB__MRA_READ1__Msk);
    reg = (reg | (OTP_SH_READ1_MRAB__MRA_READ1__Shift((uint32_t)bf_value)));
    OTP_SH_READ1_MRAB__SET(reg);
}

/** OTP_SH_READ1_MRAB__MRA_READ1__GET() gets READ1_MRAB.MRA_READ1's current value.
 *
 * When reading from READ1_MRAB.MRA_READ1, this is recommended to use.
 *
 * @return current value of READ1_MRAB.MRA_READ1
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MRAB__MRA_READ1__GET(void)
{
    uint32_t reg = OTP_SH_READ1_MRAB__GET();
    reg = (reg & OTP_SH_READ1_MRAB__MRA_READ1__Msk);
    reg = (reg >> OTP_SH_READ1_MRAB__MRA_READ1__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_READ1_MRAB__MRA_READ1__MODIFY() modifies READ1_MRAB.MRA_READ1.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.READ1_MRAB.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.READ1_MRAB
 * @param bf_value new value for READ1_MRAB.MRA_READ1
 * @return new value of OTP_SH.READ1_MRAB
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MRAB__MRA_READ1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_READ1_MRAB__MRA_READ1__Msk);
    reg = (reg | (OTP_SH_READ1_MRAB__MRA_READ1__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_READ1_MRAB__MRA_READ1__EXTRACT() extracts READ1_MRAB.MRA_READ1.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.READ1_MRAB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.READ1_MRAB
 * @return current value of READ1_MRAB.MRA_READ1
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MRAB__MRA_READ1__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_READ1_MRAB__MRA_READ1__Msk);
    reg = (reg >> OTP_SH_READ1_MRAB__MRA_READ1__Pos);
    return (uint32_t)reg;
}

/* ---------------------- OTP_SH.READ1_MRAB.MRB_READ1 ---------------------- */


#define OTP_SH_READ1_MRAB__MRB_READ1__Pos                       0                                                                      /*!< Right-most bit position of MRB_READ1 in OTP_SH.READ1_MRAB */
#define OTP_SH_READ1_MRAB__MRB_READ1__Msk                       (0x0000FFFFUL << OTP_SH_READ1_MRAB__MRB_READ1__Pos)                    /*!< Mask for MRB_READ1 in OTP_SH.READ1_MRAB */
#define OTP_SH_READ1_MRAB__MRB_READ1__Shift(v)                  (((v) << OTP_SH_READ1_MRAB__MRB_READ1__Pos) & OTP_SH_READ1_MRAB__MRB_READ1__Msk) /*!< Shift value 'v' into MRB_READ1 and mask 'v' to fit it into MRB_READ1 field */

/** OTP_SH_READ1_MRAB__MRB_READ1__SET() sets READ1_MRAB.MRB_READ1 to given value.
 *
 * When writing to READ1_MRAB.MRB_READ1, this is recommended to use.
 *
 * @param bf_value new value for READ1_MRAB.MRB_READ1
 */
__OTP_SH_INLINE void OTP_SH_READ1_MRAB__MRB_READ1__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_READ1_MRAB__GET();
    reg = (reg & ~OTP_SH_READ1_MRAB__MRB_READ1__Msk);
    reg = (reg | (OTP_SH_READ1_MRAB__MRB_READ1__Shift((uint32_t)bf_value)));
    OTP_SH_READ1_MRAB__SET(reg);
}

/** OTP_SH_READ1_MRAB__MRB_READ1__GET() gets READ1_MRAB.MRB_READ1's current value.
 *
 * When reading from READ1_MRAB.MRB_READ1, this is recommended to use.
 *
 * @return current value of READ1_MRAB.MRB_READ1
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MRAB__MRB_READ1__GET(void)
{
    uint32_t reg = OTP_SH_READ1_MRAB__GET();
    reg = (reg & OTP_SH_READ1_MRAB__MRB_READ1__Msk);
    reg = (reg >> OTP_SH_READ1_MRAB__MRB_READ1__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_READ1_MRAB__MRB_READ1__MODIFY() modifies READ1_MRAB.MRB_READ1.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.READ1_MRAB.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.READ1_MRAB
 * @param bf_value new value for READ1_MRAB.MRB_READ1
 * @return new value of OTP_SH.READ1_MRAB
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MRAB__MRB_READ1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_READ1_MRAB__MRB_READ1__Msk);
    reg = (reg | (OTP_SH_READ1_MRAB__MRB_READ1__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_READ1_MRAB__MRB_READ1__EXTRACT() extracts READ1_MRAB.MRB_READ1.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.READ1_MRAB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.READ1_MRAB
 * @return current value of READ1_MRAB.MRB_READ1
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MRAB__MRB_READ1__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_READ1_MRAB__MRB_READ1__Msk);
    reg = (reg >> OTP_SH_READ1_MRAB__MRB_READ1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        READ1_MR member of OTP_SH_t                        */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_READ1_MR__ADDRESS returns the address of member READ1_MR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of READ1_MR
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_READ1_MR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, READ1_MR)));
}

/** OTP_SH_READ1_MR__SET() sets READ1_MR to given value.
 *
 * When writing to READ1_MR, this is mandatory to use.
 *
 * @param value new value for READ1_MR
 */
__OTP_SH_INLINE void OTP_SH_READ1_MR__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_READ1_MR__ADDRESS(), value);
}

/** OTP_SH_READ1_MR__GET() gets READ1_MR's current value.
 *
 * When reading from READ1_MR, this is mandatory to use.
 *
 * @return current value of READ1_MR
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MR__GET(void)
{
    return HAL_GET32(__OTP_SH_READ1_MR__ADDRESS());
}

/* ------------------------ OTP_SH.READ1_MR.MR_READ1 ------------------------ */


#define OTP_SH_READ1_MR__MR_READ1__Pos                          0                                                                      /*!< Right-most bit position of MR_READ1 in OTP_SH.READ1_MR */
#define OTP_SH_READ1_MR__MR_READ1__Msk                          (0x0000FFFFUL << OTP_SH_READ1_MR__MR_READ1__Pos)                       /*!< Mask for MR_READ1 in OTP_SH.READ1_MR */
#define OTP_SH_READ1_MR__MR_READ1__Shift(v)                     (((v) << OTP_SH_READ1_MR__MR_READ1__Pos) & OTP_SH_READ1_MR__MR_READ1__Msk) /*!< Shift value 'v' into MR_READ1 and mask 'v' to fit it into MR_READ1 field */

/** OTP_SH_READ1_MR__MR_READ1__SET() sets READ1_MR.MR_READ1 to given value.
 *
 * When writing to READ1_MR.MR_READ1, this is recommended to use.
 *
 * @param bf_value new value for READ1_MR.MR_READ1
 */
__OTP_SH_INLINE void OTP_SH_READ1_MR__MR_READ1__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_READ1_MR__GET();
    reg = (reg & ~OTP_SH_READ1_MR__MR_READ1__Msk);
    reg = (reg | (OTP_SH_READ1_MR__MR_READ1__Shift((uint32_t)bf_value)));
    OTP_SH_READ1_MR__SET(reg);
}

/** OTP_SH_READ1_MR__MR_READ1__GET() gets READ1_MR.MR_READ1's current value.
 *
 * When reading from READ1_MR.MR_READ1, this is recommended to use.
 *
 * @return current value of READ1_MR.MR_READ1
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MR__MR_READ1__GET(void)
{
    uint32_t reg = OTP_SH_READ1_MR__GET();
    reg = (reg & OTP_SH_READ1_MR__MR_READ1__Msk);
    reg = (reg >> OTP_SH_READ1_MR__MR_READ1__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_READ1_MR__MR_READ1__MODIFY() modifies READ1_MR.MR_READ1.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.READ1_MR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.READ1_MR
 * @param bf_value new value for READ1_MR.MR_READ1
 * @return new value of OTP_SH.READ1_MR
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MR__MR_READ1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_READ1_MR__MR_READ1__Msk);
    reg = (reg | (OTP_SH_READ1_MR__MR_READ1__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_READ1_MR__MR_READ1__EXTRACT() extracts READ1_MR.MR_READ1.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.READ1_MR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.READ1_MR
 * @return current value of READ1_MR.MR_READ1
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ1_MR__MR_READ1__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_READ1_MR__MR_READ1__Msk);
    reg = (reg >> OTP_SH_READ1_MR__MR_READ1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       READ2_MRAB member of OTP_SH_t                       */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_READ2_MRAB__ADDRESS returns the address of member READ2_MRAB.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of READ2_MRAB
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_READ2_MRAB__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, READ2_MRAB)));
}

/** OTP_SH_READ2_MRAB__SET() sets READ2_MRAB to given value.
 *
 * When writing to READ2_MRAB, this is mandatory to use.
 *
 * @param value new value for READ2_MRAB
 */
__OTP_SH_INLINE void OTP_SH_READ2_MRAB__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_READ2_MRAB__ADDRESS(), value);
}

/** OTP_SH_READ2_MRAB__GET() gets READ2_MRAB's current value.
 *
 * When reading from READ2_MRAB, this is mandatory to use.
 *
 * @return current value of READ2_MRAB
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MRAB__GET(void)
{
    return HAL_GET32(__OTP_SH_READ2_MRAB__ADDRESS());
}

/* ---------------------- OTP_SH.READ2_MRAB.MRA_READ2 ---------------------- */


#define OTP_SH_READ2_MRAB__MRA_READ2__Pos                       16                                                                     /*!< Right-most bit position of MRA_READ2 in OTP_SH.READ2_MRAB */
#define OTP_SH_READ2_MRAB__MRA_READ2__Msk                       (0x0000FFFFUL << OTP_SH_READ2_MRAB__MRA_READ2__Pos)                    /*!< Mask for MRA_READ2 in OTP_SH.READ2_MRAB */
#define OTP_SH_READ2_MRAB__MRA_READ2__Shift(v)                  (((v) << OTP_SH_READ2_MRAB__MRA_READ2__Pos) & OTP_SH_READ2_MRAB__MRA_READ2__Msk) /*!< Shift value 'v' into MRA_READ2 and mask 'v' to fit it into MRA_READ2 field */

/** OTP_SH_READ2_MRAB__MRA_READ2__SET() sets READ2_MRAB.MRA_READ2 to given value.
 *
 * When writing to READ2_MRAB.MRA_READ2, this is recommended to use.
 *
 * @param bf_value new value for READ2_MRAB.MRA_READ2
 */
__OTP_SH_INLINE void OTP_SH_READ2_MRAB__MRA_READ2__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_READ2_MRAB__GET();
    reg = (reg & ~OTP_SH_READ2_MRAB__MRA_READ2__Msk);
    reg = (reg | (OTP_SH_READ2_MRAB__MRA_READ2__Shift((uint32_t)bf_value)));
    OTP_SH_READ2_MRAB__SET(reg);
}

/** OTP_SH_READ2_MRAB__MRA_READ2__GET() gets READ2_MRAB.MRA_READ2's current value.
 *
 * When reading from READ2_MRAB.MRA_READ2, this is recommended to use.
 *
 * @return current value of READ2_MRAB.MRA_READ2
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MRAB__MRA_READ2__GET(void)
{
    uint32_t reg = OTP_SH_READ2_MRAB__GET();
    reg = (reg & OTP_SH_READ2_MRAB__MRA_READ2__Msk);
    reg = (reg >> OTP_SH_READ2_MRAB__MRA_READ2__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_READ2_MRAB__MRA_READ2__MODIFY() modifies READ2_MRAB.MRA_READ2.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.READ2_MRAB.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.READ2_MRAB
 * @param bf_value new value for READ2_MRAB.MRA_READ2
 * @return new value of OTP_SH.READ2_MRAB
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MRAB__MRA_READ2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_READ2_MRAB__MRA_READ2__Msk);
    reg = (reg | (OTP_SH_READ2_MRAB__MRA_READ2__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_READ2_MRAB__MRA_READ2__EXTRACT() extracts READ2_MRAB.MRA_READ2.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.READ2_MRAB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.READ2_MRAB
 * @return current value of READ2_MRAB.MRA_READ2
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MRAB__MRA_READ2__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_READ2_MRAB__MRA_READ2__Msk);
    reg = (reg >> OTP_SH_READ2_MRAB__MRA_READ2__Pos);
    return (uint32_t)reg;
}

/* ---------------------- OTP_SH.READ2_MRAB.MRB_READ2 ---------------------- */


#define OTP_SH_READ2_MRAB__MRB_READ2__Pos                       0                                                                      /*!< Right-most bit position of MRB_READ2 in OTP_SH.READ2_MRAB */
#define OTP_SH_READ2_MRAB__MRB_READ2__Msk                       (0x0000FFFFUL << OTP_SH_READ2_MRAB__MRB_READ2__Pos)                    /*!< Mask for MRB_READ2 in OTP_SH.READ2_MRAB */
#define OTP_SH_READ2_MRAB__MRB_READ2__Shift(v)                  (((v) << OTP_SH_READ2_MRAB__MRB_READ2__Pos) & OTP_SH_READ2_MRAB__MRB_READ2__Msk) /*!< Shift value 'v' into MRB_READ2 and mask 'v' to fit it into MRB_READ2 field */

/** OTP_SH_READ2_MRAB__MRB_READ2__SET() sets READ2_MRAB.MRB_READ2 to given value.
 *
 * When writing to READ2_MRAB.MRB_READ2, this is recommended to use.
 *
 * @param bf_value new value for READ2_MRAB.MRB_READ2
 */
__OTP_SH_INLINE void OTP_SH_READ2_MRAB__MRB_READ2__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_READ2_MRAB__GET();
    reg = (reg & ~OTP_SH_READ2_MRAB__MRB_READ2__Msk);
    reg = (reg | (OTP_SH_READ2_MRAB__MRB_READ2__Shift((uint32_t)bf_value)));
    OTP_SH_READ2_MRAB__SET(reg);
}

/** OTP_SH_READ2_MRAB__MRB_READ2__GET() gets READ2_MRAB.MRB_READ2's current value.
 *
 * When reading from READ2_MRAB.MRB_READ2, this is recommended to use.
 *
 * @return current value of READ2_MRAB.MRB_READ2
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MRAB__MRB_READ2__GET(void)
{
    uint32_t reg = OTP_SH_READ2_MRAB__GET();
    reg = (reg & OTP_SH_READ2_MRAB__MRB_READ2__Msk);
    reg = (reg >> OTP_SH_READ2_MRAB__MRB_READ2__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_READ2_MRAB__MRB_READ2__MODIFY() modifies READ2_MRAB.MRB_READ2.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.READ2_MRAB.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.READ2_MRAB
 * @param bf_value new value for READ2_MRAB.MRB_READ2
 * @return new value of OTP_SH.READ2_MRAB
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MRAB__MRB_READ2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_READ2_MRAB__MRB_READ2__Msk);
    reg = (reg | (OTP_SH_READ2_MRAB__MRB_READ2__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_READ2_MRAB__MRB_READ2__EXTRACT() extracts READ2_MRAB.MRB_READ2.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.READ2_MRAB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.READ2_MRAB
 * @return current value of READ2_MRAB.MRB_READ2
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MRAB__MRB_READ2__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_READ2_MRAB__MRB_READ2__Msk);
    reg = (reg >> OTP_SH_READ2_MRAB__MRB_READ2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        READ2_MR member of OTP_SH_t                        */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_READ2_MR__ADDRESS returns the address of member READ2_MR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of READ2_MR
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_READ2_MR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, READ2_MR)));
}

/** OTP_SH_READ2_MR__SET() sets READ2_MR to given value.
 *
 * When writing to READ2_MR, this is mandatory to use.
 *
 * @param value new value for READ2_MR
 */
__OTP_SH_INLINE void OTP_SH_READ2_MR__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_READ2_MR__ADDRESS(), value);
}

/** OTP_SH_READ2_MR__GET() gets READ2_MR's current value.
 *
 * When reading from READ2_MR, this is mandatory to use.
 *
 * @return current value of READ2_MR
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MR__GET(void)
{
    return HAL_GET32(__OTP_SH_READ2_MR__ADDRESS());
}

/* ------------------------ OTP_SH.READ2_MR.MR_READ2 ------------------------ */


#define OTP_SH_READ2_MR__MR_READ2__Pos                          0                                                                      /*!< Right-most bit position of MR_READ2 in OTP_SH.READ2_MR */
#define OTP_SH_READ2_MR__MR_READ2__Msk                          (0x0000FFFFUL << OTP_SH_READ2_MR__MR_READ2__Pos)                       /*!< Mask for MR_READ2 in OTP_SH.READ2_MR */
#define OTP_SH_READ2_MR__MR_READ2__Shift(v)                     (((v) << OTP_SH_READ2_MR__MR_READ2__Pos) & OTP_SH_READ2_MR__MR_READ2__Msk) /*!< Shift value 'v' into MR_READ2 and mask 'v' to fit it into MR_READ2 field */

/** OTP_SH_READ2_MR__MR_READ2__SET() sets READ2_MR.MR_READ2 to given value.
 *
 * When writing to READ2_MR.MR_READ2, this is recommended to use.
 *
 * @param bf_value new value for READ2_MR.MR_READ2
 */
__OTP_SH_INLINE void OTP_SH_READ2_MR__MR_READ2__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_READ2_MR__GET();
    reg = (reg & ~OTP_SH_READ2_MR__MR_READ2__Msk);
    reg = (reg | (OTP_SH_READ2_MR__MR_READ2__Shift((uint32_t)bf_value)));
    OTP_SH_READ2_MR__SET(reg);
}

/** OTP_SH_READ2_MR__MR_READ2__GET() gets READ2_MR.MR_READ2's current value.
 *
 * When reading from READ2_MR.MR_READ2, this is recommended to use.
 *
 * @return current value of READ2_MR.MR_READ2
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MR__MR_READ2__GET(void)
{
    uint32_t reg = OTP_SH_READ2_MR__GET();
    reg = (reg & OTP_SH_READ2_MR__MR_READ2__Msk);
    reg = (reg >> OTP_SH_READ2_MR__MR_READ2__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_READ2_MR__MR_READ2__MODIFY() modifies READ2_MR.MR_READ2.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.READ2_MR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.READ2_MR
 * @param bf_value new value for READ2_MR.MR_READ2
 * @return new value of OTP_SH.READ2_MR
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MR__MR_READ2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_READ2_MR__MR_READ2__Msk);
    reg = (reg | (OTP_SH_READ2_MR__MR_READ2__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_READ2_MR__MR_READ2__EXTRACT() extracts READ2_MR.MR_READ2.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.READ2_MR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.READ2_MR
 * @return current value of READ2_MR.MR_READ2
 */
__OTP_SH_INLINE uint32_t OTP_SH_READ2_MR__MR_READ2__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_READ2_MR__MR_READ2__Msk);
    reg = (reg >> OTP_SH_READ2_MR__MR_READ2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        OPT_MRAB member of OTP_SH_t                        */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OPT_MRAB__ADDRESS returns the address of member OPT_MRAB.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OPT_MRAB
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OPT_MRAB__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OPT_MRAB)));
}

/** OTP_SH_OPT_MRAB__GET() gets OPT_MRAB's current value.
 *
 * When reading from OPT_MRAB, this is mandatory to use.
 *
 * @return current value of OPT_MRAB
 */
__OTP_SH_INLINE uint32_t OTP_SH_OPT_MRAB__GET(void)
{
    return HAL_GET32(__OTP_SH_OPT_MRAB__ADDRESS());
}

/* ------------------------ OTP_SH.OPT_MRAB.OTP_MRB ------------------------ */


#define OTP_SH_OPT_MRAB__OTP_MRB__Pos                           16                                                                     /*!< Right-most bit position of OTP_MRB in OTP_SH.OPT_MRAB */
#define OTP_SH_OPT_MRAB__OTP_MRB__Msk                           (0x0000FFFFUL << OTP_SH_OPT_MRAB__OTP_MRB__Pos)                        /*!< Mask for OTP_MRB in OTP_SH.OPT_MRAB */
#define OTP_SH_OPT_MRAB__OTP_MRB__Shift(v)                      (((v) << OTP_SH_OPT_MRAB__OTP_MRB__Pos) & OTP_SH_OPT_MRAB__OTP_MRB__Msk) /*!< Shift value 'v' into OTP_MRB and mask 'v' to fit it into OTP_MRB field */

/** OTP_SH_OPT_MRAB__OTP_MRB__GET() gets OPT_MRAB.OTP_MRB's current value.
 *
 * When reading from OPT_MRAB.OTP_MRB, this is recommended to use.
 *
 * @return current value of OPT_MRAB.OTP_MRB
 */
__OTP_SH_INLINE uint32_t OTP_SH_OPT_MRAB__OTP_MRB__GET(void)
{
    uint32_t reg = OTP_SH_OPT_MRAB__GET();
    reg = (reg & OTP_SH_OPT_MRAB__OTP_MRB__Msk);
    reg = (reg >> OTP_SH_OPT_MRAB__OTP_MRB__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OPT_MRAB__OTP_MRB__EXTRACT() extracts OPT_MRAB.OTP_MRB.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OPT_MRAB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OPT_MRAB
 * @return current value of OPT_MRAB.OTP_MRB
 */
__OTP_SH_INLINE uint32_t OTP_SH_OPT_MRAB__OTP_MRB__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OPT_MRAB__OTP_MRB__Msk);
    reg = (reg >> OTP_SH_OPT_MRAB__OTP_MRB__Pos);
    return (uint32_t)reg;
}

/* ------------------------ OTP_SH.OPT_MRAB.OTP_MRA ------------------------ */


#define OTP_SH_OPT_MRAB__OTP_MRA__Pos                           0                                                                      /*!< Right-most bit position of OTP_MRA in OTP_SH.OPT_MRAB */
#define OTP_SH_OPT_MRAB__OTP_MRA__Msk                           (0x0000FFFFUL << OTP_SH_OPT_MRAB__OTP_MRA__Pos)                        /*!< Mask for OTP_MRA in OTP_SH.OPT_MRAB */
#define OTP_SH_OPT_MRAB__OTP_MRA__Shift(v)                      (((v) << OTP_SH_OPT_MRAB__OTP_MRA__Pos) & OTP_SH_OPT_MRAB__OTP_MRA__Msk) /*!< Shift value 'v' into OTP_MRA and mask 'v' to fit it into OTP_MRA field */

/** OTP_SH_OPT_MRAB__OTP_MRA__GET() gets OPT_MRAB.OTP_MRA's current value.
 *
 * When reading from OPT_MRAB.OTP_MRA, this is recommended to use.
 *
 * @return current value of OPT_MRAB.OTP_MRA
 */
__OTP_SH_INLINE uint32_t OTP_SH_OPT_MRAB__OTP_MRA__GET(void)
{
    uint32_t reg = OTP_SH_OPT_MRAB__GET();
    reg = (reg & OTP_SH_OPT_MRAB__OTP_MRA__Msk);
    reg = (reg >> OTP_SH_OPT_MRAB__OTP_MRA__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OPT_MRAB__OTP_MRA__EXTRACT() extracts OPT_MRAB.OTP_MRA.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OPT_MRAB.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OPT_MRAB
 * @return current value of OPT_MRAB.OTP_MRA
 */
__OTP_SH_INLINE uint32_t OTP_SH_OPT_MRAB__OTP_MRA__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OPT_MRAB__OTP_MRA__Msk);
    reg = (reg >> OTP_SH_OPT_MRAB__OTP_MRA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         OPT_MR member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OPT_MR__ADDRESS returns the address of member OPT_MR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OPT_MR
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OPT_MR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OPT_MR)));
}

/** OTP_SH_OPT_MR__GET() gets OPT_MR's current value.
 *
 * When reading from OPT_MR, this is mandatory to use.
 *
 * @return current value of OPT_MR
 */
__OTP_SH_INLINE uint32_t OTP_SH_OPT_MR__GET(void)
{
    return HAL_GET32(__OTP_SH_OPT_MR__ADDRESS());
}

/* -------------------------- OTP_SH.OPT_MR.OTP_MR -------------------------- */


#define OTP_SH_OPT_MR__OTP_MR__Pos                              0                                                                      /*!< Right-most bit position of OTP_MR in OTP_SH.OPT_MR */
#define OTP_SH_OPT_MR__OTP_MR__Msk                              (0x0000FFFFUL << OTP_SH_OPT_MR__OTP_MR__Pos)                           /*!< Mask for OTP_MR in OTP_SH.OPT_MR */
#define OTP_SH_OPT_MR__OTP_MR__Shift(v)                         (((v) << OTP_SH_OPT_MR__OTP_MR__Pos) & OTP_SH_OPT_MR__OTP_MR__Msk)     /*!< Shift value 'v' into OTP_MR and mask 'v' to fit it into OTP_MR field */

/** OTP_SH_OPT_MR__OTP_MR__GET() gets OPT_MR.OTP_MR's current value.
 *
 * When reading from OPT_MR.OTP_MR, this is recommended to use.
 *
 * @return current value of OPT_MR.OTP_MR
 */
__OTP_SH_INLINE uint32_t OTP_SH_OPT_MR__OTP_MR__GET(void)
{
    uint32_t reg = OTP_SH_OPT_MR__GET();
    reg = (reg & OTP_SH_OPT_MR__OTP_MR__Msk);
    reg = (reg >> OTP_SH_OPT_MR__OTP_MR__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OPT_MR__OTP_MR__EXTRACT() extracts OPT_MR.OTP_MR.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OPT_MR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OPT_MR
 * @return current value of OPT_MR.OTP_MR
 */
__OTP_SH_INLINE uint32_t OTP_SH_OPT_MR__OTP_MR__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OPT_MR__OTP_MR__Msk);
    reg = (reg >> OTP_SH_OPT_MR__OTP_MR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         OTP_Q0 member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OTP_Q0__ADDRESS returns the address of member OTP_Q0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OTP_Q0
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OTP_Q0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OTP_Q0)));
}

/** OTP_SH_OTP_Q0__GET() gets OTP_Q0's current value.
 *
 * When reading from OTP_Q0, this is mandatory to use.
 *
 * @return current value of OTP_Q0
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q0__GET(void)
{
    return HAL_GET32(__OTP_SH_OTP_Q0__ADDRESS());
}

/* --------------------------- OTP_SH.OTP_Q0.DATA --------------------------- */

/**
<pre>
  OTP_SH.OTP_Q0.DATA:

    Data read from selected OTP CacheLine word

</pre> */

#define OTP_SH_OTP_Q0__DATA__Pos                                0                                                                      /*!< Right-most bit position of DATA in OTP_SH.OTP_Q0 */
#define OTP_SH_OTP_Q0__DATA__Msk                                (0xFFFFFFFFUL << OTP_SH_OTP_Q0__DATA__Pos)                             /*!< Mask for DATA in OTP_SH.OTP_Q0 */
#define OTP_SH_OTP_Q0__DATA__Shift(v)                           (((v) << OTP_SH_OTP_Q0__DATA__Pos) & OTP_SH_OTP_Q0__DATA__Msk)         /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** OTP_SH_OTP_Q0__DATA__GET() gets OTP_Q0.DATA's current value.
 *
 * When reading from OTP_Q0.DATA, this is recommended to use.
 *
 * @return current value of OTP_Q0.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q0__DATA__GET(void)
{
    uint32_t reg = OTP_SH_OTP_Q0__GET();
    reg = (reg & OTP_SH_OTP_Q0__DATA__Msk);
    reg = (reg >> OTP_SH_OTP_Q0__DATA__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_Q0__DATA__EXTRACT() extracts OTP_Q0.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_Q0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_Q0
 * @return current value of OTP_Q0.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q0__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_Q0__DATA__Msk);
    reg = (reg >> OTP_SH_OTP_Q0__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         OTP_Q1 member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OTP_Q1__ADDRESS returns the address of member OTP_Q1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OTP_Q1
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OTP_Q1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OTP_Q1)));
}

/** OTP_SH_OTP_Q1__GET() gets OTP_Q1's current value.
 *
 * When reading from OTP_Q1, this is mandatory to use.
 *
 * @return current value of OTP_Q1
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q1__GET(void)
{
    return HAL_GET32(__OTP_SH_OTP_Q1__ADDRESS());
}

/* --------------------------- OTP_SH.OTP_Q1.DATA --------------------------- */

/**
<pre>
  OTP_SH.OTP_Q1.DATA:

    Data read from selected OTP CacheLine word

</pre> */

#define OTP_SH_OTP_Q1__DATA__Pos                                0                                                                      /*!< Right-most bit position of DATA in OTP_SH.OTP_Q1 */
#define OTP_SH_OTP_Q1__DATA__Msk                                (0xFFFFFFFFUL << OTP_SH_OTP_Q1__DATA__Pos)                             /*!< Mask for DATA in OTP_SH.OTP_Q1 */
#define OTP_SH_OTP_Q1__DATA__Shift(v)                           (((v) << OTP_SH_OTP_Q1__DATA__Pos) & OTP_SH_OTP_Q1__DATA__Msk)         /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** OTP_SH_OTP_Q1__DATA__GET() gets OTP_Q1.DATA's current value.
 *
 * When reading from OTP_Q1.DATA, this is recommended to use.
 *
 * @return current value of OTP_Q1.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q1__DATA__GET(void)
{
    uint32_t reg = OTP_SH_OTP_Q1__GET();
    reg = (reg & OTP_SH_OTP_Q1__DATA__Msk);
    reg = (reg >> OTP_SH_OTP_Q1__DATA__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_Q1__DATA__EXTRACT() extracts OTP_Q1.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_Q1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_Q1
 * @return current value of OTP_Q1.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q1__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_Q1__DATA__Msk);
    reg = (reg >> OTP_SH_OTP_Q1__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         OTP_Q2 member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OTP_Q2__ADDRESS returns the address of member OTP_Q2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OTP_Q2
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OTP_Q2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OTP_Q2)));
}

/** OTP_SH_OTP_Q2__GET() gets OTP_Q2's current value.
 *
 * When reading from OTP_Q2, this is mandatory to use.
 *
 * @return current value of OTP_Q2
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q2__GET(void)
{
    return HAL_GET32(__OTP_SH_OTP_Q2__ADDRESS());
}

/* --------------------------- OTP_SH.OTP_Q2.DATA --------------------------- */

/**
<pre>
  OTP_SH.OTP_Q2.DATA:

    Data read from selected OTP CacheLine word

</pre> */

#define OTP_SH_OTP_Q2__DATA__Pos                                0                                                                      /*!< Right-most bit position of DATA in OTP_SH.OTP_Q2 */
#define OTP_SH_OTP_Q2__DATA__Msk                                (0xFFFFFFFFUL << OTP_SH_OTP_Q2__DATA__Pos)                             /*!< Mask for DATA in OTP_SH.OTP_Q2 */
#define OTP_SH_OTP_Q2__DATA__Shift(v)                           (((v) << OTP_SH_OTP_Q2__DATA__Pos) & OTP_SH_OTP_Q2__DATA__Msk)         /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** OTP_SH_OTP_Q2__DATA__GET() gets OTP_Q2.DATA's current value.
 *
 * When reading from OTP_Q2.DATA, this is recommended to use.
 *
 * @return current value of OTP_Q2.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q2__DATA__GET(void)
{
    uint32_t reg = OTP_SH_OTP_Q2__GET();
    reg = (reg & OTP_SH_OTP_Q2__DATA__Msk);
    reg = (reg >> OTP_SH_OTP_Q2__DATA__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_Q2__DATA__EXTRACT() extracts OTP_Q2.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_Q2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_Q2
 * @return current value of OTP_Q2.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q2__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_Q2__DATA__Msk);
    reg = (reg >> OTP_SH_OTP_Q2__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         OTP_Q3 member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OTP_Q3__ADDRESS returns the address of member OTP_Q3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OTP_Q3
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OTP_Q3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OTP_Q3)));
}

/** OTP_SH_OTP_Q3__GET() gets OTP_Q3's current value.
 *
 * When reading from OTP_Q3, this is mandatory to use.
 *
 * @return current value of OTP_Q3
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q3__GET(void)
{
    return HAL_GET32(__OTP_SH_OTP_Q3__ADDRESS());
}

/* --------------------------- OTP_SH.OTP_Q3.DATA --------------------------- */

/**
<pre>
  OTP_SH.OTP_Q3.DATA:

    Data read from selected OTP CacheLine word

</pre> */

#define OTP_SH_OTP_Q3__DATA__Pos                                0                                                                      /*!< Right-most bit position of DATA in OTP_SH.OTP_Q3 */
#define OTP_SH_OTP_Q3__DATA__Msk                                (0xFFFFFFFFUL << OTP_SH_OTP_Q3__DATA__Pos)                             /*!< Mask for DATA in OTP_SH.OTP_Q3 */
#define OTP_SH_OTP_Q3__DATA__Shift(v)                           (((v) << OTP_SH_OTP_Q3__DATA__Pos) & OTP_SH_OTP_Q3__DATA__Msk)         /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** OTP_SH_OTP_Q3__DATA__GET() gets OTP_Q3.DATA's current value.
 *
 * When reading from OTP_Q3.DATA, this is recommended to use.
 *
 * @return current value of OTP_Q3.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q3__DATA__GET(void)
{
    uint32_t reg = OTP_SH_OTP_Q3__GET();
    reg = (reg & OTP_SH_OTP_Q3__DATA__Msk);
    reg = (reg >> OTP_SH_OTP_Q3__DATA__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_Q3__DATA__EXTRACT() extracts OTP_Q3.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_Q3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_Q3
 * @return current value of OTP_Q3.DATA
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_Q3__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_Q3__DATA__Msk);
    reg = (reg >> OTP_SH_OTP_Q3__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         INT_RAW member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_INT_RAW__ADDRESS returns the address of member INT_RAW.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of INT_RAW
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_INT_RAW__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, INT_RAW)));
}

/** OTP_SH_INT_RAW__GET() gets INT_RAW's current value.
 *
 * When reading from INT_RAW, this is mandatory to use.
 *
 * @return current value of INT_RAW
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_RAW__GET(void)
{
    return HAL_GET32(__OTP_SH_INT_RAW__ADDRESS());
}

/* --------------------- OTP_SH.INT_RAW.RAW_PROG_FAULT --------------------- */

/**
<pre>
  OTP_SH.INT_RAW.RAW_PROG_FAULT:

    OTP programming at row SR fail

</pre> */

#define OTP_SH_INT_RAW__RAW_PROG_FAULT__Pos                     3                                                                      /*!< Right-most bit position of RAW_PROG_FAULT in OTP_SH.INT_RAW */
#define OTP_SH_INT_RAW__RAW_PROG_FAULT__Msk                     (0x00000001UL << OTP_SH_INT_RAW__RAW_PROG_FAULT__Pos)                  /*!< Mask for RAW_PROG_FAULT in OTP_SH.INT_RAW */
#define OTP_SH_INT_RAW__RAW_PROG_FAULT__Shift(v)                (((v) << OTP_SH_INT_RAW__RAW_PROG_FAULT__Pos) & OTP_SH_INT_RAW__RAW_PROG_FAULT__Msk) /*!< Shift value 'v' into RAW_PROG_FAULT and mask 'v' to fit it into RAW_PROG_FAULT field */

/** OTP_SH_INT_RAW__RAW_PROG_FAULT__GET() gets INT_RAW.RAW_PROG_FAULT's current value.
 *
 * When reading from INT_RAW.RAW_PROG_FAULT, this is recommended to use.
 *
 * @return current value of INT_RAW.RAW_PROG_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_RAW__RAW_PROG_FAULT__GET(void)
{
    uint32_t reg = OTP_SH_INT_RAW__GET();
    reg = (reg & OTP_SH_INT_RAW__RAW_PROG_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_RAW__RAW_PROG_FAULT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_RAW__RAW_PROG_FAULT__EXTRACT() extracts INT_RAW.RAW_PROG_FAULT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_RAW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_RAW
 * @return current value of INT_RAW.RAW_PROG_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_RAW__RAW_PROG_FAULT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_RAW__RAW_PROG_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_RAW__RAW_PROG_FAULT__Pos);
    return (uint32_t)reg;
}

/* --------------------- OTP_SH.INT_RAW.RAW_READ_FAULT --------------------- */


#define OTP_SH_INT_RAW__RAW_READ_FAULT__Pos                     2                                                                      /*!< Right-most bit position of RAW_READ_FAULT in OTP_SH.INT_RAW */
#define OTP_SH_INT_RAW__RAW_READ_FAULT__Msk                     (0x00000001UL << OTP_SH_INT_RAW__RAW_READ_FAULT__Pos)                  /*!< Mask for RAW_READ_FAULT in OTP_SH.INT_RAW */
#define OTP_SH_INT_RAW__RAW_READ_FAULT__Shift(v)                (((v) << OTP_SH_INT_RAW__RAW_READ_FAULT__Pos) & OTP_SH_INT_RAW__RAW_READ_FAULT__Msk) /*!< Shift value 'v' into RAW_READ_FAULT and mask 'v' to fit it into RAW_READ_FAULT field */

/** OTP_SH_INT_RAW__RAW_READ_FAULT__GET() gets INT_RAW.RAW_READ_FAULT's current value.
 *
 * When reading from INT_RAW.RAW_READ_FAULT, this is recommended to use.
 *
 * @return current value of INT_RAW.RAW_READ_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_RAW__RAW_READ_FAULT__GET(void)
{
    uint32_t reg = OTP_SH_INT_RAW__GET();
    reg = (reg & OTP_SH_INT_RAW__RAW_READ_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_RAW__RAW_READ_FAULT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_RAW__RAW_READ_FAULT__EXTRACT() extracts INT_RAW.RAW_READ_FAULT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_RAW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_RAW
 * @return current value of INT_RAW.RAW_READ_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_RAW__RAW_READ_FAULT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_RAW__RAW_READ_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_RAW__RAW_READ_FAULT__Pos);
    return (uint32_t)reg;
}

/* --------------------- OTP_SH.INT_RAW.RAW_INSTR_DONE --------------------- */


#define OTP_SH_INT_RAW__RAW_INSTR_DONE__Pos                     1                                                                      /*!< Right-most bit position of RAW_INSTR_DONE in OTP_SH.INT_RAW */
#define OTP_SH_INT_RAW__RAW_INSTR_DONE__Msk                     (0x00000001UL << OTP_SH_INT_RAW__RAW_INSTR_DONE__Pos)                  /*!< Mask for RAW_INSTR_DONE in OTP_SH.INT_RAW */
#define OTP_SH_INT_RAW__RAW_INSTR_DONE__Shift(v)                (((v) << OTP_SH_INT_RAW__RAW_INSTR_DONE__Pos) & OTP_SH_INT_RAW__RAW_INSTR_DONE__Msk) /*!< Shift value 'v' into RAW_INSTR_DONE and mask 'v' to fit it into RAW_INSTR_DONE field */

/** OTP_SH_INT_RAW__RAW_INSTR_DONE__GET() gets INT_RAW.RAW_INSTR_DONE's current value.
 *
 * When reading from INT_RAW.RAW_INSTR_DONE, this is recommended to use.
 *
 * @return current value of INT_RAW.RAW_INSTR_DONE
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_RAW__RAW_INSTR_DONE__GET(void)
{
    uint32_t reg = OTP_SH_INT_RAW__GET();
    reg = (reg & OTP_SH_INT_RAW__RAW_INSTR_DONE__Msk);
    reg = (reg >> OTP_SH_INT_RAW__RAW_INSTR_DONE__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_RAW__RAW_INSTR_DONE__EXTRACT() extracts INT_RAW.RAW_INSTR_DONE.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_RAW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_RAW
 * @return current value of INT_RAW.RAW_INSTR_DONE
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_RAW__RAW_INSTR_DONE__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_RAW__RAW_INSTR_DONE__Msk);
    reg = (reg >> OTP_SH_INT_RAW__RAW_INSTR_DONE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ OTP_SH.INT_RAW.PWR_STAT ------------------------ */


#define OTP_SH_INT_RAW__PWR_STAT__Pos                           0                                                                      /*!< Right-most bit position of PWR_STAT in OTP_SH.INT_RAW */
#define OTP_SH_INT_RAW__PWR_STAT__Msk                           (0x00000001UL << OTP_SH_INT_RAW__PWR_STAT__Pos)                        /*!< Mask for PWR_STAT in OTP_SH.INT_RAW */
#define OTP_SH_INT_RAW__PWR_STAT__Shift(v)                      (((v) << OTP_SH_INT_RAW__PWR_STAT__Pos) & OTP_SH_INT_RAW__PWR_STAT__Msk) /*!< Shift value 'v' into PWR_STAT and mask 'v' to fit it into PWR_STAT field */

/** OTP_SH_INT_RAW__PWR_STAT__GET() gets INT_RAW.PWR_STAT's current value.
 *
 * When reading from INT_RAW.PWR_STAT, this is recommended to use.
 *
 * @return current value of INT_RAW.PWR_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_RAW__PWR_STAT__GET(void)
{
    uint32_t reg = OTP_SH_INT_RAW__GET();
    reg = (reg & OTP_SH_INT_RAW__PWR_STAT__Msk);
    reg = (reg >> OTP_SH_INT_RAW__PWR_STAT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_RAW__PWR_STAT__EXTRACT() extracts INT_RAW.PWR_STAT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_RAW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_RAW
 * @return current value of INT_RAW.PWR_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_RAW__PWR_STAT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_RAW__PWR_STAT__Msk);
    reg = (reg >> OTP_SH_INT_RAW__PWR_STAT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        INT_MASK member of OTP_SH_t                        */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_INT_MASK__ADDRESS returns the address of member INT_MASK.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of INT_MASK
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_INT_MASK__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, INT_MASK)));
}

/** OTP_SH_INT_MASK__SET() sets INT_MASK to given value.
 *
 * When writing to INT_MASK, this is mandatory to use.
 *
 * @param value new value for INT_MASK
 */
__OTP_SH_INLINE void OTP_SH_INT_MASK__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_INT_MASK__ADDRESS(), value);
}

/** OTP_SH_INT_MASK__GET() gets INT_MASK's current value.
 *
 * When reading from INT_MASK, this is mandatory to use.
 *
 * @return current value of INT_MASK
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__GET(void)
{
    return HAL_GET32(__OTP_SH_INT_MASK__ADDRESS());
}

/* --------------------- OTP_SH.INT_MASK.MSK_PROG_FAULT --------------------- */

/**
<pre>
  OTP_SH.INT_MASK.MSK_PROG_FAULT:

    OTP programming at row SR fail

</pre> */

#define OTP_SH_INT_MASK__MSK_PROG_FAULT__Pos                    3                                                                      /*!< Right-most bit position of MSK_PROG_FAULT in OTP_SH.INT_MASK */
#define OTP_SH_INT_MASK__MSK_PROG_FAULT__Msk                    (0x00000001UL << OTP_SH_INT_MASK__MSK_PROG_FAULT__Pos)                 /*!< Mask for MSK_PROG_FAULT in OTP_SH.INT_MASK */
#define OTP_SH_INT_MASK__MSK_PROG_FAULT__Shift(v)               (((v) << OTP_SH_INT_MASK__MSK_PROG_FAULT__Pos) & OTP_SH_INT_MASK__MSK_PROG_FAULT__Msk) /*!< Shift value 'v' into MSK_PROG_FAULT and mask 'v' to fit it into MSK_PROG_FAULT field */

/** OTP_SH_INT_MASK__MSK_PROG_FAULT__SET() sets INT_MASK.MSK_PROG_FAULT to given value.
 *
 * When writing to INT_MASK.MSK_PROG_FAULT, this is recommended to use.
 *
 * @param bf_value new value for INT_MASK.MSK_PROG_FAULT
 */
__OTP_SH_INLINE void OTP_SH_INT_MASK__MSK_PROG_FAULT__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_INT_MASK__GET();
    reg = (reg & ~OTP_SH_INT_MASK__MSK_PROG_FAULT__Msk);
    reg = (reg | (OTP_SH_INT_MASK__MSK_PROG_FAULT__Shift((uint32_t)bf_value)));
    OTP_SH_INT_MASK__SET(reg);
}

/** OTP_SH_INT_MASK__MSK_PROG_FAULT__GET() gets INT_MASK.MSK_PROG_FAULT's current value.
 *
 * When reading from INT_MASK.MSK_PROG_FAULT, this is recommended to use.
 *
 * @return current value of INT_MASK.MSK_PROG_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_PROG_FAULT__GET(void)
{
    uint32_t reg = OTP_SH_INT_MASK__GET();
    reg = (reg & OTP_SH_INT_MASK__MSK_PROG_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_MASK__MSK_PROG_FAULT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_MASK__MSK_PROG_FAULT__MODIFY() modifies INT_MASK.MSK_PROG_FAULT.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.INT_MASK.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.INT_MASK
 * @param bf_value new value for INT_MASK.MSK_PROG_FAULT
 * @return new value of OTP_SH.INT_MASK
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_PROG_FAULT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_INT_MASK__MSK_PROG_FAULT__Msk);
    reg = (reg | (OTP_SH_INT_MASK__MSK_PROG_FAULT__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_INT_MASK__MSK_PROG_FAULT__EXTRACT() extracts INT_MASK.MSK_PROG_FAULT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_MASK.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_MASK
 * @return current value of INT_MASK.MSK_PROG_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_PROG_FAULT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_MASK__MSK_PROG_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_MASK__MSK_PROG_FAULT__Pos);
    return (uint32_t)reg;
}

/* --------------------- OTP_SH.INT_MASK.MSK_READ_FAULT --------------------- */


#define OTP_SH_INT_MASK__MSK_READ_FAULT__Pos                    2                                                                      /*!< Right-most bit position of MSK_READ_FAULT in OTP_SH.INT_MASK */
#define OTP_SH_INT_MASK__MSK_READ_FAULT__Msk                    (0x00000001UL << OTP_SH_INT_MASK__MSK_READ_FAULT__Pos)                 /*!< Mask for MSK_READ_FAULT in OTP_SH.INT_MASK */
#define OTP_SH_INT_MASK__MSK_READ_FAULT__Shift(v)               (((v) << OTP_SH_INT_MASK__MSK_READ_FAULT__Pos) & OTP_SH_INT_MASK__MSK_READ_FAULT__Msk) /*!< Shift value 'v' into MSK_READ_FAULT and mask 'v' to fit it into MSK_READ_FAULT field */

/** OTP_SH_INT_MASK__MSK_READ_FAULT__SET() sets INT_MASK.MSK_READ_FAULT to given value.
 *
 * When writing to INT_MASK.MSK_READ_FAULT, this is recommended to use.
 *
 * @param bf_value new value for INT_MASK.MSK_READ_FAULT
 */
__OTP_SH_INLINE void OTP_SH_INT_MASK__MSK_READ_FAULT__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_INT_MASK__GET();
    reg = (reg & ~OTP_SH_INT_MASK__MSK_READ_FAULT__Msk);
    reg = (reg | (OTP_SH_INT_MASK__MSK_READ_FAULT__Shift((uint32_t)bf_value)));
    OTP_SH_INT_MASK__SET(reg);
}

/** OTP_SH_INT_MASK__MSK_READ_FAULT__GET() gets INT_MASK.MSK_READ_FAULT's current value.
 *
 * When reading from INT_MASK.MSK_READ_FAULT, this is recommended to use.
 *
 * @return current value of INT_MASK.MSK_READ_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_READ_FAULT__GET(void)
{
    uint32_t reg = OTP_SH_INT_MASK__GET();
    reg = (reg & OTP_SH_INT_MASK__MSK_READ_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_MASK__MSK_READ_FAULT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_MASK__MSK_READ_FAULT__MODIFY() modifies INT_MASK.MSK_READ_FAULT.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.INT_MASK.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.INT_MASK
 * @param bf_value new value for INT_MASK.MSK_READ_FAULT
 * @return new value of OTP_SH.INT_MASK
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_READ_FAULT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_INT_MASK__MSK_READ_FAULT__Msk);
    reg = (reg | (OTP_SH_INT_MASK__MSK_READ_FAULT__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_INT_MASK__MSK_READ_FAULT__EXTRACT() extracts INT_MASK.MSK_READ_FAULT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_MASK.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_MASK
 * @return current value of INT_MASK.MSK_READ_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_READ_FAULT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_MASK__MSK_READ_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_MASK__MSK_READ_FAULT__Pos);
    return (uint32_t)reg;
}

/* --------------------- OTP_SH.INT_MASK.MSK_INSTR_DONE --------------------- */


#define OTP_SH_INT_MASK__MSK_INSTR_DONE__Pos                    1                                                                      /*!< Right-most bit position of MSK_INSTR_DONE in OTP_SH.INT_MASK */
#define OTP_SH_INT_MASK__MSK_INSTR_DONE__Msk                    (0x00000001UL << OTP_SH_INT_MASK__MSK_INSTR_DONE__Pos)                 /*!< Mask for MSK_INSTR_DONE in OTP_SH.INT_MASK */
#define OTP_SH_INT_MASK__MSK_INSTR_DONE__Shift(v)               (((v) << OTP_SH_INT_MASK__MSK_INSTR_DONE__Pos) & OTP_SH_INT_MASK__MSK_INSTR_DONE__Msk) /*!< Shift value 'v' into MSK_INSTR_DONE and mask 'v' to fit it into MSK_INSTR_DONE field */

/** OTP_SH_INT_MASK__MSK_INSTR_DONE__SET() sets INT_MASK.MSK_INSTR_DONE to given value.
 *
 * When writing to INT_MASK.MSK_INSTR_DONE, this is recommended to use.
 *
 * @param bf_value new value for INT_MASK.MSK_INSTR_DONE
 */
__OTP_SH_INLINE void OTP_SH_INT_MASK__MSK_INSTR_DONE__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_INT_MASK__GET();
    reg = (reg & ~OTP_SH_INT_MASK__MSK_INSTR_DONE__Msk);
    reg = (reg | (OTP_SH_INT_MASK__MSK_INSTR_DONE__Shift((uint32_t)bf_value)));
    OTP_SH_INT_MASK__SET(reg);
}

/** OTP_SH_INT_MASK__MSK_INSTR_DONE__GET() gets INT_MASK.MSK_INSTR_DONE's current value.
 *
 * When reading from INT_MASK.MSK_INSTR_DONE, this is recommended to use.
 *
 * @return current value of INT_MASK.MSK_INSTR_DONE
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_INSTR_DONE__GET(void)
{
    uint32_t reg = OTP_SH_INT_MASK__GET();
    reg = (reg & OTP_SH_INT_MASK__MSK_INSTR_DONE__Msk);
    reg = (reg >> OTP_SH_INT_MASK__MSK_INSTR_DONE__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_MASK__MSK_INSTR_DONE__MODIFY() modifies INT_MASK.MSK_INSTR_DONE.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.INT_MASK.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.INT_MASK
 * @param bf_value new value for INT_MASK.MSK_INSTR_DONE
 * @return new value of OTP_SH.INT_MASK
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_INSTR_DONE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_INT_MASK__MSK_INSTR_DONE__Msk);
    reg = (reg | (OTP_SH_INT_MASK__MSK_INSTR_DONE__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_INT_MASK__MSK_INSTR_DONE__EXTRACT() extracts INT_MASK.MSK_INSTR_DONE.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_MASK.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_MASK
 * @return current value of INT_MASK.MSK_INSTR_DONE
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_INSTR_DONE__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_MASK__MSK_INSTR_DONE__Msk);
    reg = (reg >> OTP_SH_INT_MASK__MSK_INSTR_DONE__Pos);
    return (uint32_t)reg;
}

/* ---------------------- OTP_SH.INT_MASK.MSK_PWR_STAT ---------------------- */


#define OTP_SH_INT_MASK__MSK_PWR_STAT__Pos                      0                                                                      /*!< Right-most bit position of MSK_PWR_STAT in OTP_SH.INT_MASK */
#define OTP_SH_INT_MASK__MSK_PWR_STAT__Msk                      (0x00000001UL << OTP_SH_INT_MASK__MSK_PWR_STAT__Pos)                   /*!< Mask for MSK_PWR_STAT in OTP_SH.INT_MASK */
#define OTP_SH_INT_MASK__MSK_PWR_STAT__Shift(v)                 (((v) << OTP_SH_INT_MASK__MSK_PWR_STAT__Pos) & OTP_SH_INT_MASK__MSK_PWR_STAT__Msk) /*!< Shift value 'v' into MSK_PWR_STAT and mask 'v' to fit it into MSK_PWR_STAT field */

/** OTP_SH_INT_MASK__MSK_PWR_STAT__SET() sets INT_MASK.MSK_PWR_STAT to given value.
 *
 * When writing to INT_MASK.MSK_PWR_STAT, this is recommended to use.
 *
 * @param bf_value new value for INT_MASK.MSK_PWR_STAT
 */
__OTP_SH_INLINE void OTP_SH_INT_MASK__MSK_PWR_STAT__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_INT_MASK__GET();
    reg = (reg & ~OTP_SH_INT_MASK__MSK_PWR_STAT__Msk);
    reg = (reg | (OTP_SH_INT_MASK__MSK_PWR_STAT__Shift((uint32_t)bf_value)));
    OTP_SH_INT_MASK__SET(reg);
}

/** OTP_SH_INT_MASK__MSK_PWR_STAT__GET() gets INT_MASK.MSK_PWR_STAT's current value.
 *
 * When reading from INT_MASK.MSK_PWR_STAT, this is recommended to use.
 *
 * @return current value of INT_MASK.MSK_PWR_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_PWR_STAT__GET(void)
{
    uint32_t reg = OTP_SH_INT_MASK__GET();
    reg = (reg & OTP_SH_INT_MASK__MSK_PWR_STAT__Msk);
    reg = (reg >> OTP_SH_INT_MASK__MSK_PWR_STAT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_MASK__MSK_PWR_STAT__MODIFY() modifies INT_MASK.MSK_PWR_STAT.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.INT_MASK.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.INT_MASK
 * @param bf_value new value for INT_MASK.MSK_PWR_STAT
 * @return new value of OTP_SH.INT_MASK
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_PWR_STAT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_INT_MASK__MSK_PWR_STAT__Msk);
    reg = (reg | (OTP_SH_INT_MASK__MSK_PWR_STAT__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_INT_MASK__MSK_PWR_STAT__EXTRACT() extracts INT_MASK.MSK_PWR_STAT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_MASK.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_MASK
 * @return current value of INT_MASK.MSK_PWR_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_MASK__MSK_PWR_STAT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_MASK__MSK_PWR_STAT__Msk);
    reg = (reg >> OTP_SH_INT_MASK__MSK_PWR_STAT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       INT_ACTIVE member of OTP_SH_t                       */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_INT_ACTIVE__ADDRESS returns the address of member INT_ACTIVE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of INT_ACTIVE
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_INT_ACTIVE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, INT_ACTIVE)));
}

/** OTP_SH_INT_ACTIVE__GET() gets INT_ACTIVE's current value.
 *
 * When reading from INT_ACTIVE, this is mandatory to use.
 *
 * @return current value of INT_ACTIVE
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE__GET(void)
{
    return HAL_GET32(__OTP_SH_INT_ACTIVE__ADDRESS());
}

/* ---------------------- OTP_SH.INT_ACTIVE.PROG_FAULT ---------------------- */


#define OTP_SH_INT_ACTIVE__PROG_FAULT__Pos                      3                                                                      /*!< Right-most bit position of PROG_FAULT in OTP_SH.INT_ACTIVE */
#define OTP_SH_INT_ACTIVE__PROG_FAULT__Msk                      (0x00000001UL << OTP_SH_INT_ACTIVE__PROG_FAULT__Pos)                   /*!< Mask for PROG_FAULT in OTP_SH.INT_ACTIVE */
#define OTP_SH_INT_ACTIVE__PROG_FAULT__Shift(v)                 (((v) << OTP_SH_INT_ACTIVE__PROG_FAULT__Pos) & OTP_SH_INT_ACTIVE__PROG_FAULT__Msk) /*!< Shift value 'v' into PROG_FAULT and mask 'v' to fit it into PROG_FAULT field */

/** OTP_SH_INT_ACTIVE__PROG_FAULT__GET() gets INT_ACTIVE.PROG_FAULT's current value.
 *
 * When reading from INT_ACTIVE.PROG_FAULT, this is recommended to use.
 *
 * @return current value of INT_ACTIVE.PROG_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE__PROG_FAULT__GET(void)
{
    uint32_t reg = OTP_SH_INT_ACTIVE__GET();
    reg = (reg & OTP_SH_INT_ACTIVE__PROG_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE__PROG_FAULT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_ACTIVE__PROG_FAULT__EXTRACT() extracts INT_ACTIVE.PROG_FAULT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_ACTIVE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE
 * @return current value of INT_ACTIVE.PROG_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE__PROG_FAULT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_ACTIVE__PROG_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE__PROG_FAULT__Pos);
    return (uint32_t)reg;
}

/* ---------------------- OTP_SH.INT_ACTIVE.READ_FAULT ---------------------- */


#define OTP_SH_INT_ACTIVE__READ_FAULT__Pos                      2                                                                      /*!< Right-most bit position of READ_FAULT in OTP_SH.INT_ACTIVE */
#define OTP_SH_INT_ACTIVE__READ_FAULT__Msk                      (0x00000001UL << OTP_SH_INT_ACTIVE__READ_FAULT__Pos)                   /*!< Mask for READ_FAULT in OTP_SH.INT_ACTIVE */
#define OTP_SH_INT_ACTIVE__READ_FAULT__Shift(v)                 (((v) << OTP_SH_INT_ACTIVE__READ_FAULT__Pos) & OTP_SH_INT_ACTIVE__READ_FAULT__Msk) /*!< Shift value 'v' into READ_FAULT and mask 'v' to fit it into READ_FAULT field */

/** OTP_SH_INT_ACTIVE__READ_FAULT__GET() gets INT_ACTIVE.READ_FAULT's current value.
 *
 * When reading from INT_ACTIVE.READ_FAULT, this is recommended to use.
 *
 * @return current value of INT_ACTIVE.READ_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE__READ_FAULT__GET(void)
{
    uint32_t reg = OTP_SH_INT_ACTIVE__GET();
    reg = (reg & OTP_SH_INT_ACTIVE__READ_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE__READ_FAULT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_ACTIVE__READ_FAULT__EXTRACT() extracts INT_ACTIVE.READ_FAULT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_ACTIVE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE
 * @return current value of INT_ACTIVE.READ_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE__READ_FAULT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_ACTIVE__READ_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE__READ_FAULT__Pos);
    return (uint32_t)reg;
}

/* ---------------------- OTP_SH.INT_ACTIVE.INSTR_DONE ---------------------- */


#define OTP_SH_INT_ACTIVE__INSTR_DONE__Pos                      1                                                                      /*!< Right-most bit position of INSTR_DONE in OTP_SH.INT_ACTIVE */
#define OTP_SH_INT_ACTIVE__INSTR_DONE__Msk                      (0x00000001UL << OTP_SH_INT_ACTIVE__INSTR_DONE__Pos)                   /*!< Mask for INSTR_DONE in OTP_SH.INT_ACTIVE */
#define OTP_SH_INT_ACTIVE__INSTR_DONE__Shift(v)                 (((v) << OTP_SH_INT_ACTIVE__INSTR_DONE__Pos) & OTP_SH_INT_ACTIVE__INSTR_DONE__Msk) /*!< Shift value 'v' into INSTR_DONE and mask 'v' to fit it into INSTR_DONE field */

/** OTP_SH_INT_ACTIVE__INSTR_DONE__GET() gets INT_ACTIVE.INSTR_DONE's current value.
 *
 * When reading from INT_ACTIVE.INSTR_DONE, this is recommended to use.
 *
 * @return current value of INT_ACTIVE.INSTR_DONE
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE__INSTR_DONE__GET(void)
{
    uint32_t reg = OTP_SH_INT_ACTIVE__GET();
    reg = (reg & OTP_SH_INT_ACTIVE__INSTR_DONE__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE__INSTR_DONE__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_ACTIVE__INSTR_DONE__EXTRACT() extracts INT_ACTIVE.INSTR_DONE.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_ACTIVE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE
 * @return current value of INT_ACTIVE.INSTR_DONE
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE__INSTR_DONE__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_ACTIVE__INSTR_DONE__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE__INSTR_DONE__Pos);
    return (uint32_t)reg;
}

/* ----------------------- OTP_SH.INT_ACTIVE.PWR_STAT ----------------------- */


#define OTP_SH_INT_ACTIVE__PWR_STAT__Pos                        0                                                                      /*!< Right-most bit position of PWR_STAT in OTP_SH.INT_ACTIVE */
#define OTP_SH_INT_ACTIVE__PWR_STAT__Msk                        (0x00000001UL << OTP_SH_INT_ACTIVE__PWR_STAT__Pos)                     /*!< Mask for PWR_STAT in OTP_SH.INT_ACTIVE */
#define OTP_SH_INT_ACTIVE__PWR_STAT__Shift(v)                   (((v) << OTP_SH_INT_ACTIVE__PWR_STAT__Pos) & OTP_SH_INT_ACTIVE__PWR_STAT__Msk) /*!< Shift value 'v' into PWR_STAT and mask 'v' to fit it into PWR_STAT field */

/** OTP_SH_INT_ACTIVE__PWR_STAT__GET() gets INT_ACTIVE.PWR_STAT's current value.
 *
 * When reading from INT_ACTIVE.PWR_STAT, this is recommended to use.
 *
 * @return current value of INT_ACTIVE.PWR_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE__PWR_STAT__GET(void)
{
    uint32_t reg = OTP_SH_INT_ACTIVE__GET();
    reg = (reg & OTP_SH_INT_ACTIVE__PWR_STAT__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE__PWR_STAT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_INT_ACTIVE__PWR_STAT__EXTRACT() extracts INT_ACTIVE.PWR_STAT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_ACTIVE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE
 * @return current value of INT_ACTIVE.PWR_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE__PWR_STAT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_ACTIVE__PWR_STAT__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE__PWR_STAT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     INT_ACTIVE_CLR member of OTP_SH_t                     */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_INT_ACTIVE_CLR__ADDRESS returns the address of member INT_ACTIVE_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of INT_ACTIVE_CLR
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_INT_ACTIVE_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, INT_ACTIVE_CLR)));
}

/** OTP_SH_INT_ACTIVE_CLR__SET() sets INT_ACTIVE_CLR to given value.
 *
 * When writing to INT_ACTIVE_CLR, this is mandatory to use.
 *
 * @param value new value for INT_ACTIVE_CLR
 */
__OTP_SH_INLINE void OTP_SH_INT_ACTIVE_CLR__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_INT_ACTIVE_CLR__ADDRESS(), value);
}


/* -------------------- OTP_SH.INT_ACTIVE_CLR.PROG_FAULT -------------------- */


#define OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Pos                  3                                                                      /*!< Right-most bit position of PROG_FAULT in OTP_SH.INT_ACTIVE_CLR */
#define OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Msk                  (0x00000001UL << OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Pos)               /*!< Mask for PROG_FAULT in OTP_SH.INT_ACTIVE_CLR */
#define OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Shift(v)             (((v) << OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Pos) & OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Msk) /*!< Shift value 'v' into PROG_FAULT and mask 'v' to fit it into PROG_FAULT field */

/** OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__SET() sets INT_ACTIVE_CLR.PROG_FAULT to given value.
 *
 * When writing to INT_ACTIVE_CLR.PROG_FAULT, this is recommended to use.
 *
 * @param bf_value new value for INT_ACTIVE_CLR.PROG_FAULT
 */
__OTP_SH_INLINE void OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Shift((uint32_t)bf_value);
    OTP_SH_INT_ACTIVE_CLR__SET(reg);
}


/** OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__MODIFY() modifies INT_ACTIVE_CLR.PROG_FAULT.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.INT_ACTIVE_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE_CLR
 * @param bf_value new value for INT_ACTIVE_CLR.PROG_FAULT
 * @return new value of OTP_SH.INT_ACTIVE_CLR
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Msk);
    reg = (reg | (OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__EXTRACT() extracts INT_ACTIVE_CLR.PROG_FAULT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_ACTIVE_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE_CLR
 * @return current value of INT_ACTIVE_CLR.PROG_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE_CLR__PROG_FAULT__Pos);
    return (uint32_t)reg;
}

/* -------------------- OTP_SH.INT_ACTIVE_CLR.READ_FAULT -------------------- */


#define OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Pos                  2                                                                      /*!< Right-most bit position of READ_FAULT in OTP_SH.INT_ACTIVE_CLR */
#define OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Msk                  (0x00000001UL << OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Pos)               /*!< Mask for READ_FAULT in OTP_SH.INT_ACTIVE_CLR */
#define OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Shift(v)             (((v) << OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Pos) & OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Msk) /*!< Shift value 'v' into READ_FAULT and mask 'v' to fit it into READ_FAULT field */

/** OTP_SH_INT_ACTIVE_CLR__READ_FAULT__SET() sets INT_ACTIVE_CLR.READ_FAULT to given value.
 *
 * When writing to INT_ACTIVE_CLR.READ_FAULT, this is recommended to use.
 *
 * @param bf_value new value for INT_ACTIVE_CLR.READ_FAULT
 */
__OTP_SH_INLINE void OTP_SH_INT_ACTIVE_CLR__READ_FAULT__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Shift((uint32_t)bf_value);
    OTP_SH_INT_ACTIVE_CLR__SET(reg);
}


/** OTP_SH_INT_ACTIVE_CLR__READ_FAULT__MODIFY() modifies INT_ACTIVE_CLR.READ_FAULT.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.INT_ACTIVE_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE_CLR
 * @param bf_value new value for INT_ACTIVE_CLR.READ_FAULT
 * @return new value of OTP_SH.INT_ACTIVE_CLR
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE_CLR__READ_FAULT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Msk);
    reg = (reg | (OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_INT_ACTIVE_CLR__READ_FAULT__EXTRACT() extracts INT_ACTIVE_CLR.READ_FAULT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_ACTIVE_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE_CLR
 * @return current value of INT_ACTIVE_CLR.READ_FAULT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE_CLR__READ_FAULT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE_CLR__READ_FAULT__Pos);
    return (uint32_t)reg;
}

/* -------------------- OTP_SH.INT_ACTIVE_CLR.INSTR_DONE -------------------- */


#define OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Pos                  1                                                                      /*!< Right-most bit position of INSTR_DONE in OTP_SH.INT_ACTIVE_CLR */
#define OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Msk                  (0x00000001UL << OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Pos)               /*!< Mask for INSTR_DONE in OTP_SH.INT_ACTIVE_CLR */
#define OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Shift(v)             (((v) << OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Pos) & OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Msk) /*!< Shift value 'v' into INSTR_DONE and mask 'v' to fit it into INSTR_DONE field */

/** OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__SET() sets INT_ACTIVE_CLR.INSTR_DONE to given value.
 *
 * When writing to INT_ACTIVE_CLR.INSTR_DONE, this is recommended to use.
 *
 * @param bf_value new value for INT_ACTIVE_CLR.INSTR_DONE
 */
__OTP_SH_INLINE void OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Shift((uint32_t)bf_value);
    OTP_SH_INT_ACTIVE_CLR__SET(reg);
}


/** OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__MODIFY() modifies INT_ACTIVE_CLR.INSTR_DONE.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.INT_ACTIVE_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE_CLR
 * @param bf_value new value for INT_ACTIVE_CLR.INSTR_DONE
 * @return new value of OTP_SH.INT_ACTIVE_CLR
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Msk);
    reg = (reg | (OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__EXTRACT() extracts INT_ACTIVE_CLR.INSTR_DONE.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_ACTIVE_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE_CLR
 * @return current value of INT_ACTIVE_CLR.INSTR_DONE
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE_CLR__INSTR_DONE__Pos);
    return (uint32_t)reg;
}

/* --------------------- OTP_SH.INT_ACTIVE_CLR.PWR_STAT --------------------- */


#define OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Pos                    0                                                                      /*!< Right-most bit position of PWR_STAT in OTP_SH.INT_ACTIVE_CLR */
#define OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Msk                    (0x00000001UL << OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Pos)                 /*!< Mask for PWR_STAT in OTP_SH.INT_ACTIVE_CLR */
#define OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Shift(v)               (((v) << OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Pos) & OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Msk) /*!< Shift value 'v' into PWR_STAT and mask 'v' to fit it into PWR_STAT field */

/** OTP_SH_INT_ACTIVE_CLR__PWR_STAT__SET() sets INT_ACTIVE_CLR.PWR_STAT to given value.
 *
 * When writing to INT_ACTIVE_CLR.PWR_STAT, this is recommended to use.
 *
 * @param bf_value new value for INT_ACTIVE_CLR.PWR_STAT
 */
__OTP_SH_INLINE void OTP_SH_INT_ACTIVE_CLR__PWR_STAT__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Shift((uint32_t)bf_value);
    OTP_SH_INT_ACTIVE_CLR__SET(reg);
}


/** OTP_SH_INT_ACTIVE_CLR__PWR_STAT__MODIFY() modifies INT_ACTIVE_CLR.PWR_STAT.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.INT_ACTIVE_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE_CLR
 * @param bf_value new value for INT_ACTIVE_CLR.PWR_STAT
 * @return new value of OTP_SH.INT_ACTIVE_CLR
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE_CLR__PWR_STAT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Msk);
    reg = (reg | (OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_INT_ACTIVE_CLR__PWR_STAT__EXTRACT() extracts INT_ACTIVE_CLR.PWR_STAT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.INT_ACTIVE_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.INT_ACTIVE_CLR
 * @return current value of INT_ACTIVE_CLR.PWR_STAT
 */
__OTP_SH_INLINE uint32_t OTP_SH_INT_ACTIVE_CLR__PWR_STAT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Msk);
    reg = (reg >> OTP_SH_INT_ACTIVE_CLR__PWR_STAT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       OTP_PWRUP_C member of OTP_SH_t                       */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OTP_PWRUP_C__ADDRESS returns the address of member OTP_PWRUP_C.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OTP_PWRUP_C
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OTP_PWRUP_C__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OTP_PWRUP_C)));
}

/** OTP_SH_OTP_PWRUP_C__SET() sets OTP_PWRUP_C to given value.
 *
 * When writing to OTP_PWRUP_C, this is mandatory to use.
 *
 * @param value new value for OTP_PWRUP_C
 */
__OTP_SH_INLINE void OTP_SH_OTP_PWRUP_C__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_OTP_PWRUP_C__ADDRESS(), value);
}

/** OTP_SH_OTP_PWRUP_C__GET() gets OTP_PWRUP_C's current value.
 *
 * When reading from OTP_PWRUP_C, this is mandatory to use.
 *
 * @return current value of OTP_PWRUP_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PWRUP_C__GET(void)
{
    return HAL_GET32(__OTP_SH_OTP_PWRUP_C__ADDRESS());
}

/* ------------------------ OTP_SH.OTP_PWRUP_C.TRESR ------------------------ */

/**
<pre>
  OTP_SH.OTP_PWRUP_C.TRESR:

    Clear bit for BOOT_FAIL_FAULT Interrupt.

</pre> */

#define OTP_SH_OTP_PWRUP_C__TRESR__Pos                          16                                                                     /*!< Right-most bit position of TRESR in OTP_SH.OTP_PWRUP_C */
#define OTP_SH_OTP_PWRUP_C__TRESR__Msk                          (0x000000FFUL << OTP_SH_OTP_PWRUP_C__TRESR__Pos)                       /*!< Mask for TRESR in OTP_SH.OTP_PWRUP_C */
#define OTP_SH_OTP_PWRUP_C__TRESR__Shift(v)                     (((v) << OTP_SH_OTP_PWRUP_C__TRESR__Pos) & OTP_SH_OTP_PWRUP_C__TRESR__Msk) /*!< Shift value 'v' into TRESR and mask 'v' to fit it into TRESR field */

/** OTP_SH_OTP_PWRUP_C__TRESR__SET() sets OTP_PWRUP_C.TRESR to given value.
 *
 * When writing to OTP_PWRUP_C.TRESR, this is recommended to use.
 *
 * @param bf_value new value for OTP_PWRUP_C.TRESR
 */
__OTP_SH_INLINE void OTP_SH_OTP_PWRUP_C__TRESR__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_PWRUP_C__GET();
    reg = (reg & ~OTP_SH_OTP_PWRUP_C__TRESR__Msk);
    reg = (reg | (OTP_SH_OTP_PWRUP_C__TRESR__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_PWRUP_C__SET(reg);
}

/** OTP_SH_OTP_PWRUP_C__TRESR__GET() gets OTP_PWRUP_C.TRESR's current value.
 *
 * When reading from OTP_PWRUP_C.TRESR, this is recommended to use.
 *
 * @return current value of OTP_PWRUP_C.TRESR
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PWRUP_C__TRESR__GET(void)
{
    uint32_t reg = OTP_SH_OTP_PWRUP_C__GET();
    reg = (reg & OTP_SH_OTP_PWRUP_C__TRESR__Msk);
    reg = (reg >> OTP_SH_OTP_PWRUP_C__TRESR__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_PWRUP_C__TRESR__MODIFY() modifies OTP_PWRUP_C.TRESR.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_PWRUP_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_PWRUP_C
 * @param bf_value new value for OTP_PWRUP_C.TRESR
 * @return new value of OTP_SH.OTP_PWRUP_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PWRUP_C__TRESR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_PWRUP_C__TRESR__Msk);
    reg = (reg | (OTP_SH_OTP_PWRUP_C__TRESR__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_PWRUP_C__TRESR__EXTRACT() extracts OTP_PWRUP_C.TRESR.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_PWRUP_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_PWRUP_C
 * @return current value of OTP_PWRUP_C.TRESR
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PWRUP_C__TRESR__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_PWRUP_C__TRESR__Msk);
    reg = (reg >> OTP_SH_OTP_PWRUP_C__TRESR__Pos);
    return (uint32_t)reg;
}

/* ---------------------- OTP_SH.OTP_PWRUP_C.TPUR_PSR ---------------------- */

/**
<pre>
  OTP_SH.OTP_PWRUP_C.TPUR_PSR:

    Clear bit for BOOT_FAIL_FAULT Interrupt.

</pre> */

#define OTP_SH_OTP_PWRUP_C__TPUR_PSR__Pos                       0                                                                      /*!< Right-most bit position of TPUR_PSR in OTP_SH.OTP_PWRUP_C */
#define OTP_SH_OTP_PWRUP_C__TPUR_PSR__Msk                       (0x0000FFFFUL << OTP_SH_OTP_PWRUP_C__TPUR_PSR__Pos)                    /*!< Mask for TPUR_PSR in OTP_SH.OTP_PWRUP_C */
#define OTP_SH_OTP_PWRUP_C__TPUR_PSR__Shift(v)                  (((v) << OTP_SH_OTP_PWRUP_C__TPUR_PSR__Pos) & OTP_SH_OTP_PWRUP_C__TPUR_PSR__Msk) /*!< Shift value 'v' into TPUR_PSR and mask 'v' to fit it into TPUR_PSR field */

/** OTP_SH_OTP_PWRUP_C__TPUR_PSR__SET() sets OTP_PWRUP_C.TPUR_PSR to given value.
 *
 * When writing to OTP_PWRUP_C.TPUR_PSR, this is recommended to use.
 *
 * @param bf_value new value for OTP_PWRUP_C.TPUR_PSR
 */
__OTP_SH_INLINE void OTP_SH_OTP_PWRUP_C__TPUR_PSR__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_PWRUP_C__GET();
    reg = (reg & ~OTP_SH_OTP_PWRUP_C__TPUR_PSR__Msk);
    reg = (reg | (OTP_SH_OTP_PWRUP_C__TPUR_PSR__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_PWRUP_C__SET(reg);
}

/** OTP_SH_OTP_PWRUP_C__TPUR_PSR__GET() gets OTP_PWRUP_C.TPUR_PSR's current value.
 *
 * When reading from OTP_PWRUP_C.TPUR_PSR, this is recommended to use.
 *
 * @return current value of OTP_PWRUP_C.TPUR_PSR
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PWRUP_C__TPUR_PSR__GET(void)
{
    uint32_t reg = OTP_SH_OTP_PWRUP_C__GET();
    reg = (reg & OTP_SH_OTP_PWRUP_C__TPUR_PSR__Msk);
    reg = (reg >> OTP_SH_OTP_PWRUP_C__TPUR_PSR__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_PWRUP_C__TPUR_PSR__MODIFY() modifies OTP_PWRUP_C.TPUR_PSR.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_PWRUP_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_PWRUP_C
 * @param bf_value new value for OTP_PWRUP_C.TPUR_PSR
 * @return new value of OTP_SH.OTP_PWRUP_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PWRUP_C__TPUR_PSR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_PWRUP_C__TPUR_PSR__Msk);
    reg = (reg | (OTP_SH_OTP_PWRUP_C__TPUR_PSR__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_PWRUP_C__TPUR_PSR__EXTRACT() extracts OTP_PWRUP_C.TPUR_PSR.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_PWRUP_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_PWRUP_C
 * @return current value of OTP_PWRUP_C.TPUR_PSR
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PWRUP_C__TPUR_PSR__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_PWRUP_C__TPUR_PSR__Msk);
    reg = (reg >> OTP_SH_OTP_PWRUP_C__TPUR_PSR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       OTP_PROG_C member of OTP_SH_t                       */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OTP_PROG_C__ADDRESS returns the address of member OTP_PROG_C.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OTP_PROG_C
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OTP_PROG_C__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OTP_PROG_C)));
}

/** OTP_SH_OTP_PROG_C__SET() sets OTP_PROG_C to given value.
 *
 * When writing to OTP_PROG_C, this is mandatory to use.
 *
 * @param value new value for OTP_PROG_C
 */
__OTP_SH_INLINE void OTP_SH_OTP_PROG_C__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_OTP_PROG_C__ADDRESS(), value);
}

/** OTP_SH_OTP_PROG_C__GET() gets OTP_PROG_C's current value.
 *
 * When reading from OTP_PROG_C, this is mandatory to use.
 *
 * @return current value of OTP_PROG_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PROG_C__GET(void)
{
    return HAL_GET32(__OTP_SH_OTP_PROG_C__ADDRESS());
}

/* ---------------------- OTP_SH.OTP_PROG_C.PROG_PULSE ---------------------- */


#define OTP_SH_OTP_PROG_C__PROG_PULSE__Pos                      16                                                                     /*!< Right-most bit position of PROG_PULSE in OTP_SH.OTP_PROG_C */
#define OTP_SH_OTP_PROG_C__PROG_PULSE__Msk                      (0x0000FFFFUL << OTP_SH_OTP_PROG_C__PROG_PULSE__Pos)                   /*!< Mask for PROG_PULSE in OTP_SH.OTP_PROG_C */
#define OTP_SH_OTP_PROG_C__PROG_PULSE__Shift(v)                 (((v) << OTP_SH_OTP_PROG_C__PROG_PULSE__Pos) & OTP_SH_OTP_PROG_C__PROG_PULSE__Msk) /*!< Shift value 'v' into PROG_PULSE and mask 'v' to fit it into PROG_PULSE field */

/** OTP_SH_OTP_PROG_C__PROG_PULSE__SET() sets OTP_PROG_C.PROG_PULSE to given value.
 *
 * When writing to OTP_PROG_C.PROG_PULSE, this is recommended to use.
 *
 * @param bf_value new value for OTP_PROG_C.PROG_PULSE
 */
__OTP_SH_INLINE void OTP_SH_OTP_PROG_C__PROG_PULSE__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_PROG_C__GET();
    reg = (reg & ~OTP_SH_OTP_PROG_C__PROG_PULSE__Msk);
    reg = (reg | (OTP_SH_OTP_PROG_C__PROG_PULSE__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_PROG_C__SET(reg);
}

/** OTP_SH_OTP_PROG_C__PROG_PULSE__GET() gets OTP_PROG_C.PROG_PULSE's current value.
 *
 * When reading from OTP_PROG_C.PROG_PULSE, this is recommended to use.
 *
 * @return current value of OTP_PROG_C.PROG_PULSE
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PROG_C__PROG_PULSE__GET(void)
{
    uint32_t reg = OTP_SH_OTP_PROG_C__GET();
    reg = (reg & OTP_SH_OTP_PROG_C__PROG_PULSE__Msk);
    reg = (reg >> OTP_SH_OTP_PROG_C__PROG_PULSE__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_PROG_C__PROG_PULSE__MODIFY() modifies OTP_PROG_C.PROG_PULSE.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_PROG_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_PROG_C
 * @param bf_value new value for OTP_PROG_C.PROG_PULSE
 * @return new value of OTP_SH.OTP_PROG_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PROG_C__PROG_PULSE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_PROG_C__PROG_PULSE__Msk);
    reg = (reg | (OTP_SH_OTP_PROG_C__PROG_PULSE__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_PROG_C__PROG_PULSE__EXTRACT() extracts OTP_PROG_C.PROG_PULSE.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_PROG_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_PROG_C
 * @return current value of OTP_PROG_C.PROG_PULSE
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PROG_C__PROG_PULSE__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_PROG_C__PROG_PULSE__Msk);
    reg = (reg >> OTP_SH_OTP_PROG_C__PROG_PULSE__Pos);
    return (uint32_t)reg;
}

/* ------------------- OTP_SH.OTP_PROG_C.PROG_SOAK_PULSE ------------------- */


#define OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Pos                 0                                                                      /*!< Right-most bit position of PROG_SOAK_PULSE in OTP_SH.OTP_PROG_C */
#define OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Msk                 (0x0000FFFFUL << OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Pos)              /*!< Mask for PROG_SOAK_PULSE in OTP_SH.OTP_PROG_C */
#define OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Shift(v)            (((v) << OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Pos) & OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Msk) /*!< Shift value 'v' into PROG_SOAK_PULSE and mask 'v' to fit it into PROG_SOAK_PULSE field */

/** OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__SET() sets OTP_PROG_C.PROG_SOAK_PULSE to given value.
 *
 * When writing to OTP_PROG_C.PROG_SOAK_PULSE, this is recommended to use.
 *
 * @param bf_value new value for OTP_PROG_C.PROG_SOAK_PULSE
 */
__OTP_SH_INLINE void OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_PROG_C__GET();
    reg = (reg & ~OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Msk);
    reg = (reg | (OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_PROG_C__SET(reg);
}

/** OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__GET() gets OTP_PROG_C.PROG_SOAK_PULSE's current value.
 *
 * When reading from OTP_PROG_C.PROG_SOAK_PULSE, this is recommended to use.
 *
 * @return current value of OTP_PROG_C.PROG_SOAK_PULSE
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__GET(void)
{
    uint32_t reg = OTP_SH_OTP_PROG_C__GET();
    reg = (reg & OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Msk);
    reg = (reg >> OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__MODIFY() modifies OTP_PROG_C.PROG_SOAK_PULSE.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_PROG_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_PROG_C
 * @param bf_value new value for OTP_PROG_C.PROG_SOAK_PULSE
 * @return new value of OTP_SH.OTP_PROG_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Msk);
    reg = (reg | (OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__EXTRACT() extracts OTP_PROG_C.PROG_SOAK_PULSE.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_PROG_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_PROG_C
 * @return current value of OTP_PROG_C.PROG_SOAK_PULSE
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Msk);
    reg = (reg >> OTP_SH_OTP_PROG_C__PROG_SOAK_PULSE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        OTP_CP_C member of OTP_SH_t                        */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OTP_CP_C__ADDRESS returns the address of member OTP_CP_C.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OTP_CP_C
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OTP_CP_C__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OTP_CP_C)));
}

/** OTP_SH_OTP_CP_C__SET() sets OTP_CP_C to given value.
 *
 * When writing to OTP_CP_C, this is mandatory to use.
 *
 * @param value new value for OTP_CP_C
 */
__OTP_SH_INLINE void OTP_SH_OTP_CP_C__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_OTP_CP_C__ADDRESS(), value);
}

/** OTP_SH_OTP_CP_C__GET() gets OTP_CP_C's current value.
 *
 * When reading from OTP_CP_C, this is mandatory to use.
 *
 * @return current value of OTP_CP_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_CP_C__GET(void)
{
    return HAL_GET32(__OTP_SH_OTP_CP_C__ADDRESS());
}

/* ----------------------- OTP_SH.OTP_CP_C.VPP_WARMUP ----------------------- */


#define OTP_SH_OTP_CP_C__VPP_WARMUP__Pos                        16                                                                     /*!< Right-most bit position of VPP_WARMUP in OTP_SH.OTP_CP_C */
#define OTP_SH_OTP_CP_C__VPP_WARMUP__Msk                        (0x000001FFUL << OTP_SH_OTP_CP_C__VPP_WARMUP__Pos)                     /*!< Mask for VPP_WARMUP in OTP_SH.OTP_CP_C */
#define OTP_SH_OTP_CP_C__VPP_WARMUP__Shift(v)                   (((v) << OTP_SH_OTP_CP_C__VPP_WARMUP__Pos) & OTP_SH_OTP_CP_C__VPP_WARMUP__Msk) /*!< Shift value 'v' into VPP_WARMUP and mask 'v' to fit it into VPP_WARMUP field */

/** OTP_SH_OTP_CP_C__VPP_WARMUP__SET() sets OTP_CP_C.VPP_WARMUP to given value.
 *
 * When writing to OTP_CP_C.VPP_WARMUP, this is recommended to use.
 *
 * @param bf_value new value for OTP_CP_C.VPP_WARMUP
 */
__OTP_SH_INLINE void OTP_SH_OTP_CP_C__VPP_WARMUP__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_CP_C__GET();
    reg = (reg & ~OTP_SH_OTP_CP_C__VPP_WARMUP__Msk);
    reg = (reg | (OTP_SH_OTP_CP_C__VPP_WARMUP__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_CP_C__SET(reg);
}

/** OTP_SH_OTP_CP_C__VPP_WARMUP__GET() gets OTP_CP_C.VPP_WARMUP's current value.
 *
 * When reading from OTP_CP_C.VPP_WARMUP, this is recommended to use.
 *
 * @return current value of OTP_CP_C.VPP_WARMUP
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_CP_C__VPP_WARMUP__GET(void)
{
    uint32_t reg = OTP_SH_OTP_CP_C__GET();
    reg = (reg & OTP_SH_OTP_CP_C__VPP_WARMUP__Msk);
    reg = (reg >> OTP_SH_OTP_CP_C__VPP_WARMUP__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_CP_C__VPP_WARMUP__MODIFY() modifies OTP_CP_C.VPP_WARMUP.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_CP_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_CP_C
 * @param bf_value new value for OTP_CP_C.VPP_WARMUP
 * @return new value of OTP_SH.OTP_CP_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_CP_C__VPP_WARMUP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_CP_C__VPP_WARMUP__Msk);
    reg = (reg | (OTP_SH_OTP_CP_C__VPP_WARMUP__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_CP_C__VPP_WARMUP__EXTRACT() extracts OTP_CP_C.VPP_WARMUP.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_CP_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_CP_C
 * @return current value of OTP_CP_C.VPP_WARMUP
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_CP_C__VPP_WARMUP__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_CP_C__VPP_WARMUP__Msk);
    reg = (reg >> OTP_SH_OTP_CP_C__VPP_WARMUP__Pos);
    return (uint32_t)reg;
}

/* ---------------------- OTP_SH.OTP_CP_C.VPP_WARMDOWN ---------------------- */


#define OTP_SH_OTP_CP_C__VPP_WARMDOWN__Pos                      0                                                                      /*!< Right-most bit position of VPP_WARMDOWN in OTP_SH.OTP_CP_C */
#define OTP_SH_OTP_CP_C__VPP_WARMDOWN__Msk                      (0x0000FFFFUL << OTP_SH_OTP_CP_C__VPP_WARMDOWN__Pos)                   /*!< Mask for VPP_WARMDOWN in OTP_SH.OTP_CP_C */
#define OTP_SH_OTP_CP_C__VPP_WARMDOWN__Shift(v)                 (((v) << OTP_SH_OTP_CP_C__VPP_WARMDOWN__Pos) & OTP_SH_OTP_CP_C__VPP_WARMDOWN__Msk) /*!< Shift value 'v' into VPP_WARMDOWN and mask 'v' to fit it into VPP_WARMDOWN field */

/** OTP_SH_OTP_CP_C__VPP_WARMDOWN__SET() sets OTP_CP_C.VPP_WARMDOWN to given value.
 *
 * When writing to OTP_CP_C.VPP_WARMDOWN, this is recommended to use.
 *
 * @param bf_value new value for OTP_CP_C.VPP_WARMDOWN
 */
__OTP_SH_INLINE void OTP_SH_OTP_CP_C__VPP_WARMDOWN__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_CP_C__GET();
    reg = (reg & ~OTP_SH_OTP_CP_C__VPP_WARMDOWN__Msk);
    reg = (reg | (OTP_SH_OTP_CP_C__VPP_WARMDOWN__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_CP_C__SET(reg);
}

/** OTP_SH_OTP_CP_C__VPP_WARMDOWN__GET() gets OTP_CP_C.VPP_WARMDOWN's current value.
 *
 * When reading from OTP_CP_C.VPP_WARMDOWN, this is recommended to use.
 *
 * @return current value of OTP_CP_C.VPP_WARMDOWN
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_CP_C__VPP_WARMDOWN__GET(void)
{
    uint32_t reg = OTP_SH_OTP_CP_C__GET();
    reg = (reg & OTP_SH_OTP_CP_C__VPP_WARMDOWN__Msk);
    reg = (reg >> OTP_SH_OTP_CP_C__VPP_WARMDOWN__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_CP_C__VPP_WARMDOWN__MODIFY() modifies OTP_CP_C.VPP_WARMDOWN.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_CP_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_CP_C
 * @param bf_value new value for OTP_CP_C.VPP_WARMDOWN
 * @return new value of OTP_SH.OTP_CP_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_CP_C__VPP_WARMDOWN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_CP_C__VPP_WARMDOWN__Msk);
    reg = (reg | (OTP_SH_OTP_CP_C__VPP_WARMDOWN__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_CP_C__VPP_WARMDOWN__EXTRACT() extracts OTP_CP_C.VPP_WARMDOWN.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_CP_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_CP_C
 * @return current value of OTP_CP_C.VPP_WARMDOWN
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_CP_C__VPP_WARMDOWN__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_CP_C__VPP_WARMDOWN__Msk);
    reg = (reg >> OTP_SH_OTP_CP_C__VPP_WARMDOWN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       OTP_READ_C member of OTP_SH_t                       */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OTP_READ_C__ADDRESS returns the address of member OTP_READ_C.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OTP_READ_C
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OTP_READ_C__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OTP_READ_C)));
}

/** OTP_SH_OTP_READ_C__SET() sets OTP_READ_C to given value.
 *
 * When writing to OTP_READ_C, this is mandatory to use.
 *
 * @param value new value for OTP_READ_C
 */
__OTP_SH_INLINE void OTP_SH_OTP_READ_C__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_OTP_READ_C__ADDRESS(), value);
}

/** OTP_SH_OTP_READ_C__GET() gets OTP_READ_C's current value.
 *
 * When reading from OTP_READ_C, this is mandatory to use.
 *
 * @return current value of OTP_READ_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__GET(void)
{
    return HAL_GET32(__OTP_SH_OTP_READ_C__ADDRESS());
}

/* --------------------- OTP_SH.OTP_READ_C.MAXCNT_SOAK --------------------- */


#define OTP_SH_OTP_READ_C__MAXCNT_SOAK__Pos                     24                                                                     /*!< Right-most bit position of MAXCNT_SOAK in OTP_SH.OTP_READ_C */
#define OTP_SH_OTP_READ_C__MAXCNT_SOAK__Msk                     (0x000000FFUL << OTP_SH_OTP_READ_C__MAXCNT_SOAK__Pos)                  /*!< Mask for MAXCNT_SOAK in OTP_SH.OTP_READ_C */
#define OTP_SH_OTP_READ_C__MAXCNT_SOAK__Shift(v)                (((v) << OTP_SH_OTP_READ_C__MAXCNT_SOAK__Pos) & OTP_SH_OTP_READ_C__MAXCNT_SOAK__Msk) /*!< Shift value 'v' into MAXCNT_SOAK and mask 'v' to fit it into MAXCNT_SOAK field */

/** OTP_SH_OTP_READ_C__MAXCNT_SOAK__SET() sets OTP_READ_C.MAXCNT_SOAK to given value.
 *
 * When writing to OTP_READ_C.MAXCNT_SOAK, this is recommended to use.
 *
 * @param bf_value new value for OTP_READ_C.MAXCNT_SOAK
 */
__OTP_SH_INLINE void OTP_SH_OTP_READ_C__MAXCNT_SOAK__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_READ_C__GET();
    reg = (reg & ~OTP_SH_OTP_READ_C__MAXCNT_SOAK__Msk);
    reg = (reg | (OTP_SH_OTP_READ_C__MAXCNT_SOAK__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_READ_C__SET(reg);
}

/** OTP_SH_OTP_READ_C__MAXCNT_SOAK__GET() gets OTP_READ_C.MAXCNT_SOAK's current value.
 *
 * When reading from OTP_READ_C.MAXCNT_SOAK, this is recommended to use.
 *
 * @return current value of OTP_READ_C.MAXCNT_SOAK
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__MAXCNT_SOAK__GET(void)
{
    uint32_t reg = OTP_SH_OTP_READ_C__GET();
    reg = (reg & OTP_SH_OTP_READ_C__MAXCNT_SOAK__Msk);
    reg = (reg >> OTP_SH_OTP_READ_C__MAXCNT_SOAK__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_READ_C__MAXCNT_SOAK__MODIFY() modifies OTP_READ_C.MAXCNT_SOAK.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_READ_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_READ_C
 * @param bf_value new value for OTP_READ_C.MAXCNT_SOAK
 * @return new value of OTP_SH.OTP_READ_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__MAXCNT_SOAK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_READ_C__MAXCNT_SOAK__Msk);
    reg = (reg | (OTP_SH_OTP_READ_C__MAXCNT_SOAK__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_READ_C__MAXCNT_SOAK__EXTRACT() extracts OTP_READ_C.MAXCNT_SOAK.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_READ_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_READ_C
 * @return current value of OTP_READ_C.MAXCNT_SOAK
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__MAXCNT_SOAK__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_READ_C__MAXCNT_SOAK__Msk);
    reg = (reg >> OTP_SH_OTP_READ_C__MAXCNT_SOAK__Pos);
    return (uint32_t)reg;
}

/* ------------------ OTP_SH.OTP_READ_C.PROG_RECOVERY_TIME ------------------ */


#define OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Pos              16                                                                     /*!< Right-most bit position of PROG_RECOVERY_TIME in OTP_SH.OTP_READ_C */
#define OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Msk              (0x0000001FUL << OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Pos)           /*!< Mask for PROG_RECOVERY_TIME in OTP_SH.OTP_READ_C */
#define OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Shift(v)         (((v) << OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Pos) & OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Msk) /*!< Shift value 'v' into PROG_RECOVERY_TIME and mask 'v' to fit it into PROG_RECOVERY_TIME field */

/** OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__SET() sets OTP_READ_C.PROG_RECOVERY_TIME to given value.
 *
 * When writing to OTP_READ_C.PROG_RECOVERY_TIME, this is recommended to use.
 *
 * @param bf_value new value for OTP_READ_C.PROG_RECOVERY_TIME
 */
__OTP_SH_INLINE void OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_READ_C__GET();
    reg = (reg & ~OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Msk);
    reg = (reg | (OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_READ_C__SET(reg);
}

/** OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__GET() gets OTP_READ_C.PROG_RECOVERY_TIME's current value.
 *
 * When reading from OTP_READ_C.PROG_RECOVERY_TIME, this is recommended to use.
 *
 * @return current value of OTP_READ_C.PROG_RECOVERY_TIME
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__GET(void)
{
    uint32_t reg = OTP_SH_OTP_READ_C__GET();
    reg = (reg & OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Msk);
    reg = (reg >> OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__MODIFY() modifies OTP_READ_C.PROG_RECOVERY_TIME.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_READ_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_READ_C
 * @param bf_value new value for OTP_READ_C.PROG_RECOVERY_TIME
 * @return new value of OTP_SH.OTP_READ_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Msk);
    reg = (reg | (OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__EXTRACT() extracts OTP_READ_C.PROG_RECOVERY_TIME.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_READ_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_READ_C
 * @return current value of OTP_READ_C.PROG_RECOVERY_TIME
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Msk);
    reg = (reg >> OTP_SH_OTP_READ_C__PROG_RECOVERY_TIME__Pos);
    return (uint32_t)reg;
}

/* ------------------ OTP_SH.OTP_READ_C.BIST_READ_TIMEOUT ------------------ */


#define OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Pos               8                                                                      /*!< Right-most bit position of BIST_READ_TIMEOUT in OTP_SH.OTP_READ_C */
#define OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Msk               (0x000000FFUL << OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Pos)            /*!< Mask for BIST_READ_TIMEOUT in OTP_SH.OTP_READ_C */
#define OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Shift(v)          (((v) << OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Pos) & OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Msk) /*!< Shift value 'v' into BIST_READ_TIMEOUT and mask 'v' to fit it into BIST_READ_TIMEOUT field */

/** OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__SET() sets OTP_READ_C.BIST_READ_TIMEOUT to given value.
 *
 * When writing to OTP_READ_C.BIST_READ_TIMEOUT, this is recommended to use.
 *
 * @param bf_value new value for OTP_READ_C.BIST_READ_TIMEOUT
 */
__OTP_SH_INLINE void OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_READ_C__GET();
    reg = (reg & ~OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Msk);
    reg = (reg | (OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_READ_C__SET(reg);
}

/** OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__GET() gets OTP_READ_C.BIST_READ_TIMEOUT's current value.
 *
 * When reading from OTP_READ_C.BIST_READ_TIMEOUT, this is recommended to use.
 *
 * @return current value of OTP_READ_C.BIST_READ_TIMEOUT
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__GET(void)
{
    uint32_t reg = OTP_SH_OTP_READ_C__GET();
    reg = (reg & OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Msk);
    reg = (reg >> OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__MODIFY() modifies OTP_READ_C.BIST_READ_TIMEOUT.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_READ_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_READ_C
 * @param bf_value new value for OTP_READ_C.BIST_READ_TIMEOUT
 * @return new value of OTP_SH.OTP_READ_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Msk);
    reg = (reg | (OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__EXTRACT() extracts OTP_READ_C.BIST_READ_TIMEOUT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_READ_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_READ_C
 * @return current value of OTP_READ_C.BIST_READ_TIMEOUT
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Msk);
    reg = (reg >> OTP_SH_OTP_READ_C__BIST_READ_TIMEOUT__Pos);
    return (uint32_t)reg;
}

/* --------------------- OTP_SH.OTP_READ_C.READ_TIMEOUT --------------------- */


#define OTP_SH_OTP_READ_C__READ_TIMEOUT__Pos                    0                                                                      /*!< Right-most bit position of READ_TIMEOUT in OTP_SH.OTP_READ_C */
#define OTP_SH_OTP_READ_C__READ_TIMEOUT__Msk                    (0x000000FFUL << OTP_SH_OTP_READ_C__READ_TIMEOUT__Pos)                 /*!< Mask for READ_TIMEOUT in OTP_SH.OTP_READ_C */
#define OTP_SH_OTP_READ_C__READ_TIMEOUT__Shift(v)               (((v) << OTP_SH_OTP_READ_C__READ_TIMEOUT__Pos) & OTP_SH_OTP_READ_C__READ_TIMEOUT__Msk) /*!< Shift value 'v' into READ_TIMEOUT and mask 'v' to fit it into READ_TIMEOUT field */

/** OTP_SH_OTP_READ_C__READ_TIMEOUT__SET() sets OTP_READ_C.READ_TIMEOUT to given value.
 *
 * When writing to OTP_READ_C.READ_TIMEOUT, this is recommended to use.
 *
 * @param bf_value new value for OTP_READ_C.READ_TIMEOUT
 */
__OTP_SH_INLINE void OTP_SH_OTP_READ_C__READ_TIMEOUT__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_READ_C__GET();
    reg = (reg & ~OTP_SH_OTP_READ_C__READ_TIMEOUT__Msk);
    reg = (reg | (OTP_SH_OTP_READ_C__READ_TIMEOUT__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_READ_C__SET(reg);
}

/** OTP_SH_OTP_READ_C__READ_TIMEOUT__GET() gets OTP_READ_C.READ_TIMEOUT's current value.
 *
 * When reading from OTP_READ_C.READ_TIMEOUT, this is recommended to use.
 *
 * @return current value of OTP_READ_C.READ_TIMEOUT
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__READ_TIMEOUT__GET(void)
{
    uint32_t reg = OTP_SH_OTP_READ_C__GET();
    reg = (reg & OTP_SH_OTP_READ_C__READ_TIMEOUT__Msk);
    reg = (reg >> OTP_SH_OTP_READ_C__READ_TIMEOUT__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_READ_C__READ_TIMEOUT__MODIFY() modifies OTP_READ_C.READ_TIMEOUT.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_READ_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_READ_C
 * @param bf_value new value for OTP_READ_C.READ_TIMEOUT
 * @return new value of OTP_SH.OTP_READ_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__READ_TIMEOUT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_READ_C__READ_TIMEOUT__Msk);
    reg = (reg | (OTP_SH_OTP_READ_C__READ_TIMEOUT__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_READ_C__READ_TIMEOUT__EXTRACT() extracts OTP_READ_C.READ_TIMEOUT.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_READ_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_READ_C
 * @return current value of OTP_READ_C.READ_TIMEOUT
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_READ_C__READ_TIMEOUT__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_READ_C__READ_TIMEOUT__Msk);
    reg = (reg >> OTP_SH_OTP_READ_C__READ_TIMEOUT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         ERR_RPT member of OTP_SH_t                         */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_ERR_RPT__ADDRESS returns the address of member ERR_RPT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ERR_RPT
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_ERR_RPT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, ERR_RPT)));
}

/** OTP_SH_ERR_RPT__GET() gets ERR_RPT's current value.
 *
 * When reading from ERR_RPT, this is mandatory to use.
 *
 * @return current value of ERR_RPT
 */
__OTP_SH_INLINE uint32_t OTP_SH_ERR_RPT__GET(void)
{
    return HAL_GET32(__OTP_SH_ERR_RPT__ADDRESS());
}

/* ------------------------ OTP_SH.ERR_RPT.OTP_ADDR ------------------------ */

/**
<pre>
  OTP_SH.ERR_RPT.OTP_ADDR:

    Reflect the status of the selected group of signals







    OTP address causing illegal access

</pre> */

#define OTP_SH_ERR_RPT__OTP_ADDR__Pos                           16                                                                     /*!< Right-most bit position of OTP_ADDR in OTP_SH.ERR_RPT */
#define OTP_SH_ERR_RPT__OTP_ADDR__Msk                           (0x00000FFFUL << OTP_SH_ERR_RPT__OTP_ADDR__Pos)                        /*!< Mask for OTP_ADDR in OTP_SH.ERR_RPT */
#define OTP_SH_ERR_RPT__OTP_ADDR__Shift(v)                      (((v) << OTP_SH_ERR_RPT__OTP_ADDR__Pos) & OTP_SH_ERR_RPT__OTP_ADDR__Msk) /*!< Shift value 'v' into OTP_ADDR and mask 'v' to fit it into OTP_ADDR field */

/** OTP_SH_ERR_RPT__OTP_ADDR__GET() gets ERR_RPT.OTP_ADDR's current value.
 *
 * When reading from ERR_RPT.OTP_ADDR, this is recommended to use.
 *
 * @return current value of ERR_RPT.OTP_ADDR
 */
__OTP_SH_INLINE uint32_t OTP_SH_ERR_RPT__OTP_ADDR__GET(void)
{
    uint32_t reg = OTP_SH_ERR_RPT__GET();
    reg = (reg & OTP_SH_ERR_RPT__OTP_ADDR__Msk);
    reg = (reg >> OTP_SH_ERR_RPT__OTP_ADDR__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_ERR_RPT__OTP_ADDR__EXTRACT() extracts ERR_RPT.OTP_ADDR.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.ERR_RPT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.ERR_RPT
 * @return current value of ERR_RPT.OTP_ADDR
 */
__OTP_SH_INLINE uint32_t OTP_SH_ERR_RPT__OTP_ADDR__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_ERR_RPT__OTP_ADDR__Msk);
    reg = (reg >> OTP_SH_ERR_RPT__OTP_ADDR__Pos);
    return (uint32_t)reg;
}

/* ----------------------- OTP_SH.ERR_RPT.AHB_ILL_WR ----------------------- */

/**
<pre>
  OTP_SH.ERR_RPT.AHB_ILL_WR:

    Report the illegal bit status

</pre> */

#define OTP_SH_ERR_RPT__AHB_ILL_WR__Pos                         1                                                                      /*!< Right-most bit position of AHB_ILL_WR in OTP_SH.ERR_RPT */
#define OTP_SH_ERR_RPT__AHB_ILL_WR__Msk                         (0x00000001UL << OTP_SH_ERR_RPT__AHB_ILL_WR__Pos)                      /*!< Mask for AHB_ILL_WR in OTP_SH.ERR_RPT */
#define OTP_SH_ERR_RPT__AHB_ILL_WR__Shift(v)                    (((v) << OTP_SH_ERR_RPT__AHB_ILL_WR__Pos) & OTP_SH_ERR_RPT__AHB_ILL_WR__Msk) /*!< Shift value 'v' into AHB_ILL_WR and mask 'v' to fit it into AHB_ILL_WR field */

/** OTP_SH_ERR_RPT__AHB_ILL_WR__GET() gets ERR_RPT.AHB_ILL_WR's current value.
 *
 * When reading from ERR_RPT.AHB_ILL_WR, this is recommended to use.
 *
 * @return current value of ERR_RPT.AHB_ILL_WR
 */
__OTP_SH_INLINE uint32_t OTP_SH_ERR_RPT__AHB_ILL_WR__GET(void)
{
    uint32_t reg = OTP_SH_ERR_RPT__GET();
    reg = (reg & OTP_SH_ERR_RPT__AHB_ILL_WR__Msk);
    reg = (reg >> OTP_SH_ERR_RPT__AHB_ILL_WR__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_ERR_RPT__AHB_ILL_WR__EXTRACT() extracts ERR_RPT.AHB_ILL_WR.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.ERR_RPT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.ERR_RPT
 * @return current value of ERR_RPT.AHB_ILL_WR
 */
__OTP_SH_INLINE uint32_t OTP_SH_ERR_RPT__AHB_ILL_WR__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_ERR_RPT__AHB_ILL_WR__Msk);
    reg = (reg >> OTP_SH_ERR_RPT__AHB_ILL_WR__Pos);
    return (uint32_t)reg;
}

/* --------------------- OTP_SH.ERR_RPT.AHB_ILL_APB_ACC --------------------- */

/**
<pre>
  OTP_SH.ERR_RPT.AHB_ILL_APB_ACC:

    Report the illegal bit status

</pre> */

#define OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__Pos                    0                                                                      /*!< Right-most bit position of AHB_ILL_APB_ACC in OTP_SH.ERR_RPT */
#define OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__Msk                    (0x00000001UL << OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__Pos)                 /*!< Mask for AHB_ILL_APB_ACC in OTP_SH.ERR_RPT */
#define OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__Shift(v)               (((v) << OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__Pos) & OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__Msk) /*!< Shift value 'v' into AHB_ILL_APB_ACC and mask 'v' to fit it into AHB_ILL_APB_ACC field */

/** OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__GET() gets ERR_RPT.AHB_ILL_APB_ACC's current value.
 *
 * When reading from ERR_RPT.AHB_ILL_APB_ACC, this is recommended to use.
 *
 * @return current value of ERR_RPT.AHB_ILL_APB_ACC
 */
__OTP_SH_INLINE uint32_t OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__GET(void)
{
    uint32_t reg = OTP_SH_ERR_RPT__GET();
    reg = (reg & OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__Msk);
    reg = (reg >> OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__EXTRACT() extracts ERR_RPT.AHB_ILL_APB_ACC.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.ERR_RPT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.ERR_RPT
 * @return current value of ERR_RPT.AHB_ILL_APB_ACC
 */
__OTP_SH_INLINE uint32_t OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__Msk);
    reg = (reg >> OTP_SH_ERR_RPT__AHB_ILL_APB_ACC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       ERR_RPT_CLR member of OTP_SH_t                       */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_ERR_RPT_CLR__ADDRESS returns the address of member ERR_RPT_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ERR_RPT_CLR
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_ERR_RPT_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, ERR_RPT_CLR)));
}

/** OTP_SH_ERR_RPT_CLR__SET() sets ERR_RPT_CLR to given value.
 *
 * When writing to ERR_RPT_CLR, this is mandatory to use.
 *
 * @param value new value for ERR_RPT_CLR
 */
__OTP_SH_INLINE void OTP_SH_ERR_RPT_CLR__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_ERR_RPT_CLR__ADDRESS(), value);
}


/* ------------------------- OTP_SH.ERR_RPT_CLR.CLR ------------------------- */

/**
<pre>
  OTP_SH.ERR_RPT_CLR.CLR:

    Report the illegal bit status

</pre> */

#define OTP_SH_ERR_RPT_CLR__CLR__Pos                            0                                                                      /*!< Right-most bit position of CLR in OTP_SH.ERR_RPT_CLR */
#define OTP_SH_ERR_RPT_CLR__CLR__Msk                            (0xFFFFFFFFUL << OTP_SH_ERR_RPT_CLR__CLR__Pos)                         /*!< Mask for CLR in OTP_SH.ERR_RPT_CLR */
#define OTP_SH_ERR_RPT_CLR__CLR__Shift(v)                       (((v) << OTP_SH_ERR_RPT_CLR__CLR__Pos) & OTP_SH_ERR_RPT_CLR__CLR__Msk) /*!< Shift value 'v' into CLR and mask 'v' to fit it into CLR field */

/** OTP_SH_ERR_RPT_CLR__CLR__SET() sets ERR_RPT_CLR.CLR to given value.
 *
 * When writing to ERR_RPT_CLR.CLR, this is recommended to use.
 *
 * @param bf_value new value for ERR_RPT_CLR.CLR
 */
__OTP_SH_INLINE void OTP_SH_ERR_RPT_CLR__CLR__SET(uint32_t bf_value)
{
    uint32_t reg = OTP_SH_ERR_RPT_CLR__CLR__Shift((uint32_t)bf_value);
    OTP_SH_ERR_RPT_CLR__SET(reg);
}


/** OTP_SH_ERR_RPT_CLR__CLR__MODIFY() modifies ERR_RPT_CLR.CLR.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.ERR_RPT_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.ERR_RPT_CLR
 * @param bf_value new value for ERR_RPT_CLR.CLR
 * @return new value of OTP_SH.ERR_RPT_CLR
 */
__OTP_SH_INLINE uint32_t OTP_SH_ERR_RPT_CLR__CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~OTP_SH_ERR_RPT_CLR__CLR__Msk);
    reg = (reg | (OTP_SH_ERR_RPT_CLR__CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_ERR_RPT_CLR__CLR__EXTRACT() extracts ERR_RPT_CLR.CLR.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.ERR_RPT_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.ERR_RPT_CLR
 * @return current value of ERR_RPT_CLR.CLR
 */
__OTP_SH_INLINE uint32_t OTP_SH_ERR_RPT_CLR__CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_ERR_RPT_CLR__CLR__Msk);
    reg = (reg >> OTP_SH_ERR_RPT_CLR__CLR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       OTP_BIST_C member of OTP_SH_t                       */
/* -------------------------------------------------------------------------- */

/** __OTP_SH_OTP_BIST_C__ADDRESS returns the address of member OTP_BIST_C.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of OTP_BIST_C
 */
__OTP_SH_INLINE uint32_t* __OTP_SH_OTP_BIST_C__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__OTP_SH_BASE_PTR() + (uint32_t)(offsetof(OTP_SH_t, OTP_BIST_C)));
}

/** OTP_SH_OTP_BIST_C__SET() sets OTP_BIST_C to given value.
 *
 * When writing to OTP_BIST_C, this is mandatory to use.
 *
 * @param value new value for OTP_BIST_C
 */
__OTP_SH_INLINE void OTP_SH_OTP_BIST_C__SET(uint32_t value)
{
    HAL_SET32(__OTP_SH_OTP_BIST_C__ADDRESS(), value);
}

/** OTP_SH_OTP_BIST_C__GET() gets OTP_BIST_C's current value.
 *
 * When reading from OTP_BIST_C, this is mandatory to use.
 *
 * @return current value of OTP_BIST_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__GET(void)
{
    return HAL_GET32(__OTP_SH_OTP_BIST_C__ADDRESS());
}

/* -------------------- OTP_SH.OTP_BIST_C.BIST_ADDR_FAIL -------------------- */


#define OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__Pos                  16                                                                     /*!< Right-most bit position of BIST_ADDR_FAIL in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__Msk                  (0x00001FFFUL << OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__Pos)               /*!< Mask for BIST_ADDR_FAIL in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__Shift(v)             (((v) << OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__Pos) & OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__Msk) /*!< Shift value 'v' into BIST_ADDR_FAIL and mask 'v' to fit it into BIST_ADDR_FAIL field */

/** OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__GET() gets OTP_BIST_C.BIST_ADDR_FAIL's current value.
 *
 * When reading from OTP_BIST_C.BIST_ADDR_FAIL, this is recommended to use.
 *
 * @return current value of OTP_BIST_C.BIST_ADDR_FAIL
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__GET(void)
{
    uint32_t reg = OTP_SH_OTP_BIST_C__GET();
    reg = (reg & OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__EXTRACT() extracts OTP_BIST_C.BIST_ADDR_FAIL.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_BIST_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_BIST_C
 * @return current value of OTP_BIST_C.BIST_ADDR_FAIL
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BIST_ADDR_FAIL__Pos);
    return (uint32_t)reg;
}

/* ------------------------ OTP_SH.OTP_BIST_C.BFAIL2 ------------------------ */


#define OTP_SH_OTP_BIST_C__BFAIL2__Pos                          12                                                                     /*!< Right-most bit position of BFAIL2 in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BFAIL2__Msk                          (0x00000001UL << OTP_SH_OTP_BIST_C__BFAIL2__Pos)                       /*!< Mask for BFAIL2 in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BFAIL2__Shift(v)                     (((v) << OTP_SH_OTP_BIST_C__BFAIL2__Pos) & OTP_SH_OTP_BIST_C__BFAIL2__Msk) /*!< Shift value 'v' into BFAIL2 and mask 'v' to fit it into BFAIL2 field */

/** OTP_SH_OTP_BIST_C__BFAIL2__GET() gets OTP_BIST_C.BFAIL2's current value.
 *
 * When reading from OTP_BIST_C.BFAIL2, this is recommended to use.
 *
 * @return current value of OTP_BIST_C.BFAIL2
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BFAIL2__GET(void)
{
    uint32_t reg = OTP_SH_OTP_BIST_C__GET();
    reg = (reg & OTP_SH_OTP_BIST_C__BFAIL2__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BFAIL2__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_BIST_C__BFAIL2__EXTRACT() extracts OTP_BIST_C.BFAIL2.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_BIST_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_BIST_C
 * @return current value of OTP_BIST_C.BFAIL2
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BFAIL2__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_BIST_C__BFAIL2__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BFAIL2__Pos);
    return (uint32_t)reg;
}

/* ------------------------ OTP_SH.OTP_BIST_C.BFAIL1 ------------------------ */


#define OTP_SH_OTP_BIST_C__BFAIL1__Pos                          10                                                                     /*!< Right-most bit position of BFAIL1 in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BFAIL1__Msk                          (0x00000003UL << OTP_SH_OTP_BIST_C__BFAIL1__Pos)                       /*!< Mask for BFAIL1 in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BFAIL1__Shift(v)                     (((v) << OTP_SH_OTP_BIST_C__BFAIL1__Pos) & OTP_SH_OTP_BIST_C__BFAIL1__Msk) /*!< Shift value 'v' into BFAIL1 and mask 'v' to fit it into BFAIL1 field */

/** OTP_SH_OTP_BIST_C__BFAIL1__GET() gets OTP_BIST_C.BFAIL1's current value.
 *
 * When reading from OTP_BIST_C.BFAIL1, this is recommended to use.
 *
 * @return current value of OTP_BIST_C.BFAIL1
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BFAIL1__GET(void)
{
    uint32_t reg = OTP_SH_OTP_BIST_C__GET();
    reg = (reg & OTP_SH_OTP_BIST_C__BFAIL1__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BFAIL1__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_BIST_C__BFAIL1__EXTRACT() extracts OTP_BIST_C.BFAIL1.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_BIST_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_BIST_C
 * @return current value of OTP_BIST_C.BFAIL1
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BFAIL1__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_BIST_C__BFAIL1__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BFAIL1__Pos);
    return (uint32_t)reg;
}

/* ------------------------ OTP_SH.OTP_BIST_C.BFAIL0 ------------------------ */


#define OTP_SH_OTP_BIST_C__BFAIL0__Pos                          8                                                                      /*!< Right-most bit position of BFAIL0 in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BFAIL0__Msk                          (0x00000003UL << OTP_SH_OTP_BIST_C__BFAIL0__Pos)                       /*!< Mask for BFAIL0 in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BFAIL0__Shift(v)                     (((v) << OTP_SH_OTP_BIST_C__BFAIL0__Pos) & OTP_SH_OTP_BIST_C__BFAIL0__Msk) /*!< Shift value 'v' into BFAIL0 and mask 'v' to fit it into BFAIL0 field */

/** OTP_SH_OTP_BIST_C__BFAIL0__GET() gets OTP_BIST_C.BFAIL0's current value.
 *
 * When reading from OTP_BIST_C.BFAIL0, this is recommended to use.
 *
 * @return current value of OTP_BIST_C.BFAIL0
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BFAIL0__GET(void)
{
    uint32_t reg = OTP_SH_OTP_BIST_C__GET();
    reg = (reg & OTP_SH_OTP_BIST_C__BFAIL0__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BFAIL0__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_BIST_C__BFAIL0__EXTRACT() extracts OTP_BIST_C.BFAIL0.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_BIST_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_BIST_C
 * @return current value of OTP_BIST_C.BFAIL0
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BFAIL0__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_BIST_C__BFAIL0__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BFAIL0__Pos);
    return (uint32_t)reg;
}

/* ------------------------ OTP_SH.OTP_BIST_C.BDONE ------------------------ */


#define OTP_SH_OTP_BIST_C__BDONE__Pos                           6                                                                      /*!< Right-most bit position of BDONE in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BDONE__Msk                           (0x00000001UL << OTP_SH_OTP_BIST_C__BDONE__Pos)                        /*!< Mask for BDONE in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BDONE__Shift(v)                      (((v) << OTP_SH_OTP_BIST_C__BDONE__Pos) & OTP_SH_OTP_BIST_C__BDONE__Msk) /*!< Shift value 'v' into BDONE and mask 'v' to fit it into BDONE field */

/** OTP_SH_OTP_BIST_C__BDONE__GET() gets OTP_BIST_C.BDONE's current value.
 *
 * When reading from OTP_BIST_C.BDONE, this is recommended to use.
 *
 * @return current value of OTP_BIST_C.BDONE
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BDONE__GET(void)
{
    uint32_t reg = OTP_SH_OTP_BIST_C__GET();
    reg = (reg & OTP_SH_OTP_BIST_C__BDONE__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BDONE__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_BIST_C__BDONE__EXTRACT() extracts OTP_BIST_C.BDONE.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_BIST_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_BIST_C
 * @return current value of OTP_BIST_C.BDONE
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BDONE__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_BIST_C__BDONE__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BDONE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ OTP_SH.OTP_BIST_C.BFAIL ------------------------ */


#define OTP_SH_OTP_BIST_C__BFAIL__Pos                           5                                                                      /*!< Right-most bit position of BFAIL in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BFAIL__Msk                           (0x00000001UL << OTP_SH_OTP_BIST_C__BFAIL__Pos)                        /*!< Mask for BFAIL in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BFAIL__Shift(v)                      (((v) << OTP_SH_OTP_BIST_C__BFAIL__Pos) & OTP_SH_OTP_BIST_C__BFAIL__Msk) /*!< Shift value 'v' into BFAIL and mask 'v' to fit it into BFAIL field */

/** OTP_SH_OTP_BIST_C__BFAIL__GET() gets OTP_BIST_C.BFAIL's current value.
 *
 * When reading from OTP_BIST_C.BFAIL, this is recommended to use.
 *
 * @return current value of OTP_BIST_C.BFAIL
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BFAIL__GET(void)
{
    uint32_t reg = OTP_SH_OTP_BIST_C__GET();
    reg = (reg & OTP_SH_OTP_BIST_C__BFAIL__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BFAIL__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_BIST_C__BFAIL__EXTRACT() extracts OTP_BIST_C.BFAIL.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_BIST_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_BIST_C
 * @return current value of OTP_BIST_C.BFAIL
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BFAIL__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_BIST_C__BFAIL__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BFAIL__Pos);
    return (uint32_t)reg;
}

/* ------------------------ OTP_SH.OTP_BIST_C.BBUSY ------------------------ */


#define OTP_SH_OTP_BIST_C__BBUSY__Pos                           4                                                                      /*!< Right-most bit position of BBUSY in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BBUSY__Msk                           (0x00000001UL << OTP_SH_OTP_BIST_C__BBUSY__Pos)                        /*!< Mask for BBUSY in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BBUSY__Shift(v)                      (((v) << OTP_SH_OTP_BIST_C__BBUSY__Pos) & OTP_SH_OTP_BIST_C__BBUSY__Msk) /*!< Shift value 'v' into BBUSY and mask 'v' to fit it into BBUSY field */

/** OTP_SH_OTP_BIST_C__BBUSY__GET() gets OTP_BIST_C.BBUSY's current value.
 *
 * When reading from OTP_BIST_C.BBUSY, this is recommended to use.
 *
 * @return current value of OTP_BIST_C.BBUSY
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BBUSY__GET(void)
{
    uint32_t reg = OTP_SH_OTP_BIST_C__GET();
    reg = (reg & OTP_SH_OTP_BIST_C__BBUSY__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BBUSY__Pos);
    return (uint32_t)reg;
}

/** OTP_SH_OTP_BIST_C__BBUSY__EXTRACT() extracts OTP_BIST_C.BBUSY.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_BIST_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_BIST_C
 * @return current value of OTP_BIST_C.BBUSY
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BBUSY__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_BIST_C__BBUSY__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BBUSY__Pos);
    return (uint32_t)reg;
}

/* ---------------------- OTP_SH.OTP_BIST_C.BMODE_SEL ---------------------- */


/*lint -parent(uint32_t, otp_sh_otp_bist_c__bmode_sel_t) -strong(AJX)*/
typedef enum otp_sh_otp_bist_c__bmode_sel_e                                                                                            /*!<  */
{
    otp_sh_otp_bist_c__bmode_sel_main = 0u,                                                                                            /*!<  */
    otp_sh_otp_bist_c__bmode_sel_boot = 1u,                                                                                            /*!<  */
    otp_sh_otp_bist_c__bmode_sel_rdnt = 2u                                                                                             /*!<  */
} otp_sh_otp_bist_c__bmode_sel_t;

#define OTP_SH_OTP_BIST_C__BMODE_SEL__Pos                       0                                                                      /*!< Right-most bit position of BMODE_SEL in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BMODE_SEL__Msk                       (0x00000007UL << OTP_SH_OTP_BIST_C__BMODE_SEL__Pos)                    /*!< Mask for BMODE_SEL in OTP_SH.OTP_BIST_C */
#define OTP_SH_OTP_BIST_C__BMODE_SEL__Shift(v)                  (((v) << OTP_SH_OTP_BIST_C__BMODE_SEL__Pos) & OTP_SH_OTP_BIST_C__BMODE_SEL__Msk) /*!< Shift value 'v' into BMODE_SEL and mask 'v' to fit it into BMODE_SEL field */

/** OTP_SH_OTP_BIST_C__BMODE_SEL__SET() sets OTP_BIST_C.BMODE_SEL to given value.
 *
 * When writing to OTP_BIST_C.BMODE_SEL, this is recommended to use.
 *
 * @param bf_value new value for OTP_BIST_C.BMODE_SEL
 */
__OTP_SH_INLINE void OTP_SH_OTP_BIST_C__BMODE_SEL__SET(otp_sh_otp_bist_c__bmode_sel_t bf_value)
{
    uint32_t reg = OTP_SH_OTP_BIST_C__GET();
    reg = (reg & ~OTP_SH_OTP_BIST_C__BMODE_SEL__Msk);
    reg = (reg | (OTP_SH_OTP_BIST_C__BMODE_SEL__Shift((uint32_t)bf_value)));
    OTP_SH_OTP_BIST_C__SET(reg);
}

/** OTP_SH_OTP_BIST_C__BMODE_SEL__GET() gets OTP_BIST_C.BMODE_SEL's current value.
 *
 * When reading from OTP_BIST_C.BMODE_SEL, this is recommended to use.
 *
 * @return current value of OTP_BIST_C.BMODE_SEL
 */
__OTP_SH_INLINE otp_sh_otp_bist_c__bmode_sel_t OTP_SH_OTP_BIST_C__BMODE_SEL__GET(void)
{
    uint32_t reg = OTP_SH_OTP_BIST_C__GET();
    reg = (reg & OTP_SH_OTP_BIST_C__BMODE_SEL__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BMODE_SEL__Pos);
    return (otp_sh_otp_bist_c__bmode_sel_t)reg;
}

/** OTP_SH_OTP_BIST_C__BMODE_SEL__MODIFY() modifies OTP_BIST_C.BMODE_SEL.
 *
 * This is recommended to use when setting more than one bitfield of OTP_SH.OTP_BIST_C.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of OTP_SH.OTP_BIST_C
 * @param bf_value new value for OTP_BIST_C.BMODE_SEL
 * @return new value of OTP_SH.OTP_BIST_C
 */
__OTP_SH_INLINE uint32_t OTP_SH_OTP_BIST_C__BMODE_SEL__MODIFY(uint32_t reg, otp_sh_otp_bist_c__bmode_sel_t bf_value)
{
    reg = (reg & ~OTP_SH_OTP_BIST_C__BMODE_SEL__Msk);
    reg = (reg | (OTP_SH_OTP_BIST_C__BMODE_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** OTP_SH_OTP_BIST_C__BMODE_SEL__EXTRACT() extracts OTP_BIST_C.BMODE_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from OTP_SH.OTP_BIST_C.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of OTP_SH.OTP_BIST_C
 * @return current value of OTP_BIST_C.BMODE_SEL
 */
__OTP_SH_INLINE otp_sh_otp_bist_c__bmode_sel_t OTP_SH_OTP_BIST_C__BMODE_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & OTP_SH_OTP_BIST_C__BMODE_SEL__Msk);
    reg = (reg >> OTP_SH_OTP_BIST_C__BMODE_SEL__Pos);
    return (otp_sh_otp_bist_c__bmode_sel_t)reg;
}

/** @} */ /* End of group otp_sh block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_OTP_SH_H_ */
