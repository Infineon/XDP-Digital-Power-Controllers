/**
 * @file     shasta_hal_pmbus.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_PMBUS_H_
#define _SHASTA_HAL_PMBUS_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup pmbus
 * @{
 */

#if defined ( __CC_ARM )
#define __PMBUS_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __PMBUS_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __PMBUS_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __PMBUS_INLINE  static inline
#endif

/** register file of the pmbus block.
 */
typedef struct _PMBUS_s
{
    volatile        uint32_t        STATUS                      ; /*!< (@0x00000000)  */
    volatile        uint32_t        CNFG                        ; /*!< (@0x00000004)  */
    volatile        uint32_t        ISR                         ; /*!< (@0x00000008)  */
    volatile        uint32_t        ARA_CW                      ; /*!< (@0x0000000C)  */
    volatile        uint32_t        CTRL_RX                     ; /*!< (@0x00000010)  */
    volatile        uint32_t        RXDATA                      ; /*!< (@0x00000014)  */
    volatile        uint32_t        RXPEC                       ; /*!< (@0x00000018)  */
    volatile        uint8_t         REGMEMGAP0[4]               ; /*!< (@0x0000001C) gap in address space */
    volatile        uint32_t        CTRL_TX                     ; /*!< (@0x00000020)  */
    volatile        uint32_t        TXDATA                      ; /*!< (@0x00000024)  */
    volatile        uint32_t        TXPEC                       ; /*!< (@0x00000028)  */
    volatile        uint32_t        DMA_CTRL                    ; /*!< (@0x0000002C)  */
    volatile        uint8_t         REGMEMGAP1[16]              ; /*!< (@0x00000030) gap in address space */
    volatile        uint32_t        ADDR_LUT[8]                 ; /*!< (@0x00000040)  */
    volatile        uint8_t         REGMEMGAP2[32]              ; /*!< (@0x00000060) gap in address space */
    volatile        uint32_t        DATA_LUT[8]                 ; /*!< (@0x00000080)  */
    volatile        uint8_t         REGMEMGAP3[32]              ; /*!< (@0x000000A0) gap in address space */
    volatile        uint32_t        DATA_LUT_BIT_SET            ; /*!< (@0x000000C0)  */
    volatile        uint32_t        DATA_LUT_BIT_CLR            ; /*!< (@0x000000C4)  */
    volatile        uint8_t         REGMEMGAP4[56]              ; /*!< (@0x000000C8) gap in address space */
    volatile        uint32_t        STATUS_WORD[2]              ; /*!< (@0x00000100)  */
    volatile        uint32_t        STATUS_VOUT[2]              ; /*!< (@0x00000108)  */
    volatile        uint32_t        STATUS_IOUT[2]              ; /*!< (@0x00000110)  */
    volatile        uint32_t        STATUS_INPUT[2]             ; /*!< (@0x00000118)  */
    volatile        uint32_t        STATUS_TEMP[2]              ; /*!< (@0x00000120)  */
    volatile        uint32_t        STATUS_CML[2]               ; /*!< (@0x00000128)  */
    volatile        uint32_t        STATUS_OTHER[2]             ; /*!< (@0x00000130)  */
    volatile        uint32_t        STATUS_MFR[2]               ; /*!< (@0x00000138)  */
    volatile        uint32_t        STATUS_FAN12[2]             ; /*!< (@0x00000140)  */
    volatile        uint32_t        STATUS_PWRGOOD[2]           ; /*!< (@0x00000148)  */
    volatile        uint32_t        STATUS_OFF[2]               ; /*!< (@0x00000150)  */
    volatile        uint32_t        STATUS_BUSY[2]              ; /*!< (@0x00000158)  */
    volatile        uint32_t        STATUS_UNKNOWN[2]           ; /*!< (@0x00000160)  */
    volatile        uint32_t        STATUS_CLEAR_ALL[2]         ; /*!< (@0x00000168) Clears all status except PWRGOOD and OFF */
    volatile        uint32_t        STATUS_MASK_LP0[8]          ; /*!< (@0x00000170)  */
    volatile        uint32_t        STATUS_MASK_LP1[8]          ; /*!< (@0x00000190)  */
} PMBUS_t;

/** enumeration of PMBUS.ADDR_LUT member index
 */
/*lint -parent(uint32_t, pmbus_addr_lut_idx_t) -strong(AJX)*/
typedef enum _pmbus_addr_lut_idx_e
{
    pmbus_addr_lut_0 = 0u,    //!< Index 0
    pmbus_addr_lut_1 = 1u,    //!< Index 1
    pmbus_addr_lut_2 = 2u,    //!< Index 2
    pmbus_addr_lut_3 = 3u,    //!< Index 3
    pmbus_addr_lut_4 = 4u,    //!< Index 4
    pmbus_addr_lut_5 = 5u,    //!< Index 5
    pmbus_addr_lut_6 = 6u,    //!< Index 6
    pmbus_addr_lut_7 = 7u     //!< Index 7
} pmbus_addr_lut_idx_t;

/** enumeration of PMBUS.DATA_LUT member index
 */
/*lint -parent(uint32_t, pmbus_data_lut_idx_t) -strong(AJX)*/
typedef enum _pmbus_data_lut_idx_e
{
    pmbus_data_lut_0 = 0u,    //!< Index 0
    pmbus_data_lut_1 = 1u,    //!< Index 1
    pmbus_data_lut_2 = 2u,    //!< Index 2
    pmbus_data_lut_3 = 3u,    //!< Index 3
    pmbus_data_lut_4 = 4u,    //!< Index 4
    pmbus_data_lut_5 = 5u,    //!< Index 5
    pmbus_data_lut_6 = 6u,    //!< Index 6
    pmbus_data_lut_7 = 7u     //!< Index 7
} pmbus_data_lut_idx_t;

/** @todo dlewis4 - hand edited hal after auto gen here to add common enum, autogen can't handle this **/
/** enumeration of PMBUS.STATUS_WORD member index
 */
/*lint -parent(uint32_t, pmbus_status_loop_idx_t) -strong(AJX)*/
typedef enum _pmbus_status_loop_idx_e
{
    pmbus_status_word_0 = 0u,    //!< Index 0
    pmbus_status_word_1 = 1u     //!< Index 1
} pmbus_status_loop_idx_t;

/** enumeration of PMBUS.STATUS_MASK_LP0 member index
 */
/*lint -parent(uint32_t, pmbus_status_mask_lp0_idx_t) -strong(AJX)*/
typedef enum _pmbus_status_mask_lp0_idx_e
{
    pmbus_status_mask_lp0_0 = 0u,    //!< Index 0
    pmbus_status_mask_lp0_1 = 1u,    //!< Index 1
    pmbus_status_mask_lp0_2 = 2u,    //!< Index 2
    pmbus_status_mask_lp0_3 = 3u,    //!< Index 3
    pmbus_status_mask_lp0_4 = 4u,    //!< Index 4
    pmbus_status_mask_lp0_5 = 5u,    //!< Index 5
    pmbus_status_mask_lp0_6 = 6u,    //!< Index 6
    pmbus_status_mask_lp0_7 = 7u     //!< Index 7
} pmbus_status_mask_lp0_idx_t;

/** enumeration of PMBUS.STATUS_MASK_LP1 member index
 */
/*lint -parent(uint32_t, pmbus_status_mask_lp1_idx_t) -strong(AJX)*/
typedef enum _pmbus_status_mask_lp1_idx_e
{
    pmbus_status_mask_lp1_0 = 0u,    //!< Index 0
    pmbus_status_mask_lp1_1 = 1u,    //!< Index 1
    pmbus_status_mask_lp1_2 = 2u,    //!< Index 2
    pmbus_status_mask_lp1_3 = 3u,    //!< Index 3
    pmbus_status_mask_lp1_4 = 4u,    //!< Index 4
    pmbus_status_mask_lp1_5 = 5u,    //!< Index 5
    pmbus_status_mask_lp1_6 = 6u,    //!< Index 6
    pmbus_status_mask_lp1_7 = 7u     //!< Index 7
} pmbus_status_mask_lp1_idx_t;


#define PMBUS_BASE (0x70080000u)                                                          /*!< pmbus base address */

/** __PMBUS_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__PMBUS_INLINE uint32_t* __PMBUS_BASE_PTR(void)
{
    return (uint32_t*)(PMBUS_BASE);
}


/* -------------------------------------------------------------------------- */
/*                          STATUS member of PMBUS_t                          */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS__ADDRESS returns the address of member STATUS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of STATUS
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS)));
}

/** PMBUS_STATUS__GET() gets STATUS's current value.
 *
 * When reading from STATUS, this is mandatory to use.
 *
 * @return current value of STATUS
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__GET(void)
{
    return HAL_GET32(__PMBUS_STATUS__ADDRESS());
}

/* --------------------- PMBUS.STATUS.TOO_LONG_SCL_HIGH --------------------- */


#define PMBUS_STATUS__TOO_LONG_SCL_HIGH__Pos                    29                                                                     /*!< Right-most bit position of TOO_LONG_SCL_HIGH in PMBUS.STATUS */
#define PMBUS_STATUS__TOO_LONG_SCL_HIGH__Msk                    (0x00000001UL << PMBUS_STATUS__TOO_LONG_SCL_HIGH__Pos)                 /*!< Mask for TOO_LONG_SCL_HIGH in PMBUS.STATUS */
#define PMBUS_STATUS__TOO_LONG_SCL_HIGH__Shift(v)               (((v) << PMBUS_STATUS__TOO_LONG_SCL_HIGH__Pos) & PMBUS_STATUS__TOO_LONG_SCL_HIGH__Msk) /*!< Shift value 'v' into TOO_LONG_SCL_HIGH and mask 'v' to fit it into TOO_LONG_SCL_HIGH field */

/** PMBUS_STATUS__TOO_LONG_SCL_HIGH__GET() gets STATUS.TOO_LONG_SCL_HIGH's current value.
 *
 * When reading from STATUS.TOO_LONG_SCL_HIGH, this is recommended to use.
 *
 * @return current value of STATUS.TOO_LONG_SCL_HIGH
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__TOO_LONG_SCL_HIGH__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__TOO_LONG_SCL_HIGH__Msk);
    reg = (reg >> PMBUS_STATUS__TOO_LONG_SCL_HIGH__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__TOO_LONG_SCL_HIGH__EXTRACT() extracts STATUS.TOO_LONG_SCL_HIGH.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.TOO_LONG_SCL_HIGH
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__TOO_LONG_SCL_HIGH__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__TOO_LONG_SCL_HIGH__Msk);
    reg = (reg >> PMBUS_STATUS__TOO_LONG_SCL_HIGH__Pos);
    return (uint32_t)reg;
}

/* ----------------- PMBUS.STATUS.FISRT_TO_ASSERT_SMBALERT ----------------- */


#define PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__Pos             28                                                                     /*!< Right-most bit position of FISRT_TO_ASSERT_SMBALERT in PMBUS.STATUS */
#define PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__Msk             (0x00000001UL << PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__Pos)          /*!< Mask for FISRT_TO_ASSERT_SMBALERT in PMBUS.STATUS */
#define PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__Shift(v)        (((v) << PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__Pos) & PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__Msk) /*!< Shift value 'v' into FISRT_TO_ASSERT_SMBALERT and mask 'v' to fit it into FISRT_TO_ASSERT_SMBALERT field */

/** PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__GET() gets STATUS.FISRT_TO_ASSERT_SMBALERT's current value.
 *
 * When reading from STATUS.FISRT_TO_ASSERT_SMBALERT, this is recommended to use.
 *
 * @return current value of STATUS.FISRT_TO_ASSERT_SMBALERT
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__Msk);
    reg = (reg >> PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__EXTRACT() extracts STATUS.FISRT_TO_ASSERT_SMBALERT.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.FISRT_TO_ASSERT_SMBALERT
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__Msk);
    reg = (reg >> PMBUS_STATUS__FISRT_TO_ASSERT_SMBALERT__Pos);
    return (uint32_t)reg;
}

/* -------------------------- PMBUS.STATUS.SDA_IN -------------------------- */


#define PMBUS_STATUS__SDA_IN__Pos                               27                                                                     /*!< Right-most bit position of SDA_IN in PMBUS.STATUS */
#define PMBUS_STATUS__SDA_IN__Msk                               (0x00000001UL << PMBUS_STATUS__SDA_IN__Pos)                            /*!< Mask for SDA_IN in PMBUS.STATUS */
#define PMBUS_STATUS__SDA_IN__Shift(v)                          (((v) << PMBUS_STATUS__SDA_IN__Pos) & PMBUS_STATUS__SDA_IN__Msk)       /*!< Shift value 'v' into SDA_IN and mask 'v' to fit it into SDA_IN field */

/** PMBUS_STATUS__SDA_IN__GET() gets STATUS.SDA_IN's current value.
 *
 * When reading from STATUS.SDA_IN, this is recommended to use.
 *
 * @return current value of STATUS.SDA_IN
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__SDA_IN__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__SDA_IN__Msk);
    reg = (reg >> PMBUS_STATUS__SDA_IN__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__SDA_IN__EXTRACT() extracts STATUS.SDA_IN.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.SDA_IN
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__SDA_IN__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__SDA_IN__Msk);
    reg = (reg >> PMBUS_STATUS__SDA_IN__Pos);
    return (uint32_t)reg;
}

/* -------------------------- PMBUS.STATUS.SCL_IN -------------------------- */


#define PMBUS_STATUS__SCL_IN__Pos                               26                                                                     /*!< Right-most bit position of SCL_IN in PMBUS.STATUS */
#define PMBUS_STATUS__SCL_IN__Msk                               (0x00000001UL << PMBUS_STATUS__SCL_IN__Pos)                            /*!< Mask for SCL_IN in PMBUS.STATUS */
#define PMBUS_STATUS__SCL_IN__Shift(v)                          (((v) << PMBUS_STATUS__SCL_IN__Pos) & PMBUS_STATUS__SCL_IN__Msk)       /*!< Shift value 'v' into SCL_IN and mask 'v' to fit it into SCL_IN field */

/** PMBUS_STATUS__SCL_IN__GET() gets STATUS.SCL_IN's current value.
 *
 * When reading from STATUS.SCL_IN, this is recommended to use.
 *
 * @return current value of STATUS.SCL_IN
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__SCL_IN__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__SCL_IN__Msk);
    reg = (reg >> PMBUS_STATUS__SCL_IN__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__SCL_IN__EXTRACT() extracts STATUS.SCL_IN.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.SCL_IN
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__SCL_IN__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__SCL_IN__Msk);
    reg = (reg >> PMBUS_STATUS__SCL_IN__Pos);
    return (uint32_t)reg;
}

/* ------------------- PMBUS.STATUS.TOO_LONG_SCL_STRETCH ------------------- */


#define PMBUS_STATUS__TOO_LONG_SCL_STRETCH__Pos                 25                                                                     /*!< Right-most bit position of TOO_LONG_SCL_STRETCH in PMBUS.STATUS */
#define PMBUS_STATUS__TOO_LONG_SCL_STRETCH__Msk                 (0x00000001UL << PMBUS_STATUS__TOO_LONG_SCL_STRETCH__Pos)              /*!< Mask for TOO_LONG_SCL_STRETCH in PMBUS.STATUS */
#define PMBUS_STATUS__TOO_LONG_SCL_STRETCH__Shift(v)            (((v) << PMBUS_STATUS__TOO_LONG_SCL_STRETCH__Pos) & PMBUS_STATUS__TOO_LONG_SCL_STRETCH__Msk) /*!< Shift value 'v' into TOO_LONG_SCL_STRETCH and mask 'v' to fit it into TOO_LONG_SCL_STRETCH field */

/** PMBUS_STATUS__TOO_LONG_SCL_STRETCH__GET() gets STATUS.TOO_LONG_SCL_STRETCH's current value.
 *
 * When reading from STATUS.TOO_LONG_SCL_STRETCH, this is recommended to use.
 *
 * @return current value of STATUS.TOO_LONG_SCL_STRETCH
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__TOO_LONG_SCL_STRETCH__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__TOO_LONG_SCL_STRETCH__Msk);
    reg = (reg >> PMBUS_STATUS__TOO_LONG_SCL_STRETCH__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__TOO_LONG_SCL_STRETCH__EXTRACT() extracts STATUS.TOO_LONG_SCL_STRETCH.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.TOO_LONG_SCL_STRETCH
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__TOO_LONG_SCL_STRETCH__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__TOO_LONG_SCL_STRETCH__Msk);
    reg = (reg >> PMBUS_STATUS__TOO_LONG_SCL_STRETCH__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PMBUS.STATUS.BUS_CONTENTION ---------------------- */


#define PMBUS_STATUS__BUS_CONTENTION__Pos                       24                                                                     /*!< Right-most bit position of BUS_CONTENTION in PMBUS.STATUS */
#define PMBUS_STATUS__BUS_CONTENTION__Msk                       (0x00000001UL << PMBUS_STATUS__BUS_CONTENTION__Pos)                    /*!< Mask for BUS_CONTENTION in PMBUS.STATUS */
#define PMBUS_STATUS__BUS_CONTENTION__Shift(v)                  (((v) << PMBUS_STATUS__BUS_CONTENTION__Pos) & PMBUS_STATUS__BUS_CONTENTION__Msk) /*!< Shift value 'v' into BUS_CONTENTION and mask 'v' to fit it into BUS_CONTENTION field */

/** PMBUS_STATUS__BUS_CONTENTION__GET() gets STATUS.BUS_CONTENTION's current value.
 *
 * When reading from STATUS.BUS_CONTENTION, this is recommended to use.
 *
 * @return current value of STATUS.BUS_CONTENTION
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__BUS_CONTENTION__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__BUS_CONTENTION__Msk);
    reg = (reg >> PMBUS_STATUS__BUS_CONTENTION__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__BUS_CONTENTION__EXTRACT() extracts STATUS.BUS_CONTENTION.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.BUS_CONTENTION
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__BUS_CONTENTION__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__BUS_CONTENTION__Msk);
    reg = (reg >> PMBUS_STATUS__BUS_CONTENTION__Pos);
    return (uint32_t)reg;
}

/* ------------------------ PMBUS.STATUS.BYTE_CNT_TX ------------------------ */


#define PMBUS_STATUS__BYTE_CNT_TX__Pos                          16                                                                     /*!< Right-most bit position of BYTE_CNT_TX in PMBUS.STATUS */
#define PMBUS_STATUS__BYTE_CNT_TX__Msk                          (0x000000FFUL << PMBUS_STATUS__BYTE_CNT_TX__Pos)                       /*!< Mask for BYTE_CNT_TX in PMBUS.STATUS */
#define PMBUS_STATUS__BYTE_CNT_TX__Shift(v)                     (((v) << PMBUS_STATUS__BYTE_CNT_TX__Pos) & PMBUS_STATUS__BYTE_CNT_TX__Msk) /*!< Shift value 'v' into BYTE_CNT_TX and mask 'v' to fit it into BYTE_CNT_TX field */

/** PMBUS_STATUS__BYTE_CNT_TX__GET() gets STATUS.BYTE_CNT_TX's current value.
 *
 * When reading from STATUS.BYTE_CNT_TX, this is recommended to use.
 *
 * @return current value of STATUS.BYTE_CNT_TX
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__BYTE_CNT_TX__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__BYTE_CNT_TX__Msk);
    reg = (reg >> PMBUS_STATUS__BYTE_CNT_TX__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__BYTE_CNT_TX__EXTRACT() extracts STATUS.BYTE_CNT_TX.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.BYTE_CNT_TX
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__BYTE_CNT_TX__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__BYTE_CNT_TX__Msk);
    reg = (reg >> PMBUS_STATUS__BYTE_CNT_TX__Pos);
    return (uint32_t)reg;
}

/* ------------------------ PMBUS.STATUS.BYTE_CNT_RX ------------------------ */


#define PMBUS_STATUS__BYTE_CNT_RX__Pos                          8                                                                      /*!< Right-most bit position of BYTE_CNT_RX in PMBUS.STATUS */
#define PMBUS_STATUS__BYTE_CNT_RX__Msk                          (0x000000FFUL << PMBUS_STATUS__BYTE_CNT_RX__Pos)                       /*!< Mask for BYTE_CNT_RX in PMBUS.STATUS */
#define PMBUS_STATUS__BYTE_CNT_RX__Shift(v)                     (((v) << PMBUS_STATUS__BYTE_CNT_RX__Pos) & PMBUS_STATUS__BYTE_CNT_RX__Msk) /*!< Shift value 'v' into BYTE_CNT_RX and mask 'v' to fit it into BYTE_CNT_RX field */

/** PMBUS_STATUS__BYTE_CNT_RX__GET() gets STATUS.BYTE_CNT_RX's current value.
 *
 * When reading from STATUS.BYTE_CNT_RX, this is recommended to use.
 *
 * @return current value of STATUS.BYTE_CNT_RX
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__BYTE_CNT_RX__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__BYTE_CNT_RX__Msk);
    reg = (reg >> PMBUS_STATUS__BYTE_CNT_RX__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__BYTE_CNT_RX__EXTRACT() extracts STATUS.BYTE_CNT_RX.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.BYTE_CNT_RX
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__BYTE_CNT_RX__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__BYTE_CNT_RX__Msk);
    reg = (reg >> PMBUS_STATUS__BYTE_CNT_RX__Pos);
    return (uint32_t)reg;
}

/* -------------------------- PMBUS.STATUS.BIT_CNT -------------------------- */


#define PMBUS_STATUS__BIT_CNT__Pos                              4                                                                      /*!< Right-most bit position of BIT_CNT in PMBUS.STATUS */
#define PMBUS_STATUS__BIT_CNT__Msk                              (0x0000000FUL << PMBUS_STATUS__BIT_CNT__Pos)                           /*!< Mask for BIT_CNT in PMBUS.STATUS */
#define PMBUS_STATUS__BIT_CNT__Shift(v)                         (((v) << PMBUS_STATUS__BIT_CNT__Pos) & PMBUS_STATUS__BIT_CNT__Msk)     /*!< Shift value 'v' into BIT_CNT and mask 'v' to fit it into BIT_CNT field */

/** PMBUS_STATUS__BIT_CNT__GET() gets STATUS.BIT_CNT's current value.
 *
 * When reading from STATUS.BIT_CNT, this is recommended to use.
 *
 * @return current value of STATUS.BIT_CNT
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__BIT_CNT__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__BIT_CNT__Msk);
    reg = (reg >> PMBUS_STATUS__BIT_CNT__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__BIT_CNT__EXTRACT() extracts STATUS.BIT_CNT.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.BIT_CNT
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__BIT_CNT__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__BIT_CNT__Msk);
    reg = (reg >> PMBUS_STATUS__BIT_CNT__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PMBUS.STATUS.TOO_FEW_BITS ----------------------- */


#define PMBUS_STATUS__TOO_FEW_BITS__Pos                         3                                                                      /*!< Right-most bit position of TOO_FEW_BITS in PMBUS.STATUS */
#define PMBUS_STATUS__TOO_FEW_BITS__Msk                         (0x00000001UL << PMBUS_STATUS__TOO_FEW_BITS__Pos)                      /*!< Mask for TOO_FEW_BITS in PMBUS.STATUS */
#define PMBUS_STATUS__TOO_FEW_BITS__Shift(v)                    (((v) << PMBUS_STATUS__TOO_FEW_BITS__Pos) & PMBUS_STATUS__TOO_FEW_BITS__Msk) /*!< Shift value 'v' into TOO_FEW_BITS and mask 'v' to fit it into TOO_FEW_BITS field */

/** PMBUS_STATUS__TOO_FEW_BITS__GET() gets STATUS.TOO_FEW_BITS's current value.
 *
 * When reading from STATUS.TOO_FEW_BITS, this is recommended to use.
 *
 * @return current value of STATUS.TOO_FEW_BITS
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__TOO_FEW_BITS__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__TOO_FEW_BITS__Msk);
    reg = (reg >> PMBUS_STATUS__TOO_FEW_BITS__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__TOO_FEW_BITS__EXTRACT() extracts STATUS.TOO_FEW_BITS.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.TOO_FEW_BITS
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__TOO_FEW_BITS__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__TOO_FEW_BITS__Msk);
    reg = (reg >> PMBUS_STATUS__TOO_FEW_BITS__Pos);
    return (uint32_t)reg;
}

/* ------------------------ PMBUS.STATUS.ACK_STATUS ------------------------ */


#define PMBUS_STATUS__ACK_STATUS__Pos                           2                                                                      /*!< Right-most bit position of ACK_STATUS in PMBUS.STATUS */
#define PMBUS_STATUS__ACK_STATUS__Msk                           (0x00000001UL << PMBUS_STATUS__ACK_STATUS__Pos)                        /*!< Mask for ACK_STATUS in PMBUS.STATUS */
#define PMBUS_STATUS__ACK_STATUS__Shift(v)                      (((v) << PMBUS_STATUS__ACK_STATUS__Pos) & PMBUS_STATUS__ACK_STATUS__Msk) /*!< Shift value 'v' into ACK_STATUS and mask 'v' to fit it into ACK_STATUS field */

/** PMBUS_STATUS__ACK_STATUS__GET() gets STATUS.ACK_STATUS's current value.
 *
 * When reading from STATUS.ACK_STATUS, this is recommended to use.
 *
 * @return current value of STATUS.ACK_STATUS
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__ACK_STATUS__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__ACK_STATUS__Msk);
    reg = (reg >> PMBUS_STATUS__ACK_STATUS__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__ACK_STATUS__EXTRACT() extracts STATUS.ACK_STATUS.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.ACK_STATUS
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__ACK_STATUS__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__ACK_STATUS__Msk);
    reg = (reg >> PMBUS_STATUS__ACK_STATUS__Pos);
    return (uint32_t)reg;
}

/* ------------------------- PMBUS.STATUS.DIRECTION ------------------------- */


#define PMBUS_STATUS__DIRECTION__Pos                            1                                                                      /*!< Right-most bit position of DIRECTION in PMBUS.STATUS */
#define PMBUS_STATUS__DIRECTION__Msk                            (0x00000001UL << PMBUS_STATUS__DIRECTION__Pos)                         /*!< Mask for DIRECTION in PMBUS.STATUS */
#define PMBUS_STATUS__DIRECTION__Shift(v)                       (((v) << PMBUS_STATUS__DIRECTION__Pos) & PMBUS_STATUS__DIRECTION__Msk) /*!< Shift value 'v' into DIRECTION and mask 'v' to fit it into DIRECTION field */

/** PMBUS_STATUS__DIRECTION__GET() gets STATUS.DIRECTION's current value.
 *
 * When reading from STATUS.DIRECTION, this is recommended to use.
 *
 * @return current value of STATUS.DIRECTION
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__DIRECTION__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__DIRECTION__Msk);
    reg = (reg >> PMBUS_STATUS__DIRECTION__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__DIRECTION__EXTRACT() extracts STATUS.DIRECTION.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.DIRECTION
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__DIRECTION__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__DIRECTION__Msk);
    reg = (reg >> PMBUS_STATUS__DIRECTION__Pos);
    return (uint32_t)reg;
}

/* --------------------------- PMBUS.STATUS.BUSY --------------------------- */


#define PMBUS_STATUS__BUSY__Pos                                 0                                                                      /*!< Right-most bit position of BUSY in PMBUS.STATUS */
#define PMBUS_STATUS__BUSY__Msk                                 (0x00000001UL << PMBUS_STATUS__BUSY__Pos)                              /*!< Mask for BUSY in PMBUS.STATUS */
#define PMBUS_STATUS__BUSY__Shift(v)                            (((v) << PMBUS_STATUS__BUSY__Pos) & PMBUS_STATUS__BUSY__Msk)           /*!< Shift value 'v' into BUSY and mask 'v' to fit it into BUSY field */

/** PMBUS_STATUS__BUSY__GET() gets STATUS.BUSY's current value.
 *
 * When reading from STATUS.BUSY, this is recommended to use.
 *
 * @return current value of STATUS.BUSY
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__BUSY__GET(void)
{
    uint32_t reg = PMBUS_STATUS__GET();
    reg = (reg & PMBUS_STATUS__BUSY__Msk);
    reg = (reg >> PMBUS_STATUS__BUSY__Pos);
    return (uint32_t)reg;
}

/** PMBUS_STATUS__BUSY__EXTRACT() extracts STATUS.BUSY.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.STATUS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.STATUS
 * @return current value of STATUS.BUSY
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS__BUSY__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_STATUS__BUSY__Msk);
    reg = (reg >> PMBUS_STATUS__BUSY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           CNFG member of PMBUS_t                           */
/* -------------------------------------------------------------------------- */

/** __PMBUS_CNFG__ADDRESS returns the address of member CNFG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CNFG
 */
__PMBUS_INLINE uint32_t* __PMBUS_CNFG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, CNFG)));
}

/** PMBUS_CNFG__SET() sets CNFG to given value.
 *
 * When writing to CNFG, this is mandatory to use.
 *
 * @param value new value for CNFG
 */
__PMBUS_INLINE void PMBUS_CNFG__SET(uint32_t value)
{
    HAL_SET32(__PMBUS_CNFG__ADDRESS(), value);
}

/** PMBUS_CNFG__GET() gets CNFG's current value.
 *
 * When reading from CNFG, this is mandatory to use.
 *
 * @return current value of CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__GET(void)
{
    return HAL_GET32(__PMBUS_CNFG__ADDRESS());
}

/* ----------------------- PMBUS.CNFG.WDT_SCL_LOW_MAX ----------------------- */


#define PMBUS_CNFG__WDT_SCL_LOW_MAX__Pos                        19                                                                     /*!< Right-most bit position of WDT_SCL_LOW_MAX in PMBUS.CNFG */
#define PMBUS_CNFG__WDT_SCL_LOW_MAX__Msk                        (0x00001FFFUL << PMBUS_CNFG__WDT_SCL_LOW_MAX__Pos)                     /*!< Mask for WDT_SCL_LOW_MAX in PMBUS.CNFG */
#define PMBUS_CNFG__WDT_SCL_LOW_MAX__Shift(v)                   (((v) << PMBUS_CNFG__WDT_SCL_LOW_MAX__Pos) & PMBUS_CNFG__WDT_SCL_LOW_MAX__Msk) /*!< Shift value 'v' into WDT_SCL_LOW_MAX and mask 'v' to fit it into WDT_SCL_LOW_MAX field */

/** PMBUS_CNFG__WDT_SCL_LOW_MAX__SET() sets CNFG.WDT_SCL_LOW_MAX to given value.
 *
 * When writing to CNFG.WDT_SCL_LOW_MAX, this is recommended to use.
 *
 * @param bf_value new value for CNFG.WDT_SCL_LOW_MAX
 */
__PMBUS_INLINE void PMBUS_CNFG__WDT_SCL_LOW_MAX__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & ~PMBUS_CNFG__WDT_SCL_LOW_MAX__Msk);
    reg = (reg | (PMBUS_CNFG__WDT_SCL_LOW_MAX__Shift((uint32_t)bf_value)));
    PMBUS_CNFG__SET(reg);
}

/** PMBUS_CNFG__WDT_SCL_LOW_MAX__GET() gets CNFG.WDT_SCL_LOW_MAX's current value.
 *
 * When reading from CNFG.WDT_SCL_LOW_MAX, this is recommended to use.
 *
 * @return current value of CNFG.WDT_SCL_LOW_MAX
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__WDT_SCL_LOW_MAX__GET(void)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & PMBUS_CNFG__WDT_SCL_LOW_MAX__Msk);
    reg = (reg >> PMBUS_CNFG__WDT_SCL_LOW_MAX__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CNFG__WDT_SCL_LOW_MAX__MODIFY() modifies CNFG.WDT_SCL_LOW_MAX.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CNFG
 * @param bf_value new value for CNFG.WDT_SCL_LOW_MAX
 * @return new value of PMBUS.CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__WDT_SCL_LOW_MAX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CNFG__WDT_SCL_LOW_MAX__Msk);
    reg = (reg | (PMBUS_CNFG__WDT_SCL_LOW_MAX__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CNFG__WDT_SCL_LOW_MAX__EXTRACT() extracts CNFG.WDT_SCL_LOW_MAX.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CNFG
 * @return current value of CNFG.WDT_SCL_LOW_MAX
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__WDT_SCL_LOW_MAX__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CNFG__WDT_SCL_LOW_MAX__Msk);
    reg = (reg >> PMBUS_CNFG__WDT_SCL_LOW_MAX__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PMBUS.CNFG.WDT_SCL_STRETCH ----------------------- */


#define PMBUS_CNFG__WDT_SCL_STRETCH__Pos                        10                                                                     /*!< Right-most bit position of WDT_SCL_STRETCH in PMBUS.CNFG */
#define PMBUS_CNFG__WDT_SCL_STRETCH__Msk                        (0x000001FFUL << PMBUS_CNFG__WDT_SCL_STRETCH__Pos)                     /*!< Mask for WDT_SCL_STRETCH in PMBUS.CNFG */
#define PMBUS_CNFG__WDT_SCL_STRETCH__Shift(v)                   (((v) << PMBUS_CNFG__WDT_SCL_STRETCH__Pos) & PMBUS_CNFG__WDT_SCL_STRETCH__Msk) /*!< Shift value 'v' into WDT_SCL_STRETCH and mask 'v' to fit it into WDT_SCL_STRETCH field */

/** PMBUS_CNFG__WDT_SCL_STRETCH__SET() sets CNFG.WDT_SCL_STRETCH to given value.
 *
 * When writing to CNFG.WDT_SCL_STRETCH, this is recommended to use.
 *
 * @param bf_value new value for CNFG.WDT_SCL_STRETCH
 */
__PMBUS_INLINE void PMBUS_CNFG__WDT_SCL_STRETCH__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & ~PMBUS_CNFG__WDT_SCL_STRETCH__Msk);
    reg = (reg | (PMBUS_CNFG__WDT_SCL_STRETCH__Shift((uint32_t)bf_value)));
    PMBUS_CNFG__SET(reg);
}

/** PMBUS_CNFG__WDT_SCL_STRETCH__GET() gets CNFG.WDT_SCL_STRETCH's current value.
 *
 * When reading from CNFG.WDT_SCL_STRETCH, this is recommended to use.
 *
 * @return current value of CNFG.WDT_SCL_STRETCH
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__WDT_SCL_STRETCH__GET(void)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & PMBUS_CNFG__WDT_SCL_STRETCH__Msk);
    reg = (reg >> PMBUS_CNFG__WDT_SCL_STRETCH__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CNFG__WDT_SCL_STRETCH__MODIFY() modifies CNFG.WDT_SCL_STRETCH.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CNFG
 * @param bf_value new value for CNFG.WDT_SCL_STRETCH
 * @return new value of PMBUS.CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__WDT_SCL_STRETCH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CNFG__WDT_SCL_STRETCH__Msk);
    reg = (reg | (PMBUS_CNFG__WDT_SCL_STRETCH__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CNFG__WDT_SCL_STRETCH__EXTRACT() extracts CNFG.WDT_SCL_STRETCH.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CNFG
 * @return current value of CNFG.WDT_SCL_STRETCH
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__WDT_SCL_STRETCH__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CNFG__WDT_SCL_STRETCH__Msk);
    reg = (reg >> PMBUS_CNFG__WDT_SCL_STRETCH__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PMBUS.CNFG.DEBOUNCE_LENGTH ----------------------- */


#define PMBUS_CNFG__DEBOUNCE_LENGTH__Pos                        7                                                                      /*!< Right-most bit position of DEBOUNCE_LENGTH in PMBUS.CNFG */
#define PMBUS_CNFG__DEBOUNCE_LENGTH__Msk                        (0x00000007UL << PMBUS_CNFG__DEBOUNCE_LENGTH__Pos)                     /*!< Mask for DEBOUNCE_LENGTH in PMBUS.CNFG */
#define PMBUS_CNFG__DEBOUNCE_LENGTH__Shift(v)                   (((v) << PMBUS_CNFG__DEBOUNCE_LENGTH__Pos) & PMBUS_CNFG__DEBOUNCE_LENGTH__Msk) /*!< Shift value 'v' into DEBOUNCE_LENGTH and mask 'v' to fit it into DEBOUNCE_LENGTH field */

/** PMBUS_CNFG__DEBOUNCE_LENGTH__SET() sets CNFG.DEBOUNCE_LENGTH to given value.
 *
 * When writing to CNFG.DEBOUNCE_LENGTH, this is recommended to use.
 *
 * @param bf_value new value for CNFG.DEBOUNCE_LENGTH
 */
__PMBUS_INLINE void PMBUS_CNFG__DEBOUNCE_LENGTH__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & ~PMBUS_CNFG__DEBOUNCE_LENGTH__Msk);
    reg = (reg | (PMBUS_CNFG__DEBOUNCE_LENGTH__Shift((uint32_t)bf_value)));
    PMBUS_CNFG__SET(reg);
}

/** PMBUS_CNFG__DEBOUNCE_LENGTH__GET() gets CNFG.DEBOUNCE_LENGTH's current value.
 *
 * When reading from CNFG.DEBOUNCE_LENGTH, this is recommended to use.
 *
 * @return current value of CNFG.DEBOUNCE_LENGTH
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DEBOUNCE_LENGTH__GET(void)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & PMBUS_CNFG__DEBOUNCE_LENGTH__Msk);
    reg = (reg >> PMBUS_CNFG__DEBOUNCE_LENGTH__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CNFG__DEBOUNCE_LENGTH__MODIFY() modifies CNFG.DEBOUNCE_LENGTH.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CNFG
 * @param bf_value new value for CNFG.DEBOUNCE_LENGTH
 * @return new value of PMBUS.CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DEBOUNCE_LENGTH__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CNFG__DEBOUNCE_LENGTH__Msk);
    reg = (reg | (PMBUS_CNFG__DEBOUNCE_LENGTH__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CNFG__DEBOUNCE_LENGTH__EXTRACT() extracts CNFG.DEBOUNCE_LENGTH.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CNFG
 * @return current value of CNFG.DEBOUNCE_LENGTH
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DEBOUNCE_LENGTH__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CNFG__DEBOUNCE_LENGTH__Msk);
    reg = (reg >> PMBUS_CNFG__DEBOUNCE_LENGTH__Pos);
    return (uint32_t)reg;
}

/* --------------------- PMBUS.CNFG.USE_START_IRQ_DELAY --------------------- */


#define PMBUS_CNFG__USE_START_IRQ_DELAY__Pos                    6                                                                      /*!< Right-most bit position of USE_START_IRQ_DELAY in PMBUS.CNFG */
#define PMBUS_CNFG__USE_START_IRQ_DELAY__Msk                    (0x00000001UL << PMBUS_CNFG__USE_START_IRQ_DELAY__Pos)                 /*!< Mask for USE_START_IRQ_DELAY in PMBUS.CNFG */
#define PMBUS_CNFG__USE_START_IRQ_DELAY__Shift(v)               (((v) << PMBUS_CNFG__USE_START_IRQ_DELAY__Pos) & PMBUS_CNFG__USE_START_IRQ_DELAY__Msk) /*!< Shift value 'v' into USE_START_IRQ_DELAY and mask 'v' to fit it into USE_START_IRQ_DELAY field */

/** PMBUS_CNFG__USE_START_IRQ_DELAY__SET() sets CNFG.USE_START_IRQ_DELAY to given value.
 *
 * When writing to CNFG.USE_START_IRQ_DELAY, this is recommended to use.
 *
 * @param bf_value new value for CNFG.USE_START_IRQ_DELAY
 */
__PMBUS_INLINE void PMBUS_CNFG__USE_START_IRQ_DELAY__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & ~PMBUS_CNFG__USE_START_IRQ_DELAY__Msk);
    reg = (reg | (PMBUS_CNFG__USE_START_IRQ_DELAY__Shift((uint32_t)bf_value)));
    PMBUS_CNFG__SET(reg);
}

/** PMBUS_CNFG__USE_START_IRQ_DELAY__GET() gets CNFG.USE_START_IRQ_DELAY's current value.
 *
 * When reading from CNFG.USE_START_IRQ_DELAY, this is recommended to use.
 *
 * @return current value of CNFG.USE_START_IRQ_DELAY
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__USE_START_IRQ_DELAY__GET(void)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & PMBUS_CNFG__USE_START_IRQ_DELAY__Msk);
    reg = (reg >> PMBUS_CNFG__USE_START_IRQ_DELAY__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CNFG__USE_START_IRQ_DELAY__MODIFY() modifies CNFG.USE_START_IRQ_DELAY.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CNFG
 * @param bf_value new value for CNFG.USE_START_IRQ_DELAY
 * @return new value of PMBUS.CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__USE_START_IRQ_DELAY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CNFG__USE_START_IRQ_DELAY__Msk);
    reg = (reg | (PMBUS_CNFG__USE_START_IRQ_DELAY__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CNFG__USE_START_IRQ_DELAY__EXTRACT() extracts CNFG.USE_START_IRQ_DELAY.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CNFG
 * @return current value of CNFG.USE_START_IRQ_DELAY
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__USE_START_IRQ_DELAY__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CNFG__USE_START_IRQ_DELAY__Msk);
    reg = (reg >> PMBUS_CNFG__USE_START_IRQ_DELAY__Pos);
    return (uint32_t)reg;
}

/* ------------------- PMBUS.CNFG.EN_AUTO_TRANSMIT_TX_PEC ------------------- */


#define PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Pos                5                                                                      /*!< Right-most bit position of EN_AUTO_TRANSMIT_TX_PEC in PMBUS.CNFG */
#define PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Msk                (0x00000001UL << PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Pos)             /*!< Mask for EN_AUTO_TRANSMIT_TX_PEC in PMBUS.CNFG */
#define PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Shift(v)           (((v) << PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Pos) & PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Msk) /*!< Shift value 'v' into EN_AUTO_TRANSMIT_TX_PEC and mask 'v' to fit it into EN_AUTO_TRANSMIT_TX_PEC field */

/** PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__SET() sets CNFG.EN_AUTO_TRANSMIT_TX_PEC to given value.
 *
 * When writing to CNFG.EN_AUTO_TRANSMIT_TX_PEC, this is recommended to use.
 *
 * @param bf_value new value for CNFG.EN_AUTO_TRANSMIT_TX_PEC
 */
__PMBUS_INLINE void PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & ~PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Msk);
    reg = (reg | (PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Shift((uint32_t)bf_value)));
    PMBUS_CNFG__SET(reg);
}

/** PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__GET() gets CNFG.EN_AUTO_TRANSMIT_TX_PEC's current value.
 *
 * When reading from CNFG.EN_AUTO_TRANSMIT_TX_PEC, this is recommended to use.
 *
 * @return current value of CNFG.EN_AUTO_TRANSMIT_TX_PEC
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__GET(void)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Msk);
    reg = (reg >> PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__MODIFY() modifies CNFG.EN_AUTO_TRANSMIT_TX_PEC.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CNFG
 * @param bf_value new value for CNFG.EN_AUTO_TRANSMIT_TX_PEC
 * @return new value of PMBUS.CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Msk);
    reg = (reg | (PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__EXTRACT() extracts CNFG.EN_AUTO_TRANSMIT_TX_PEC.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CNFG
 * @return current value of CNFG.EN_AUTO_TRANSMIT_TX_PEC
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Msk);
    reg = (reg >> PMBUS_CNFG__EN_AUTO_TRANSMIT_TX_PEC__Pos);
    return (uint32_t)reg;
}

/* ------------------------- PMBUS.CNFG.PREEMPTIVE ------------------------- */


#define PMBUS_CNFG__PREEMPTIVE__Pos                             4                                                                      /*!< Right-most bit position of PREEMPTIVE in PMBUS.CNFG */
#define PMBUS_CNFG__PREEMPTIVE__Msk                             (0x00000001UL << PMBUS_CNFG__PREEMPTIVE__Pos)                          /*!< Mask for PREEMPTIVE in PMBUS.CNFG */
#define PMBUS_CNFG__PREEMPTIVE__Shift(v)                        (((v) << PMBUS_CNFG__PREEMPTIVE__Pos) & PMBUS_CNFG__PREEMPTIVE__Msk)   /*!< Shift value 'v' into PREEMPTIVE and mask 'v' to fit it into PREEMPTIVE field */

/** PMBUS_CNFG__PREEMPTIVE__SET() sets CNFG.PREEMPTIVE to given value.
 *
 * When writing to CNFG.PREEMPTIVE, this is recommended to use.
 *
 * @param bf_value new value for CNFG.PREEMPTIVE
 */
__PMBUS_INLINE void PMBUS_CNFG__PREEMPTIVE__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & ~PMBUS_CNFG__PREEMPTIVE__Msk);
    reg = (reg | (PMBUS_CNFG__PREEMPTIVE__Shift((uint32_t)bf_value)));
    PMBUS_CNFG__SET(reg);
}

/** PMBUS_CNFG__PREEMPTIVE__GET() gets CNFG.PREEMPTIVE's current value.
 *
 * When reading from CNFG.PREEMPTIVE, this is recommended to use.
 *
 * @return current value of CNFG.PREEMPTIVE
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__PREEMPTIVE__GET(void)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & PMBUS_CNFG__PREEMPTIVE__Msk);
    reg = (reg >> PMBUS_CNFG__PREEMPTIVE__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CNFG__PREEMPTIVE__MODIFY() modifies CNFG.PREEMPTIVE.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CNFG
 * @param bf_value new value for CNFG.PREEMPTIVE
 * @return new value of PMBUS.CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__PREEMPTIVE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CNFG__PREEMPTIVE__Msk);
    reg = (reg | (PMBUS_CNFG__PREEMPTIVE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CNFG__PREEMPTIVE__EXTRACT() extracts CNFG.PREEMPTIVE.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CNFG
 * @return current value of CNFG.PREEMPTIVE
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__PREEMPTIVE__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CNFG__PREEMPTIVE__Msk);
    reg = (reg >> PMBUS_CNFG__PREEMPTIVE__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PMBUS.CNFG.DS_APB_IRQ_CLK_G ---------------------- */


#define PMBUS_CNFG__DS_APB_IRQ_CLK_G__Pos                       3                                                                      /*!< Right-most bit position of DS_APB_IRQ_CLK_G in PMBUS.CNFG */
#define PMBUS_CNFG__DS_APB_IRQ_CLK_G__Msk                       (0x00000001UL << PMBUS_CNFG__DS_APB_IRQ_CLK_G__Pos)                    /*!< Mask for DS_APB_IRQ_CLK_G in PMBUS.CNFG */
#define PMBUS_CNFG__DS_APB_IRQ_CLK_G__Shift(v)                  (((v) << PMBUS_CNFG__DS_APB_IRQ_CLK_G__Pos) & PMBUS_CNFG__DS_APB_IRQ_CLK_G__Msk) /*!< Shift value 'v' into DS_APB_IRQ_CLK_G and mask 'v' to fit it into DS_APB_IRQ_CLK_G field */

/** PMBUS_CNFG__DS_APB_IRQ_CLK_G__SET() sets CNFG.DS_APB_IRQ_CLK_G to given value.
 *
 * When writing to CNFG.DS_APB_IRQ_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CNFG.DS_APB_IRQ_CLK_G
 */
__PMBUS_INLINE void PMBUS_CNFG__DS_APB_IRQ_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & ~PMBUS_CNFG__DS_APB_IRQ_CLK_G__Msk);
    reg = (reg | (PMBUS_CNFG__DS_APB_IRQ_CLK_G__Shift((uint32_t)bf_value)));
    PMBUS_CNFG__SET(reg);
}

/** PMBUS_CNFG__DS_APB_IRQ_CLK_G__GET() gets CNFG.DS_APB_IRQ_CLK_G's current value.
 *
 * When reading from CNFG.DS_APB_IRQ_CLK_G, this is recommended to use.
 *
 * @return current value of CNFG.DS_APB_IRQ_CLK_G
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DS_APB_IRQ_CLK_G__GET(void)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & PMBUS_CNFG__DS_APB_IRQ_CLK_G__Msk);
    reg = (reg >> PMBUS_CNFG__DS_APB_IRQ_CLK_G__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CNFG__DS_APB_IRQ_CLK_G__MODIFY() modifies CNFG.DS_APB_IRQ_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CNFG
 * @param bf_value new value for CNFG.DS_APB_IRQ_CLK_G
 * @return new value of PMBUS.CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DS_APB_IRQ_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CNFG__DS_APB_IRQ_CLK_G__Msk);
    reg = (reg | (PMBUS_CNFG__DS_APB_IRQ_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CNFG__DS_APB_IRQ_CLK_G__EXTRACT() extracts CNFG.DS_APB_IRQ_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CNFG
 * @return current value of CNFG.DS_APB_IRQ_CLK_G
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DS_APB_IRQ_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CNFG__DS_APB_IRQ_CLK_G__Msk);
    reg = (reg >> PMBUS_CNFG__DS_APB_IRQ_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PMBUS.CNFG.DS_FSM_IRQ_CLK_G ---------------------- */


#define PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Pos                       2                                                                      /*!< Right-most bit position of DS_FSM_IRQ_CLK_G in PMBUS.CNFG */
#define PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Msk                       (0x00000001UL << PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Pos)                    /*!< Mask for DS_FSM_IRQ_CLK_G in PMBUS.CNFG */
#define PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Shift(v)                  (((v) << PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Pos) & PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Msk) /*!< Shift value 'v' into DS_FSM_IRQ_CLK_G and mask 'v' to fit it into DS_FSM_IRQ_CLK_G field */

/** PMBUS_CNFG__DS_FSM_IRQ_CLK_G__SET() sets CNFG.DS_FSM_IRQ_CLK_G to given value.
 *
 * When writing to CNFG.DS_FSM_IRQ_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CNFG.DS_FSM_IRQ_CLK_G
 */
__PMBUS_INLINE void PMBUS_CNFG__DS_FSM_IRQ_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & ~PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Msk);
    reg = (reg | (PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Shift((uint32_t)bf_value)));
    PMBUS_CNFG__SET(reg);
}

/** PMBUS_CNFG__DS_FSM_IRQ_CLK_G__GET() gets CNFG.DS_FSM_IRQ_CLK_G's current value.
 *
 * When reading from CNFG.DS_FSM_IRQ_CLK_G, this is recommended to use.
 *
 * @return current value of CNFG.DS_FSM_IRQ_CLK_G
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DS_FSM_IRQ_CLK_G__GET(void)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Msk);
    reg = (reg >> PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CNFG__DS_FSM_IRQ_CLK_G__MODIFY() modifies CNFG.DS_FSM_IRQ_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CNFG
 * @param bf_value new value for CNFG.DS_FSM_IRQ_CLK_G
 * @return new value of PMBUS.CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DS_FSM_IRQ_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Msk);
    reg = (reg | (PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CNFG__DS_FSM_IRQ_CLK_G__EXTRACT() extracts CNFG.DS_FSM_IRQ_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CNFG
 * @return current value of CNFG.DS_FSM_IRQ_CLK_G
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DS_FSM_IRQ_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Msk);
    reg = (reg >> PMBUS_CNFG__DS_FSM_IRQ_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------------- PMBUS.CNFG.DS_FSM_FSM_CLK_G ---------------------- */


#define PMBUS_CNFG__DS_FSM_FSM_CLK_G__Pos                       1                                                                      /*!< Right-most bit position of DS_FSM_FSM_CLK_G in PMBUS.CNFG */
#define PMBUS_CNFG__DS_FSM_FSM_CLK_G__Msk                       (0x00000001UL << PMBUS_CNFG__DS_FSM_FSM_CLK_G__Pos)                    /*!< Mask for DS_FSM_FSM_CLK_G in PMBUS.CNFG */
#define PMBUS_CNFG__DS_FSM_FSM_CLK_G__Shift(v)                  (((v) << PMBUS_CNFG__DS_FSM_FSM_CLK_G__Pos) & PMBUS_CNFG__DS_FSM_FSM_CLK_G__Msk) /*!< Shift value 'v' into DS_FSM_FSM_CLK_G and mask 'v' to fit it into DS_FSM_FSM_CLK_G field */

/** PMBUS_CNFG__DS_FSM_FSM_CLK_G__SET() sets CNFG.DS_FSM_FSM_CLK_G to given value.
 *
 * When writing to CNFG.DS_FSM_FSM_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CNFG.DS_FSM_FSM_CLK_G
 */
__PMBUS_INLINE void PMBUS_CNFG__DS_FSM_FSM_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & ~PMBUS_CNFG__DS_FSM_FSM_CLK_G__Msk);
    reg = (reg | (PMBUS_CNFG__DS_FSM_FSM_CLK_G__Shift((uint32_t)bf_value)));
    PMBUS_CNFG__SET(reg);
}

/** PMBUS_CNFG__DS_FSM_FSM_CLK_G__GET() gets CNFG.DS_FSM_FSM_CLK_G's current value.
 *
 * When reading from CNFG.DS_FSM_FSM_CLK_G, this is recommended to use.
 *
 * @return current value of CNFG.DS_FSM_FSM_CLK_G
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DS_FSM_FSM_CLK_G__GET(void)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & PMBUS_CNFG__DS_FSM_FSM_CLK_G__Msk);
    reg = (reg >> PMBUS_CNFG__DS_FSM_FSM_CLK_G__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CNFG__DS_FSM_FSM_CLK_G__MODIFY() modifies CNFG.DS_FSM_FSM_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CNFG
 * @param bf_value new value for CNFG.DS_FSM_FSM_CLK_G
 * @return new value of PMBUS.CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DS_FSM_FSM_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CNFG__DS_FSM_FSM_CLK_G__Msk);
    reg = (reg | (PMBUS_CNFG__DS_FSM_FSM_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CNFG__DS_FSM_FSM_CLK_G__EXTRACT() extracts CNFG.DS_FSM_FSM_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CNFG
 * @return current value of CNFG.DS_FSM_FSM_CLK_G
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__DS_FSM_FSM_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CNFG__DS_FSM_FSM_CLK_G__Msk);
    reg = (reg >> PMBUS_CNFG__DS_FSM_FSM_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------------- PMBUS.CNFG.EN_PHY --------------------------- */


#define PMBUS_CNFG__EN_PHY__Pos                                 0                                                                      /*!< Right-most bit position of EN_PHY in PMBUS.CNFG */
#define PMBUS_CNFG__EN_PHY__Msk                                 (0x00000001UL << PMBUS_CNFG__EN_PHY__Pos)                              /*!< Mask for EN_PHY in PMBUS.CNFG */
#define PMBUS_CNFG__EN_PHY__Shift(v)                            (((v) << PMBUS_CNFG__EN_PHY__Pos) & PMBUS_CNFG__EN_PHY__Msk)           /*!< Shift value 'v' into EN_PHY and mask 'v' to fit it into EN_PHY field */

/** PMBUS_CNFG__EN_PHY__SET() sets CNFG.EN_PHY to given value.
 *
 * When writing to CNFG.EN_PHY, this is recommended to use.
 *
 * @param bf_value new value for CNFG.EN_PHY
 */
__PMBUS_INLINE void PMBUS_CNFG__EN_PHY__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & ~PMBUS_CNFG__EN_PHY__Msk);
    reg = (reg | (PMBUS_CNFG__EN_PHY__Shift((uint32_t)bf_value)));
    PMBUS_CNFG__SET(reg);
}

/** PMBUS_CNFG__EN_PHY__GET() gets CNFG.EN_PHY's current value.
 *
 * When reading from CNFG.EN_PHY, this is recommended to use.
 *
 * @return current value of CNFG.EN_PHY
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__EN_PHY__GET(void)
{
    uint32_t reg = PMBUS_CNFG__GET();
    reg = (reg & PMBUS_CNFG__EN_PHY__Msk);
    reg = (reg >> PMBUS_CNFG__EN_PHY__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CNFG__EN_PHY__MODIFY() modifies CNFG.EN_PHY.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CNFG
 * @param bf_value new value for CNFG.EN_PHY
 * @return new value of PMBUS.CNFG
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__EN_PHY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CNFG__EN_PHY__Msk);
    reg = (reg | (PMBUS_CNFG__EN_PHY__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CNFG__EN_PHY__EXTRACT() extracts CNFG.EN_PHY.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CNFG
 * @return current value of CNFG.EN_PHY
 */
__PMBUS_INLINE uint32_t PMBUS_CNFG__EN_PHY__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CNFG__EN_PHY__Msk);
    reg = (reg >> PMBUS_CNFG__EN_PHY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                           ISR member of PMBUS_t                           */
/* -------------------------------------------------------------------------- */

/** __PMBUS_ISR__ADDRESS returns the address of member ISR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ISR
 */
__PMBUS_INLINE uint32_t* __PMBUS_ISR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, ISR)));
}

/** PMBUS_ISR__SET() sets ISR to given value.
 *
 * When writing to ISR, this is mandatory to use.
 *
 * @param value new value for ISR
 */
__PMBUS_INLINE void PMBUS_ISR__SET(uint32_t value)
{
    HAL_SET32(__PMBUS_ISR__ADDRESS(), value);
}

/** PMBUS_ISR__GET() gets ISR's current value.
 *
 * When reading from ISR, this is mandatory to use.
 *
 * @return current value of ISR
 */
__PMBUS_INLINE uint32_t PMBUS_ISR__GET(void)
{
    return HAL_GET32(__PMBUS_ISR__ADDRESS());
}

/* ---------------------------- PMBUS.ISR.I_CODE ---------------------------- */


/*lint -parent(uint32_t, pmbus_isr__i_code_t) -strong(AJX)*/
typedef enum pmbus_isr__i_code_e                                                                                                       /*!<  */
{
    pmbus_isr__i_code_none_irq = 0u,                                                                                                   /*!<  */
    pmbus_isr__i_code_start_irq = 1u,                                                                                                  /*!<  */
    pmbus_isr__i_code_rx_adr_w_irq = 2u,                                                                                               /*!<  */
    pmbus_isr__i_code_rx_irq = 3u,                                                                                                     /*!<  */
    pmbus_isr__i_code_rx_adr_r_irq = 4u,                                                                                               /*!<  */
    pmbus_isr__i_code_tx_irq = 5u,                                                                                                     /*!<  */
    pmbus_isr__i_code_stop_irq = 6u,                                                                                                   /*!<  */
    pmbus_isr__i_code_wdt_irq = 7u,                                                                                                    /*!<  */
    pmbus_isr__i_code_busy_irq = 8u                                                                                                    /*!<  */
} pmbus_isr__i_code_t;

#define PMBUS_ISR__I_CODE__Pos                                  3                                                                      /*!< Right-most bit position of I_CODE in PMBUS.ISR */
#define PMBUS_ISR__I_CODE__Msk                                  (0x0000000FUL << PMBUS_ISR__I_CODE__Pos)                               /*!< Mask for I_CODE in PMBUS.ISR */
#define PMBUS_ISR__I_CODE__Shift(v)                             (((v) << PMBUS_ISR__I_CODE__Pos) & PMBUS_ISR__I_CODE__Msk)             /*!< Shift value 'v' into I_CODE and mask 'v' to fit it into I_CODE field */

/** PMBUS_ISR__I_CODE__GET() gets ISR.I_CODE's current value.
 *
 * When reading from ISR.I_CODE, this is recommended to use.
 *
 * @return current value of ISR.I_CODE
 */
__PMBUS_INLINE pmbus_isr__i_code_t PMBUS_ISR__I_CODE__GET(void)
{
    uint32_t reg = PMBUS_ISR__GET();
    reg = (reg & PMBUS_ISR__I_CODE__Msk);
    reg = (reg >> PMBUS_ISR__I_CODE__Pos);
    return (pmbus_isr__i_code_t)reg;
}

/** PMBUS_ISR__I_CODE__EXTRACT() extracts ISR.I_CODE.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.ISR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.ISR
 * @return current value of ISR.I_CODE
 */
__PMBUS_INLINE pmbus_isr__i_code_t PMBUS_ISR__I_CODE__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_ISR__I_CODE__Msk);
    reg = (reg >> PMBUS_ISR__I_CODE__Pos);
    return (pmbus_isr__i_code_t)reg;
}

/* ------------------------- PMBUS.ISR.SEL_FLAG_SRC ------------------------- */

/**
<pre>
  PMBUS.ISR.SEL_FLAG_SRC:

    Select the flags source:
    0 - Normal register
    1 - FIFO IRQ

</pre> */

#define PMBUS_ISR__SEL_FLAG_SRC__Pos                            2                                                                      /*!< Right-most bit position of SEL_FLAG_SRC in PMBUS.ISR */
#define PMBUS_ISR__SEL_FLAG_SRC__Msk                            (0x00000001UL << PMBUS_ISR__SEL_FLAG_SRC__Pos)                         /*!< Mask for SEL_FLAG_SRC in PMBUS.ISR */
#define PMBUS_ISR__SEL_FLAG_SRC__Shift(v)                       (((v) << PMBUS_ISR__SEL_FLAG_SRC__Pos) & PMBUS_ISR__SEL_FLAG_SRC__Msk) /*!< Shift value 'v' into SEL_FLAG_SRC and mask 'v' to fit it into SEL_FLAG_SRC field */

/** PMBUS_ISR__SEL_FLAG_SRC__SET() sets ISR.SEL_FLAG_SRC to given value.
 *
 * When writing to ISR.SEL_FLAG_SRC, this is recommended to use.
 *
 * @param bf_value new value for ISR.SEL_FLAG_SRC
 */
__PMBUS_INLINE void PMBUS_ISR__SEL_FLAG_SRC__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_ISR__GET();
    reg = (reg & ~PMBUS_ISR__SEL_FLAG_SRC__Msk);
    reg = (reg | (PMBUS_ISR__SEL_FLAG_SRC__Shift((uint32_t)bf_value)));
    PMBUS_ISR__SET(reg);
}

/** PMBUS_ISR__SEL_FLAG_SRC__GET() gets ISR.SEL_FLAG_SRC's current value.
 *
 * When reading from ISR.SEL_FLAG_SRC, this is recommended to use.
 *
 * @return current value of ISR.SEL_FLAG_SRC
 */
__PMBUS_INLINE uint32_t PMBUS_ISR__SEL_FLAG_SRC__GET(void)
{
    uint32_t reg = PMBUS_ISR__GET();
    reg = (reg & PMBUS_ISR__SEL_FLAG_SRC__Msk);
    reg = (reg >> PMBUS_ISR__SEL_FLAG_SRC__Pos);
    return (uint32_t)reg;
}

/** PMBUS_ISR__SEL_FLAG_SRC__MODIFY() modifies ISR.SEL_FLAG_SRC.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.ISR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.ISR
 * @param bf_value new value for ISR.SEL_FLAG_SRC
 * @return new value of PMBUS.ISR
 */
__PMBUS_INLINE uint32_t PMBUS_ISR__SEL_FLAG_SRC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_ISR__SEL_FLAG_SRC__Msk);
    reg = (reg | (PMBUS_ISR__SEL_FLAG_SRC__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_ISR__SEL_FLAG_SRC__EXTRACT() extracts ISR.SEL_FLAG_SRC.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.ISR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.ISR
 * @return current value of ISR.SEL_FLAG_SRC
 */
__PMBUS_INLINE uint32_t PMBUS_ISR__SEL_FLAG_SRC__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_ISR__SEL_FLAG_SRC__Msk);
    reg = (reg >> PMBUS_ISR__SEL_FLAG_SRC__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- PMBUS.ISR.IE_FSM ---------------------------- */


#define PMBUS_ISR__IE_FSM__Pos                                  1                                                                      /*!< Right-most bit position of IE_FSM in PMBUS.ISR */
#define PMBUS_ISR__IE_FSM__Msk                                  (0x00000001UL << PMBUS_ISR__IE_FSM__Pos)                               /*!< Mask for IE_FSM in PMBUS.ISR */
#define PMBUS_ISR__IE_FSM__Shift(v)                             (((v) << PMBUS_ISR__IE_FSM__Pos) & PMBUS_ISR__IE_FSM__Msk)             /*!< Shift value 'v' into IE_FSM and mask 'v' to fit it into IE_FSM field */

/** PMBUS_ISR__IE_FSM__SET() sets ISR.IE_FSM to given value.
 *
 * When writing to ISR.IE_FSM, this is recommended to use.
 *
 * @param bf_value new value for ISR.IE_FSM
 */
__PMBUS_INLINE void PMBUS_ISR__IE_FSM__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_ISR__GET();
    reg = (reg & ~PMBUS_ISR__IE_FSM__Msk);
    reg = (reg | (PMBUS_ISR__IE_FSM__Shift((uint32_t)bf_value)));
    PMBUS_ISR__SET(reg);
}

/** PMBUS_ISR__IE_FSM__GET() gets ISR.IE_FSM's current value.
 *
 * When reading from ISR.IE_FSM, this is recommended to use.
 *
 * @return current value of ISR.IE_FSM
 */
__PMBUS_INLINE uint32_t PMBUS_ISR__IE_FSM__GET(void)
{
    uint32_t reg = PMBUS_ISR__GET();
    reg = (reg & PMBUS_ISR__IE_FSM__Msk);
    reg = (reg >> PMBUS_ISR__IE_FSM__Pos);
    return (uint32_t)reg;
}

/** PMBUS_ISR__IE_FSM__MODIFY() modifies ISR.IE_FSM.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.ISR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.ISR
 * @param bf_value new value for ISR.IE_FSM
 * @return new value of PMBUS.ISR
 */
__PMBUS_INLINE uint32_t PMBUS_ISR__IE_FSM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_ISR__IE_FSM__Msk);
    reg = (reg | (PMBUS_ISR__IE_FSM__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_ISR__IE_FSM__EXTRACT() extracts ISR.IE_FSM.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.ISR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.ISR
 * @return current value of ISR.IE_FSM
 */
__PMBUS_INLINE uint32_t PMBUS_ISR__IE_FSM__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_ISR__IE_FSM__Msk);
    reg = (reg >> PMBUS_ISR__IE_FSM__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- PMBUS.ISR.I_FSM ---------------------------- */


#define PMBUS_ISR__I_FSM__Pos                                   0                                                                      /*!< Right-most bit position of I_FSM in PMBUS.ISR */
#define PMBUS_ISR__I_FSM__Msk                                   (0x00000001UL << PMBUS_ISR__I_FSM__Pos)                                /*!< Mask for I_FSM in PMBUS.ISR */
#define PMBUS_ISR__I_FSM__Shift(v)                              (((v) << PMBUS_ISR__I_FSM__Pos) & PMBUS_ISR__I_FSM__Msk)               /*!< Shift value 'v' into I_FSM and mask 'v' to fit it into I_FSM field */

/** PMBUS_ISR__I_FSM__SET() sets ISR.I_FSM to given value.
 *
 * When writing to ISR.I_FSM, this is recommended to use.
 *
 * @param bf_value new value for ISR.I_FSM
 */
__PMBUS_INLINE void PMBUS_ISR__I_FSM__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_ISR__GET();
    reg = (reg & ~PMBUS_ISR__I_FSM__Msk);
    reg = (reg | (PMBUS_ISR__I_FSM__Shift((uint32_t)bf_value)));
    PMBUS_ISR__SET(reg);
}

/** PMBUS_ISR__I_FSM__GET() gets ISR.I_FSM's current value.
 *
 * When reading from ISR.I_FSM, this is recommended to use.
 *
 * @return current value of ISR.I_FSM
 */
__PMBUS_INLINE uint32_t PMBUS_ISR__I_FSM__GET(void)
{
    uint32_t reg = PMBUS_ISR__GET();
    reg = (reg & PMBUS_ISR__I_FSM__Msk);
    reg = (reg >> PMBUS_ISR__I_FSM__Pos);
    return (uint32_t)reg;
}

/** PMBUS_ISR__I_FSM__MODIFY() modifies ISR.I_FSM.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.ISR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.ISR
 * @param bf_value new value for ISR.I_FSM
 * @return new value of PMBUS.ISR
 */
__PMBUS_INLINE uint32_t PMBUS_ISR__I_FSM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_ISR__I_FSM__Msk);
    reg = (reg | (PMBUS_ISR__I_FSM__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_ISR__I_FSM__EXTRACT() extracts ISR.I_FSM.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.ISR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.ISR
 * @return current value of ISR.I_FSM
 */
__PMBUS_INLINE uint32_t PMBUS_ISR__I_FSM__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_ISR__I_FSM__Msk);
    reg = (reg >> PMBUS_ISR__I_FSM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          ARA_CW member of PMBUS_t                          */
/* -------------------------------------------------------------------------- */

/** __PMBUS_ARA_CW__ADDRESS returns the address of member ARA_CW.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ARA_CW
 */
__PMBUS_INLINE uint32_t* __PMBUS_ARA_CW__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, ARA_CW)));
}

/** PMBUS_ARA_CW__SET() sets ARA_CW to given value.
 *
 * When writing to ARA_CW, this is mandatory to use.
 *
 * @param value new value for ARA_CW
 */
__PMBUS_INLINE void PMBUS_ARA_CW__SET(uint32_t value)
{
    HAL_SET32(__PMBUS_ARA_CW__ADDRESS(), value);
}

/** PMBUS_ARA_CW__GET() gets ARA_CW's current value.
 *
 * When reading from ARA_CW, this is mandatory to use.
 *
 * @return current value of ARA_CW
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__GET(void)
{
    return HAL_GET32(__PMBUS_ARA_CW__ADDRESS());
}

/* ------------------ PMBUS.ARA_CW.SLAVE_ADDR_GEN_SMBALERT ------------------ */


#define PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Pos              10                                                                     /*!< Right-most bit position of SLAVE_ADDR_GEN_SMBALERT in PMBUS.ARA_CW */
#define PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Msk              (0x0000007FUL << PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Pos)           /*!< Mask for SLAVE_ADDR_GEN_SMBALERT in PMBUS.ARA_CW */
#define PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Shift(v)         (((v) << PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Pos) & PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Msk) /*!< Shift value 'v' into SLAVE_ADDR_GEN_SMBALERT and mask 'v' to fit it into SLAVE_ADDR_GEN_SMBALERT field */

/** PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__SET() sets ARA_CW.SLAVE_ADDR_GEN_SMBALERT to given value.
 *
 * When writing to ARA_CW.SLAVE_ADDR_GEN_SMBALERT, this is recommended to use.
 *
 * @param bf_value new value for ARA_CW.SLAVE_ADDR_GEN_SMBALERT
 */
__PMBUS_INLINE void PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_ARA_CW__GET();
    reg = (reg & ~PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Msk);
    reg = (reg | (PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Shift((uint32_t)bf_value)));
    PMBUS_ARA_CW__SET(reg);
}

/** PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__GET() gets ARA_CW.SLAVE_ADDR_GEN_SMBALERT's current value.
 *
 * When reading from ARA_CW.SLAVE_ADDR_GEN_SMBALERT, this is recommended to use.
 *
 * @return current value of ARA_CW.SLAVE_ADDR_GEN_SMBALERT
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__GET(void)
{
    uint32_t reg = PMBUS_ARA_CW__GET();
    reg = (reg & PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Msk);
    reg = (reg >> PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Pos);
    return (uint32_t)reg;
}

/** PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__MODIFY() modifies ARA_CW.SLAVE_ADDR_GEN_SMBALERT.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.ARA_CW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.ARA_CW
 * @param bf_value new value for ARA_CW.SLAVE_ADDR_GEN_SMBALERT
 * @return new value of PMBUS.ARA_CW
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Msk);
    reg = (reg | (PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__EXTRACT() extracts ARA_CW.SLAVE_ADDR_GEN_SMBALERT.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.ARA_CW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.ARA_CW
 * @return current value of ARA_CW.SLAVE_ADDR_GEN_SMBALERT
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Msk);
    reg = (reg >> PMBUS_ARA_CW__SLAVE_ADDR_GEN_SMBALERT__Pos);
    return (uint32_t)reg;
}

/* ------------------------- PMBUS.ARA_CW.SMBALERT ------------------------- */


#define PMBUS_ARA_CW__SMBALERT__Pos                             9                                                                      /*!< Right-most bit position of SMBALERT in PMBUS.ARA_CW */
#define PMBUS_ARA_CW__SMBALERT__Msk                             (0x00000001UL << PMBUS_ARA_CW__SMBALERT__Pos)                          /*!< Mask for SMBALERT in PMBUS.ARA_CW */
#define PMBUS_ARA_CW__SMBALERT__Shift(v)                        (((v) << PMBUS_ARA_CW__SMBALERT__Pos) & PMBUS_ARA_CW__SMBALERT__Msk)   /*!< Shift value 'v' into SMBALERT and mask 'v' to fit it into SMBALERT field */

/** PMBUS_ARA_CW__SMBALERT__SET() sets ARA_CW.SMBALERT to given value.
 *
 * When writing to ARA_CW.SMBALERT, this is recommended to use.
 *
 * @param bf_value new value for ARA_CW.SMBALERT
 */
__PMBUS_INLINE void PMBUS_ARA_CW__SMBALERT__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_ARA_CW__GET();
    reg = (reg & ~PMBUS_ARA_CW__SMBALERT__Msk);
    reg = (reg | (PMBUS_ARA_CW__SMBALERT__Shift((uint32_t)bf_value)));
    PMBUS_ARA_CW__SET(reg);
}

/** PMBUS_ARA_CW__SMBALERT__GET() gets ARA_CW.SMBALERT's current value.
 *
 * When reading from ARA_CW.SMBALERT, this is recommended to use.
 *
 * @return current value of ARA_CW.SMBALERT
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__SMBALERT__GET(void)
{
    uint32_t reg = PMBUS_ARA_CW__GET();
    reg = (reg & PMBUS_ARA_CW__SMBALERT__Msk);
    reg = (reg >> PMBUS_ARA_CW__SMBALERT__Pos);
    return (uint32_t)reg;
}

/** PMBUS_ARA_CW__SMBALERT__MODIFY() modifies ARA_CW.SMBALERT.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.ARA_CW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.ARA_CW
 * @param bf_value new value for ARA_CW.SMBALERT
 * @return new value of PMBUS.ARA_CW
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__SMBALERT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_ARA_CW__SMBALERT__Msk);
    reg = (reg | (PMBUS_ARA_CW__SMBALERT__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_ARA_CW__SMBALERT__EXTRACT() extracts ARA_CW.SMBALERT.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.ARA_CW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.ARA_CW
 * @return current value of ARA_CW.SMBALERT
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__SMBALERT__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_ARA_CW__SMBALERT__Msk);
    reg = (reg >> PMBUS_ARA_CW__SMBALERT__Pos);
    return (uint32_t)reg;
}

/* ------------------------- PMBUS.ARA_CW.ARA_ADDR ------------------------- */


#define PMBUS_ARA_CW__ARA_ADDR__Pos                             2                                                                      /*!< Right-most bit position of ARA_ADDR in PMBUS.ARA_CW */
#define PMBUS_ARA_CW__ARA_ADDR__Msk                             (0x0000007FUL << PMBUS_ARA_CW__ARA_ADDR__Pos)                          /*!< Mask for ARA_ADDR in PMBUS.ARA_CW */
#define PMBUS_ARA_CW__ARA_ADDR__Shift(v)                        (((v) << PMBUS_ARA_CW__ARA_ADDR__Pos) & PMBUS_ARA_CW__ARA_ADDR__Msk)   /*!< Shift value 'v' into ARA_ADDR and mask 'v' to fit it into ARA_ADDR field */

/** PMBUS_ARA_CW__ARA_ADDR__SET() sets ARA_CW.ARA_ADDR to given value.
 *
 * When writing to ARA_CW.ARA_ADDR, this is recommended to use.
 *
 * @param bf_value new value for ARA_CW.ARA_ADDR
 */
__PMBUS_INLINE void PMBUS_ARA_CW__ARA_ADDR__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_ARA_CW__GET();
    reg = (reg & ~PMBUS_ARA_CW__ARA_ADDR__Msk);
    reg = (reg | (PMBUS_ARA_CW__ARA_ADDR__Shift((uint32_t)bf_value)));
    PMBUS_ARA_CW__SET(reg);
}

/** PMBUS_ARA_CW__ARA_ADDR__GET() gets ARA_CW.ARA_ADDR's current value.
 *
 * When reading from ARA_CW.ARA_ADDR, this is recommended to use.
 *
 * @return current value of ARA_CW.ARA_ADDR
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__ARA_ADDR__GET(void)
{
    uint32_t reg = PMBUS_ARA_CW__GET();
    reg = (reg & PMBUS_ARA_CW__ARA_ADDR__Msk);
    reg = (reg >> PMBUS_ARA_CW__ARA_ADDR__Pos);
    return (uint32_t)reg;
}

/** PMBUS_ARA_CW__ARA_ADDR__MODIFY() modifies ARA_CW.ARA_ADDR.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.ARA_CW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.ARA_CW
 * @param bf_value new value for ARA_CW.ARA_ADDR
 * @return new value of PMBUS.ARA_CW
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__ARA_ADDR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_ARA_CW__ARA_ADDR__Msk);
    reg = (reg | (PMBUS_ARA_CW__ARA_ADDR__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_ARA_CW__ARA_ADDR__EXTRACT() extracts ARA_CW.ARA_ADDR.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.ARA_CW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.ARA_CW
 * @return current value of ARA_CW.ARA_ADDR
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__ARA_ADDR__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_ARA_CW__ARA_ADDR__Msk);
    reg = (reg >> PMBUS_ARA_CW__ARA_ADDR__Pos);
    return (uint32_t)reg;
}

/* ------------------------- PMBUS.ARA_CW.DIRECTION ------------------------- */


#define PMBUS_ARA_CW__DIRECTION__Pos                            1                                                                      /*!< Right-most bit position of DIRECTION in PMBUS.ARA_CW */
#define PMBUS_ARA_CW__DIRECTION__Msk                            (0x00000001UL << PMBUS_ARA_CW__DIRECTION__Pos)                         /*!< Mask for DIRECTION in PMBUS.ARA_CW */
#define PMBUS_ARA_CW__DIRECTION__Shift(v)                       (((v) << PMBUS_ARA_CW__DIRECTION__Pos) & PMBUS_ARA_CW__DIRECTION__Msk) /*!< Shift value 'v' into DIRECTION and mask 'v' to fit it into DIRECTION field */

/** PMBUS_ARA_CW__DIRECTION__SET() sets ARA_CW.DIRECTION to given value.
 *
 * When writing to ARA_CW.DIRECTION, this is recommended to use.
 *
 * @param bf_value new value for ARA_CW.DIRECTION
 */
__PMBUS_INLINE void PMBUS_ARA_CW__DIRECTION__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_ARA_CW__GET();
    reg = (reg & ~PMBUS_ARA_CW__DIRECTION__Msk);
    reg = (reg | (PMBUS_ARA_CW__DIRECTION__Shift((uint32_t)bf_value)));
    PMBUS_ARA_CW__SET(reg);
}

/** PMBUS_ARA_CW__DIRECTION__GET() gets ARA_CW.DIRECTION's current value.
 *
 * When reading from ARA_CW.DIRECTION, this is recommended to use.
 *
 * @return current value of ARA_CW.DIRECTION
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__DIRECTION__GET(void)
{
    uint32_t reg = PMBUS_ARA_CW__GET();
    reg = (reg & PMBUS_ARA_CW__DIRECTION__Msk);
    reg = (reg >> PMBUS_ARA_CW__DIRECTION__Pos);
    return (uint32_t)reg;
}

/** PMBUS_ARA_CW__DIRECTION__MODIFY() modifies ARA_CW.DIRECTION.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.ARA_CW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.ARA_CW
 * @param bf_value new value for ARA_CW.DIRECTION
 * @return new value of PMBUS.ARA_CW
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__DIRECTION__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_ARA_CW__DIRECTION__Msk);
    reg = (reg | (PMBUS_ARA_CW__DIRECTION__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_ARA_CW__DIRECTION__EXTRACT() extracts ARA_CW.DIRECTION.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.ARA_CW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.ARA_CW
 * @return current value of ARA_CW.DIRECTION
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__DIRECTION__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_ARA_CW__DIRECTION__Msk);
    reg = (reg >> PMBUS_ARA_CW__DIRECTION__Pos);
    return (uint32_t)reg;
}

/* ------------------------- PMBUS.ARA_CW.EN_ARA_CW ------------------------- */


#define PMBUS_ARA_CW__EN_ARA_CW__Pos                            0                                                                      /*!< Right-most bit position of EN_ARA_CW in PMBUS.ARA_CW */
#define PMBUS_ARA_CW__EN_ARA_CW__Msk                            (0x00000001UL << PMBUS_ARA_CW__EN_ARA_CW__Pos)                         /*!< Mask for EN_ARA_CW in PMBUS.ARA_CW */
#define PMBUS_ARA_CW__EN_ARA_CW__Shift(v)                       (((v) << PMBUS_ARA_CW__EN_ARA_CW__Pos) & PMBUS_ARA_CW__EN_ARA_CW__Msk) /*!< Shift value 'v' into EN_ARA_CW and mask 'v' to fit it into EN_ARA_CW field */

/** PMBUS_ARA_CW__EN_ARA_CW__SET() sets ARA_CW.EN_ARA_CW to given value.
 *
 * When writing to ARA_CW.EN_ARA_CW, this is recommended to use.
 *
 * @param bf_value new value for ARA_CW.EN_ARA_CW
 */
__PMBUS_INLINE void PMBUS_ARA_CW__EN_ARA_CW__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_ARA_CW__GET();
    reg = (reg & ~PMBUS_ARA_CW__EN_ARA_CW__Msk);
    reg = (reg | (PMBUS_ARA_CW__EN_ARA_CW__Shift((uint32_t)bf_value)));
    PMBUS_ARA_CW__SET(reg);
}

/** PMBUS_ARA_CW__EN_ARA_CW__GET() gets ARA_CW.EN_ARA_CW's current value.
 *
 * When reading from ARA_CW.EN_ARA_CW, this is recommended to use.
 *
 * @return current value of ARA_CW.EN_ARA_CW
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__EN_ARA_CW__GET(void)
{
    uint32_t reg = PMBUS_ARA_CW__GET();
    reg = (reg & PMBUS_ARA_CW__EN_ARA_CW__Msk);
    reg = (reg >> PMBUS_ARA_CW__EN_ARA_CW__Pos);
    return (uint32_t)reg;
}

/** PMBUS_ARA_CW__EN_ARA_CW__MODIFY() modifies ARA_CW.EN_ARA_CW.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.ARA_CW.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.ARA_CW
 * @param bf_value new value for ARA_CW.EN_ARA_CW
 * @return new value of PMBUS.ARA_CW
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__EN_ARA_CW__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_ARA_CW__EN_ARA_CW__Msk);
    reg = (reg | (PMBUS_ARA_CW__EN_ARA_CW__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_ARA_CW__EN_ARA_CW__EXTRACT() extracts ARA_CW.EN_ARA_CW.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.ARA_CW.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.ARA_CW
 * @return current value of ARA_CW.EN_ARA_CW
 */
__PMBUS_INLINE uint32_t PMBUS_ARA_CW__EN_ARA_CW__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_ARA_CW__EN_ARA_CW__Msk);
    reg = (reg >> PMBUS_ARA_CW__EN_ARA_CW__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         CTRL_RX member of PMBUS_t                         */
/* -------------------------------------------------------------------------- */

/** __PMBUS_CTRL_RX__ADDRESS returns the address of member CTRL_RX.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CTRL_RX
 */
__PMBUS_INLINE uint32_t* __PMBUS_CTRL_RX__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, CTRL_RX)));
}

/** PMBUS_CTRL_RX__SET() sets CTRL_RX to given value.
 *
 * When writing to CTRL_RX, this is mandatory to use.
 *
 * @param value new value for CTRL_RX
 */
__PMBUS_INLINE void PMBUS_CTRL_RX__SET(uint32_t value)
{
    HAL_SET32(__PMBUS_CTRL_RX__ADDRESS(), value);
}

/** PMBUS_CTRL_RX__GET() gets CTRL_RX's current value.
 *
 * When reading from CTRL_RX, this is mandatory to use.
 *
 * @return current value of CTRL_RX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__GET(void)
{
    return HAL_GET32(__PMBUS_CTRL_RX__ADDRESS());
}

/* ------------------------ PMBUS.CTRL_RX.MAX_RANGE ------------------------ */


#define PMBUS_CTRL_RX__MAX_RANGE__Pos                           16                                                                     /*!< Right-most bit position of MAX_RANGE in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__MAX_RANGE__Msk                           (0x000000FFUL << PMBUS_CTRL_RX__MAX_RANGE__Pos)                        /*!< Mask for MAX_RANGE in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__MAX_RANGE__Shift(v)                      (((v) << PMBUS_CTRL_RX__MAX_RANGE__Pos) & PMBUS_CTRL_RX__MAX_RANGE__Msk) /*!< Shift value 'v' into MAX_RANGE and mask 'v' to fit it into MAX_RANGE field */

/** PMBUS_CTRL_RX__MAX_RANGE__SET() sets CTRL_RX.MAX_RANGE to given value.
 *
 * When writing to CTRL_RX.MAX_RANGE, this is recommended to use.
 *
 * @param bf_value new value for CTRL_RX.MAX_RANGE
 */
__PMBUS_INLINE void PMBUS_CTRL_RX__MAX_RANGE__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & ~PMBUS_CTRL_RX__MAX_RANGE__Msk);
    reg = (reg | (PMBUS_CTRL_RX__MAX_RANGE__Shift((uint32_t)bf_value)));
    PMBUS_CTRL_RX__SET(reg);
}

/** PMBUS_CTRL_RX__MAX_RANGE__GET() gets CTRL_RX.MAX_RANGE's current value.
 *
 * When reading from CTRL_RX.MAX_RANGE, this is recommended to use.
 *
 * @return current value of CTRL_RX.MAX_RANGE
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__MAX_RANGE__GET(void)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & PMBUS_CTRL_RX__MAX_RANGE__Msk);
    reg = (reg >> PMBUS_CTRL_RX__MAX_RANGE__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CTRL_RX__MAX_RANGE__MODIFY() modifies CTRL_RX.MAX_RANGE.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_RX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @param bf_value new value for CTRL_RX.MAX_RANGE
 * @return new value of PMBUS.CTRL_RX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__MAX_RANGE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_RX__MAX_RANGE__Msk);
    reg = (reg | (PMBUS_CTRL_RX__MAX_RANGE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_RX__MAX_RANGE__EXTRACT() extracts CTRL_RX.MAX_RANGE.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_RX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @return current value of CTRL_RX.MAX_RANGE
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__MAX_RANGE__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_RX__MAX_RANGE__Msk);
    reg = (reg >> PMBUS_CTRL_RX__MAX_RANGE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ PMBUS.CTRL_RX.MIN_RANGE ------------------------ */


#define PMBUS_CTRL_RX__MIN_RANGE__Pos                           8                                                                      /*!< Right-most bit position of MIN_RANGE in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__MIN_RANGE__Msk                           (0x000000FFUL << PMBUS_CTRL_RX__MIN_RANGE__Pos)                        /*!< Mask for MIN_RANGE in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__MIN_RANGE__Shift(v)                      (((v) << PMBUS_CTRL_RX__MIN_RANGE__Pos) & PMBUS_CTRL_RX__MIN_RANGE__Msk) /*!< Shift value 'v' into MIN_RANGE and mask 'v' to fit it into MIN_RANGE field */

/** PMBUS_CTRL_RX__MIN_RANGE__SET() sets CTRL_RX.MIN_RANGE to given value.
 *
 * When writing to CTRL_RX.MIN_RANGE, this is recommended to use.
 *
 * @param bf_value new value for CTRL_RX.MIN_RANGE
 */
__PMBUS_INLINE void PMBUS_CTRL_RX__MIN_RANGE__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & ~PMBUS_CTRL_RX__MIN_RANGE__Msk);
    reg = (reg | (PMBUS_CTRL_RX__MIN_RANGE__Shift((uint32_t)bf_value)));
    PMBUS_CTRL_RX__SET(reg);
}

/** PMBUS_CTRL_RX__MIN_RANGE__GET() gets CTRL_RX.MIN_RANGE's current value.
 *
 * When reading from CTRL_RX.MIN_RANGE, this is recommended to use.
 *
 * @return current value of CTRL_RX.MIN_RANGE
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__MIN_RANGE__GET(void)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & PMBUS_CTRL_RX__MIN_RANGE__Msk);
    reg = (reg >> PMBUS_CTRL_RX__MIN_RANGE__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CTRL_RX__MIN_RANGE__MODIFY() modifies CTRL_RX.MIN_RANGE.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_RX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @param bf_value new value for CTRL_RX.MIN_RANGE
 * @return new value of PMBUS.CTRL_RX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__MIN_RANGE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_RX__MIN_RANGE__Msk);
    reg = (reg | (PMBUS_CTRL_RX__MIN_RANGE__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_RX__MIN_RANGE__EXTRACT() extracts CTRL_RX.MIN_RANGE.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_RX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @return current value of CTRL_RX.MIN_RANGE
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__MIN_RANGE__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_RX__MIN_RANGE__Msk);
    reg = (reg >> PMBUS_CTRL_RX__MIN_RANGE__Pos);
    return (uint32_t)reg;
}

/* -------------------------- PMBUS.CTRL_RX.RX_REQ -------------------------- */


#define PMBUS_CTRL_RX__RX_REQ__Pos                              7                                                                      /*!< Right-most bit position of RX_REQ in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__RX_REQ__Msk                              (0x00000001UL << PMBUS_CTRL_RX__RX_REQ__Pos)                           /*!< Mask for RX_REQ in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__RX_REQ__Shift(v)                         (((v) << PMBUS_CTRL_RX__RX_REQ__Pos) & PMBUS_CTRL_RX__RX_REQ__Msk)     /*!< Shift value 'v' into RX_REQ and mask 'v' to fit it into RX_REQ field */

/** PMBUS_CTRL_RX__RX_REQ__GET() gets CTRL_RX.RX_REQ's current value.
 *
 * When reading from CTRL_RX.RX_REQ, this is recommended to use.
 *
 * @return current value of CTRL_RX.RX_REQ
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__RX_REQ__GET(void)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & PMBUS_CTRL_RX__RX_REQ__Msk);
    reg = (reg >> PMBUS_CTRL_RX__RX_REQ__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CTRL_RX__RX_REQ__EXTRACT() extracts CTRL_RX.RX_REQ.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_RX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @return current value of CTRL_RX.RX_REQ
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__RX_REQ__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_RX__RX_REQ__Msk);
    reg = (reg >> PMBUS_CTRL_RX__RX_REQ__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PMBUS.CTRL_RX.DATA_LUT_OP ----------------------- */


/*lint -parent(uint32_t, pmbus_ctrl_rx__data_lut_op_t) -strong(AJX)*/
typedef enum pmbus_ctrl_rx__data_lut_op_e                                                                                              /*!<  */
{
    pmbus_ctrl_rx__data_lut_op_dont_care_0 = 0u,                                                                                       /*!<  */
    pmbus_ctrl_rx__data_lut_op_clr = 1u,                                                                                               /*!<  */
    pmbus_ctrl_rx__data_lut_op_msk = 2u,                                                                                               /*!<  */
    pmbus_ctrl_rx__data_lut_op_set = 3u                                                                                                /*!<  */
} pmbus_ctrl_rx__data_lut_op_t;

#define PMBUS_CTRL_RX__DATA_LUT_OP__Pos                         5                                                                      /*!< Right-most bit position of DATA_LUT_OP in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__DATA_LUT_OP__Msk                         (0x00000003UL << PMBUS_CTRL_RX__DATA_LUT_OP__Pos)                      /*!< Mask for DATA_LUT_OP in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__DATA_LUT_OP__Shift(v)                    (((v) << PMBUS_CTRL_RX__DATA_LUT_OP__Pos) & PMBUS_CTRL_RX__DATA_LUT_OP__Msk) /*!< Shift value 'v' into DATA_LUT_OP and mask 'v' to fit it into DATA_LUT_OP field */

/** PMBUS_CTRL_RX__DATA_LUT_OP__SET() sets CTRL_RX.DATA_LUT_OP to given value.
 *
 * When writing to CTRL_RX.DATA_LUT_OP, this is recommended to use.
 *
 * @param bf_value new value for CTRL_RX.DATA_LUT_OP
 */
__PMBUS_INLINE void PMBUS_CTRL_RX__DATA_LUT_OP__SET(pmbus_ctrl_rx__data_lut_op_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & ~PMBUS_CTRL_RX__DATA_LUT_OP__Msk);
    reg = (reg | (PMBUS_CTRL_RX__DATA_LUT_OP__Shift((uint32_t)bf_value)));
    PMBUS_CTRL_RX__SET(reg);
}

/** PMBUS_CTRL_RX__DATA_LUT_OP__GET() gets CTRL_RX.DATA_LUT_OP's current value.
 *
 * When reading from CTRL_RX.DATA_LUT_OP, this is recommended to use.
 *
 * @return current value of CTRL_RX.DATA_LUT_OP
 */
__PMBUS_INLINE pmbus_ctrl_rx__data_lut_op_t PMBUS_CTRL_RX__DATA_LUT_OP__GET(void)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & PMBUS_CTRL_RX__DATA_LUT_OP__Msk);
    reg = (reg >> PMBUS_CTRL_RX__DATA_LUT_OP__Pos);
    return (pmbus_ctrl_rx__data_lut_op_t)reg;
}

/** PMBUS_CTRL_RX__DATA_LUT_OP__MODIFY() modifies CTRL_RX.DATA_LUT_OP.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_RX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @param bf_value new value for CTRL_RX.DATA_LUT_OP
 * @return new value of PMBUS.CTRL_RX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__DATA_LUT_OP__MODIFY(uint32_t reg, pmbus_ctrl_rx__data_lut_op_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_RX__DATA_LUT_OP__Msk);
    reg = (reg | (PMBUS_CTRL_RX__DATA_LUT_OP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_RX__DATA_LUT_OP__EXTRACT() extracts CTRL_RX.DATA_LUT_OP.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_RX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @return current value of CTRL_RX.DATA_LUT_OP
 */
__PMBUS_INLINE pmbus_ctrl_rx__data_lut_op_t PMBUS_CTRL_RX__DATA_LUT_OP__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_RX__DATA_LUT_OP__Msk);
    reg = (reg >> PMBUS_CTRL_RX__DATA_LUT_OP__Pos);
    return (pmbus_ctrl_rx__data_lut_op_t)reg;
}

/* ----------------------- PMBUS.CTRL_RX.ACK_SRC_SEL ----------------------- */


/*lint -parent(uint32_t, pmbus_ctrl_rx__ack_src_sel_t) -strong(AJX)*/
typedef enum pmbus_ctrl_rx__ack_src_sel_e                                                                                              /*!<  */
{
    pmbus_ctrl_rx__ack_src_sel_nack_0 = 0u,                                                                                            /*!<  */
    pmbus_ctrl_rx__ack_src_sel_adr_hit = 1u,                                                                                           /*!<  */
    pmbus_ctrl_rx__ack_src_sel_data_hit = 2u,                                                                                          /*!<  */
    pmbus_ctrl_rx__ack_src_sel_pec_chk = 3u,                                                                                           /*!<  */
    pmbus_ctrl_rx__ack_src_sel_ack = 4u,                                                                                               /*!<  */
    pmbus_ctrl_rx__ack_src_sel_nack_5 = 5u,                                                                                            /*!<  */
    pmbus_ctrl_rx__ack_src_sel_nack_6 = 6u,                                                                                            /*!<  */
    pmbus_ctrl_rx__ack_src_sel_nack_7 = 7u                                                                                             /*!<  */
} pmbus_ctrl_rx__ack_src_sel_t;

#define PMBUS_CTRL_RX__ACK_SRC_SEL__Pos                         2                                                                      /*!< Right-most bit position of ACK_SRC_SEL in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__ACK_SRC_SEL__Msk                         (0x00000007UL << PMBUS_CTRL_RX__ACK_SRC_SEL__Pos)                      /*!< Mask for ACK_SRC_SEL in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__ACK_SRC_SEL__Shift(v)                    (((v) << PMBUS_CTRL_RX__ACK_SRC_SEL__Pos) & PMBUS_CTRL_RX__ACK_SRC_SEL__Msk) /*!< Shift value 'v' into ACK_SRC_SEL and mask 'v' to fit it into ACK_SRC_SEL field */

/** PMBUS_CTRL_RX__ACK_SRC_SEL__SET() sets CTRL_RX.ACK_SRC_SEL to given value.
 *
 * When writing to CTRL_RX.ACK_SRC_SEL, this is recommended to use.
 *
 * @param bf_value new value for CTRL_RX.ACK_SRC_SEL
 */
__PMBUS_INLINE void PMBUS_CTRL_RX__ACK_SRC_SEL__SET(pmbus_ctrl_rx__ack_src_sel_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & ~PMBUS_CTRL_RX__ACK_SRC_SEL__Msk);
    reg = (reg | (PMBUS_CTRL_RX__ACK_SRC_SEL__Shift((uint32_t)bf_value)));
    PMBUS_CTRL_RX__SET(reg);
}

/** PMBUS_CTRL_RX__ACK_SRC_SEL__GET() gets CTRL_RX.ACK_SRC_SEL's current value.
 *
 * When reading from CTRL_RX.ACK_SRC_SEL, this is recommended to use.
 *
 * @return current value of CTRL_RX.ACK_SRC_SEL
 */
__PMBUS_INLINE pmbus_ctrl_rx__ack_src_sel_t PMBUS_CTRL_RX__ACK_SRC_SEL__GET(void)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & PMBUS_CTRL_RX__ACK_SRC_SEL__Msk);
    reg = (reg >> PMBUS_CTRL_RX__ACK_SRC_SEL__Pos);
    return (pmbus_ctrl_rx__ack_src_sel_t)reg;
}

/** PMBUS_CTRL_RX__ACK_SRC_SEL__MODIFY() modifies CTRL_RX.ACK_SRC_SEL.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_RX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @param bf_value new value for CTRL_RX.ACK_SRC_SEL
 * @return new value of PMBUS.CTRL_RX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__ACK_SRC_SEL__MODIFY(uint32_t reg, pmbus_ctrl_rx__ack_src_sel_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_RX__ACK_SRC_SEL__Msk);
    reg = (reg | (PMBUS_CTRL_RX__ACK_SRC_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_RX__ACK_SRC_SEL__EXTRACT() extracts CTRL_RX.ACK_SRC_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_RX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @return current value of CTRL_RX.ACK_SRC_SEL
 */
__PMBUS_INLINE pmbus_ctrl_rx__ack_src_sel_t PMBUS_CTRL_RX__ACK_SRC_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_RX__ACK_SRC_SEL__Msk);
    reg = (reg >> PMBUS_CTRL_RX__ACK_SRC_SEL__Pos);
    return (pmbus_ctrl_rx__ack_src_sel_t)reg;
}

/* ---------------------- PMBUS.CTRL_RX.ACK_RECEPTION ---------------------- */


#define PMBUS_CTRL_RX__ACK_RECEPTION__Pos                       1                                                                      /*!< Right-most bit position of ACK_RECEPTION in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__ACK_RECEPTION__Msk                       (0x00000001UL << PMBUS_CTRL_RX__ACK_RECEPTION__Pos)                    /*!< Mask for ACK_RECEPTION in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__ACK_RECEPTION__Shift(v)                  (((v) << PMBUS_CTRL_RX__ACK_RECEPTION__Pos) & PMBUS_CTRL_RX__ACK_RECEPTION__Msk) /*!< Shift value 'v' into ACK_RECEPTION and mask 'v' to fit it into ACK_RECEPTION field */

/** PMBUS_CTRL_RX__ACK_RECEPTION__SET() sets CTRL_RX.ACK_RECEPTION to given value.
 *
 * When writing to CTRL_RX.ACK_RECEPTION, this is recommended to use.
 *
 * @param bf_value new value for CTRL_RX.ACK_RECEPTION
 */
__PMBUS_INLINE void PMBUS_CTRL_RX__ACK_RECEPTION__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & ~PMBUS_CTRL_RX__ACK_RECEPTION__Msk);
    reg = (reg | (PMBUS_CTRL_RX__ACK_RECEPTION__Shift((uint32_t)bf_value)));
    PMBUS_CTRL_RX__SET(reg);
}

/** PMBUS_CTRL_RX__ACK_RECEPTION__GET() gets CTRL_RX.ACK_RECEPTION's current value.
 *
 * When reading from CTRL_RX.ACK_RECEPTION, this is recommended to use.
 *
 * @return current value of CTRL_RX.ACK_RECEPTION
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__ACK_RECEPTION__GET(void)
{
    uint32_t reg = PMBUS_CTRL_RX__GET();
    reg = (reg & PMBUS_CTRL_RX__ACK_RECEPTION__Msk);
    reg = (reg >> PMBUS_CTRL_RX__ACK_RECEPTION__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CTRL_RX__ACK_RECEPTION__MODIFY() modifies CTRL_RX.ACK_RECEPTION.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_RX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @param bf_value new value for CTRL_RX.ACK_RECEPTION
 * @return new value of PMBUS.CTRL_RX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__ACK_RECEPTION__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_RX__ACK_RECEPTION__Msk);
    reg = (reg | (PMBUS_CTRL_RX__ACK_RECEPTION__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_RX__ACK_RECEPTION__EXTRACT() extracts CTRL_RX.ACK_RECEPTION.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_RX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @return current value of CTRL_RX.ACK_RECEPTION
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__ACK_RECEPTION__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_RX__ACK_RECEPTION__Msk);
    reg = (reg >> PMBUS_CTRL_RX__ACK_RECEPTION__Pos);
    return (uint32_t)reg;
}

/* ------------------------ PMBUS.CTRL_RX.RX_TRIGGER ------------------------ */


#define PMBUS_CTRL_RX__RX_TRIGGER__Pos                          0                                                                      /*!< Right-most bit position of RX_TRIGGER in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__RX_TRIGGER__Msk                          (0x00000001UL << PMBUS_CTRL_RX__RX_TRIGGER__Pos)                       /*!< Mask for RX_TRIGGER in PMBUS.CTRL_RX */
#define PMBUS_CTRL_RX__RX_TRIGGER__Shift(v)                     (((v) << PMBUS_CTRL_RX__RX_TRIGGER__Pos) & PMBUS_CTRL_RX__RX_TRIGGER__Msk) /*!< Shift value 'v' into RX_TRIGGER and mask 'v' to fit it into RX_TRIGGER field */

/** PMBUS_CTRL_RX__RX_TRIGGER__SET() sets CTRL_RX.RX_TRIGGER to given value.
 *
 * When writing to CTRL_RX.RX_TRIGGER, this is recommended to use.
 *
 * @param bf_value new value for CTRL_RX.RX_TRIGGER
 */
__PMBUS_INLINE void PMBUS_CTRL_RX__RX_TRIGGER__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_RX__RX_TRIGGER__Shift((uint32_t)bf_value);
    PMBUS_CTRL_RX__SET(reg);
}


/** PMBUS_CTRL_RX__RX_TRIGGER__MODIFY() modifies CTRL_RX.RX_TRIGGER.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_RX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @param bf_value new value for CTRL_RX.RX_TRIGGER
 * @return new value of PMBUS.CTRL_RX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__RX_TRIGGER__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_RX__RX_TRIGGER__Msk);
    reg = (reg | (PMBUS_CTRL_RX__RX_TRIGGER__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_RX__RX_TRIGGER__EXTRACT() extracts CTRL_RX.RX_TRIGGER.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_RX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_RX
 * @return current value of CTRL_RX.RX_TRIGGER
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_RX__RX_TRIGGER__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_RX__RX_TRIGGER__Msk);
    reg = (reg >> PMBUS_CTRL_RX__RX_TRIGGER__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          RXDATA member of PMBUS_t                          */
/* -------------------------------------------------------------------------- */

/** __PMBUS_RXDATA__ADDRESS returns the address of member RXDATA.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RXDATA
 */
__PMBUS_INLINE uint32_t* __PMBUS_RXDATA__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, RXDATA)));
}

/** PMBUS_RXDATA__GET() gets RXDATA's current value.
 *
 * When reading from RXDATA, this is mandatory to use.
 *
 * @return current value of RXDATA
 */
__PMBUS_INLINE uint32_t PMBUS_RXDATA__GET(void)
{
    return HAL_GET32(__PMBUS_RXDATA__ADDRESS());
}

/* --------------------------- PMBUS.RXDATA.DATA --------------------------- */


#define PMBUS_RXDATA__DATA__Pos                                 0                                                                      /*!< Right-most bit position of DATA in PMBUS.RXDATA */
#define PMBUS_RXDATA__DATA__Msk                                 (0x000000FFUL << PMBUS_RXDATA__DATA__Pos)                              /*!< Mask for DATA in PMBUS.RXDATA */
#define PMBUS_RXDATA__DATA__Shift(v)                            (((v) << PMBUS_RXDATA__DATA__Pos) & PMBUS_RXDATA__DATA__Msk)           /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** PMBUS_RXDATA__DATA__GET() gets RXDATA.DATA's current value.
 *
 * When reading from RXDATA.DATA, this is recommended to use.
 *
 * @return current value of RXDATA.DATA
 */
__PMBUS_INLINE uint32_t PMBUS_RXDATA__DATA__GET(void)
{
    uint32_t reg = PMBUS_RXDATA__GET();
    reg = (reg & PMBUS_RXDATA__DATA__Msk);
    reg = (reg >> PMBUS_RXDATA__DATA__Pos);
    return (uint32_t)reg;
}

/** PMBUS_RXDATA__DATA__EXTRACT() extracts RXDATA.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.RXDATA.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.RXDATA
 * @return current value of RXDATA.DATA
 */
__PMBUS_INLINE uint32_t PMBUS_RXDATA__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_RXDATA__DATA__Msk);
    reg = (reg >> PMBUS_RXDATA__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          RXPEC member of PMBUS_t                          */
/* -------------------------------------------------------------------------- */

/** __PMBUS_RXPEC__ADDRESS returns the address of member RXPEC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of RXPEC
 */
__PMBUS_INLINE uint32_t* __PMBUS_RXPEC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, RXPEC)));
}

/** PMBUS_RXPEC__GET() gets RXPEC's current value.
 *
 * When reading from RXPEC, this is mandatory to use.
 *
 * @return current value of RXPEC
 */
__PMBUS_INLINE uint32_t PMBUS_RXPEC__GET(void)
{
    return HAL_GET32(__PMBUS_RXPEC__ADDRESS());
}

/* ---------------------------- PMBUS.RXPEC.DATA ---------------------------- */


#define PMBUS_RXPEC__DATA__Pos                                  0                                                                      /*!< Right-most bit position of DATA in PMBUS.RXPEC */
#define PMBUS_RXPEC__DATA__Msk                                  (0x000000FFUL << PMBUS_RXPEC__DATA__Pos)                               /*!< Mask for DATA in PMBUS.RXPEC */
#define PMBUS_RXPEC__DATA__Shift(v)                             (((v) << PMBUS_RXPEC__DATA__Pos) & PMBUS_RXPEC__DATA__Msk)             /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** PMBUS_RXPEC__DATA__GET() gets RXPEC.DATA's current value.
 *
 * When reading from RXPEC.DATA, this is recommended to use.
 *
 * @return current value of RXPEC.DATA
 */
__PMBUS_INLINE uint32_t PMBUS_RXPEC__DATA__GET(void)
{
    uint32_t reg = PMBUS_RXPEC__GET();
    reg = (reg & PMBUS_RXPEC__DATA__Msk);
    reg = (reg >> PMBUS_RXPEC__DATA__Pos);
    return (uint32_t)reg;
}

/** PMBUS_RXPEC__DATA__EXTRACT() extracts RXPEC.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.RXPEC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.RXPEC
 * @return current value of RXPEC.DATA
 */
__PMBUS_INLINE uint32_t PMBUS_RXPEC__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_RXPEC__DATA__Msk);
    reg = (reg >> PMBUS_RXPEC__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         CTRL_TX member of PMBUS_t                         */
/* -------------------------------------------------------------------------- */

/** __PMBUS_CTRL_TX__ADDRESS returns the address of member CTRL_TX.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CTRL_TX
 */
__PMBUS_INLINE uint32_t* __PMBUS_CTRL_TX__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, CTRL_TX)));
}

/** PMBUS_CTRL_TX__SET() sets CTRL_TX to given value.
 *
 * When writing to CTRL_TX, this is mandatory to use.
 *
 * @param value new value for CTRL_TX
 */
__PMBUS_INLINE void PMBUS_CTRL_TX__SET(uint32_t value)
{
    HAL_SET32(__PMBUS_CTRL_TX__ADDRESS(), value);
}

/** PMBUS_CTRL_TX__GET() gets CTRL_TX's current value.
 *
 * When reading from CTRL_TX, this is mandatory to use.
 *
 * @return current value of CTRL_TX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__GET(void)
{
    return HAL_GET32(__PMBUS_CTRL_TX__ADDRESS());
}

/* -------------------------- PMBUS.CTRL_TX.TX_REQ -------------------------- */


#define PMBUS_CTRL_TX__TX_REQ__Pos                              16                                                                     /*!< Right-most bit position of TX_REQ in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__TX_REQ__Msk                              (0x00000001UL << PMBUS_CTRL_TX__TX_REQ__Pos)                           /*!< Mask for TX_REQ in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__TX_REQ__Shift(v)                         (((v) << PMBUS_CTRL_TX__TX_REQ__Pos) & PMBUS_CTRL_TX__TX_REQ__Msk)     /*!< Shift value 'v' into TX_REQ and mask 'v' to fit it into TX_REQ field */

/** PMBUS_CTRL_TX__TX_REQ__GET() gets CTRL_TX.TX_REQ's current value.
 *
 * When reading from CTRL_TX.TX_REQ, this is recommended to use.
 *
 * @return current value of CTRL_TX.TX_REQ
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__TX_REQ__GET(void)
{
    uint32_t reg = PMBUS_CTRL_TX__GET();
    reg = (reg & PMBUS_CTRL_TX__TX_REQ__Msk);
    reg = (reg >> PMBUS_CTRL_TX__TX_REQ__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CTRL_TX__TX_REQ__EXTRACT() extracts CTRL_TX.TX_REQ.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_TX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @return current value of CTRL_TX.TX_REQ
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__TX_REQ__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_TX__TX_REQ__Msk);
    reg = (reg >> PMBUS_CTRL_TX__TX_REQ__Pos);
    return (uint32_t)reg;
}

/* ----------------------- PMBUS.CTRL_TX.DATA_LUT_OP ----------------------- */


/*lint -parent(uint32_t, pmbus_ctrl_tx__data_lut_op_t) -strong(AJX)*/
typedef enum pmbus_ctrl_tx__data_lut_op_e                                                                                              /*!<  */
{
    pmbus_ctrl_tx__data_lut_op_dont_care_0 = 0u,                                                                                       /*!<  */
    pmbus_ctrl_tx__data_lut_op_clr = 1u,                                                                                               /*!<  */
    pmbus_ctrl_tx__data_lut_op_msk = 2u,                                                                                               /*!<  */
    pmbus_ctrl_tx__data_lut_op_set = 3u                                                                                                /*!<  */
} pmbus_ctrl_tx__data_lut_op_t;

#define PMBUS_CTRL_TX__DATA_LUT_OP__Pos                         14                                                                     /*!< Right-most bit position of DATA_LUT_OP in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__DATA_LUT_OP__Msk                         (0x00000003UL << PMBUS_CTRL_TX__DATA_LUT_OP__Pos)                      /*!< Mask for DATA_LUT_OP in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__DATA_LUT_OP__Shift(v)                    (((v) << PMBUS_CTRL_TX__DATA_LUT_OP__Pos) & PMBUS_CTRL_TX__DATA_LUT_OP__Msk) /*!< Shift value 'v' into DATA_LUT_OP and mask 'v' to fit it into DATA_LUT_OP field */

/** PMBUS_CTRL_TX__DATA_LUT_OP__SET() sets CTRL_TX.DATA_LUT_OP to given value.
 *
 * When writing to CTRL_TX.DATA_LUT_OP, this is recommended to use.
 *
 * @param bf_value new value for CTRL_TX.DATA_LUT_OP
 */
__PMBUS_INLINE void PMBUS_CTRL_TX__DATA_LUT_OP__SET(pmbus_ctrl_tx__data_lut_op_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_TX__GET();
    reg = (reg & ~PMBUS_CTRL_TX__DATA_LUT_OP__Msk);
    reg = (reg | (PMBUS_CTRL_TX__DATA_LUT_OP__Shift((uint32_t)bf_value)));
    PMBUS_CTRL_TX__SET(reg);
}

/** PMBUS_CTRL_TX__DATA_LUT_OP__GET() gets CTRL_TX.DATA_LUT_OP's current value.
 *
 * When reading from CTRL_TX.DATA_LUT_OP, this is recommended to use.
 *
 * @return current value of CTRL_TX.DATA_LUT_OP
 */
__PMBUS_INLINE pmbus_ctrl_tx__data_lut_op_t PMBUS_CTRL_TX__DATA_LUT_OP__GET(void)
{
    uint32_t reg = PMBUS_CTRL_TX__GET();
    reg = (reg & PMBUS_CTRL_TX__DATA_LUT_OP__Msk);
    reg = (reg >> PMBUS_CTRL_TX__DATA_LUT_OP__Pos);
    return (pmbus_ctrl_tx__data_lut_op_t)reg;
}

/** PMBUS_CTRL_TX__DATA_LUT_OP__MODIFY() modifies CTRL_TX.DATA_LUT_OP.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_TX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @param bf_value new value for CTRL_TX.DATA_LUT_OP
 * @return new value of PMBUS.CTRL_TX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__DATA_LUT_OP__MODIFY(uint32_t reg, pmbus_ctrl_tx__data_lut_op_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_TX__DATA_LUT_OP__Msk);
    reg = (reg | (PMBUS_CTRL_TX__DATA_LUT_OP__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_TX__DATA_LUT_OP__EXTRACT() extracts CTRL_TX.DATA_LUT_OP.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_TX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @return current value of CTRL_TX.DATA_LUT_OP
 */
__PMBUS_INLINE pmbus_ctrl_tx__data_lut_op_t PMBUS_CTRL_TX__DATA_LUT_OP__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_TX__DATA_LUT_OP__Msk);
    reg = (reg >> PMBUS_CTRL_TX__DATA_LUT_OP__Pos);
    return (pmbus_ctrl_tx__data_lut_op_t)reg;
}

/* ---------------------- PMBUS.CTRL_TX.BYTE_REMAINING ---------------------- */


#define PMBUS_CTRL_TX__BYTE_REMAINING__Pos                      11                                                                     /*!< Right-most bit position of BYTE_REMAINING in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__BYTE_REMAINING__Msk                      (0x00000007UL << PMBUS_CTRL_TX__BYTE_REMAINING__Pos)                   /*!< Mask for BYTE_REMAINING in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__BYTE_REMAINING__Shift(v)                 (((v) << PMBUS_CTRL_TX__BYTE_REMAINING__Pos) & PMBUS_CTRL_TX__BYTE_REMAINING__Msk) /*!< Shift value 'v' into BYTE_REMAINING and mask 'v' to fit it into BYTE_REMAINING field */

/** PMBUS_CTRL_TX__BYTE_REMAINING__SET() sets CTRL_TX.BYTE_REMAINING to given value.
 *
 * When writing to CTRL_TX.BYTE_REMAINING, this is recommended to use.
 *
 * @param bf_value new value for CTRL_TX.BYTE_REMAINING
 */
__PMBUS_INLINE void PMBUS_CTRL_TX__BYTE_REMAINING__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_TX__GET();
    reg = (reg & ~PMBUS_CTRL_TX__BYTE_REMAINING__Msk);
    reg = (reg | (PMBUS_CTRL_TX__BYTE_REMAINING__Shift((uint32_t)bf_value)));
    PMBUS_CTRL_TX__SET(reg);
}

/** PMBUS_CTRL_TX__BYTE_REMAINING__GET() gets CTRL_TX.BYTE_REMAINING's current value.
 *
 * When reading from CTRL_TX.BYTE_REMAINING, this is recommended to use.
 *
 * @return current value of CTRL_TX.BYTE_REMAINING
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__BYTE_REMAINING__GET(void)
{
    uint32_t reg = PMBUS_CTRL_TX__GET();
    reg = (reg & PMBUS_CTRL_TX__BYTE_REMAINING__Msk);
    reg = (reg >> PMBUS_CTRL_TX__BYTE_REMAINING__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CTRL_TX__BYTE_REMAINING__MODIFY() modifies CTRL_TX.BYTE_REMAINING.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_TX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @param bf_value new value for CTRL_TX.BYTE_REMAINING
 * @return new value of PMBUS.CTRL_TX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__BYTE_REMAINING__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_TX__BYTE_REMAINING__Msk);
    reg = (reg | (PMBUS_CTRL_TX__BYTE_REMAINING__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_TX__BYTE_REMAINING__EXTRACT() extracts CTRL_TX.BYTE_REMAINING.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_TX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @return current value of CTRL_TX.BYTE_REMAINING
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__BYTE_REMAINING__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_TX__BYTE_REMAINING__Msk);
    reg = (reg >> PMBUS_CTRL_TX__BYTE_REMAINING__Pos);
    return (uint32_t)reg;
}

/* ------------------------ PMBUS.CTRL_TX.BYTE_TO_TX ------------------------ */


#define PMBUS_CTRL_TX__BYTE_TO_TX__Pos                          2                                                                      /*!< Right-most bit position of BYTE_TO_TX in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__BYTE_TO_TX__Msk                          (0x000001FFUL << PMBUS_CTRL_TX__BYTE_TO_TX__Pos)                       /*!< Mask for BYTE_TO_TX in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__BYTE_TO_TX__Shift(v)                     (((v) << PMBUS_CTRL_TX__BYTE_TO_TX__Pos) & PMBUS_CTRL_TX__BYTE_TO_TX__Msk) /*!< Shift value 'v' into BYTE_TO_TX and mask 'v' to fit it into BYTE_TO_TX field */

/** PMBUS_CTRL_TX__BYTE_TO_TX__SET() sets CTRL_TX.BYTE_TO_TX to given value.
 *
 * When writing to CTRL_TX.BYTE_TO_TX, this is recommended to use.
 *
 * @param bf_value new value for CTRL_TX.BYTE_TO_TX
 */
__PMBUS_INLINE void PMBUS_CTRL_TX__BYTE_TO_TX__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_TX__GET();
    reg = (reg & ~PMBUS_CTRL_TX__BYTE_TO_TX__Msk);
    reg = (reg | (PMBUS_CTRL_TX__BYTE_TO_TX__Shift((uint32_t)bf_value)));
    PMBUS_CTRL_TX__SET(reg);
}

/** PMBUS_CTRL_TX__BYTE_TO_TX__GET() gets CTRL_TX.BYTE_TO_TX's current value.
 *
 * When reading from CTRL_TX.BYTE_TO_TX, this is recommended to use.
 *
 * @return current value of CTRL_TX.BYTE_TO_TX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__BYTE_TO_TX__GET(void)
{
    uint32_t reg = PMBUS_CTRL_TX__GET();
    reg = (reg & PMBUS_CTRL_TX__BYTE_TO_TX__Msk);
    reg = (reg >> PMBUS_CTRL_TX__BYTE_TO_TX__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CTRL_TX__BYTE_TO_TX__MODIFY() modifies CTRL_TX.BYTE_TO_TX.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_TX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @param bf_value new value for CTRL_TX.BYTE_TO_TX
 * @return new value of PMBUS.CTRL_TX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__BYTE_TO_TX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_TX__BYTE_TO_TX__Msk);
    reg = (reg | (PMBUS_CTRL_TX__BYTE_TO_TX__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_TX__BYTE_TO_TX__EXTRACT() extracts CTRL_TX.BYTE_TO_TX.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_TX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @return current value of CTRL_TX.BYTE_TO_TX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__BYTE_TO_TX__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_TX__BYTE_TO_TX__Msk);
    reg = (reg >> PMBUS_CTRL_TX__BYTE_TO_TX__Pos);
    return (uint32_t)reg;
}

/* -------------------- PMBUS.CTRL_TX.DROP_TRANSMISSION -------------------- */


#define PMBUS_CTRL_TX__DROP_TRANSMISSION__Pos                   1                                                                      /*!< Right-most bit position of DROP_TRANSMISSION in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__DROP_TRANSMISSION__Msk                   (0x00000001UL << PMBUS_CTRL_TX__DROP_TRANSMISSION__Pos)                /*!< Mask for DROP_TRANSMISSION in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__DROP_TRANSMISSION__Shift(v)              (((v) << PMBUS_CTRL_TX__DROP_TRANSMISSION__Pos) & PMBUS_CTRL_TX__DROP_TRANSMISSION__Msk) /*!< Shift value 'v' into DROP_TRANSMISSION and mask 'v' to fit it into DROP_TRANSMISSION field */

/** PMBUS_CTRL_TX__DROP_TRANSMISSION__SET() sets CTRL_TX.DROP_TRANSMISSION to given value.
 *
 * When writing to CTRL_TX.DROP_TRANSMISSION, this is recommended to use.
 *
 * @param bf_value new value for CTRL_TX.DROP_TRANSMISSION
 */
__PMBUS_INLINE void PMBUS_CTRL_TX__DROP_TRANSMISSION__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_TX__GET();
    reg = (reg & ~PMBUS_CTRL_TX__DROP_TRANSMISSION__Msk);
    reg = (reg | (PMBUS_CTRL_TX__DROP_TRANSMISSION__Shift((uint32_t)bf_value)));
    PMBUS_CTRL_TX__SET(reg);
}

/** PMBUS_CTRL_TX__DROP_TRANSMISSION__GET() gets CTRL_TX.DROP_TRANSMISSION's current value.
 *
 * When reading from CTRL_TX.DROP_TRANSMISSION, this is recommended to use.
 *
 * @return current value of CTRL_TX.DROP_TRANSMISSION
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__DROP_TRANSMISSION__GET(void)
{
    uint32_t reg = PMBUS_CTRL_TX__GET();
    reg = (reg & PMBUS_CTRL_TX__DROP_TRANSMISSION__Msk);
    reg = (reg >> PMBUS_CTRL_TX__DROP_TRANSMISSION__Pos);
    return (uint32_t)reg;
}

/** PMBUS_CTRL_TX__DROP_TRANSMISSION__MODIFY() modifies CTRL_TX.DROP_TRANSMISSION.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_TX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @param bf_value new value for CTRL_TX.DROP_TRANSMISSION
 * @return new value of PMBUS.CTRL_TX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__DROP_TRANSMISSION__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_TX__DROP_TRANSMISSION__Msk);
    reg = (reg | (PMBUS_CTRL_TX__DROP_TRANSMISSION__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_TX__DROP_TRANSMISSION__EXTRACT() extracts CTRL_TX.DROP_TRANSMISSION.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_TX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @return current value of CTRL_TX.DROP_TRANSMISSION
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__DROP_TRANSMISSION__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_TX__DROP_TRANSMISSION__Msk);
    reg = (reg >> PMBUS_CTRL_TX__DROP_TRANSMISSION__Pos);
    return (uint32_t)reg;
}

/* ------------------------ PMBUS.CTRL_TX.TX_TRIGGER ------------------------ */


#define PMBUS_CTRL_TX__TX_TRIGGER__Pos                          0                                                                      /*!< Right-most bit position of TX_TRIGGER in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__TX_TRIGGER__Msk                          (0x00000001UL << PMBUS_CTRL_TX__TX_TRIGGER__Pos)                       /*!< Mask for TX_TRIGGER in PMBUS.CTRL_TX */
#define PMBUS_CTRL_TX__TX_TRIGGER__Shift(v)                     (((v) << PMBUS_CTRL_TX__TX_TRIGGER__Pos) & PMBUS_CTRL_TX__TX_TRIGGER__Msk) /*!< Shift value 'v' into TX_TRIGGER and mask 'v' to fit it into TX_TRIGGER field */

/** PMBUS_CTRL_TX__TX_TRIGGER__SET() sets CTRL_TX.TX_TRIGGER to given value.
 *
 * When writing to CTRL_TX.TX_TRIGGER, this is recommended to use.
 *
 * @param bf_value new value for CTRL_TX.TX_TRIGGER
 */
__PMBUS_INLINE void PMBUS_CTRL_TX__TX_TRIGGER__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_CTRL_TX__TX_TRIGGER__Shift((uint32_t)bf_value);
    PMBUS_CTRL_TX__SET(reg);
}


/** PMBUS_CTRL_TX__TX_TRIGGER__MODIFY() modifies CTRL_TX.TX_TRIGGER.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.CTRL_TX.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @param bf_value new value for CTRL_TX.TX_TRIGGER
 * @return new value of PMBUS.CTRL_TX
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__TX_TRIGGER__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_CTRL_TX__TX_TRIGGER__Msk);
    reg = (reg | (PMBUS_CTRL_TX__TX_TRIGGER__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_CTRL_TX__TX_TRIGGER__EXTRACT() extracts CTRL_TX.TX_TRIGGER.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.CTRL_TX.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.CTRL_TX
 * @return current value of CTRL_TX.TX_TRIGGER
 */
__PMBUS_INLINE uint32_t PMBUS_CTRL_TX__TX_TRIGGER__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_CTRL_TX__TX_TRIGGER__Msk);
    reg = (reg >> PMBUS_CTRL_TX__TX_TRIGGER__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          TXDATA member of PMBUS_t                          */
/* -------------------------------------------------------------------------- */

/** __PMBUS_TXDATA__ADDRESS returns the address of member TXDATA.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TXDATA
 */
__PMBUS_INLINE uint32_t* __PMBUS_TXDATA__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, TXDATA)));
}

/** PMBUS_TXDATA__GET() gets TXDATA's current value.
 *
 * When reading from TXDATA, this is mandatory to use.
 *
 * @return current value of TXDATA
 */
__PMBUS_INLINE uint32_t PMBUS_TXDATA__GET(void)
{
    return HAL_GET32(__PMBUS_TXDATA__ADDRESS());
}

/* --------------------------- PMBUS.TXDATA.DATA --------------------------- */


#define PMBUS_TXDATA__DATA__Pos                                 0                                                                      /*!< Right-most bit position of DATA in PMBUS.TXDATA */
#define PMBUS_TXDATA__DATA__Msk                                 (0x000000FFUL << PMBUS_TXDATA__DATA__Pos)                              /*!< Mask for DATA in PMBUS.TXDATA */
#define PMBUS_TXDATA__DATA__Shift(v)                            (((v) << PMBUS_TXDATA__DATA__Pos) & PMBUS_TXDATA__DATA__Msk)           /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** PMBUS_TXDATA__DATA__GET() gets TXDATA.DATA's current value.
 *
 * When reading from TXDATA.DATA, this is recommended to use.
 *
 * @return current value of TXDATA.DATA
 */
__PMBUS_INLINE uint32_t PMBUS_TXDATA__DATA__GET(void)
{
    uint32_t reg = PMBUS_TXDATA__GET();
    reg = (reg & PMBUS_TXDATA__DATA__Msk);
    reg = (reg >> PMBUS_TXDATA__DATA__Pos);
    return (uint32_t)reg;
}

/** PMBUS_TXDATA__DATA__EXTRACT() extracts TXDATA.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.TXDATA.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.TXDATA
 * @return current value of TXDATA.DATA
 */
__PMBUS_INLINE uint32_t PMBUS_TXDATA__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_TXDATA__DATA__Msk);
    reg = (reg >> PMBUS_TXDATA__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          TXPEC member of PMBUS_t                          */
/* -------------------------------------------------------------------------- */

/** __PMBUS_TXPEC__ADDRESS returns the address of member TXPEC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of TXPEC
 */
__PMBUS_INLINE uint32_t* __PMBUS_TXPEC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, TXPEC)));
}

/** PMBUS_TXPEC__GET() gets TXPEC's current value.
 *
 * When reading from TXPEC, this is mandatory to use.
 *
 * @return current value of TXPEC
 */
__PMBUS_INLINE uint32_t PMBUS_TXPEC__GET(void)
{
    return HAL_GET32(__PMBUS_TXPEC__ADDRESS());
}

/* ---------------------------- PMBUS.TXPEC.DATA ---------------------------- */


#define PMBUS_TXPEC__DATA__Pos                                  0                                                                      /*!< Right-most bit position of DATA in PMBUS.TXPEC */
#define PMBUS_TXPEC__DATA__Msk                                  (0x000000FFUL << PMBUS_TXPEC__DATA__Pos)                               /*!< Mask for DATA in PMBUS.TXPEC */
#define PMBUS_TXPEC__DATA__Shift(v)                             (((v) << PMBUS_TXPEC__DATA__Pos) & PMBUS_TXPEC__DATA__Msk)             /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** PMBUS_TXPEC__DATA__GET() gets TXPEC.DATA's current value.
 *
 * When reading from TXPEC.DATA, this is recommended to use.
 *
 * @return current value of TXPEC.DATA
 */
__PMBUS_INLINE uint32_t PMBUS_TXPEC__DATA__GET(void)
{
    uint32_t reg = PMBUS_TXPEC__GET();
    reg = (reg & PMBUS_TXPEC__DATA__Msk);
    reg = (reg >> PMBUS_TXPEC__DATA__Pos);
    return (uint32_t)reg;
}

/** PMBUS_TXPEC__DATA__EXTRACT() extracts TXPEC.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.TXPEC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.TXPEC
 * @return current value of TXPEC.DATA
 */
__PMBUS_INLINE uint32_t PMBUS_TXPEC__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_TXPEC__DATA__Msk);
    reg = (reg >> PMBUS_TXPEC__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         DMA_CTRL member of PMBUS_t                         */
/* -------------------------------------------------------------------------- */

/** __PMBUS_DMA_CTRL__ADDRESS returns the address of member DMA_CTRL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DMA_CTRL
 */
__PMBUS_INLINE uint32_t* __PMBUS_DMA_CTRL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, DMA_CTRL)));
}

/** PMBUS_DMA_CTRL__SET() sets DMA_CTRL to given value.
 *
 * When writing to DMA_CTRL, this is mandatory to use.
 *
 * @param value new value for DMA_CTRL
 */
__PMBUS_INLINE void PMBUS_DMA_CTRL__SET(uint32_t value)
{
    HAL_SET32(__PMBUS_DMA_CTRL__ADDRESS(), value);
}

/** PMBUS_DMA_CTRL__GET() gets DMA_CTRL's current value.
 *
 * When reading from DMA_CTRL, this is mandatory to use.
 *
 * @return current value of DMA_CTRL
 */
__PMBUS_INLINE uint32_t PMBUS_DMA_CTRL__GET(void)
{
    return HAL_GET32(__PMBUS_DMA_CTRL__ADDRESS());
}

/* ------------------------ PMBUS.DMA_CTRL.EN_DMATX ------------------------ */


#define PMBUS_DMA_CTRL__EN_DMATX__Pos                           1                                                                      /*!< Right-most bit position of EN_DMATX in PMBUS.DMA_CTRL */
#define PMBUS_DMA_CTRL__EN_DMATX__Msk                           (0x00000001UL << PMBUS_DMA_CTRL__EN_DMATX__Pos)                        /*!< Mask for EN_DMATX in PMBUS.DMA_CTRL */
#define PMBUS_DMA_CTRL__EN_DMATX__Shift(v)                      (((v) << PMBUS_DMA_CTRL__EN_DMATX__Pos) & PMBUS_DMA_CTRL__EN_DMATX__Msk) /*!< Shift value 'v' into EN_DMATX and mask 'v' to fit it into EN_DMATX field */

/** PMBUS_DMA_CTRL__EN_DMATX__SET() sets DMA_CTRL.EN_DMATX to given value.
 *
 * When writing to DMA_CTRL.EN_DMATX, this is recommended to use.
 *
 * @param bf_value new value for DMA_CTRL.EN_DMATX
 */
__PMBUS_INLINE void PMBUS_DMA_CTRL__EN_DMATX__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_DMA_CTRL__GET();
    reg = (reg & ~PMBUS_DMA_CTRL__EN_DMATX__Msk);
    reg = (reg | (PMBUS_DMA_CTRL__EN_DMATX__Shift((uint32_t)bf_value)));
    PMBUS_DMA_CTRL__SET(reg);
}

/** PMBUS_DMA_CTRL__EN_DMATX__GET() gets DMA_CTRL.EN_DMATX's current value.
 *
 * When reading from DMA_CTRL.EN_DMATX, this is recommended to use.
 *
 * @return current value of DMA_CTRL.EN_DMATX
 */
__PMBUS_INLINE uint32_t PMBUS_DMA_CTRL__EN_DMATX__GET(void)
{
    uint32_t reg = PMBUS_DMA_CTRL__GET();
    reg = (reg & PMBUS_DMA_CTRL__EN_DMATX__Msk);
    reg = (reg >> PMBUS_DMA_CTRL__EN_DMATX__Pos);
    return (uint32_t)reg;
}

/** PMBUS_DMA_CTRL__EN_DMATX__MODIFY() modifies DMA_CTRL.EN_DMATX.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.DMA_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.DMA_CTRL
 * @param bf_value new value for DMA_CTRL.EN_DMATX
 * @return new value of PMBUS.DMA_CTRL
 */
__PMBUS_INLINE uint32_t PMBUS_DMA_CTRL__EN_DMATX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_DMA_CTRL__EN_DMATX__Msk);
    reg = (reg | (PMBUS_DMA_CTRL__EN_DMATX__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_DMA_CTRL__EN_DMATX__EXTRACT() extracts DMA_CTRL.EN_DMATX.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.DMA_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.DMA_CTRL
 * @return current value of DMA_CTRL.EN_DMATX
 */
__PMBUS_INLINE uint32_t PMBUS_DMA_CTRL__EN_DMATX__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_DMA_CTRL__EN_DMATX__Msk);
    reg = (reg >> PMBUS_DMA_CTRL__EN_DMATX__Pos);
    return (uint32_t)reg;
}

/* ------------------------ PMBUS.DMA_CTRL.EN_DMARX ------------------------ */


#define PMBUS_DMA_CTRL__EN_DMARX__Pos                           0                                                                      /*!< Right-most bit position of EN_DMARX in PMBUS.DMA_CTRL */
#define PMBUS_DMA_CTRL__EN_DMARX__Msk                           (0x00000001UL << PMBUS_DMA_CTRL__EN_DMARX__Pos)                        /*!< Mask for EN_DMARX in PMBUS.DMA_CTRL */
#define PMBUS_DMA_CTRL__EN_DMARX__Shift(v)                      (((v) << PMBUS_DMA_CTRL__EN_DMARX__Pos) & PMBUS_DMA_CTRL__EN_DMARX__Msk) /*!< Shift value 'v' into EN_DMARX and mask 'v' to fit it into EN_DMARX field */

/** PMBUS_DMA_CTRL__EN_DMARX__SET() sets DMA_CTRL.EN_DMARX to given value.
 *
 * When writing to DMA_CTRL.EN_DMARX, this is recommended to use.
 *
 * @param bf_value new value for DMA_CTRL.EN_DMARX
 */
__PMBUS_INLINE void PMBUS_DMA_CTRL__EN_DMARX__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_DMA_CTRL__GET();
    reg = (reg & ~PMBUS_DMA_CTRL__EN_DMARX__Msk);
    reg = (reg | (PMBUS_DMA_CTRL__EN_DMARX__Shift((uint32_t)bf_value)));
    PMBUS_DMA_CTRL__SET(reg);
}

/** PMBUS_DMA_CTRL__EN_DMARX__GET() gets DMA_CTRL.EN_DMARX's current value.
 *
 * When reading from DMA_CTRL.EN_DMARX, this is recommended to use.
 *
 * @return current value of DMA_CTRL.EN_DMARX
 */
__PMBUS_INLINE uint32_t PMBUS_DMA_CTRL__EN_DMARX__GET(void)
{
    uint32_t reg = PMBUS_DMA_CTRL__GET();
    reg = (reg & PMBUS_DMA_CTRL__EN_DMARX__Msk);
    reg = (reg >> PMBUS_DMA_CTRL__EN_DMARX__Pos);
    return (uint32_t)reg;
}

/** PMBUS_DMA_CTRL__EN_DMARX__MODIFY() modifies DMA_CTRL.EN_DMARX.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.DMA_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.DMA_CTRL
 * @param bf_value new value for DMA_CTRL.EN_DMARX
 * @return new value of PMBUS.DMA_CTRL
 */
__PMBUS_INLINE uint32_t PMBUS_DMA_CTRL__EN_DMARX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_DMA_CTRL__EN_DMARX__Msk);
    reg = (reg | (PMBUS_DMA_CTRL__EN_DMARX__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_DMA_CTRL__EN_DMARX__EXTRACT() extracts DMA_CTRL.EN_DMARX.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.DMA_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.DMA_CTRL
 * @return current value of DMA_CTRL.EN_DMARX
 */
__PMBUS_INLINE uint32_t PMBUS_DMA_CTRL__EN_DMARX__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_DMA_CTRL__EN_DMARX__Msk);
    reg = (reg >> PMBUS_DMA_CTRL__EN_DMARX__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         ADDR_LUT member of PMBUS_t                         */
/* -------------------------------------------------------------------------- */

/** __PMBUS_ADDR_LUT__ADDRESS returns the address of member ADDR_LUT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in ADDR_LUT array
 * @return address of ADDR_LUT
 */
__PMBUS_INLINE uint32_t* __PMBUS_ADDR_LUT__ADDRESS(pmbus_addr_lut_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, ADDR_LUT)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_ADDR_LUT__SET() sets ADDR_LUT to given value.
 *
 * When writing to ADDR_LUT, this is mandatory to use.
 *
 * @param ida index in ADDR_LUT array
 * @param value new value for ADDR_LUT
 */
__PMBUS_INLINE void PMBUS_ADDR_LUT__SET(pmbus_addr_lut_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_ADDR_LUT__ADDRESS(ida), value);
}

/** PMBUS_ADDR_LUT__GET() gets ADDR_LUT's current value.
 *
 * When reading from ADDR_LUT, this is mandatory to use.
 *
 * @param ida index in ADDR_LUT array
 * @return current value of ADDR_LUT
 */
__PMBUS_INLINE uint32_t PMBUS_ADDR_LUT__GET(pmbus_addr_lut_idx_t ida)
{
    return HAL_GET32(__PMBUS_ADDR_LUT__ADDRESS(ida));
}

/* -------------------------- PMBUS.ADDR_LUT.TYPE -------------------------- */


/*lint -parent(uint32_t, pmbus_addr_lut__type_t) -strong(AJX)*/
typedef enum pmbus_addr_lut__type_e                                                                                                    /*!<  */
{
    pmbus_addr_lut__type_pmb = 0u,                                                                                                     /*!<  */
    pmbus_addr_lut__type_i2c = 1u,                                                                                                     /*!<  */
    pmbus_addr_lut__type_res0 = 2u,                                                                                                    /*!<  */
    pmbus_addr_lut__type_res1 = 3u                                                                                                     /*!<  */
} pmbus_addr_lut__type_t;

#define PMBUS_ADDR_LUT__TYPE__Pos                               9                                                                      /*!< Right-most bit position of TYPE in PMBUS.ADDR_LUT */
#define PMBUS_ADDR_LUT__TYPE__Msk                               (0x00000003UL << PMBUS_ADDR_LUT__TYPE__Pos)                            /*!< Mask for TYPE in PMBUS.ADDR_LUT */
#define PMBUS_ADDR_LUT__TYPE__Shift(v)                          (((v) << PMBUS_ADDR_LUT__TYPE__Pos) & PMBUS_ADDR_LUT__TYPE__Msk)       /*!< Shift value 'v' into TYPE and mask 'v' to fit it into TYPE field */

/** PMBUS_ADDR_LUT__TYPE__SET() sets ADDR_LUT.TYPE to given value.
 *
 * When writing to ADDR_LUT.TYPE, this is recommended to use.
 *
 * @param ida index in ADDR_LUT array
 * @param bf_value new value for ADDR_LUT.TYPE
 */
__PMBUS_INLINE void PMBUS_ADDR_LUT__TYPE__SET(pmbus_addr_lut_idx_t ida, pmbus_addr_lut__type_t bf_value)
{
    uint32_t reg = PMBUS_ADDR_LUT__GET(ida);
    reg = (reg & ~PMBUS_ADDR_LUT__TYPE__Msk);
    reg = (reg | (PMBUS_ADDR_LUT__TYPE__Shift((uint32_t)bf_value)));
    PMBUS_ADDR_LUT__SET(ida, reg);
}

/** PMBUS_ADDR_LUT__TYPE__GET() gets ADDR_LUT.TYPE's current value.
 *
 * When reading from ADDR_LUT.TYPE, this is recommended to use.
 *
 * @param ida index in ADDR_LUT array
 * @return current value of ADDR_LUT.TYPE
 */
__PMBUS_INLINE pmbus_addr_lut__type_t PMBUS_ADDR_LUT__TYPE__GET(pmbus_addr_lut_idx_t ida)
{
    uint32_t reg = PMBUS_ADDR_LUT__GET(ida);
    reg = (reg & PMBUS_ADDR_LUT__TYPE__Msk);
    reg = (reg >> PMBUS_ADDR_LUT__TYPE__Pos);
    return (pmbus_addr_lut__type_t)reg;
}

/* -------------------------- PMBUS.ADDR_LUT.ADDR -------------------------- */


#define PMBUS_ADDR_LUT__ADDR__Pos                               2                                                                      /*!< Right-most bit position of ADDR in PMBUS.ADDR_LUT */
#define PMBUS_ADDR_LUT__ADDR__Msk                               (0x0000007FUL << PMBUS_ADDR_LUT__ADDR__Pos)                            /*!< Mask for ADDR in PMBUS.ADDR_LUT */
#define PMBUS_ADDR_LUT__ADDR__Shift(v)                          (((v) << PMBUS_ADDR_LUT__ADDR__Pos) & PMBUS_ADDR_LUT__ADDR__Msk)       /*!< Shift value 'v' into ADDR and mask 'v' to fit it into ADDR field */

/** PMBUS_ADDR_LUT__ADDR__SET() sets ADDR_LUT.ADDR to given value.
 *
 * When writing to ADDR_LUT.ADDR, this is recommended to use.
 *
 * @param ida index in ADDR_LUT array
 * @param bf_value new value for ADDR_LUT.ADDR
 */
__PMBUS_INLINE void PMBUS_ADDR_LUT__ADDR__SET(pmbus_addr_lut_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_ADDR_LUT__GET(ida);
    reg = (reg & ~PMBUS_ADDR_LUT__ADDR__Msk);
    reg = (reg | (PMBUS_ADDR_LUT__ADDR__Shift((uint32_t)bf_value)));
    PMBUS_ADDR_LUT__SET(ida, reg);
}

/** PMBUS_ADDR_LUT__ADDR__GET() gets ADDR_LUT.ADDR's current value.
 *
 * When reading from ADDR_LUT.ADDR, this is recommended to use.
 *
 * @param ida index in ADDR_LUT array
 * @return current value of ADDR_LUT.ADDR
 */
__PMBUS_INLINE uint32_t PMBUS_ADDR_LUT__ADDR__GET(pmbus_addr_lut_idx_t ida)
{
    uint32_t reg = PMBUS_ADDR_LUT__GET(ida);
    reg = (reg & PMBUS_ADDR_LUT__ADDR__Msk);
    reg = (reg >> PMBUS_ADDR_LUT__ADDR__Pos);
    return (uint32_t)reg;
}

/* ------------------------- PMBUS.ADDR_LUT.EN_ADDR ------------------------- */


/*lint -parent(uint32_t, pmbus_addr_lut__en_addr_t) -strong(AJX)*/
typedef enum pmbus_addr_lut__en_addr_e                                                                                                 /*!<  */
{
    pmbus_addr_lut__en_addr_ds = 0u,                                                                                                   /*!<  */
    pmbus_addr_lut__en_addr_wr = 1u,                                                                                                   /*!<  */
    pmbus_addr_lut__en_addr_rd = 2u,                                                                                                   /*!<  */
    pmbus_addr_lut__en_addr_rw = 3u                                                                                                    /*!<  */
} pmbus_addr_lut__en_addr_t;

#define PMBUS_ADDR_LUT__EN_ADDR__Pos                            0                                                                      /*!< Right-most bit position of EN_ADDR in PMBUS.ADDR_LUT */
#define PMBUS_ADDR_LUT__EN_ADDR__Msk                            (0x00000003UL << PMBUS_ADDR_LUT__EN_ADDR__Pos)                         /*!< Mask for EN_ADDR in PMBUS.ADDR_LUT */
#define PMBUS_ADDR_LUT__EN_ADDR__Shift(v)                       (((v) << PMBUS_ADDR_LUT__EN_ADDR__Pos) & PMBUS_ADDR_LUT__EN_ADDR__Msk) /*!< Shift value 'v' into EN_ADDR and mask 'v' to fit it into EN_ADDR field */

/** PMBUS_ADDR_LUT__EN_ADDR__SET() sets ADDR_LUT.EN_ADDR to given value.
 *
 * When writing to ADDR_LUT.EN_ADDR, this is recommended to use.
 *
 * @param ida index in ADDR_LUT array
 * @param bf_value new value for ADDR_LUT.EN_ADDR
 */
__PMBUS_INLINE void PMBUS_ADDR_LUT__EN_ADDR__SET(pmbus_addr_lut_idx_t ida, pmbus_addr_lut__en_addr_t bf_value)
{
    uint32_t reg = PMBUS_ADDR_LUT__GET(ida);
    reg = (reg & ~PMBUS_ADDR_LUT__EN_ADDR__Msk);
    reg = (reg | (PMBUS_ADDR_LUT__EN_ADDR__Shift((uint32_t)bf_value)));
    PMBUS_ADDR_LUT__SET(ida, reg);
}

/** PMBUS_ADDR_LUT__EN_ADDR__GET() gets ADDR_LUT.EN_ADDR's current value.
 *
 * When reading from ADDR_LUT.EN_ADDR, this is recommended to use.
 *
 * @param ida index in ADDR_LUT array
 * @return current value of ADDR_LUT.EN_ADDR
 */
__PMBUS_INLINE pmbus_addr_lut__en_addr_t PMBUS_ADDR_LUT__EN_ADDR__GET(pmbus_addr_lut_idx_t ida)
{
    uint32_t reg = PMBUS_ADDR_LUT__GET(ida);
    reg = (reg & PMBUS_ADDR_LUT__EN_ADDR__Msk);
    reg = (reg >> PMBUS_ADDR_LUT__EN_ADDR__Pos);
    return (pmbus_addr_lut__en_addr_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         DATA_LUT member of PMBUS_t                         */
/* -------------------------------------------------------------------------- */

/** __PMBUS_DATA_LUT__ADDRESS returns the address of member DATA_LUT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in DATA_LUT array
 * @return address of DATA_LUT
 */
__PMBUS_INLINE uint32_t* __PMBUS_DATA_LUT__ADDRESS(pmbus_data_lut_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, DATA_LUT)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_DATA_LUT__SET() sets DATA_LUT to given value.
 *
 * When writing to DATA_LUT, this is mandatory to use.
 *
 * @param ida index in DATA_LUT array
 * @param value new value for DATA_LUT
 */
__PMBUS_INLINE void PMBUS_DATA_LUT__SET(pmbus_data_lut_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_DATA_LUT__ADDRESS(ida), value);
}

/** PMBUS_DATA_LUT__GET() gets DATA_LUT's current value.
 *
 * When reading from DATA_LUT, this is mandatory to use.
 *
 * @param ida index in DATA_LUT array
 * @return current value of DATA_LUT
 */
__PMBUS_INLINE uint32_t PMBUS_DATA_LUT__GET(pmbus_data_lut_idx_t ida)
{
    return HAL_GET32(__PMBUS_DATA_LUT__ADDRESS(ida));
}

/* -------------------------- PMBUS.DATA_LUT.DATA -------------------------- */


#define PMBUS_DATA_LUT__DATA__Pos                               0                                                                      /*!< Right-most bit position of DATA in PMBUS.DATA_LUT */
#define PMBUS_DATA_LUT__DATA__Msk                               (0xFFFFFFFFUL << PMBUS_DATA_LUT__DATA__Pos)                            /*!< Mask for DATA in PMBUS.DATA_LUT */
#define PMBUS_DATA_LUT__DATA__Shift(v)                          (((v) << PMBUS_DATA_LUT__DATA__Pos) & PMBUS_DATA_LUT__DATA__Msk)       /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** PMBUS_DATA_LUT__DATA__SET() sets DATA_LUT.DATA to given value.
 *
 * When writing to DATA_LUT.DATA, this is recommended to use.
 *
 * @param ida index in DATA_LUT array
 * @param bf_value new value for DATA_LUT.DATA
 */
__PMBUS_INLINE void PMBUS_DATA_LUT__DATA__SET(pmbus_data_lut_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_DATA_LUT__GET(ida);
    reg = (reg & ~PMBUS_DATA_LUT__DATA__Msk);
    reg = (reg | (PMBUS_DATA_LUT__DATA__Shift((uint32_t)bf_value)));
    PMBUS_DATA_LUT__SET(ida, reg);
}

/** PMBUS_DATA_LUT__DATA__GET() gets DATA_LUT.DATA's current value.
 *
 * When reading from DATA_LUT.DATA, this is recommended to use.
 *
 * @param ida index in DATA_LUT array
 * @return current value of DATA_LUT.DATA
 */
__PMBUS_INLINE uint32_t PMBUS_DATA_LUT__DATA__GET(pmbus_data_lut_idx_t ida)
{
    uint32_t reg = PMBUS_DATA_LUT__GET(ida);
    reg = (reg & PMBUS_DATA_LUT__DATA__Msk);
    reg = (reg >> PMBUS_DATA_LUT__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     DATA_LUT_BIT_SET member of PMBUS_t                     */
/* -------------------------------------------------------------------------- */

/** __PMBUS_DATA_LUT_BIT_SET__ADDRESS returns the address of member DATA_LUT_BIT_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DATA_LUT_BIT_SET
 */
__PMBUS_INLINE uint32_t* __PMBUS_DATA_LUT_BIT_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, DATA_LUT_BIT_SET)));
}

/** PMBUS_DATA_LUT_BIT_SET__SET() sets DATA_LUT_BIT_SET to given value.
 *
 * When writing to DATA_LUT_BIT_SET, this is mandatory to use.
 *
 * @param value new value for DATA_LUT_BIT_SET
 */
__PMBUS_INLINE void PMBUS_DATA_LUT_BIT_SET__SET(uint32_t value)
{
    HAL_SET32(__PMBUS_DATA_LUT_BIT_SET__ADDRESS(), value);
}


/* ---------------------- PMBUS.DATA_LUT_BIT_SET.INDEX ---------------------- */


#define PMBUS_DATA_LUT_BIT_SET__INDEX__Pos                      0                                                                      /*!< Right-most bit position of INDEX in PMBUS.DATA_LUT_BIT_SET */
#define PMBUS_DATA_LUT_BIT_SET__INDEX__Msk                      (0x000000FFUL << PMBUS_DATA_LUT_BIT_SET__INDEX__Pos)                   /*!< Mask for INDEX in PMBUS.DATA_LUT_BIT_SET */
#define PMBUS_DATA_LUT_BIT_SET__INDEX__Shift(v)                 (((v) << PMBUS_DATA_LUT_BIT_SET__INDEX__Pos) & PMBUS_DATA_LUT_BIT_SET__INDEX__Msk) /*!< Shift value 'v' into INDEX and mask 'v' to fit it into INDEX field */

/** PMBUS_DATA_LUT_BIT_SET__INDEX__SET() sets DATA_LUT_BIT_SET.INDEX to given value.
 *
 * When writing to DATA_LUT_BIT_SET.INDEX, this is recommended to use.
 *
 * @param bf_value new value for DATA_LUT_BIT_SET.INDEX
 */
__PMBUS_INLINE void PMBUS_DATA_LUT_BIT_SET__INDEX__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_DATA_LUT_BIT_SET__INDEX__Shift((uint32_t)bf_value);
    PMBUS_DATA_LUT_BIT_SET__SET(reg);
}


/** PMBUS_DATA_LUT_BIT_SET__INDEX__MODIFY() modifies DATA_LUT_BIT_SET.INDEX.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.DATA_LUT_BIT_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.DATA_LUT_BIT_SET
 * @param bf_value new value for DATA_LUT_BIT_SET.INDEX
 * @return new value of PMBUS.DATA_LUT_BIT_SET
 */
__PMBUS_INLINE uint32_t PMBUS_DATA_LUT_BIT_SET__INDEX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_DATA_LUT_BIT_SET__INDEX__Msk);
    reg = (reg | (PMBUS_DATA_LUT_BIT_SET__INDEX__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_DATA_LUT_BIT_SET__INDEX__EXTRACT() extracts DATA_LUT_BIT_SET.INDEX.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.DATA_LUT_BIT_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.DATA_LUT_BIT_SET
 * @return current value of DATA_LUT_BIT_SET.INDEX
 */
__PMBUS_INLINE uint32_t PMBUS_DATA_LUT_BIT_SET__INDEX__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_DATA_LUT_BIT_SET__INDEX__Msk);
    reg = (reg >> PMBUS_DATA_LUT_BIT_SET__INDEX__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     DATA_LUT_BIT_CLR member of PMBUS_t                     */
/* -------------------------------------------------------------------------- */

/** __PMBUS_DATA_LUT_BIT_CLR__ADDRESS returns the address of member DATA_LUT_BIT_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of DATA_LUT_BIT_CLR
 */
__PMBUS_INLINE uint32_t* __PMBUS_DATA_LUT_BIT_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, DATA_LUT_BIT_CLR)));
}

/** PMBUS_DATA_LUT_BIT_CLR__SET() sets DATA_LUT_BIT_CLR to given value.
 *
 * When writing to DATA_LUT_BIT_CLR, this is mandatory to use.
 *
 * @param value new value for DATA_LUT_BIT_CLR
 */
__PMBUS_INLINE void PMBUS_DATA_LUT_BIT_CLR__SET(uint32_t value)
{
    HAL_SET32(__PMBUS_DATA_LUT_BIT_CLR__ADDRESS(), value);
}


/* ---------------------- PMBUS.DATA_LUT_BIT_CLR.INDEX ---------------------- */


#define PMBUS_DATA_LUT_BIT_CLR__INDEX__Pos                      0                                                                      /*!< Right-most bit position of INDEX in PMBUS.DATA_LUT_BIT_CLR */
#define PMBUS_DATA_LUT_BIT_CLR__INDEX__Msk                      (0x000000FFUL << PMBUS_DATA_LUT_BIT_CLR__INDEX__Pos)                   /*!< Mask for INDEX in PMBUS.DATA_LUT_BIT_CLR */
#define PMBUS_DATA_LUT_BIT_CLR__INDEX__Shift(v)                 (((v) << PMBUS_DATA_LUT_BIT_CLR__INDEX__Pos) & PMBUS_DATA_LUT_BIT_CLR__INDEX__Msk) /*!< Shift value 'v' into INDEX and mask 'v' to fit it into INDEX field */

/** PMBUS_DATA_LUT_BIT_CLR__INDEX__SET() sets DATA_LUT_BIT_CLR.INDEX to given value.
 *
 * When writing to DATA_LUT_BIT_CLR.INDEX, this is recommended to use.
 *
 * @param bf_value new value for DATA_LUT_BIT_CLR.INDEX
 */
__PMBUS_INLINE void PMBUS_DATA_LUT_BIT_CLR__INDEX__SET(uint32_t bf_value)
{
    uint32_t reg = PMBUS_DATA_LUT_BIT_CLR__INDEX__Shift((uint32_t)bf_value);
    PMBUS_DATA_LUT_BIT_CLR__SET(reg);
}


/** PMBUS_DATA_LUT_BIT_CLR__INDEX__MODIFY() modifies DATA_LUT_BIT_CLR.INDEX.
 *
 * This is recommended to use when setting more than one bitfield of PMBUS.DATA_LUT_BIT_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of PMBUS.DATA_LUT_BIT_CLR
 * @param bf_value new value for DATA_LUT_BIT_CLR.INDEX
 * @return new value of PMBUS.DATA_LUT_BIT_CLR
 */
__PMBUS_INLINE uint32_t PMBUS_DATA_LUT_BIT_CLR__INDEX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~PMBUS_DATA_LUT_BIT_CLR__INDEX__Msk);
    reg = (reg | (PMBUS_DATA_LUT_BIT_CLR__INDEX__Shift((uint32_t)bf_value)));
    return reg;
}

/** PMBUS_DATA_LUT_BIT_CLR__INDEX__EXTRACT() extracts DATA_LUT_BIT_CLR.INDEX.
 *
 * This is recommended to use when extracting more than one bitfield from PMBUS.DATA_LUT_BIT_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of PMBUS.DATA_LUT_BIT_CLR
 * @return current value of DATA_LUT_BIT_CLR.INDEX
 */
__PMBUS_INLINE uint32_t PMBUS_DATA_LUT_BIT_CLR__INDEX__EXTRACT(uint32_t reg)
{
    reg = (reg & PMBUS_DATA_LUT_BIT_CLR__INDEX__Msk);
    reg = (reg >> PMBUS_DATA_LUT_BIT_CLR__INDEX__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       STATUS_WORD member of PMBUS_t                       */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_WORD__ADDRESS returns the address of member STATUS_WORD.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_WORD array
 * @return address of STATUS_WORD
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_WORD__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_WORD)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_WORD__GET() gets STATUS_WORD's current value.
 *
 * When reading from STATUS_WORD, this is mandatory to use.
 *
 * @param ida index in STATUS_WORD array
 * @return current value of STATUS_WORD
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_WORD__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_WORD__ADDRESS(ida));
}

/* --------------------- PMBUS.STATUS_WORD.STATUS_WORD --------------------- */


#define PMBUS_STATUS_WORD__STATUS_WORD__Pos                     0                                                                      /*!< Right-most bit position of STATUS_WORD in PMBUS.STATUS_WORD */
#define PMBUS_STATUS_WORD__STATUS_WORD__Msk                     (0x0000FFFFUL << PMBUS_STATUS_WORD__STATUS_WORD__Pos)                  /*!< Mask for STATUS_WORD in PMBUS.STATUS_WORD */
#define PMBUS_STATUS_WORD__STATUS_WORD__Shift(v)                (((v) << PMBUS_STATUS_WORD__STATUS_WORD__Pos) & PMBUS_STATUS_WORD__STATUS_WORD__Msk) /*!< Shift value 'v' into STATUS_WORD and mask 'v' to fit it into STATUS_WORD field */

/** PMBUS_STATUS_WORD__STATUS_WORD__GET() gets STATUS_WORD.STATUS_WORD's current value.
 *
 * When reading from STATUS_WORD.STATUS_WORD, this is recommended to use.
 *
 * @param ida index in STATUS_WORD array
 * @return current value of STATUS_WORD.STATUS_WORD
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_WORD__STATUS_WORD__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_WORD__GET(ida);
    reg = (reg & PMBUS_STATUS_WORD__STATUS_WORD__Msk);
    reg = (reg >> PMBUS_STATUS_WORD__STATUS_WORD__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       STATUS_VOUT member of PMBUS_t                       */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_VOUT__ADDRESS returns the address of member STATUS_VOUT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_VOUT array
 * @return address of STATUS_VOUT
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_VOUT__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_VOUT)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_VOUT__SET() sets STATUS_VOUT to given value.
 *
 * When writing to STATUS_VOUT, this is mandatory to use.
 *
 * @param ida index in STATUS_VOUT array
 * @param value new value for STATUS_VOUT
 */
__PMBUS_INLINE void PMBUS_STATUS_VOUT__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_VOUT__ADDRESS(ida), value);
}

/** PMBUS_STATUS_VOUT__GET() gets STATUS_VOUT's current value.
 *
 * When reading from STATUS_VOUT, this is mandatory to use.
 *
 * @param ida index in STATUS_VOUT array
 * @return current value of STATUS_VOUT
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_VOUT__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_VOUT__ADDRESS(ida));
}

/* --------------------- PMBUS.STATUS_VOUT.STATUS_VOUT --------------------- */


#define PMBUS_STATUS_VOUT__STATUS_VOUT__Pos                     0                                                                      /*!< Right-most bit position of STATUS_VOUT in PMBUS.STATUS_VOUT */
#define PMBUS_STATUS_VOUT__STATUS_VOUT__Msk                     (0x000000FFUL << PMBUS_STATUS_VOUT__STATUS_VOUT__Pos)                  /*!< Mask for STATUS_VOUT in PMBUS.STATUS_VOUT */
#define PMBUS_STATUS_VOUT__STATUS_VOUT__Shift(v)                (((v) << PMBUS_STATUS_VOUT__STATUS_VOUT__Pos) & PMBUS_STATUS_VOUT__STATUS_VOUT__Msk) /*!< Shift value 'v' into STATUS_VOUT and mask 'v' to fit it into STATUS_VOUT field */

/** PMBUS_STATUS_VOUT__STATUS_VOUT__SET() sets STATUS_VOUT.STATUS_VOUT to given value.
 *
 * When writing to STATUS_VOUT.STATUS_VOUT, this is recommended to use.
 *
 * @param ida index in STATUS_VOUT array
 * @param bf_value new value for STATUS_VOUT.STATUS_VOUT
 */
__PMBUS_INLINE void PMBUS_STATUS_VOUT__STATUS_VOUT__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_VOUT__GET(ida);
    reg = (reg & ~PMBUS_STATUS_VOUT__STATUS_VOUT__Msk);
    reg = (reg | (PMBUS_STATUS_VOUT__STATUS_VOUT__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_VOUT__SET(ida, reg);
}

/** PMBUS_STATUS_VOUT__STATUS_VOUT__GET() gets STATUS_VOUT.STATUS_VOUT's current value.
 *
 * When reading from STATUS_VOUT.STATUS_VOUT, this is recommended to use.
 *
 * @param ida index in STATUS_VOUT array
 * @return current value of STATUS_VOUT.STATUS_VOUT
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_VOUT__STATUS_VOUT__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_VOUT__GET(ida);
    reg = (reg & PMBUS_STATUS_VOUT__STATUS_VOUT__Msk);
    reg = (reg >> PMBUS_STATUS_VOUT__STATUS_VOUT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       STATUS_IOUT member of PMBUS_t                       */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_IOUT__ADDRESS returns the address of member STATUS_IOUT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_IOUT array
 * @return address of STATUS_IOUT
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_IOUT__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_IOUT)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_IOUT__SET() sets STATUS_IOUT to given value.
 *
 * When writing to STATUS_IOUT, this is mandatory to use.
 *
 * @param ida index in STATUS_IOUT array
 * @param value new value for STATUS_IOUT
 */
__PMBUS_INLINE void PMBUS_STATUS_IOUT__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_IOUT__ADDRESS(ida), value);
}

/** PMBUS_STATUS_IOUT__GET() gets STATUS_IOUT's current value.
 *
 * When reading from STATUS_IOUT, this is mandatory to use.
 *
 * @param ida index in STATUS_IOUT array
 * @return current value of STATUS_IOUT
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_IOUT__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_IOUT__ADDRESS(ida));
}

/* --------------------- PMBUS.STATUS_IOUT.STATUS_IOUT --------------------- */


#define PMBUS_STATUS_IOUT__STATUS_IOUT__Pos                     0                                                                      /*!< Right-most bit position of STATUS_IOUT in PMBUS.STATUS_IOUT */
#define PMBUS_STATUS_IOUT__STATUS_IOUT__Msk                     (0x000000FFUL << PMBUS_STATUS_IOUT__STATUS_IOUT__Pos)                  /*!< Mask for STATUS_IOUT in PMBUS.STATUS_IOUT */
#define PMBUS_STATUS_IOUT__STATUS_IOUT__Shift(v)                (((v) << PMBUS_STATUS_IOUT__STATUS_IOUT__Pos) & PMBUS_STATUS_IOUT__STATUS_IOUT__Msk) /*!< Shift value 'v' into STATUS_IOUT and mask 'v' to fit it into STATUS_IOUT field */

/** PMBUS_STATUS_IOUT__STATUS_IOUT__SET() sets STATUS_IOUT.STATUS_IOUT to given value.
 *
 * When writing to STATUS_IOUT.STATUS_IOUT, this is recommended to use.
 *
 * @param ida index in STATUS_IOUT array
 * @param bf_value new value for STATUS_IOUT.STATUS_IOUT
 */
__PMBUS_INLINE void PMBUS_STATUS_IOUT__STATUS_IOUT__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_IOUT__GET(ida);
    reg = (reg & ~PMBUS_STATUS_IOUT__STATUS_IOUT__Msk);
    reg = (reg | (PMBUS_STATUS_IOUT__STATUS_IOUT__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_IOUT__SET(ida, reg);
}

/** PMBUS_STATUS_IOUT__STATUS_IOUT__GET() gets STATUS_IOUT.STATUS_IOUT's current value.
 *
 * When reading from STATUS_IOUT.STATUS_IOUT, this is recommended to use.
 *
 * @param ida index in STATUS_IOUT array
 * @return current value of STATUS_IOUT.STATUS_IOUT
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_IOUT__STATUS_IOUT__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_IOUT__GET(ida);
    reg = (reg & PMBUS_STATUS_IOUT__STATUS_IOUT__Msk);
    reg = (reg >> PMBUS_STATUS_IOUT__STATUS_IOUT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       STATUS_INPUT member of PMBUS_t                       */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_INPUT__ADDRESS returns the address of member STATUS_INPUT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_INPUT array
 * @return address of STATUS_INPUT
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_INPUT__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_INPUT)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_INPUT__SET() sets STATUS_INPUT to given value.
 *
 * When writing to STATUS_INPUT, this is mandatory to use.
 *
 * @param ida index in STATUS_INPUT array
 * @param value new value for STATUS_INPUT
 */
__PMBUS_INLINE void PMBUS_STATUS_INPUT__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_INPUT__ADDRESS(ida), value);
}

/** PMBUS_STATUS_INPUT__GET() gets STATUS_INPUT's current value.
 *
 * When reading from STATUS_INPUT, this is mandatory to use.
 *
 * @param ida index in STATUS_INPUT array
 * @return current value of STATUS_INPUT
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_INPUT__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_INPUT__ADDRESS(ida));
}

/* -------------------- PMBUS.STATUS_INPUT.STATUS_INPUT -------------------- */


#define PMBUS_STATUS_INPUT__STATUS_INPUT__Pos                   0                                                                      /*!< Right-most bit position of STATUS_INPUT in PMBUS.STATUS_INPUT */
#define PMBUS_STATUS_INPUT__STATUS_INPUT__Msk                   (0x000000FFUL << PMBUS_STATUS_INPUT__STATUS_INPUT__Pos)                /*!< Mask for STATUS_INPUT in PMBUS.STATUS_INPUT */
#define PMBUS_STATUS_INPUT__STATUS_INPUT__Shift(v)              (((v) << PMBUS_STATUS_INPUT__STATUS_INPUT__Pos) & PMBUS_STATUS_INPUT__STATUS_INPUT__Msk) /*!< Shift value 'v' into STATUS_INPUT and mask 'v' to fit it into STATUS_INPUT field */

/** PMBUS_STATUS_INPUT__STATUS_INPUT__SET() sets STATUS_INPUT.STATUS_INPUT to given value.
 *
 * When writing to STATUS_INPUT.STATUS_INPUT, this is recommended to use.
 *
 * @param ida index in STATUS_INPUT array
 * @param bf_value new value for STATUS_INPUT.STATUS_INPUT
 */
__PMBUS_INLINE void PMBUS_STATUS_INPUT__STATUS_INPUT__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_INPUT__GET(ida);
    reg = (reg & ~PMBUS_STATUS_INPUT__STATUS_INPUT__Msk);
    reg = (reg | (PMBUS_STATUS_INPUT__STATUS_INPUT__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_INPUT__SET(ida, reg);
}

/** PMBUS_STATUS_INPUT__STATUS_INPUT__GET() gets STATUS_INPUT.STATUS_INPUT's current value.
 *
 * When reading from STATUS_INPUT.STATUS_INPUT, this is recommended to use.
 *
 * @param ida index in STATUS_INPUT array
 * @return current value of STATUS_INPUT.STATUS_INPUT
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_INPUT__STATUS_INPUT__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_INPUT__GET(ida);
    reg = (reg & PMBUS_STATUS_INPUT__STATUS_INPUT__Msk);
    reg = (reg >> PMBUS_STATUS_INPUT__STATUS_INPUT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       STATUS_TEMP member of PMBUS_t                       */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_TEMP__ADDRESS returns the address of member STATUS_TEMP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_TEMP array
 * @return address of STATUS_TEMP
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_TEMP__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_TEMP)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_TEMP__SET() sets STATUS_TEMP to given value.
 *
 * When writing to STATUS_TEMP, this is mandatory to use.
 *
 * @param ida index in STATUS_TEMP array
 * @param value new value for STATUS_TEMP
 */
__PMBUS_INLINE void PMBUS_STATUS_TEMP__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_TEMP__ADDRESS(ida), value);
}

/** PMBUS_STATUS_TEMP__GET() gets STATUS_TEMP's current value.
 *
 * When reading from STATUS_TEMP, this is mandatory to use.
 *
 * @param ida index in STATUS_TEMP array
 * @return current value of STATUS_TEMP
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_TEMP__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_TEMP__ADDRESS(ida));
}

/* --------------------- PMBUS.STATUS_TEMP.STATUS_TEMP --------------------- */


#define PMBUS_STATUS_TEMP__STATUS_TEMP__Pos                     0                                                                      /*!< Right-most bit position of STATUS_TEMP in PMBUS.STATUS_TEMP */
#define PMBUS_STATUS_TEMP__STATUS_TEMP__Msk                     (0x000000FFUL << PMBUS_STATUS_TEMP__STATUS_TEMP__Pos)                  /*!< Mask for STATUS_TEMP in PMBUS.STATUS_TEMP */
#define PMBUS_STATUS_TEMP__STATUS_TEMP__Shift(v)                (((v) << PMBUS_STATUS_TEMP__STATUS_TEMP__Pos) & PMBUS_STATUS_TEMP__STATUS_TEMP__Msk) /*!< Shift value 'v' into STATUS_TEMP and mask 'v' to fit it into STATUS_TEMP field */

/** PMBUS_STATUS_TEMP__STATUS_TEMP__SET() sets STATUS_TEMP.STATUS_TEMP to given value.
 *
 * When writing to STATUS_TEMP.STATUS_TEMP, this is recommended to use.
 *
 * @param ida index in STATUS_TEMP array
 * @param bf_value new value for STATUS_TEMP.STATUS_TEMP
 */
__PMBUS_INLINE void PMBUS_STATUS_TEMP__STATUS_TEMP__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_TEMP__GET(ida);
    reg = (reg & ~PMBUS_STATUS_TEMP__STATUS_TEMP__Msk);
    reg = (reg | (PMBUS_STATUS_TEMP__STATUS_TEMP__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_TEMP__SET(ida, reg);
}

/** PMBUS_STATUS_TEMP__STATUS_TEMP__GET() gets STATUS_TEMP.STATUS_TEMP's current value.
 *
 * When reading from STATUS_TEMP.STATUS_TEMP, this is recommended to use.
 *
 * @param ida index in STATUS_TEMP array
 * @return current value of STATUS_TEMP.STATUS_TEMP
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_TEMP__STATUS_TEMP__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_TEMP__GET(ida);
    reg = (reg & PMBUS_STATUS_TEMP__STATUS_TEMP__Msk);
    reg = (reg >> PMBUS_STATUS_TEMP__STATUS_TEMP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        STATUS_CML member of PMBUS_t                        */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_CML__ADDRESS returns the address of member STATUS_CML.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_CML array
 * @return address of STATUS_CML
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_CML__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_CML)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_CML__SET() sets STATUS_CML to given value.
 *
 * When writing to STATUS_CML, this is mandatory to use.
 *
 * @param ida index in STATUS_CML array
 * @param value new value for STATUS_CML
 */
__PMBUS_INLINE void PMBUS_STATUS_CML__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_CML__ADDRESS(ida), value);
}

/** PMBUS_STATUS_CML__GET() gets STATUS_CML's current value.
 *
 * When reading from STATUS_CML, this is mandatory to use.
 *
 * @param ida index in STATUS_CML array
 * @return current value of STATUS_CML
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_CML__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_CML__ADDRESS(ida));
}

/* ---------------------- PMBUS.STATUS_CML.STATUS_CML ---------------------- */


#define PMBUS_STATUS_CML__STATUS_CML__Pos                       0                                                                      /*!< Right-most bit position of STATUS_CML in PMBUS.STATUS_CML */
#define PMBUS_STATUS_CML__STATUS_CML__Msk                       (0x000000FFUL << PMBUS_STATUS_CML__STATUS_CML__Pos)                    /*!< Mask for STATUS_CML in PMBUS.STATUS_CML */
#define PMBUS_STATUS_CML__STATUS_CML__Shift(v)                  (((v) << PMBUS_STATUS_CML__STATUS_CML__Pos) & PMBUS_STATUS_CML__STATUS_CML__Msk) /*!< Shift value 'v' into STATUS_CML and mask 'v' to fit it into STATUS_CML field */

/** PMBUS_STATUS_CML__STATUS_CML__SET() sets STATUS_CML.STATUS_CML to given value.
 *
 * When writing to STATUS_CML.STATUS_CML, this is recommended to use.
 *
 * @param ida index in STATUS_CML array
 * @param bf_value new value for STATUS_CML.STATUS_CML
 */
__PMBUS_INLINE void PMBUS_STATUS_CML__STATUS_CML__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_CML__GET(ida);
    reg = (reg & ~PMBUS_STATUS_CML__STATUS_CML__Msk);
    reg = (reg | (PMBUS_STATUS_CML__STATUS_CML__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_CML__SET(ida, reg);
}

/** PMBUS_STATUS_CML__STATUS_CML__GET() gets STATUS_CML.STATUS_CML's current value.
 *
 * When reading from STATUS_CML.STATUS_CML, this is recommended to use.
 *
 * @param ida index in STATUS_CML array
 * @return current value of STATUS_CML.STATUS_CML
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_CML__STATUS_CML__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_CML__GET(ida);
    reg = (reg & PMBUS_STATUS_CML__STATUS_CML__Msk);
    reg = (reg >> PMBUS_STATUS_CML__STATUS_CML__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       STATUS_OTHER member of PMBUS_t                       */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_OTHER__ADDRESS returns the address of member STATUS_OTHER.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_OTHER array
 * @return address of STATUS_OTHER
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_OTHER__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_OTHER)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_OTHER__SET() sets STATUS_OTHER to given value.
 *
 * When writing to STATUS_OTHER, this is mandatory to use.
 *
 * @param ida index in STATUS_OTHER array
 * @param value new value for STATUS_OTHER
 */
__PMBUS_INLINE void PMBUS_STATUS_OTHER__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_OTHER__ADDRESS(ida), value);
}

/** PMBUS_STATUS_OTHER__GET() gets STATUS_OTHER's current value.
 *
 * When reading from STATUS_OTHER, this is mandatory to use.
 *
 * @param ida index in STATUS_OTHER array
 * @return current value of STATUS_OTHER
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_OTHER__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_OTHER__ADDRESS(ida));
}

/* -------------------- PMBUS.STATUS_OTHER.STATUS_OTHER -------------------- */


#define PMBUS_STATUS_OTHER__STATUS_OTHER__Pos                   0                                                                      /*!< Right-most bit position of STATUS_OTHER in PMBUS.STATUS_OTHER */
#define PMBUS_STATUS_OTHER__STATUS_OTHER__Msk                   (0x000000FFUL << PMBUS_STATUS_OTHER__STATUS_OTHER__Pos)                /*!< Mask for STATUS_OTHER in PMBUS.STATUS_OTHER */
#define PMBUS_STATUS_OTHER__STATUS_OTHER__Shift(v)              (((v) << PMBUS_STATUS_OTHER__STATUS_OTHER__Pos) & PMBUS_STATUS_OTHER__STATUS_OTHER__Msk) /*!< Shift value 'v' into STATUS_OTHER and mask 'v' to fit it into STATUS_OTHER field */

/** PMBUS_STATUS_OTHER__STATUS_OTHER__SET() sets STATUS_OTHER.STATUS_OTHER to given value.
 *
 * When writing to STATUS_OTHER.STATUS_OTHER, this is recommended to use.
 *
 * @param ida index in STATUS_OTHER array
 * @param bf_value new value for STATUS_OTHER.STATUS_OTHER
 */
__PMBUS_INLINE void PMBUS_STATUS_OTHER__STATUS_OTHER__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_OTHER__GET(ida);
    reg = (reg & ~PMBUS_STATUS_OTHER__STATUS_OTHER__Msk);
    reg = (reg | (PMBUS_STATUS_OTHER__STATUS_OTHER__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_OTHER__SET(ida, reg);
}

/** PMBUS_STATUS_OTHER__STATUS_OTHER__GET() gets STATUS_OTHER.STATUS_OTHER's current value.
 *
 * When reading from STATUS_OTHER.STATUS_OTHER, this is recommended to use.
 *
 * @param ida index in STATUS_OTHER array
 * @return current value of STATUS_OTHER.STATUS_OTHER
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_OTHER__STATUS_OTHER__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_OTHER__GET(ida);
    reg = (reg & PMBUS_STATUS_OTHER__STATUS_OTHER__Msk);
    reg = (reg >> PMBUS_STATUS_OTHER__STATUS_OTHER__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        STATUS_MFR member of PMBUS_t                        */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_MFR__ADDRESS returns the address of member STATUS_MFR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_MFR array
 * @return address of STATUS_MFR
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_MFR__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_MFR)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_MFR__SET() sets STATUS_MFR to given value.
 *
 * When writing to STATUS_MFR, this is mandatory to use.
 *
 * @param ida index in STATUS_MFR array
 * @param value new value for STATUS_MFR
 */
__PMBUS_INLINE void PMBUS_STATUS_MFR__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_MFR__ADDRESS(ida), value);
}

/** PMBUS_STATUS_MFR__GET() gets STATUS_MFR's current value.
 *
 * When reading from STATUS_MFR, this is mandatory to use.
 *
 * @param ida index in STATUS_MFR array
 * @return current value of STATUS_MFR
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_MFR__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_MFR__ADDRESS(ida));
}

/* ---------------------- PMBUS.STATUS_MFR.STATUS_MFR ---------------------- */


#define PMBUS_STATUS_MFR__STATUS_MFR__Pos                       0                                                                      /*!< Right-most bit position of STATUS_MFR in PMBUS.STATUS_MFR */
#define PMBUS_STATUS_MFR__STATUS_MFR__Msk                       (0x000000FFUL << PMBUS_STATUS_MFR__STATUS_MFR__Pos)                    /*!< Mask for STATUS_MFR in PMBUS.STATUS_MFR */
#define PMBUS_STATUS_MFR__STATUS_MFR__Shift(v)                  (((v) << PMBUS_STATUS_MFR__STATUS_MFR__Pos) & PMBUS_STATUS_MFR__STATUS_MFR__Msk) /*!< Shift value 'v' into STATUS_MFR and mask 'v' to fit it into STATUS_MFR field */

/** PMBUS_STATUS_MFR__STATUS_MFR__SET() sets STATUS_MFR.STATUS_MFR to given value.
 *
 * When writing to STATUS_MFR.STATUS_MFR, this is recommended to use.
 *
 * @param ida index in STATUS_MFR array
 * @param bf_value new value for STATUS_MFR.STATUS_MFR
 */
__PMBUS_INLINE void PMBUS_STATUS_MFR__STATUS_MFR__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_MFR__GET(ida);
    reg = (reg & ~PMBUS_STATUS_MFR__STATUS_MFR__Msk);
    reg = (reg | (PMBUS_STATUS_MFR__STATUS_MFR__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_MFR__SET(ida, reg);
}

/** PMBUS_STATUS_MFR__STATUS_MFR__GET() gets STATUS_MFR.STATUS_MFR's current value.
 *
 * When reading from STATUS_MFR.STATUS_MFR, this is recommended to use.
 *
 * @param ida index in STATUS_MFR array
 * @return current value of STATUS_MFR.STATUS_MFR
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_MFR__STATUS_MFR__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_MFR__GET(ida);
    reg = (reg & PMBUS_STATUS_MFR__STATUS_MFR__Msk);
    reg = (reg >> PMBUS_STATUS_MFR__STATUS_MFR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       STATUS_FAN12 member of PMBUS_t                       */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_FAN12__ADDRESS returns the address of member STATUS_FAN12.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_FAN12 array
 * @return address of STATUS_FAN12
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_FAN12__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_FAN12)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_FAN12__SET() sets STATUS_FAN12 to given value.
 *
 * When writing to STATUS_FAN12, this is mandatory to use.
 *
 * @param ida index in STATUS_FAN12 array
 * @param value new value for STATUS_FAN12
 */
__PMBUS_INLINE void PMBUS_STATUS_FAN12__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_FAN12__ADDRESS(ida), value);
}

/** PMBUS_STATUS_FAN12__GET() gets STATUS_FAN12's current value.
 *
 * When reading from STATUS_FAN12, this is mandatory to use.
 *
 * @param ida index in STATUS_FAN12 array
 * @return current value of STATUS_FAN12
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_FAN12__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_FAN12__ADDRESS(ida));
}

/* -------------------- PMBUS.STATUS_FAN12.STATUS_FAN12 -------------------- */


#define PMBUS_STATUS_FAN12__STATUS_FAN12__Pos                   0                                                                      /*!< Right-most bit position of STATUS_FAN12 in PMBUS.STATUS_FAN12 */
#define PMBUS_STATUS_FAN12__STATUS_FAN12__Msk                   (0x000000FFUL << PMBUS_STATUS_FAN12__STATUS_FAN12__Pos)                /*!< Mask for STATUS_FAN12 in PMBUS.STATUS_FAN12 */
#define PMBUS_STATUS_FAN12__STATUS_FAN12__Shift(v)              (((v) << PMBUS_STATUS_FAN12__STATUS_FAN12__Pos) & PMBUS_STATUS_FAN12__STATUS_FAN12__Msk) /*!< Shift value 'v' into STATUS_FAN12 and mask 'v' to fit it into STATUS_FAN12 field */

/** PMBUS_STATUS_FAN12__STATUS_FAN12__SET() sets STATUS_FAN12.STATUS_FAN12 to given value.
 *
 * When writing to STATUS_FAN12.STATUS_FAN12, this is recommended to use.
 *
 * @param ida index in STATUS_FAN12 array
 * @param bf_value new value for STATUS_FAN12.STATUS_FAN12
 */
__PMBUS_INLINE void PMBUS_STATUS_FAN12__STATUS_FAN12__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_FAN12__GET(ida);
    reg = (reg & ~PMBUS_STATUS_FAN12__STATUS_FAN12__Msk);
    reg = (reg | (PMBUS_STATUS_FAN12__STATUS_FAN12__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_FAN12__SET(ida, reg);
}

/** PMBUS_STATUS_FAN12__STATUS_FAN12__GET() gets STATUS_FAN12.STATUS_FAN12's current value.
 *
 * When reading from STATUS_FAN12.STATUS_FAN12, this is recommended to use.
 *
 * @param ida index in STATUS_FAN12 array
 * @return current value of STATUS_FAN12.STATUS_FAN12
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_FAN12__STATUS_FAN12__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_FAN12__GET(ida);
    reg = (reg & PMBUS_STATUS_FAN12__STATUS_FAN12__Msk);
    reg = (reg >> PMBUS_STATUS_FAN12__STATUS_FAN12__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      STATUS_PWRGOOD member of PMBUS_t                      */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_PWRGOOD__ADDRESS returns the address of member STATUS_PWRGOOD.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_PWRGOOD array
 * @return address of STATUS_PWRGOOD
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_PWRGOOD__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_PWRGOOD)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_PWRGOOD__SET() sets STATUS_PWRGOOD to given value.
 *
 * When writing to STATUS_PWRGOOD, this is mandatory to use.
 *
 * @param ida index in STATUS_PWRGOOD array
 * @param value new value for STATUS_PWRGOOD
 */
__PMBUS_INLINE void PMBUS_STATUS_PWRGOOD__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_PWRGOOD__ADDRESS(ida), value);
}

/** PMBUS_STATUS_PWRGOOD__GET() gets STATUS_PWRGOOD's current value.
 *
 * When reading from STATUS_PWRGOOD, this is mandatory to use.
 *
 * @param ida index in STATUS_PWRGOOD array
 * @return current value of STATUS_PWRGOOD
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_PWRGOOD__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_PWRGOOD__ADDRESS(ida));
}

/* ------------------ PMBUS.STATUS_PWRGOOD.STATUS_PWRGOOD ------------------ */


#define PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__Pos               0                                                                      /*!< Right-most bit position of STATUS_PWRGOOD in PMBUS.STATUS_PWRGOOD */
#define PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__Msk               (0x00000001UL << PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__Pos)            /*!< Mask for STATUS_PWRGOOD in PMBUS.STATUS_PWRGOOD */
#define PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__Shift(v)          (((v) << PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__Pos) & PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__Msk) /*!< Shift value 'v' into STATUS_PWRGOOD and mask 'v' to fit it into STATUS_PWRGOOD field */

/** PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__SET() sets STATUS_PWRGOOD.STATUS_PWRGOOD to given value.
 *
 * When writing to STATUS_PWRGOOD.STATUS_PWRGOOD, this is recommended to use.
 *
 * @param ida index in STATUS_PWRGOOD array
 * @param bf_value new value for STATUS_PWRGOOD.STATUS_PWRGOOD
 */
__PMBUS_INLINE void PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_PWRGOOD__GET(ida);
    reg = (reg & ~PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__Msk);
    reg = (reg | (PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_PWRGOOD__SET(ida, reg);
}

/** PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__GET() gets STATUS_PWRGOOD.STATUS_PWRGOOD's current value.
 *
 * When reading from STATUS_PWRGOOD.STATUS_PWRGOOD, this is recommended to use.
 *
 * @param ida index in STATUS_PWRGOOD array
 * @return current value of STATUS_PWRGOOD.STATUS_PWRGOOD
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_PWRGOOD__GET(ida);
    reg = (reg & PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__Msk);
    reg = (reg >> PMBUS_STATUS_PWRGOOD__STATUS_PWRGOOD__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        STATUS_OFF member of PMBUS_t                        */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_OFF__ADDRESS returns the address of member STATUS_OFF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_OFF array
 * @return address of STATUS_OFF
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_OFF__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_OFF)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_OFF__SET() sets STATUS_OFF to given value.
 *
 * When writing to STATUS_OFF, this is mandatory to use.
 *
 * @param ida index in STATUS_OFF array
 * @param value new value for STATUS_OFF
 */
__PMBUS_INLINE void PMBUS_STATUS_OFF__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_OFF__ADDRESS(ida), value);
}

/** PMBUS_STATUS_OFF__GET() gets STATUS_OFF's current value.
 *
 * When reading from STATUS_OFF, this is mandatory to use.
 *
 * @param ida index in STATUS_OFF array
 * @return current value of STATUS_OFF
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_OFF__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_OFF__ADDRESS(ida));
}

/* ---------------------- PMBUS.STATUS_OFF.STATUS_OFF ---------------------- */


#define PMBUS_STATUS_OFF__STATUS_OFF__Pos                       0                                                                      /*!< Right-most bit position of STATUS_OFF in PMBUS.STATUS_OFF */
#define PMBUS_STATUS_OFF__STATUS_OFF__Msk                       (0x00000001UL << PMBUS_STATUS_OFF__STATUS_OFF__Pos)                    /*!< Mask for STATUS_OFF in PMBUS.STATUS_OFF */
#define PMBUS_STATUS_OFF__STATUS_OFF__Shift(v)                  (((v) << PMBUS_STATUS_OFF__STATUS_OFF__Pos) & PMBUS_STATUS_OFF__STATUS_OFF__Msk) /*!< Shift value 'v' into STATUS_OFF and mask 'v' to fit it into STATUS_OFF field */

/** PMBUS_STATUS_OFF__STATUS_OFF__SET() sets STATUS_OFF.STATUS_OFF to given value.
 *
 * When writing to STATUS_OFF.STATUS_OFF, this is recommended to use.
 *
 * @param ida index in STATUS_OFF array
 * @param bf_value new value for STATUS_OFF.STATUS_OFF
 */
__PMBUS_INLINE void PMBUS_STATUS_OFF__STATUS_OFF__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_OFF__GET(ida);
    reg = (reg & ~PMBUS_STATUS_OFF__STATUS_OFF__Msk);
    reg = (reg | (PMBUS_STATUS_OFF__STATUS_OFF__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_OFF__SET(ida, reg);
}

/** PMBUS_STATUS_OFF__STATUS_OFF__GET() gets STATUS_OFF.STATUS_OFF's current value.
 *
 * When reading from STATUS_OFF.STATUS_OFF, this is recommended to use.
 *
 * @param ida index in STATUS_OFF array
 * @return current value of STATUS_OFF.STATUS_OFF
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_OFF__STATUS_OFF__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_OFF__GET(ida);
    reg = (reg & PMBUS_STATUS_OFF__STATUS_OFF__Msk);
    reg = (reg >> PMBUS_STATUS_OFF__STATUS_OFF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       STATUS_BUSY member of PMBUS_t                       */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_BUSY__ADDRESS returns the address of member STATUS_BUSY.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_BUSY array
 * @return address of STATUS_BUSY
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_BUSY__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_BUSY)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_BUSY__SET() sets STATUS_BUSY to given value.
 *
 * When writing to STATUS_BUSY, this is mandatory to use.
 *
 * @param ida index in STATUS_BUSY array
 * @param value new value for STATUS_BUSY
 */
__PMBUS_INLINE void PMBUS_STATUS_BUSY__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_BUSY__ADDRESS(ida), value);
}

/** PMBUS_STATUS_BUSY__GET() gets STATUS_BUSY's current value.
 *
 * When reading from STATUS_BUSY, this is mandatory to use.
 *
 * @param ida index in STATUS_BUSY array
 * @return current value of STATUS_BUSY
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_BUSY__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_BUSY__ADDRESS(ida));
}

/* --------------------- PMBUS.STATUS_BUSY.STATUS_BUSY --------------------- */


#define PMBUS_STATUS_BUSY__STATUS_BUSY__Pos                     0                                                                      /*!< Right-most bit position of STATUS_BUSY in PMBUS.STATUS_BUSY */
#define PMBUS_STATUS_BUSY__STATUS_BUSY__Msk                     (0x00000001UL << PMBUS_STATUS_BUSY__STATUS_BUSY__Pos)                  /*!< Mask for STATUS_BUSY in PMBUS.STATUS_BUSY */
#define PMBUS_STATUS_BUSY__STATUS_BUSY__Shift(v)                (((v) << PMBUS_STATUS_BUSY__STATUS_BUSY__Pos) & PMBUS_STATUS_BUSY__STATUS_BUSY__Msk) /*!< Shift value 'v' into STATUS_BUSY and mask 'v' to fit it into STATUS_BUSY field */

/** PMBUS_STATUS_BUSY__STATUS_BUSY__SET() sets STATUS_BUSY.STATUS_BUSY to given value.
 *
 * When writing to STATUS_BUSY.STATUS_BUSY, this is recommended to use.
 *
 * @param ida index in STATUS_BUSY array
 * @param bf_value new value for STATUS_BUSY.STATUS_BUSY
 */
__PMBUS_INLINE void PMBUS_STATUS_BUSY__STATUS_BUSY__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_BUSY__GET(ida);
    reg = (reg & ~PMBUS_STATUS_BUSY__STATUS_BUSY__Msk);
    reg = (reg | (PMBUS_STATUS_BUSY__STATUS_BUSY__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_BUSY__SET(ida, reg);
}

/** PMBUS_STATUS_BUSY__STATUS_BUSY__GET() gets STATUS_BUSY.STATUS_BUSY's current value.
 *
 * When reading from STATUS_BUSY.STATUS_BUSY, this is recommended to use.
 *
 * @param ida index in STATUS_BUSY array
 * @return current value of STATUS_BUSY.STATUS_BUSY
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_BUSY__STATUS_BUSY__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_BUSY__GET(ida);
    reg = (reg & PMBUS_STATUS_BUSY__STATUS_BUSY__Msk);
    reg = (reg >> PMBUS_STATUS_BUSY__STATUS_BUSY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      STATUS_UNKNOWN member of PMBUS_t                      */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_UNKNOWN__ADDRESS returns the address of member STATUS_UNKNOWN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_UNKNOWN array
 * @return address of STATUS_UNKNOWN
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_UNKNOWN__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_UNKNOWN)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_UNKNOWN__SET() sets STATUS_UNKNOWN to given value.
 *
 * When writing to STATUS_UNKNOWN, this is mandatory to use.
 *
 * @param ida index in STATUS_UNKNOWN array
 * @param value new value for STATUS_UNKNOWN
 */
__PMBUS_INLINE void PMBUS_STATUS_UNKNOWN__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_UNKNOWN__ADDRESS(ida), value);
}

/** PMBUS_STATUS_UNKNOWN__GET() gets STATUS_UNKNOWN's current value.
 *
 * When reading from STATUS_UNKNOWN, this is mandatory to use.
 *
 * @param ida index in STATUS_UNKNOWN array
 * @return current value of STATUS_UNKNOWN
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_UNKNOWN__GET(pmbus_status_loop_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_UNKNOWN__ADDRESS(ida));
}

/* ------------------ PMBUS.STATUS_UNKNOWN.STATUS_UNKNOWN ------------------ */


#define PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__Pos               0                                                                      /*!< Right-most bit position of STATUS_UNKNOWN in PMBUS.STATUS_UNKNOWN */
#define PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__Msk               (0x00000001UL << PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__Pos)            /*!< Mask for STATUS_UNKNOWN in PMBUS.STATUS_UNKNOWN */
#define PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__Shift(v)          (((v) << PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__Pos) & PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__Msk) /*!< Shift value 'v' into STATUS_UNKNOWN and mask 'v' to fit it into STATUS_UNKNOWN field */

/** PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__SET() sets STATUS_UNKNOWN.STATUS_UNKNOWN to given value.
 *
 * When writing to STATUS_UNKNOWN.STATUS_UNKNOWN, this is recommended to use.
 *
 * @param ida index in STATUS_UNKNOWN array
 * @param bf_value new value for STATUS_UNKNOWN.STATUS_UNKNOWN
 */
__PMBUS_INLINE void PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_UNKNOWN__GET(ida);
    reg = (reg & ~PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__Msk);
    reg = (reg | (PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_UNKNOWN__SET(ida, reg);
}

/** PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__GET() gets STATUS_UNKNOWN.STATUS_UNKNOWN's current value.
 *
 * When reading from STATUS_UNKNOWN.STATUS_UNKNOWN, this is recommended to use.
 *
 * @param ida index in STATUS_UNKNOWN array
 * @return current value of STATUS_UNKNOWN.STATUS_UNKNOWN
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__GET(pmbus_status_loop_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_UNKNOWN__GET(ida);
    reg = (reg & PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__Msk);
    reg = (reg >> PMBUS_STATUS_UNKNOWN__STATUS_UNKNOWN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     STATUS_CLEAR_ALL member of PMBUS_t                     */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_CLEAR_ALL__ADDRESS returns the address of member STATUS_CLEAR_ALL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_CLEAR_ALL array
 * @return address of STATUS_CLEAR_ALL
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_CLEAR_ALL__ADDRESS(pmbus_status_loop_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_CLEAR_ALL)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_CLEAR_ALL__SET() sets STATUS_CLEAR_ALL to given value.
 *
 * When writing to STATUS_CLEAR_ALL, this is mandatory to use.
 *
 * @param ida index in STATUS_CLEAR_ALL array
 * @param value new value for STATUS_CLEAR_ALL
 */
__PMBUS_INLINE void PMBUS_STATUS_CLEAR_ALL__SET(pmbus_status_loop_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_CLEAR_ALL__ADDRESS(ida), value);
}


/* ---------------- PMBUS.STATUS_CLEAR_ALL.STATUS_CLEAR_ALL ---------------- */


#define PMBUS_STATUS_CLEAR_ALL__STATUS_CLEAR_ALL__Pos           0                                                                      /*!< Right-most bit position of STATUS_CLEAR_ALL in PMBUS.STATUS_CLEAR_ALL */
#define PMBUS_STATUS_CLEAR_ALL__STATUS_CLEAR_ALL__Msk           (0x00000001UL << PMBUS_STATUS_CLEAR_ALL__STATUS_CLEAR_ALL__Pos)        /*!< Mask for STATUS_CLEAR_ALL in PMBUS.STATUS_CLEAR_ALL */
#define PMBUS_STATUS_CLEAR_ALL__STATUS_CLEAR_ALL__Shift(v)      (((v) << PMBUS_STATUS_CLEAR_ALL__STATUS_CLEAR_ALL__Pos) & PMBUS_STATUS_CLEAR_ALL__STATUS_CLEAR_ALL__Msk) /*!< Shift value 'v' into STATUS_CLEAR_ALL and mask 'v' to fit it into STATUS_CLEAR_ALL field */

/** PMBUS_STATUS_CLEAR_ALL__STATUS_CLEAR_ALL__SET() sets STATUS_CLEAR_ALL.STATUS_CLEAR_ALL to given value.
 *
 * When writing to STATUS_CLEAR_ALL.STATUS_CLEAR_ALL, this is recommended to use.
 *
 * @param ida index in STATUS_CLEAR_ALL array
 * @param bf_value new value for STATUS_CLEAR_ALL.STATUS_CLEAR_ALL
 */
__PMBUS_INLINE void PMBUS_STATUS_CLEAR_ALL__STATUS_CLEAR_ALL__SET(pmbus_status_loop_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_CLEAR_ALL__STATUS_CLEAR_ALL__Shift((uint32_t)bf_value);
    PMBUS_STATUS_CLEAR_ALL__SET(ida, reg);
}


/* -------------------------------------------------------------------------- */
/*                     STATUS_MASK_LP0 member of PMBUS_t                     */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_MASK_LP0__ADDRESS returns the address of member STATUS_MASK_LP0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_MASK_LP0 array
 * @return address of STATUS_MASK_LP0
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_MASK_LP0__ADDRESS(pmbus_status_mask_lp0_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_MASK_LP0)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_MASK_LP0__SET() sets STATUS_MASK_LP0 to given value.
 *
 * When writing to STATUS_MASK_LP0, this is mandatory to use.
 *
 * @param ida index in STATUS_MASK_LP0 array
 * @param value new value for STATUS_MASK_LP0
 */
__PMBUS_INLINE void PMBUS_STATUS_MASK_LP0__SET(pmbus_status_mask_lp0_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_MASK_LP0__ADDRESS(ida), value);
}

/** PMBUS_STATUS_MASK_LP0__GET() gets STATUS_MASK_LP0's current value.
 *
 * When reading from STATUS_MASK_LP0, this is mandatory to use.
 *
 * @param ida index in STATUS_MASK_LP0 array
 * @return current value of STATUS_MASK_LP0
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_MASK_LP0__GET(pmbus_status_mask_lp0_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_MASK_LP0__ADDRESS(ida));
}

/* ----------------- PMBUS.STATUS_MASK_LP0.STATUS_VOUT_MASK ----------------- */


#define PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__Pos            0                                                                      /*!< Right-most bit position of STATUS_VOUT_MASK in PMBUS.STATUS_MASK_LP0 */
#define PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__Msk            (0x000000FFUL << PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__Pos)         /*!< Mask for STATUS_VOUT_MASK in PMBUS.STATUS_MASK_LP0 */
#define PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__Shift(v)       (((v) << PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__Pos) & PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__Msk) /*!< Shift value 'v' into STATUS_VOUT_MASK and mask 'v' to fit it into STATUS_VOUT_MASK field */

/** PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__SET() sets STATUS_MASK_LP0.STATUS_VOUT_MASK to given value.
 *
 * When writing to STATUS_MASK_LP0.STATUS_VOUT_MASK, this is recommended to use.
 *
 * @param ida index in STATUS_MASK_LP0 array
 * @param bf_value new value for STATUS_MASK_LP0.STATUS_VOUT_MASK
 */
__PMBUS_INLINE void PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__SET(pmbus_status_mask_lp0_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_MASK_LP0__GET(ida);
    reg = (reg & ~PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__Msk);
    reg = (reg | (PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_MASK_LP0__SET(ida, reg);
}

/** PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__GET() gets STATUS_MASK_LP0.STATUS_VOUT_MASK's current value.
 *
 * When reading from STATUS_MASK_LP0.STATUS_VOUT_MASK, this is recommended to use.
 *
 * @param ida index in STATUS_MASK_LP0 array
 * @return current value of STATUS_MASK_LP0.STATUS_VOUT_MASK
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__GET(pmbus_status_mask_lp0_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_MASK_LP0__GET(ida);
    reg = (reg & PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__Msk);
    reg = (reg >> PMBUS_STATUS_MASK_LP0__STATUS_VOUT_MASK__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     STATUS_MASK_LP1 member of PMBUS_t                     */
/* -------------------------------------------------------------------------- */

/** __PMBUS_STATUS_MASK_LP1__ADDRESS returns the address of member STATUS_MASK_LP1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in STATUS_MASK_LP1 array
 * @return address of STATUS_MASK_LP1
 */
__PMBUS_INLINE uint32_t* __PMBUS_STATUS_MASK_LP1__ADDRESS(pmbus_status_mask_lp1_idx_t ida)
{
    return (uint32_t*)((uint32_t)__PMBUS_BASE_PTR() + (uint32_t)(offsetof(PMBUS_t, STATUS_MASK_LP1)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** PMBUS_STATUS_MASK_LP1__SET() sets STATUS_MASK_LP1 to given value.
 *
 * When writing to STATUS_MASK_LP1, this is mandatory to use.
 *
 * @param ida index in STATUS_MASK_LP1 array
 * @param value new value for STATUS_MASK_LP1
 */
__PMBUS_INLINE void PMBUS_STATUS_MASK_LP1__SET(pmbus_status_mask_lp1_idx_t ida, uint32_t value)
{
    HAL_SET32(__PMBUS_STATUS_MASK_LP1__ADDRESS(ida), value);
}

/** PMBUS_STATUS_MASK_LP1__GET() gets STATUS_MASK_LP1's current value.
 *
 * When reading from STATUS_MASK_LP1, this is mandatory to use.
 *
 * @param ida index in STATUS_MASK_LP1 array
 * @return current value of STATUS_MASK_LP1
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_MASK_LP1__GET(pmbus_status_mask_lp1_idx_t ida)
{
    return HAL_GET32(__PMBUS_STATUS_MASK_LP1__ADDRESS(ida));
}

/* ----------------- PMBUS.STATUS_MASK_LP1.STATUS_IOUT_MASK ----------------- */


#define PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__Pos            0                                                                      /*!< Right-most bit position of STATUS_IOUT_MASK in PMBUS.STATUS_MASK_LP1 */
#define PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__Msk            (0x000000FFUL << PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__Pos)         /*!< Mask for STATUS_IOUT_MASK in PMBUS.STATUS_MASK_LP1 */
#define PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__Shift(v)       (((v) << PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__Pos) & PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__Msk) /*!< Shift value 'v' into STATUS_IOUT_MASK and mask 'v' to fit it into STATUS_IOUT_MASK field */

/** PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__SET() sets STATUS_MASK_LP1.STATUS_IOUT_MASK to given value.
 *
 * When writing to STATUS_MASK_LP1.STATUS_IOUT_MASK, this is recommended to use.
 *
 * @param ida index in STATUS_MASK_LP1 array
 * @param bf_value new value for STATUS_MASK_LP1.STATUS_IOUT_MASK
 */
__PMBUS_INLINE void PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__SET(pmbus_status_mask_lp1_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = PMBUS_STATUS_MASK_LP1__GET(ida);
    reg = (reg & ~PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__Msk);
    reg = (reg | (PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__Shift((uint32_t)bf_value)));
    PMBUS_STATUS_MASK_LP1__SET(ida, reg);
}

/** PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__GET() gets STATUS_MASK_LP1.STATUS_IOUT_MASK's current value.
 *
 * When reading from STATUS_MASK_LP1.STATUS_IOUT_MASK, this is recommended to use.
 *
 * @param ida index in STATUS_MASK_LP1 array
 * @return current value of STATUS_MASK_LP1.STATUS_IOUT_MASK
 */
__PMBUS_INLINE uint32_t PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__GET(pmbus_status_mask_lp1_idx_t ida)
{
    uint32_t reg = PMBUS_STATUS_MASK_LP1__GET(ida);
    reg = (reg & PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__Msk);
    reg = (reg >> PMBUS_STATUS_MASK_LP1__STATUS_IOUT_MASK__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group pmbus block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_PMBUS_H_ */
