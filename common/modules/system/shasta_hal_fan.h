/**
 * @file     shasta_hal_fan.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_FAN_H_
#define _SHASTA_HAL_FAN_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup fan
 * @{
 */

#if defined ( __CC_ARM )
#define __FAN_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __FAN_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __FAN_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __FAN_INLINE  static inline
#endif

/** register file of the fan block.
 */
typedef struct _FAN_s
{
    volatile        uint32_t        FAN_CONFIG                  ; /*!< (@0x00000000) Fan maximum current reference when operating in current mode.  When the output current exceeds fan_imax the output duty cycle will be 100%.  See fan_imin fo...(more) */
    volatile        uint32_t        FAN_DUTY                    ; /*!< (@0x00000004) Fan commanded duty cycle when operating in duty cycle mode.  Note fan_duty=0xFF overrides to 100%. Computed from PMBus command as follows: <start table> "fa...(more) */
    volatile        uint32_t        FAN_SPEED                   ; /*!< (@0x00000008) Fan speed in rotations per minute (RPM) as measured at the fan_tach_i input. PMBus command computed as follows: <start table> "if (fan_speed[11]) READ_FAN_S...(more) */
} FAN_t;


/** enumeration of implemented fan blocks
 */
typedef enum _fan_idx_e
{
    FAN1 = 0u,    //!< FAN1
    FAN2 = 1u     //!< FAN2
} fan_idx_t;

#define FAN_BASE (0x70004400u)                                                          /*!< fan base address */
#define FAN_STRIDE (0x00000400u)                                                         

/** __FAN_BASE_PTR returns the base address of the peripheral.
 *
 * @param idp index of peripheral
 * @return base address of peripheral's instance
 */
__FAN_INLINE uint32_t* __FAN_BASE_PTR(fan_idx_t idp)
{
    return (uint32_t*)(FAN_BASE + (uint32_t)((uint32_t)idp * FAN_STRIDE));
}


/* -------------------------------------------------------------------------- */
/*                         FAN_CONFIG member of FAN_t                         */
/* -------------------------------------------------------------------------- */

/** __FAN_FAN_CONFIG__ADDRESS returns the address of member FAN_CONFIG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAN_CONFIG
 */
__FAN_INLINE uint32_t* __FAN_FAN_CONFIG__ADDRESS(fan_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAN_BASE_PTR(idp) + (uint32_t)(offsetof(FAN_t, FAN_CONFIG)));
}

/** FAN_FAN_CONFIG__SET() sets FAN_CONFIG to given value.
 *
 * When writing to FAN_CONFIG, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAN_CONFIG
 */
__FAN_INLINE void FAN_FAN_CONFIG__SET(fan_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAN_FAN_CONFIG__ADDRESS(idp), value);
}

/** FAN_FAN_CONFIG__GET() gets FAN_CONFIG's current value.
 *
 * When reading from FAN_CONFIG, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_CONFIG
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__GET(fan_idx_t idp)
{
    return HAL_GET32(__FAN_FAN_CONFIG__ADDRESS(idp));
}

/* ---------------------- FAN.FAN_CONFIG.FAN_IOUT_SEL ---------------------- */

/**
<pre>
  FAN.FAN_CONFIG.FAN_IOUT_SEL:

    Fan IOUT source when operating in current mode
    <start table>
    0 "Loop 0 IOUT"
    1 "Loop 1 IOUT"
    <end table>

</pre> */

#define FAN_FAN_CONFIG__FAN_IOUT_SEL__Pos                       29                                                                     /*!< Right-most bit position of fan_iout_sel in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_IOUT_SEL__Msk                       (0x00000001UL << FAN_FAN_CONFIG__FAN_IOUT_SEL__Pos)                    /*!< Mask for fan_iout_sel in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_IOUT_SEL__Shift(v)                  (((v) << FAN_FAN_CONFIG__FAN_IOUT_SEL__Pos) & FAN_FAN_CONFIG__FAN_IOUT_SEL__Msk) /*!< Shift value 'v' into fan_iout_sel and mask 'v' to fit it into fan_iout_sel field */

/** FAN_FAN_CONFIG__FAN_IOUT_SEL__SET() sets FAN_CONFIG.FAN_IOUT_SEL to given value.
 *
 * When writing to FAN_CONFIG.FAN_IOUT_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAN_CONFIG.FAN_IOUT_SEL
 */
__FAN_INLINE void FAN_FAN_CONFIG__FAN_IOUT_SEL__SET(fan_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & ~FAN_FAN_CONFIG__FAN_IOUT_SEL__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_IOUT_SEL__Shift((uint32_t)bf_value)));
    FAN_FAN_CONFIG__SET(idp, reg);
}

/** FAN_FAN_CONFIG__FAN_IOUT_SEL__GET() gets FAN_CONFIG.FAN_IOUT_SEL's current value.
 *
 * When reading from FAN_CONFIG.FAN_IOUT_SEL, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_CONFIG.FAN_IOUT_SEL
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_IOUT_SEL__GET(fan_idx_t idp)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & FAN_FAN_CONFIG__FAN_IOUT_SEL__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_IOUT_SEL__Pos);
    return (uint32_t)reg;
}

/** FAN_FAN_CONFIG__FAN_IOUT_SEL__MODIFY() modifies FAN_CONFIG.FAN_IOUT_SEL.
 *
 * This is recommended to use when setting more than one bitfield of FAN.FAN_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @param bf_value new value for FAN_CONFIG.FAN_IOUT_SEL
 * @return new value of FAN.FAN_CONFIG
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_IOUT_SEL__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAN_FAN_CONFIG__FAN_IOUT_SEL__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_IOUT_SEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAN_FAN_CONFIG__FAN_IOUT_SEL__EXTRACT() extracts FAN_CONFIG.FAN_IOUT_SEL.
 *
 * This is recommended to use when extracting more than one bitfield from FAN.FAN_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @return current value of FAN_CONFIG.FAN_IOUT_SEL
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_IOUT_SEL__EXTRACT(uint32_t reg)
{
    reg = (reg & FAN_FAN_CONFIG__FAN_IOUT_SEL__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_IOUT_SEL__Pos);
    return (uint32_t)reg;
}

/* ------------------------ FAN.FAN_CONFIG.FAN_MODE ------------------------ */

/**
<pre>
  FAN.FAN_CONFIG.FAN_MODE:

    Fan operating mode
    <start table>
    0 "Duty Cycle Mode"
    1 "Current Mode"
    <end table>

</pre> */

#define FAN_FAN_CONFIG__FAN_MODE__Pos                           28                                                                     /*!< Right-most bit position of fan_mode in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_MODE__Msk                           (0x00000001UL << FAN_FAN_CONFIG__FAN_MODE__Pos)                        /*!< Mask for fan_mode in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_MODE__Shift(v)                      (((v) << FAN_FAN_CONFIG__FAN_MODE__Pos) & FAN_FAN_CONFIG__FAN_MODE__Msk) /*!< Shift value 'v' into fan_mode and mask 'v' to fit it into fan_mode field */

/** FAN_FAN_CONFIG__FAN_MODE__SET() sets FAN_CONFIG.FAN_MODE to given value.
 *
 * When writing to FAN_CONFIG.FAN_MODE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAN_CONFIG.FAN_MODE
 */
__FAN_INLINE void FAN_FAN_CONFIG__FAN_MODE__SET(fan_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & ~FAN_FAN_CONFIG__FAN_MODE__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_MODE__Shift((uint32_t)bf_value)));
    FAN_FAN_CONFIG__SET(idp, reg);
}

/** FAN_FAN_CONFIG__FAN_MODE__GET() gets FAN_CONFIG.FAN_MODE's current value.
 *
 * When reading from FAN_CONFIG.FAN_MODE, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_CONFIG.FAN_MODE
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_MODE__GET(fan_idx_t idp)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & FAN_FAN_CONFIG__FAN_MODE__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_MODE__Pos);
    return (uint32_t)reg;
}

/** FAN_FAN_CONFIG__FAN_MODE__MODIFY() modifies FAN_CONFIG.FAN_MODE.
 *
 * This is recommended to use when setting more than one bitfield of FAN.FAN_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @param bf_value new value for FAN_CONFIG.FAN_MODE
 * @return new value of FAN.FAN_CONFIG
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAN_FAN_CONFIG__FAN_MODE__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAN_FAN_CONFIG__FAN_MODE__EXTRACT() extracts FAN_CONFIG.FAN_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from FAN.FAN_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @return current value of FAN_CONFIG.FAN_MODE
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & FAN_FAN_CONFIG__FAN_MODE__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_MODE__Pos);
    return (uint32_t)reg;
}

/* ---------------------- FAN.FAN_CONFIG.FAN_TACH_PPR ---------------------- */

/**
<pre>
  FAN.FAN_CONFIG.FAN_TACH_PPR:

    Tachometer pulses per revolution (ppr)
    <start table_with_header>
    [1:0] "PPR"
    00 "1"
    01 "2"
    10 "3"
    11 "4"
    <end table>

</pre> */

#define FAN_FAN_CONFIG__FAN_TACH_PPR__Pos                       26                                                                     /*!< Right-most bit position of fan_tach_ppr in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_TACH_PPR__Msk                       (0x00000003UL << FAN_FAN_CONFIG__FAN_TACH_PPR__Pos)                    /*!< Mask for fan_tach_ppr in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_TACH_PPR__Shift(v)                  (((v) << FAN_FAN_CONFIG__FAN_TACH_PPR__Pos) & FAN_FAN_CONFIG__FAN_TACH_PPR__Msk) /*!< Shift value 'v' into fan_tach_ppr and mask 'v' to fit it into fan_tach_ppr field */

/** FAN_FAN_CONFIG__FAN_TACH_PPR__SET() sets FAN_CONFIG.FAN_TACH_PPR to given value.
 *
 * When writing to FAN_CONFIG.FAN_TACH_PPR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAN_CONFIG.FAN_TACH_PPR
 */
__FAN_INLINE void FAN_FAN_CONFIG__FAN_TACH_PPR__SET(fan_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & ~FAN_FAN_CONFIG__FAN_TACH_PPR__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_TACH_PPR__Shift((uint32_t)bf_value)));
    FAN_FAN_CONFIG__SET(idp, reg);
}

/** FAN_FAN_CONFIG__FAN_TACH_PPR__GET() gets FAN_CONFIG.FAN_TACH_PPR's current value.
 *
 * When reading from FAN_CONFIG.FAN_TACH_PPR, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_CONFIG.FAN_TACH_PPR
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_TACH_PPR__GET(fan_idx_t idp)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & FAN_FAN_CONFIG__FAN_TACH_PPR__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_TACH_PPR__Pos);
    return (uint32_t)reg;
}

/** FAN_FAN_CONFIG__FAN_TACH_PPR__MODIFY() modifies FAN_CONFIG.FAN_TACH_PPR.
 *
 * This is recommended to use when setting more than one bitfield of FAN.FAN_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @param bf_value new value for FAN_CONFIG.FAN_TACH_PPR
 * @return new value of FAN.FAN_CONFIG
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_TACH_PPR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAN_FAN_CONFIG__FAN_TACH_PPR__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_TACH_PPR__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAN_FAN_CONFIG__FAN_TACH_PPR__EXTRACT() extracts FAN_CONFIG.FAN_TACH_PPR.
 *
 * This is recommended to use when extracting more than one bitfield from FAN.FAN_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @return current value of FAN_CONFIG.FAN_TACH_PPR
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_TACH_PPR__EXTRACT(uint32_t reg)
{
    reg = (reg & FAN_FAN_CONFIG__FAN_TACH_PPR__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_TACH_PPR__Pos);
    return (uint32_t)reg;
}

/* ------------------------ FAN.FAN_CONFIG.FAN_FREQ ------------------------ */

/**
<pre>
  FAN.FAN_CONFIG.FAN_FREQ:

    Fan switching frequency
    <start table>
    00 25kHz
    01 50kHz
    10 100kHz
    11 200kHz
    <end table>

</pre> */

#define FAN_FAN_CONFIG__FAN_FREQ__Pos                           24                                                                     /*!< Right-most bit position of fan_freq in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_FREQ__Msk                           (0x00000003UL << FAN_FAN_CONFIG__FAN_FREQ__Pos)                        /*!< Mask for fan_freq in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_FREQ__Shift(v)                      (((v) << FAN_FAN_CONFIG__FAN_FREQ__Pos) & FAN_FAN_CONFIG__FAN_FREQ__Msk) /*!< Shift value 'v' into fan_freq and mask 'v' to fit it into fan_freq field */

/** FAN_FAN_CONFIG__FAN_FREQ__SET() sets FAN_CONFIG.FAN_FREQ to given value.
 *
 * When writing to FAN_CONFIG.FAN_FREQ, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAN_CONFIG.FAN_FREQ
 */
__FAN_INLINE void FAN_FAN_CONFIG__FAN_FREQ__SET(fan_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & ~FAN_FAN_CONFIG__FAN_FREQ__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_FREQ__Shift((uint32_t)bf_value)));
    FAN_FAN_CONFIG__SET(idp, reg);
}

/** FAN_FAN_CONFIG__FAN_FREQ__GET() gets FAN_CONFIG.FAN_FREQ's current value.
 *
 * When reading from FAN_CONFIG.FAN_FREQ, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_CONFIG.FAN_FREQ
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_FREQ__GET(fan_idx_t idp)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & FAN_FAN_CONFIG__FAN_FREQ__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_FREQ__Pos);
    return (uint32_t)reg;
}

/** FAN_FAN_CONFIG__FAN_FREQ__MODIFY() modifies FAN_CONFIG.FAN_FREQ.
 *
 * This is recommended to use when setting more than one bitfield of FAN.FAN_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @param bf_value new value for FAN_CONFIG.FAN_FREQ
 * @return new value of FAN.FAN_CONFIG
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_FREQ__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAN_FAN_CONFIG__FAN_FREQ__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_FREQ__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAN_FAN_CONFIG__FAN_FREQ__EXTRACT() extracts FAN_CONFIG.FAN_FREQ.
 *
 * This is recommended to use when extracting more than one bitfield from FAN.FAN_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @return current value of FAN_CONFIG.FAN_FREQ
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_FREQ__EXTRACT(uint32_t reg)
{
    reg = (reg & FAN_FAN_CONFIG__FAN_FREQ__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_FREQ__Pos);
    return (uint32_t)reg;
}

/* ---------------------- FAN.FAN_CONFIG.FAN_DUTY_MIN ---------------------- */

/**
<pre>
  FAN.FAN_CONFIG.FAN_DUTY_MIN:

    Fan minimum duty cycle when operating in current mode.    See fan_imin for the current mode current to duty cycle equation.
    LSB = 1/256, Range = 0 to 255/256

</pre> */

#define FAN_FAN_CONFIG__FAN_DUTY_MIN__Pos                       16                                                                     /*!< Right-most bit position of fan_duty_min in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_DUTY_MIN__Msk                       (0x000000FFUL << FAN_FAN_CONFIG__FAN_DUTY_MIN__Pos)                    /*!< Mask for fan_duty_min in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_DUTY_MIN__Shift(v)                  (((v) << FAN_FAN_CONFIG__FAN_DUTY_MIN__Pos) & FAN_FAN_CONFIG__FAN_DUTY_MIN__Msk) /*!< Shift value 'v' into fan_duty_min and mask 'v' to fit it into fan_duty_min field */

/** FAN_FAN_CONFIG__FAN_DUTY_MIN__SET() sets FAN_CONFIG.FAN_DUTY_MIN to given value.
 *
 * When writing to FAN_CONFIG.FAN_DUTY_MIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAN_CONFIG.FAN_DUTY_MIN
 */
__FAN_INLINE void FAN_FAN_CONFIG__FAN_DUTY_MIN__SET(fan_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & ~FAN_FAN_CONFIG__FAN_DUTY_MIN__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_DUTY_MIN__Shift((uint32_t)bf_value)));
    FAN_FAN_CONFIG__SET(idp, reg);
}

/** FAN_FAN_CONFIG__FAN_DUTY_MIN__GET() gets FAN_CONFIG.FAN_DUTY_MIN's current value.
 *
 * When reading from FAN_CONFIG.FAN_DUTY_MIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_CONFIG.FAN_DUTY_MIN
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_DUTY_MIN__GET(fan_idx_t idp)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & FAN_FAN_CONFIG__FAN_DUTY_MIN__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_DUTY_MIN__Pos);
    return (uint32_t)reg;
}

/** FAN_FAN_CONFIG__FAN_DUTY_MIN__MODIFY() modifies FAN_CONFIG.FAN_DUTY_MIN.
 *
 * This is recommended to use when setting more than one bitfield of FAN.FAN_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @param bf_value new value for FAN_CONFIG.FAN_DUTY_MIN
 * @return new value of FAN.FAN_CONFIG
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_DUTY_MIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAN_FAN_CONFIG__FAN_DUTY_MIN__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_DUTY_MIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAN_FAN_CONFIG__FAN_DUTY_MIN__EXTRACT() extracts FAN_CONFIG.FAN_DUTY_MIN.
 *
 * This is recommended to use when extracting more than one bitfield from FAN.FAN_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @return current value of FAN_CONFIG.FAN_DUTY_MIN
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_DUTY_MIN__EXTRACT(uint32_t reg)
{
    reg = (reg & FAN_FAN_CONFIG__FAN_DUTY_MIN__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_DUTY_MIN__Pos);
    return (uint32_t)reg;
}

/* ------------------------ FAN.FAN_CONFIG.FAN_IMIN ------------------------ */

/**
<pre>
  FAN.FAN_CONFIG.FAN_IMIN:

    Fan minimum current reference when operating in current mode.  When the output current is less than fan_imin the output duty cycle will be zero.  When the output current exceeds fan_imin the output duty cycle is given by the equation,
    <start table>
    "Duty(%) = 100 * min(1.0, max(fan_duty_min(U0.8), Iout(A) / fan_imax(A)))"
    <end table>
    LSB = 1A, Range = 0 to 255A

</pre> */

#define FAN_FAN_CONFIG__FAN_IMIN__Pos                           8                                                                      /*!< Right-most bit position of fan_imin in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_IMIN__Msk                           (0x000000FFUL << FAN_FAN_CONFIG__FAN_IMIN__Pos)                        /*!< Mask for fan_imin in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_IMIN__Shift(v)                      (((v) << FAN_FAN_CONFIG__FAN_IMIN__Pos) & FAN_FAN_CONFIG__FAN_IMIN__Msk) /*!< Shift value 'v' into fan_imin and mask 'v' to fit it into fan_imin field */

/** FAN_FAN_CONFIG__FAN_IMIN__SET() sets FAN_CONFIG.FAN_IMIN to given value.
 *
 * When writing to FAN_CONFIG.FAN_IMIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAN_CONFIG.FAN_IMIN
 */
__FAN_INLINE void FAN_FAN_CONFIG__FAN_IMIN__SET(fan_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & ~FAN_FAN_CONFIG__FAN_IMIN__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_IMIN__Shift((uint32_t)bf_value)));
    FAN_FAN_CONFIG__SET(idp, reg);
}

/** FAN_FAN_CONFIG__FAN_IMIN__GET() gets FAN_CONFIG.FAN_IMIN's current value.
 *
 * When reading from FAN_CONFIG.FAN_IMIN, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_CONFIG.FAN_IMIN
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_IMIN__GET(fan_idx_t idp)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & FAN_FAN_CONFIG__FAN_IMIN__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_IMIN__Pos);
    return (uint32_t)reg;
}

/** FAN_FAN_CONFIG__FAN_IMIN__MODIFY() modifies FAN_CONFIG.FAN_IMIN.
 *
 * This is recommended to use when setting more than one bitfield of FAN.FAN_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @param bf_value new value for FAN_CONFIG.FAN_IMIN
 * @return new value of FAN.FAN_CONFIG
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_IMIN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAN_FAN_CONFIG__FAN_IMIN__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_IMIN__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAN_FAN_CONFIG__FAN_IMIN__EXTRACT() extracts FAN_CONFIG.FAN_IMIN.
 *
 * This is recommended to use when extracting more than one bitfield from FAN.FAN_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @return current value of FAN_CONFIG.FAN_IMIN
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_IMIN__EXTRACT(uint32_t reg)
{
    reg = (reg & FAN_FAN_CONFIG__FAN_IMIN__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_IMIN__Pos);
    return (uint32_t)reg;
}

/* ------------------------ FAN.FAN_CONFIG.FAN_IMAX ------------------------ */

/**
<pre>
  FAN.FAN_CONFIG.FAN_IMAX:

    Fan maximum current reference when operating in current mode.  When the output current exceeds fan_imax the output duty cycle will be 100%.  See fan_imin for the current mode current to duty cycle equation.
    LSB = 1A, Range = 0 to 255A

</pre> */

#define FAN_FAN_CONFIG__FAN_IMAX__Pos                           0                                                                      /*!< Right-most bit position of fan_imax in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_IMAX__Msk                           (0x000000FFUL << FAN_FAN_CONFIG__FAN_IMAX__Pos)                        /*!< Mask for fan_imax in FAN.FAN_CONFIG */
#define FAN_FAN_CONFIG__FAN_IMAX__Shift(v)                      (((v) << FAN_FAN_CONFIG__FAN_IMAX__Pos) & FAN_FAN_CONFIG__FAN_IMAX__Msk) /*!< Shift value 'v' into fan_imax and mask 'v' to fit it into fan_imax field */

/** FAN_FAN_CONFIG__FAN_IMAX__SET() sets FAN_CONFIG.FAN_IMAX to given value.
 *
 * When writing to FAN_CONFIG.FAN_IMAX, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAN_CONFIG.FAN_IMAX
 */
__FAN_INLINE void FAN_FAN_CONFIG__FAN_IMAX__SET(fan_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & ~FAN_FAN_CONFIG__FAN_IMAX__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_IMAX__Shift((uint32_t)bf_value)));
    FAN_FAN_CONFIG__SET(idp, reg);
}

/** FAN_FAN_CONFIG__FAN_IMAX__GET() gets FAN_CONFIG.FAN_IMAX's current value.
 *
 * When reading from FAN_CONFIG.FAN_IMAX, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_CONFIG.FAN_IMAX
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_IMAX__GET(fan_idx_t idp)
{
    uint32_t reg = FAN_FAN_CONFIG__GET(idp);
    reg = (reg & FAN_FAN_CONFIG__FAN_IMAX__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_IMAX__Pos);
    return (uint32_t)reg;
}

/** FAN_FAN_CONFIG__FAN_IMAX__MODIFY() modifies FAN_CONFIG.FAN_IMAX.
 *
 * This is recommended to use when setting more than one bitfield of FAN.FAN_CONFIG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @param bf_value new value for FAN_CONFIG.FAN_IMAX
 * @return new value of FAN.FAN_CONFIG
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_IMAX__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAN_FAN_CONFIG__FAN_IMAX__Msk);
    reg = (reg | (FAN_FAN_CONFIG__FAN_IMAX__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAN_FAN_CONFIG__FAN_IMAX__EXTRACT() extracts FAN_CONFIG.FAN_IMAX.
 *
 * This is recommended to use when extracting more than one bitfield from FAN.FAN_CONFIG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAN.FAN_CONFIG
 * @return current value of FAN_CONFIG.FAN_IMAX
 */
__FAN_INLINE uint32_t FAN_FAN_CONFIG__FAN_IMAX__EXTRACT(uint32_t reg)
{
    reg = (reg & FAN_FAN_CONFIG__FAN_IMAX__Msk);
    reg = (reg >> FAN_FAN_CONFIG__FAN_IMAX__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          FAN_DUTY member of FAN_t                          */
/* -------------------------------------------------------------------------- */

/** __FAN_FAN_DUTY__ADDRESS returns the address of member FAN_DUTY.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAN_DUTY
 */
__FAN_INLINE uint32_t* __FAN_FAN_DUTY__ADDRESS(fan_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAN_BASE_PTR(idp) + (uint32_t)(offsetof(FAN_t, FAN_DUTY)));
}

/** FAN_FAN_DUTY__SET() sets FAN_DUTY to given value.
 *
 * When writing to FAN_DUTY, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @param value new value for FAN_DUTY
 */
__FAN_INLINE void FAN_FAN_DUTY__SET(fan_idx_t idp, uint32_t value)
{
    HAL_SET32(__FAN_FAN_DUTY__ADDRESS(idp), value);
}

/** FAN_FAN_DUTY__GET() gets FAN_DUTY's current value.
 *
 * When reading from FAN_DUTY, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_DUTY
 */
__FAN_INLINE uint32_t FAN_FAN_DUTY__GET(fan_idx_t idp)
{
    return HAL_GET32(__FAN_FAN_DUTY__ADDRESS(idp));
}

/* ------------------------- FAN.FAN_DUTY.FAN_DUTY ------------------------- */

/**
<pre>
  FAN.FAN_DUTY.FAN_DUTY:

    Fan commanded duty cycle when operating in duty cycle mode.  Note fan_duty=0xFF overrides to 100%.
    Computed from PMBus command as follows:
    <start table>
    "fan_duty(U0.8) = FAN_COMMAND(U6.2) * 256 / 400"
    <end table>
    LSB = 1/256, Range = 0 to 255/256

</pre> */

#define FAN_FAN_DUTY__FAN_DUTY__Pos                             0                                                                      /*!< Right-most bit position of fan_duty in FAN.FAN_DUTY */
#define FAN_FAN_DUTY__FAN_DUTY__Msk                             (0x000000FFUL << FAN_FAN_DUTY__FAN_DUTY__Pos)                          /*!< Mask for fan_duty in FAN.FAN_DUTY */
#define FAN_FAN_DUTY__FAN_DUTY__Shift(v)                        (((v) << FAN_FAN_DUTY__FAN_DUTY__Pos) & FAN_FAN_DUTY__FAN_DUTY__Msk)   /*!< Shift value 'v' into fan_duty and mask 'v' to fit it into fan_duty field */

/** FAN_FAN_DUTY__FAN_DUTY__SET() sets FAN_DUTY.FAN_DUTY to given value.
 *
 * When writing to FAN_DUTY.FAN_DUTY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @param bf_value new value for FAN_DUTY.FAN_DUTY
 */
__FAN_INLINE void FAN_FAN_DUTY__FAN_DUTY__SET(fan_idx_t idp, uint32_t bf_value)
{
    uint32_t reg = FAN_FAN_DUTY__GET(idp);
    reg = (reg & ~FAN_FAN_DUTY__FAN_DUTY__Msk);
    reg = (reg | (FAN_FAN_DUTY__FAN_DUTY__Shift((uint32_t)bf_value)));
    FAN_FAN_DUTY__SET(idp, reg);
}

/** FAN_FAN_DUTY__FAN_DUTY__GET() gets FAN_DUTY.FAN_DUTY's current value.
 *
 * When reading from FAN_DUTY.FAN_DUTY, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_DUTY.FAN_DUTY
 */
__FAN_INLINE uint32_t FAN_FAN_DUTY__FAN_DUTY__GET(fan_idx_t idp)
{
    uint32_t reg = FAN_FAN_DUTY__GET(idp);
    reg = (reg & FAN_FAN_DUTY__FAN_DUTY__Msk);
    reg = (reg >> FAN_FAN_DUTY__FAN_DUTY__Pos);
    return (uint32_t)reg;
}

/** FAN_FAN_DUTY__FAN_DUTY__MODIFY() modifies FAN_DUTY.FAN_DUTY.
 *
 * This is recommended to use when setting more than one bitfield of FAN.FAN_DUTY.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of FAN.FAN_DUTY
 * @param bf_value new value for FAN_DUTY.FAN_DUTY
 * @return new value of FAN.FAN_DUTY
 */
__FAN_INLINE uint32_t FAN_FAN_DUTY__FAN_DUTY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~FAN_FAN_DUTY__FAN_DUTY__Msk);
    reg = (reg | (FAN_FAN_DUTY__FAN_DUTY__Shift((uint32_t)bf_value)));
    return reg;
}

/** FAN_FAN_DUTY__FAN_DUTY__EXTRACT() extracts FAN_DUTY.FAN_DUTY.
 *
 * This is recommended to use when extracting more than one bitfield from FAN.FAN_DUTY.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAN.FAN_DUTY
 * @return current value of FAN_DUTY.FAN_DUTY
 */
__FAN_INLINE uint32_t FAN_FAN_DUTY__FAN_DUTY__EXTRACT(uint32_t reg)
{
    reg = (reg & FAN_FAN_DUTY__FAN_DUTY__Msk);
    reg = (reg >> FAN_FAN_DUTY__FAN_DUTY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         FAN_SPEED member of FAN_t                         */
/* -------------------------------------------------------------------------- */

/** __FAN_FAN_SPEED__ADDRESS returns the address of member FAN_SPEED.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param idp index of peripheral
 * @return address of FAN_SPEED
 */
__FAN_INLINE uint32_t* __FAN_FAN_SPEED__ADDRESS(fan_idx_t idp)
{
    return (uint32_t*)((uint32_t)__FAN_BASE_PTR(idp) + (uint32_t)(offsetof(FAN_t, FAN_SPEED)));
}

/** FAN_FAN_SPEED__GET() gets FAN_SPEED's current value.
 *
 * When reading from FAN_SPEED, this is mandatory to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_SPEED
 */
__FAN_INLINE uint32_t FAN_FAN_SPEED__GET(fan_idx_t idp)
{
    return HAL_GET32(__FAN_FAN_SPEED__ADDRESS(idp));
}

/* ------------------------ FAN.FAN_SPEED.FAN_SPEED ------------------------ */

/**
<pre>
  FAN.FAN_SPEED.FAN_SPEED:

    Fan speed in rotations per minute (RPM) as measured at the fan_tach_i input.
    PMBus command computed as follows:
    <start table>
    "if (fan_speed[11]) READ_FAN_SPEED = {6'd10,fan_speed[11:2]}"
    "else if (fan_speed[10]) READ_FAN_SPEED = {6'd8,fan_speed[10:1]}"
    "else READ_FAN_SPEED = {6'd6,fan_speed[9:0]}"
    <end table>
    LSB = 8 RPM, Range = 0 to 32760 RPM

</pre> */

#define FAN_FAN_SPEED__FAN_SPEED__Pos                           0                                                                      /*!< Right-most bit position of fan_speed in FAN.FAN_SPEED */
#define FAN_FAN_SPEED__FAN_SPEED__Msk                           (0x00000FFFUL << FAN_FAN_SPEED__FAN_SPEED__Pos)                        /*!< Mask for fan_speed in FAN.FAN_SPEED */
#define FAN_FAN_SPEED__FAN_SPEED__Shift(v)                      (((v) << FAN_FAN_SPEED__FAN_SPEED__Pos) & FAN_FAN_SPEED__FAN_SPEED__Msk) /*!< Shift value 'v' into fan_speed and mask 'v' to fit it into fan_speed field */

/** FAN_FAN_SPEED__FAN_SPEED__GET() gets FAN_SPEED.FAN_SPEED's current value.
 *
 * When reading from FAN_SPEED.FAN_SPEED, this is recommended to use.
 *
 * @param idp index of peripheral
 * @return current value of FAN_SPEED.FAN_SPEED
 */
__FAN_INLINE uint32_t FAN_FAN_SPEED__FAN_SPEED__GET(fan_idx_t idp)
{
    uint32_t reg = FAN_FAN_SPEED__GET(idp);
    reg = (reg & FAN_FAN_SPEED__FAN_SPEED__Msk);
    reg = (reg >> FAN_FAN_SPEED__FAN_SPEED__Pos);
    return (uint32_t)reg;
}

/** FAN_FAN_SPEED__FAN_SPEED__EXTRACT() extracts FAN_SPEED.FAN_SPEED.
 *
 * This is recommended to use when extracting more than one bitfield from FAN.FAN_SPEED.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of FAN.FAN_SPEED
 * @return current value of FAN_SPEED.FAN_SPEED
 */
__FAN_INLINE uint32_t FAN_FAN_SPEED__FAN_SPEED__EXTRACT(uint32_t reg)
{
    reg = (reg & FAN_FAN_SPEED__FAN_SPEED__Msk);
    reg = (reg >> FAN_FAN_SPEED__FAN_SPEED__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group fan block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_FAN_H_ */
