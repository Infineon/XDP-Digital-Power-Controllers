/**
 * @file     shasta_hal_analog.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_ANALOG_H_
#define _SHASTA_HAL_ANALOG_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup analog
 * @{
 */

#if defined ( __CC_ARM )
#define __ANALOG_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __ANALOG_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __ANALOG_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __ANALOG_INLINE  static inline
#endif

/** register file of the analog block.
 */
typedef struct _ANALOG_s
{
    volatile        uint32_t        VS_STEP                     ; /*!< (@0x00000000) VS0 (VSEN) ADC tracking loop integrator step size when automatic step size disabled.  Recommended setting is 1 for highest resolution. */
    volatile        uint32_t        VS0_OSP_IN                  ; /*!< (@0x00000004) VREF open sense protection current enable.  When enabled, a 50uA current is sourced to the VREF pin.  This can be used to detect higher that expected voltag...(more) */
    volatile        uint32_t        VS0_OSP_IP                  ; /*!< (@0x00000008) VSEN open sense protection current enable.  When enabled, a 50uA current is sourced to the VSEN pin.  This can be used to detect higher that expected voltag...(more) */
    volatile        uint32_t        VS1_OSP_IN                  ; /*!< (@0x0000000C) VRREF open sense protection current enable.  When enabled, a 50uA current is sourced to the VRREF pin.  This can be used to detect higher that expected volt...(more) */
    volatile        uint32_t        VS1_OSP_IP                  ; /*!< (@0x00000010) VRSEN open sense protection current enable.  When enabled, a 50uA current is sourced to the VRSEN pin.  This can be used to detect higher that expected volt...(more) */
    volatile        uint32_t        VS2_OSP_IN                  ; /*!< (@0x00000014) BVREF_BVRREF open sense protection current enable.  When enabled, a 50uA current is sourced to the BVREF_BVRREF pin.  This can be used to detect higher that...(more) */
    volatile        uint32_t        VS2_OSP_IP                  ; /*!< (@0x00000018) BVSEN_BVRSEN open sense protection current enable.  When enabled, a 50uA current is sourced to the BVSEN_BVRSEN pin.  This can be used to detect higher that...(more) */
    volatile        uint32_t        VS_INTEG_RESET              ; /*!< (@0x0000001C) Voltage Sense integrator min/max detect reset.  Setting any single bit high will reset the min/max code detectors of all 3 voltage sense ADC's.  Returning t...(more) */
} ANALOG_t;


#define ANALOG_BASE (0x70000400u)                                                          /*!< analog base address */

/** __ANALOG_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__ANALOG_INLINE uint32_t* __ANALOG_BASE_PTR(void)
{
    return (uint32_t*)(ANALOG_BASE);
}


/* -------------------------------------------------------------------------- */
/*                         VS_STEP member of ANALOG_t                         */
/* -------------------------------------------------------------------------- */

/** __ANALOG_VS_STEP__ADDRESS returns the address of member VS_STEP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VS_STEP
 */
__ANALOG_INLINE uint32_t* __ANALOG_VS_STEP__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__ANALOG_BASE_PTR() + (uint32_t)(offsetof(ANALOG_t, VS_STEP)));
}

/** ANALOG_VS_STEP__SET() sets VS_STEP to given value.
 *
 * When writing to VS_STEP, this is mandatory to use.
 *
 * @param value new value for VS_STEP
 */
__ANALOG_INLINE void ANALOG_VS_STEP__SET(uint32_t value)
{
    HAL_SET32(__ANALOG_VS_STEP__ADDRESS(), value);
}

/** ANALOG_VS_STEP__GET() gets VS_STEP's current value.
 *
 * When reading from VS_STEP, this is mandatory to use.
 *
 * @return current value of VS_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__GET(void)
{
    return HAL_GET32(__ANALOG_VS_STEP__ADDRESS());
}

/* --------------------- ANALOG.VS_STEP.ISEN2_GAIN_MODE --------------------- */

/**
<pre>
  ANALOG.VS_STEP.ISEN2_GAIN_MODE:

    ISEN2 (BISEN) gain mode select.  Defines LSB weight of ISEN2 ADC.  Also defines expected  reference voltage level on IREF2 (BIREF).
    <start table_with_header>
    [1:0] "ISEN2 LSB" "IREF2 Level"
    0 "50 uV" GND
    1 "100 uV" GND
    2 "1.45 mV" GND
    3 "1.45 mV" 1.2V
    <end table>

</pre> */

#define ANALOG_VS_STEP__ISEN2_GAIN_MODE__Pos                    14                                                                     /*!< Right-most bit position of isen2_gain_mode in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__ISEN2_GAIN_MODE__Msk                    (0x00000003UL << ANALOG_VS_STEP__ISEN2_GAIN_MODE__Pos)                 /*!< Mask for isen2_gain_mode in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__ISEN2_GAIN_MODE__Shift(v)               (((v) << ANALOG_VS_STEP__ISEN2_GAIN_MODE__Pos) & ANALOG_VS_STEP__ISEN2_GAIN_MODE__Msk) /*!< Shift value 'v' into isen2_gain_mode and mask 'v' to fit it into isen2_gain_mode field */

/** ANALOG_VS_STEP__ISEN2_GAIN_MODE__SET() sets VS_STEP.ISEN2_GAIN_MODE to given value.
 *
 * When writing to VS_STEP.ISEN2_GAIN_MODE, this is recommended to use.
 *
 * @param bf_value new value for VS_STEP.ISEN2_GAIN_MODE
 */
__ANALOG_INLINE void ANALOG_VS_STEP__ISEN2_GAIN_MODE__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ~ANALOG_VS_STEP__ISEN2_GAIN_MODE__Msk);
    reg = (reg | (ANALOG_VS_STEP__ISEN2_GAIN_MODE__Shift((uint32_t)bf_value)));
    ANALOG_VS_STEP__SET(reg);
}

/** ANALOG_VS_STEP__ISEN2_GAIN_MODE__GET() gets VS_STEP.ISEN2_GAIN_MODE's current value.
 *
 * When reading from VS_STEP.ISEN2_GAIN_MODE, this is recommended to use.
 *
 * @return current value of VS_STEP.ISEN2_GAIN_MODE
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__ISEN2_GAIN_MODE__GET(void)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ANALOG_VS_STEP__ISEN2_GAIN_MODE__Msk);
    reg = (reg >> ANALOG_VS_STEP__ISEN2_GAIN_MODE__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS_STEP__ISEN2_GAIN_MODE__MODIFY() modifies VS_STEP.ISEN2_GAIN_MODE.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS_STEP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @param bf_value new value for VS_STEP.ISEN2_GAIN_MODE
 * @return new value of ANALOG.VS_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__ISEN2_GAIN_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS_STEP__ISEN2_GAIN_MODE__Msk);
    reg = (reg | (ANALOG_VS_STEP__ISEN2_GAIN_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS_STEP__ISEN2_GAIN_MODE__EXTRACT() extracts VS_STEP.ISEN2_GAIN_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS_STEP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @return current value of VS_STEP.ISEN2_GAIN_MODE
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__ISEN2_GAIN_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS_STEP__ISEN2_GAIN_MODE__Msk);
    reg = (reg >> ANALOG_VS_STEP__ISEN2_GAIN_MODE__Pos);
    return (uint32_t)reg;
}

/* --------------------- ANALOG.VS_STEP.ISEN1_GAIN_MODE --------------------- */

/**
<pre>
  ANALOG.VS_STEP.ISEN1_GAIN_MODE:

    ISEN1 (ISEN) gain mode select.  Defines LSB weight of ISEN1 ADC.  Also defines expected  reference voltage level on IREF1 (IREF).
    <start table_with_header>
    [1:0] "ISEN1 LSB" "IREF1 Level"
    0 "50 uV" GND
    1 "100 uV" GND
    2 "1.45 mV" GND
    3 "1.45 mV" 1.2V
    <end table>

</pre> */

#define ANALOG_VS_STEP__ISEN1_GAIN_MODE__Pos                    12                                                                     /*!< Right-most bit position of isen1_gain_mode in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__ISEN1_GAIN_MODE__Msk                    (0x00000003UL << ANALOG_VS_STEP__ISEN1_GAIN_MODE__Pos)                 /*!< Mask for isen1_gain_mode in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__ISEN1_GAIN_MODE__Shift(v)               (((v) << ANALOG_VS_STEP__ISEN1_GAIN_MODE__Pos) & ANALOG_VS_STEP__ISEN1_GAIN_MODE__Msk) /*!< Shift value 'v' into isen1_gain_mode and mask 'v' to fit it into isen1_gain_mode field */

/** ANALOG_VS_STEP__ISEN1_GAIN_MODE__SET() sets VS_STEP.ISEN1_GAIN_MODE to given value.
 *
 * When writing to VS_STEP.ISEN1_GAIN_MODE, this is recommended to use.
 *
 * @param bf_value new value for VS_STEP.ISEN1_GAIN_MODE
 */
__ANALOG_INLINE void ANALOG_VS_STEP__ISEN1_GAIN_MODE__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ~ANALOG_VS_STEP__ISEN1_GAIN_MODE__Msk);
    reg = (reg | (ANALOG_VS_STEP__ISEN1_GAIN_MODE__Shift((uint32_t)bf_value)));
    ANALOG_VS_STEP__SET(reg);
}

/** ANALOG_VS_STEP__ISEN1_GAIN_MODE__GET() gets VS_STEP.ISEN1_GAIN_MODE's current value.
 *
 * When reading from VS_STEP.ISEN1_GAIN_MODE, this is recommended to use.
 *
 * @return current value of VS_STEP.ISEN1_GAIN_MODE
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__ISEN1_GAIN_MODE__GET(void)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ANALOG_VS_STEP__ISEN1_GAIN_MODE__Msk);
    reg = (reg >> ANALOG_VS_STEP__ISEN1_GAIN_MODE__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS_STEP__ISEN1_GAIN_MODE__MODIFY() modifies VS_STEP.ISEN1_GAIN_MODE.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS_STEP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @param bf_value new value for VS_STEP.ISEN1_GAIN_MODE
 * @return new value of ANALOG.VS_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__ISEN1_GAIN_MODE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS_STEP__ISEN1_GAIN_MODE__Msk);
    reg = (reg | (ANALOG_VS_STEP__ISEN1_GAIN_MODE__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS_STEP__ISEN1_GAIN_MODE__EXTRACT() extracts VS_STEP.ISEN1_GAIN_MODE.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS_STEP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @return current value of VS_STEP.ISEN1_GAIN_MODE
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__ISEN1_GAIN_MODE__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS_STEP__ISEN1_GAIN_MODE__Msk);
    reg = (reg >> ANALOG_VS_STEP__ISEN1_GAIN_MODE__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ANALOG.VS_STEP.VS2_STEP_EN ----------------------- */

/**
<pre>
  ANALOG.VS_STEP.VS2_STEP_EN:

    VS2 (BVSEN_BVRSEN) tracking loop step size control.
    <start table>
    0 "Automatic step size (Recommended for Vrect sense)"
    1 "Use vs2_step[2:0] (Recommended for Vout, Vin sense)"
    <end table>

</pre> */

#define ANALOG_VS_STEP__VS2_STEP_EN__Pos                        11                                                                     /*!< Right-most bit position of vs2_step_en in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS2_STEP_EN__Msk                        (0x00000001UL << ANALOG_VS_STEP__VS2_STEP_EN__Pos)                     /*!< Mask for vs2_step_en in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS2_STEP_EN__Shift(v)                   (((v) << ANALOG_VS_STEP__VS2_STEP_EN__Pos) & ANALOG_VS_STEP__VS2_STEP_EN__Msk) /*!< Shift value 'v' into vs2_step_en and mask 'v' to fit it into vs2_step_en field */

/** ANALOG_VS_STEP__VS2_STEP_EN__SET() sets VS_STEP.VS2_STEP_EN to given value.
 *
 * When writing to VS_STEP.VS2_STEP_EN, this is recommended to use.
 *
 * @param bf_value new value for VS_STEP.VS2_STEP_EN
 */
__ANALOG_INLINE void ANALOG_VS_STEP__VS2_STEP_EN__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ~ANALOG_VS_STEP__VS2_STEP_EN__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS2_STEP_EN__Shift((uint32_t)bf_value)));
    ANALOG_VS_STEP__SET(reg);
}

/** ANALOG_VS_STEP__VS2_STEP_EN__GET() gets VS_STEP.VS2_STEP_EN's current value.
 *
 * When reading from VS_STEP.VS2_STEP_EN, this is recommended to use.
 *
 * @return current value of VS_STEP.VS2_STEP_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS2_STEP_EN__GET(void)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ANALOG_VS_STEP__VS2_STEP_EN__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS2_STEP_EN__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS_STEP__VS2_STEP_EN__MODIFY() modifies VS_STEP.VS2_STEP_EN.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS_STEP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @param bf_value new value for VS_STEP.VS2_STEP_EN
 * @return new value of ANALOG.VS_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS2_STEP_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS_STEP__VS2_STEP_EN__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS2_STEP_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS_STEP__VS2_STEP_EN__EXTRACT() extracts VS_STEP.VS2_STEP_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS_STEP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @return current value of VS_STEP.VS2_STEP_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS2_STEP_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS_STEP__VS2_STEP_EN__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS2_STEP_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------------ ANALOG.VS_STEP.VS2_STEP ------------------------ */

/**
<pre>
  ANALOG.VS_STEP.VS2_STEP:

    VS2 (BVSEN_BVRSEN) tracking loop step size when automatic step size disabled.  Recommended setting is 1 for highest resolution.

</pre> */

#define ANALOG_VS_STEP__VS2_STEP__Pos                           8                                                                      /*!< Right-most bit position of vs2_step in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS2_STEP__Msk                           (0x00000007UL << ANALOG_VS_STEP__VS2_STEP__Pos)                        /*!< Mask for vs2_step in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS2_STEP__Shift(v)                      (((v) << ANALOG_VS_STEP__VS2_STEP__Pos) & ANALOG_VS_STEP__VS2_STEP__Msk) /*!< Shift value 'v' into vs2_step and mask 'v' to fit it into vs2_step field */

/** ANALOG_VS_STEP__VS2_STEP__SET() sets VS_STEP.VS2_STEP to given value.
 *
 * When writing to VS_STEP.VS2_STEP, this is recommended to use.
 *
 * @param bf_value new value for VS_STEP.VS2_STEP
 */
__ANALOG_INLINE void ANALOG_VS_STEP__VS2_STEP__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ~ANALOG_VS_STEP__VS2_STEP__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS2_STEP__Shift((uint32_t)bf_value)));
    ANALOG_VS_STEP__SET(reg);
}

/** ANALOG_VS_STEP__VS2_STEP__GET() gets VS_STEP.VS2_STEP's current value.
 *
 * When reading from VS_STEP.VS2_STEP, this is recommended to use.
 *
 * @return current value of VS_STEP.VS2_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS2_STEP__GET(void)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ANALOG_VS_STEP__VS2_STEP__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS2_STEP__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS_STEP__VS2_STEP__MODIFY() modifies VS_STEP.VS2_STEP.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS_STEP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @param bf_value new value for VS_STEP.VS2_STEP
 * @return new value of ANALOG.VS_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS2_STEP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS_STEP__VS2_STEP__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS2_STEP__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS_STEP__VS2_STEP__EXTRACT() extracts VS_STEP.VS2_STEP.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS_STEP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @return current value of VS_STEP.VS2_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS2_STEP__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS_STEP__VS2_STEP__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS2_STEP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ANALOG.VS_STEP.VS1_STEP_EN ----------------------- */

/**
<pre>
  ANALOG.VS_STEP.VS1_STEP_EN:

    VS1 (VRSEN) tracking loop step size control.
    <start table>
    0 "Automatic step size (Recommended for Vrect sense)"
    1 "Use vs1_step[2:0] (Recommended for Vin sense)"
    <end table>

</pre> */

#define ANALOG_VS_STEP__VS1_STEP_EN__Pos                        7                                                                      /*!< Right-most bit position of vs1_step_en in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS1_STEP_EN__Msk                        (0x00000001UL << ANALOG_VS_STEP__VS1_STEP_EN__Pos)                     /*!< Mask for vs1_step_en in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS1_STEP_EN__Shift(v)                   (((v) << ANALOG_VS_STEP__VS1_STEP_EN__Pos) & ANALOG_VS_STEP__VS1_STEP_EN__Msk) /*!< Shift value 'v' into vs1_step_en and mask 'v' to fit it into vs1_step_en field */

/** ANALOG_VS_STEP__VS1_STEP_EN__SET() sets VS_STEP.VS1_STEP_EN to given value.
 *
 * When writing to VS_STEP.VS1_STEP_EN, this is recommended to use.
 *
 * @param bf_value new value for VS_STEP.VS1_STEP_EN
 */
__ANALOG_INLINE void ANALOG_VS_STEP__VS1_STEP_EN__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ~ANALOG_VS_STEP__VS1_STEP_EN__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS1_STEP_EN__Shift((uint32_t)bf_value)));
    ANALOG_VS_STEP__SET(reg);
}

/** ANALOG_VS_STEP__VS1_STEP_EN__GET() gets VS_STEP.VS1_STEP_EN's current value.
 *
 * When reading from VS_STEP.VS1_STEP_EN, this is recommended to use.
 *
 * @return current value of VS_STEP.VS1_STEP_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS1_STEP_EN__GET(void)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ANALOG_VS_STEP__VS1_STEP_EN__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS1_STEP_EN__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS_STEP__VS1_STEP_EN__MODIFY() modifies VS_STEP.VS1_STEP_EN.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS_STEP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @param bf_value new value for VS_STEP.VS1_STEP_EN
 * @return new value of ANALOG.VS_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS1_STEP_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS_STEP__VS1_STEP_EN__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS1_STEP_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS_STEP__VS1_STEP_EN__EXTRACT() extracts VS_STEP.VS1_STEP_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS_STEP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @return current value of VS_STEP.VS1_STEP_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS1_STEP_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS_STEP__VS1_STEP_EN__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS1_STEP_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------------ ANALOG.VS_STEP.VS1_STEP ------------------------ */

/**
<pre>
  ANALOG.VS_STEP.VS1_STEP:

    VS1 (VRSEN) tracking loop step size when automatic step size disabled.  Recommended setting is 1 for highest resolution.

</pre> */

#define ANALOG_VS_STEP__VS1_STEP__Pos                           4                                                                      /*!< Right-most bit position of vs1_step in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS1_STEP__Msk                           (0x00000007UL << ANALOG_VS_STEP__VS1_STEP__Pos)                        /*!< Mask for vs1_step in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS1_STEP__Shift(v)                      (((v) << ANALOG_VS_STEP__VS1_STEP__Pos) & ANALOG_VS_STEP__VS1_STEP__Msk) /*!< Shift value 'v' into vs1_step and mask 'v' to fit it into vs1_step field */

/** ANALOG_VS_STEP__VS1_STEP__SET() sets VS_STEP.VS1_STEP to given value.
 *
 * When writing to VS_STEP.VS1_STEP, this is recommended to use.
 *
 * @param bf_value new value for VS_STEP.VS1_STEP
 */
__ANALOG_INLINE void ANALOG_VS_STEP__VS1_STEP__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ~ANALOG_VS_STEP__VS1_STEP__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS1_STEP__Shift((uint32_t)bf_value)));
    ANALOG_VS_STEP__SET(reg);
}

/** ANALOG_VS_STEP__VS1_STEP__GET() gets VS_STEP.VS1_STEP's current value.
 *
 * When reading from VS_STEP.VS1_STEP, this is recommended to use.
 *
 * @return current value of VS_STEP.VS1_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS1_STEP__GET(void)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ANALOG_VS_STEP__VS1_STEP__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS1_STEP__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS_STEP__VS1_STEP__MODIFY() modifies VS_STEP.VS1_STEP.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS_STEP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @param bf_value new value for VS_STEP.VS1_STEP
 * @return new value of ANALOG.VS_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS1_STEP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS_STEP__VS1_STEP__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS1_STEP__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS_STEP__VS1_STEP__EXTRACT() extracts VS_STEP.VS1_STEP.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS_STEP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @return current value of VS_STEP.VS1_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS1_STEP__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS_STEP__VS1_STEP__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS1_STEP__Pos);
    return (uint32_t)reg;
}

/* ----------------------- ANALOG.VS_STEP.VS0_STEP_EN ----------------------- */

/**
<pre>
  ANALOG.VS_STEP.VS0_STEP_EN:

    VS0 (VSEN) tracking loop step size control.
    <start table>
    0 "Automatic step size"
    1 "Use vs0_step[2:0] (recommended for VSEN)"
    <end table>

</pre> */

#define ANALOG_VS_STEP__VS0_STEP_EN__Pos                        3                                                                      /*!< Right-most bit position of vs0_step_en in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS0_STEP_EN__Msk                        (0x00000001UL << ANALOG_VS_STEP__VS0_STEP_EN__Pos)                     /*!< Mask for vs0_step_en in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS0_STEP_EN__Shift(v)                   (((v) << ANALOG_VS_STEP__VS0_STEP_EN__Pos) & ANALOG_VS_STEP__VS0_STEP_EN__Msk) /*!< Shift value 'v' into vs0_step_en and mask 'v' to fit it into vs0_step_en field */

/** ANALOG_VS_STEP__VS0_STEP_EN__SET() sets VS_STEP.VS0_STEP_EN to given value.
 *
 * When writing to VS_STEP.VS0_STEP_EN, this is recommended to use.
 *
 * @param bf_value new value for VS_STEP.VS0_STEP_EN
 */
__ANALOG_INLINE void ANALOG_VS_STEP__VS0_STEP_EN__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ~ANALOG_VS_STEP__VS0_STEP_EN__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS0_STEP_EN__Shift((uint32_t)bf_value)));
    ANALOG_VS_STEP__SET(reg);
}

/** ANALOG_VS_STEP__VS0_STEP_EN__GET() gets VS_STEP.VS0_STEP_EN's current value.
 *
 * When reading from VS_STEP.VS0_STEP_EN, this is recommended to use.
 *
 * @return current value of VS_STEP.VS0_STEP_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS0_STEP_EN__GET(void)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ANALOG_VS_STEP__VS0_STEP_EN__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS0_STEP_EN__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS_STEP__VS0_STEP_EN__MODIFY() modifies VS_STEP.VS0_STEP_EN.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS_STEP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @param bf_value new value for VS_STEP.VS0_STEP_EN
 * @return new value of ANALOG.VS_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS0_STEP_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS_STEP__VS0_STEP_EN__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS0_STEP_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS_STEP__VS0_STEP_EN__EXTRACT() extracts VS_STEP.VS0_STEP_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS_STEP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @return current value of VS_STEP.VS0_STEP_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS0_STEP_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS_STEP__VS0_STEP_EN__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS0_STEP_EN__Pos);
    return (uint32_t)reg;
}

/* ------------------------ ANALOG.VS_STEP.VS0_STEP ------------------------ */

/**
<pre>
  ANALOG.VS_STEP.VS0_STEP:

    VS0 (VSEN) ADC tracking loop integrator step size when automatic step size disabled.  Recommended setting is 1 for highest resolution.

</pre> */

#define ANALOG_VS_STEP__VS0_STEP__Pos                           0                                                                      /*!< Right-most bit position of vs0_step in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS0_STEP__Msk                           (0x00000007UL << ANALOG_VS_STEP__VS0_STEP__Pos)                        /*!< Mask for vs0_step in ANALOG.VS_STEP */
#define ANALOG_VS_STEP__VS0_STEP__Shift(v)                      (((v) << ANALOG_VS_STEP__VS0_STEP__Pos) & ANALOG_VS_STEP__VS0_STEP__Msk) /*!< Shift value 'v' into vs0_step and mask 'v' to fit it into vs0_step field */

/** ANALOG_VS_STEP__VS0_STEP__SET() sets VS_STEP.VS0_STEP to given value.
 *
 * When writing to VS_STEP.VS0_STEP, this is recommended to use.
 *
 * @param bf_value new value for VS_STEP.VS0_STEP
 */
__ANALOG_INLINE void ANALOG_VS_STEP__VS0_STEP__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ~ANALOG_VS_STEP__VS0_STEP__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS0_STEP__Shift((uint32_t)bf_value)));
    ANALOG_VS_STEP__SET(reg);
}

/** ANALOG_VS_STEP__VS0_STEP__GET() gets VS_STEP.VS0_STEP's current value.
 *
 * When reading from VS_STEP.VS0_STEP, this is recommended to use.
 *
 * @return current value of VS_STEP.VS0_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS0_STEP__GET(void)
{
    uint32_t reg = ANALOG_VS_STEP__GET();
    reg = (reg & ANALOG_VS_STEP__VS0_STEP__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS0_STEP__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS_STEP__VS0_STEP__MODIFY() modifies VS_STEP.VS0_STEP.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS_STEP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @param bf_value new value for VS_STEP.VS0_STEP
 * @return new value of ANALOG.VS_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS0_STEP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS_STEP__VS0_STEP__Msk);
    reg = (reg | (ANALOG_VS_STEP__VS0_STEP__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS_STEP__VS0_STEP__EXTRACT() extracts VS_STEP.VS0_STEP.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS_STEP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS_STEP
 * @return current value of VS_STEP.VS0_STEP
 */
__ANALOG_INLINE uint32_t ANALOG_VS_STEP__VS0_STEP__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS_STEP__VS0_STEP__Msk);
    reg = (reg >> ANALOG_VS_STEP__VS0_STEP__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VS0_OSP_IN member of ANALOG_t                       */
/* -------------------------------------------------------------------------- */

/** __ANALOG_VS0_OSP_IN__ADDRESS returns the address of member VS0_OSP_IN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VS0_OSP_IN
 */
__ANALOG_INLINE uint32_t* __ANALOG_VS0_OSP_IN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__ANALOG_BASE_PTR() + (uint32_t)(offsetof(ANALOG_t, VS0_OSP_IN)));
}

/** ANALOG_VS0_OSP_IN__SET() sets VS0_OSP_IN to given value.
 *
 * When writing to VS0_OSP_IN, this is mandatory to use.
 *
 * @param value new value for VS0_OSP_IN
 */
__ANALOG_INLINE void ANALOG_VS0_OSP_IN__SET(uint32_t value)
{
    HAL_SET32(__ANALOG_VS0_OSP_IN__ADDRESS(), value);
}

/** ANALOG_VS0_OSP_IN__GET() gets VS0_OSP_IN's current value.
 *
 * When reading from VS0_OSP_IN, this is mandatory to use.
 *
 * @return current value of VS0_OSP_IN
 */
__ANALOG_INLINE uint32_t ANALOG_VS0_OSP_IN__GET(void)
{
    return HAL_GET32(__ANALOG_VS0_OSP_IN__ADDRESS());
}

/* ------------------- ANALOG.VS0_OSP_IN.VS0_OSP_CUR_N_EN ------------------- */

/**
<pre>
  ANALOG.VS0_OSP_IN.VS0_OSP_CUR_N_EN:

    VREF open sense protection current enable.  When enabled, a 50uA current is sourced to the VREF pin.  This can be used to detect higher that expected voltage rise on the VREF pin prior to startup indicative of a higher than expected impedance at the VREF pin.
    <start table>
    0 "current source disabled"
    1 "current source enabled"
    <end table>

</pre> */

#define ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Pos                0                                                                      /*!< Right-most bit position of vs0_osp_cur_n_en in ANALOG.VS0_OSP_IN */
#define ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Msk                (0x00000001UL << ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Pos)             /*!< Mask for vs0_osp_cur_n_en in ANALOG.VS0_OSP_IN */
#define ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Shift(v)           (((v) << ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Pos) & ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Msk) /*!< Shift value 'v' into vs0_osp_cur_n_en and mask 'v' to fit it into vs0_osp_cur_n_en field */

/** ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__SET() sets VS0_OSP_IN.VS0_OSP_CUR_N_EN to given value.
 *
 * When writing to VS0_OSP_IN.VS0_OSP_CUR_N_EN, this is recommended to use.
 *
 * @param bf_value new value for VS0_OSP_IN.VS0_OSP_CUR_N_EN
 */
__ANALOG_INLINE void ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS0_OSP_IN__GET();
    reg = (reg & ~ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Msk);
    reg = (reg | (ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Shift((uint32_t)bf_value)));
    ANALOG_VS0_OSP_IN__SET(reg);
}

/** ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__GET() gets VS0_OSP_IN.VS0_OSP_CUR_N_EN's current value.
 *
 * When reading from VS0_OSP_IN.VS0_OSP_CUR_N_EN, this is recommended to use.
 *
 * @return current value of VS0_OSP_IN.VS0_OSP_CUR_N_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__GET(void)
{
    uint32_t reg = ANALOG_VS0_OSP_IN__GET();
    reg = (reg & ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Msk);
    reg = (reg >> ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__MODIFY() modifies VS0_OSP_IN.VS0_OSP_CUR_N_EN.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS0_OSP_IN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS0_OSP_IN
 * @param bf_value new value for VS0_OSP_IN.VS0_OSP_CUR_N_EN
 * @return new value of ANALOG.VS0_OSP_IN
 */
__ANALOG_INLINE uint32_t ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Msk);
    reg = (reg | (ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__EXTRACT() extracts VS0_OSP_IN.VS0_OSP_CUR_N_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS0_OSP_IN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS0_OSP_IN
 * @return current value of VS0_OSP_IN.VS0_OSP_CUR_N_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Msk);
    reg = (reg >> ANALOG_VS0_OSP_IN__VS0_OSP_CUR_N_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VS0_OSP_IP member of ANALOG_t                       */
/* -------------------------------------------------------------------------- */

/** __ANALOG_VS0_OSP_IP__ADDRESS returns the address of member VS0_OSP_IP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VS0_OSP_IP
 */
__ANALOG_INLINE uint32_t* __ANALOG_VS0_OSP_IP__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__ANALOG_BASE_PTR() + (uint32_t)(offsetof(ANALOG_t, VS0_OSP_IP)));
}

/** ANALOG_VS0_OSP_IP__SET() sets VS0_OSP_IP to given value.
 *
 * When writing to VS0_OSP_IP, this is mandatory to use.
 *
 * @param value new value for VS0_OSP_IP
 */
__ANALOG_INLINE void ANALOG_VS0_OSP_IP__SET(uint32_t value)
{
    HAL_SET32(__ANALOG_VS0_OSP_IP__ADDRESS(), value);
}

/** ANALOG_VS0_OSP_IP__GET() gets VS0_OSP_IP's current value.
 *
 * When reading from VS0_OSP_IP, this is mandatory to use.
 *
 * @return current value of VS0_OSP_IP
 */
__ANALOG_INLINE uint32_t ANALOG_VS0_OSP_IP__GET(void)
{
    return HAL_GET32(__ANALOG_VS0_OSP_IP__ADDRESS());
}

/* ------------------- ANALOG.VS0_OSP_IP.VS0_OSP_CUR_P_EN ------------------- */

/**
<pre>
  ANALOG.VS0_OSP_IP.VS0_OSP_CUR_P_EN:

    VSEN open sense protection current enable.  When enabled, a 50uA current is sourced to the VSEN pin.  This can be used to detect higher that expected voltage rise on the VSEN pin prior to startup indicative of a higher than expected impedance at the VSEN pin.
    <start table>
    0 "current source disabled"
    1 "current source enabled"
    <end table>

</pre> */

#define ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Pos                0                                                                      /*!< Right-most bit position of vs0_osp_cur_p_en in ANALOG.VS0_OSP_IP */
#define ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Msk                (0x00000001UL << ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Pos)             /*!< Mask for vs0_osp_cur_p_en in ANALOG.VS0_OSP_IP */
#define ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Shift(v)           (((v) << ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Pos) & ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Msk) /*!< Shift value 'v' into vs0_osp_cur_p_en and mask 'v' to fit it into vs0_osp_cur_p_en field */

/** ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__SET() sets VS0_OSP_IP.VS0_OSP_CUR_P_EN to given value.
 *
 * When writing to VS0_OSP_IP.VS0_OSP_CUR_P_EN, this is recommended to use.
 *
 * @param bf_value new value for VS0_OSP_IP.VS0_OSP_CUR_P_EN
 */
__ANALOG_INLINE void ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS0_OSP_IP__GET();
    reg = (reg & ~ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Msk);
    reg = (reg | (ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Shift((uint32_t)bf_value)));
    ANALOG_VS0_OSP_IP__SET(reg);
}

/** ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__GET() gets VS0_OSP_IP.VS0_OSP_CUR_P_EN's current value.
 *
 * When reading from VS0_OSP_IP.VS0_OSP_CUR_P_EN, this is recommended to use.
 *
 * @return current value of VS0_OSP_IP.VS0_OSP_CUR_P_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__GET(void)
{
    uint32_t reg = ANALOG_VS0_OSP_IP__GET();
    reg = (reg & ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Msk);
    reg = (reg >> ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__MODIFY() modifies VS0_OSP_IP.VS0_OSP_CUR_P_EN.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS0_OSP_IP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS0_OSP_IP
 * @param bf_value new value for VS0_OSP_IP.VS0_OSP_CUR_P_EN
 * @return new value of ANALOG.VS0_OSP_IP
 */
__ANALOG_INLINE uint32_t ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Msk);
    reg = (reg | (ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__EXTRACT() extracts VS0_OSP_IP.VS0_OSP_CUR_P_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS0_OSP_IP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS0_OSP_IP
 * @return current value of VS0_OSP_IP.VS0_OSP_CUR_P_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Msk);
    reg = (reg >> ANALOG_VS0_OSP_IP__VS0_OSP_CUR_P_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VS1_OSP_IN member of ANALOG_t                       */
/* -------------------------------------------------------------------------- */

/** __ANALOG_VS1_OSP_IN__ADDRESS returns the address of member VS1_OSP_IN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VS1_OSP_IN
 */
__ANALOG_INLINE uint32_t* __ANALOG_VS1_OSP_IN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__ANALOG_BASE_PTR() + (uint32_t)(offsetof(ANALOG_t, VS1_OSP_IN)));
}

/** ANALOG_VS1_OSP_IN__SET() sets VS1_OSP_IN to given value.
 *
 * When writing to VS1_OSP_IN, this is mandatory to use.
 *
 * @param value new value for VS1_OSP_IN
 */
__ANALOG_INLINE void ANALOG_VS1_OSP_IN__SET(uint32_t value)
{
    HAL_SET32(__ANALOG_VS1_OSP_IN__ADDRESS(), value);
}

/** ANALOG_VS1_OSP_IN__GET() gets VS1_OSP_IN's current value.
 *
 * When reading from VS1_OSP_IN, this is mandatory to use.
 *
 * @return current value of VS1_OSP_IN
 */
__ANALOG_INLINE uint32_t ANALOG_VS1_OSP_IN__GET(void)
{
    return HAL_GET32(__ANALOG_VS1_OSP_IN__ADDRESS());
}

/* ------------------- ANALOG.VS1_OSP_IN.VS1_OSP_CUR_N_EN ------------------- */

/**
<pre>
  ANALOG.VS1_OSP_IN.VS1_OSP_CUR_N_EN:

    VRREF open sense protection current enable.  When enabled, a 50uA current is sourced to the VRREF pin.  This can be used to detect higher that expected voltage rise on the VRREF pin prior to startup indicative of a higher than expected impedance at the VRREF pin.
    <start table>
    0 "current source disabled"
    1 "current source enabled"
    <end table>

</pre> */

#define ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Pos                0                                                                      /*!< Right-most bit position of vs1_osp_cur_n_en in ANALOG.VS1_OSP_IN */
#define ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Msk                (0x00000001UL << ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Pos)             /*!< Mask for vs1_osp_cur_n_en in ANALOG.VS1_OSP_IN */
#define ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Shift(v)           (((v) << ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Pos) & ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Msk) /*!< Shift value 'v' into vs1_osp_cur_n_en and mask 'v' to fit it into vs1_osp_cur_n_en field */

/** ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__SET() sets VS1_OSP_IN.VS1_OSP_CUR_N_EN to given value.
 *
 * When writing to VS1_OSP_IN.VS1_OSP_CUR_N_EN, this is recommended to use.
 *
 * @param bf_value new value for VS1_OSP_IN.VS1_OSP_CUR_N_EN
 */
__ANALOG_INLINE void ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS1_OSP_IN__GET();
    reg = (reg & ~ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Msk);
    reg = (reg | (ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Shift((uint32_t)bf_value)));
    ANALOG_VS1_OSP_IN__SET(reg);
}

/** ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__GET() gets VS1_OSP_IN.VS1_OSP_CUR_N_EN's current value.
 *
 * When reading from VS1_OSP_IN.VS1_OSP_CUR_N_EN, this is recommended to use.
 *
 * @return current value of VS1_OSP_IN.VS1_OSP_CUR_N_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__GET(void)
{
    uint32_t reg = ANALOG_VS1_OSP_IN__GET();
    reg = (reg & ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Msk);
    reg = (reg >> ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__MODIFY() modifies VS1_OSP_IN.VS1_OSP_CUR_N_EN.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS1_OSP_IN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS1_OSP_IN
 * @param bf_value new value for VS1_OSP_IN.VS1_OSP_CUR_N_EN
 * @return new value of ANALOG.VS1_OSP_IN
 */
__ANALOG_INLINE uint32_t ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Msk);
    reg = (reg | (ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__EXTRACT() extracts VS1_OSP_IN.VS1_OSP_CUR_N_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS1_OSP_IN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS1_OSP_IN
 * @return current value of VS1_OSP_IN.VS1_OSP_CUR_N_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Msk);
    reg = (reg >> ANALOG_VS1_OSP_IN__VS1_OSP_CUR_N_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VS1_OSP_IP member of ANALOG_t                       */
/* -------------------------------------------------------------------------- */

/** __ANALOG_VS1_OSP_IP__ADDRESS returns the address of member VS1_OSP_IP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VS1_OSP_IP
 */
__ANALOG_INLINE uint32_t* __ANALOG_VS1_OSP_IP__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__ANALOG_BASE_PTR() + (uint32_t)(offsetof(ANALOG_t, VS1_OSP_IP)));
}

/** ANALOG_VS1_OSP_IP__SET() sets VS1_OSP_IP to given value.
 *
 * When writing to VS1_OSP_IP, this is mandatory to use.
 *
 * @param value new value for VS1_OSP_IP
 */
__ANALOG_INLINE void ANALOG_VS1_OSP_IP__SET(uint32_t value)
{
    HAL_SET32(__ANALOG_VS1_OSP_IP__ADDRESS(), value);
}

/** ANALOG_VS1_OSP_IP__GET() gets VS1_OSP_IP's current value.
 *
 * When reading from VS1_OSP_IP, this is mandatory to use.
 *
 * @return current value of VS1_OSP_IP
 */
__ANALOG_INLINE uint32_t ANALOG_VS1_OSP_IP__GET(void)
{
    return HAL_GET32(__ANALOG_VS1_OSP_IP__ADDRESS());
}

/* ------------------- ANALOG.VS1_OSP_IP.VS1_OSP_CUR_P_EN ------------------- */

/**
<pre>
  ANALOG.VS1_OSP_IP.VS1_OSP_CUR_P_EN:

    VRSEN open sense protection current enable.  When enabled, a 50uA current is sourced to the VRSEN pin.  This can be used to detect higher that expected voltage rise on the VRSEN pin prior to startup indicative of a higher than expected impedance at the VRSEN pin.
    <start table>
    0 "current source disabled"
    1 "current source enabled"
    <end table>

</pre> */

#define ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Pos                0                                                                      /*!< Right-most bit position of vs1_osp_cur_p_en in ANALOG.VS1_OSP_IP */
#define ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Msk                (0x00000001UL << ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Pos)             /*!< Mask for vs1_osp_cur_p_en in ANALOG.VS1_OSP_IP */
#define ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Shift(v)           (((v) << ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Pos) & ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Msk) /*!< Shift value 'v' into vs1_osp_cur_p_en and mask 'v' to fit it into vs1_osp_cur_p_en field */

/** ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__SET() sets VS1_OSP_IP.VS1_OSP_CUR_P_EN to given value.
 *
 * When writing to VS1_OSP_IP.VS1_OSP_CUR_P_EN, this is recommended to use.
 *
 * @param bf_value new value for VS1_OSP_IP.VS1_OSP_CUR_P_EN
 */
__ANALOG_INLINE void ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS1_OSP_IP__GET();
    reg = (reg & ~ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Msk);
    reg = (reg | (ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Shift((uint32_t)bf_value)));
    ANALOG_VS1_OSP_IP__SET(reg);
}

/** ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__GET() gets VS1_OSP_IP.VS1_OSP_CUR_P_EN's current value.
 *
 * When reading from VS1_OSP_IP.VS1_OSP_CUR_P_EN, this is recommended to use.
 *
 * @return current value of VS1_OSP_IP.VS1_OSP_CUR_P_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__GET(void)
{
    uint32_t reg = ANALOG_VS1_OSP_IP__GET();
    reg = (reg & ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Msk);
    reg = (reg >> ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__MODIFY() modifies VS1_OSP_IP.VS1_OSP_CUR_P_EN.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS1_OSP_IP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS1_OSP_IP
 * @param bf_value new value for VS1_OSP_IP.VS1_OSP_CUR_P_EN
 * @return new value of ANALOG.VS1_OSP_IP
 */
__ANALOG_INLINE uint32_t ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Msk);
    reg = (reg | (ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__EXTRACT() extracts VS1_OSP_IP.VS1_OSP_CUR_P_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS1_OSP_IP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS1_OSP_IP
 * @return current value of VS1_OSP_IP.VS1_OSP_CUR_P_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Msk);
    reg = (reg >> ANALOG_VS1_OSP_IP__VS1_OSP_CUR_P_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VS2_OSP_IN member of ANALOG_t                       */
/* -------------------------------------------------------------------------- */

/** __ANALOG_VS2_OSP_IN__ADDRESS returns the address of member VS2_OSP_IN.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VS2_OSP_IN
 */
__ANALOG_INLINE uint32_t* __ANALOG_VS2_OSP_IN__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__ANALOG_BASE_PTR() + (uint32_t)(offsetof(ANALOG_t, VS2_OSP_IN)));
}

/** ANALOG_VS2_OSP_IN__SET() sets VS2_OSP_IN to given value.
 *
 * When writing to VS2_OSP_IN, this is mandatory to use.
 *
 * @param value new value for VS2_OSP_IN
 */
__ANALOG_INLINE void ANALOG_VS2_OSP_IN__SET(uint32_t value)
{
    HAL_SET32(__ANALOG_VS2_OSP_IN__ADDRESS(), value);
}

/** ANALOG_VS2_OSP_IN__GET() gets VS2_OSP_IN's current value.
 *
 * When reading from VS2_OSP_IN, this is mandatory to use.
 *
 * @return current value of VS2_OSP_IN
 */
__ANALOG_INLINE uint32_t ANALOG_VS2_OSP_IN__GET(void)
{
    return HAL_GET32(__ANALOG_VS2_OSP_IN__ADDRESS());
}

/* ------------------- ANALOG.VS2_OSP_IN.VS2_OSP_CUR_N_EN ------------------- */

/**
<pre>
  ANALOG.VS2_OSP_IN.VS2_OSP_CUR_N_EN:

    BVREF_BVRREF open sense protection current enable.  When enabled, a 50uA current is sourced to the BVREF_BVRREF pin.  This can be used to detect higher that expected voltage rise on the BVREF_BVRREF pin prior to startup indicative of a higher than expected impedance at the BVREF_BVRREF pin.
    <start table>
    0 "current source disabled"
    1 "current source enabled"
    <end table>

</pre> */

#define ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Pos                0                                                                      /*!< Right-most bit position of vs2_osp_cur_n_en in ANALOG.VS2_OSP_IN */
#define ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Msk                (0x00000001UL << ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Pos)             /*!< Mask for vs2_osp_cur_n_en in ANALOG.VS2_OSP_IN */
#define ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Shift(v)           (((v) << ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Pos) & ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Msk) /*!< Shift value 'v' into vs2_osp_cur_n_en and mask 'v' to fit it into vs2_osp_cur_n_en field */

/** ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__SET() sets VS2_OSP_IN.VS2_OSP_CUR_N_EN to given value.
 *
 * When writing to VS2_OSP_IN.VS2_OSP_CUR_N_EN, this is recommended to use.
 *
 * @param bf_value new value for VS2_OSP_IN.VS2_OSP_CUR_N_EN
 */
__ANALOG_INLINE void ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS2_OSP_IN__GET();
    reg = (reg & ~ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Msk);
    reg = (reg | (ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Shift((uint32_t)bf_value)));
    ANALOG_VS2_OSP_IN__SET(reg);
}

/** ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__GET() gets VS2_OSP_IN.VS2_OSP_CUR_N_EN's current value.
 *
 * When reading from VS2_OSP_IN.VS2_OSP_CUR_N_EN, this is recommended to use.
 *
 * @return current value of VS2_OSP_IN.VS2_OSP_CUR_N_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__GET(void)
{
    uint32_t reg = ANALOG_VS2_OSP_IN__GET();
    reg = (reg & ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Msk);
    reg = (reg >> ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__MODIFY() modifies VS2_OSP_IN.VS2_OSP_CUR_N_EN.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS2_OSP_IN.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS2_OSP_IN
 * @param bf_value new value for VS2_OSP_IN.VS2_OSP_CUR_N_EN
 * @return new value of ANALOG.VS2_OSP_IN
 */
__ANALOG_INLINE uint32_t ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Msk);
    reg = (reg | (ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__EXTRACT() extracts VS2_OSP_IN.VS2_OSP_CUR_N_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS2_OSP_IN.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS2_OSP_IN
 * @return current value of VS2_OSP_IN.VS2_OSP_CUR_N_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Msk);
    reg = (reg >> ANALOG_VS2_OSP_IN__VS2_OSP_CUR_N_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       VS2_OSP_IP member of ANALOG_t                       */
/* -------------------------------------------------------------------------- */

/** __ANALOG_VS2_OSP_IP__ADDRESS returns the address of member VS2_OSP_IP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VS2_OSP_IP
 */
__ANALOG_INLINE uint32_t* __ANALOG_VS2_OSP_IP__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__ANALOG_BASE_PTR() + (uint32_t)(offsetof(ANALOG_t, VS2_OSP_IP)));
}

/** ANALOG_VS2_OSP_IP__SET() sets VS2_OSP_IP to given value.
 *
 * When writing to VS2_OSP_IP, this is mandatory to use.
 *
 * @param value new value for VS2_OSP_IP
 */
__ANALOG_INLINE void ANALOG_VS2_OSP_IP__SET(uint32_t value)
{
    HAL_SET32(__ANALOG_VS2_OSP_IP__ADDRESS(), value);
}

/** ANALOG_VS2_OSP_IP__GET() gets VS2_OSP_IP's current value.
 *
 * When reading from VS2_OSP_IP, this is mandatory to use.
 *
 * @return current value of VS2_OSP_IP
 */
__ANALOG_INLINE uint32_t ANALOG_VS2_OSP_IP__GET(void)
{
    return HAL_GET32(__ANALOG_VS2_OSP_IP__ADDRESS());
}

/* ------------------- ANALOG.VS2_OSP_IP.VS2_OSP_CUR_P_EN ------------------- */

/**
<pre>
  ANALOG.VS2_OSP_IP.VS2_OSP_CUR_P_EN:

    BVSEN_BVRSEN open sense protection current enable.  When enabled, a 50uA current is sourced to the BVSEN_BVRSEN pin.  This can be used to detect higher that expected voltage rise on the BVSEN_BVRSEN pin prior to startup indicative of a higher than expected impedance at the BVSEN_BVRSEN pin.
    <start table>
    0 "current source disabled"
    1 "current source enabled"
    <end table>

</pre> */

#define ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Pos                0                                                                      /*!< Right-most bit position of vs2_osp_cur_p_en in ANALOG.VS2_OSP_IP */
#define ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Msk                (0x00000001UL << ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Pos)             /*!< Mask for vs2_osp_cur_p_en in ANALOG.VS2_OSP_IP */
#define ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Shift(v)           (((v) << ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Pos) & ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Msk) /*!< Shift value 'v' into vs2_osp_cur_p_en and mask 'v' to fit it into vs2_osp_cur_p_en field */

/** ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__SET() sets VS2_OSP_IP.VS2_OSP_CUR_P_EN to given value.
 *
 * When writing to VS2_OSP_IP.VS2_OSP_CUR_P_EN, this is recommended to use.
 *
 * @param bf_value new value for VS2_OSP_IP.VS2_OSP_CUR_P_EN
 */
__ANALOG_INLINE void ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS2_OSP_IP__GET();
    reg = (reg & ~ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Msk);
    reg = (reg | (ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Shift((uint32_t)bf_value)));
    ANALOG_VS2_OSP_IP__SET(reg);
}

/** ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__GET() gets VS2_OSP_IP.VS2_OSP_CUR_P_EN's current value.
 *
 * When reading from VS2_OSP_IP.VS2_OSP_CUR_P_EN, this is recommended to use.
 *
 * @return current value of VS2_OSP_IP.VS2_OSP_CUR_P_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__GET(void)
{
    uint32_t reg = ANALOG_VS2_OSP_IP__GET();
    reg = (reg & ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Msk);
    reg = (reg >> ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__MODIFY() modifies VS2_OSP_IP.VS2_OSP_CUR_P_EN.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS2_OSP_IP.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS2_OSP_IP
 * @param bf_value new value for VS2_OSP_IP.VS2_OSP_CUR_P_EN
 * @return new value of ANALOG.VS2_OSP_IP
 */
__ANALOG_INLINE uint32_t ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Msk);
    reg = (reg | (ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__EXTRACT() extracts VS2_OSP_IP.VS2_OSP_CUR_P_EN.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS2_OSP_IP.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS2_OSP_IP
 * @return current value of VS2_OSP_IP.VS2_OSP_CUR_P_EN
 */
__ANALOG_INLINE uint32_t ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Msk);
    reg = (reg >> ANALOG_VS2_OSP_IP__VS2_OSP_CUR_P_EN__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     VS_INTEG_RESET member of ANALOG_t                     */
/* -------------------------------------------------------------------------- */

/** __ANALOG_VS_INTEG_RESET__ADDRESS returns the address of member VS_INTEG_RESET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of VS_INTEG_RESET
 */
__ANALOG_INLINE uint32_t* __ANALOG_VS_INTEG_RESET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__ANALOG_BASE_PTR() + (uint32_t)(offsetof(ANALOG_t, VS_INTEG_RESET)));
}

/** ANALOG_VS_INTEG_RESET__SET() sets VS_INTEG_RESET to given value.
 *
 * When writing to VS_INTEG_RESET, this is mandatory to use.
 *
 * @param value new value for VS_INTEG_RESET
 */
__ANALOG_INLINE void ANALOG_VS_INTEG_RESET__SET(uint32_t value)
{
    HAL_SET32(__ANALOG_VS_INTEG_RESET__ADDRESS(), value);
}

/** ANALOG_VS_INTEG_RESET__GET() gets VS_INTEG_RESET's current value.
 *
 * When reading from VS_INTEG_RESET, this is mandatory to use.
 *
 * @return current value of VS_INTEG_RESET
 */
__ANALOG_INLINE uint32_t ANALOG_VS_INTEG_RESET__GET(void)
{
    return HAL_GET32(__ANALOG_VS_INTEG_RESET__ADDRESS());
}

/* ------------------ ANALOG.VS_INTEG_RESET.VS_INTEG_RESET ------------------ */

/**
<pre>
  ANALOG.VS_INTEG_RESET.VS_INTEG_RESET:

    Voltage Sense integrator min/max detect reset.  Setting any single bit high will reset the min/max code detectors of all 3 voltage sense ADC's.  Returning this parameter to 0 will enable the min/max code detectors.

</pre> */

#define ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Pos              0                                                                      /*!< Right-most bit position of vs_integ_reset in ANALOG.VS_INTEG_RESET */
#define ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Msk              (0x00000007UL << ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Pos)           /*!< Mask for vs_integ_reset in ANALOG.VS_INTEG_RESET */
#define ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Shift(v)         (((v) << ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Pos) & ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Msk) /*!< Shift value 'v' into vs_integ_reset and mask 'v' to fit it into vs_integ_reset field */

/** ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__SET() sets VS_INTEG_RESET.VS_INTEG_RESET to given value.
 *
 * When writing to VS_INTEG_RESET.VS_INTEG_RESET, this is recommended to use.
 *
 * @param bf_value new value for VS_INTEG_RESET.VS_INTEG_RESET
 */
__ANALOG_INLINE void ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__SET(uint32_t bf_value)
{
    uint32_t reg = ANALOG_VS_INTEG_RESET__GET();
    reg = (reg & ~ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Msk);
    reg = (reg | (ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Shift((uint32_t)bf_value)));
    ANALOG_VS_INTEG_RESET__SET(reg);
}

/** ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__GET() gets VS_INTEG_RESET.VS_INTEG_RESET's current value.
 *
 * When reading from VS_INTEG_RESET.VS_INTEG_RESET, this is recommended to use.
 *
 * @return current value of VS_INTEG_RESET.VS_INTEG_RESET
 */
__ANALOG_INLINE uint32_t ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__GET(void)
{
    uint32_t reg = ANALOG_VS_INTEG_RESET__GET();
    reg = (reg & ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Msk);
    reg = (reg >> ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Pos);
    return (uint32_t)reg;
}

/** ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__MODIFY() modifies VS_INTEG_RESET.VS_INTEG_RESET.
 *
 * This is recommended to use when setting more than one bitfield of ANALOG.VS_INTEG_RESET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of ANALOG.VS_INTEG_RESET
 * @param bf_value new value for VS_INTEG_RESET.VS_INTEG_RESET
 * @return new value of ANALOG.VS_INTEG_RESET
 */
__ANALOG_INLINE uint32_t ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Msk);
    reg = (reg | (ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Shift((uint32_t)bf_value)));
    return reg;
}

/** ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__EXTRACT() extracts VS_INTEG_RESET.VS_INTEG_RESET.
 *
 * This is recommended to use when extracting more than one bitfield from ANALOG.VS_INTEG_RESET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of ANALOG.VS_INTEG_RESET
 * @return current value of VS_INTEG_RESET.VS_INTEG_RESET
 */
__ANALOG_INLINE uint32_t ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__EXTRACT(uint32_t reg)
{
    reg = (reg & ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Msk);
    reg = (reg >> ANALOG_VS_INTEG_RESET__VS_INTEG_RESET__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group analog block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_ANALOG_H_ */
