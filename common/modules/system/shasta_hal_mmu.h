/**
 * @file     shasta_hal_mmu.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2017 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_MMU_H_
#define _SHASTA_HAL_MMU_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup mmu
 * @{
 */

#if defined ( __CC_ARM )
#define __MMU_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __MMU_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __MMU_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __MMU_INLINE  static inline
#endif

/** register file of the mmu block.
 */
typedef struct _MMU_s
{
    volatile        uint32_t        MMU_LUT_ROM[80]             ; /*!< (@0x00000000)  */
    volatile        uint8_t         REGMEMGAP0[192]             ; /*!< (@0x00000140) gap in address space */
    volatile        uint32_t        MMU_LUT_OTP[64]             ; /*!< (@0x00000200)  */
    volatile        uint8_t         REGMEMGAP1[256]             ; /*!< (@0x00000300) gap in address space */
    volatile        uint32_t        MMU_LUT_RAM1[16]            ; /*!< (@0x00000400)  */
    volatile        uint8_t         REGMEMGAP2[192]             ; /*!< (@0x00000440) gap in address space */
    volatile        uint32_t        MMU_LUT_RAM2[16]            ; /*!< (@0x00000500)  */
    volatile        uint8_t         REGMEMGAP3[192]             ; /*!< (@0x00000540) gap in address space */
    volatile        uint32_t        MMU_PER_SPACE               ; /*!< (@0x00000600)  */
    volatile        uint32_t        MMU_PER_SPACE_SET           ; /*!< (@0x00000604)  */
    volatile        uint32_t        MMU_PER_SPACE_CLR           ; /*!< (@0x00000608)  */
    volatile        uint8_t         REGMEMGAP4[244]             ; /*!< (@0x0000060C) gap in address space */
    volatile        uint32_t        MMU_CNFG                    ; /*!< (@0x00000700)  */
    volatile        uint32_t        MMU_ERR_RPT                 ; /*!< (@0x00000704)  */
    volatile        uint32_t        MMU_ERR_RPT_CLR             ; /*!< (@0x00000708)  */
} MMU_t;

/** enumeration of MMU.MMU_LUT_ROM member index
 */
/*lint -parent(uint32_t, mmu_mmu_lut_rom_idx_t) -strong(AJX)*/
typedef enum _mmu_mmu_lut_rom_idx_e
{
    mmu_mmu_lut_rom_0 = 0u,    //!< Index 0
    mmu_mmu_lut_rom_1 = 1u,    //!< Index 1
    mmu_mmu_lut_rom_2 = 2u,    //!< Index 2
    mmu_mmu_lut_rom_3 = 3u,    //!< Index 3
    mmu_mmu_lut_rom_4 = 4u,    //!< Index 4
    mmu_mmu_lut_rom_5 = 5u,    //!< Index 5
    mmu_mmu_lut_rom_6 = 6u,    //!< Index 6
    mmu_mmu_lut_rom_7 = 7u,    //!< Index 7
    mmu_mmu_lut_rom_8 = 8u,    //!< Index 8
    mmu_mmu_lut_rom_9 = 9u,    //!< Index 9
    mmu_mmu_lut_rom_10 = 10u,    //!< Index 10
    mmu_mmu_lut_rom_11 = 11u,    //!< Index 11
    mmu_mmu_lut_rom_12 = 12u,    //!< Index 12
    mmu_mmu_lut_rom_13 = 13u,    //!< Index 13
    mmu_mmu_lut_rom_14 = 14u,    //!< Index 14
    mmu_mmu_lut_rom_15 = 15u,    //!< Index 15
    mmu_mmu_lut_rom_16 = 16u,    //!< Index 16
    mmu_mmu_lut_rom_17 = 17u,    //!< Index 17
    mmu_mmu_lut_rom_18 = 18u,    //!< Index 18
    mmu_mmu_lut_rom_19 = 19u,    //!< Index 19
    mmu_mmu_lut_rom_20 = 20u,    //!< Index 20
    mmu_mmu_lut_rom_21 = 21u,    //!< Index 21
    mmu_mmu_lut_rom_22 = 22u,    //!< Index 22
    mmu_mmu_lut_rom_23 = 23u,    //!< Index 23
    mmu_mmu_lut_rom_24 = 24u,    //!< Index 24
    mmu_mmu_lut_rom_25 = 25u,    //!< Index 25
    mmu_mmu_lut_rom_26 = 26u,    //!< Index 26
    mmu_mmu_lut_rom_27 = 27u,    //!< Index 27
    mmu_mmu_lut_rom_28 = 28u,    //!< Index 28
    mmu_mmu_lut_rom_29 = 29u,    //!< Index 29
    mmu_mmu_lut_rom_30 = 30u,    //!< Index 30
    mmu_mmu_lut_rom_31 = 31u,    //!< Index 31
    mmu_mmu_lut_rom_32 = 32u,    //!< Index 32
    mmu_mmu_lut_rom_33 = 33u,    //!< Index 33
    mmu_mmu_lut_rom_34 = 34u,    //!< Index 34
    mmu_mmu_lut_rom_35 = 35u,    //!< Index 35
    mmu_mmu_lut_rom_36 = 36u,    //!< Index 36
    mmu_mmu_lut_rom_37 = 37u,    //!< Index 37
    mmu_mmu_lut_rom_38 = 38u,    //!< Index 38
    mmu_mmu_lut_rom_39 = 39u,    //!< Index 39
    mmu_mmu_lut_rom_40 = 40u,    //!< Index 40
    mmu_mmu_lut_rom_41 = 41u,    //!< Index 41
    mmu_mmu_lut_rom_42 = 42u,    //!< Index 42
    mmu_mmu_lut_rom_43 = 43u,    //!< Index 43
    mmu_mmu_lut_rom_44 = 44u,    //!< Index 44
    mmu_mmu_lut_rom_45 = 45u,    //!< Index 45
    mmu_mmu_lut_rom_46 = 46u,    //!< Index 46
    mmu_mmu_lut_rom_47 = 47u,    //!< Index 47
    mmu_mmu_lut_rom_48 = 48u,    //!< Index 48
    mmu_mmu_lut_rom_49 = 49u,    //!< Index 49
    mmu_mmu_lut_rom_50 = 50u,    //!< Index 50
    mmu_mmu_lut_rom_51 = 51u,    //!< Index 51
    mmu_mmu_lut_rom_52 = 52u,    //!< Index 52
    mmu_mmu_lut_rom_53 = 53u,    //!< Index 53
    mmu_mmu_lut_rom_54 = 54u,    //!< Index 54
    mmu_mmu_lut_rom_55 = 55u,    //!< Index 55
    mmu_mmu_lut_rom_56 = 56u,    //!< Index 56
    mmu_mmu_lut_rom_57 = 57u,    //!< Index 57
    mmu_mmu_lut_rom_58 = 58u,    //!< Index 58
    mmu_mmu_lut_rom_59 = 59u,    //!< Index 59
    mmu_mmu_lut_rom_60 = 60u,    //!< Index 60
    mmu_mmu_lut_rom_61 = 61u,    //!< Index 61
    mmu_mmu_lut_rom_62 = 62u,    //!< Index 62
    mmu_mmu_lut_rom_63 = 63u,    //!< Index 63
    mmu_mmu_lut_rom_64 = 64u,    //!< Index 64
    mmu_mmu_lut_rom_65 = 65u,    //!< Index 65
    mmu_mmu_lut_rom_66 = 66u,    //!< Index 66
    mmu_mmu_lut_rom_67 = 67u,    //!< Index 67
    mmu_mmu_lut_rom_68 = 68u,    //!< Index 68
    mmu_mmu_lut_rom_69 = 69u,    //!< Index 69
    mmu_mmu_lut_rom_70 = 70u,    //!< Index 70
    mmu_mmu_lut_rom_71 = 71u,    //!< Index 71
    mmu_mmu_lut_rom_72 = 72u,    //!< Index 72
    mmu_mmu_lut_rom_73 = 73u,    //!< Index 73
    mmu_mmu_lut_rom_74 = 74u,    //!< Index 74
    mmu_mmu_lut_rom_75 = 75u,    //!< Index 75
    mmu_mmu_lut_rom_76 = 76u,    //!< Index 76
    mmu_mmu_lut_rom_77 = 77u,    //!< Index 77
    mmu_mmu_lut_rom_78 = 78u,    //!< Index 78
    mmu_mmu_lut_rom_79 = 79u     //!< Index 79
} mmu_mmu_lut_rom_idx_t;

/** enumeration of MMU.MMU_LUT_OTP member index
 */
/*lint -parent(uint32_t, mmu_mmu_lut_otp_idx_t) -strong(AJX)*/
typedef enum _mmu_mmu_lut_otp_idx_e
{
    mmu_mmu_lut_otp_0 = 0u,    //!< Index 0
    mmu_mmu_lut_otp_1 = 1u,    //!< Index 1
    mmu_mmu_lut_otp_2 = 2u,    //!< Index 2
    mmu_mmu_lut_otp_3 = 3u,    //!< Index 3
    mmu_mmu_lut_otp_4 = 4u,    //!< Index 4
    mmu_mmu_lut_otp_5 = 5u,    //!< Index 5
    mmu_mmu_lut_otp_6 = 6u,    //!< Index 6
    mmu_mmu_lut_otp_7 = 7u,    //!< Index 7
    mmu_mmu_lut_otp_8 = 8u,    //!< Index 8
    mmu_mmu_lut_otp_9 = 9u,    //!< Index 9
    mmu_mmu_lut_otp_10 = 10u,    //!< Index 10
    mmu_mmu_lut_otp_11 = 11u,    //!< Index 11
    mmu_mmu_lut_otp_12 = 12u,    //!< Index 12
    mmu_mmu_lut_otp_13 = 13u,    //!< Index 13
    mmu_mmu_lut_otp_14 = 14u,    //!< Index 14
    mmu_mmu_lut_otp_15 = 15u,    //!< Index 15
    mmu_mmu_lut_otp_16 = 16u,    //!< Index 16
    mmu_mmu_lut_otp_17 = 17u,    //!< Index 17
    mmu_mmu_lut_otp_18 = 18u,    //!< Index 18
    mmu_mmu_lut_otp_19 = 19u,    //!< Index 19
    mmu_mmu_lut_otp_20 = 20u,    //!< Index 20
    mmu_mmu_lut_otp_21 = 21u,    //!< Index 21
    mmu_mmu_lut_otp_22 = 22u,    //!< Index 22
    mmu_mmu_lut_otp_23 = 23u,    //!< Index 23
    mmu_mmu_lut_otp_24 = 24u,    //!< Index 24
    mmu_mmu_lut_otp_25 = 25u,    //!< Index 25
    mmu_mmu_lut_otp_26 = 26u,    //!< Index 26
    mmu_mmu_lut_otp_27 = 27u,    //!< Index 27
    mmu_mmu_lut_otp_28 = 28u,    //!< Index 28
    mmu_mmu_lut_otp_29 = 29u,    //!< Index 29
    mmu_mmu_lut_otp_30 = 30u,    //!< Index 30
    mmu_mmu_lut_otp_31 = 31u,    //!< Index 31
    mmu_mmu_lut_otp_32 = 32u,    //!< Index 32
    mmu_mmu_lut_otp_33 = 33u,    //!< Index 33
    mmu_mmu_lut_otp_34 = 34u,    //!< Index 34
    mmu_mmu_lut_otp_35 = 35u,    //!< Index 35
    mmu_mmu_lut_otp_36 = 36u,    //!< Index 36
    mmu_mmu_lut_otp_37 = 37u,    //!< Index 37
    mmu_mmu_lut_otp_38 = 38u,    //!< Index 38
    mmu_mmu_lut_otp_39 = 39u,    //!< Index 39
    mmu_mmu_lut_otp_40 = 40u,    //!< Index 40
    mmu_mmu_lut_otp_41 = 41u,    //!< Index 41
    mmu_mmu_lut_otp_42 = 42u,    //!< Index 42
    mmu_mmu_lut_otp_43 = 43u,    //!< Index 43
    mmu_mmu_lut_otp_44 = 44u,    //!< Index 44
    mmu_mmu_lut_otp_45 = 45u,    //!< Index 45
    mmu_mmu_lut_otp_46 = 46u,    //!< Index 46
    mmu_mmu_lut_otp_47 = 47u,    //!< Index 47
    mmu_mmu_lut_otp_48 = 48u,    //!< Index 48
    mmu_mmu_lut_otp_49 = 49u,    //!< Index 49
    mmu_mmu_lut_otp_50 = 50u,    //!< Index 50
    mmu_mmu_lut_otp_51 = 51u,    //!< Index 51
    mmu_mmu_lut_otp_52 = 52u,    //!< Index 52
    mmu_mmu_lut_otp_53 = 53u,    //!< Index 53
    mmu_mmu_lut_otp_54 = 54u,    //!< Index 54
    mmu_mmu_lut_otp_55 = 55u,    //!< Index 55
    mmu_mmu_lut_otp_56 = 56u,    //!< Index 56
    mmu_mmu_lut_otp_57 = 57u,    //!< Index 57
    mmu_mmu_lut_otp_58 = 58u,    //!< Index 58
    mmu_mmu_lut_otp_59 = 59u,    //!< Index 59
    mmu_mmu_lut_otp_60 = 60u,    //!< Index 60
    mmu_mmu_lut_otp_61 = 61u,    //!< Index 61
    mmu_mmu_lut_otp_62 = 62u,    //!< Index 62
    mmu_mmu_lut_otp_63 = 63u     //!< Index 63
} mmu_mmu_lut_otp_idx_t;

/** enumeration of MMU.MMU_LUT_RAM1 member index
 */
/*lint -parent(uint32_t, mmu_mmu_lut_ram1_idx_t) -strong(AJX)*/
typedef enum _mmu_mmu_lut_ram1_idx_e
{
    mmu_mmu_lut_ram1_0 = 0u,    //!< Index 0
    mmu_mmu_lut_ram1_1 = 1u,    //!< Index 1
    mmu_mmu_lut_ram1_2 = 2u,    //!< Index 2
    mmu_mmu_lut_ram1_3 = 3u,    //!< Index 3
    mmu_mmu_lut_ram1_4 = 4u,    //!< Index 4
    mmu_mmu_lut_ram1_5 = 5u,    //!< Index 5
    mmu_mmu_lut_ram1_6 = 6u,    //!< Index 6
    mmu_mmu_lut_ram1_7 = 7u,    //!< Index 7
    mmu_mmu_lut_ram1_8 = 8u,    //!< Index 8
    mmu_mmu_lut_ram1_9 = 9u,    //!< Index 9
    mmu_mmu_lut_ram1_10 = 10u,    //!< Index 10
    mmu_mmu_lut_ram1_11 = 11u,    //!< Index 11
    mmu_mmu_lut_ram1_12 = 12u,    //!< Index 12
    mmu_mmu_lut_ram1_13 = 13u,    //!< Index 13
    mmu_mmu_lut_ram1_14 = 14u,    //!< Index 14
    mmu_mmu_lut_ram1_15 = 15u     //!< Index 15
} mmu_mmu_lut_ram1_idx_t;

/** enumeration of MMU.MMU_LUT_RAM2 member index
 */
/*lint -parent(uint32_t, mmu_mmu_lut_ram2_idx_t) -strong(AJX)*/
typedef enum _mmu_mmu_lut_ram2_idx_e
{
    mmu_mmu_lut_ram2_0 = 0u,    //!< Index 0
    mmu_mmu_lut_ram2_1 = 1u,    //!< Index 1
    mmu_mmu_lut_ram2_2 = 2u,    //!< Index 2
    mmu_mmu_lut_ram2_3 = 3u,    //!< Index 3
    mmu_mmu_lut_ram2_4 = 4u,    //!< Index 4
    mmu_mmu_lut_ram2_5 = 5u,    //!< Index 5
    mmu_mmu_lut_ram2_6 = 6u,    //!< Index 6
    mmu_mmu_lut_ram2_7 = 7u,    //!< Index 7
    mmu_mmu_lut_ram2_8 = 8u,    //!< Index 8
    mmu_mmu_lut_ram2_9 = 9u,    //!< Index 9
    mmu_mmu_lut_ram2_10 = 10u,    //!< Index 10
    mmu_mmu_lut_ram2_11 = 11u,    //!< Index 11
    mmu_mmu_lut_ram2_12 = 12u,    //!< Index 12
    mmu_mmu_lut_ram2_13 = 13u,    //!< Index 13
    mmu_mmu_lut_ram2_14 = 14u,    //!< Index 14
    mmu_mmu_lut_ram2_15 = 15u     //!< Index 15
} mmu_mmu_lut_ram2_idx_t;


#define MMU_BASE (0x40004000u)                                                          /*!< mmu base address */

/** __MMU_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__MMU_INLINE uint32_t* __MMU_BASE_PTR(void)
{
    return (uint32_t*)(MMU_BASE);
}


/* -------------------------------------------------------------------------- */
/*                        MMU_LUT_ROM member of MMU_t                        */
/* -------------------------------------------------------------------------- */

/** __MMU_MMU_LUT_ROM__ADDRESS returns the address of member MMU_LUT_ROM.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in MMU_LUT_ROM array
 * @return address of MMU_LUT_ROM
 */
__MMU_INLINE uint32_t* __MMU_MMU_LUT_ROM__ADDRESS(mmu_mmu_lut_rom_idx_t ida)
{
    return (uint32_t*)((uint32_t)__MMU_BASE_PTR() + (uint32_t)(offsetof(MMU_t, MMU_LUT_ROM)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** MMU_MMU_LUT_ROM__SET() sets MMU_LUT_ROM to given value.
 *
 * When writing to MMU_LUT_ROM, this is mandatory to use.
 *
 * @param ida index in MMU_LUT_ROM array
 * @param value new value for MMU_LUT_ROM
 */
__MMU_INLINE void MMU_MMU_LUT_ROM__SET(mmu_mmu_lut_rom_idx_t ida, uint32_t value)
{
    HAL_SET32(__MMU_MMU_LUT_ROM__ADDRESS(ida), value);
}

/** MMU_MMU_LUT_ROM__GET() gets MMU_LUT_ROM's current value.
 *
 * When reading from MMU_LUT_ROM, this is mandatory to use.
 *
 * @param ida index in MMU_LUT_ROM array
 * @return current value of MMU_LUT_ROM
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_ROM__GET(mmu_mmu_lut_rom_idx_t ida)
{
    return HAL_GET32(__MMU_MMU_LUT_ROM__ADDRESS(ida));
}

/* ------------------------ MMU.MMU_LUT_ROM.BASE_ADR ------------------------ */


#define MMU_MMU_LUT_ROM__BASE_ADR__Pos                          8                                                                      /*!< Right-most bit position of BASE_ADR in MMU.MMU_LUT_ROM */
#define MMU_MMU_LUT_ROM__BASE_ADR__Msk                          (0x00000003UL << MMU_MMU_LUT_ROM__BASE_ADR__Pos)                       /*!< Mask for BASE_ADR in MMU.MMU_LUT_ROM */
#define MMU_MMU_LUT_ROM__BASE_ADR__Shift(v)                     (((v) << MMU_MMU_LUT_ROM__BASE_ADR__Pos) & MMU_MMU_LUT_ROM__BASE_ADR__Msk) /*!< Shift value 'v' into BASE_ADR and mask 'v' to fit it into BASE_ADR field */

/** MMU_MMU_LUT_ROM__BASE_ADR__SET() sets MMU_LUT_ROM.BASE_ADR to given value.
 *
 * When writing to MMU_LUT_ROM.BASE_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_ROM array
 * @param bf_value new value for MMU_LUT_ROM.BASE_ADR
 */
__MMU_INLINE void MMU_MMU_LUT_ROM__BASE_ADR__SET(mmu_mmu_lut_rom_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_ROM__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_ROM__BASE_ADR__Msk);
    reg = (reg | (MMU_MMU_LUT_ROM__BASE_ADR__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_ROM__SET(ida, reg);
}

/** MMU_MMU_LUT_ROM__BASE_ADR__GET() gets MMU_LUT_ROM.BASE_ADR's current value.
 *
 * When reading from MMU_LUT_ROM.BASE_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_ROM array
 * @return current value of MMU_LUT_ROM.BASE_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_ROM__BASE_ADR__GET(mmu_mmu_lut_rom_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_ROM__GET(ida);
    reg = (reg & MMU_MMU_LUT_ROM__BASE_ADR__Msk);
    reg = (reg >> MMU_MMU_LUT_ROM__BASE_ADR__Pos);
    return (uint32_t)reg;
}

/* ------------------------ MMU.MMU_LUT_ROM.BLK_ADR ------------------------ */


#define MMU_MMU_LUT_ROM__BLK_ADR__Pos                           1                                                                      /*!< Right-most bit position of BLK_ADR in MMU.MMU_LUT_ROM */
#define MMU_MMU_LUT_ROM__BLK_ADR__Msk                           (0x0000007FUL << MMU_MMU_LUT_ROM__BLK_ADR__Pos)                        /*!< Mask for BLK_ADR in MMU.MMU_LUT_ROM */
#define MMU_MMU_LUT_ROM__BLK_ADR__Shift(v)                      (((v) << MMU_MMU_LUT_ROM__BLK_ADR__Pos) & MMU_MMU_LUT_ROM__BLK_ADR__Msk) /*!< Shift value 'v' into BLK_ADR and mask 'v' to fit it into BLK_ADR field */

/** MMU_MMU_LUT_ROM__BLK_ADR__SET() sets MMU_LUT_ROM.BLK_ADR to given value.
 *
 * When writing to MMU_LUT_ROM.BLK_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_ROM array
 * @param bf_value new value for MMU_LUT_ROM.BLK_ADR
 */
__MMU_INLINE void MMU_MMU_LUT_ROM__BLK_ADR__SET(mmu_mmu_lut_rom_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_ROM__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_ROM__BLK_ADR__Msk);
    reg = (reg | (MMU_MMU_LUT_ROM__BLK_ADR__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_ROM__SET(ida, reg);
}

/** MMU_MMU_LUT_ROM__BLK_ADR__GET() gets MMU_LUT_ROM.BLK_ADR's current value.
 *
 * When reading from MMU_LUT_ROM.BLK_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_ROM array
 * @return current value of MMU_LUT_ROM.BLK_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_ROM__BLK_ADR__GET(mmu_mmu_lut_rom_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_ROM__GET(ida);
    reg = (reg & MMU_MMU_LUT_ROM__BLK_ADR__Msk);
    reg = (reg >> MMU_MMU_LUT_ROM__BLK_ADR__Pos);
    return (uint32_t)reg;
}

/* -------------------------- MMU.MMU_LUT_ROM.PROT -------------------------- */


#define MMU_MMU_LUT_ROM__PROT__Pos                              0                                                                      /*!< Right-most bit position of PROT in MMU.MMU_LUT_ROM */
#define MMU_MMU_LUT_ROM__PROT__Msk                              (0x00000001UL << MMU_MMU_LUT_ROM__PROT__Pos)                           /*!< Mask for PROT in MMU.MMU_LUT_ROM */
#define MMU_MMU_LUT_ROM__PROT__Shift(v)                         (((v) << MMU_MMU_LUT_ROM__PROT__Pos) & MMU_MMU_LUT_ROM__PROT__Msk)     /*!< Shift value 'v' into PROT and mask 'v' to fit it into PROT field */

/** MMU_MMU_LUT_ROM__PROT__SET() sets MMU_LUT_ROM.PROT to given value.
 *
 * When writing to MMU_LUT_ROM.PROT, this is recommended to use.
 *
 * @param ida index in MMU_LUT_ROM array
 * @param bf_value new value for MMU_LUT_ROM.PROT
 */
__MMU_INLINE void MMU_MMU_LUT_ROM__PROT__SET(mmu_mmu_lut_rom_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_ROM__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_ROM__PROT__Msk);
    reg = (reg | (MMU_MMU_LUT_ROM__PROT__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_ROM__SET(ida, reg);
}

/** MMU_MMU_LUT_ROM__PROT__GET() gets MMU_LUT_ROM.PROT's current value.
 *
 * When reading from MMU_LUT_ROM.PROT, this is recommended to use.
 *
 * @param ida index in MMU_LUT_ROM array
 * @return current value of MMU_LUT_ROM.PROT
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_ROM__PROT__GET(mmu_mmu_lut_rom_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_ROM__GET(ida);
    reg = (reg & MMU_MMU_LUT_ROM__PROT__Msk);
    reg = (reg >> MMU_MMU_LUT_ROM__PROT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        MMU_LUT_OTP member of MMU_t                        */
/* -------------------------------------------------------------------------- */

/** __MMU_MMU_LUT_OTP__ADDRESS returns the address of member MMU_LUT_OTP.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in MMU_LUT_OTP array
 * @return address of MMU_LUT_OTP
 */
__MMU_INLINE uint32_t* __MMU_MMU_LUT_OTP__ADDRESS(mmu_mmu_lut_otp_idx_t ida)
{
    return (uint32_t*)((uint32_t)__MMU_BASE_PTR() + (uint32_t)(offsetof(MMU_t, MMU_LUT_OTP)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** MMU_MMU_LUT_OTP__SET() sets MMU_LUT_OTP to given value.
 *
 * When writing to MMU_LUT_OTP, this is mandatory to use.
 *
 * @param ida index in MMU_LUT_OTP array
 * @param value new value for MMU_LUT_OTP
 */
__MMU_INLINE void MMU_MMU_LUT_OTP__SET(mmu_mmu_lut_otp_idx_t ida, uint32_t value)
{
    HAL_SET32(__MMU_MMU_LUT_OTP__ADDRESS(ida), value);
}

/** MMU_MMU_LUT_OTP__GET() gets MMU_LUT_OTP's current value.
 *
 * When reading from MMU_LUT_OTP, this is mandatory to use.
 *
 * @param ida index in MMU_LUT_OTP array
 * @return current value of MMU_LUT_OTP
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_OTP__GET(mmu_mmu_lut_otp_idx_t ida)
{
    return HAL_GET32(__MMU_MMU_LUT_OTP__ADDRESS(ida));
}

/* ------------------------ MMU.MMU_LUT_OTP.BASE_ADR ------------------------ */


#define MMU_MMU_LUT_OTP__BASE_ADR__Pos                          8                                                                      /*!< Right-most bit position of BASE_ADR in MMU.MMU_LUT_OTP */
#define MMU_MMU_LUT_OTP__BASE_ADR__Msk                          (0x00000003UL << MMU_MMU_LUT_OTP__BASE_ADR__Pos)                       /*!< Mask for BASE_ADR in MMU.MMU_LUT_OTP */
#define MMU_MMU_LUT_OTP__BASE_ADR__Shift(v)                     (((v) << MMU_MMU_LUT_OTP__BASE_ADR__Pos) & MMU_MMU_LUT_OTP__BASE_ADR__Msk) /*!< Shift value 'v' into BASE_ADR and mask 'v' to fit it into BASE_ADR field */

/** MMU_MMU_LUT_OTP__BASE_ADR__SET() sets MMU_LUT_OTP.BASE_ADR to given value.
 *
 * When writing to MMU_LUT_OTP.BASE_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_OTP array
 * @param bf_value new value for MMU_LUT_OTP.BASE_ADR
 */
__MMU_INLINE void MMU_MMU_LUT_OTP__BASE_ADR__SET(mmu_mmu_lut_otp_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_OTP__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_OTP__BASE_ADR__Msk);
    reg = (reg | (MMU_MMU_LUT_OTP__BASE_ADR__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_OTP__SET(ida, reg);
}

/** MMU_MMU_LUT_OTP__BASE_ADR__GET() gets MMU_LUT_OTP.BASE_ADR's current value.
 *
 * When reading from MMU_LUT_OTP.BASE_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_OTP array
 * @return current value of MMU_LUT_OTP.BASE_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_OTP__BASE_ADR__GET(mmu_mmu_lut_otp_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_OTP__GET(ida);
    reg = (reg & MMU_MMU_LUT_OTP__BASE_ADR__Msk);
    reg = (reg >> MMU_MMU_LUT_OTP__BASE_ADR__Pos);
    return (uint32_t)reg;
}

/* ------------------------ MMU.MMU_LUT_OTP.BLK_ADR ------------------------ */


#define MMU_MMU_LUT_OTP__BLK_ADR__Pos                           1                                                                      /*!< Right-most bit position of BLK_ADR in MMU.MMU_LUT_OTP */
#define MMU_MMU_LUT_OTP__BLK_ADR__Msk                           (0x0000007FUL << MMU_MMU_LUT_OTP__BLK_ADR__Pos)                        /*!< Mask for BLK_ADR in MMU.MMU_LUT_OTP */
#define MMU_MMU_LUT_OTP__BLK_ADR__Shift(v)                      (((v) << MMU_MMU_LUT_OTP__BLK_ADR__Pos) & MMU_MMU_LUT_OTP__BLK_ADR__Msk) /*!< Shift value 'v' into BLK_ADR and mask 'v' to fit it into BLK_ADR field */

/** MMU_MMU_LUT_OTP__BLK_ADR__SET() sets MMU_LUT_OTP.BLK_ADR to given value.
 *
 * When writing to MMU_LUT_OTP.BLK_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_OTP array
 * @param bf_value new value for MMU_LUT_OTP.BLK_ADR
 */
__MMU_INLINE void MMU_MMU_LUT_OTP__BLK_ADR__SET(mmu_mmu_lut_otp_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_OTP__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_OTP__BLK_ADR__Msk);
    reg = (reg | (MMU_MMU_LUT_OTP__BLK_ADR__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_OTP__SET(ida, reg);
}

/** MMU_MMU_LUT_OTP__BLK_ADR__GET() gets MMU_LUT_OTP.BLK_ADR's current value.
 *
 * When reading from MMU_LUT_OTP.BLK_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_OTP array
 * @return current value of MMU_LUT_OTP.BLK_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_OTP__BLK_ADR__GET(mmu_mmu_lut_otp_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_OTP__GET(ida);
    reg = (reg & MMU_MMU_LUT_OTP__BLK_ADR__Msk);
    reg = (reg >> MMU_MMU_LUT_OTP__BLK_ADR__Pos);
    return (uint32_t)reg;
}

/* -------------------------- MMU.MMU_LUT_OTP.PROT -------------------------- */


#define MMU_MMU_LUT_OTP__PROT__Pos                              0                                                                      /*!< Right-most bit position of PROT in MMU.MMU_LUT_OTP */
#define MMU_MMU_LUT_OTP__PROT__Msk                              (0x00000001UL << MMU_MMU_LUT_OTP__PROT__Pos)                           /*!< Mask for PROT in MMU.MMU_LUT_OTP */
#define MMU_MMU_LUT_OTP__PROT__Shift(v)                         (((v) << MMU_MMU_LUT_OTP__PROT__Pos) & MMU_MMU_LUT_OTP__PROT__Msk)     /*!< Shift value 'v' into PROT and mask 'v' to fit it into PROT field */

/** MMU_MMU_LUT_OTP__PROT__SET() sets MMU_LUT_OTP.PROT to given value.
 *
 * When writing to MMU_LUT_OTP.PROT, this is recommended to use.
 *
 * @param ida index in MMU_LUT_OTP array
 * @param bf_value new value for MMU_LUT_OTP.PROT
 */
__MMU_INLINE void MMU_MMU_LUT_OTP__PROT__SET(mmu_mmu_lut_otp_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_OTP__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_OTP__PROT__Msk);
    reg = (reg | (MMU_MMU_LUT_OTP__PROT__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_OTP__SET(ida, reg);
}

/** MMU_MMU_LUT_OTP__PROT__GET() gets MMU_LUT_OTP.PROT's current value.
 *
 * When reading from MMU_LUT_OTP.PROT, this is recommended to use.
 *
 * @param ida index in MMU_LUT_OTP array
 * @return current value of MMU_LUT_OTP.PROT
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_OTP__PROT__GET(mmu_mmu_lut_otp_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_OTP__GET(ida);
    reg = (reg & MMU_MMU_LUT_OTP__PROT__Msk);
    reg = (reg >> MMU_MMU_LUT_OTP__PROT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        MMU_LUT_RAM1 member of MMU_t                        */
/* -------------------------------------------------------------------------- */

/** __MMU_MMU_LUT_RAM1__ADDRESS returns the address of member MMU_LUT_RAM1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in MMU_LUT_RAM1 array
 * @return address of MMU_LUT_RAM1
 */
__MMU_INLINE uint32_t* __MMU_MMU_LUT_RAM1__ADDRESS(mmu_mmu_lut_ram1_idx_t ida)
{
    return (uint32_t*)((uint32_t)__MMU_BASE_PTR() + (uint32_t)(offsetof(MMU_t, MMU_LUT_RAM1)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** MMU_MMU_LUT_RAM1__SET() sets MMU_LUT_RAM1 to given value.
 *
 * When writing to MMU_LUT_RAM1, this is mandatory to use.
 *
 * @param ida index in MMU_LUT_RAM1 array
 * @param value new value for MMU_LUT_RAM1
 */
__MMU_INLINE void MMU_MMU_LUT_RAM1__SET(mmu_mmu_lut_ram1_idx_t ida, uint32_t value)
{
    HAL_SET32(__MMU_MMU_LUT_RAM1__ADDRESS(ida), value);
}

/** MMU_MMU_LUT_RAM1__GET() gets MMU_LUT_RAM1's current value.
 *
 * When reading from MMU_LUT_RAM1, this is mandatory to use.
 *
 * @param ida index in MMU_LUT_RAM1 array
 * @return current value of MMU_LUT_RAM1
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_RAM1__GET(mmu_mmu_lut_ram1_idx_t ida)
{
    return HAL_GET32(__MMU_MMU_LUT_RAM1__ADDRESS(ida));
}

/* ----------------------- MMU.MMU_LUT_RAM1.BASE_ADR ----------------------- */


#define MMU_MMU_LUT_RAM1__BASE_ADR__Pos                         8                                                                      /*!< Right-most bit position of BASE_ADR in MMU.MMU_LUT_RAM1 */
#define MMU_MMU_LUT_RAM1__BASE_ADR__Msk                         (0x00000003UL << MMU_MMU_LUT_RAM1__BASE_ADR__Pos)                      /*!< Mask for BASE_ADR in MMU.MMU_LUT_RAM1 */
#define MMU_MMU_LUT_RAM1__BASE_ADR__Shift(v)                    (((v) << MMU_MMU_LUT_RAM1__BASE_ADR__Pos) & MMU_MMU_LUT_RAM1__BASE_ADR__Msk) /*!< Shift value 'v' into BASE_ADR and mask 'v' to fit it into BASE_ADR field */

/** MMU_MMU_LUT_RAM1__BASE_ADR__SET() sets MMU_LUT_RAM1.BASE_ADR to given value.
 *
 * When writing to MMU_LUT_RAM1.BASE_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM1 array
 * @param bf_value new value for MMU_LUT_RAM1.BASE_ADR
 */
__MMU_INLINE void MMU_MMU_LUT_RAM1__BASE_ADR__SET(mmu_mmu_lut_ram1_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_RAM1__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_RAM1__BASE_ADR__Msk);
    reg = (reg | (MMU_MMU_LUT_RAM1__BASE_ADR__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_RAM1__SET(ida, reg);
}

/** MMU_MMU_LUT_RAM1__BASE_ADR__GET() gets MMU_LUT_RAM1.BASE_ADR's current value.
 *
 * When reading from MMU_LUT_RAM1.BASE_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM1 array
 * @return current value of MMU_LUT_RAM1.BASE_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_RAM1__BASE_ADR__GET(mmu_mmu_lut_ram1_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_RAM1__GET(ida);
    reg = (reg & MMU_MMU_LUT_RAM1__BASE_ADR__Msk);
    reg = (reg >> MMU_MMU_LUT_RAM1__BASE_ADR__Pos);
    return (uint32_t)reg;
}

/* ------------------------ MMU.MMU_LUT_RAM1.BLK_ADR ------------------------ */


#define MMU_MMU_LUT_RAM1__BLK_ADR__Pos                          1                                                                      /*!< Right-most bit position of BLK_ADR in MMU.MMU_LUT_RAM1 */
#define MMU_MMU_LUT_RAM1__BLK_ADR__Msk                          (0x0000007FUL << MMU_MMU_LUT_RAM1__BLK_ADR__Pos)                       /*!< Mask for BLK_ADR in MMU.MMU_LUT_RAM1 */
#define MMU_MMU_LUT_RAM1__BLK_ADR__Shift(v)                     (((v) << MMU_MMU_LUT_RAM1__BLK_ADR__Pos) & MMU_MMU_LUT_RAM1__BLK_ADR__Msk) /*!< Shift value 'v' into BLK_ADR and mask 'v' to fit it into BLK_ADR field */

/** MMU_MMU_LUT_RAM1__BLK_ADR__SET() sets MMU_LUT_RAM1.BLK_ADR to given value.
 *
 * When writing to MMU_LUT_RAM1.BLK_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM1 array
 * @param bf_value new value for MMU_LUT_RAM1.BLK_ADR
 */
__MMU_INLINE void MMU_MMU_LUT_RAM1__BLK_ADR__SET(mmu_mmu_lut_ram1_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_RAM1__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_RAM1__BLK_ADR__Msk);
    reg = (reg | (MMU_MMU_LUT_RAM1__BLK_ADR__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_RAM1__SET(ida, reg);
}

/** MMU_MMU_LUT_RAM1__BLK_ADR__GET() gets MMU_LUT_RAM1.BLK_ADR's current value.
 *
 * When reading from MMU_LUT_RAM1.BLK_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM1 array
 * @return current value of MMU_LUT_RAM1.BLK_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_RAM1__BLK_ADR__GET(mmu_mmu_lut_ram1_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_RAM1__GET(ida);
    reg = (reg & MMU_MMU_LUT_RAM1__BLK_ADR__Msk);
    reg = (reg >> MMU_MMU_LUT_RAM1__BLK_ADR__Pos);
    return (uint32_t)reg;
}

/* ------------------------- MMU.MMU_LUT_RAM1.PROT ------------------------- */


#define MMU_MMU_LUT_RAM1__PROT__Pos                             0                                                                      /*!< Right-most bit position of PROT in MMU.MMU_LUT_RAM1 */
#define MMU_MMU_LUT_RAM1__PROT__Msk                             (0x00000001UL << MMU_MMU_LUT_RAM1__PROT__Pos)                          /*!< Mask for PROT in MMU.MMU_LUT_RAM1 */
#define MMU_MMU_LUT_RAM1__PROT__Shift(v)                        (((v) << MMU_MMU_LUT_RAM1__PROT__Pos) & MMU_MMU_LUT_RAM1__PROT__Msk)   /*!< Shift value 'v' into PROT and mask 'v' to fit it into PROT field */

/** MMU_MMU_LUT_RAM1__PROT__SET() sets MMU_LUT_RAM1.PROT to given value.
 *
 * When writing to MMU_LUT_RAM1.PROT, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM1 array
 * @param bf_value new value for MMU_LUT_RAM1.PROT
 */
__MMU_INLINE void MMU_MMU_LUT_RAM1__PROT__SET(mmu_mmu_lut_ram1_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_RAM1__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_RAM1__PROT__Msk);
    reg = (reg | (MMU_MMU_LUT_RAM1__PROT__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_RAM1__SET(ida, reg);
}

/** MMU_MMU_LUT_RAM1__PROT__GET() gets MMU_LUT_RAM1.PROT's current value.
 *
 * When reading from MMU_LUT_RAM1.PROT, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM1 array
 * @return current value of MMU_LUT_RAM1.PROT
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_RAM1__PROT__GET(mmu_mmu_lut_ram1_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_RAM1__GET(ida);
    reg = (reg & MMU_MMU_LUT_RAM1__PROT__Msk);
    reg = (reg >> MMU_MMU_LUT_RAM1__PROT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        MMU_LUT_RAM2 member of MMU_t                        */
/* -------------------------------------------------------------------------- */

/** __MMU_MMU_LUT_RAM2__ADDRESS returns the address of member MMU_LUT_RAM2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @param ida index in MMU_LUT_RAM2 array
 * @return address of MMU_LUT_RAM2
 */
__MMU_INLINE uint32_t* __MMU_MMU_LUT_RAM2__ADDRESS(mmu_mmu_lut_ram2_idx_t ida)
{
    return (uint32_t*)((uint32_t)__MMU_BASE_PTR() + (uint32_t)(offsetof(MMU_t, MMU_LUT_RAM2)) + (uint32_t)(sizeof(uint32_t)*(uint32_t)ida));
}

/** MMU_MMU_LUT_RAM2__SET() sets MMU_LUT_RAM2 to given value.
 *
 * When writing to MMU_LUT_RAM2, this is mandatory to use.
 *
 * @param ida index in MMU_LUT_RAM2 array
 * @param value new value for MMU_LUT_RAM2
 */
__MMU_INLINE void MMU_MMU_LUT_RAM2__SET(mmu_mmu_lut_ram2_idx_t ida, uint32_t value)
{
    HAL_SET32(__MMU_MMU_LUT_RAM2__ADDRESS(ida), value);
}

/** MMU_MMU_LUT_RAM2__GET() gets MMU_LUT_RAM2's current value.
 *
 * When reading from MMU_LUT_RAM2, this is mandatory to use.
 *
 * @param ida index in MMU_LUT_RAM2 array
 * @return current value of MMU_LUT_RAM2
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_RAM2__GET(mmu_mmu_lut_ram2_idx_t ida)
{
    return HAL_GET32(__MMU_MMU_LUT_RAM2__ADDRESS(ida));
}

/* ----------------------- MMU.MMU_LUT_RAM2.BASE_ADR ----------------------- */


#define MMU_MMU_LUT_RAM2__BASE_ADR__Pos                         8                                                                      /*!< Right-most bit position of BASE_ADR in MMU.MMU_LUT_RAM2 */
#define MMU_MMU_LUT_RAM2__BASE_ADR__Msk                         (0x00000003UL << MMU_MMU_LUT_RAM2__BASE_ADR__Pos)                      /*!< Mask for BASE_ADR in MMU.MMU_LUT_RAM2 */
#define MMU_MMU_LUT_RAM2__BASE_ADR__Shift(v)                    (((v) << MMU_MMU_LUT_RAM2__BASE_ADR__Pos) & MMU_MMU_LUT_RAM2__BASE_ADR__Msk) /*!< Shift value 'v' into BASE_ADR and mask 'v' to fit it into BASE_ADR field */

/** MMU_MMU_LUT_RAM2__BASE_ADR__SET() sets MMU_LUT_RAM2.BASE_ADR to given value.
 *
 * When writing to MMU_LUT_RAM2.BASE_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM2 array
 * @param bf_value new value for MMU_LUT_RAM2.BASE_ADR
 */
__MMU_INLINE void MMU_MMU_LUT_RAM2__BASE_ADR__SET(mmu_mmu_lut_ram2_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_RAM2__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_RAM2__BASE_ADR__Msk);
    reg = (reg | (MMU_MMU_LUT_RAM2__BASE_ADR__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_RAM2__SET(ida, reg);
}

/** MMU_MMU_LUT_RAM2__BASE_ADR__GET() gets MMU_LUT_RAM2.BASE_ADR's current value.
 *
 * When reading from MMU_LUT_RAM2.BASE_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM2 array
 * @return current value of MMU_LUT_RAM2.BASE_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_RAM2__BASE_ADR__GET(mmu_mmu_lut_ram2_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_RAM2__GET(ida);
    reg = (reg & MMU_MMU_LUT_RAM2__BASE_ADR__Msk);
    reg = (reg >> MMU_MMU_LUT_RAM2__BASE_ADR__Pos);
    return (uint32_t)reg;
}

/* ------------------------ MMU.MMU_LUT_RAM2.BLK_ADR ------------------------ */


#define MMU_MMU_LUT_RAM2__BLK_ADR__Pos                          1                                                                      /*!< Right-most bit position of BLK_ADR in MMU.MMU_LUT_RAM2 */
#define MMU_MMU_LUT_RAM2__BLK_ADR__Msk                          (0x0000007FUL << MMU_MMU_LUT_RAM2__BLK_ADR__Pos)                       /*!< Mask for BLK_ADR in MMU.MMU_LUT_RAM2 */
#define MMU_MMU_LUT_RAM2__BLK_ADR__Shift(v)                     (((v) << MMU_MMU_LUT_RAM2__BLK_ADR__Pos) & MMU_MMU_LUT_RAM2__BLK_ADR__Msk) /*!< Shift value 'v' into BLK_ADR and mask 'v' to fit it into BLK_ADR field */

/** MMU_MMU_LUT_RAM2__BLK_ADR__SET() sets MMU_LUT_RAM2.BLK_ADR to given value.
 *
 * When writing to MMU_LUT_RAM2.BLK_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM2 array
 * @param bf_value new value for MMU_LUT_RAM2.BLK_ADR
 */
__MMU_INLINE void MMU_MMU_LUT_RAM2__BLK_ADR__SET(mmu_mmu_lut_ram2_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_RAM2__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_RAM2__BLK_ADR__Msk);
    reg = (reg | (MMU_MMU_LUT_RAM2__BLK_ADR__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_RAM2__SET(ida, reg);
}

/** MMU_MMU_LUT_RAM2__BLK_ADR__GET() gets MMU_LUT_RAM2.BLK_ADR's current value.
 *
 * When reading from MMU_LUT_RAM2.BLK_ADR, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM2 array
 * @return current value of MMU_LUT_RAM2.BLK_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_RAM2__BLK_ADR__GET(mmu_mmu_lut_ram2_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_RAM2__GET(ida);
    reg = (reg & MMU_MMU_LUT_RAM2__BLK_ADR__Msk);
    reg = (reg >> MMU_MMU_LUT_RAM2__BLK_ADR__Pos);
    return (uint32_t)reg;
}

/* ------------------------- MMU.MMU_LUT_RAM2.PROT ------------------------- */


#define MMU_MMU_LUT_RAM2__PROT__Pos                             0                                                                      /*!< Right-most bit position of PROT in MMU.MMU_LUT_RAM2 */
#define MMU_MMU_LUT_RAM2__PROT__Msk                             (0x00000001UL << MMU_MMU_LUT_RAM2__PROT__Pos)                          /*!< Mask for PROT in MMU.MMU_LUT_RAM2 */
#define MMU_MMU_LUT_RAM2__PROT__Shift(v)                        (((v) << MMU_MMU_LUT_RAM2__PROT__Pos) & MMU_MMU_LUT_RAM2__PROT__Msk)   /*!< Shift value 'v' into PROT and mask 'v' to fit it into PROT field */

/** MMU_MMU_LUT_RAM2__PROT__SET() sets MMU_LUT_RAM2.PROT to given value.
 *
 * When writing to MMU_LUT_RAM2.PROT, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM2 array
 * @param bf_value new value for MMU_LUT_RAM2.PROT
 */
__MMU_INLINE void MMU_MMU_LUT_RAM2__PROT__SET(mmu_mmu_lut_ram2_idx_t ida, uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_LUT_RAM2__GET(ida);
    reg = (reg & ~MMU_MMU_LUT_RAM2__PROT__Msk);
    reg = (reg | (MMU_MMU_LUT_RAM2__PROT__Shift((uint32_t)bf_value)));
    MMU_MMU_LUT_RAM2__SET(ida, reg);
}

/** MMU_MMU_LUT_RAM2__PROT__GET() gets MMU_LUT_RAM2.PROT's current value.
 *
 * When reading from MMU_LUT_RAM2.PROT, this is recommended to use.
 *
 * @param ida index in MMU_LUT_RAM2 array
 * @return current value of MMU_LUT_RAM2.PROT
 */
__MMU_INLINE uint32_t MMU_MMU_LUT_RAM2__PROT__GET(mmu_mmu_lut_ram2_idx_t ida)
{
    uint32_t reg = MMU_MMU_LUT_RAM2__GET(ida);
    reg = (reg & MMU_MMU_LUT_RAM2__PROT__Msk);
    reg = (reg >> MMU_MMU_LUT_RAM2__PROT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       MMU_PER_SPACE member of MMU_t                       */
/* -------------------------------------------------------------------------- */

/** __MMU_MMU_PER_SPACE__ADDRESS returns the address of member MMU_PER_SPACE.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MMU_PER_SPACE
 */
__MMU_INLINE uint32_t* __MMU_MMU_PER_SPACE__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__MMU_BASE_PTR() + (uint32_t)(offsetof(MMU_t, MMU_PER_SPACE)));
}

/** MMU_MMU_PER_SPACE__SET() sets MMU_PER_SPACE to given value.
 *
 * When writing to MMU_PER_SPACE, this is mandatory to use.
 *
 * @param value new value for MMU_PER_SPACE
 */
__MMU_INLINE void MMU_MMU_PER_SPACE__SET(uint32_t value)
{
    HAL_SET32(__MMU_MMU_PER_SPACE__ADDRESS(), value);
}

/** MMU_MMU_PER_SPACE__GET() gets MMU_PER_SPACE's current value.
 *
 * When reading from MMU_PER_SPACE, this is mandatory to use.
 *
 * @return current value of MMU_PER_SPACE
 */
__MMU_INLINE uint32_t MMU_MMU_PER_SPACE__GET(void)
{
    return HAL_GET32(__MMU_MMU_PER_SPACE__ADDRESS());
}

/* ------------------------- MMU.MMU_PER_SPACE.PER ------------------------- */


/*lint -parent(uint32_t, mmu_mmu_per_space__per_t) -strong(AJX)*/
typedef enum mmu_mmu_per_space__per_e                                                                                                  /*!<  */
{
    mmu_mmu_per_space__per_none = 0x1u,                                                                                                /*!<  */
    mmu_mmu_per_space__per_cpup = 0x2u,                                                                                                /*!<  */
    mmu_mmu_per_space__per_bifp = 0x4u,                                                                                                /*!<  */
    mmu_mmu_per_space__per_bifr_trim = 0x8u,                                                                                           /*!<  */
    mmu_mmu_per_space__per_bifr_ana = 0x10u,                                                                                           /*!<  */
    mmu_mmu_per_space__per_bifr_vsp0 = 0x20u,                                                                                          /*!<  */
    mmu_mmu_per_space__per_bifr_vsp1 = 0x40u,                                                                                          /*!<  */
    mmu_mmu_per_space__per_bifr_vsp2 = 0x80u,                                                                                          /*!<  */
    mmu_mmu_per_space__per_bifr_vctrl0 = 0x100u,                                                                                       /*!<  */
    mmu_mmu_per_space__per_bifr_vctrl1 = 0x200u,                                                                                       /*!<  */
    mmu_mmu_per_space__per_bifr_pid0 = 0x400u,                                                                                         /*!<  */
    mmu_mmu_per_space__per_bifr_pid1 = 0x800u,                                                                                         /*!<  */
    mmu_mmu_per_space__per_bifr_isp0 = 0x1000u,                                                                                        /*!<  */
    mmu_mmu_per_space__per_bifr_isp1 = 0x2000u,                                                                                        /*!<  */
    mmu_mmu_per_space__per_bifr_pwm = 0x4000u,                                                                                         /*!<  */
    mmu_mmu_per_space__per_bifr_comm = 0x8000u,                                                                                        /*!<  */
    mmu_mmu_per_space__per_bifr_telem0 = 0x10000u,                                                                                     /*!<  */
    mmu_mmu_per_space__per_bifr_telem1 = 0x20000u,                                                                                     /*!<  */
    mmu_mmu_per_space__per_bifr_fault0 = 0x40000u,                                                                                     /*!<  */
    mmu_mmu_per_space__per_bifr_fault1 = 0x80000u,                                                                                     /*!<  */
    mmu_mmu_per_space__per_bifr_fan1 = 0x100000u,                                                                                      /*!<  */
    mmu_mmu_per_space__per_bifr_fan2 = 0x200000u,                                                                                      /*!<  */
    mmu_mmu_per_space__per_bifr_ts = 0x400000u,                                                                                        /*!<  */
    mmu_mmu_per_space__per_bifr_tlmcom = 0x800000u,                                                                                    /*!<  */
    mmu_mmu_per_space__per_bifr_faultcom = 0x1000000u,                                                                                 /*!<  */
    mmu_mmu_per_space__per_bifr_test = 0x2000000u,                                                                                     /*!<  */
    mmu_mmu_per_space__per_bifr_teststat = 0x4000000u,                                                                                 /*!<  */
    mmu_mmu_per_space__per_bifr_cse = 0x8000000u                                                                                       /*!<  */
} mmu_mmu_per_space__per_t;

#define MMU_MMU_PER_SPACE__PER__Pos                             0                                                                      /*!< Right-most bit position of PER in MMU.MMU_PER_SPACE */
#define MMU_MMU_PER_SPACE__PER__Msk                             (0x0FFFFFFFUL << MMU_MMU_PER_SPACE__PER__Pos)                          /*!< Mask for PER in MMU.MMU_PER_SPACE */
#define MMU_MMU_PER_SPACE__PER__Shift(v)                        (((v) << MMU_MMU_PER_SPACE__PER__Pos) & MMU_MMU_PER_SPACE__PER__Msk)   /*!< Shift value 'v' into PER and mask 'v' to fit it into PER field */

/** MMU_MMU_PER_SPACE__PER__SET() sets MMU_PER_SPACE.PER to given value.
 *
 * When writing to MMU_PER_SPACE.PER, this is recommended to use.
 *
 * @param bf_value new value for MMU_PER_SPACE.PER
 */
__MMU_INLINE void MMU_MMU_PER_SPACE__PER__SET(mmu_mmu_per_space__per_t bf_value)
{
    uint32_t reg = MMU_MMU_PER_SPACE__GET();
    reg = (reg & ~MMU_MMU_PER_SPACE__PER__Msk);
    reg = (reg | (MMU_MMU_PER_SPACE__PER__Shift((uint32_t)bf_value)));
    MMU_MMU_PER_SPACE__SET(reg);
}

/** MMU_MMU_PER_SPACE__PER__GET() gets MMU_PER_SPACE.PER's current value.
 *
 * When reading from MMU_PER_SPACE.PER, this is recommended to use.
 *
 * @return current value of MMU_PER_SPACE.PER
 */
__MMU_INLINE mmu_mmu_per_space__per_t MMU_MMU_PER_SPACE__PER__GET(void)
{
    uint32_t reg = MMU_MMU_PER_SPACE__GET();
    reg = (reg & MMU_MMU_PER_SPACE__PER__Msk);
    reg = (reg >> MMU_MMU_PER_SPACE__PER__Pos);
    return (mmu_mmu_per_space__per_t)reg;
}

/** MMU_MMU_PER_SPACE__PER__MODIFY() modifies MMU_PER_SPACE.PER.
 *
 * This is recommended to use when setting more than one bitfield of MMU.MMU_PER_SPACE.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of MMU.MMU_PER_SPACE
 * @param bf_value new value for MMU_PER_SPACE.PER
 * @return new value of MMU.MMU_PER_SPACE
 */
__MMU_INLINE uint32_t MMU_MMU_PER_SPACE__PER__MODIFY(uint32_t reg, mmu_mmu_per_space__per_t bf_value)
{
    reg = (reg & ~MMU_MMU_PER_SPACE__PER__Msk);
    reg = (reg | (MMU_MMU_PER_SPACE__PER__Shift((uint32_t)bf_value)));
    return reg;
}

/** MMU_MMU_PER_SPACE__PER__EXTRACT() extracts MMU_PER_SPACE.PER.
 *
 * This is recommended to use when extracting more than one bitfield from MMU.MMU_PER_SPACE.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of MMU.MMU_PER_SPACE
 * @return current value of MMU_PER_SPACE.PER
 */
__MMU_INLINE mmu_mmu_per_space__per_t MMU_MMU_PER_SPACE__PER__EXTRACT(uint32_t reg)
{
    reg = (reg & MMU_MMU_PER_SPACE__PER__Msk);
    reg = (reg >> MMU_MMU_PER_SPACE__PER__Pos);
    return (mmu_mmu_per_space__per_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     MMU_PER_SPACE_SET member of MMU_t                     */
/* -------------------------------------------------------------------------- */

/** __MMU_MMU_PER_SPACE_SET__ADDRESS returns the address of member MMU_PER_SPACE_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MMU_PER_SPACE_SET
 */
__MMU_INLINE uint32_t* __MMU_MMU_PER_SPACE_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__MMU_BASE_PTR() + (uint32_t)(offsetof(MMU_t, MMU_PER_SPACE_SET)));
}

/** MMU_MMU_PER_SPACE_SET__SET() sets MMU_PER_SPACE_SET to given value.
 *
 * When writing to MMU_PER_SPACE_SET, this is mandatory to use.
 *
 * @param value new value for MMU_PER_SPACE_SET
 */
__MMU_INLINE void MMU_MMU_PER_SPACE_SET__SET(uint32_t value)
{
    HAL_SET32(__MMU_MMU_PER_SPACE_SET__ADDRESS(), value);
}


/* ----------------------- MMU.MMU_PER_SPACE_SET.PER ----------------------- */


/*lint -parent(uint32_t, mmu_mmu_per_space_set__per_t) -strong(AJX)*/
typedef enum mmu_mmu_per_space_set__per_e                                                                                              /*!<  */
{
    mmu_mmu_per_space_set__per_none = 0x1u,                                                                                            /*!<  */
    mmu_mmu_per_space_set__per_cpup = 0x2u,                                                                                            /*!<  */
    mmu_mmu_per_space_set__per_bifp = 0x4u,                                                                                            /*!<  */
    mmu_mmu_per_space_set__per_bifr_trim = 0x8u,                                                                                       /*!<  */
    mmu_mmu_per_space_set__per_bifr_ana = 0x10u,                                                                                       /*!<  */
    mmu_mmu_per_space_set__per_bifr_vsp0 = 0x20u,                                                                                      /*!<  */
    mmu_mmu_per_space_set__per_bifr_vsp1 = 0x40u,                                                                                      /*!<  */
    mmu_mmu_per_space_set__per_bifr_vsp2 = 0x80u,                                                                                      /*!<  */
    mmu_mmu_per_space_set__per_bifr_vctrl0 = 0x100u,                                                                                   /*!<  */
    mmu_mmu_per_space_set__per_bifr_vctrl1 = 0x200u,                                                                                   /*!<  */
    mmu_mmu_per_space_set__per_bifr_pid0 = 0x400u,                                                                                     /*!<  */
    mmu_mmu_per_space_set__per_bifr_pid1 = 0x800u,                                                                                     /*!<  */
    mmu_mmu_per_space_set__per_bifr_isp0 = 0x1000u,                                                                                    /*!<  */
    mmu_mmu_per_space_set__per_bifr_isp1 = 0x2000u,                                                                                    /*!<  */
    mmu_mmu_per_space_set__per_bifr_pwm = 0x4000u,                                                                                     /*!<  */
    mmu_mmu_per_space_set__per_bifr_comm = 0x8000u,                                                                                    /*!<  */
    mmu_mmu_per_space_set__per_bifr_telem0 = 0x10000u,                                                                                 /*!<  */
    mmu_mmu_per_space_set__per_bifr_telem1 = 0x20000u,                                                                                 /*!<  */
    mmu_mmu_per_space_set__per_bifr_fault0 = 0x40000u,                                                                                 /*!<  */
    mmu_mmu_per_space_set__per_bifr_fault1 = 0x80000u,                                                                                 /*!<  */
    mmu_mmu_per_space_set__per_bifr_fan1 = 0x100000u,                                                                                  /*!<  */
    mmu_mmu_per_space_set__per_bifr_fan2 = 0x200000u,                                                                                  /*!<  */
    mmu_mmu_per_space_set__per_bifr_ts = 0x400000u,                                                                                    /*!<  */
    mmu_mmu_per_space_set__per_bifr_tlmcom = 0x800000u,                                                                                /*!<  */
    mmu_mmu_per_space_set__per_bifr_faultcom = 0x1000000u,                                                                             /*!<  */
    mmu_mmu_per_space_set__per_bifr_test = 0x2000000u,                                                                                 /*!<  */
    mmu_mmu_per_space_set__per_bifr_teststat = 0x4000000u,                                                                             /*!<  */
    mmu_mmu_per_space_set__per_bifr_cse = 0x8000000u                                                                                   /*!<  */
} mmu_mmu_per_space_set__per_t;

#define MMU_MMU_PER_SPACE_SET__PER__Pos                         0                                                                      /*!< Right-most bit position of PER in MMU.MMU_PER_SPACE_SET */
#define MMU_MMU_PER_SPACE_SET__PER__Msk                         (0x0FFFFFFFUL << MMU_MMU_PER_SPACE_SET__PER__Pos)                      /*!< Mask for PER in MMU.MMU_PER_SPACE_SET */
#define MMU_MMU_PER_SPACE_SET__PER__Shift(v)                    (((v) << MMU_MMU_PER_SPACE_SET__PER__Pos) & MMU_MMU_PER_SPACE_SET__PER__Msk) /*!< Shift value 'v' into PER and mask 'v' to fit it into PER field */

/** MMU_MMU_PER_SPACE_SET__PER__SET() sets MMU_PER_SPACE_SET.PER to given value.
 *
 * When writing to MMU_PER_SPACE_SET.PER, this is recommended to use.
 *
 * @param bf_value new value for MMU_PER_SPACE_SET.PER
 */
__MMU_INLINE void MMU_MMU_PER_SPACE_SET__PER__SET(mmu_mmu_per_space_set__per_t bf_value)
{
    uint32_t reg = MMU_MMU_PER_SPACE_SET__PER__Shift((uint32_t)bf_value);
    MMU_MMU_PER_SPACE_SET__SET(reg);
}


/** MMU_MMU_PER_SPACE_SET__PER__MODIFY() modifies MMU_PER_SPACE_SET.PER.
 *
 * This is recommended to use when setting more than one bitfield of MMU.MMU_PER_SPACE_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of MMU.MMU_PER_SPACE_SET
 * @param bf_value new value for MMU_PER_SPACE_SET.PER
 * @return new value of MMU.MMU_PER_SPACE_SET
 */
__MMU_INLINE uint32_t MMU_MMU_PER_SPACE_SET__PER__MODIFY(uint32_t reg, mmu_mmu_per_space_set__per_t bf_value)
{
    reg = (reg & ~MMU_MMU_PER_SPACE_SET__PER__Msk);
    reg = (reg | (MMU_MMU_PER_SPACE_SET__PER__Shift((uint32_t)bf_value)));
    return reg;
}

/** MMU_MMU_PER_SPACE_SET__PER__EXTRACT() extracts MMU_PER_SPACE_SET.PER.
 *
 * This is recommended to use when extracting more than one bitfield from MMU.MMU_PER_SPACE_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of MMU.MMU_PER_SPACE_SET
 * @return current value of MMU_PER_SPACE_SET.PER
 */
__MMU_INLINE mmu_mmu_per_space_set__per_t MMU_MMU_PER_SPACE_SET__PER__EXTRACT(uint32_t reg)
{
    reg = (reg & MMU_MMU_PER_SPACE_SET__PER__Msk);
    reg = (reg >> MMU_MMU_PER_SPACE_SET__PER__Pos);
    return (mmu_mmu_per_space_set__per_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     MMU_PER_SPACE_CLR member of MMU_t                     */
/* -------------------------------------------------------------------------- */

/** __MMU_MMU_PER_SPACE_CLR__ADDRESS returns the address of member MMU_PER_SPACE_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MMU_PER_SPACE_CLR
 */
__MMU_INLINE uint32_t* __MMU_MMU_PER_SPACE_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__MMU_BASE_PTR() + (uint32_t)(offsetof(MMU_t, MMU_PER_SPACE_CLR)));
}

/** MMU_MMU_PER_SPACE_CLR__SET() sets MMU_PER_SPACE_CLR to given value.
 *
 * When writing to MMU_PER_SPACE_CLR, this is mandatory to use.
 *
 * @param value new value for MMU_PER_SPACE_CLR
 */
__MMU_INLINE void MMU_MMU_PER_SPACE_CLR__SET(uint32_t value)
{
    HAL_SET32(__MMU_MMU_PER_SPACE_CLR__ADDRESS(), value);
}


/* ----------------------- MMU.MMU_PER_SPACE_CLR.PER ----------------------- */


/*lint -parent(uint32_t, mmu_mmu_per_space_clr__per_t) -strong(AJX)*/
typedef enum mmu_mmu_per_space_clr__per_e                                                                                              /*!<  */
{
    mmu_mmu_per_space_clr__per_none = 0x1u,                                                                                            /*!<  */
    mmu_mmu_per_space_clr__per_cpup = 0x2u,                                                                                            /*!<  */
    mmu_mmu_per_space_clr__per_bifp = 0x4u,                                                                                            /*!<  */
    mmu_mmu_per_space_clr__per_bifr_trim = 0x8u,                                                                                       /*!<  */
    mmu_mmu_per_space_clr__per_bifr_ana = 0x10u,                                                                                       /*!<  */
    mmu_mmu_per_space_clr__per_bifr_vsp0 = 0x20u,                                                                                      /*!<  */
    mmu_mmu_per_space_clr__per_bifr_vsp1 = 0x40u,                                                                                      /*!<  */
    mmu_mmu_per_space_clr__per_bifr_vsp2 = 0x80u,                                                                                      /*!<  */
    mmu_mmu_per_space_clr__per_bifr_vctrl0 = 0x100u,                                                                                   /*!<  */
    mmu_mmu_per_space_clr__per_bifr_vctrl1 = 0x200u,                                                                                   /*!<  */
    mmu_mmu_per_space_clr__per_bifr_pid0 = 0x400u,                                                                                     /*!<  */
    mmu_mmu_per_space_clr__per_bifr_pid1 = 0x800u,                                                                                     /*!<  */
    mmu_mmu_per_space_clr__per_bifr_isp0 = 0x1000u,                                                                                    /*!<  */
    mmu_mmu_per_space_clr__per_bifr_isp1 = 0x2000u,                                                                                    /*!<  */
    mmu_mmu_per_space_clr__per_bifr_pwm = 0x4000u,                                                                                     /*!<  */
    mmu_mmu_per_space_clr__per_bifr_comm = 0x8000u,                                                                                    /*!<  */
    mmu_mmu_per_space_clr__per_bifr_telem0 = 0x10000u,                                                                                 /*!<  */
    mmu_mmu_per_space_clr__per_bifr_telem1 = 0x20000u,                                                                                 /*!<  */
    mmu_mmu_per_space_clr__per_bifr_fault0 = 0x40000u,                                                                                 /*!<  */
    mmu_mmu_per_space_clr__per_bifr_fault1 = 0x80000u,                                                                                 /*!<  */
    mmu_mmu_per_space_clr__per_bifr_fan1 = 0x100000u,                                                                                  /*!<  */
    mmu_mmu_per_space_clr__per_bifr_fan2 = 0x200000u,                                                                                  /*!<  */
    mmu_mmu_per_space_clr__per_bifr_ts = 0x400000u,                                                                                    /*!<  */
    mmu_mmu_per_space_clr__per_bifr_tlmcom = 0x800000u,                                                                                /*!<  */
    mmu_mmu_per_space_clr__per_bifr_faultcom = 0x1000000u,                                                                             /*!<  */
    mmu_mmu_per_space_clr__per_bifr_test = 0x2000000u,                                                                                 /*!<  */
    mmu_mmu_per_space_clr__per_bifr_teststat = 0x4000000u,                                                                             /*!<  */
    mmu_mmu_per_space_clr__per_bifr_cse = 0x8000000u                                                                                   /*!<  */
} mmu_mmu_per_space_clr__per_t;

#define MMU_MMU_PER_SPACE_CLR__PER__Pos                         0                                                                      /*!< Right-most bit position of PER in MMU.MMU_PER_SPACE_CLR */
#define MMU_MMU_PER_SPACE_CLR__PER__Msk                         (0x0FFFFFFFUL << MMU_MMU_PER_SPACE_CLR__PER__Pos)                      /*!< Mask for PER in MMU.MMU_PER_SPACE_CLR */
#define MMU_MMU_PER_SPACE_CLR__PER__Shift(v)                    (((v) << MMU_MMU_PER_SPACE_CLR__PER__Pos) & MMU_MMU_PER_SPACE_CLR__PER__Msk) /*!< Shift value 'v' into PER and mask 'v' to fit it into PER field */

/** MMU_MMU_PER_SPACE_CLR__PER__SET() sets MMU_PER_SPACE_CLR.PER to given value.
 *
 * When writing to MMU_PER_SPACE_CLR.PER, this is recommended to use.
 *
 * @param bf_value new value for MMU_PER_SPACE_CLR.PER
 */
__MMU_INLINE void MMU_MMU_PER_SPACE_CLR__PER__SET(mmu_mmu_per_space_clr__per_t bf_value)
{
    uint32_t reg = MMU_MMU_PER_SPACE_CLR__PER__Shift((uint32_t)bf_value);
    MMU_MMU_PER_SPACE_CLR__SET(reg);
}


/** MMU_MMU_PER_SPACE_CLR__PER__MODIFY() modifies MMU_PER_SPACE_CLR.PER.
 *
 * This is recommended to use when setting more than one bitfield of MMU.MMU_PER_SPACE_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of MMU.MMU_PER_SPACE_CLR
 * @param bf_value new value for MMU_PER_SPACE_CLR.PER
 * @return new value of MMU.MMU_PER_SPACE_CLR
 */
__MMU_INLINE uint32_t MMU_MMU_PER_SPACE_CLR__PER__MODIFY(uint32_t reg, mmu_mmu_per_space_clr__per_t bf_value)
{
    reg = (reg & ~MMU_MMU_PER_SPACE_CLR__PER__Msk);
    reg = (reg | (MMU_MMU_PER_SPACE_CLR__PER__Shift((uint32_t)bf_value)));
    return reg;
}

/** MMU_MMU_PER_SPACE_CLR__PER__EXTRACT() extracts MMU_PER_SPACE_CLR.PER.
 *
 * This is recommended to use when extracting more than one bitfield from MMU.MMU_PER_SPACE_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of MMU.MMU_PER_SPACE_CLR
 * @return current value of MMU_PER_SPACE_CLR.PER
 */
__MMU_INLINE mmu_mmu_per_space_clr__per_t MMU_MMU_PER_SPACE_CLR__PER__EXTRACT(uint32_t reg)
{
    reg = (reg & MMU_MMU_PER_SPACE_CLR__PER__Msk);
    reg = (reg >> MMU_MMU_PER_SPACE_CLR__PER__Pos);
    return (mmu_mmu_per_space_clr__per_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          MMU_CNFG member of MMU_t                          */
/* -------------------------------------------------------------------------- */

/** __MMU_MMU_CNFG__ADDRESS returns the address of member MMU_CNFG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MMU_CNFG
 */
__MMU_INLINE uint32_t* __MMU_MMU_CNFG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__MMU_BASE_PTR() + (uint32_t)(offsetof(MMU_t, MMU_CNFG)));
}

/** MMU_MMU_CNFG__SET() sets MMU_CNFG to given value.
 *
 * When writing to MMU_CNFG, this is mandatory to use.
 *
 * @param value new value for MMU_CNFG
 */
__MMU_INLINE void MMU_MMU_CNFG__SET(uint32_t value)
{
    HAL_SET32(__MMU_MMU_CNFG__ADDRESS(), value);
}

/** MMU_MMU_CNFG__GET() gets MMU_CNFG's current value.
 *
 * When reading from MMU_CNFG, this is mandatory to use.
 *
 * @return current value of MMU_CNFG
 */
__MMU_INLINE uint32_t MMU_MMU_CNFG__GET(void)
{
    return HAL_GET32(__MMU_MMU_CNFG__ADDRESS());
}

/* --------------------- MMU.MMU_CNFG.EN_LOAD_MMU_TABLE --------------------- */


#define MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Pos                    1                                                                      /*!< Right-most bit position of EN_LOAD_MMU_TABLE in MMU.MMU_CNFG */
#define MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Msk                    (0x00000001UL << MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Pos)                 /*!< Mask for EN_LOAD_MMU_TABLE in MMU.MMU_CNFG */
#define MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Shift(v)               (((v) << MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Pos) & MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Msk) /*!< Shift value 'v' into EN_LOAD_MMU_TABLE and mask 'v' to fit it into EN_LOAD_MMU_TABLE field */

/** MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__SET() sets MMU_CNFG.EN_LOAD_MMU_TABLE to given value.
 *
 * When writing to MMU_CNFG.EN_LOAD_MMU_TABLE, this is recommended to use.
 *
 * @param bf_value new value for MMU_CNFG.EN_LOAD_MMU_TABLE
 */
__MMU_INLINE void MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__SET(uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_CNFG__GET();
    reg = (reg & ~MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Msk);
    reg = (reg | (MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Shift((uint32_t)bf_value)));
    MMU_MMU_CNFG__SET(reg);
}

/** MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__GET() gets MMU_CNFG.EN_LOAD_MMU_TABLE's current value.
 *
 * When reading from MMU_CNFG.EN_LOAD_MMU_TABLE, this is recommended to use.
 *
 * @return current value of MMU_CNFG.EN_LOAD_MMU_TABLE
 */
__MMU_INLINE uint32_t MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__GET(void)
{
    uint32_t reg = MMU_MMU_CNFG__GET();
    reg = (reg & MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Msk);
    reg = (reg >> MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Pos);
    return (uint32_t)reg;
}

/** MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__MODIFY() modifies MMU_CNFG.EN_LOAD_MMU_TABLE.
 *
 * This is recommended to use when setting more than one bitfield of MMU.MMU_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of MMU.MMU_CNFG
 * @param bf_value new value for MMU_CNFG.EN_LOAD_MMU_TABLE
 * @return new value of MMU.MMU_CNFG
 */
__MMU_INLINE uint32_t MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Msk);
    reg = (reg | (MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Shift((uint32_t)bf_value)));
    return reg;
}

/** MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__EXTRACT() extracts MMU_CNFG.EN_LOAD_MMU_TABLE.
 *
 * This is recommended to use when extracting more than one bitfield from MMU.MMU_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of MMU.MMU_CNFG
 * @return current value of MMU_CNFG.EN_LOAD_MMU_TABLE
 */
__MMU_INLINE uint32_t MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__EXTRACT(uint32_t reg)
{
    reg = (reg & MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Msk);
    reg = (reg >> MMU_MMU_CNFG__EN_LOAD_MMU_TABLE__Pos);
    return (uint32_t)reg;
}

/* -------------------------- MMU.MMU_CNFG.EN_MMU -------------------------- */


#define MMU_MMU_CNFG__EN_MMU__Pos                               0                                                                      /*!< Right-most bit position of EN_MMU in MMU.MMU_CNFG */
#define MMU_MMU_CNFG__EN_MMU__Msk                               (0x00000001UL << MMU_MMU_CNFG__EN_MMU__Pos)                            /*!< Mask for EN_MMU in MMU.MMU_CNFG */
#define MMU_MMU_CNFG__EN_MMU__Shift(v)                          (((v) << MMU_MMU_CNFG__EN_MMU__Pos) & MMU_MMU_CNFG__EN_MMU__Msk)       /*!< Shift value 'v' into EN_MMU and mask 'v' to fit it into EN_MMU field */

/** MMU_MMU_CNFG__EN_MMU__SET() sets MMU_CNFG.EN_MMU to given value.
 *
 * When writing to MMU_CNFG.EN_MMU, this is recommended to use.
 *
 * @param bf_value new value for MMU_CNFG.EN_MMU
 */
__MMU_INLINE void MMU_MMU_CNFG__EN_MMU__SET(uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_CNFG__GET();
    reg = (reg & ~MMU_MMU_CNFG__EN_MMU__Msk);
    reg = (reg | (MMU_MMU_CNFG__EN_MMU__Shift((uint32_t)bf_value)));
    MMU_MMU_CNFG__SET(reg);
}

/** MMU_MMU_CNFG__EN_MMU__GET() gets MMU_CNFG.EN_MMU's current value.
 *
 * When reading from MMU_CNFG.EN_MMU, this is recommended to use.
 *
 * @return current value of MMU_CNFG.EN_MMU
 */
__MMU_INLINE uint32_t MMU_MMU_CNFG__EN_MMU__GET(void)
{
    uint32_t reg = MMU_MMU_CNFG__GET();
    reg = (reg & MMU_MMU_CNFG__EN_MMU__Msk);
    reg = (reg >> MMU_MMU_CNFG__EN_MMU__Pos);
    return (uint32_t)reg;
}

/** MMU_MMU_CNFG__EN_MMU__MODIFY() modifies MMU_CNFG.EN_MMU.
 *
 * This is recommended to use when setting more than one bitfield of MMU.MMU_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of MMU.MMU_CNFG
 * @param bf_value new value for MMU_CNFG.EN_MMU
 * @return new value of MMU.MMU_CNFG
 */
__MMU_INLINE uint32_t MMU_MMU_CNFG__EN_MMU__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~MMU_MMU_CNFG__EN_MMU__Msk);
    reg = (reg | (MMU_MMU_CNFG__EN_MMU__Shift((uint32_t)bf_value)));
    return reg;
}

/** MMU_MMU_CNFG__EN_MMU__EXTRACT() extracts MMU_CNFG.EN_MMU.
 *
 * This is recommended to use when extracting more than one bitfield from MMU.MMU_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of MMU.MMU_CNFG
 * @return current value of MMU_CNFG.EN_MMU
 */
__MMU_INLINE uint32_t MMU_MMU_CNFG__EN_MMU__EXTRACT(uint32_t reg)
{
    reg = (reg & MMU_MMU_CNFG__EN_MMU__Msk);
    reg = (reg >> MMU_MMU_CNFG__EN_MMU__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        MMU_ERR_RPT member of MMU_t                        */
/* -------------------------------------------------------------------------- */

/** __MMU_MMU_ERR_RPT__ADDRESS returns the address of member MMU_ERR_RPT.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MMU_ERR_RPT
 */
__MMU_INLINE uint32_t* __MMU_MMU_ERR_RPT__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__MMU_BASE_PTR() + (uint32_t)(offsetof(MMU_t, MMU_ERR_RPT)));
}

/** MMU_MMU_ERR_RPT__GET() gets MMU_ERR_RPT's current value.
 *
 * When reading from MMU_ERR_RPT, this is mandatory to use.
 *
 * @return current value of MMU_ERR_RPT
 */
__MMU_INLINE uint32_t MMU_MMU_ERR_RPT__GET(void)
{
    return HAL_GET32(__MMU_MMU_ERR_RPT__ADDRESS());
}

/* -------------------------- MMU.MMU_ERR_RPT.PROT -------------------------- */


#define MMU_MMU_ERR_RPT__PROT__Pos                              22                                                                     /*!< Right-most bit position of PROT in MMU.MMU_ERR_RPT */
#define MMU_MMU_ERR_RPT__PROT__Msk                              (0x00000001UL << MMU_MMU_ERR_RPT__PROT__Pos)                           /*!< Mask for PROT in MMU.MMU_ERR_RPT */
#define MMU_MMU_ERR_RPT__PROT__Shift(v)                         (((v) << MMU_MMU_ERR_RPT__PROT__Pos) & MMU_MMU_ERR_RPT__PROT__Msk)     /*!< Shift value 'v' into PROT and mask 'v' to fit it into PROT field */

/** MMU_MMU_ERR_RPT__PROT__GET() gets MMU_ERR_RPT.PROT's current value.
 *
 * When reading from MMU_ERR_RPT.PROT, this is recommended to use.
 *
 * @return current value of MMU_ERR_RPT.PROT
 */
__MMU_INLINE uint32_t MMU_MMU_ERR_RPT__PROT__GET(void)
{
    uint32_t reg = MMU_MMU_ERR_RPT__GET();
    reg = (reg & MMU_MMU_ERR_RPT__PROT__Msk);
    reg = (reg >> MMU_MMU_ERR_RPT__PROT__Pos);
    return (uint32_t)reg;
}

/** MMU_MMU_ERR_RPT__PROT__EXTRACT() extracts MMU_ERR_RPT.PROT.
 *
 * This is recommended to use when extracting more than one bitfield from MMU.MMU_ERR_RPT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of MMU.MMU_ERR_RPT
 * @return current value of MMU_ERR_RPT.PROT
 */
__MMU_INLINE uint32_t MMU_MMU_ERR_RPT__PROT__EXTRACT(uint32_t reg)
{
    reg = (reg & MMU_MMU_ERR_RPT__PROT__Msk);
    reg = (reg >> MMU_MMU_ERR_RPT__PROT__Pos);
    return (uint32_t)reg;
}

/* ------------------------ MMU.MMU_ERR_RPT.BASE_ADR ------------------------ */


#define MMU_MMU_ERR_RPT__BASE_ADR__Pos                          7                                                                      /*!< Right-most bit position of BASE_ADR in MMU.MMU_ERR_RPT */
#define MMU_MMU_ERR_RPT__BASE_ADR__Msk                          (0x00007FFFUL << MMU_MMU_ERR_RPT__BASE_ADR__Pos)                       /*!< Mask for BASE_ADR in MMU.MMU_ERR_RPT */
#define MMU_MMU_ERR_RPT__BASE_ADR__Shift(v)                     (((v) << MMU_MMU_ERR_RPT__BASE_ADR__Pos) & MMU_MMU_ERR_RPT__BASE_ADR__Msk) /*!< Shift value 'v' into BASE_ADR and mask 'v' to fit it into BASE_ADR field */

/** MMU_MMU_ERR_RPT__BASE_ADR__GET() gets MMU_ERR_RPT.BASE_ADR's current value.
 *
 * When reading from MMU_ERR_RPT.BASE_ADR, this is recommended to use.
 *
 * @return current value of MMU_ERR_RPT.BASE_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_ERR_RPT__BASE_ADR__GET(void)
{
    uint32_t reg = MMU_MMU_ERR_RPT__GET();
    reg = (reg & MMU_MMU_ERR_RPT__BASE_ADR__Msk);
    reg = (reg >> MMU_MMU_ERR_RPT__BASE_ADR__Pos);
    return (uint32_t)reg;
}

/** MMU_MMU_ERR_RPT__BASE_ADR__EXTRACT() extracts MMU_ERR_RPT.BASE_ADR.
 *
 * This is recommended to use when extracting more than one bitfield from MMU.MMU_ERR_RPT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of MMU.MMU_ERR_RPT
 * @return current value of MMU_ERR_RPT.BASE_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_ERR_RPT__BASE_ADR__EXTRACT(uint32_t reg)
{
    reg = (reg & MMU_MMU_ERR_RPT__BASE_ADR__Msk);
    reg = (reg >> MMU_MMU_ERR_RPT__BASE_ADR__Pos);
    return (uint32_t)reg;
}

/* ------------------------ MMU.MMU_ERR_RPT.BLK_ADR ------------------------ */


#define MMU_MMU_ERR_RPT__BLK_ADR__Pos                           0                                                                      /*!< Right-most bit position of BLK_ADR in MMU.MMU_ERR_RPT */
#define MMU_MMU_ERR_RPT__BLK_ADR__Msk                           (0x0000007FUL << MMU_MMU_ERR_RPT__BLK_ADR__Pos)                        /*!< Mask for BLK_ADR in MMU.MMU_ERR_RPT */
#define MMU_MMU_ERR_RPT__BLK_ADR__Shift(v)                      (((v) << MMU_MMU_ERR_RPT__BLK_ADR__Pos) & MMU_MMU_ERR_RPT__BLK_ADR__Msk) /*!< Shift value 'v' into BLK_ADR and mask 'v' to fit it into BLK_ADR field */

/** MMU_MMU_ERR_RPT__BLK_ADR__GET() gets MMU_ERR_RPT.BLK_ADR's current value.
 *
 * When reading from MMU_ERR_RPT.BLK_ADR, this is recommended to use.
 *
 * @return current value of MMU_ERR_RPT.BLK_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_ERR_RPT__BLK_ADR__GET(void)
{
    uint32_t reg = MMU_MMU_ERR_RPT__GET();
    reg = (reg & MMU_MMU_ERR_RPT__BLK_ADR__Msk);
    reg = (reg >> MMU_MMU_ERR_RPT__BLK_ADR__Pos);
    return (uint32_t)reg;
}

/** MMU_MMU_ERR_RPT__BLK_ADR__EXTRACT() extracts MMU_ERR_RPT.BLK_ADR.
 *
 * This is recommended to use when extracting more than one bitfield from MMU.MMU_ERR_RPT.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of MMU.MMU_ERR_RPT
 * @return current value of MMU_ERR_RPT.BLK_ADR
 */
__MMU_INLINE uint32_t MMU_MMU_ERR_RPT__BLK_ADR__EXTRACT(uint32_t reg)
{
    reg = (reg & MMU_MMU_ERR_RPT__BLK_ADR__Msk);
    reg = (reg >> MMU_MMU_ERR_RPT__BLK_ADR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      MMU_ERR_RPT_CLR member of MMU_t                      */
/* -------------------------------------------------------------------------- */

/** __MMU_MMU_ERR_RPT_CLR__ADDRESS returns the address of member MMU_ERR_RPT_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of MMU_ERR_RPT_CLR
 */
__MMU_INLINE uint32_t* __MMU_MMU_ERR_RPT_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__MMU_BASE_PTR() + (uint32_t)(offsetof(MMU_t, MMU_ERR_RPT_CLR)));
}

/** MMU_MMU_ERR_RPT_CLR__SET() sets MMU_ERR_RPT_CLR to given value.
 *
 * When writing to MMU_ERR_RPT_CLR, this is mandatory to use.
 *
 * @param value new value for MMU_ERR_RPT_CLR
 */
__MMU_INLINE void MMU_MMU_ERR_RPT_CLR__SET(uint32_t value)
{
    HAL_SET32(__MMU_MMU_ERR_RPT_CLR__ADDRESS(), value);
}


/* ------------------------ MMU.MMU_ERR_RPT_CLR.CLR ------------------------ */


#define MMU_MMU_ERR_RPT_CLR__CLR__Pos                           0                                                                      /*!< Right-most bit position of CLR in MMU.MMU_ERR_RPT_CLR */
#define MMU_MMU_ERR_RPT_CLR__CLR__Msk                           (0x00000001UL << MMU_MMU_ERR_RPT_CLR__CLR__Pos)                        /*!< Mask for CLR in MMU.MMU_ERR_RPT_CLR */
#define MMU_MMU_ERR_RPT_CLR__CLR__Shift(v)                      (((v) << MMU_MMU_ERR_RPT_CLR__CLR__Pos) & MMU_MMU_ERR_RPT_CLR__CLR__Msk) /*!< Shift value 'v' into CLR and mask 'v' to fit it into CLR field */

/** MMU_MMU_ERR_RPT_CLR__CLR__SET() sets MMU_ERR_RPT_CLR.CLR to given value.
 *
 * When writing to MMU_ERR_RPT_CLR.CLR, this is recommended to use.
 *
 * @param bf_value new value for MMU_ERR_RPT_CLR.CLR
 */
__MMU_INLINE void MMU_MMU_ERR_RPT_CLR__CLR__SET(uint32_t bf_value)
{
    uint32_t reg = MMU_MMU_ERR_RPT_CLR__CLR__Shift((uint32_t)bf_value);
    MMU_MMU_ERR_RPT_CLR__SET(reg);
}


/** MMU_MMU_ERR_RPT_CLR__CLR__MODIFY() modifies MMU_ERR_RPT_CLR.CLR.
 *
 * This is recommended to use when setting more than one bitfield of MMU.MMU_ERR_RPT_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of MMU.MMU_ERR_RPT_CLR
 * @param bf_value new value for MMU_ERR_RPT_CLR.CLR
 * @return new value of MMU.MMU_ERR_RPT_CLR
 */
__MMU_INLINE uint32_t MMU_MMU_ERR_RPT_CLR__CLR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~MMU_MMU_ERR_RPT_CLR__CLR__Msk);
    reg = (reg | (MMU_MMU_ERR_RPT_CLR__CLR__Shift((uint32_t)bf_value)));
    return reg;
}

/** MMU_MMU_ERR_RPT_CLR__CLR__EXTRACT() extracts MMU_ERR_RPT_CLR.CLR.
 *
 * This is recommended to use when extracting more than one bitfield from MMU.MMU_ERR_RPT_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of MMU.MMU_ERR_RPT_CLR
 * @return current value of MMU_ERR_RPT_CLR.CLR
 */
__MMU_INLINE uint32_t MMU_MMU_ERR_RPT_CLR__CLR__EXTRACT(uint32_t reg)
{
    reg = (reg & MMU_MMU_ERR_RPT_CLR__CLR__Msk);
    reg = (reg >> MMU_MMU_ERR_RPT_CLR__CLR__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group mmu block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_MMU_H_ */
