/**
 * @file     shasta_hal_uart.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_UART_H_
#define _SHASTA_HAL_UART_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup uart
 * @{
 */

#if defined ( __CC_ARM )
#define __UART_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __UART_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __UART_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __UART_INLINE  static inline
#endif

/** register file of the uart block.
 */
typedef struct _UART_s
{
    volatile        uint32_t        UARTDR                      ; /*!< (@0x00000000) UART Data Register */
    volatile        uint32_t        UARTRSR_UARTECR             ; /*!< (@0x00000004) Receive Status Register/Error Clear Register */
    volatile        uint8_t         REGMEMGAP0[16]              ; /*!< (@0x00000008) gap in address space */
    volatile        uint32_t        UARTFR                      ; /*!< (@0x00000018) Flag Register */
    volatile        uint8_t         REGMEMGAP1[4]               ; /*!< (@0x0000001C) gap in address space */
    volatile        uint32_t        UARTILPR                    ; /*!< (@0x00000020) IrDA Low-Power Counter Register */
    volatile        uint32_t        UARTIBRD                    ; /*!< (@0x00000024) Integer Baud Rate Register */
    volatile        uint32_t        UARTFBRD                    ; /*!< (@0x00000028) Fractional Baud Rate Register */
    volatile        uint32_t        UARTLCR_H                   ; /*!< (@0x0000002C) Line Control Register */
    volatile        uint32_t        UARTCR                      ; /*!< (@0x00000030) Control Register */
    volatile        uint32_t        UARTIFLS                    ; /*!< (@0x00000034) Interrupt FIFO Level Select Register */
    volatile        uint32_t        UARTIMSC                    ; /*!< (@0x00000038) Interrupt Mask Set/Clear Register */
    volatile        uint32_t        UARTRIS                     ; /*!< (@0x0000003C) Raw Interrupt Status Register */
    volatile        uint32_t        UARTMIS                     ; /*!< (@0x00000040) Masked Interrupt Status Register */
    volatile        uint32_t        UARTICR                     ; /*!< (@0x00000044) Interrupt Clear Register */
    volatile        uint32_t        UARTDMACR                   ; /*!< (@0x00000048) DMA Control Register */
    volatile        uint8_t         REGMEMGAP2[3988]            ; /*!< (@0x0000004C) gap in address space */
    volatile        uint32_t        UARTPERIPHID0               ; /*!< (@0x00000FE0) Peripheral Identification Register */
    volatile        uint32_t        UARTPERIPHID1               ; /*!< (@0x00000FE4) Peripheral Identification Register */
    volatile        uint32_t        UARTPERIPHID2               ; /*!< (@0x00000FE8) Peripheral Identification Register */
    volatile        uint32_t        UARTPERIPHID3               ; /*!< (@0x00000FEC) Peripheral Identification Register */
    volatile        uint32_t        UARTPCELLID0                ; /*!< (@0x00000FF0) PrimeCell Identification Register */
    volatile        uint32_t        UARTPCELLID1                ; /*!< (@0x00000FF4) PrimeCell Identification Register */
    volatile        uint32_t        UARTPCELLID2                ; /*!< (@0x00000FF8) PrimeCell Identification Register */
    volatile        uint32_t        UARTPCELLID3                ; /*!< (@0x00000FFC) PrimeCell Identification Register */
} UART_t;


#define UART_BASE (0x700C0000u)                                                          /*!< uart base address */

/** __UART_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__UART_INLINE uint32_t* __UART_BASE_PTR(void)
{
    return (uint32_t*)(UART_BASE);
}


/* -------------------------------------------------------------------------- */
/*                          UARTDR member of UART_t                          */
/* -------------------------------------------------------------------------- */

/** __UART_UARTDR__ADDRESS returns the address of member UARTDR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTDR
 */
__UART_INLINE uint32_t* __UART_UARTDR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTDR)));
}

/** UART_UARTDR__SET() sets UARTDR to given value.
 *
 * When writing to UARTDR, this is mandatory to use.
 *
 * @param value new value for UARTDR
 */
__UART_INLINE void UART_UARTDR__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTDR__ADDRESS(), value);
}

/** UART_UARTDR__GET() gets UARTDR's current value.
 *
 * When reading from UARTDR, this is mandatory to use.
 *
 * @return current value of UARTDR
 */
__UART_INLINE uint32_t UART_UARTDR__GET(void)
{
    return HAL_GET32(__UART_UARTDR__ADDRESS());
}

/* ----------------------------- UART.UARTDR.OE ----------------------------- */

/**
<pre>
  UART.UARTDR.OE:

    Overrun Error

</pre> */

#define UART_UARTDR__OE__Pos                                    11                                                                     /*!< Right-most bit position of OE in UART.UARTDR */
#define UART_UARTDR__OE__Msk                                    (0x00000001UL << UART_UARTDR__OE__Pos)                                 /*!< Mask for OE in UART.UARTDR */
#define UART_UARTDR__OE__Shift(v)                               (((v) << UART_UARTDR__OE__Pos) & UART_UARTDR__OE__Msk)                 /*!< Shift value 'v' into OE and mask 'v' to fit it into OE field */

/** UART_UARTDR__OE__GET() gets UARTDR.OE's current value.
 *
 * When reading from UARTDR.OE, this is recommended to use.
 *
 * @return current value of UARTDR.OE
 */
__UART_INLINE uint32_t UART_UARTDR__OE__GET(void)
{
    uint32_t reg = UART_UARTDR__GET();
    reg = (reg & UART_UARTDR__OE__Msk);
    reg = (reg >> UART_UARTDR__OE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTDR__OE__EXTRACT() extracts UARTDR.OE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTDR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTDR
 * @return current value of UARTDR.OE
 */
__UART_INLINE uint32_t UART_UARTDR__OE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTDR__OE__Msk);
    reg = (reg >> UART_UARTDR__OE__Pos);
    return (uint32_t)reg;
}

/* ----------------------------- UART.UARTDR.BE ----------------------------- */

/**
<pre>
  UART.UARTDR.BE:

    Break Error

</pre> */

#define UART_UARTDR__BE__Pos                                    10                                                                     /*!< Right-most bit position of BE in UART.UARTDR */
#define UART_UARTDR__BE__Msk                                    (0x00000001UL << UART_UARTDR__BE__Pos)                                 /*!< Mask for BE in UART.UARTDR */
#define UART_UARTDR__BE__Shift(v)                               (((v) << UART_UARTDR__BE__Pos) & UART_UARTDR__BE__Msk)                 /*!< Shift value 'v' into BE and mask 'v' to fit it into BE field */

/** UART_UARTDR__BE__GET() gets UARTDR.BE's current value.
 *
 * When reading from UARTDR.BE, this is recommended to use.
 *
 * @return current value of UARTDR.BE
 */
__UART_INLINE uint32_t UART_UARTDR__BE__GET(void)
{
    uint32_t reg = UART_UARTDR__GET();
    reg = (reg & UART_UARTDR__BE__Msk);
    reg = (reg >> UART_UARTDR__BE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTDR__BE__EXTRACT() extracts UARTDR.BE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTDR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTDR
 * @return current value of UARTDR.BE
 */
__UART_INLINE uint32_t UART_UARTDR__BE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTDR__BE__Msk);
    reg = (reg >> UART_UARTDR__BE__Pos);
    return (uint32_t)reg;
}

/* ----------------------------- UART.UARTDR.PE ----------------------------- */

/**
<pre>
  UART.UARTDR.PE:

    Parity Error

</pre> */

#define UART_UARTDR__PE__Pos                                    9                                                                      /*!< Right-most bit position of PE in UART.UARTDR */
#define UART_UARTDR__PE__Msk                                    (0x00000001UL << UART_UARTDR__PE__Pos)                                 /*!< Mask for PE in UART.UARTDR */
#define UART_UARTDR__PE__Shift(v)                               (((v) << UART_UARTDR__PE__Pos) & UART_UARTDR__PE__Msk)                 /*!< Shift value 'v' into PE and mask 'v' to fit it into PE field */

/** UART_UARTDR__PE__GET() gets UARTDR.PE's current value.
 *
 * When reading from UARTDR.PE, this is recommended to use.
 *
 * @return current value of UARTDR.PE
 */
__UART_INLINE uint32_t UART_UARTDR__PE__GET(void)
{
    uint32_t reg = UART_UARTDR__GET();
    reg = (reg & UART_UARTDR__PE__Msk);
    reg = (reg >> UART_UARTDR__PE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTDR__PE__EXTRACT() extracts UARTDR.PE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTDR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTDR
 * @return current value of UARTDR.PE
 */
__UART_INLINE uint32_t UART_UARTDR__PE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTDR__PE__Msk);
    reg = (reg >> UART_UARTDR__PE__Pos);
    return (uint32_t)reg;
}

/* ----------------------------- UART.UARTDR.FE ----------------------------- */

/**
<pre>
  UART.UARTDR.FE:

    Framing Error

</pre> */

#define UART_UARTDR__FE__Pos                                    8                                                                      /*!< Right-most bit position of FE in UART.UARTDR */
#define UART_UARTDR__FE__Msk                                    (0x00000001UL << UART_UARTDR__FE__Pos)                                 /*!< Mask for FE in UART.UARTDR */
#define UART_UARTDR__FE__Shift(v)                               (((v) << UART_UARTDR__FE__Pos) & UART_UARTDR__FE__Msk)                 /*!< Shift value 'v' into FE and mask 'v' to fit it into FE field */

/** UART_UARTDR__FE__GET() gets UARTDR.FE's current value.
 *
 * When reading from UARTDR.FE, this is recommended to use.
 *
 * @return current value of UARTDR.FE
 */
__UART_INLINE uint32_t UART_UARTDR__FE__GET(void)
{
    uint32_t reg = UART_UARTDR__GET();
    reg = (reg & UART_UARTDR__FE__Msk);
    reg = (reg >> UART_UARTDR__FE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTDR__FE__EXTRACT() extracts UARTDR.FE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTDR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTDR
 * @return current value of UARTDR.FE
 */
__UART_INLINE uint32_t UART_UARTDR__FE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTDR__FE__Msk);
    reg = (reg >> UART_UARTDR__FE__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTDR.DATA ---------------------------- */

/**
<pre>
  UART.UARTDR.DATA:

    Data Character

</pre> */

#define UART_UARTDR__DATA__Pos                                  0                                                                      /*!< Right-most bit position of DATA in UART.UARTDR */
#define UART_UARTDR__DATA__Msk                                  (0x000000FFUL << UART_UARTDR__DATA__Pos)                               /*!< Mask for DATA in UART.UARTDR */
#define UART_UARTDR__DATA__Shift(v)                             (((v) << UART_UARTDR__DATA__Pos) & UART_UARTDR__DATA__Msk)             /*!< Shift value 'v' into DATA and mask 'v' to fit it into DATA field */

/** UART_UARTDR__DATA__SET() sets UARTDR.DATA to given value.
 *
 * When writing to UARTDR.DATA, this is recommended to use.
 *
 * @param bf_value new value for UARTDR.DATA
 */
__UART_INLINE void UART_UARTDR__DATA__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTDR__GET();
    reg = (reg & ~UART_UARTDR__DATA__Msk);
    reg = (reg | (UART_UARTDR__DATA__Shift((uint32_t)bf_value)));
    UART_UARTDR__SET(reg);
}

/** UART_UARTDR__DATA__GET() gets UARTDR.DATA's current value.
 *
 * When reading from UARTDR.DATA, this is recommended to use.
 *
 * @return current value of UARTDR.DATA
 */
__UART_INLINE uint32_t UART_UARTDR__DATA__GET(void)
{
    uint32_t reg = UART_UARTDR__GET();
    reg = (reg & UART_UARTDR__DATA__Msk);
    reg = (reg >> UART_UARTDR__DATA__Pos);
    return (uint32_t)reg;
}

/** UART_UARTDR__DATA__MODIFY() modifies UARTDR.DATA.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTDR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTDR
 * @param bf_value new value for UARTDR.DATA
 * @return new value of UART.UARTDR
 */
__UART_INLINE uint32_t UART_UARTDR__DATA__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTDR__DATA__Msk);
    reg = (reg | (UART_UARTDR__DATA__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTDR__DATA__EXTRACT() extracts UARTDR.DATA.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTDR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTDR
 * @return current value of UARTDR.DATA
 */
__UART_INLINE uint32_t UART_UARTDR__DATA__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTDR__DATA__Msk);
    reg = (reg >> UART_UARTDR__DATA__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      UARTRSR_UARTECR member of UART_t                      */
/* -------------------------------------------------------------------------- */

/** __UART_UARTRSR_UARTECR__ADDRESS returns the address of member UARTRSR_UARTECR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTRSR_UARTECR
 */
__UART_INLINE uint32_t* __UART_UARTRSR_UARTECR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTRSR_UARTECR)));
}

/** UART_UARTRSR_UARTECR__SET() sets UARTRSR_UARTECR to given value.
 *
 * When writing to UARTRSR_UARTECR, this is mandatory to use.
 *
 * @param value new value for UARTRSR_UARTECR
 */
__UART_INLINE void UART_UARTRSR_UARTECR__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTRSR_UARTECR__ADDRESS(), value);
}

/** UART_UARTRSR_UARTECR__GET() gets UARTRSR_UARTECR's current value.
 *
 * When reading from UARTRSR_UARTECR, this is mandatory to use.
 *
 * @return current value of UARTRSR_UARTECR
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__GET(void)
{
    return HAL_GET32(__UART_UARTRSR_UARTECR__ADDRESS());
}

/* ------------------------ UART.UARTRSR_UARTECR.OE ------------------------ */

/**
<pre>
  UART.UARTRSR_UARTECR.OE:

    Overrun Error

</pre> */

#define UART_UARTRSR_UARTECR__OE__Pos                           3                                                                      /*!< Right-most bit position of OE in UART.UARTRSR_UARTECR */
#define UART_UARTRSR_UARTECR__OE__Msk                           (0x00000001UL << UART_UARTRSR_UARTECR__OE__Pos)                        /*!< Mask for OE in UART.UARTRSR_UARTECR */
#define UART_UARTRSR_UARTECR__OE__Shift(v)                      (((v) << UART_UARTRSR_UARTECR__OE__Pos) & UART_UARTRSR_UARTECR__OE__Msk) /*!< Shift value 'v' into OE and mask 'v' to fit it into OE field */

/** UART_UARTRSR_UARTECR__OE__SET() sets UARTRSR_UARTECR.OE to given value.
 *
 * When writing to UARTRSR_UARTECR.OE, this is recommended to use.
 *
 * @param bf_value new value for UARTRSR_UARTECR.OE
 */
__UART_INLINE void UART_UARTRSR_UARTECR__OE__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTRSR_UARTECR__GET();
    reg = (reg & ~UART_UARTRSR_UARTECR__OE__Msk);
    reg = (reg | (UART_UARTRSR_UARTECR__OE__Shift((uint32_t)bf_value)));
    UART_UARTRSR_UARTECR__SET(reg);
}

/** UART_UARTRSR_UARTECR__OE__GET() gets UARTRSR_UARTECR.OE's current value.
 *
 * When reading from UARTRSR_UARTECR.OE, this is recommended to use.
 *
 * @return current value of UARTRSR_UARTECR.OE
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__OE__GET(void)
{
    uint32_t reg = UART_UARTRSR_UARTECR__GET();
    reg = (reg & UART_UARTRSR_UARTECR__OE__Msk);
    reg = (reg >> UART_UARTRSR_UARTECR__OE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRSR_UARTECR__OE__MODIFY() modifies UARTRSR_UARTECR.OE.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTRSR_UARTECR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTRSR_UARTECR
 * @param bf_value new value for UARTRSR_UARTECR.OE
 * @return new value of UART.UARTRSR_UARTECR
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__OE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTRSR_UARTECR__OE__Msk);
    reg = (reg | (UART_UARTRSR_UARTECR__OE__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTRSR_UARTECR__OE__EXTRACT() extracts UARTRSR_UARTECR.OE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRSR_UARTECR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRSR_UARTECR
 * @return current value of UARTRSR_UARTECR.OE
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__OE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRSR_UARTECR__OE__Msk);
    reg = (reg >> UART_UARTRSR_UARTECR__OE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ UART.UARTRSR_UARTECR.BE ------------------------ */

/**
<pre>
  UART.UARTRSR_UARTECR.BE:

    Break Error

</pre> */

#define UART_UARTRSR_UARTECR__BE__Pos                           2                                                                      /*!< Right-most bit position of BE in UART.UARTRSR_UARTECR */
#define UART_UARTRSR_UARTECR__BE__Msk                           (0x00000001UL << UART_UARTRSR_UARTECR__BE__Pos)                        /*!< Mask for BE in UART.UARTRSR_UARTECR */
#define UART_UARTRSR_UARTECR__BE__Shift(v)                      (((v) << UART_UARTRSR_UARTECR__BE__Pos) & UART_UARTRSR_UARTECR__BE__Msk) /*!< Shift value 'v' into BE and mask 'v' to fit it into BE field */

/** UART_UARTRSR_UARTECR__BE__SET() sets UARTRSR_UARTECR.BE to given value.
 *
 * When writing to UARTRSR_UARTECR.BE, this is recommended to use.
 *
 * @param bf_value new value for UARTRSR_UARTECR.BE
 */
__UART_INLINE void UART_UARTRSR_UARTECR__BE__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTRSR_UARTECR__GET();
    reg = (reg & ~UART_UARTRSR_UARTECR__BE__Msk);
    reg = (reg | (UART_UARTRSR_UARTECR__BE__Shift((uint32_t)bf_value)));
    UART_UARTRSR_UARTECR__SET(reg);
}

/** UART_UARTRSR_UARTECR__BE__GET() gets UARTRSR_UARTECR.BE's current value.
 *
 * When reading from UARTRSR_UARTECR.BE, this is recommended to use.
 *
 * @return current value of UARTRSR_UARTECR.BE
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__BE__GET(void)
{
    uint32_t reg = UART_UARTRSR_UARTECR__GET();
    reg = (reg & UART_UARTRSR_UARTECR__BE__Msk);
    reg = (reg >> UART_UARTRSR_UARTECR__BE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRSR_UARTECR__BE__MODIFY() modifies UARTRSR_UARTECR.BE.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTRSR_UARTECR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTRSR_UARTECR
 * @param bf_value new value for UARTRSR_UARTECR.BE
 * @return new value of UART.UARTRSR_UARTECR
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__BE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTRSR_UARTECR__BE__Msk);
    reg = (reg | (UART_UARTRSR_UARTECR__BE__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTRSR_UARTECR__BE__EXTRACT() extracts UARTRSR_UARTECR.BE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRSR_UARTECR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRSR_UARTECR
 * @return current value of UARTRSR_UARTECR.BE
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__BE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRSR_UARTECR__BE__Msk);
    reg = (reg >> UART_UARTRSR_UARTECR__BE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ UART.UARTRSR_UARTECR.PE ------------------------ */

/**
<pre>
  UART.UARTRSR_UARTECR.PE:

    Parity Error

</pre> */

#define UART_UARTRSR_UARTECR__PE__Pos                           1                                                                      /*!< Right-most bit position of PE in UART.UARTRSR_UARTECR */
#define UART_UARTRSR_UARTECR__PE__Msk                           (0x00000001UL << UART_UARTRSR_UARTECR__PE__Pos)                        /*!< Mask for PE in UART.UARTRSR_UARTECR */
#define UART_UARTRSR_UARTECR__PE__Shift(v)                      (((v) << UART_UARTRSR_UARTECR__PE__Pos) & UART_UARTRSR_UARTECR__PE__Msk) /*!< Shift value 'v' into PE and mask 'v' to fit it into PE field */

/** UART_UARTRSR_UARTECR__PE__SET() sets UARTRSR_UARTECR.PE to given value.
 *
 * When writing to UARTRSR_UARTECR.PE, this is recommended to use.
 *
 * @param bf_value new value for UARTRSR_UARTECR.PE
 */
__UART_INLINE void UART_UARTRSR_UARTECR__PE__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTRSR_UARTECR__GET();
    reg = (reg & ~UART_UARTRSR_UARTECR__PE__Msk);
    reg = (reg | (UART_UARTRSR_UARTECR__PE__Shift((uint32_t)bf_value)));
    UART_UARTRSR_UARTECR__SET(reg);
}

/** UART_UARTRSR_UARTECR__PE__GET() gets UARTRSR_UARTECR.PE's current value.
 *
 * When reading from UARTRSR_UARTECR.PE, this is recommended to use.
 *
 * @return current value of UARTRSR_UARTECR.PE
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__PE__GET(void)
{
    uint32_t reg = UART_UARTRSR_UARTECR__GET();
    reg = (reg & UART_UARTRSR_UARTECR__PE__Msk);
    reg = (reg >> UART_UARTRSR_UARTECR__PE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRSR_UARTECR__PE__MODIFY() modifies UARTRSR_UARTECR.PE.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTRSR_UARTECR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTRSR_UARTECR
 * @param bf_value new value for UARTRSR_UARTECR.PE
 * @return new value of UART.UARTRSR_UARTECR
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__PE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTRSR_UARTECR__PE__Msk);
    reg = (reg | (UART_UARTRSR_UARTECR__PE__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTRSR_UARTECR__PE__EXTRACT() extracts UARTRSR_UARTECR.PE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRSR_UARTECR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRSR_UARTECR
 * @return current value of UARTRSR_UARTECR.PE
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__PE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRSR_UARTECR__PE__Msk);
    reg = (reg >> UART_UARTRSR_UARTECR__PE__Pos);
    return (uint32_t)reg;
}

/* ------------------------ UART.UARTRSR_UARTECR.FE ------------------------ */

/**
<pre>
  UART.UARTRSR_UARTECR.FE:

    Framing Error

</pre> */

#define UART_UARTRSR_UARTECR__FE__Pos                           0                                                                      /*!< Right-most bit position of FE in UART.UARTRSR_UARTECR */
#define UART_UARTRSR_UARTECR__FE__Msk                           (0x00000001UL << UART_UARTRSR_UARTECR__FE__Pos)                        /*!< Mask for FE in UART.UARTRSR_UARTECR */
#define UART_UARTRSR_UARTECR__FE__Shift(v)                      (((v) << UART_UARTRSR_UARTECR__FE__Pos) & UART_UARTRSR_UARTECR__FE__Msk) /*!< Shift value 'v' into FE and mask 'v' to fit it into FE field */

/** UART_UARTRSR_UARTECR__FE__SET() sets UARTRSR_UARTECR.FE to given value.
 *
 * When writing to UARTRSR_UARTECR.FE, this is recommended to use.
 *
 * @param bf_value new value for UARTRSR_UARTECR.FE
 */
__UART_INLINE void UART_UARTRSR_UARTECR__FE__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTRSR_UARTECR__GET();
    reg = (reg & ~UART_UARTRSR_UARTECR__FE__Msk);
    reg = (reg | (UART_UARTRSR_UARTECR__FE__Shift((uint32_t)bf_value)));
    UART_UARTRSR_UARTECR__SET(reg);
}

/** UART_UARTRSR_UARTECR__FE__GET() gets UARTRSR_UARTECR.FE's current value.
 *
 * When reading from UARTRSR_UARTECR.FE, this is recommended to use.
 *
 * @return current value of UARTRSR_UARTECR.FE
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__FE__GET(void)
{
    uint32_t reg = UART_UARTRSR_UARTECR__GET();
    reg = (reg & UART_UARTRSR_UARTECR__FE__Msk);
    reg = (reg >> UART_UARTRSR_UARTECR__FE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRSR_UARTECR__FE__MODIFY() modifies UARTRSR_UARTECR.FE.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTRSR_UARTECR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTRSR_UARTECR
 * @param bf_value new value for UARTRSR_UARTECR.FE
 * @return new value of UART.UARTRSR_UARTECR
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__FE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTRSR_UARTECR__FE__Msk);
    reg = (reg | (UART_UARTRSR_UARTECR__FE__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTRSR_UARTECR__FE__EXTRACT() extracts UARTRSR_UARTECR.FE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRSR_UARTECR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRSR_UARTECR
 * @return current value of UARTRSR_UARTECR.FE
 */
__UART_INLINE uint32_t UART_UARTRSR_UARTECR__FE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRSR_UARTECR__FE__Msk);
    reg = (reg >> UART_UARTRSR_UARTECR__FE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          UARTFR member of UART_t                          */
/* -------------------------------------------------------------------------- */

/** __UART_UARTFR__ADDRESS returns the address of member UARTFR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTFR
 */
__UART_INLINE uint32_t* __UART_UARTFR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTFR)));
}

/** UART_UARTFR__GET() gets UARTFR's current value.
 *
 * When reading from UARTFR, this is mandatory to use.
 *
 * @return current value of UARTFR
 */
__UART_INLINE uint32_t UART_UARTFR__GET(void)
{
    return HAL_GET32(__UART_UARTFR__ADDRESS());
}

/* ----------------------------- UART.UARTFR.RI ----------------------------- */

/**
<pre>
  UART.UARTFR.RI:

    Ring indicator

</pre> */

#define UART_UARTFR__RI__Pos                                    8                                                                      /*!< Right-most bit position of RI in UART.UARTFR */
#define UART_UARTFR__RI__Msk                                    (0x00000001UL << UART_UARTFR__RI__Pos)                                 /*!< Mask for RI in UART.UARTFR */
#define UART_UARTFR__RI__Shift(v)                               (((v) << UART_UARTFR__RI__Pos) & UART_UARTFR__RI__Msk)                 /*!< Shift value 'v' into RI and mask 'v' to fit it into RI field */

/** UART_UARTFR__RI__GET() gets UARTFR.RI's current value.
 *
 * When reading from UARTFR.RI, this is recommended to use.
 *
 * @return current value of UARTFR.RI
 */
__UART_INLINE uint32_t UART_UARTFR__RI__GET(void)
{
    uint32_t reg = UART_UARTFR__GET();
    reg = (reg & UART_UARTFR__RI__Msk);
    reg = (reg >> UART_UARTFR__RI__Pos);
    return (uint32_t)reg;
}

/** UART_UARTFR__RI__EXTRACT() extracts UARTFR.RI.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTFR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTFR
 * @return current value of UARTFR.RI
 */
__UART_INLINE uint32_t UART_UARTFR__RI__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTFR__RI__Msk);
    reg = (reg >> UART_UARTFR__RI__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTFR.TXFE ---------------------------- */

/**
<pre>
  UART.UARTFR.TXFE:

    Transmit FIFO empty

</pre> */

#define UART_UARTFR__TXFE__Pos                                  7                                                                      /*!< Right-most bit position of TXFE in UART.UARTFR */
#define UART_UARTFR__TXFE__Msk                                  (0x00000001UL << UART_UARTFR__TXFE__Pos)                               /*!< Mask for TXFE in UART.UARTFR */
#define UART_UARTFR__TXFE__Shift(v)                             (((v) << UART_UARTFR__TXFE__Pos) & UART_UARTFR__TXFE__Msk)             /*!< Shift value 'v' into TXFE and mask 'v' to fit it into TXFE field */

/** UART_UARTFR__TXFE__GET() gets UARTFR.TXFE's current value.
 *
 * When reading from UARTFR.TXFE, this is recommended to use.
 *
 * @return current value of UARTFR.TXFE
 */
__UART_INLINE uint32_t UART_UARTFR__TXFE__GET(void)
{
    uint32_t reg = UART_UARTFR__GET();
    reg = (reg & UART_UARTFR__TXFE__Msk);
    reg = (reg >> UART_UARTFR__TXFE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTFR__TXFE__EXTRACT() extracts UARTFR.TXFE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTFR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTFR
 * @return current value of UARTFR.TXFE
 */
__UART_INLINE uint32_t UART_UARTFR__TXFE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTFR__TXFE__Msk);
    reg = (reg >> UART_UARTFR__TXFE__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTFR.RXFF ---------------------------- */

/**
<pre>
  UART.UARTFR.RXFF:

    Receive FIFO full

</pre> */

#define UART_UARTFR__RXFF__Pos                                  6                                                                      /*!< Right-most bit position of RXFF in UART.UARTFR */
#define UART_UARTFR__RXFF__Msk                                  (0x00000001UL << UART_UARTFR__RXFF__Pos)                               /*!< Mask for RXFF in UART.UARTFR */
#define UART_UARTFR__RXFF__Shift(v)                             (((v) << UART_UARTFR__RXFF__Pos) & UART_UARTFR__RXFF__Msk)             /*!< Shift value 'v' into RXFF and mask 'v' to fit it into RXFF field */

/** UART_UARTFR__RXFF__GET() gets UARTFR.RXFF's current value.
 *
 * When reading from UARTFR.RXFF, this is recommended to use.
 *
 * @return current value of UARTFR.RXFF
 */
__UART_INLINE uint32_t UART_UARTFR__RXFF__GET(void)
{
    uint32_t reg = UART_UARTFR__GET();
    reg = (reg & UART_UARTFR__RXFF__Msk);
    reg = (reg >> UART_UARTFR__RXFF__Pos);
    return (uint32_t)reg;
}

/** UART_UARTFR__RXFF__EXTRACT() extracts UARTFR.RXFF.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTFR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTFR
 * @return current value of UARTFR.RXFF
 */
__UART_INLINE uint32_t UART_UARTFR__RXFF__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTFR__RXFF__Msk);
    reg = (reg >> UART_UARTFR__RXFF__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTFR.TXFF ---------------------------- */

/**
<pre>
  UART.UARTFR.TXFF:

    Transmit FIFO full

</pre> */

#define UART_UARTFR__TXFF__Pos                                  5                                                                      /*!< Right-most bit position of TXFF in UART.UARTFR */
#define UART_UARTFR__TXFF__Msk                                  (0x00000001UL << UART_UARTFR__TXFF__Pos)                               /*!< Mask for TXFF in UART.UARTFR */
#define UART_UARTFR__TXFF__Shift(v)                             (((v) << UART_UARTFR__TXFF__Pos) & UART_UARTFR__TXFF__Msk)             /*!< Shift value 'v' into TXFF and mask 'v' to fit it into TXFF field */

/** UART_UARTFR__TXFF__GET() gets UARTFR.TXFF's current value.
 *
 * When reading from UARTFR.TXFF, this is recommended to use.
 *
 * @return current value of UARTFR.TXFF
 */
__UART_INLINE uint32_t UART_UARTFR__TXFF__GET(void)
{
    uint32_t reg = UART_UARTFR__GET();
    reg = (reg & UART_UARTFR__TXFF__Msk);
    reg = (reg >> UART_UARTFR__TXFF__Pos);
    return (uint32_t)reg;
}

/** UART_UARTFR__TXFF__EXTRACT() extracts UARTFR.TXFF.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTFR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTFR
 * @return current value of UARTFR.TXFF
 */
__UART_INLINE uint32_t UART_UARTFR__TXFF__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTFR__TXFF__Msk);
    reg = (reg >> UART_UARTFR__TXFF__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTFR.RXFE ---------------------------- */

/**
<pre>
  UART.UARTFR.RXFE:

    Receive FIFO empty

</pre> */

#define UART_UARTFR__RXFE__Pos                                  4                                                                      /*!< Right-most bit position of RXFE in UART.UARTFR */
#define UART_UARTFR__RXFE__Msk                                  (0x00000001UL << UART_UARTFR__RXFE__Pos)                               /*!< Mask for RXFE in UART.UARTFR */
#define UART_UARTFR__RXFE__Shift(v)                             (((v) << UART_UARTFR__RXFE__Pos) & UART_UARTFR__RXFE__Msk)             /*!< Shift value 'v' into RXFE and mask 'v' to fit it into RXFE field */

/** UART_UARTFR__RXFE__GET() gets UARTFR.RXFE's current value.
 *
 * When reading from UARTFR.RXFE, this is recommended to use.
 *
 * @return current value of UARTFR.RXFE
 */
__UART_INLINE uint32_t UART_UARTFR__RXFE__GET(void)
{
    uint32_t reg = UART_UARTFR__GET();
    reg = (reg & UART_UARTFR__RXFE__Msk);
    reg = (reg >> UART_UARTFR__RXFE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTFR__RXFE__EXTRACT() extracts UARTFR.RXFE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTFR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTFR
 * @return current value of UARTFR.RXFE
 */
__UART_INLINE uint32_t UART_UARTFR__RXFE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTFR__RXFE__Msk);
    reg = (reg >> UART_UARTFR__RXFE__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTFR.BUSY ---------------------------- */

/**
<pre>
  UART.UARTFR.BUSY:

    UART busy

</pre> */

#define UART_UARTFR__BUSY__Pos                                  3                                                                      /*!< Right-most bit position of BUSY in UART.UARTFR */
#define UART_UARTFR__BUSY__Msk                                  (0x00000001UL << UART_UARTFR__BUSY__Pos)                               /*!< Mask for BUSY in UART.UARTFR */
#define UART_UARTFR__BUSY__Shift(v)                             (((v) << UART_UARTFR__BUSY__Pos) & UART_UARTFR__BUSY__Msk)             /*!< Shift value 'v' into BUSY and mask 'v' to fit it into BUSY field */

/** UART_UARTFR__BUSY__GET() gets UARTFR.BUSY's current value.
 *
 * When reading from UARTFR.BUSY, this is recommended to use.
 *
 * @return current value of UARTFR.BUSY
 */
__UART_INLINE uint32_t UART_UARTFR__BUSY__GET(void)
{
    uint32_t reg = UART_UARTFR__GET();
    reg = (reg & UART_UARTFR__BUSY__Msk);
    reg = (reg >> UART_UARTFR__BUSY__Pos);
    return (uint32_t)reg;
}

/** UART_UARTFR__BUSY__EXTRACT() extracts UARTFR.BUSY.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTFR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTFR
 * @return current value of UARTFR.BUSY
 */
__UART_INLINE uint32_t UART_UARTFR__BUSY__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTFR__BUSY__Msk);
    reg = (reg >> UART_UARTFR__BUSY__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTFR.DCD ---------------------------- */

/**
<pre>
  UART.UARTFR.DCD:

    Data carrier detect

</pre> */

#define UART_UARTFR__DCD__Pos                                   2                                                                      /*!< Right-most bit position of DCD in UART.UARTFR */
#define UART_UARTFR__DCD__Msk                                   (0x00000001UL << UART_UARTFR__DCD__Pos)                                /*!< Mask for DCD in UART.UARTFR */
#define UART_UARTFR__DCD__Shift(v)                              (((v) << UART_UARTFR__DCD__Pos) & UART_UARTFR__DCD__Msk)               /*!< Shift value 'v' into DCD and mask 'v' to fit it into DCD field */

/** UART_UARTFR__DCD__GET() gets UARTFR.DCD's current value.
 *
 * When reading from UARTFR.DCD, this is recommended to use.
 *
 * @return current value of UARTFR.DCD
 */
__UART_INLINE uint32_t UART_UARTFR__DCD__GET(void)
{
    uint32_t reg = UART_UARTFR__GET();
    reg = (reg & UART_UARTFR__DCD__Msk);
    reg = (reg >> UART_UARTFR__DCD__Pos);
    return (uint32_t)reg;
}

/** UART_UARTFR__DCD__EXTRACT() extracts UARTFR.DCD.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTFR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTFR
 * @return current value of UARTFR.DCD
 */
__UART_INLINE uint32_t UART_UARTFR__DCD__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTFR__DCD__Msk);
    reg = (reg >> UART_UARTFR__DCD__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTFR.DSR ---------------------------- */

/**
<pre>
  UART.UARTFR.DSR:

    Data set ready

</pre> */

#define UART_UARTFR__DSR__Pos                                   1                                                                      /*!< Right-most bit position of DSR in UART.UARTFR */
#define UART_UARTFR__DSR__Msk                                   (0x00000001UL << UART_UARTFR__DSR__Pos)                                /*!< Mask for DSR in UART.UARTFR */
#define UART_UARTFR__DSR__Shift(v)                              (((v) << UART_UARTFR__DSR__Pos) & UART_UARTFR__DSR__Msk)               /*!< Shift value 'v' into DSR and mask 'v' to fit it into DSR field */

/** UART_UARTFR__DSR__GET() gets UARTFR.DSR's current value.
 *
 * When reading from UARTFR.DSR, this is recommended to use.
 *
 * @return current value of UARTFR.DSR
 */
__UART_INLINE uint32_t UART_UARTFR__DSR__GET(void)
{
    uint32_t reg = UART_UARTFR__GET();
    reg = (reg & UART_UARTFR__DSR__Msk);
    reg = (reg >> UART_UARTFR__DSR__Pos);
    return (uint32_t)reg;
}

/** UART_UARTFR__DSR__EXTRACT() extracts UARTFR.DSR.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTFR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTFR
 * @return current value of UARTFR.DSR
 */
__UART_INLINE uint32_t UART_UARTFR__DSR__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTFR__DSR__Msk);
    reg = (reg >> UART_UARTFR__DSR__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTFR.CTS ---------------------------- */

/**
<pre>
  UART.UARTFR.CTS:

    Clear to send

</pre> */

#define UART_UARTFR__CTS__Pos                                   0                                                                      /*!< Right-most bit position of CTS in UART.UARTFR */
#define UART_UARTFR__CTS__Msk                                   (0x00000001UL << UART_UARTFR__CTS__Pos)                                /*!< Mask for CTS in UART.UARTFR */
#define UART_UARTFR__CTS__Shift(v)                              (((v) << UART_UARTFR__CTS__Pos) & UART_UARTFR__CTS__Msk)               /*!< Shift value 'v' into CTS and mask 'v' to fit it into CTS field */

/** UART_UARTFR__CTS__GET() gets UARTFR.CTS's current value.
 *
 * When reading from UARTFR.CTS, this is recommended to use.
 *
 * @return current value of UARTFR.CTS
 */
__UART_INLINE uint32_t UART_UARTFR__CTS__GET(void)
{
    uint32_t reg = UART_UARTFR__GET();
    reg = (reg & UART_UARTFR__CTS__Msk);
    reg = (reg >> UART_UARTFR__CTS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTFR__CTS__EXTRACT() extracts UARTFR.CTS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTFR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTFR
 * @return current value of UARTFR.CTS
 */
__UART_INLINE uint32_t UART_UARTFR__CTS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTFR__CTS__Msk);
    reg = (reg >> UART_UARTFR__CTS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         UARTILPR member of UART_t                         */
/* -------------------------------------------------------------------------- */

/** __UART_UARTILPR__ADDRESS returns the address of member UARTILPR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTILPR
 */
__UART_INLINE uint32_t* __UART_UARTILPR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTILPR)));
}

/** UART_UARTILPR__SET() sets UARTILPR to given value.
 *
 * When writing to UARTILPR, this is mandatory to use.
 *
 * @param value new value for UARTILPR
 */
__UART_INLINE void UART_UARTILPR__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTILPR__ADDRESS(), value);
}

/** UART_UARTILPR__GET() gets UARTILPR's current value.
 *
 * When reading from UARTILPR, this is mandatory to use.
 *
 * @return current value of UARTILPR
 */
__UART_INLINE uint32_t UART_UARTILPR__GET(void)
{
    return HAL_GET32(__UART_UARTILPR__ADDRESS());
}

/* ------------------------- UART.UARTILPR.ILPDVSR ------------------------- */

/**
<pre>
  UART.UARTILPR.ILPDVSR:

    8-bit low-power divisor value

</pre> */

#define UART_UARTILPR__ILPDVSR__Pos                             0                                                                      /*!< Right-most bit position of ILPDVSR in UART.UARTILPR */
#define UART_UARTILPR__ILPDVSR__Msk                             (0x000000FFUL << UART_UARTILPR__ILPDVSR__Pos)                          /*!< Mask for ILPDVSR in UART.UARTILPR */
#define UART_UARTILPR__ILPDVSR__Shift(v)                        (((v) << UART_UARTILPR__ILPDVSR__Pos) & UART_UARTILPR__ILPDVSR__Msk)   /*!< Shift value 'v' into ILPDVSR and mask 'v' to fit it into ILPDVSR field */

/** UART_UARTILPR__ILPDVSR__SET() sets UARTILPR.ILPDVSR to given value.
 *
 * When writing to UARTILPR.ILPDVSR, this is recommended to use.
 *
 * @param bf_value new value for UARTILPR.ILPDVSR
 */
__UART_INLINE void UART_UARTILPR__ILPDVSR__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTILPR__GET();
    reg = (reg & ~UART_UARTILPR__ILPDVSR__Msk);
    reg = (reg | (UART_UARTILPR__ILPDVSR__Shift((uint32_t)bf_value)));
    UART_UARTILPR__SET(reg);
}

/** UART_UARTILPR__ILPDVSR__GET() gets UARTILPR.ILPDVSR's current value.
 *
 * When reading from UARTILPR.ILPDVSR, this is recommended to use.
 *
 * @return current value of UARTILPR.ILPDVSR
 */
__UART_INLINE uint32_t UART_UARTILPR__ILPDVSR__GET(void)
{
    uint32_t reg = UART_UARTILPR__GET();
    reg = (reg & UART_UARTILPR__ILPDVSR__Msk);
    reg = (reg >> UART_UARTILPR__ILPDVSR__Pos);
    return (uint32_t)reg;
}

/** UART_UARTILPR__ILPDVSR__MODIFY() modifies UARTILPR.ILPDVSR.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTILPR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTILPR
 * @param bf_value new value for UARTILPR.ILPDVSR
 * @return new value of UART.UARTILPR
 */
__UART_INLINE uint32_t UART_UARTILPR__ILPDVSR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTILPR__ILPDVSR__Msk);
    reg = (reg | (UART_UARTILPR__ILPDVSR__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTILPR__ILPDVSR__EXTRACT() extracts UARTILPR.ILPDVSR.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTILPR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTILPR
 * @return current value of UARTILPR.ILPDVSR
 */
__UART_INLINE uint32_t UART_UARTILPR__ILPDVSR__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTILPR__ILPDVSR__Msk);
    reg = (reg >> UART_UARTILPR__ILPDVSR__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         UARTIBRD member of UART_t                         */
/* -------------------------------------------------------------------------- */

/** __UART_UARTIBRD__ADDRESS returns the address of member UARTIBRD.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTIBRD
 */
__UART_INLINE uint32_t* __UART_UARTIBRD__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTIBRD)));
}

/** UART_UARTIBRD__SET() sets UARTIBRD to given value.
 *
 * When writing to UARTIBRD, this is mandatory to use.
 *
 * @param value new value for UARTIBRD
 */
__UART_INLINE void UART_UARTIBRD__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTIBRD__ADDRESS(), value);
}

/** UART_UARTIBRD__GET() gets UARTIBRD's current value.
 *
 * When reading from UARTIBRD, this is mandatory to use.
 *
 * @return current value of UARTIBRD
 */
__UART_INLINE uint32_t UART_UARTIBRD__GET(void)
{
    return HAL_GET32(__UART_UARTIBRD__ADDRESS());
}

/* ----------------------- UART.UARTIBRD.BAUD_DIVINT ----------------------- */

/**
<pre>
  UART.UARTIBRD.BAUD_DIVINT:

    Integer baud rate divisor

</pre> */

#define UART_UARTIBRD__BAUD_DIVINT__Pos                         0                                                                      /*!< Right-most bit position of BAUD_DIVINT in UART.UARTIBRD */
#define UART_UARTIBRD__BAUD_DIVINT__Msk                         (0x0000FFFFUL << UART_UARTIBRD__BAUD_DIVINT__Pos)                      /*!< Mask for BAUD_DIVINT in UART.UARTIBRD */
#define UART_UARTIBRD__BAUD_DIVINT__Shift(v)                    (((v) << UART_UARTIBRD__BAUD_DIVINT__Pos) & UART_UARTIBRD__BAUD_DIVINT__Msk) /*!< Shift value 'v' into BAUD_DIVINT and mask 'v' to fit it into BAUD_DIVINT field */

/** UART_UARTIBRD__BAUD_DIVINT__SET() sets UARTIBRD.BAUD_DIVINT to given value.
 *
 * When writing to UARTIBRD.BAUD_DIVINT, this is recommended to use.
 *
 * @param bf_value new value for UARTIBRD.BAUD_DIVINT
 */
__UART_INLINE void UART_UARTIBRD__BAUD_DIVINT__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIBRD__GET();
    reg = (reg & ~UART_UARTIBRD__BAUD_DIVINT__Msk);
    reg = (reg | (UART_UARTIBRD__BAUD_DIVINT__Shift((uint32_t)bf_value)));
    UART_UARTIBRD__SET(reg);
}

/** UART_UARTIBRD__BAUD_DIVINT__GET() gets UARTIBRD.BAUD_DIVINT's current value.
 *
 * When reading from UARTIBRD.BAUD_DIVINT, this is recommended to use.
 *
 * @return current value of UARTIBRD.BAUD_DIVINT
 */
__UART_INLINE uint32_t UART_UARTIBRD__BAUD_DIVINT__GET(void)
{
    uint32_t reg = UART_UARTIBRD__GET();
    reg = (reg & UART_UARTIBRD__BAUD_DIVINT__Msk);
    reg = (reg >> UART_UARTIBRD__BAUD_DIVINT__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIBRD__BAUD_DIVINT__MODIFY() modifies UARTIBRD.BAUD_DIVINT.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIBRD.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIBRD
 * @param bf_value new value for UARTIBRD.BAUD_DIVINT
 * @return new value of UART.UARTIBRD
 */
__UART_INLINE uint32_t UART_UARTIBRD__BAUD_DIVINT__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIBRD__BAUD_DIVINT__Msk);
    reg = (reg | (UART_UARTIBRD__BAUD_DIVINT__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIBRD__BAUD_DIVINT__EXTRACT() extracts UARTIBRD.BAUD_DIVINT.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIBRD.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIBRD
 * @return current value of UARTIBRD.BAUD_DIVINT
 */
__UART_INLINE uint32_t UART_UARTIBRD__BAUD_DIVINT__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIBRD__BAUD_DIVINT__Msk);
    reg = (reg >> UART_UARTIBRD__BAUD_DIVINT__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         UARTFBRD member of UART_t                         */
/* -------------------------------------------------------------------------- */

/** __UART_UARTFBRD__ADDRESS returns the address of member UARTFBRD.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTFBRD
 */
__UART_INLINE uint32_t* __UART_UARTFBRD__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTFBRD)));
}

/** UART_UARTFBRD__SET() sets UARTFBRD to given value.
 *
 * When writing to UARTFBRD, this is mandatory to use.
 *
 * @param value new value for UARTFBRD
 */
__UART_INLINE void UART_UARTFBRD__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTFBRD__ADDRESS(), value);
}

/** UART_UARTFBRD__GET() gets UARTFBRD's current value.
 *
 * When reading from UARTFBRD, this is mandatory to use.
 *
 * @return current value of UARTFBRD
 */
__UART_INLINE uint32_t UART_UARTFBRD__GET(void)
{
    return HAL_GET32(__UART_UARTFBRD__ADDRESS());
}

/* ----------------------- UART.UARTFBRD.BAUD_DIVFRAC ----------------------- */

/**
<pre>
  UART.UARTFBRD.BAUD_DIVFRAC:

    Fractional baud rate divisor

</pre> */

#define UART_UARTFBRD__BAUD_DIVFRAC__Pos                        0                                                                      /*!< Right-most bit position of BAUD_DIVFRAC in UART.UARTFBRD */
#define UART_UARTFBRD__BAUD_DIVFRAC__Msk                        (0x0000003FUL << UART_UARTFBRD__BAUD_DIVFRAC__Pos)                     /*!< Mask for BAUD_DIVFRAC in UART.UARTFBRD */
#define UART_UARTFBRD__BAUD_DIVFRAC__Shift(v)                   (((v) << UART_UARTFBRD__BAUD_DIVFRAC__Pos) & UART_UARTFBRD__BAUD_DIVFRAC__Msk) /*!< Shift value 'v' into BAUD_DIVFRAC and mask 'v' to fit it into BAUD_DIVFRAC field */

/** UART_UARTFBRD__BAUD_DIVFRAC__SET() sets UARTFBRD.BAUD_DIVFRAC to given value.
 *
 * When writing to UARTFBRD.BAUD_DIVFRAC, this is recommended to use.
 *
 * @param bf_value new value for UARTFBRD.BAUD_DIVFRAC
 */
__UART_INLINE void UART_UARTFBRD__BAUD_DIVFRAC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTFBRD__GET();
    reg = (reg & ~UART_UARTFBRD__BAUD_DIVFRAC__Msk);
    reg = (reg | (UART_UARTFBRD__BAUD_DIVFRAC__Shift((uint32_t)bf_value)));
    UART_UARTFBRD__SET(reg);
}

/** UART_UARTFBRD__BAUD_DIVFRAC__GET() gets UARTFBRD.BAUD_DIVFRAC's current value.
 *
 * When reading from UARTFBRD.BAUD_DIVFRAC, this is recommended to use.
 *
 * @return current value of UARTFBRD.BAUD_DIVFRAC
 */
__UART_INLINE uint32_t UART_UARTFBRD__BAUD_DIVFRAC__GET(void)
{
    uint32_t reg = UART_UARTFBRD__GET();
    reg = (reg & UART_UARTFBRD__BAUD_DIVFRAC__Msk);
    reg = (reg >> UART_UARTFBRD__BAUD_DIVFRAC__Pos);
    return (uint32_t)reg;
}

/** UART_UARTFBRD__BAUD_DIVFRAC__MODIFY() modifies UARTFBRD.BAUD_DIVFRAC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTFBRD.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTFBRD
 * @param bf_value new value for UARTFBRD.BAUD_DIVFRAC
 * @return new value of UART.UARTFBRD
 */
__UART_INLINE uint32_t UART_UARTFBRD__BAUD_DIVFRAC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTFBRD__BAUD_DIVFRAC__Msk);
    reg = (reg | (UART_UARTFBRD__BAUD_DIVFRAC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTFBRD__BAUD_DIVFRAC__EXTRACT() extracts UARTFBRD.BAUD_DIVFRAC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTFBRD.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTFBRD
 * @return current value of UARTFBRD.BAUD_DIVFRAC
 */
__UART_INLINE uint32_t UART_UARTFBRD__BAUD_DIVFRAC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTFBRD__BAUD_DIVFRAC__Msk);
    reg = (reg >> UART_UARTFBRD__BAUD_DIVFRAC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         UARTLCR_H member of UART_t                         */
/* -------------------------------------------------------------------------- */

/** __UART_UARTLCR_H__ADDRESS returns the address of member UARTLCR_H.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTLCR_H
 */
__UART_INLINE uint32_t* __UART_UARTLCR_H__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTLCR_H)));
}

/** UART_UARTLCR_H__SET() sets UARTLCR_H to given value.
 *
 * When writing to UARTLCR_H, this is mandatory to use.
 *
 * @param value new value for UARTLCR_H
 */
__UART_INLINE void UART_UARTLCR_H__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTLCR_H__ADDRESS(), value);
}

/** UART_UARTLCR_H__GET() gets UARTLCR_H's current value.
 *
 * When reading from UARTLCR_H, this is mandatory to use.
 *
 * @return current value of UARTLCR_H
 */
__UART_INLINE uint32_t UART_UARTLCR_H__GET(void)
{
    return HAL_GET32(__UART_UARTLCR_H__ADDRESS());
}

/* --------------------------- UART.UARTLCR_H.SPS --------------------------- */

/**
<pre>
  UART.UARTLCR_H.SPS:

    Stick parity select

</pre> */

/*lint -parent(uint32_t, uart_uartlcr_h__sps_t) -strong(AJX)*/
typedef enum uart_uartlcr_h__sps_e                                                                                                     /*!< Stick parity select */
{
    uart_uartlcr_h__sps_low = 0u,                                                                                                      /*!<      stick parity is disabled */
    uart_uartlcr_h__sps_high = 1u                                                                                                      /*!<      either:    - if the EPS bit is 0 then the parity bit is tran...(more) */
} uart_uartlcr_h__sps_t;

#define UART_UARTLCR_H__SPS__Pos                                7                                                                      /*!< Right-most bit position of SPS in UART.UARTLCR_H */
#define UART_UARTLCR_H__SPS__Msk                                (0x00000001UL << UART_UARTLCR_H__SPS__Pos)                             /*!< Mask for SPS in UART.UARTLCR_H */
#define UART_UARTLCR_H__SPS__Shift(v)                           (((v) << UART_UARTLCR_H__SPS__Pos) & UART_UARTLCR_H__SPS__Msk)         /*!< Shift value 'v' into SPS and mask 'v' to fit it into SPS field */

/** UART_UARTLCR_H__SPS__SET() sets UARTLCR_H.SPS to given value.
 *
 * When writing to UARTLCR_H.SPS, this is recommended to use.
 *
 * @param bf_value new value for UARTLCR_H.SPS
 */
__UART_INLINE void UART_UARTLCR_H__SPS__SET(uart_uartlcr_h__sps_t bf_value)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & ~UART_UARTLCR_H__SPS__Msk);
    reg = (reg | (UART_UARTLCR_H__SPS__Shift((uint32_t)bf_value)));
    UART_UARTLCR_H__SET(reg);
}

/** UART_UARTLCR_H__SPS__GET() gets UARTLCR_H.SPS's current value.
 *
 * When reading from UARTLCR_H.SPS, this is recommended to use.
 *
 * @return current value of UARTLCR_H.SPS
 */
__UART_INLINE uart_uartlcr_h__sps_t UART_UARTLCR_H__SPS__GET(void)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & UART_UARTLCR_H__SPS__Msk);
    reg = (reg >> UART_UARTLCR_H__SPS__Pos);
    return (uart_uartlcr_h__sps_t)reg;
}

/** UART_UARTLCR_H__SPS__MODIFY() modifies UARTLCR_H.SPS.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTLCR_H.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTLCR_H
 * @param bf_value new value for UARTLCR_H.SPS
 * @return new value of UART.UARTLCR_H
 */
__UART_INLINE uint32_t UART_UARTLCR_H__SPS__MODIFY(uint32_t reg, uart_uartlcr_h__sps_t bf_value)
{
    reg = (reg & ~UART_UARTLCR_H__SPS__Msk);
    reg = (reg | (UART_UARTLCR_H__SPS__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTLCR_H__SPS__EXTRACT() extracts UARTLCR_H.SPS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTLCR_H.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTLCR_H
 * @return current value of UARTLCR_H.SPS
 */
__UART_INLINE uart_uartlcr_h__sps_t UART_UARTLCR_H__SPS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTLCR_H__SPS__Msk);
    reg = (reg >> UART_UARTLCR_H__SPS__Pos);
    return (uart_uartlcr_h__sps_t)reg;
}

/* -------------------------- UART.UARTLCR_H.WLEN -------------------------- */

/**
<pre>
  UART.UARTLCR_H.WLEN:

    Word length

</pre> */

/*lint -parent(uint32_t, uart_uartlcr_h__wlen_t) -strong(AJX)*/
typedef enum uart_uartlcr_h__wlen_e                                                                                                    /*!< Word length */
{
    uart_uartlcr_h__wlen_s0 = 0u,                                                                                                      /*!<      5 bits */
    uart_uartlcr_h__wlen_s1 = 1u,                                                                                                      /*!<      6 bits */
    uart_uartlcr_h__wlen_s2 = 2u,                                                                                                      /*!<      7 bits */
    uart_uartlcr_h__wlen_s3 = 3u                                                                                                       /*!<      8 bits */
} uart_uartlcr_h__wlen_t;

#define UART_UARTLCR_H__WLEN__Pos                               5                                                                      /*!< Right-most bit position of WLEN in UART.UARTLCR_H */
#define UART_UARTLCR_H__WLEN__Msk                               (0x00000003UL << UART_UARTLCR_H__WLEN__Pos)                            /*!< Mask for WLEN in UART.UARTLCR_H */
#define UART_UARTLCR_H__WLEN__Shift(v)                          (((v) << UART_UARTLCR_H__WLEN__Pos) & UART_UARTLCR_H__WLEN__Msk)       /*!< Shift value 'v' into WLEN and mask 'v' to fit it into WLEN field */

/** UART_UARTLCR_H__WLEN__SET() sets UARTLCR_H.WLEN to given value.
 *
 * When writing to UARTLCR_H.WLEN, this is recommended to use.
 *
 * @param bf_value new value for UARTLCR_H.WLEN
 */
__UART_INLINE void UART_UARTLCR_H__WLEN__SET(uart_uartlcr_h__wlen_t bf_value)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & ~UART_UARTLCR_H__WLEN__Msk);
    reg = (reg | (UART_UARTLCR_H__WLEN__Shift((uint32_t)bf_value)));
    UART_UARTLCR_H__SET(reg);
}

/** UART_UARTLCR_H__WLEN__GET() gets UARTLCR_H.WLEN's current value.
 *
 * When reading from UARTLCR_H.WLEN, this is recommended to use.
 *
 * @return current value of UARTLCR_H.WLEN
 */
__UART_INLINE uart_uartlcr_h__wlen_t UART_UARTLCR_H__WLEN__GET(void)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & UART_UARTLCR_H__WLEN__Msk);
    reg = (reg >> UART_UARTLCR_H__WLEN__Pos);
    return (uart_uartlcr_h__wlen_t)reg;
}

/** UART_UARTLCR_H__WLEN__MODIFY() modifies UARTLCR_H.WLEN.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTLCR_H.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTLCR_H
 * @param bf_value new value for UARTLCR_H.WLEN
 * @return new value of UART.UARTLCR_H
 */
__UART_INLINE uint32_t UART_UARTLCR_H__WLEN__MODIFY(uint32_t reg, uart_uartlcr_h__wlen_t bf_value)
{
    reg = (reg & ~UART_UARTLCR_H__WLEN__Msk);
    reg = (reg | (UART_UARTLCR_H__WLEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTLCR_H__WLEN__EXTRACT() extracts UARTLCR_H.WLEN.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTLCR_H.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTLCR_H
 * @return current value of UARTLCR_H.WLEN
 */
__UART_INLINE uart_uartlcr_h__wlen_t UART_UARTLCR_H__WLEN__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTLCR_H__WLEN__Msk);
    reg = (reg >> UART_UARTLCR_H__WLEN__Pos);
    return (uart_uartlcr_h__wlen_t)reg;
}

/* --------------------------- UART.UARTLCR_H.FEN --------------------------- */

/**
<pre>
  UART.UARTLCR_H.FEN:

    Enable FIFOs

</pre> */

/*lint -parent(uint32_t, uart_uartlcr_h__fen_t) -strong(AJX)*/
typedef enum uart_uartlcr_h__fen_e                                                                                                     /*!< Enable FIFOs */
{
    uart_uartlcr_h__fen_low = 0u,                                                                                                      /*!<      FIFOs are disabled (character mode); that is, the FIFOs beco...(more) */
    uart_uartlcr_h__fen_high = 1u                                                                                                      /*!<      transmit and receive FIFO buffers are enabled (FIFO mode). */
} uart_uartlcr_h__fen_t;

#define UART_UARTLCR_H__FEN__Pos                                4                                                                      /*!< Right-most bit position of FEN in UART.UARTLCR_H */
#define UART_UARTLCR_H__FEN__Msk                                (0x00000001UL << UART_UARTLCR_H__FEN__Pos)                             /*!< Mask for FEN in UART.UARTLCR_H */
#define UART_UARTLCR_H__FEN__Shift(v)                           (((v) << UART_UARTLCR_H__FEN__Pos) & UART_UARTLCR_H__FEN__Msk)         /*!< Shift value 'v' into FEN and mask 'v' to fit it into FEN field */

/** UART_UARTLCR_H__FEN__SET() sets UARTLCR_H.FEN to given value.
 *
 * When writing to UARTLCR_H.FEN, this is recommended to use.
 *
 * @param bf_value new value for UARTLCR_H.FEN
 */
__UART_INLINE void UART_UARTLCR_H__FEN__SET(uart_uartlcr_h__fen_t bf_value)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & ~UART_UARTLCR_H__FEN__Msk);
    reg = (reg | (UART_UARTLCR_H__FEN__Shift((uint32_t)bf_value)));
    UART_UARTLCR_H__SET(reg);
}

/** UART_UARTLCR_H__FEN__GET() gets UARTLCR_H.FEN's current value.
 *
 * When reading from UARTLCR_H.FEN, this is recommended to use.
 *
 * @return current value of UARTLCR_H.FEN
 */
__UART_INLINE uart_uartlcr_h__fen_t UART_UARTLCR_H__FEN__GET(void)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & UART_UARTLCR_H__FEN__Msk);
    reg = (reg >> UART_UARTLCR_H__FEN__Pos);
    return (uart_uartlcr_h__fen_t)reg;
}

/** UART_UARTLCR_H__FEN__MODIFY() modifies UARTLCR_H.FEN.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTLCR_H.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTLCR_H
 * @param bf_value new value for UARTLCR_H.FEN
 * @return new value of UART.UARTLCR_H
 */
__UART_INLINE uint32_t UART_UARTLCR_H__FEN__MODIFY(uint32_t reg, uart_uartlcr_h__fen_t bf_value)
{
    reg = (reg & ~UART_UARTLCR_H__FEN__Msk);
    reg = (reg | (UART_UARTLCR_H__FEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTLCR_H__FEN__EXTRACT() extracts UARTLCR_H.FEN.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTLCR_H.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTLCR_H
 * @return current value of UARTLCR_H.FEN
 */
__UART_INLINE uart_uartlcr_h__fen_t UART_UARTLCR_H__FEN__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTLCR_H__FEN__Msk);
    reg = (reg >> UART_UARTLCR_H__FEN__Pos);
    return (uart_uartlcr_h__fen_t)reg;
}

/* -------------------------- UART.UARTLCR_H.STP2 -------------------------- */

/**
<pre>
  UART.UARTLCR_H.STP2:

    Two stop bits select

</pre> */

#define UART_UARTLCR_H__STP2__Pos                               3                                                                      /*!< Right-most bit position of STP2 in UART.UARTLCR_H */
#define UART_UARTLCR_H__STP2__Msk                               (0x00000001UL << UART_UARTLCR_H__STP2__Pos)                            /*!< Mask for STP2 in UART.UARTLCR_H */
#define UART_UARTLCR_H__STP2__Shift(v)                          (((v) << UART_UARTLCR_H__STP2__Pos) & UART_UARTLCR_H__STP2__Msk)       /*!< Shift value 'v' into STP2 and mask 'v' to fit it into STP2 field */

/** UART_UARTLCR_H__STP2__SET() sets UARTLCR_H.STP2 to given value.
 *
 * When writing to UARTLCR_H.STP2, this is recommended to use.
 *
 * @param bf_value new value for UARTLCR_H.STP2
 */
__UART_INLINE void UART_UARTLCR_H__STP2__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & ~UART_UARTLCR_H__STP2__Msk);
    reg = (reg | (UART_UARTLCR_H__STP2__Shift((uint32_t)bf_value)));
    UART_UARTLCR_H__SET(reg);
}

/** UART_UARTLCR_H__STP2__GET() gets UARTLCR_H.STP2's current value.
 *
 * When reading from UARTLCR_H.STP2, this is recommended to use.
 *
 * @return current value of UARTLCR_H.STP2
 */
__UART_INLINE uint32_t UART_UARTLCR_H__STP2__GET(void)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & UART_UARTLCR_H__STP2__Msk);
    reg = (reg >> UART_UARTLCR_H__STP2__Pos);
    return (uint32_t)reg;
}

/** UART_UARTLCR_H__STP2__MODIFY() modifies UARTLCR_H.STP2.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTLCR_H.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTLCR_H
 * @param bf_value new value for UARTLCR_H.STP2
 * @return new value of UART.UARTLCR_H
 */
__UART_INLINE uint32_t UART_UARTLCR_H__STP2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTLCR_H__STP2__Msk);
    reg = (reg | (UART_UARTLCR_H__STP2__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTLCR_H__STP2__EXTRACT() extracts UARTLCR_H.STP2.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTLCR_H.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTLCR_H
 * @return current value of UARTLCR_H.STP2
 */
__UART_INLINE uint32_t UART_UARTLCR_H__STP2__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTLCR_H__STP2__Msk);
    reg = (reg >> UART_UARTLCR_H__STP2__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTLCR_H.EPS --------------------------- */

/**
<pre>
  UART.UARTLCR_H.EPS:

    Even parity select

</pre> */

/*lint -parent(uint32_t, uart_uartlcr_h__eps_t) -strong(AJX)*/
typedef enum uart_uartlcr_h__eps_e                                                                                                     /*!< Even parity select */
{
    uart_uartlcr_h__eps_low = 0u,                                                                                                      /*!<      odd parity. The UART generates or checks for an odd number o...(more) */
    uart_uartlcr_h__eps_high = 1u                                                                                                      /*!<      even parity. The UART generates or checks for an even number...(more) */
} uart_uartlcr_h__eps_t;

#define UART_UARTLCR_H__EPS__Pos                                2                                                                      /*!< Right-most bit position of EPS in UART.UARTLCR_H */
#define UART_UARTLCR_H__EPS__Msk                                (0x00000001UL << UART_UARTLCR_H__EPS__Pos)                             /*!< Mask for EPS in UART.UARTLCR_H */
#define UART_UARTLCR_H__EPS__Shift(v)                           (((v) << UART_UARTLCR_H__EPS__Pos) & UART_UARTLCR_H__EPS__Msk)         /*!< Shift value 'v' into EPS and mask 'v' to fit it into EPS field */

/** UART_UARTLCR_H__EPS__SET() sets UARTLCR_H.EPS to given value.
 *
 * When writing to UARTLCR_H.EPS, this is recommended to use.
 *
 * @param bf_value new value for UARTLCR_H.EPS
 */
__UART_INLINE void UART_UARTLCR_H__EPS__SET(uart_uartlcr_h__eps_t bf_value)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & ~UART_UARTLCR_H__EPS__Msk);
    reg = (reg | (UART_UARTLCR_H__EPS__Shift((uint32_t)bf_value)));
    UART_UARTLCR_H__SET(reg);
}

/** UART_UARTLCR_H__EPS__GET() gets UARTLCR_H.EPS's current value.
 *
 * When reading from UARTLCR_H.EPS, this is recommended to use.
 *
 * @return current value of UARTLCR_H.EPS
 */
__UART_INLINE uart_uartlcr_h__eps_t UART_UARTLCR_H__EPS__GET(void)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & UART_UARTLCR_H__EPS__Msk);
    reg = (reg >> UART_UARTLCR_H__EPS__Pos);
    return (uart_uartlcr_h__eps_t)reg;
}

/** UART_UARTLCR_H__EPS__MODIFY() modifies UARTLCR_H.EPS.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTLCR_H.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTLCR_H
 * @param bf_value new value for UARTLCR_H.EPS
 * @return new value of UART.UARTLCR_H
 */
__UART_INLINE uint32_t UART_UARTLCR_H__EPS__MODIFY(uint32_t reg, uart_uartlcr_h__eps_t bf_value)
{
    reg = (reg & ~UART_UARTLCR_H__EPS__Msk);
    reg = (reg | (UART_UARTLCR_H__EPS__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTLCR_H__EPS__EXTRACT() extracts UARTLCR_H.EPS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTLCR_H.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTLCR_H
 * @return current value of UARTLCR_H.EPS
 */
__UART_INLINE uart_uartlcr_h__eps_t UART_UARTLCR_H__EPS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTLCR_H__EPS__Msk);
    reg = (reg >> UART_UARTLCR_H__EPS__Pos);
    return (uart_uartlcr_h__eps_t)reg;
}

/* --------------------------- UART.UARTLCR_H.PEN --------------------------- */

/**
<pre>
  UART.UARTLCR_H.PEN:

    Parity enable

</pre> */

/*lint -parent(uint32_t, uart_uartlcr_h__pen_t) -strong(AJX)*/
typedef enum uart_uartlcr_h__pen_e                                                                                                     /*!< Parity enable */
{
    uart_uartlcr_h__pen_low = 0u,                                                                                                      /*!<      parity is disabled and no parity bit added to the data frame */
    uart_uartlcr_h__pen_high = 1u                                                                                                      /*!<      parity checking and generation is enabled */
} uart_uartlcr_h__pen_t;

#define UART_UARTLCR_H__PEN__Pos                                1                                                                      /*!< Right-most bit position of PEN in UART.UARTLCR_H */
#define UART_UARTLCR_H__PEN__Msk                                (0x00000001UL << UART_UARTLCR_H__PEN__Pos)                             /*!< Mask for PEN in UART.UARTLCR_H */
#define UART_UARTLCR_H__PEN__Shift(v)                           (((v) << UART_UARTLCR_H__PEN__Pos) & UART_UARTLCR_H__PEN__Msk)         /*!< Shift value 'v' into PEN and mask 'v' to fit it into PEN field */

/** UART_UARTLCR_H__PEN__SET() sets UARTLCR_H.PEN to given value.
 *
 * When writing to UARTLCR_H.PEN, this is recommended to use.
 *
 * @param bf_value new value for UARTLCR_H.PEN
 */
__UART_INLINE void UART_UARTLCR_H__PEN__SET(uart_uartlcr_h__pen_t bf_value)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & ~UART_UARTLCR_H__PEN__Msk);
    reg = (reg | (UART_UARTLCR_H__PEN__Shift((uint32_t)bf_value)));
    UART_UARTLCR_H__SET(reg);
}

/** UART_UARTLCR_H__PEN__GET() gets UARTLCR_H.PEN's current value.
 *
 * When reading from UARTLCR_H.PEN, this is recommended to use.
 *
 * @return current value of UARTLCR_H.PEN
 */
__UART_INLINE uart_uartlcr_h__pen_t UART_UARTLCR_H__PEN__GET(void)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & UART_UARTLCR_H__PEN__Msk);
    reg = (reg >> UART_UARTLCR_H__PEN__Pos);
    return (uart_uartlcr_h__pen_t)reg;
}

/** UART_UARTLCR_H__PEN__MODIFY() modifies UARTLCR_H.PEN.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTLCR_H.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTLCR_H
 * @param bf_value new value for UARTLCR_H.PEN
 * @return new value of UART.UARTLCR_H
 */
__UART_INLINE uint32_t UART_UARTLCR_H__PEN__MODIFY(uint32_t reg, uart_uartlcr_h__pen_t bf_value)
{
    reg = (reg & ~UART_UARTLCR_H__PEN__Msk);
    reg = (reg | (UART_UARTLCR_H__PEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTLCR_H__PEN__EXTRACT() extracts UARTLCR_H.PEN.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTLCR_H.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTLCR_H
 * @return current value of UARTLCR_H.PEN
 */
__UART_INLINE uart_uartlcr_h__pen_t UART_UARTLCR_H__PEN__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTLCR_H__PEN__Msk);
    reg = (reg >> UART_UARTLCR_H__PEN__Pos);
    return (uart_uartlcr_h__pen_t)reg;
}

/* --------------------------- UART.UARTLCR_H.BRK --------------------------- */

/**
<pre>
  UART.UARTLCR_H.BRK:

    Send break

</pre> */

#define UART_UARTLCR_H__BRK__Pos                                0                                                                      /*!< Right-most bit position of BRK in UART.UARTLCR_H */
#define UART_UARTLCR_H__BRK__Msk                                (0x00000001UL << UART_UARTLCR_H__BRK__Pos)                             /*!< Mask for BRK in UART.UARTLCR_H */
#define UART_UARTLCR_H__BRK__Shift(v)                           (((v) << UART_UARTLCR_H__BRK__Pos) & UART_UARTLCR_H__BRK__Msk)         /*!< Shift value 'v' into BRK and mask 'v' to fit it into BRK field */

/** UART_UARTLCR_H__BRK__SET() sets UARTLCR_H.BRK to given value.
 *
 * When writing to UARTLCR_H.BRK, this is recommended to use.
 *
 * @param bf_value new value for UARTLCR_H.BRK
 */
__UART_INLINE void UART_UARTLCR_H__BRK__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & ~UART_UARTLCR_H__BRK__Msk);
    reg = (reg | (UART_UARTLCR_H__BRK__Shift((uint32_t)bf_value)));
    UART_UARTLCR_H__SET(reg);
}

/** UART_UARTLCR_H__BRK__GET() gets UARTLCR_H.BRK's current value.
 *
 * When reading from UARTLCR_H.BRK, this is recommended to use.
 *
 * @return current value of UARTLCR_H.BRK
 */
__UART_INLINE uint32_t UART_UARTLCR_H__BRK__GET(void)
{
    uint32_t reg = UART_UARTLCR_H__GET();
    reg = (reg & UART_UARTLCR_H__BRK__Msk);
    reg = (reg >> UART_UARTLCR_H__BRK__Pos);
    return (uint32_t)reg;
}

/** UART_UARTLCR_H__BRK__MODIFY() modifies UARTLCR_H.BRK.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTLCR_H.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTLCR_H
 * @param bf_value new value for UARTLCR_H.BRK
 * @return new value of UART.UARTLCR_H
 */
__UART_INLINE uint32_t UART_UARTLCR_H__BRK__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTLCR_H__BRK__Msk);
    reg = (reg | (UART_UARTLCR_H__BRK__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTLCR_H__BRK__EXTRACT() extracts UARTLCR_H.BRK.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTLCR_H.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTLCR_H
 * @return current value of UARTLCR_H.BRK
 */
__UART_INLINE uint32_t UART_UARTLCR_H__BRK__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTLCR_H__BRK__Msk);
    reg = (reg >> UART_UARTLCR_H__BRK__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          UARTCR member of UART_t                          */
/* -------------------------------------------------------------------------- */

/** __UART_UARTCR__ADDRESS returns the address of member UARTCR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTCR
 */
__UART_INLINE uint32_t* __UART_UARTCR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTCR)));
}

/** UART_UARTCR__SET() sets UARTCR to given value.
 *
 * When writing to UARTCR, this is mandatory to use.
 *
 * @param value new value for UARTCR
 */
__UART_INLINE void UART_UARTCR__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTCR__ADDRESS(), value);
}

/** UART_UARTCR__GET() gets UARTCR's current value.
 *
 * When reading from UARTCR, this is mandatory to use.
 *
 * @return current value of UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__GET(void)
{
    return HAL_GET32(__UART_UARTCR__ADDRESS());
}

/* --------------------------- UART.UARTCR.CTSEN --------------------------- */

/**
<pre>
  UART.UARTCR.CTSEN:

    CTS hardware flow control enable

</pre> */

/*lint -parent(uint32_t, uart_uartcr__ctsen_t) -strong(AJX)*/
typedef enum uart_uartcr__ctsen_e                                                                                                      /*!< CTS hardware flow control enable */
{
    uart_uartcr__ctsen_low = 0u,                                                                                                       /*!<      CTS hardware flow control is disabled */
    uart_uartcr__ctsen_high = 1u                                                                                                       /*!<      CTS hardware flow control is enabled */
} uart_uartcr__ctsen_t;

#define UART_UARTCR__CTSEN__Pos                                 15                                                                     /*!< Right-most bit position of CTSEn in UART.UARTCR */
#define UART_UARTCR__CTSEN__Msk                                 (0x00000001UL << UART_UARTCR__CTSEN__Pos)                              /*!< Mask for CTSEn in UART.UARTCR */
#define UART_UARTCR__CTSEN__Shift(v)                            (((v) << UART_UARTCR__CTSEN__Pos) & UART_UARTCR__CTSEN__Msk)           /*!< Shift value 'v' into CTSEn and mask 'v' to fit it into CTSEn field */

/** UART_UARTCR__CTSEN__SET() sets UARTCR.CTSEN to given value.
 *
 * When writing to UARTCR.CTSEN, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.CTSEN
 */
__UART_INLINE void UART_UARTCR__CTSEN__SET(uart_uartcr__ctsen_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__CTSEN__Msk);
    reg = (reg | (UART_UARTCR__CTSEN__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__CTSEN__GET() gets UARTCR.CTSEN's current value.
 *
 * When reading from UARTCR.CTSEN, this is recommended to use.
 *
 * @return current value of UARTCR.CTSEN
 */
__UART_INLINE uart_uartcr__ctsen_t UART_UARTCR__CTSEN__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__CTSEN__Msk);
    reg = (reg >> UART_UARTCR__CTSEN__Pos);
    return (uart_uartcr__ctsen_t)reg;
}

/** UART_UARTCR__CTSEN__MODIFY() modifies UARTCR.CTSEN.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.CTSEN
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__CTSEN__MODIFY(uint32_t reg, uart_uartcr__ctsen_t bf_value)
{
    reg = (reg & ~UART_UARTCR__CTSEN__Msk);
    reg = (reg | (UART_UARTCR__CTSEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__CTSEN__EXTRACT() extracts UARTCR.CTSEN.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.CTSEN
 */
__UART_INLINE uart_uartcr__ctsen_t UART_UARTCR__CTSEN__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__CTSEN__Msk);
    reg = (reg >> UART_UARTCR__CTSEN__Pos);
    return (uart_uartcr__ctsen_t)reg;
}

/* --------------------------- UART.UARTCR.RTSEN --------------------------- */

/**
<pre>
  UART.UARTCR.RTSEN:

    RTS hardware flow control enable

</pre> */

/*lint -parent(uint32_t, uart_uartcr__rtsen_t) -strong(AJX)*/
typedef enum uart_uartcr__rtsen_e                                                                                                      /*!< RTS hardware flow control enable */
{
    uart_uartcr__rtsen_low = 0u,                                                                                                       /*!<      RTS hardware flow control is disabled */
    uart_uartcr__rtsen_high = 1u                                                                                                       /*!<      RTS hardware flow control is enabled */
} uart_uartcr__rtsen_t;

#define UART_UARTCR__RTSEN__Pos                                 14                                                                     /*!< Right-most bit position of RTSEn in UART.UARTCR */
#define UART_UARTCR__RTSEN__Msk                                 (0x00000001UL << UART_UARTCR__RTSEN__Pos)                              /*!< Mask for RTSEn in UART.UARTCR */
#define UART_UARTCR__RTSEN__Shift(v)                            (((v) << UART_UARTCR__RTSEN__Pos) & UART_UARTCR__RTSEN__Msk)           /*!< Shift value 'v' into RTSEn and mask 'v' to fit it into RTSEn field */

/** UART_UARTCR__RTSEN__SET() sets UARTCR.RTSEN to given value.
 *
 * When writing to UARTCR.RTSEN, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.RTSEN
 */
__UART_INLINE void UART_UARTCR__RTSEN__SET(uart_uartcr__rtsen_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__RTSEN__Msk);
    reg = (reg | (UART_UARTCR__RTSEN__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__RTSEN__GET() gets UARTCR.RTSEN's current value.
 *
 * When reading from UARTCR.RTSEN, this is recommended to use.
 *
 * @return current value of UARTCR.RTSEN
 */
__UART_INLINE uart_uartcr__rtsen_t UART_UARTCR__RTSEN__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__RTSEN__Msk);
    reg = (reg >> UART_UARTCR__RTSEN__Pos);
    return (uart_uartcr__rtsen_t)reg;
}

/** UART_UARTCR__RTSEN__MODIFY() modifies UARTCR.RTSEN.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.RTSEN
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__RTSEN__MODIFY(uint32_t reg, uart_uartcr__rtsen_t bf_value)
{
    reg = (reg & ~UART_UARTCR__RTSEN__Msk);
    reg = (reg | (UART_UARTCR__RTSEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__RTSEN__EXTRACT() extracts UARTCR.RTSEN.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.RTSEN
 */
__UART_INLINE uart_uartcr__rtsen_t UART_UARTCR__RTSEN__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__RTSEN__Msk);
    reg = (reg >> UART_UARTCR__RTSEN__Pos);
    return (uart_uartcr__rtsen_t)reg;
}

/* ---------------------------- UART.UARTCR.OUT2 ---------------------------- */

/**
<pre>
  UART.UARTCR.OUT2:

    Complement of the UART Out2 Modem Status Output

</pre> */

#define UART_UARTCR__OUT2__Pos                                  13                                                                     /*!< Right-most bit position of OUT2 in UART.UARTCR */
#define UART_UARTCR__OUT2__Msk                                  (0x00000001UL << UART_UARTCR__OUT2__Pos)                               /*!< Mask for OUT2 in UART.UARTCR */
#define UART_UARTCR__OUT2__Shift(v)                             (((v) << UART_UARTCR__OUT2__Pos) & UART_UARTCR__OUT2__Msk)             /*!< Shift value 'v' into OUT2 and mask 'v' to fit it into OUT2 field */

/** UART_UARTCR__OUT2__SET() sets UARTCR.OUT2 to given value.
 *
 * When writing to UARTCR.OUT2, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.OUT2
 */
__UART_INLINE void UART_UARTCR__OUT2__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__OUT2__Msk);
    reg = (reg | (UART_UARTCR__OUT2__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__OUT2__GET() gets UARTCR.OUT2's current value.
 *
 * When reading from UARTCR.OUT2, this is recommended to use.
 *
 * @return current value of UARTCR.OUT2
 */
__UART_INLINE uint32_t UART_UARTCR__OUT2__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__OUT2__Msk);
    reg = (reg >> UART_UARTCR__OUT2__Pos);
    return (uint32_t)reg;
}

/** UART_UARTCR__OUT2__MODIFY() modifies UARTCR.OUT2.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.OUT2
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__OUT2__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTCR__OUT2__Msk);
    reg = (reg | (UART_UARTCR__OUT2__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__OUT2__EXTRACT() extracts UARTCR.OUT2.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.OUT2
 */
__UART_INLINE uint32_t UART_UARTCR__OUT2__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__OUT2__Msk);
    reg = (reg >> UART_UARTCR__OUT2__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTCR.OUT1 ---------------------------- */

/**
<pre>
  UART.UARTCR.OUT1:

    Complement of the UART Out1 Modem Status Output

</pre> */

#define UART_UARTCR__OUT1__Pos                                  12                                                                     /*!< Right-most bit position of OUT1 in UART.UARTCR */
#define UART_UARTCR__OUT1__Msk                                  (0x00000001UL << UART_UARTCR__OUT1__Pos)                               /*!< Mask for OUT1 in UART.UARTCR */
#define UART_UARTCR__OUT1__Shift(v)                             (((v) << UART_UARTCR__OUT1__Pos) & UART_UARTCR__OUT1__Msk)             /*!< Shift value 'v' into OUT1 and mask 'v' to fit it into OUT1 field */

/** UART_UARTCR__OUT1__SET() sets UARTCR.OUT1 to given value.
 *
 * When writing to UARTCR.OUT1, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.OUT1
 */
__UART_INLINE void UART_UARTCR__OUT1__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__OUT1__Msk);
    reg = (reg | (UART_UARTCR__OUT1__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__OUT1__GET() gets UARTCR.OUT1's current value.
 *
 * When reading from UARTCR.OUT1, this is recommended to use.
 *
 * @return current value of UARTCR.OUT1
 */
__UART_INLINE uint32_t UART_UARTCR__OUT1__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__OUT1__Msk);
    reg = (reg >> UART_UARTCR__OUT1__Pos);
    return (uint32_t)reg;
}

/** UART_UARTCR__OUT1__MODIFY() modifies UARTCR.OUT1.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.OUT1
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__OUT1__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTCR__OUT1__Msk);
    reg = (reg | (UART_UARTCR__OUT1__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__OUT1__EXTRACT() extracts UARTCR.OUT1.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.OUT1
 */
__UART_INLINE uint32_t UART_UARTCR__OUT1__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__OUT1__Msk);
    reg = (reg >> UART_UARTCR__OUT1__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTCR.RTS ---------------------------- */

/**
<pre>
  UART.UARTCR.RTS:

    Request to send

</pre> */

#define UART_UARTCR__RTS__Pos                                   11                                                                     /*!< Right-most bit position of RTS in UART.UARTCR */
#define UART_UARTCR__RTS__Msk                                   (0x00000001UL << UART_UARTCR__RTS__Pos)                                /*!< Mask for RTS in UART.UARTCR */
#define UART_UARTCR__RTS__Shift(v)                              (((v) << UART_UARTCR__RTS__Pos) & UART_UARTCR__RTS__Msk)               /*!< Shift value 'v' into RTS and mask 'v' to fit it into RTS field */

/** UART_UARTCR__RTS__SET() sets UARTCR.RTS to given value.
 *
 * When writing to UARTCR.RTS, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.RTS
 */
__UART_INLINE void UART_UARTCR__RTS__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__RTS__Msk);
    reg = (reg | (UART_UARTCR__RTS__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__RTS__GET() gets UARTCR.RTS's current value.
 *
 * When reading from UARTCR.RTS, this is recommended to use.
 *
 * @return current value of UARTCR.RTS
 */
__UART_INLINE uint32_t UART_UARTCR__RTS__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__RTS__Msk);
    reg = (reg >> UART_UARTCR__RTS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTCR__RTS__MODIFY() modifies UARTCR.RTS.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.RTS
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__RTS__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTCR__RTS__Msk);
    reg = (reg | (UART_UARTCR__RTS__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__RTS__EXTRACT() extracts UARTCR.RTS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.RTS
 */
__UART_INLINE uint32_t UART_UARTCR__RTS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__RTS__Msk);
    reg = (reg >> UART_UARTCR__RTS__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTCR.DTR ---------------------------- */

/**
<pre>
  UART.UARTCR.DTR:

    Data transmit ready

</pre> */

#define UART_UARTCR__DTR__Pos                                   10                                                                     /*!< Right-most bit position of DTR in UART.UARTCR */
#define UART_UARTCR__DTR__Msk                                   (0x00000001UL << UART_UARTCR__DTR__Pos)                                /*!< Mask for DTR in UART.UARTCR */
#define UART_UARTCR__DTR__Shift(v)                              (((v) << UART_UARTCR__DTR__Pos) & UART_UARTCR__DTR__Msk)               /*!< Shift value 'v' into DTR and mask 'v' to fit it into DTR field */

/** UART_UARTCR__DTR__SET() sets UARTCR.DTR to given value.
 *
 * When writing to UARTCR.DTR, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.DTR
 */
__UART_INLINE void UART_UARTCR__DTR__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__DTR__Msk);
    reg = (reg | (UART_UARTCR__DTR__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__DTR__GET() gets UARTCR.DTR's current value.
 *
 * When reading from UARTCR.DTR, this is recommended to use.
 *
 * @return current value of UARTCR.DTR
 */
__UART_INLINE uint32_t UART_UARTCR__DTR__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__DTR__Msk);
    reg = (reg >> UART_UARTCR__DTR__Pos);
    return (uint32_t)reg;
}

/** UART_UARTCR__DTR__MODIFY() modifies UARTCR.DTR.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.DTR
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__DTR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTCR__DTR__Msk);
    reg = (reg | (UART_UARTCR__DTR__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__DTR__EXTRACT() extracts UARTCR.DTR.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.DTR
 */
__UART_INLINE uint32_t UART_UARTCR__DTR__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__DTR__Msk);
    reg = (reg >> UART_UARTCR__DTR__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTCR.RXE ---------------------------- */

/**
<pre>
  UART.UARTCR.RXE:

    Receive enable

</pre> */

#define UART_UARTCR__RXE__Pos                                   9                                                                      /*!< Right-most bit position of RXE in UART.UARTCR */
#define UART_UARTCR__RXE__Msk                                   (0x00000001UL << UART_UARTCR__RXE__Pos)                                /*!< Mask for RXE in UART.UARTCR */
#define UART_UARTCR__RXE__Shift(v)                              (((v) << UART_UARTCR__RXE__Pos) & UART_UARTCR__RXE__Msk)               /*!< Shift value 'v' into RXE and mask 'v' to fit it into RXE field */

/** UART_UARTCR__RXE__SET() sets UARTCR.RXE to given value.
 *
 * When writing to UARTCR.RXE, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.RXE
 */
__UART_INLINE void UART_UARTCR__RXE__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__RXE__Msk);
    reg = (reg | (UART_UARTCR__RXE__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__RXE__GET() gets UARTCR.RXE's current value.
 *
 * When reading from UARTCR.RXE, this is recommended to use.
 *
 * @return current value of UARTCR.RXE
 */
__UART_INLINE uint32_t UART_UARTCR__RXE__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__RXE__Msk);
    reg = (reg >> UART_UARTCR__RXE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTCR__RXE__MODIFY() modifies UARTCR.RXE.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.RXE
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__RXE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTCR__RXE__Msk);
    reg = (reg | (UART_UARTCR__RXE__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__RXE__EXTRACT() extracts UARTCR.RXE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.RXE
 */
__UART_INLINE uint32_t UART_UARTCR__RXE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__RXE__Msk);
    reg = (reg >> UART_UARTCR__RXE__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTCR.TXE ---------------------------- */

/**
<pre>
  UART.UARTCR.TXE:

    Transmit enable

</pre> */

#define UART_UARTCR__TXE__Pos                                   8                                                                      /*!< Right-most bit position of TXE in UART.UARTCR */
#define UART_UARTCR__TXE__Msk                                   (0x00000001UL << UART_UARTCR__TXE__Pos)                                /*!< Mask for TXE in UART.UARTCR */
#define UART_UARTCR__TXE__Shift(v)                              (((v) << UART_UARTCR__TXE__Pos) & UART_UARTCR__TXE__Msk)               /*!< Shift value 'v' into TXE and mask 'v' to fit it into TXE field */

/** UART_UARTCR__TXE__SET() sets UARTCR.TXE to given value.
 *
 * When writing to UARTCR.TXE, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.TXE
 */
__UART_INLINE void UART_UARTCR__TXE__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__TXE__Msk);
    reg = (reg | (UART_UARTCR__TXE__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__TXE__GET() gets UARTCR.TXE's current value.
 *
 * When reading from UARTCR.TXE, this is recommended to use.
 *
 * @return current value of UARTCR.TXE
 */
__UART_INLINE uint32_t UART_UARTCR__TXE__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__TXE__Msk);
    reg = (reg >> UART_UARTCR__TXE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTCR__TXE__MODIFY() modifies UARTCR.TXE.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.TXE
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__TXE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTCR__TXE__Msk);
    reg = (reg | (UART_UARTCR__TXE__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__TXE__EXTRACT() extracts UARTCR.TXE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.TXE
 */
__UART_INLINE uint32_t UART_UARTCR__TXE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__TXE__Msk);
    reg = (reg >> UART_UARTCR__TXE__Pos);
    return (uint32_t)reg;
}

/* ---------------------------- UART.UARTCR.LBE ---------------------------- */

/**
<pre>
  UART.UARTCR.LBE:

    Loopback enable

</pre> */

#define UART_UARTCR__LBE__Pos                                   7                                                                      /*!< Right-most bit position of LBE in UART.UARTCR */
#define UART_UARTCR__LBE__Msk                                   (0x00000001UL << UART_UARTCR__LBE__Pos)                                /*!< Mask for LBE in UART.UARTCR */
#define UART_UARTCR__LBE__Shift(v)                              (((v) << UART_UARTCR__LBE__Pos) & UART_UARTCR__LBE__Msk)               /*!< Shift value 'v' into LBE and mask 'v' to fit it into LBE field */

/** UART_UARTCR__LBE__SET() sets UARTCR.LBE to given value.
 *
 * When writing to UARTCR.LBE, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.LBE
 */
__UART_INLINE void UART_UARTCR__LBE__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__LBE__Msk);
    reg = (reg | (UART_UARTCR__LBE__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__LBE__GET() gets UARTCR.LBE's current value.
 *
 * When reading from UARTCR.LBE, this is recommended to use.
 *
 * @return current value of UARTCR.LBE
 */
__UART_INLINE uint32_t UART_UARTCR__LBE__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__LBE__Msk);
    reg = (reg >> UART_UARTCR__LBE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTCR__LBE__MODIFY() modifies UARTCR.LBE.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.LBE
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__LBE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTCR__LBE__Msk);
    reg = (reg | (UART_UARTCR__LBE__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__LBE__EXTRACT() extracts UARTCR.LBE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.LBE
 */
__UART_INLINE uint32_t UART_UARTCR__LBE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__LBE__Msk);
    reg = (reg >> UART_UARTCR__LBE__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTCR.SIRLP --------------------------- */

/**
<pre>
  UART.UARTCR.SIRLP:

    SIR low-power IrDA mode

</pre> */

#define UART_UARTCR__SIRLP__Pos                                 2                                                                      /*!< Right-most bit position of SIRLP in UART.UARTCR */
#define UART_UARTCR__SIRLP__Msk                                 (0x00000001UL << UART_UARTCR__SIRLP__Pos)                              /*!< Mask for SIRLP in UART.UARTCR */
#define UART_UARTCR__SIRLP__Shift(v)                            (((v) << UART_UARTCR__SIRLP__Pos) & UART_UARTCR__SIRLP__Msk)           /*!< Shift value 'v' into SIRLP and mask 'v' to fit it into SIRLP field */

/** UART_UARTCR__SIRLP__SET() sets UARTCR.SIRLP to given value.
 *
 * When writing to UARTCR.SIRLP, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.SIRLP
 */
__UART_INLINE void UART_UARTCR__SIRLP__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__SIRLP__Msk);
    reg = (reg | (UART_UARTCR__SIRLP__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__SIRLP__GET() gets UARTCR.SIRLP's current value.
 *
 * When reading from UARTCR.SIRLP, this is recommended to use.
 *
 * @return current value of UARTCR.SIRLP
 */
__UART_INLINE uint32_t UART_UARTCR__SIRLP__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__SIRLP__Msk);
    reg = (reg >> UART_UARTCR__SIRLP__Pos);
    return (uint32_t)reg;
}

/** UART_UARTCR__SIRLP__MODIFY() modifies UARTCR.SIRLP.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.SIRLP
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__SIRLP__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTCR__SIRLP__Msk);
    reg = (reg | (UART_UARTCR__SIRLP__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__SIRLP__EXTRACT() extracts UARTCR.SIRLP.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.SIRLP
 */
__UART_INLINE uint32_t UART_UARTCR__SIRLP__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__SIRLP__Msk);
    reg = (reg >> UART_UARTCR__SIRLP__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTCR.SIREN --------------------------- */

/**
<pre>
  UART.UARTCR.SIREN:

    SIR enable

</pre> */

/*lint -parent(uint32_t, uart_uartcr__siren_t) -strong(AJX)*/
typedef enum uart_uartcr__siren_e                                                                                                      /*!< SIR enable */
{
    uart_uartcr__siren_low = 0u,                                                                                                       /*!<      IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pu...(more) */
    uart_uartcr__siren_high = 1u                                                                                                       /*!<      IrDA SIR ENDEC is enabled. Data is transmitted and received ...(more) */
} uart_uartcr__siren_t;

#define UART_UARTCR__SIREN__Pos                                 1                                                                      /*!< Right-most bit position of SIREN in UART.UARTCR */
#define UART_UARTCR__SIREN__Msk                                 (0x00000001UL << UART_UARTCR__SIREN__Pos)                              /*!< Mask for SIREN in UART.UARTCR */
#define UART_UARTCR__SIREN__Shift(v)                            (((v) << UART_UARTCR__SIREN__Pos) & UART_UARTCR__SIREN__Msk)           /*!< Shift value 'v' into SIREN and mask 'v' to fit it into SIREN field */

/** UART_UARTCR__SIREN__SET() sets UARTCR.SIREN to given value.
 *
 * When writing to UARTCR.SIREN, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.SIREN
 */
__UART_INLINE void UART_UARTCR__SIREN__SET(uart_uartcr__siren_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__SIREN__Msk);
    reg = (reg | (UART_UARTCR__SIREN__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__SIREN__GET() gets UARTCR.SIREN's current value.
 *
 * When reading from UARTCR.SIREN, this is recommended to use.
 *
 * @return current value of UARTCR.SIREN
 */
__UART_INLINE uart_uartcr__siren_t UART_UARTCR__SIREN__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__SIREN__Msk);
    reg = (reg >> UART_UARTCR__SIREN__Pos);
    return (uart_uartcr__siren_t)reg;
}

/** UART_UARTCR__SIREN__MODIFY() modifies UARTCR.SIREN.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.SIREN
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__SIREN__MODIFY(uint32_t reg, uart_uartcr__siren_t bf_value)
{
    reg = (reg & ~UART_UARTCR__SIREN__Msk);
    reg = (reg | (UART_UARTCR__SIREN__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__SIREN__EXTRACT() extracts UARTCR.SIREN.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.SIREN
 */
__UART_INLINE uart_uartcr__siren_t UART_UARTCR__SIREN__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__SIREN__Msk);
    reg = (reg >> UART_UARTCR__SIREN__Pos);
    return (uart_uartcr__siren_t)reg;
}

/* --------------------------- UART.UARTCR.UARTEN --------------------------- */

/**
<pre>
  UART.UARTCR.UARTEN:

    UART enable

</pre> */

/*lint -parent(uint32_t, uart_uartcr__uarten_t) -strong(AJX)*/
typedef enum uart_uartcr__uarten_e                                                                                                     /*!< UART enable */
{
    uart_uartcr__uarten_low = 0u,                                                                                                      /*!<      UART is disabled. If the UART is disabled in the middle of t...(more) */
    uart_uartcr__uarten_high = 1u                                                                                                      /*!<      UART is enabled. Data transmission and reception occurs for ...(more) */
} uart_uartcr__uarten_t;

#define UART_UARTCR__UARTEN__Pos                                0                                                                      /*!< Right-most bit position of UARTEN in UART.UARTCR */
#define UART_UARTCR__UARTEN__Msk                                (0x00000001UL << UART_UARTCR__UARTEN__Pos)                             /*!< Mask for UARTEN in UART.UARTCR */
#define UART_UARTCR__UARTEN__Shift(v)                           (((v) << UART_UARTCR__UARTEN__Pos) & UART_UARTCR__UARTEN__Msk)         /*!< Shift value 'v' into UARTEN and mask 'v' to fit it into UARTEN field */

/** UART_UARTCR__UARTEN__SET() sets UARTCR.UARTEN to given value.
 *
 * When writing to UARTCR.UARTEN, this is recommended to use.
 *
 * @param bf_value new value for UARTCR.UARTEN
 */
__UART_INLINE void UART_UARTCR__UARTEN__SET(uart_uartcr__uarten_t bf_value)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & ~UART_UARTCR__UARTEN__Msk);
    reg = (reg | (UART_UARTCR__UARTEN__Shift((uint32_t)bf_value)));
    UART_UARTCR__SET(reg);
}

/** UART_UARTCR__UARTEN__GET() gets UARTCR.UARTEN's current value.
 *
 * When reading from UARTCR.UARTEN, this is recommended to use.
 *
 * @return current value of UARTCR.UARTEN
 */
__UART_INLINE uart_uartcr__uarten_t UART_UARTCR__UARTEN__GET(void)
{
    uint32_t reg = UART_UARTCR__GET();
    reg = (reg & UART_UARTCR__UARTEN__Msk);
    reg = (reg >> UART_UARTCR__UARTEN__Pos);
    return (uart_uartcr__uarten_t)reg;
}

/** UART_UARTCR__UARTEN__MODIFY() modifies UARTCR.UARTEN.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTCR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTCR
 * @param bf_value new value for UARTCR.UARTEN
 * @return new value of UART.UARTCR
 */
__UART_INLINE uint32_t UART_UARTCR__UARTEN__MODIFY(uint32_t reg, uart_uartcr__uarten_t bf_value)
{
    reg = (reg & ~UART_UARTCR__UARTEN__Msk);
    reg = (reg | (UART_UARTCR__UARTEN__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTCR__UARTEN__EXTRACT() extracts UARTCR.UARTEN.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTCR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTCR
 * @return current value of UARTCR.UARTEN
 */
__UART_INLINE uart_uartcr__uarten_t UART_UARTCR__UARTEN__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTCR__UARTEN__Msk);
    reg = (reg >> UART_UARTCR__UARTEN__Pos);
    return (uart_uartcr__uarten_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         UARTIFLS member of UART_t                         */
/* -------------------------------------------------------------------------- */

/** __UART_UARTIFLS__ADDRESS returns the address of member UARTIFLS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTIFLS
 */
__UART_INLINE uint32_t* __UART_UARTIFLS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTIFLS)));
}

/** UART_UARTIFLS__SET() sets UARTIFLS to given value.
 *
 * When writing to UARTIFLS, this is mandatory to use.
 *
 * @param value new value for UARTIFLS
 */
__UART_INLINE void UART_UARTIFLS__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTIFLS__ADDRESS(), value);
}

/** UART_UARTIFLS__GET() gets UARTIFLS's current value.
 *
 * When reading from UARTIFLS, this is mandatory to use.
 *
 * @return current value of UARTIFLS
 */
__UART_INLINE uint32_t UART_UARTIFLS__GET(void)
{
    return HAL_GET32(__UART_UARTIFLS__ADDRESS());
}

/* ------------------------- UART.UARTIFLS.RXIFLSEL ------------------------- */

/**
<pre>
  UART.UARTIFLS.RXIFLSEL:

    Receive interrupt FIFO level select

</pre> */

/*lint -parent(uint32_t, uart_uartifls__rxiflsel_t) -strong(AJX)*/
typedef enum uart_uartifls__rxiflsel_e                                                                                                 /*!< Receive interrupt FIFO level select */
{
    uart_uartifls__rxiflsel_s0 = 0u,                                                                                                   /*!<      Receive FIFO becomes&gt;1/8 full */
    uart_uartifls__rxiflsel_s6s7 = 0u,                                                                                                 /*!<      reserved */
    uart_uartifls__rxiflsel_s1 = 1u,                                                                                                   /*!<      Receive FIFO becomes&gt;1/4 full */
    uart_uartifls__rxiflsel_s2 = 2u,                                                                                                   /*!<      Receive FIFO becomes&gt;1/2 full */
    uart_uartifls__rxiflsel_s3 = 3u,                                                                                                   /*!<      Receive FIFO becomes&gt;3/4 full */
    uart_uartifls__rxiflsel_s4 = 4u,                                                                                                   /*!<      Receive FIFO becomes&gt;7/8 full */
    uart_uartifls__rxiflsel_s5 = 5u                                                                                                    /*!<      reserved */
} uart_uartifls__rxiflsel_t;

#define UART_UARTIFLS__RXIFLSEL__Pos                            3                                                                      /*!< Right-most bit position of RXIFLSEL in UART.UARTIFLS */
#define UART_UARTIFLS__RXIFLSEL__Msk                            (0x00000007UL << UART_UARTIFLS__RXIFLSEL__Pos)                         /*!< Mask for RXIFLSEL in UART.UARTIFLS */
#define UART_UARTIFLS__RXIFLSEL__Shift(v)                       (((v) << UART_UARTIFLS__RXIFLSEL__Pos) & UART_UARTIFLS__RXIFLSEL__Msk) /*!< Shift value 'v' into RXIFLSEL and mask 'v' to fit it into RXIFLSEL field */

/** UART_UARTIFLS__RXIFLSEL__SET() sets UARTIFLS.RXIFLSEL to given value.
 *
 * When writing to UARTIFLS.RXIFLSEL, this is recommended to use.
 *
 * @param bf_value new value for UARTIFLS.RXIFLSEL
 */
__UART_INLINE void UART_UARTIFLS__RXIFLSEL__SET(uart_uartifls__rxiflsel_t bf_value)
{
    uint32_t reg = UART_UARTIFLS__GET();
    reg = (reg & ~UART_UARTIFLS__RXIFLSEL__Msk);
    reg = (reg | (UART_UARTIFLS__RXIFLSEL__Shift((uint32_t)bf_value)));
    UART_UARTIFLS__SET(reg);
}

/** UART_UARTIFLS__RXIFLSEL__GET() gets UARTIFLS.RXIFLSEL's current value.
 *
 * When reading from UARTIFLS.RXIFLSEL, this is recommended to use.
 *
 * @return current value of UARTIFLS.RXIFLSEL
 */
__UART_INLINE uart_uartifls__rxiflsel_t UART_UARTIFLS__RXIFLSEL__GET(void)
{
    uint32_t reg = UART_UARTIFLS__GET();
    reg = (reg & UART_UARTIFLS__RXIFLSEL__Msk);
    reg = (reg >> UART_UARTIFLS__RXIFLSEL__Pos);
    return (uart_uartifls__rxiflsel_t)reg;
}

/** UART_UARTIFLS__RXIFLSEL__MODIFY() modifies UARTIFLS.RXIFLSEL.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIFLS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIFLS
 * @param bf_value new value for UARTIFLS.RXIFLSEL
 * @return new value of UART.UARTIFLS
 */
__UART_INLINE uint32_t UART_UARTIFLS__RXIFLSEL__MODIFY(uint32_t reg, uart_uartifls__rxiflsel_t bf_value)
{
    reg = (reg & ~UART_UARTIFLS__RXIFLSEL__Msk);
    reg = (reg | (UART_UARTIFLS__RXIFLSEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIFLS__RXIFLSEL__EXTRACT() extracts UARTIFLS.RXIFLSEL.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIFLS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIFLS
 * @return current value of UARTIFLS.RXIFLSEL
 */
__UART_INLINE uart_uartifls__rxiflsel_t UART_UARTIFLS__RXIFLSEL__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIFLS__RXIFLSEL__Msk);
    reg = (reg >> UART_UARTIFLS__RXIFLSEL__Pos);
    return (uart_uartifls__rxiflsel_t)reg;
}

/* ------------------------- UART.UARTIFLS.TXIFLSEL ------------------------- */

/**
<pre>
  UART.UARTIFLS.TXIFLSEL:

    Transmit interrupt FIFO level select

</pre> */

/*lint -parent(uint32_t, uart_uartifls__txiflsel_t) -strong(AJX)*/
typedef enum uart_uartifls__txiflsel_e                                                                                                 /*!< Transmit interrupt FIFO level select */
{
    uart_uartifls__txiflsel_s0 = 0u,                                                                                                   /*!<      Transmit FIFO becomes&lt;1/8 full */
    uart_uartifls__txiflsel_s6s7 = 0u,                                                                                                 /*!<      reserved */
    uart_uartifls__txiflsel_s1 = 1u,                                                                                                   /*!<      Transmit FIFO becomes&lt;1/4 full */
    uart_uartifls__txiflsel_s2 = 2u,                                                                                                   /*!<      Transmit FIFO becomes&lt;1/2 full */
    uart_uartifls__txiflsel_s3 = 3u,                                                                                                   /*!<      Transmit FIFO becomes&lt;3/4 full */
    uart_uartifls__txiflsel_s4 = 4u,                                                                                                   /*!<      Transmit FIFO becomes&lt;7/8 full */
    uart_uartifls__txiflsel_s5 = 5u                                                                                                    /*!<      reserved */
} uart_uartifls__txiflsel_t;

#define UART_UARTIFLS__TXIFLSEL__Pos                            0                                                                      /*!< Right-most bit position of TXIFLSEL in UART.UARTIFLS */
#define UART_UARTIFLS__TXIFLSEL__Msk                            (0x00000007UL << UART_UARTIFLS__TXIFLSEL__Pos)                         /*!< Mask for TXIFLSEL in UART.UARTIFLS */
#define UART_UARTIFLS__TXIFLSEL__Shift(v)                       (((v) << UART_UARTIFLS__TXIFLSEL__Pos) & UART_UARTIFLS__TXIFLSEL__Msk) /*!< Shift value 'v' into TXIFLSEL and mask 'v' to fit it into TXIFLSEL field */

/** UART_UARTIFLS__TXIFLSEL__SET() sets UARTIFLS.TXIFLSEL to given value.
 *
 * When writing to UARTIFLS.TXIFLSEL, this is recommended to use.
 *
 * @param bf_value new value for UARTIFLS.TXIFLSEL
 */
__UART_INLINE void UART_UARTIFLS__TXIFLSEL__SET(uart_uartifls__txiflsel_t bf_value)
{
    uint32_t reg = UART_UARTIFLS__GET();
    reg = (reg & ~UART_UARTIFLS__TXIFLSEL__Msk);
    reg = (reg | (UART_UARTIFLS__TXIFLSEL__Shift((uint32_t)bf_value)));
    UART_UARTIFLS__SET(reg);
}

/** UART_UARTIFLS__TXIFLSEL__GET() gets UARTIFLS.TXIFLSEL's current value.
 *
 * When reading from UARTIFLS.TXIFLSEL, this is recommended to use.
 *
 * @return current value of UARTIFLS.TXIFLSEL
 */
__UART_INLINE uart_uartifls__txiflsel_t UART_UARTIFLS__TXIFLSEL__GET(void)
{
    uint32_t reg = UART_UARTIFLS__GET();
    reg = (reg & UART_UARTIFLS__TXIFLSEL__Msk);
    reg = (reg >> UART_UARTIFLS__TXIFLSEL__Pos);
    return (uart_uartifls__txiflsel_t)reg;
}

/** UART_UARTIFLS__TXIFLSEL__MODIFY() modifies UARTIFLS.TXIFLSEL.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIFLS.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIFLS
 * @param bf_value new value for UARTIFLS.TXIFLSEL
 * @return new value of UART.UARTIFLS
 */
__UART_INLINE uint32_t UART_UARTIFLS__TXIFLSEL__MODIFY(uint32_t reg, uart_uartifls__txiflsel_t bf_value)
{
    reg = (reg & ~UART_UARTIFLS__TXIFLSEL__Msk);
    reg = (reg | (UART_UARTIFLS__TXIFLSEL__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIFLS__TXIFLSEL__EXTRACT() extracts UARTIFLS.TXIFLSEL.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIFLS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIFLS
 * @return current value of UARTIFLS.TXIFLSEL
 */
__UART_INLINE uart_uartifls__txiflsel_t UART_UARTIFLS__TXIFLSEL__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIFLS__TXIFLSEL__Msk);
    reg = (reg >> UART_UARTIFLS__TXIFLSEL__Pos);
    return (uart_uartifls__txiflsel_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         UARTIMSC member of UART_t                         */
/* -------------------------------------------------------------------------- */

/** __UART_UARTIMSC__ADDRESS returns the address of member UARTIMSC.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTIMSC
 */
__UART_INLINE uint32_t* __UART_UARTIMSC__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTIMSC)));
}

/** UART_UARTIMSC__SET() sets UARTIMSC to given value.
 *
 * When writing to UARTIMSC, this is mandatory to use.
 *
 * @param value new value for UARTIMSC
 */
__UART_INLINE void UART_UARTIMSC__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTIMSC__ADDRESS(), value);
}

/** UART_UARTIMSC__GET() gets UARTIMSC's current value.
 *
 * When reading from UARTIMSC, this is mandatory to use.
 *
 * @return current value of UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__GET(void)
{
    return HAL_GET32(__UART_UARTIMSC__ADDRESS());
}

/* --------------------------- UART.UARTIMSC.OEIM --------------------------- */

/**
<pre>
  UART.UARTIMSC.OEIM:

    Overrun error interrupt mask

</pre> */

#define UART_UARTIMSC__OEIM__Pos                                10                                                                     /*!< Right-most bit position of OEIM in UART.UARTIMSC */
#define UART_UARTIMSC__OEIM__Msk                                (0x00000001UL << UART_UARTIMSC__OEIM__Pos)                             /*!< Mask for OEIM in UART.UARTIMSC */
#define UART_UARTIMSC__OEIM__Shift(v)                           (((v) << UART_UARTIMSC__OEIM__Pos) & UART_UARTIMSC__OEIM__Msk)         /*!< Shift value 'v' into OEIM and mask 'v' to fit it into OEIM field */

/** UART_UARTIMSC__OEIM__SET() sets UARTIMSC.OEIM to given value.
 *
 * When writing to UARTIMSC.OEIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.OEIM
 */
__UART_INLINE void UART_UARTIMSC__OEIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__OEIM__Msk);
    reg = (reg | (UART_UARTIMSC__OEIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__OEIM__GET() gets UARTIMSC.OEIM's current value.
 *
 * When reading from UARTIMSC.OEIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.OEIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__OEIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__OEIM__Msk);
    reg = (reg >> UART_UARTIMSC__OEIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__OEIM__MODIFY() modifies UARTIMSC.OEIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.OEIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__OEIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__OEIM__Msk);
    reg = (reg | (UART_UARTIMSC__OEIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__OEIM__EXTRACT() extracts UARTIMSC.OEIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.OEIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__OEIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__OEIM__Msk);
    reg = (reg >> UART_UARTIMSC__OEIM__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTIMSC.BEIM --------------------------- */

/**
<pre>
  UART.UARTIMSC.BEIM:

    Break error interrupt mask

</pre> */

#define UART_UARTIMSC__BEIM__Pos                                9                                                                      /*!< Right-most bit position of BEIM in UART.UARTIMSC */
#define UART_UARTIMSC__BEIM__Msk                                (0x00000001UL << UART_UARTIMSC__BEIM__Pos)                             /*!< Mask for BEIM in UART.UARTIMSC */
#define UART_UARTIMSC__BEIM__Shift(v)                           (((v) << UART_UARTIMSC__BEIM__Pos) & UART_UARTIMSC__BEIM__Msk)         /*!< Shift value 'v' into BEIM and mask 'v' to fit it into BEIM field */

/** UART_UARTIMSC__BEIM__SET() sets UARTIMSC.BEIM to given value.
 *
 * When writing to UARTIMSC.BEIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.BEIM
 */
__UART_INLINE void UART_UARTIMSC__BEIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__BEIM__Msk);
    reg = (reg | (UART_UARTIMSC__BEIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__BEIM__GET() gets UARTIMSC.BEIM's current value.
 *
 * When reading from UARTIMSC.BEIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.BEIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__BEIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__BEIM__Msk);
    reg = (reg >> UART_UARTIMSC__BEIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__BEIM__MODIFY() modifies UARTIMSC.BEIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.BEIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__BEIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__BEIM__Msk);
    reg = (reg | (UART_UARTIMSC__BEIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__BEIM__EXTRACT() extracts UARTIMSC.BEIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.BEIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__BEIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__BEIM__Msk);
    reg = (reg >> UART_UARTIMSC__BEIM__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTIMSC.PEIM --------------------------- */

/**
<pre>
  UART.UARTIMSC.PEIM:

    Parity error interrupt mask

</pre> */

#define UART_UARTIMSC__PEIM__Pos                                8                                                                      /*!< Right-most bit position of PEIM in UART.UARTIMSC */
#define UART_UARTIMSC__PEIM__Msk                                (0x00000001UL << UART_UARTIMSC__PEIM__Pos)                             /*!< Mask for PEIM in UART.UARTIMSC */
#define UART_UARTIMSC__PEIM__Shift(v)                           (((v) << UART_UARTIMSC__PEIM__Pos) & UART_UARTIMSC__PEIM__Msk)         /*!< Shift value 'v' into PEIM and mask 'v' to fit it into PEIM field */

/** UART_UARTIMSC__PEIM__SET() sets UARTIMSC.PEIM to given value.
 *
 * When writing to UARTIMSC.PEIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.PEIM
 */
__UART_INLINE void UART_UARTIMSC__PEIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__PEIM__Msk);
    reg = (reg | (UART_UARTIMSC__PEIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__PEIM__GET() gets UARTIMSC.PEIM's current value.
 *
 * When reading from UARTIMSC.PEIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.PEIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__PEIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__PEIM__Msk);
    reg = (reg >> UART_UARTIMSC__PEIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__PEIM__MODIFY() modifies UARTIMSC.PEIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.PEIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__PEIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__PEIM__Msk);
    reg = (reg | (UART_UARTIMSC__PEIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__PEIM__EXTRACT() extracts UARTIMSC.PEIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.PEIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__PEIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__PEIM__Msk);
    reg = (reg >> UART_UARTIMSC__PEIM__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTIMSC.FEIM --------------------------- */

/**
<pre>
  UART.UARTIMSC.FEIM:

    Framing error interrupt mask

</pre> */

#define UART_UARTIMSC__FEIM__Pos                                7                                                                      /*!< Right-most bit position of FEIM in UART.UARTIMSC */
#define UART_UARTIMSC__FEIM__Msk                                (0x00000001UL << UART_UARTIMSC__FEIM__Pos)                             /*!< Mask for FEIM in UART.UARTIMSC */
#define UART_UARTIMSC__FEIM__Shift(v)                           (((v) << UART_UARTIMSC__FEIM__Pos) & UART_UARTIMSC__FEIM__Msk)         /*!< Shift value 'v' into FEIM and mask 'v' to fit it into FEIM field */

/** UART_UARTIMSC__FEIM__SET() sets UARTIMSC.FEIM to given value.
 *
 * When writing to UARTIMSC.FEIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.FEIM
 */
__UART_INLINE void UART_UARTIMSC__FEIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__FEIM__Msk);
    reg = (reg | (UART_UARTIMSC__FEIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__FEIM__GET() gets UARTIMSC.FEIM's current value.
 *
 * When reading from UARTIMSC.FEIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.FEIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__FEIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__FEIM__Msk);
    reg = (reg >> UART_UARTIMSC__FEIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__FEIM__MODIFY() modifies UARTIMSC.FEIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.FEIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__FEIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__FEIM__Msk);
    reg = (reg | (UART_UARTIMSC__FEIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__FEIM__EXTRACT() extracts UARTIMSC.FEIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.FEIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__FEIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__FEIM__Msk);
    reg = (reg >> UART_UARTIMSC__FEIM__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTIMSC.RTIM --------------------------- */

/**
<pre>
  UART.UARTIMSC.RTIM:

    Receive timeout interrupt mask

</pre> */

#define UART_UARTIMSC__RTIM__Pos                                6                                                                      /*!< Right-most bit position of RTIM in UART.UARTIMSC */
#define UART_UARTIMSC__RTIM__Msk                                (0x00000001UL << UART_UARTIMSC__RTIM__Pos)                             /*!< Mask for RTIM in UART.UARTIMSC */
#define UART_UARTIMSC__RTIM__Shift(v)                           (((v) << UART_UARTIMSC__RTIM__Pos) & UART_UARTIMSC__RTIM__Msk)         /*!< Shift value 'v' into RTIM and mask 'v' to fit it into RTIM field */

/** UART_UARTIMSC__RTIM__SET() sets UARTIMSC.RTIM to given value.
 *
 * When writing to UARTIMSC.RTIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.RTIM
 */
__UART_INLINE void UART_UARTIMSC__RTIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__RTIM__Msk);
    reg = (reg | (UART_UARTIMSC__RTIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__RTIM__GET() gets UARTIMSC.RTIM's current value.
 *
 * When reading from UARTIMSC.RTIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.RTIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__RTIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__RTIM__Msk);
    reg = (reg >> UART_UARTIMSC__RTIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__RTIM__MODIFY() modifies UARTIMSC.RTIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.RTIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__RTIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__RTIM__Msk);
    reg = (reg | (UART_UARTIMSC__RTIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__RTIM__EXTRACT() extracts UARTIMSC.RTIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.RTIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__RTIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__RTIM__Msk);
    reg = (reg >> UART_UARTIMSC__RTIM__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTIMSC.TXIM --------------------------- */

/**
<pre>
  UART.UARTIMSC.TXIM:

    Transmit interrupt mask

</pre> */

#define UART_UARTIMSC__TXIM__Pos                                5                                                                      /*!< Right-most bit position of TXIM in UART.UARTIMSC */
#define UART_UARTIMSC__TXIM__Msk                                (0x00000001UL << UART_UARTIMSC__TXIM__Pos)                             /*!< Mask for TXIM in UART.UARTIMSC */
#define UART_UARTIMSC__TXIM__Shift(v)                           (((v) << UART_UARTIMSC__TXIM__Pos) & UART_UARTIMSC__TXIM__Msk)         /*!< Shift value 'v' into TXIM and mask 'v' to fit it into TXIM field */

/** UART_UARTIMSC__TXIM__SET() sets UARTIMSC.TXIM to given value.
 *
 * When writing to UARTIMSC.TXIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.TXIM
 */
__UART_INLINE void UART_UARTIMSC__TXIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__TXIM__Msk);
    reg = (reg | (UART_UARTIMSC__TXIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__TXIM__GET() gets UARTIMSC.TXIM's current value.
 *
 * When reading from UARTIMSC.TXIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.TXIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__TXIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__TXIM__Msk);
    reg = (reg >> UART_UARTIMSC__TXIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__TXIM__MODIFY() modifies UARTIMSC.TXIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.TXIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__TXIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__TXIM__Msk);
    reg = (reg | (UART_UARTIMSC__TXIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__TXIM__EXTRACT() extracts UARTIMSC.TXIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.TXIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__TXIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__TXIM__Msk);
    reg = (reg >> UART_UARTIMSC__TXIM__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTIMSC.RXIM --------------------------- */

/**
<pre>
  UART.UARTIMSC.RXIM:

    Receive interrupt mask

</pre> */

#define UART_UARTIMSC__RXIM__Pos                                4                                                                      /*!< Right-most bit position of RXIM in UART.UARTIMSC */
#define UART_UARTIMSC__RXIM__Msk                                (0x00000001UL << UART_UARTIMSC__RXIM__Pos)                             /*!< Mask for RXIM in UART.UARTIMSC */
#define UART_UARTIMSC__RXIM__Shift(v)                           (((v) << UART_UARTIMSC__RXIM__Pos) & UART_UARTIMSC__RXIM__Msk)         /*!< Shift value 'v' into RXIM and mask 'v' to fit it into RXIM field */

/** UART_UARTIMSC__RXIM__SET() sets UARTIMSC.RXIM to given value.
 *
 * When writing to UARTIMSC.RXIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.RXIM
 */
__UART_INLINE void UART_UARTIMSC__RXIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__RXIM__Msk);
    reg = (reg | (UART_UARTIMSC__RXIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__RXIM__GET() gets UARTIMSC.RXIM's current value.
 *
 * When reading from UARTIMSC.RXIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.RXIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__RXIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__RXIM__Msk);
    reg = (reg >> UART_UARTIMSC__RXIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__RXIM__MODIFY() modifies UARTIMSC.RXIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.RXIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__RXIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__RXIM__Msk);
    reg = (reg | (UART_UARTIMSC__RXIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__RXIM__EXTRACT() extracts UARTIMSC.RXIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.RXIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__RXIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__RXIM__Msk);
    reg = (reg >> UART_UARTIMSC__RXIM__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTIMSC.DSRMIM -------------------------- */

/**
<pre>
  UART.UARTIMSC.DSRMIM:

    nUARTDSR modem interrupt mask

</pre> */

#define UART_UARTIMSC__DSRMIM__Pos                              3                                                                      /*!< Right-most bit position of DSRMIM in UART.UARTIMSC */
#define UART_UARTIMSC__DSRMIM__Msk                              (0x00000001UL << UART_UARTIMSC__DSRMIM__Pos)                           /*!< Mask for DSRMIM in UART.UARTIMSC */
#define UART_UARTIMSC__DSRMIM__Shift(v)                         (((v) << UART_UARTIMSC__DSRMIM__Pos) & UART_UARTIMSC__DSRMIM__Msk)     /*!< Shift value 'v' into DSRMIM and mask 'v' to fit it into DSRMIM field */

/** UART_UARTIMSC__DSRMIM__SET() sets UARTIMSC.DSRMIM to given value.
 *
 * When writing to UARTIMSC.DSRMIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.DSRMIM
 */
__UART_INLINE void UART_UARTIMSC__DSRMIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__DSRMIM__Msk);
    reg = (reg | (UART_UARTIMSC__DSRMIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__DSRMIM__GET() gets UARTIMSC.DSRMIM's current value.
 *
 * When reading from UARTIMSC.DSRMIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.DSRMIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__DSRMIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__DSRMIM__Msk);
    reg = (reg >> UART_UARTIMSC__DSRMIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__DSRMIM__MODIFY() modifies UARTIMSC.DSRMIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.DSRMIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__DSRMIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__DSRMIM__Msk);
    reg = (reg | (UART_UARTIMSC__DSRMIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__DSRMIM__EXTRACT() extracts UARTIMSC.DSRMIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.DSRMIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__DSRMIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__DSRMIM__Msk);
    reg = (reg >> UART_UARTIMSC__DSRMIM__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTIMSC.DCDMIM -------------------------- */

/**
<pre>
  UART.UARTIMSC.DCDMIM:

    nUARTDCD modem interrupt mask

</pre> */

#define UART_UARTIMSC__DCDMIM__Pos                              2                                                                      /*!< Right-most bit position of DCDMIM in UART.UARTIMSC */
#define UART_UARTIMSC__DCDMIM__Msk                              (0x00000001UL << UART_UARTIMSC__DCDMIM__Pos)                           /*!< Mask for DCDMIM in UART.UARTIMSC */
#define UART_UARTIMSC__DCDMIM__Shift(v)                         (((v) << UART_UARTIMSC__DCDMIM__Pos) & UART_UARTIMSC__DCDMIM__Msk)     /*!< Shift value 'v' into DCDMIM and mask 'v' to fit it into DCDMIM field */

/** UART_UARTIMSC__DCDMIM__SET() sets UARTIMSC.DCDMIM to given value.
 *
 * When writing to UARTIMSC.DCDMIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.DCDMIM
 */
__UART_INLINE void UART_UARTIMSC__DCDMIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__DCDMIM__Msk);
    reg = (reg | (UART_UARTIMSC__DCDMIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__DCDMIM__GET() gets UARTIMSC.DCDMIM's current value.
 *
 * When reading from UARTIMSC.DCDMIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.DCDMIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__DCDMIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__DCDMIM__Msk);
    reg = (reg >> UART_UARTIMSC__DCDMIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__DCDMIM__MODIFY() modifies UARTIMSC.DCDMIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.DCDMIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__DCDMIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__DCDMIM__Msk);
    reg = (reg | (UART_UARTIMSC__DCDMIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__DCDMIM__EXTRACT() extracts UARTIMSC.DCDMIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.DCDMIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__DCDMIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__DCDMIM__Msk);
    reg = (reg >> UART_UARTIMSC__DCDMIM__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTIMSC.CTSMIM -------------------------- */

/**
<pre>
  UART.UARTIMSC.CTSMIM:

    nUARTCTS modem interrupt mask

</pre> */

#define UART_UARTIMSC__CTSMIM__Pos                              1                                                                      /*!< Right-most bit position of CTSMIM in UART.UARTIMSC */
#define UART_UARTIMSC__CTSMIM__Msk                              (0x00000001UL << UART_UARTIMSC__CTSMIM__Pos)                           /*!< Mask for CTSMIM in UART.UARTIMSC */
#define UART_UARTIMSC__CTSMIM__Shift(v)                         (((v) << UART_UARTIMSC__CTSMIM__Pos) & UART_UARTIMSC__CTSMIM__Msk)     /*!< Shift value 'v' into CTSMIM and mask 'v' to fit it into CTSMIM field */

/** UART_UARTIMSC__CTSMIM__SET() sets UARTIMSC.CTSMIM to given value.
 *
 * When writing to UARTIMSC.CTSMIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.CTSMIM
 */
__UART_INLINE void UART_UARTIMSC__CTSMIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__CTSMIM__Msk);
    reg = (reg | (UART_UARTIMSC__CTSMIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__CTSMIM__GET() gets UARTIMSC.CTSMIM's current value.
 *
 * When reading from UARTIMSC.CTSMIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.CTSMIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__CTSMIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__CTSMIM__Msk);
    reg = (reg >> UART_UARTIMSC__CTSMIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__CTSMIM__MODIFY() modifies UARTIMSC.CTSMIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.CTSMIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__CTSMIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__CTSMIM__Msk);
    reg = (reg | (UART_UARTIMSC__CTSMIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__CTSMIM__EXTRACT() extracts UARTIMSC.CTSMIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.CTSMIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__CTSMIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__CTSMIM__Msk);
    reg = (reg >> UART_UARTIMSC__CTSMIM__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTIMSC.RIMIM -------------------------- */

/**
<pre>
  UART.UARTIMSC.RIMIM:

    nUARTRI modem interrupt mask

</pre> */

#define UART_UARTIMSC__RIMIM__Pos                               0                                                                      /*!< Right-most bit position of RIMIM in UART.UARTIMSC */
#define UART_UARTIMSC__RIMIM__Msk                               (0x00000001UL << UART_UARTIMSC__RIMIM__Pos)                            /*!< Mask for RIMIM in UART.UARTIMSC */
#define UART_UARTIMSC__RIMIM__Shift(v)                          (((v) << UART_UARTIMSC__RIMIM__Pos) & UART_UARTIMSC__RIMIM__Msk)       /*!< Shift value 'v' into RIMIM and mask 'v' to fit it into RIMIM field */

/** UART_UARTIMSC__RIMIM__SET() sets UARTIMSC.RIMIM to given value.
 *
 * When writing to UARTIMSC.RIMIM, this is recommended to use.
 *
 * @param bf_value new value for UARTIMSC.RIMIM
 */
__UART_INLINE void UART_UARTIMSC__RIMIM__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & ~UART_UARTIMSC__RIMIM__Msk);
    reg = (reg | (UART_UARTIMSC__RIMIM__Shift((uint32_t)bf_value)));
    UART_UARTIMSC__SET(reg);
}

/** UART_UARTIMSC__RIMIM__GET() gets UARTIMSC.RIMIM's current value.
 *
 * When reading from UARTIMSC.RIMIM, this is recommended to use.
 *
 * @return current value of UARTIMSC.RIMIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__RIMIM__GET(void)
{
    uint32_t reg = UART_UARTIMSC__GET();
    reg = (reg & UART_UARTIMSC__RIMIM__Msk);
    reg = (reg >> UART_UARTIMSC__RIMIM__Pos);
    return (uint32_t)reg;
}

/** UART_UARTIMSC__RIMIM__MODIFY() modifies UARTIMSC.RIMIM.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTIMSC.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTIMSC
 * @param bf_value new value for UARTIMSC.RIMIM
 * @return new value of UART.UARTIMSC
 */
__UART_INLINE uint32_t UART_UARTIMSC__RIMIM__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTIMSC__RIMIM__Msk);
    reg = (reg | (UART_UARTIMSC__RIMIM__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTIMSC__RIMIM__EXTRACT() extracts UARTIMSC.RIMIM.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTIMSC.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTIMSC
 * @return current value of UARTIMSC.RIMIM
 */
__UART_INLINE uint32_t UART_UARTIMSC__RIMIM__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTIMSC__RIMIM__Msk);
    reg = (reg >> UART_UARTIMSC__RIMIM__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          UARTRIS member of UART_t                          */
/* -------------------------------------------------------------------------- */

/** __UART_UARTRIS__ADDRESS returns the address of member UARTRIS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTRIS
 */
__UART_INLINE uint32_t* __UART_UARTRIS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTRIS)));
}

/** UART_UARTRIS__GET() gets UARTRIS's current value.
 *
 * When reading from UARTRIS, this is mandatory to use.
 *
 * @return current value of UARTRIS
 */
__UART_INLINE uint32_t UART_UARTRIS__GET(void)
{
    return HAL_GET32(__UART_UARTRIS__ADDRESS());
}

/* --------------------------- UART.UARTRIS.OERIS --------------------------- */

/**
<pre>
  UART.UARTRIS.OERIS:

    Overrun error interrupt status

</pre> */

#define UART_UARTRIS__OERIS__Pos                                10                                                                     /*!< Right-most bit position of OERIS in UART.UARTRIS */
#define UART_UARTRIS__OERIS__Msk                                (0x00000001UL << UART_UARTRIS__OERIS__Pos)                             /*!< Mask for OERIS in UART.UARTRIS */
#define UART_UARTRIS__OERIS__Shift(v)                           (((v) << UART_UARTRIS__OERIS__Pos) & UART_UARTRIS__OERIS__Msk)         /*!< Shift value 'v' into OERIS and mask 'v' to fit it into OERIS field */

/** UART_UARTRIS__OERIS__GET() gets UARTRIS.OERIS's current value.
 *
 * When reading from UARTRIS.OERIS, this is recommended to use.
 *
 * @return current value of UARTRIS.OERIS
 */
__UART_INLINE uint32_t UART_UARTRIS__OERIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__OERIS__Msk);
    reg = (reg >> UART_UARTRIS__OERIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__OERIS__EXTRACT() extracts UARTRIS.OERIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.OERIS
 */
__UART_INLINE uint32_t UART_UARTRIS__OERIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__OERIS__Msk);
    reg = (reg >> UART_UARTRIS__OERIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTRIS.BERIS --------------------------- */

/**
<pre>
  UART.UARTRIS.BERIS:

    Break error interrupt status

</pre> */

#define UART_UARTRIS__BERIS__Pos                                9                                                                      /*!< Right-most bit position of BERIS in UART.UARTRIS */
#define UART_UARTRIS__BERIS__Msk                                (0x00000001UL << UART_UARTRIS__BERIS__Pos)                             /*!< Mask for BERIS in UART.UARTRIS */
#define UART_UARTRIS__BERIS__Shift(v)                           (((v) << UART_UARTRIS__BERIS__Pos) & UART_UARTRIS__BERIS__Msk)         /*!< Shift value 'v' into BERIS and mask 'v' to fit it into BERIS field */

/** UART_UARTRIS__BERIS__GET() gets UARTRIS.BERIS's current value.
 *
 * When reading from UARTRIS.BERIS, this is recommended to use.
 *
 * @return current value of UARTRIS.BERIS
 */
__UART_INLINE uint32_t UART_UARTRIS__BERIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__BERIS__Msk);
    reg = (reg >> UART_UARTRIS__BERIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__BERIS__EXTRACT() extracts UARTRIS.BERIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.BERIS
 */
__UART_INLINE uint32_t UART_UARTRIS__BERIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__BERIS__Msk);
    reg = (reg >> UART_UARTRIS__BERIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTRIS.PERIS --------------------------- */

/**
<pre>
  UART.UARTRIS.PERIS:

    Parity error interrupt status

</pre> */

#define UART_UARTRIS__PERIS__Pos                                8                                                                      /*!< Right-most bit position of PERIS in UART.UARTRIS */
#define UART_UARTRIS__PERIS__Msk                                (0x00000001UL << UART_UARTRIS__PERIS__Pos)                             /*!< Mask for PERIS in UART.UARTRIS */
#define UART_UARTRIS__PERIS__Shift(v)                           (((v) << UART_UARTRIS__PERIS__Pos) & UART_UARTRIS__PERIS__Msk)         /*!< Shift value 'v' into PERIS and mask 'v' to fit it into PERIS field */

/** UART_UARTRIS__PERIS__GET() gets UARTRIS.PERIS's current value.
 *
 * When reading from UARTRIS.PERIS, this is recommended to use.
 *
 * @return current value of UARTRIS.PERIS
 */
__UART_INLINE uint32_t UART_UARTRIS__PERIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__PERIS__Msk);
    reg = (reg >> UART_UARTRIS__PERIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__PERIS__EXTRACT() extracts UARTRIS.PERIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.PERIS
 */
__UART_INLINE uint32_t UART_UARTRIS__PERIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__PERIS__Msk);
    reg = (reg >> UART_UARTRIS__PERIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTRIS.FERIS --------------------------- */

/**
<pre>
  UART.UARTRIS.FERIS:

    Framing error interrupt status

</pre> */

#define UART_UARTRIS__FERIS__Pos                                7                                                                      /*!< Right-most bit position of FERIS in UART.UARTRIS */
#define UART_UARTRIS__FERIS__Msk                                (0x00000001UL << UART_UARTRIS__FERIS__Pos)                             /*!< Mask for FERIS in UART.UARTRIS */
#define UART_UARTRIS__FERIS__Shift(v)                           (((v) << UART_UARTRIS__FERIS__Pos) & UART_UARTRIS__FERIS__Msk)         /*!< Shift value 'v' into FERIS and mask 'v' to fit it into FERIS field */

/** UART_UARTRIS__FERIS__GET() gets UARTRIS.FERIS's current value.
 *
 * When reading from UARTRIS.FERIS, this is recommended to use.
 *
 * @return current value of UARTRIS.FERIS
 */
__UART_INLINE uint32_t UART_UARTRIS__FERIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__FERIS__Msk);
    reg = (reg >> UART_UARTRIS__FERIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__FERIS__EXTRACT() extracts UARTRIS.FERIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.FERIS
 */
__UART_INLINE uint32_t UART_UARTRIS__FERIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__FERIS__Msk);
    reg = (reg >> UART_UARTRIS__FERIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTRIS.RTRIS --------------------------- */

/**
<pre>
  UART.UARTRIS.RTRIS:

    Receive timeout interrupt status

</pre> */

#define UART_UARTRIS__RTRIS__Pos                                6                                                                      /*!< Right-most bit position of RTRIS in UART.UARTRIS */
#define UART_UARTRIS__RTRIS__Msk                                (0x00000001UL << UART_UARTRIS__RTRIS__Pos)                             /*!< Mask for RTRIS in UART.UARTRIS */
#define UART_UARTRIS__RTRIS__Shift(v)                           (((v) << UART_UARTRIS__RTRIS__Pos) & UART_UARTRIS__RTRIS__Msk)         /*!< Shift value 'v' into RTRIS and mask 'v' to fit it into RTRIS field */

/** UART_UARTRIS__RTRIS__GET() gets UARTRIS.RTRIS's current value.
 *
 * When reading from UARTRIS.RTRIS, this is recommended to use.
 *
 * @return current value of UARTRIS.RTRIS
 */
__UART_INLINE uint32_t UART_UARTRIS__RTRIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__RTRIS__Msk);
    reg = (reg >> UART_UARTRIS__RTRIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__RTRIS__EXTRACT() extracts UARTRIS.RTRIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.RTRIS
 */
__UART_INLINE uint32_t UART_UARTRIS__RTRIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__RTRIS__Msk);
    reg = (reg >> UART_UARTRIS__RTRIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTRIS.TXRIS --------------------------- */

/**
<pre>
  UART.UARTRIS.TXRIS:

    Transmit interrupt status

</pre> */

#define UART_UARTRIS__TXRIS__Pos                                5                                                                      /*!< Right-most bit position of TXRIS in UART.UARTRIS */
#define UART_UARTRIS__TXRIS__Msk                                (0x00000001UL << UART_UARTRIS__TXRIS__Pos)                             /*!< Mask for TXRIS in UART.UARTRIS */
#define UART_UARTRIS__TXRIS__Shift(v)                           (((v) << UART_UARTRIS__TXRIS__Pos) & UART_UARTRIS__TXRIS__Msk)         /*!< Shift value 'v' into TXRIS and mask 'v' to fit it into TXRIS field */

/** UART_UARTRIS__TXRIS__GET() gets UARTRIS.TXRIS's current value.
 *
 * When reading from UARTRIS.TXRIS, this is recommended to use.
 *
 * @return current value of UARTRIS.TXRIS
 */
__UART_INLINE uint32_t UART_UARTRIS__TXRIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__TXRIS__Msk);
    reg = (reg >> UART_UARTRIS__TXRIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__TXRIS__EXTRACT() extracts UARTRIS.TXRIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.TXRIS
 */
__UART_INLINE uint32_t UART_UARTRIS__TXRIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__TXRIS__Msk);
    reg = (reg >> UART_UARTRIS__TXRIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTRIS.RXRIS --------------------------- */

/**
<pre>
  UART.UARTRIS.RXRIS:

    Receive interrupt status

</pre> */

#define UART_UARTRIS__RXRIS__Pos                                4                                                                      /*!< Right-most bit position of RXRIS in UART.UARTRIS */
#define UART_UARTRIS__RXRIS__Msk                                (0x00000001UL << UART_UARTRIS__RXRIS__Pos)                             /*!< Mask for RXRIS in UART.UARTRIS */
#define UART_UARTRIS__RXRIS__Shift(v)                           (((v) << UART_UARTRIS__RXRIS__Pos) & UART_UARTRIS__RXRIS__Msk)         /*!< Shift value 'v' into RXRIS and mask 'v' to fit it into RXRIS field */

/** UART_UARTRIS__RXRIS__GET() gets UARTRIS.RXRIS's current value.
 *
 * When reading from UARTRIS.RXRIS, this is recommended to use.
 *
 * @return current value of UARTRIS.RXRIS
 */
__UART_INLINE uint32_t UART_UARTRIS__RXRIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__RXRIS__Msk);
    reg = (reg >> UART_UARTRIS__RXRIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__RXRIS__EXTRACT() extracts UARTRIS.RXRIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.RXRIS
 */
__UART_INLINE uint32_t UART_UARTRIS__RXRIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__RXRIS__Msk);
    reg = (reg >> UART_UARTRIS__RXRIS__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTRIS.DSRRMIS -------------------------- */

/**
<pre>
  UART.UARTRIS.DSRRMIS:

    nUARTDSR modem interrupt status

</pre> */

#define UART_UARTRIS__DSRRMIS__Pos                              3                                                                      /*!< Right-most bit position of DSRRMIS in UART.UARTRIS */
#define UART_UARTRIS__DSRRMIS__Msk                              (0x00000001UL << UART_UARTRIS__DSRRMIS__Pos)                           /*!< Mask for DSRRMIS in UART.UARTRIS */
#define UART_UARTRIS__DSRRMIS__Shift(v)                         (((v) << UART_UARTRIS__DSRRMIS__Pos) & UART_UARTRIS__DSRRMIS__Msk)     /*!< Shift value 'v' into DSRRMIS and mask 'v' to fit it into DSRRMIS field */

/** UART_UARTRIS__DSRRMIS__GET() gets UARTRIS.DSRRMIS's current value.
 *
 * When reading from UARTRIS.DSRRMIS, this is recommended to use.
 *
 * @return current value of UARTRIS.DSRRMIS
 */
__UART_INLINE uint32_t UART_UARTRIS__DSRRMIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__DSRRMIS__Msk);
    reg = (reg >> UART_UARTRIS__DSRRMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__DSRRMIS__EXTRACT() extracts UARTRIS.DSRRMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.DSRRMIS
 */
__UART_INLINE uint32_t UART_UARTRIS__DSRRMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__DSRRMIS__Msk);
    reg = (reg >> UART_UARTRIS__DSRRMIS__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTRIS.DCDRMIS -------------------------- */

/**
<pre>
  UART.UARTRIS.DCDRMIS:

    nUARTDCD modem interrupt status

</pre> */

#define UART_UARTRIS__DCDRMIS__Pos                              2                                                                      /*!< Right-most bit position of DCDRMIS in UART.UARTRIS */
#define UART_UARTRIS__DCDRMIS__Msk                              (0x00000001UL << UART_UARTRIS__DCDRMIS__Pos)                           /*!< Mask for DCDRMIS in UART.UARTRIS */
#define UART_UARTRIS__DCDRMIS__Shift(v)                         (((v) << UART_UARTRIS__DCDRMIS__Pos) & UART_UARTRIS__DCDRMIS__Msk)     /*!< Shift value 'v' into DCDRMIS and mask 'v' to fit it into DCDRMIS field */

/** UART_UARTRIS__DCDRMIS__GET() gets UARTRIS.DCDRMIS's current value.
 *
 * When reading from UARTRIS.DCDRMIS, this is recommended to use.
 *
 * @return current value of UARTRIS.DCDRMIS
 */
__UART_INLINE uint32_t UART_UARTRIS__DCDRMIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__DCDRMIS__Msk);
    reg = (reg >> UART_UARTRIS__DCDRMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__DCDRMIS__EXTRACT() extracts UARTRIS.DCDRMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.DCDRMIS
 */
__UART_INLINE uint32_t UART_UARTRIS__DCDRMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__DCDRMIS__Msk);
    reg = (reg >> UART_UARTRIS__DCDRMIS__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTRIS.CTSRMIS -------------------------- */

/**
<pre>
  UART.UARTRIS.CTSRMIS:

    nUARTCTS modem interrupt status

</pre> */

#define UART_UARTRIS__CTSRMIS__Pos                              1                                                                      /*!< Right-most bit position of CTSRMIS in UART.UARTRIS */
#define UART_UARTRIS__CTSRMIS__Msk                              (0x00000001UL << UART_UARTRIS__CTSRMIS__Pos)                           /*!< Mask for CTSRMIS in UART.UARTRIS */
#define UART_UARTRIS__CTSRMIS__Shift(v)                         (((v) << UART_UARTRIS__CTSRMIS__Pos) & UART_UARTRIS__CTSRMIS__Msk)     /*!< Shift value 'v' into CTSRMIS and mask 'v' to fit it into CTSRMIS field */

/** UART_UARTRIS__CTSRMIS__GET() gets UARTRIS.CTSRMIS's current value.
 *
 * When reading from UARTRIS.CTSRMIS, this is recommended to use.
 *
 * @return current value of UARTRIS.CTSRMIS
 */
__UART_INLINE uint32_t UART_UARTRIS__CTSRMIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__CTSRMIS__Msk);
    reg = (reg >> UART_UARTRIS__CTSRMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__CTSRMIS__EXTRACT() extracts UARTRIS.CTSRMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.CTSRMIS
 */
__UART_INLINE uint32_t UART_UARTRIS__CTSRMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__CTSRMIS__Msk);
    reg = (reg >> UART_UARTRIS__CTSRMIS__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTRIS.RIRMIS -------------------------- */

/**
<pre>
  UART.UARTRIS.RIRMIS:

    nUARTRI modem interrupt status

</pre> */

#define UART_UARTRIS__RIRMIS__Pos                               0                                                                      /*!< Right-most bit position of RIRMIS in UART.UARTRIS */
#define UART_UARTRIS__RIRMIS__Msk                               (0x00000001UL << UART_UARTRIS__RIRMIS__Pos)                            /*!< Mask for RIRMIS in UART.UARTRIS */
#define UART_UARTRIS__RIRMIS__Shift(v)                          (((v) << UART_UARTRIS__RIRMIS__Pos) & UART_UARTRIS__RIRMIS__Msk)       /*!< Shift value 'v' into RIRMIS and mask 'v' to fit it into RIRMIS field */

/** UART_UARTRIS__RIRMIS__GET() gets UARTRIS.RIRMIS's current value.
 *
 * When reading from UARTRIS.RIRMIS, this is recommended to use.
 *
 * @return current value of UARTRIS.RIRMIS
 */
__UART_INLINE uint32_t UART_UARTRIS__RIRMIS__GET(void)
{
    uint32_t reg = UART_UARTRIS__GET();
    reg = (reg & UART_UARTRIS__RIRMIS__Msk);
    reg = (reg >> UART_UARTRIS__RIRMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTRIS__RIRMIS__EXTRACT() extracts UARTRIS.RIRMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTRIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTRIS
 * @return current value of UARTRIS.RIRMIS
 */
__UART_INLINE uint32_t UART_UARTRIS__RIRMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTRIS__RIRMIS__Msk);
    reg = (reg >> UART_UARTRIS__RIRMIS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          UARTMIS member of UART_t                          */
/* -------------------------------------------------------------------------- */

/** __UART_UARTMIS__ADDRESS returns the address of member UARTMIS.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTMIS
 */
__UART_INLINE uint32_t* __UART_UARTMIS__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTMIS)));
}

/** UART_UARTMIS__GET() gets UARTMIS's current value.
 *
 * When reading from UARTMIS, this is mandatory to use.
 *
 * @return current value of UARTMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__GET(void)
{
    return HAL_GET32(__UART_UARTMIS__ADDRESS());
}

/* --------------------------- UART.UARTMIS.OEMIS --------------------------- */

/**
<pre>
  UART.UARTMIS.OEMIS:

    Overrun error masked interrupt status

</pre> */

#define UART_UARTMIS__OEMIS__Pos                                10                                                                     /*!< Right-most bit position of OEMIS in UART.UARTMIS */
#define UART_UARTMIS__OEMIS__Msk                                (0x00000001UL << UART_UARTMIS__OEMIS__Pos)                             /*!< Mask for OEMIS in UART.UARTMIS */
#define UART_UARTMIS__OEMIS__Shift(v)                           (((v) << UART_UARTMIS__OEMIS__Pos) & UART_UARTMIS__OEMIS__Msk)         /*!< Shift value 'v' into OEMIS and mask 'v' to fit it into OEMIS field */

/** UART_UARTMIS__OEMIS__GET() gets UARTMIS.OEMIS's current value.
 *
 * When reading from UARTMIS.OEMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.OEMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__OEMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__OEMIS__Msk);
    reg = (reg >> UART_UARTMIS__OEMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__OEMIS__EXTRACT() extracts UARTMIS.OEMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.OEMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__OEMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__OEMIS__Msk);
    reg = (reg >> UART_UARTMIS__OEMIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTMIS.BEMIS --------------------------- */

/**
<pre>
  UART.UARTMIS.BEMIS:

    Break error masked interrupt status

</pre> */

#define UART_UARTMIS__BEMIS__Pos                                9                                                                      /*!< Right-most bit position of BEMIS in UART.UARTMIS */
#define UART_UARTMIS__BEMIS__Msk                                (0x00000001UL << UART_UARTMIS__BEMIS__Pos)                             /*!< Mask for BEMIS in UART.UARTMIS */
#define UART_UARTMIS__BEMIS__Shift(v)                           (((v) << UART_UARTMIS__BEMIS__Pos) & UART_UARTMIS__BEMIS__Msk)         /*!< Shift value 'v' into BEMIS and mask 'v' to fit it into BEMIS field */

/** UART_UARTMIS__BEMIS__GET() gets UARTMIS.BEMIS's current value.
 *
 * When reading from UARTMIS.BEMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.BEMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__BEMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__BEMIS__Msk);
    reg = (reg >> UART_UARTMIS__BEMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__BEMIS__EXTRACT() extracts UARTMIS.BEMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.BEMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__BEMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__BEMIS__Msk);
    reg = (reg >> UART_UARTMIS__BEMIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTMIS.PEMIS --------------------------- */

/**
<pre>
  UART.UARTMIS.PEMIS:

    Parity error masked interrupt status

</pre> */

#define UART_UARTMIS__PEMIS__Pos                                8                                                                      /*!< Right-most bit position of PEMIS in UART.UARTMIS */
#define UART_UARTMIS__PEMIS__Msk                                (0x00000001UL << UART_UARTMIS__PEMIS__Pos)                             /*!< Mask for PEMIS in UART.UARTMIS */
#define UART_UARTMIS__PEMIS__Shift(v)                           (((v) << UART_UARTMIS__PEMIS__Pos) & UART_UARTMIS__PEMIS__Msk)         /*!< Shift value 'v' into PEMIS and mask 'v' to fit it into PEMIS field */

/** UART_UARTMIS__PEMIS__GET() gets UARTMIS.PEMIS's current value.
 *
 * When reading from UARTMIS.PEMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.PEMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__PEMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__PEMIS__Msk);
    reg = (reg >> UART_UARTMIS__PEMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__PEMIS__EXTRACT() extracts UARTMIS.PEMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.PEMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__PEMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__PEMIS__Msk);
    reg = (reg >> UART_UARTMIS__PEMIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTMIS.FEMIS --------------------------- */

/**
<pre>
  UART.UARTMIS.FEMIS:

    Framing error masked interrupt status

</pre> */

#define UART_UARTMIS__FEMIS__Pos                                7                                                                      /*!< Right-most bit position of FEMIS in UART.UARTMIS */
#define UART_UARTMIS__FEMIS__Msk                                (0x00000001UL << UART_UARTMIS__FEMIS__Pos)                             /*!< Mask for FEMIS in UART.UARTMIS */
#define UART_UARTMIS__FEMIS__Shift(v)                           (((v) << UART_UARTMIS__FEMIS__Pos) & UART_UARTMIS__FEMIS__Msk)         /*!< Shift value 'v' into FEMIS and mask 'v' to fit it into FEMIS field */

/** UART_UARTMIS__FEMIS__GET() gets UARTMIS.FEMIS's current value.
 *
 * When reading from UARTMIS.FEMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.FEMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__FEMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__FEMIS__Msk);
    reg = (reg >> UART_UARTMIS__FEMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__FEMIS__EXTRACT() extracts UARTMIS.FEMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.FEMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__FEMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__FEMIS__Msk);
    reg = (reg >> UART_UARTMIS__FEMIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTMIS.RTMIS --------------------------- */

/**
<pre>
  UART.UARTMIS.RTMIS:

    Receive timeout masked interrupt status

</pre> */

#define UART_UARTMIS__RTMIS__Pos                                6                                                                      /*!< Right-most bit position of RTMIS in UART.UARTMIS */
#define UART_UARTMIS__RTMIS__Msk                                (0x00000001UL << UART_UARTMIS__RTMIS__Pos)                             /*!< Mask for RTMIS in UART.UARTMIS */
#define UART_UARTMIS__RTMIS__Shift(v)                           (((v) << UART_UARTMIS__RTMIS__Pos) & UART_UARTMIS__RTMIS__Msk)         /*!< Shift value 'v' into RTMIS and mask 'v' to fit it into RTMIS field */

/** UART_UARTMIS__RTMIS__GET() gets UARTMIS.RTMIS's current value.
 *
 * When reading from UARTMIS.RTMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.RTMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__RTMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__RTMIS__Msk);
    reg = (reg >> UART_UARTMIS__RTMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__RTMIS__EXTRACT() extracts UARTMIS.RTMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.RTMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__RTMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__RTMIS__Msk);
    reg = (reg >> UART_UARTMIS__RTMIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTMIS.TXMIS --------------------------- */

/**
<pre>
  UART.UARTMIS.TXMIS:

    Transmit masked interrupt status

</pre> */

#define UART_UARTMIS__TXMIS__Pos                                5                                                                      /*!< Right-most bit position of TXMIS in UART.UARTMIS */
#define UART_UARTMIS__TXMIS__Msk                                (0x00000001UL << UART_UARTMIS__TXMIS__Pos)                             /*!< Mask for TXMIS in UART.UARTMIS */
#define UART_UARTMIS__TXMIS__Shift(v)                           (((v) << UART_UARTMIS__TXMIS__Pos) & UART_UARTMIS__TXMIS__Msk)         /*!< Shift value 'v' into TXMIS and mask 'v' to fit it into TXMIS field */

/** UART_UARTMIS__TXMIS__GET() gets UARTMIS.TXMIS's current value.
 *
 * When reading from UARTMIS.TXMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.TXMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__TXMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__TXMIS__Msk);
    reg = (reg >> UART_UARTMIS__TXMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__TXMIS__EXTRACT() extracts UARTMIS.TXMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.TXMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__TXMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__TXMIS__Msk);
    reg = (reg >> UART_UARTMIS__TXMIS__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTMIS.RXMIS --------------------------- */

/**
<pre>
  UART.UARTMIS.RXMIS:

    Receive masked interrupt status

</pre> */

#define UART_UARTMIS__RXMIS__Pos                                4                                                                      /*!< Right-most bit position of RXMIS in UART.UARTMIS */
#define UART_UARTMIS__RXMIS__Msk                                (0x00000001UL << UART_UARTMIS__RXMIS__Pos)                             /*!< Mask for RXMIS in UART.UARTMIS */
#define UART_UARTMIS__RXMIS__Shift(v)                           (((v) << UART_UARTMIS__RXMIS__Pos) & UART_UARTMIS__RXMIS__Msk)         /*!< Shift value 'v' into RXMIS and mask 'v' to fit it into RXMIS field */

/** UART_UARTMIS__RXMIS__GET() gets UARTMIS.RXMIS's current value.
 *
 * When reading from UARTMIS.RXMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.RXMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__RXMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__RXMIS__Msk);
    reg = (reg >> UART_UARTMIS__RXMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__RXMIS__EXTRACT() extracts UARTMIS.RXMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.RXMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__RXMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__RXMIS__Msk);
    reg = (reg >> UART_UARTMIS__RXMIS__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTMIS.DSRMMIS -------------------------- */

/**
<pre>
  UART.UARTMIS.DSRMMIS:

    nUARTDSR modem masked interrupt status

</pre> */

#define UART_UARTMIS__DSRMMIS__Pos                              3                                                                      /*!< Right-most bit position of DSRMMIS in UART.UARTMIS */
#define UART_UARTMIS__DSRMMIS__Msk                              (0x00000001UL << UART_UARTMIS__DSRMMIS__Pos)                           /*!< Mask for DSRMMIS in UART.UARTMIS */
#define UART_UARTMIS__DSRMMIS__Shift(v)                         (((v) << UART_UARTMIS__DSRMMIS__Pos) & UART_UARTMIS__DSRMMIS__Msk)     /*!< Shift value 'v' into DSRMMIS and mask 'v' to fit it into DSRMMIS field */

/** UART_UARTMIS__DSRMMIS__GET() gets UARTMIS.DSRMMIS's current value.
 *
 * When reading from UARTMIS.DSRMMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.DSRMMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__DSRMMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__DSRMMIS__Msk);
    reg = (reg >> UART_UARTMIS__DSRMMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__DSRMMIS__EXTRACT() extracts UARTMIS.DSRMMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.DSRMMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__DSRMMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__DSRMMIS__Msk);
    reg = (reg >> UART_UARTMIS__DSRMMIS__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTMIS.DCDMMIS -------------------------- */

/**
<pre>
  UART.UARTMIS.DCDMMIS:

    nUARTDCD modem masked interrupt status

</pre> */

#define UART_UARTMIS__DCDMMIS__Pos                              2                                                                      /*!< Right-most bit position of DCDMMIS in UART.UARTMIS */
#define UART_UARTMIS__DCDMMIS__Msk                              (0x00000001UL << UART_UARTMIS__DCDMMIS__Pos)                           /*!< Mask for DCDMMIS in UART.UARTMIS */
#define UART_UARTMIS__DCDMMIS__Shift(v)                         (((v) << UART_UARTMIS__DCDMMIS__Pos) & UART_UARTMIS__DCDMMIS__Msk)     /*!< Shift value 'v' into DCDMMIS and mask 'v' to fit it into DCDMMIS field */

/** UART_UARTMIS__DCDMMIS__GET() gets UARTMIS.DCDMMIS's current value.
 *
 * When reading from UARTMIS.DCDMMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.DCDMMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__DCDMMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__DCDMMIS__Msk);
    reg = (reg >> UART_UARTMIS__DCDMMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__DCDMMIS__EXTRACT() extracts UARTMIS.DCDMMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.DCDMMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__DCDMMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__DCDMMIS__Msk);
    reg = (reg >> UART_UARTMIS__DCDMMIS__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTMIS.CTSMMIS -------------------------- */

/**
<pre>
  UART.UARTMIS.CTSMMIS:

    nUARTCTS modem masked interrupt status

</pre> */

#define UART_UARTMIS__CTSMMIS__Pos                              1                                                                      /*!< Right-most bit position of CTSMMIS in UART.UARTMIS */
#define UART_UARTMIS__CTSMMIS__Msk                              (0x00000001UL << UART_UARTMIS__CTSMMIS__Pos)                           /*!< Mask for CTSMMIS in UART.UARTMIS */
#define UART_UARTMIS__CTSMMIS__Shift(v)                         (((v) << UART_UARTMIS__CTSMMIS__Pos) & UART_UARTMIS__CTSMMIS__Msk)     /*!< Shift value 'v' into CTSMMIS and mask 'v' to fit it into CTSMMIS field */

/** UART_UARTMIS__CTSMMIS__GET() gets UARTMIS.CTSMMIS's current value.
 *
 * When reading from UARTMIS.CTSMMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.CTSMMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__CTSMMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__CTSMMIS__Msk);
    reg = (reg >> UART_UARTMIS__CTSMMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__CTSMMIS__EXTRACT() extracts UARTMIS.CTSMMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.CTSMMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__CTSMMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__CTSMMIS__Msk);
    reg = (reg >> UART_UARTMIS__CTSMMIS__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTMIS.RIMMIS -------------------------- */

/**
<pre>
  UART.UARTMIS.RIMMIS:

    nUARTRI modem masked interrupt status

</pre> */

#define UART_UARTMIS__RIMMIS__Pos                               0                                                                      /*!< Right-most bit position of RIMMIS in UART.UARTMIS */
#define UART_UARTMIS__RIMMIS__Msk                               (0x00000001UL << UART_UARTMIS__RIMMIS__Pos)                            /*!< Mask for RIMMIS in UART.UARTMIS */
#define UART_UARTMIS__RIMMIS__Shift(v)                          (((v) << UART_UARTMIS__RIMMIS__Pos) & UART_UARTMIS__RIMMIS__Msk)       /*!< Shift value 'v' into RIMMIS and mask 'v' to fit it into RIMMIS field */

/** UART_UARTMIS__RIMMIS__GET() gets UARTMIS.RIMMIS's current value.
 *
 * When reading from UARTMIS.RIMMIS, this is recommended to use.
 *
 * @return current value of UARTMIS.RIMMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__RIMMIS__GET(void)
{
    uint32_t reg = UART_UARTMIS__GET();
    reg = (reg & UART_UARTMIS__RIMMIS__Msk);
    reg = (reg >> UART_UARTMIS__RIMMIS__Pos);
    return (uint32_t)reg;
}

/** UART_UARTMIS__RIMMIS__EXTRACT() extracts UARTMIS.RIMMIS.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTMIS.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTMIS
 * @return current value of UARTMIS.RIMMIS
 */
__UART_INLINE uint32_t UART_UARTMIS__RIMMIS__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTMIS__RIMMIS__Msk);
    reg = (reg >> UART_UARTMIS__RIMMIS__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          UARTICR member of UART_t                          */
/* -------------------------------------------------------------------------- */

/** __UART_UARTICR__ADDRESS returns the address of member UARTICR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTICR
 */
__UART_INLINE uint32_t* __UART_UARTICR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTICR)));
}

/** UART_UARTICR__SET() sets UARTICR to given value.
 *
 * When writing to UARTICR, this is mandatory to use.
 *
 * @param value new value for UARTICR
 */
__UART_INLINE void UART_UARTICR__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTICR__ADDRESS(), value);
}

/** UART_UARTICR__GET() gets UARTICR's current value.
 *
 * When reading from UARTICR, this is mandatory to use.
 *
 * @return current value of UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__GET(void)
{
    return HAL_GET32(__UART_UARTICR__ADDRESS());
}

/* --------------------------- UART.UARTICR.OEIC --------------------------- */

/**
<pre>
  UART.UARTICR.OEIC:

    Overrun error interrupt clear

</pre> */

#define UART_UARTICR__OEIC__Pos                                 10                                                                     /*!< Right-most bit position of OEIC in UART.UARTICR */
#define UART_UARTICR__OEIC__Msk                                 (0x00000001UL << UART_UARTICR__OEIC__Pos)                              /*!< Mask for OEIC in UART.UARTICR */
#define UART_UARTICR__OEIC__Shift(v)                            (((v) << UART_UARTICR__OEIC__Pos) & UART_UARTICR__OEIC__Msk)           /*!< Shift value 'v' into OEIC and mask 'v' to fit it into OEIC field */

/** UART_UARTICR__OEIC__SET() sets UARTICR.OEIC to given value.
 *
 * When writing to UARTICR.OEIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.OEIC
 */
__UART_INLINE void UART_UARTICR__OEIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__OEIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__OEIC__MODIFY() modifies UARTICR.OEIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.OEIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__OEIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__OEIC__Msk);
    reg = (reg | (UART_UARTICR__OEIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__OEIC__EXTRACT() extracts UARTICR.OEIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.OEIC
 */
__UART_INLINE uint32_t UART_UARTICR__OEIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__OEIC__Msk);
    reg = (reg >> UART_UARTICR__OEIC__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTICR.BEIC --------------------------- */

/**
<pre>
  UART.UARTICR.BEIC:

    Break error interrupt clear

</pre> */

#define UART_UARTICR__BEIC__Pos                                 9                                                                      /*!< Right-most bit position of BEIC in UART.UARTICR */
#define UART_UARTICR__BEIC__Msk                                 (0x00000001UL << UART_UARTICR__BEIC__Pos)                              /*!< Mask for BEIC in UART.UARTICR */
#define UART_UARTICR__BEIC__Shift(v)                            (((v) << UART_UARTICR__BEIC__Pos) & UART_UARTICR__BEIC__Msk)           /*!< Shift value 'v' into BEIC and mask 'v' to fit it into BEIC field */

/** UART_UARTICR__BEIC__SET() sets UARTICR.BEIC to given value.
 *
 * When writing to UARTICR.BEIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.BEIC
 */
__UART_INLINE void UART_UARTICR__BEIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__BEIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__BEIC__MODIFY() modifies UARTICR.BEIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.BEIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__BEIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__BEIC__Msk);
    reg = (reg | (UART_UARTICR__BEIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__BEIC__EXTRACT() extracts UARTICR.BEIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.BEIC
 */
__UART_INLINE uint32_t UART_UARTICR__BEIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__BEIC__Msk);
    reg = (reg >> UART_UARTICR__BEIC__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTICR.PEIC --------------------------- */

/**
<pre>
  UART.UARTICR.PEIC:

    Parity error interrupt clear

</pre> */

#define UART_UARTICR__PEIC__Pos                                 8                                                                      /*!< Right-most bit position of PEIC in UART.UARTICR */
#define UART_UARTICR__PEIC__Msk                                 (0x00000001UL << UART_UARTICR__PEIC__Pos)                              /*!< Mask for PEIC in UART.UARTICR */
#define UART_UARTICR__PEIC__Shift(v)                            (((v) << UART_UARTICR__PEIC__Pos) & UART_UARTICR__PEIC__Msk)           /*!< Shift value 'v' into PEIC and mask 'v' to fit it into PEIC field */

/** UART_UARTICR__PEIC__SET() sets UARTICR.PEIC to given value.
 *
 * When writing to UARTICR.PEIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.PEIC
 */
__UART_INLINE void UART_UARTICR__PEIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__PEIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__PEIC__MODIFY() modifies UARTICR.PEIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.PEIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__PEIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__PEIC__Msk);
    reg = (reg | (UART_UARTICR__PEIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__PEIC__EXTRACT() extracts UARTICR.PEIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.PEIC
 */
__UART_INLINE uint32_t UART_UARTICR__PEIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__PEIC__Msk);
    reg = (reg >> UART_UARTICR__PEIC__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTICR.FEIC --------------------------- */

/**
<pre>
  UART.UARTICR.FEIC:

    Framing error interrupt clear

</pre> */

#define UART_UARTICR__FEIC__Pos                                 7                                                                      /*!< Right-most bit position of FEIC in UART.UARTICR */
#define UART_UARTICR__FEIC__Msk                                 (0x00000001UL << UART_UARTICR__FEIC__Pos)                              /*!< Mask for FEIC in UART.UARTICR */
#define UART_UARTICR__FEIC__Shift(v)                            (((v) << UART_UARTICR__FEIC__Pos) & UART_UARTICR__FEIC__Msk)           /*!< Shift value 'v' into FEIC and mask 'v' to fit it into FEIC field */

/** UART_UARTICR__FEIC__SET() sets UARTICR.FEIC to given value.
 *
 * When writing to UARTICR.FEIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.FEIC
 */
__UART_INLINE void UART_UARTICR__FEIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__FEIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__FEIC__MODIFY() modifies UARTICR.FEIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.FEIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__FEIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__FEIC__Msk);
    reg = (reg | (UART_UARTICR__FEIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__FEIC__EXTRACT() extracts UARTICR.FEIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.FEIC
 */
__UART_INLINE uint32_t UART_UARTICR__FEIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__FEIC__Msk);
    reg = (reg >> UART_UARTICR__FEIC__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTICR.RTIC --------------------------- */

/**
<pre>
  UART.UARTICR.RTIC:

    Receive timeout interrupt clear

</pre> */

#define UART_UARTICR__RTIC__Pos                                 6                                                                      /*!< Right-most bit position of RTIC in UART.UARTICR */
#define UART_UARTICR__RTIC__Msk                                 (0x00000001UL << UART_UARTICR__RTIC__Pos)                              /*!< Mask for RTIC in UART.UARTICR */
#define UART_UARTICR__RTIC__Shift(v)                            (((v) << UART_UARTICR__RTIC__Pos) & UART_UARTICR__RTIC__Msk)           /*!< Shift value 'v' into RTIC and mask 'v' to fit it into RTIC field */

/** UART_UARTICR__RTIC__SET() sets UARTICR.RTIC to given value.
 *
 * When writing to UARTICR.RTIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.RTIC
 */
__UART_INLINE void UART_UARTICR__RTIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__RTIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__RTIC__MODIFY() modifies UARTICR.RTIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.RTIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__RTIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__RTIC__Msk);
    reg = (reg | (UART_UARTICR__RTIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__RTIC__EXTRACT() extracts UARTICR.RTIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.RTIC
 */
__UART_INLINE uint32_t UART_UARTICR__RTIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__RTIC__Msk);
    reg = (reg >> UART_UARTICR__RTIC__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTICR.TXIC --------------------------- */

/**
<pre>
  UART.UARTICR.TXIC:

    Transmit interrupt clear

</pre> */

#define UART_UARTICR__TXIC__Pos                                 5                                                                      /*!< Right-most bit position of TXIC in UART.UARTICR */
#define UART_UARTICR__TXIC__Msk                                 (0x00000001UL << UART_UARTICR__TXIC__Pos)                              /*!< Mask for TXIC in UART.UARTICR */
#define UART_UARTICR__TXIC__Shift(v)                            (((v) << UART_UARTICR__TXIC__Pos) & UART_UARTICR__TXIC__Msk)           /*!< Shift value 'v' into TXIC and mask 'v' to fit it into TXIC field */

/** UART_UARTICR__TXIC__SET() sets UARTICR.TXIC to given value.
 *
 * When writing to UARTICR.TXIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.TXIC
 */
__UART_INLINE void UART_UARTICR__TXIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__TXIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__TXIC__MODIFY() modifies UARTICR.TXIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.TXIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__TXIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__TXIC__Msk);
    reg = (reg | (UART_UARTICR__TXIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__TXIC__EXTRACT() extracts UARTICR.TXIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.TXIC
 */
__UART_INLINE uint32_t UART_UARTICR__TXIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__TXIC__Msk);
    reg = (reg >> UART_UARTICR__TXIC__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTICR.RXIC --------------------------- */

/**
<pre>
  UART.UARTICR.RXIC:

    Receive interrupt clear

</pre> */

#define UART_UARTICR__RXIC__Pos                                 4                                                                      /*!< Right-most bit position of RXIC in UART.UARTICR */
#define UART_UARTICR__RXIC__Msk                                 (0x00000001UL << UART_UARTICR__RXIC__Pos)                              /*!< Mask for RXIC in UART.UARTICR */
#define UART_UARTICR__RXIC__Shift(v)                            (((v) << UART_UARTICR__RXIC__Pos) & UART_UARTICR__RXIC__Msk)           /*!< Shift value 'v' into RXIC and mask 'v' to fit it into RXIC field */

/** UART_UARTICR__RXIC__SET() sets UARTICR.RXIC to given value.
 *
 * When writing to UARTICR.RXIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.RXIC
 */
__UART_INLINE void UART_UARTICR__RXIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__RXIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__RXIC__MODIFY() modifies UARTICR.RXIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.RXIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__RXIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__RXIC__Msk);
    reg = (reg | (UART_UARTICR__RXIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__RXIC__EXTRACT() extracts UARTICR.RXIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.RXIC
 */
__UART_INLINE uint32_t UART_UARTICR__RXIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__RXIC__Msk);
    reg = (reg >> UART_UARTICR__RXIC__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTICR.DSRMIC -------------------------- */

/**
<pre>
  UART.UARTICR.DSRMIC:

    nUARTDSR modem interrupt clear

</pre> */

#define UART_UARTICR__DSRMIC__Pos                               3                                                                      /*!< Right-most bit position of DSRMIC in UART.UARTICR */
#define UART_UARTICR__DSRMIC__Msk                               (0x00000001UL << UART_UARTICR__DSRMIC__Pos)                            /*!< Mask for DSRMIC in UART.UARTICR */
#define UART_UARTICR__DSRMIC__Shift(v)                          (((v) << UART_UARTICR__DSRMIC__Pos) & UART_UARTICR__DSRMIC__Msk)       /*!< Shift value 'v' into DSRMIC and mask 'v' to fit it into DSRMIC field */

/** UART_UARTICR__DSRMIC__SET() sets UARTICR.DSRMIC to given value.
 *
 * When writing to UARTICR.DSRMIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.DSRMIC
 */
__UART_INLINE void UART_UARTICR__DSRMIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__DSRMIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__DSRMIC__MODIFY() modifies UARTICR.DSRMIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.DSRMIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__DSRMIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__DSRMIC__Msk);
    reg = (reg | (UART_UARTICR__DSRMIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__DSRMIC__EXTRACT() extracts UARTICR.DSRMIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.DSRMIC
 */
__UART_INLINE uint32_t UART_UARTICR__DSRMIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__DSRMIC__Msk);
    reg = (reg >> UART_UARTICR__DSRMIC__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTICR.DCDMIC -------------------------- */

/**
<pre>
  UART.UARTICR.DCDMIC:

    nUARTDCD modem interrupt clear

</pre> */

#define UART_UARTICR__DCDMIC__Pos                               2                                                                      /*!< Right-most bit position of DCDMIC in UART.UARTICR */
#define UART_UARTICR__DCDMIC__Msk                               (0x00000001UL << UART_UARTICR__DCDMIC__Pos)                            /*!< Mask for DCDMIC in UART.UARTICR */
#define UART_UARTICR__DCDMIC__Shift(v)                          (((v) << UART_UARTICR__DCDMIC__Pos) & UART_UARTICR__DCDMIC__Msk)       /*!< Shift value 'v' into DCDMIC and mask 'v' to fit it into DCDMIC field */

/** UART_UARTICR__DCDMIC__SET() sets UARTICR.DCDMIC to given value.
 *
 * When writing to UARTICR.DCDMIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.DCDMIC
 */
__UART_INLINE void UART_UARTICR__DCDMIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__DCDMIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__DCDMIC__MODIFY() modifies UARTICR.DCDMIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.DCDMIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__DCDMIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__DCDMIC__Msk);
    reg = (reg | (UART_UARTICR__DCDMIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__DCDMIC__EXTRACT() extracts UARTICR.DCDMIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.DCDMIC
 */
__UART_INLINE uint32_t UART_UARTICR__DCDMIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__DCDMIC__Msk);
    reg = (reg >> UART_UARTICR__DCDMIC__Pos);
    return (uint32_t)reg;
}

/* -------------------------- UART.UARTICR.CTSMIC -------------------------- */

/**
<pre>
  UART.UARTICR.CTSMIC:

    nUARTCTS modem interrupt clear

</pre> */

#define UART_UARTICR__CTSMIC__Pos                               1                                                                      /*!< Right-most bit position of CTSMIC in UART.UARTICR */
#define UART_UARTICR__CTSMIC__Msk                               (0x00000001UL << UART_UARTICR__CTSMIC__Pos)                            /*!< Mask for CTSMIC in UART.UARTICR */
#define UART_UARTICR__CTSMIC__Shift(v)                          (((v) << UART_UARTICR__CTSMIC__Pos) & UART_UARTICR__CTSMIC__Msk)       /*!< Shift value 'v' into CTSMIC and mask 'v' to fit it into CTSMIC field */

/** UART_UARTICR__CTSMIC__SET() sets UARTICR.CTSMIC to given value.
 *
 * When writing to UARTICR.CTSMIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.CTSMIC
 */
__UART_INLINE void UART_UARTICR__CTSMIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__CTSMIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__CTSMIC__MODIFY() modifies UARTICR.CTSMIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.CTSMIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__CTSMIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__CTSMIC__Msk);
    reg = (reg | (UART_UARTICR__CTSMIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__CTSMIC__EXTRACT() extracts UARTICR.CTSMIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.CTSMIC
 */
__UART_INLINE uint32_t UART_UARTICR__CTSMIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__CTSMIC__Msk);
    reg = (reg >> UART_UARTICR__CTSMIC__Pos);
    return (uint32_t)reg;
}

/* --------------------------- UART.UARTICR.RIMIC --------------------------- */

/**
<pre>
  UART.UARTICR.RIMIC:

    nUARTRI modem interrupt clear

</pre> */

#define UART_UARTICR__RIMIC__Pos                                0                                                                      /*!< Right-most bit position of RIMIC in UART.UARTICR */
#define UART_UARTICR__RIMIC__Msk                                (0x00000001UL << UART_UARTICR__RIMIC__Pos)                             /*!< Mask for RIMIC in UART.UARTICR */
#define UART_UARTICR__RIMIC__Shift(v)                           (((v) << UART_UARTICR__RIMIC__Pos) & UART_UARTICR__RIMIC__Msk)         /*!< Shift value 'v' into RIMIC and mask 'v' to fit it into RIMIC field */

/** UART_UARTICR__RIMIC__SET() sets UARTICR.RIMIC to given value.
 *
 * When writing to UARTICR.RIMIC, this is recommended to use.
 *
 * @param bf_value new value for UARTICR.RIMIC
 */
__UART_INLINE void UART_UARTICR__RIMIC__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTICR__RIMIC__Shift((uint32_t)bf_value);
    UART_UARTICR__SET(reg);
}


/** UART_UARTICR__RIMIC__MODIFY() modifies UARTICR.RIMIC.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTICR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTICR
 * @param bf_value new value for UARTICR.RIMIC
 * @return new value of UART.UARTICR
 */
__UART_INLINE uint32_t UART_UARTICR__RIMIC__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTICR__RIMIC__Msk);
    reg = (reg | (UART_UARTICR__RIMIC__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTICR__RIMIC__EXTRACT() extracts UARTICR.RIMIC.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTICR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTICR
 * @return current value of UARTICR.RIMIC
 */
__UART_INLINE uint32_t UART_UARTICR__RIMIC__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTICR__RIMIC__Msk);
    reg = (reg >> UART_UARTICR__RIMIC__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                         UARTDMACR member of UART_t                         */
/* -------------------------------------------------------------------------- */

/** __UART_UARTDMACR__ADDRESS returns the address of member UARTDMACR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTDMACR
 */
__UART_INLINE uint32_t* __UART_UARTDMACR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTDMACR)));
}

/** UART_UARTDMACR__SET() sets UARTDMACR to given value.
 *
 * When writing to UARTDMACR, this is mandatory to use.
 *
 * @param value new value for UARTDMACR
 */
__UART_INLINE void UART_UARTDMACR__SET(uint32_t value)
{
    HAL_SET32(__UART_UARTDMACR__ADDRESS(), value);
}

/** UART_UARTDMACR__GET() gets UARTDMACR's current value.
 *
 * When reading from UARTDMACR, this is mandatory to use.
 *
 * @return current value of UARTDMACR
 */
__UART_INLINE uint32_t UART_UARTDMACR__GET(void)
{
    return HAL_GET32(__UART_UARTDMACR__ADDRESS());
}

/* ------------------------ UART.UARTDMACR.DMAONERR ------------------------ */

/**
<pre>
  UART.UARTDMACR.DMAONERR:

    DMA on error

</pre> */

#define UART_UARTDMACR__DMAONERR__Pos                           2                                                                      /*!< Right-most bit position of DMAONERR in UART.UARTDMACR */
#define UART_UARTDMACR__DMAONERR__Msk                           (0x00000001UL << UART_UARTDMACR__DMAONERR__Pos)                        /*!< Mask for DMAONERR in UART.UARTDMACR */
#define UART_UARTDMACR__DMAONERR__Shift(v)                      (((v) << UART_UARTDMACR__DMAONERR__Pos) & UART_UARTDMACR__DMAONERR__Msk) /*!< Shift value 'v' into DMAONERR and mask 'v' to fit it into DMAONERR field */

/** UART_UARTDMACR__DMAONERR__SET() sets UARTDMACR.DMAONERR to given value.
 *
 * When writing to UARTDMACR.DMAONERR, this is recommended to use.
 *
 * @param bf_value new value for UARTDMACR.DMAONERR
 */
__UART_INLINE void UART_UARTDMACR__DMAONERR__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTDMACR__GET();
    reg = (reg & ~UART_UARTDMACR__DMAONERR__Msk);
    reg = (reg | (UART_UARTDMACR__DMAONERR__Shift((uint32_t)bf_value)));
    UART_UARTDMACR__SET(reg);
}

/** UART_UARTDMACR__DMAONERR__GET() gets UARTDMACR.DMAONERR's current value.
 *
 * When reading from UARTDMACR.DMAONERR, this is recommended to use.
 *
 * @return current value of UARTDMACR.DMAONERR
 */
__UART_INLINE uint32_t UART_UARTDMACR__DMAONERR__GET(void)
{
    uint32_t reg = UART_UARTDMACR__GET();
    reg = (reg & UART_UARTDMACR__DMAONERR__Msk);
    reg = (reg >> UART_UARTDMACR__DMAONERR__Pos);
    return (uint32_t)reg;
}

/** UART_UARTDMACR__DMAONERR__MODIFY() modifies UARTDMACR.DMAONERR.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTDMACR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTDMACR
 * @param bf_value new value for UARTDMACR.DMAONERR
 * @return new value of UART.UARTDMACR
 */
__UART_INLINE uint32_t UART_UARTDMACR__DMAONERR__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTDMACR__DMAONERR__Msk);
    reg = (reg | (UART_UARTDMACR__DMAONERR__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTDMACR__DMAONERR__EXTRACT() extracts UARTDMACR.DMAONERR.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTDMACR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTDMACR
 * @return current value of UARTDMACR.DMAONERR
 */
__UART_INLINE uint32_t UART_UARTDMACR__DMAONERR__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTDMACR__DMAONERR__Msk);
    reg = (reg >> UART_UARTDMACR__DMAONERR__Pos);
    return (uint32_t)reg;
}

/* ------------------------- UART.UARTDMACR.TXDMAE ------------------------- */

/**
<pre>
  UART.UARTDMACR.TXDMAE:

    Transmit DMA enable

</pre> */

#define UART_UARTDMACR__TXDMAE__Pos                             1                                                                      /*!< Right-most bit position of TXDMAE in UART.UARTDMACR */
#define UART_UARTDMACR__TXDMAE__Msk                             (0x00000001UL << UART_UARTDMACR__TXDMAE__Pos)                          /*!< Mask for TXDMAE in UART.UARTDMACR */
#define UART_UARTDMACR__TXDMAE__Shift(v)                        (((v) << UART_UARTDMACR__TXDMAE__Pos) & UART_UARTDMACR__TXDMAE__Msk)   /*!< Shift value 'v' into TXDMAE and mask 'v' to fit it into TXDMAE field */

/** UART_UARTDMACR__TXDMAE__SET() sets UARTDMACR.TXDMAE to given value.
 *
 * When writing to UARTDMACR.TXDMAE, this is recommended to use.
 *
 * @param bf_value new value for UARTDMACR.TXDMAE
 */
__UART_INLINE void UART_UARTDMACR__TXDMAE__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTDMACR__GET();
    reg = (reg & ~UART_UARTDMACR__TXDMAE__Msk);
    reg = (reg | (UART_UARTDMACR__TXDMAE__Shift((uint32_t)bf_value)));
    UART_UARTDMACR__SET(reg);
}

/** UART_UARTDMACR__TXDMAE__GET() gets UARTDMACR.TXDMAE's current value.
 *
 * When reading from UARTDMACR.TXDMAE, this is recommended to use.
 *
 * @return current value of UARTDMACR.TXDMAE
 */
__UART_INLINE uint32_t UART_UARTDMACR__TXDMAE__GET(void)
{
    uint32_t reg = UART_UARTDMACR__GET();
    reg = (reg & UART_UARTDMACR__TXDMAE__Msk);
    reg = (reg >> UART_UARTDMACR__TXDMAE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTDMACR__TXDMAE__MODIFY() modifies UARTDMACR.TXDMAE.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTDMACR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTDMACR
 * @param bf_value new value for UARTDMACR.TXDMAE
 * @return new value of UART.UARTDMACR
 */
__UART_INLINE uint32_t UART_UARTDMACR__TXDMAE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTDMACR__TXDMAE__Msk);
    reg = (reg | (UART_UARTDMACR__TXDMAE__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTDMACR__TXDMAE__EXTRACT() extracts UARTDMACR.TXDMAE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTDMACR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTDMACR
 * @return current value of UARTDMACR.TXDMAE
 */
__UART_INLINE uint32_t UART_UARTDMACR__TXDMAE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTDMACR__TXDMAE__Msk);
    reg = (reg >> UART_UARTDMACR__TXDMAE__Pos);
    return (uint32_t)reg;
}

/* ------------------------- UART.UARTDMACR.RXDMAE ------------------------- */

/**
<pre>
  UART.UARTDMACR.RXDMAE:

    Receive DMA enable

</pre> */

#define UART_UARTDMACR__RXDMAE__Pos                             0                                                                      /*!< Right-most bit position of RXDMAE in UART.UARTDMACR */
#define UART_UARTDMACR__RXDMAE__Msk                             (0x00000001UL << UART_UARTDMACR__RXDMAE__Pos)                          /*!< Mask for RXDMAE in UART.UARTDMACR */
#define UART_UARTDMACR__RXDMAE__Shift(v)                        (((v) << UART_UARTDMACR__RXDMAE__Pos) & UART_UARTDMACR__RXDMAE__Msk)   /*!< Shift value 'v' into RXDMAE and mask 'v' to fit it into RXDMAE field */

/** UART_UARTDMACR__RXDMAE__SET() sets UARTDMACR.RXDMAE to given value.
 *
 * When writing to UARTDMACR.RXDMAE, this is recommended to use.
 *
 * @param bf_value new value for UARTDMACR.RXDMAE
 */
__UART_INLINE void UART_UARTDMACR__RXDMAE__SET(uint32_t bf_value)
{
    uint32_t reg = UART_UARTDMACR__GET();
    reg = (reg & ~UART_UARTDMACR__RXDMAE__Msk);
    reg = (reg | (UART_UARTDMACR__RXDMAE__Shift((uint32_t)bf_value)));
    UART_UARTDMACR__SET(reg);
}

/** UART_UARTDMACR__RXDMAE__GET() gets UARTDMACR.RXDMAE's current value.
 *
 * When reading from UARTDMACR.RXDMAE, this is recommended to use.
 *
 * @return current value of UARTDMACR.RXDMAE
 */
__UART_INLINE uint32_t UART_UARTDMACR__RXDMAE__GET(void)
{
    uint32_t reg = UART_UARTDMACR__GET();
    reg = (reg & UART_UARTDMACR__RXDMAE__Msk);
    reg = (reg >> UART_UARTDMACR__RXDMAE__Pos);
    return (uint32_t)reg;
}

/** UART_UARTDMACR__RXDMAE__MODIFY() modifies UARTDMACR.RXDMAE.
 *
 * This is recommended to use when setting more than one bitfield of UART.UARTDMACR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of UART.UARTDMACR
 * @param bf_value new value for UARTDMACR.RXDMAE
 * @return new value of UART.UARTDMACR
 */
__UART_INLINE uint32_t UART_UARTDMACR__RXDMAE__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~UART_UARTDMACR__RXDMAE__Msk);
    reg = (reg | (UART_UARTDMACR__RXDMAE__Shift((uint32_t)bf_value)));
    return reg;
}

/** UART_UARTDMACR__RXDMAE__EXTRACT() extracts UARTDMACR.RXDMAE.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTDMACR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTDMACR
 * @return current value of UARTDMACR.RXDMAE
 */
__UART_INLINE uint32_t UART_UARTDMACR__RXDMAE__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTDMACR__RXDMAE__Msk);
    reg = (reg >> UART_UARTDMACR__RXDMAE__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       UARTPERIPHID0 member of UART_t                       */
/* -------------------------------------------------------------------------- */

/** __UART_UARTPERIPHID0__ADDRESS returns the address of member UARTPERIPHID0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTPERIPHID0
 */
__UART_INLINE uint32_t* __UART_UARTPERIPHID0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTPERIPHID0)));
}

/** UART_UARTPERIPHID0__GET() gets UARTPERIPHID0's current value.
 *
 * When reading from UARTPERIPHID0, this is mandatory to use.
 *
 * @return current value of UARTPERIPHID0
 */
__UART_INLINE uint32_t UART_UARTPERIPHID0__GET(void)
{
    return HAL_GET32(__UART_UARTPERIPHID0__ADDRESS());
}

/* --------------------- UART.UARTPERIPHID0.PARTNUMBER0 --------------------- */

/**
<pre>
  UART.UARTPERIPHID0.PARTNUMBER0:

    PartNumber

</pre> */

#define UART_UARTPERIPHID0__PARTNUMBER0__Pos                    0                                                                      /*!< Right-most bit position of PARTNUMBER0 in UART.UARTPERIPHID0 */
#define UART_UARTPERIPHID0__PARTNUMBER0__Msk                    (0x000000FFUL << UART_UARTPERIPHID0__PARTNUMBER0__Pos)                 /*!< Mask for PARTNUMBER0 in UART.UARTPERIPHID0 */
#define UART_UARTPERIPHID0__PARTNUMBER0__Shift(v)               (((v) << UART_UARTPERIPHID0__PARTNUMBER0__Pos) & UART_UARTPERIPHID0__PARTNUMBER0__Msk) /*!< Shift value 'v' into PARTNUMBER0 and mask 'v' to fit it into PARTNUMBER0 field */

/** UART_UARTPERIPHID0__PARTNUMBER0__GET() gets UARTPERIPHID0.PARTNUMBER0's current value.
 *
 * When reading from UARTPERIPHID0.PARTNUMBER0, this is recommended to use.
 *
 * @return current value of UARTPERIPHID0.PARTNUMBER0
 */
__UART_INLINE uint32_t UART_UARTPERIPHID0__PARTNUMBER0__GET(void)
{
    uint32_t reg = UART_UARTPERIPHID0__GET();
    reg = (reg & UART_UARTPERIPHID0__PARTNUMBER0__Msk);
    reg = (reg >> UART_UARTPERIPHID0__PARTNUMBER0__Pos);
    return (uint32_t)reg;
}

/** UART_UARTPERIPHID0__PARTNUMBER0__EXTRACT() extracts UARTPERIPHID0.PARTNUMBER0.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTPERIPHID0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTPERIPHID0
 * @return current value of UARTPERIPHID0.PARTNUMBER0
 */
__UART_INLINE uint32_t UART_UARTPERIPHID0__PARTNUMBER0__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTPERIPHID0__PARTNUMBER0__Msk);
    reg = (reg >> UART_UARTPERIPHID0__PARTNUMBER0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       UARTPERIPHID1 member of UART_t                       */
/* -------------------------------------------------------------------------- */

/** __UART_UARTPERIPHID1__ADDRESS returns the address of member UARTPERIPHID1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTPERIPHID1
 */
__UART_INLINE uint32_t* __UART_UARTPERIPHID1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTPERIPHID1)));
}

/** UART_UARTPERIPHID1__GET() gets UARTPERIPHID1's current value.
 *
 * When reading from UARTPERIPHID1, this is mandatory to use.
 *
 * @return current value of UARTPERIPHID1
 */
__UART_INLINE uint32_t UART_UARTPERIPHID1__GET(void)
{
    return HAL_GET32(__UART_UARTPERIPHID1__ADDRESS());
}

/* ---------------------- UART.UARTPERIPHID1.DESIGNER0 ---------------------- */

/**
<pre>
  UART.UARTPERIPHID1.DESIGNER0:

    Designer ID

</pre> */

#define UART_UARTPERIPHID1__DESIGNER0__Pos                      4                                                                      /*!< Right-most bit position of DESIGNER0 in UART.UARTPERIPHID1 */
#define UART_UARTPERIPHID1__DESIGNER0__Msk                      (0x0000000FUL << UART_UARTPERIPHID1__DESIGNER0__Pos)                   /*!< Mask for DESIGNER0 in UART.UARTPERIPHID1 */
#define UART_UARTPERIPHID1__DESIGNER0__Shift(v)                 (((v) << UART_UARTPERIPHID1__DESIGNER0__Pos) & UART_UARTPERIPHID1__DESIGNER0__Msk) /*!< Shift value 'v' into DESIGNER0 and mask 'v' to fit it into DESIGNER0 field */

/** UART_UARTPERIPHID1__DESIGNER0__GET() gets UARTPERIPHID1.DESIGNER0's current value.
 *
 * When reading from UARTPERIPHID1.DESIGNER0, this is recommended to use.
 *
 * @return current value of UARTPERIPHID1.DESIGNER0
 */
__UART_INLINE uint32_t UART_UARTPERIPHID1__DESIGNER0__GET(void)
{
    uint32_t reg = UART_UARTPERIPHID1__GET();
    reg = (reg & UART_UARTPERIPHID1__DESIGNER0__Msk);
    reg = (reg >> UART_UARTPERIPHID1__DESIGNER0__Pos);
    return (uint32_t)reg;
}

/** UART_UARTPERIPHID1__DESIGNER0__EXTRACT() extracts UARTPERIPHID1.DESIGNER0.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTPERIPHID1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTPERIPHID1
 * @return current value of UARTPERIPHID1.DESIGNER0
 */
__UART_INLINE uint32_t UART_UARTPERIPHID1__DESIGNER0__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTPERIPHID1__DESIGNER0__Msk);
    reg = (reg >> UART_UARTPERIPHID1__DESIGNER0__Pos);
    return (uint32_t)reg;
}

/* --------------------- UART.UARTPERIPHID1.PARTNUMBER1 --------------------- */

/**
<pre>
  UART.UARTPERIPHID1.PARTNUMBER1:

    PartNumber

</pre> */

#define UART_UARTPERIPHID1__PARTNUMBER1__Pos                    0                                                                      /*!< Right-most bit position of PARTNUMBER1 in UART.UARTPERIPHID1 */
#define UART_UARTPERIPHID1__PARTNUMBER1__Msk                    (0x0000000FUL << UART_UARTPERIPHID1__PARTNUMBER1__Pos)                 /*!< Mask for PARTNUMBER1 in UART.UARTPERIPHID1 */
#define UART_UARTPERIPHID1__PARTNUMBER1__Shift(v)               (((v) << UART_UARTPERIPHID1__PARTNUMBER1__Pos) & UART_UARTPERIPHID1__PARTNUMBER1__Msk) /*!< Shift value 'v' into PARTNUMBER1 and mask 'v' to fit it into PARTNUMBER1 field */

/** UART_UARTPERIPHID1__PARTNUMBER1__GET() gets UARTPERIPHID1.PARTNUMBER1's current value.
 *
 * When reading from UARTPERIPHID1.PARTNUMBER1, this is recommended to use.
 *
 * @return current value of UARTPERIPHID1.PARTNUMBER1
 */
__UART_INLINE uint32_t UART_UARTPERIPHID1__PARTNUMBER1__GET(void)
{
    uint32_t reg = UART_UARTPERIPHID1__GET();
    reg = (reg & UART_UARTPERIPHID1__PARTNUMBER1__Msk);
    reg = (reg >> UART_UARTPERIPHID1__PARTNUMBER1__Pos);
    return (uint32_t)reg;
}

/** UART_UARTPERIPHID1__PARTNUMBER1__EXTRACT() extracts UARTPERIPHID1.PARTNUMBER1.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTPERIPHID1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTPERIPHID1
 * @return current value of UARTPERIPHID1.PARTNUMBER1
 */
__UART_INLINE uint32_t UART_UARTPERIPHID1__PARTNUMBER1__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTPERIPHID1__PARTNUMBER1__Msk);
    reg = (reg >> UART_UARTPERIPHID1__PARTNUMBER1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       UARTPERIPHID2 member of UART_t                       */
/* -------------------------------------------------------------------------- */

/** __UART_UARTPERIPHID2__ADDRESS returns the address of member UARTPERIPHID2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTPERIPHID2
 */
__UART_INLINE uint32_t* __UART_UARTPERIPHID2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTPERIPHID2)));
}

/** UART_UARTPERIPHID2__GET() gets UARTPERIPHID2's current value.
 *
 * When reading from UARTPERIPHID2, this is mandatory to use.
 *
 * @return current value of UARTPERIPHID2
 */
__UART_INLINE uint32_t UART_UARTPERIPHID2__GET(void)
{
    return HAL_GET32(__UART_UARTPERIPHID2__ADDRESS());
}

/* ---------------------- UART.UARTPERIPHID2.REVISION ---------------------- */

/**
<pre>
  UART.UARTPERIPHID2.REVISION:

    Revision

</pre> */

#define UART_UARTPERIPHID2__REVISION__Pos                       4                                                                      /*!< Right-most bit position of REVISION in UART.UARTPERIPHID2 */
#define UART_UARTPERIPHID2__REVISION__Msk                       (0x0000000FUL << UART_UARTPERIPHID2__REVISION__Pos)                    /*!< Mask for REVISION in UART.UARTPERIPHID2 */
#define UART_UARTPERIPHID2__REVISION__Shift(v)                  (((v) << UART_UARTPERIPHID2__REVISION__Pos) & UART_UARTPERIPHID2__REVISION__Msk) /*!< Shift value 'v' into REVISION and mask 'v' to fit it into REVISION field */

/** UART_UARTPERIPHID2__REVISION__GET() gets UARTPERIPHID2.REVISION's current value.
 *
 * When reading from UARTPERIPHID2.REVISION, this is recommended to use.
 *
 * @return current value of UARTPERIPHID2.REVISION
 */
__UART_INLINE uint32_t UART_UARTPERIPHID2__REVISION__GET(void)
{
    uint32_t reg = UART_UARTPERIPHID2__GET();
    reg = (reg & UART_UARTPERIPHID2__REVISION__Msk);
    reg = (reg >> UART_UARTPERIPHID2__REVISION__Pos);
    return (uint32_t)reg;
}

/** UART_UARTPERIPHID2__REVISION__EXTRACT() extracts UARTPERIPHID2.REVISION.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTPERIPHID2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTPERIPHID2
 * @return current value of UARTPERIPHID2.REVISION
 */
__UART_INLINE uint32_t UART_UARTPERIPHID2__REVISION__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTPERIPHID2__REVISION__Msk);
    reg = (reg >> UART_UARTPERIPHID2__REVISION__Pos);
    return (uint32_t)reg;
}

/* ---------------------- UART.UARTPERIPHID2.DESIGNER1 ---------------------- */

/**
<pre>
  UART.UARTPERIPHID2.DESIGNER1:

    Designer ID

</pre> */

#define UART_UARTPERIPHID2__DESIGNER1__Pos                      0                                                                      /*!< Right-most bit position of DESIGNER1 in UART.UARTPERIPHID2 */
#define UART_UARTPERIPHID2__DESIGNER1__Msk                      (0x0000000FUL << UART_UARTPERIPHID2__DESIGNER1__Pos)                   /*!< Mask for DESIGNER1 in UART.UARTPERIPHID2 */
#define UART_UARTPERIPHID2__DESIGNER1__Shift(v)                 (((v) << UART_UARTPERIPHID2__DESIGNER1__Pos) & UART_UARTPERIPHID2__DESIGNER1__Msk) /*!< Shift value 'v' into DESIGNER1 and mask 'v' to fit it into DESIGNER1 field */

/** UART_UARTPERIPHID2__DESIGNER1__GET() gets UARTPERIPHID2.DESIGNER1's current value.
 *
 * When reading from UARTPERIPHID2.DESIGNER1, this is recommended to use.
 *
 * @return current value of UARTPERIPHID2.DESIGNER1
 */
__UART_INLINE uint32_t UART_UARTPERIPHID2__DESIGNER1__GET(void)
{
    uint32_t reg = UART_UARTPERIPHID2__GET();
    reg = (reg & UART_UARTPERIPHID2__DESIGNER1__Msk);
    reg = (reg >> UART_UARTPERIPHID2__DESIGNER1__Pos);
    return (uint32_t)reg;
}

/** UART_UARTPERIPHID2__DESIGNER1__EXTRACT() extracts UARTPERIPHID2.DESIGNER1.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTPERIPHID2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTPERIPHID2
 * @return current value of UARTPERIPHID2.DESIGNER1
 */
__UART_INLINE uint32_t UART_UARTPERIPHID2__DESIGNER1__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTPERIPHID2__DESIGNER1__Msk);
    reg = (reg >> UART_UARTPERIPHID2__DESIGNER1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       UARTPERIPHID3 member of UART_t                       */
/* -------------------------------------------------------------------------- */

/** __UART_UARTPERIPHID3__ADDRESS returns the address of member UARTPERIPHID3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTPERIPHID3
 */
__UART_INLINE uint32_t* __UART_UARTPERIPHID3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTPERIPHID3)));
}

/** UART_UARTPERIPHID3__GET() gets UARTPERIPHID3's current value.
 *
 * When reading from UARTPERIPHID3, this is mandatory to use.
 *
 * @return current value of UARTPERIPHID3
 */
__UART_INLINE uint32_t UART_UARTPERIPHID3__GET(void)
{
    return HAL_GET32(__UART_UARTPERIPHID3__ADDRESS());
}

/* -------------------- UART.UARTPERIPHID3.CONFIGURATION -------------------- */

/**
<pre>
  UART.UARTPERIPHID3.CONFIGURATION:

    Configuration

</pre> */

#define UART_UARTPERIPHID3__CONFIGURATION__Pos                  0                                                                      /*!< Right-most bit position of CONFIGURATION in UART.UARTPERIPHID3 */
#define UART_UARTPERIPHID3__CONFIGURATION__Msk                  (0x000000FFUL << UART_UARTPERIPHID3__CONFIGURATION__Pos)               /*!< Mask for CONFIGURATION in UART.UARTPERIPHID3 */
#define UART_UARTPERIPHID3__CONFIGURATION__Shift(v)             (((v) << UART_UARTPERIPHID3__CONFIGURATION__Pos) & UART_UARTPERIPHID3__CONFIGURATION__Msk) /*!< Shift value 'v' into CONFIGURATION and mask 'v' to fit it into CONFIGURATION field */

/** UART_UARTPERIPHID3__CONFIGURATION__GET() gets UARTPERIPHID3.CONFIGURATION's current value.
 *
 * When reading from UARTPERIPHID3.CONFIGURATION, this is recommended to use.
 *
 * @return current value of UARTPERIPHID3.CONFIGURATION
 */
__UART_INLINE uint32_t UART_UARTPERIPHID3__CONFIGURATION__GET(void)
{
    uint32_t reg = UART_UARTPERIPHID3__GET();
    reg = (reg & UART_UARTPERIPHID3__CONFIGURATION__Msk);
    reg = (reg >> UART_UARTPERIPHID3__CONFIGURATION__Pos);
    return (uint32_t)reg;
}

/** UART_UARTPERIPHID3__CONFIGURATION__EXTRACT() extracts UARTPERIPHID3.CONFIGURATION.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTPERIPHID3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTPERIPHID3
 * @return current value of UARTPERIPHID3.CONFIGURATION
 */
__UART_INLINE uint32_t UART_UARTPERIPHID3__CONFIGURATION__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTPERIPHID3__CONFIGURATION__Msk);
    reg = (reg >> UART_UARTPERIPHID3__CONFIGURATION__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       UARTPCELLID0 member of UART_t                       */
/* -------------------------------------------------------------------------- */

/** __UART_UARTPCELLID0__ADDRESS returns the address of member UARTPCELLID0.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTPCELLID0
 */
__UART_INLINE uint32_t* __UART_UARTPCELLID0__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTPCELLID0)));
}

/** UART_UARTPCELLID0__GET() gets UARTPCELLID0's current value.
 *
 * When reading from UARTPCELLID0, this is mandatory to use.
 *
 * @return current value of UARTPCELLID0
 */
__UART_INLINE uint32_t UART_UARTPCELLID0__GET(void)
{
    return HAL_GET32(__UART_UARTPCELLID0__ADDRESS());
}

/* --------------------- UART.UARTPCELLID0.UARTPCELLID0 --------------------- */

/**
<pre>
  UART.UARTPCELLID0.UARTPCELLID0:

    UARTPCellID0

</pre> */

#define UART_UARTPCELLID0__UARTPCELLID0__Pos                    0                                                                      /*!< Right-most bit position of UARTPCellID0 in UART.UARTPCELLID0 */
#define UART_UARTPCELLID0__UARTPCELLID0__Msk                    (0x000000FFUL << UART_UARTPCELLID0__UARTPCELLID0__Pos)                 /*!< Mask for UARTPCellID0 in UART.UARTPCELLID0 */
#define UART_UARTPCELLID0__UARTPCELLID0__Shift(v)               (((v) << UART_UARTPCELLID0__UARTPCELLID0__Pos) & UART_UARTPCELLID0__UARTPCELLID0__Msk) /*!< Shift value 'v' into UARTPCellID0 and mask 'v' to fit it into UARTPCellID0 field */

/** UART_UARTPCELLID0__UARTPCELLID0__GET() gets UARTPCELLID0.UARTPCELLID0's current value.
 *
 * When reading from UARTPCELLID0.UARTPCELLID0, this is recommended to use.
 *
 * @return current value of UARTPCELLID0.UARTPCELLID0
 */
__UART_INLINE uint32_t UART_UARTPCELLID0__UARTPCELLID0__GET(void)
{
    uint32_t reg = UART_UARTPCELLID0__GET();
    reg = (reg & UART_UARTPCELLID0__UARTPCELLID0__Msk);
    reg = (reg >> UART_UARTPCELLID0__UARTPCELLID0__Pos);
    return (uint32_t)reg;
}

/** UART_UARTPCELLID0__UARTPCELLID0__EXTRACT() extracts UARTPCELLID0.UARTPCELLID0.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTPCELLID0.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTPCELLID0
 * @return current value of UARTPCELLID0.UARTPCELLID0
 */
__UART_INLINE uint32_t UART_UARTPCELLID0__UARTPCELLID0__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTPCELLID0__UARTPCELLID0__Msk);
    reg = (reg >> UART_UARTPCELLID0__UARTPCELLID0__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       UARTPCELLID1 member of UART_t                       */
/* -------------------------------------------------------------------------- */

/** __UART_UARTPCELLID1__ADDRESS returns the address of member UARTPCELLID1.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTPCELLID1
 */
__UART_INLINE uint32_t* __UART_UARTPCELLID1__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTPCELLID1)));
}

/** UART_UARTPCELLID1__GET() gets UARTPCELLID1's current value.
 *
 * When reading from UARTPCELLID1, this is mandatory to use.
 *
 * @return current value of UARTPCELLID1
 */
__UART_INLINE uint32_t UART_UARTPCELLID1__GET(void)
{
    return HAL_GET32(__UART_UARTPCELLID1__ADDRESS());
}

/* --------------------- UART.UARTPCELLID1.UARTPCELLID1 --------------------- */

/**
<pre>
  UART.UARTPCELLID1.UARTPCELLID1:

    UARTPCellID1

</pre> */

#define UART_UARTPCELLID1__UARTPCELLID1__Pos                    0                                                                      /*!< Right-most bit position of UARTPCellID1 in UART.UARTPCELLID1 */
#define UART_UARTPCELLID1__UARTPCELLID1__Msk                    (0x000000FFUL << UART_UARTPCELLID1__UARTPCELLID1__Pos)                 /*!< Mask for UARTPCellID1 in UART.UARTPCELLID1 */
#define UART_UARTPCELLID1__UARTPCELLID1__Shift(v)               (((v) << UART_UARTPCELLID1__UARTPCELLID1__Pos) & UART_UARTPCELLID1__UARTPCELLID1__Msk) /*!< Shift value 'v' into UARTPCellID1 and mask 'v' to fit it into UARTPCellID1 field */

/** UART_UARTPCELLID1__UARTPCELLID1__GET() gets UARTPCELLID1.UARTPCELLID1's current value.
 *
 * When reading from UARTPCELLID1.UARTPCELLID1, this is recommended to use.
 *
 * @return current value of UARTPCELLID1.UARTPCELLID1
 */
__UART_INLINE uint32_t UART_UARTPCELLID1__UARTPCELLID1__GET(void)
{
    uint32_t reg = UART_UARTPCELLID1__GET();
    reg = (reg & UART_UARTPCELLID1__UARTPCELLID1__Msk);
    reg = (reg >> UART_UARTPCELLID1__UARTPCELLID1__Pos);
    return (uint32_t)reg;
}

/** UART_UARTPCELLID1__UARTPCELLID1__EXTRACT() extracts UARTPCELLID1.UARTPCELLID1.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTPCELLID1.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTPCELLID1
 * @return current value of UARTPCELLID1.UARTPCELLID1
 */
__UART_INLINE uint32_t UART_UARTPCELLID1__UARTPCELLID1__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTPCELLID1__UARTPCELLID1__Msk);
    reg = (reg >> UART_UARTPCELLID1__UARTPCELLID1__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       UARTPCELLID2 member of UART_t                       */
/* -------------------------------------------------------------------------- */

/** __UART_UARTPCELLID2__ADDRESS returns the address of member UARTPCELLID2.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTPCELLID2
 */
__UART_INLINE uint32_t* __UART_UARTPCELLID2__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTPCELLID2)));
}

/** UART_UARTPCELLID2__GET() gets UARTPCELLID2's current value.
 *
 * When reading from UARTPCELLID2, this is mandatory to use.
 *
 * @return current value of UARTPCELLID2
 */
__UART_INLINE uint32_t UART_UARTPCELLID2__GET(void)
{
    return HAL_GET32(__UART_UARTPCELLID2__ADDRESS());
}

/* --------------------- UART.UARTPCELLID2.UARTPCELLID2 --------------------- */

/**
<pre>
  UART.UARTPCELLID2.UARTPCELLID2:

    UARTPCellID2

</pre> */

#define UART_UARTPCELLID2__UARTPCELLID2__Pos                    0                                                                      /*!< Right-most bit position of UARTPCellID2 in UART.UARTPCELLID2 */
#define UART_UARTPCELLID2__UARTPCELLID2__Msk                    (0x000000FFUL << UART_UARTPCELLID2__UARTPCELLID2__Pos)                 /*!< Mask for UARTPCellID2 in UART.UARTPCELLID2 */
#define UART_UARTPCELLID2__UARTPCELLID2__Shift(v)               (((v) << UART_UARTPCELLID2__UARTPCELLID2__Pos) & UART_UARTPCELLID2__UARTPCELLID2__Msk) /*!< Shift value 'v' into UARTPCellID2 and mask 'v' to fit it into UARTPCellID2 field */

/** UART_UARTPCELLID2__UARTPCELLID2__GET() gets UARTPCELLID2.UARTPCELLID2's current value.
 *
 * When reading from UARTPCELLID2.UARTPCELLID2, this is recommended to use.
 *
 * @return current value of UARTPCELLID2.UARTPCELLID2
 */
__UART_INLINE uint32_t UART_UARTPCELLID2__UARTPCELLID2__GET(void)
{
    uint32_t reg = UART_UARTPCELLID2__GET();
    reg = (reg & UART_UARTPCELLID2__UARTPCELLID2__Msk);
    reg = (reg >> UART_UARTPCELLID2__UARTPCELLID2__Pos);
    return (uint32_t)reg;
}

/** UART_UARTPCELLID2__UARTPCELLID2__EXTRACT() extracts UARTPCELLID2.UARTPCELLID2.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTPCELLID2.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTPCELLID2
 * @return current value of UARTPCELLID2.UARTPCELLID2
 */
__UART_INLINE uint32_t UART_UARTPCELLID2__UARTPCELLID2__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTPCELLID2__UARTPCELLID2__Msk);
    reg = (reg >> UART_UARTPCELLID2__UARTPCELLID2__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                       UARTPCELLID3 member of UART_t                       */
/* -------------------------------------------------------------------------- */

/** __UART_UARTPCELLID3__ADDRESS returns the address of member UARTPCELLID3.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of UARTPCELLID3
 */
__UART_INLINE uint32_t* __UART_UARTPCELLID3__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__UART_BASE_PTR() + (uint32_t)(offsetof(UART_t, UARTPCELLID3)));
}

/** UART_UARTPCELLID3__GET() gets UARTPCELLID3's current value.
 *
 * When reading from UARTPCELLID3, this is mandatory to use.
 *
 * @return current value of UARTPCELLID3
 */
__UART_INLINE uint32_t UART_UARTPCELLID3__GET(void)
{
    return HAL_GET32(__UART_UARTPCELLID3__ADDRESS());
}

/* --------------------- UART.UARTPCELLID3.UARTPCELLID3 --------------------- */

/**
<pre>
  UART.UARTPCELLID3.UARTPCELLID3:

    UARTPCellID3

</pre> */

#define UART_UARTPCELLID3__UARTPCELLID3__Pos                    0                                                                      /*!< Right-most bit position of UARTPCellID3 in UART.UARTPCELLID3 */
#define UART_UARTPCELLID3__UARTPCELLID3__Msk                    (0x000000FFUL << UART_UARTPCELLID3__UARTPCELLID3__Pos)                 /*!< Mask for UARTPCellID3 in UART.UARTPCELLID3 */
#define UART_UARTPCELLID3__UARTPCELLID3__Shift(v)               (((v) << UART_UARTPCELLID3__UARTPCELLID3__Pos) & UART_UARTPCELLID3__UARTPCELLID3__Msk) /*!< Shift value 'v' into UARTPCellID3 and mask 'v' to fit it into UARTPCellID3 field */

/** UART_UARTPCELLID3__UARTPCELLID3__GET() gets UARTPCELLID3.UARTPCELLID3's current value.
 *
 * When reading from UARTPCELLID3.UARTPCELLID3, this is recommended to use.
 *
 * @return current value of UARTPCELLID3.UARTPCELLID3
 */
__UART_INLINE uint32_t UART_UARTPCELLID3__UARTPCELLID3__GET(void)
{
    uint32_t reg = UART_UARTPCELLID3__GET();
    reg = (reg & UART_UARTPCELLID3__UARTPCELLID3__Msk);
    reg = (reg >> UART_UARTPCELLID3__UARTPCELLID3__Pos);
    return (uint32_t)reg;
}

/** UART_UARTPCELLID3__UARTPCELLID3__EXTRACT() extracts UARTPCELLID3.UARTPCELLID3.
 *
 * This is recommended to use when extracting more than one bitfield from UART.UARTPCELLID3.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of UART.UARTPCELLID3
 * @return current value of UARTPCELLID3.UARTPCELLID3
 */
__UART_INLINE uint32_t UART_UARTPCELLID3__UARTPCELLID3__EXTRACT(uint32_t reg)
{
    reg = (reg & UART_UARTPCELLID3__UARTPCELLID3__Msk);
    reg = (reg >> UART_UARTPCELLID3__UARTPCELLID3__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group uart block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_UART_H_ */
