/**
 * @file     shasta_hal_cgu.h
 *
 * @brief    Definitions for the SHASTA Hardware Access Layer (HAL).
 *
 * @version  v0.0
 * @date     date
 *
 * @note
 */

/* ============================================================================
** Copyright (C) 2019 Infineon. All rights reserved.
**               Infineon Technologies, PMM SYS / DES
** ============================================================================
**
** ============================================================================
** This document contains proprietary information. Passing on and
** copying of this document, and communication of its contents is not
** permitted without prior written authorisation.
** ============================================================================
*
*/
/* This file is automatically generated. Do not edit! */
/*lint -save -e960 */


#ifndef _SHASTA_HAL_CGU_H_
#define _SHASTA_HAL_CGU_H_

#include    <stdint.h>

#include    <stddef.h>
#include    "fw_config.h"
#include    "hal_api.h"

/** @addtogroup Infineon
 * @{
 */

/** @addtogroup SHASTA
 * @{
 */


/** @addtogroup cgu
 * @{
 */

#if defined ( __CC_ARM )
#define __CGU_INLINE  static __inline __attribute__((always_inline))
#elif defined ( __GNUC__ )
#define __CGU_INLINE  static inline __attribute__((always_inline))
#elif defined ( _MSC_VER )
#define __CGU_INLINE  static __forceinline
#else
#warning Unsupported Compiler
#define __CGU_INLINE  static inline
#endif

/** register file of the cgu block.
 */
typedef struct _CGU_s
{
    volatile        uint32_t        ALPHA_CLK_DIV_CTRL          ; /*!< (@0x00000000) Alpha Clock Divider Control Register */
    volatile        uint32_t        CPU_CLK_DIV_CTRL            ; /*!< (@0x00000004) CPU Clock Divider Control Register */
    volatile        uint32_t        KRN_CLK_DIV_CTRL            ; /*!< (@0x00000008) Kernel Clocks Divider Control Register */
    volatile        uint32_t        CLKOUT_CTRL                 ; /*!< (@0x0000000C) Clockout Control Register */
    volatile        uint32_t        CLK_EN_CTRL                 ; /*!< (@0x00000010) Clock Enable Control Register */
    volatile        uint32_t        CLK_SLEEP_MSK_CNFG          ; /*!< (@0x00000014) Clock Sleep Mask Configuration Register */
    volatile        uint32_t        CLK_DEEP_SLEEP_MSK_CNFG     ; /*!< (@0x00000018) Clock Deep Sleep Mask Configuration Register */
    volatile        uint32_t        HOSC_SW_CLK_GATING_CTRL     ; /*!< (@0x0000001C) Hosc SW Clock Gating Control Register */
    volatile        uint32_t        HOSC_HW_CLK_GATING_CTRL     ; /*!< (@0x00000020) Hosc HW Clock Gating Control Register */
    volatile        uint32_t        SPARE_FF                    ; /*!< (@0x00000024) Spare Register */
    volatile        uint8_t         REGMEMGAP0[8]               ; /*!< (@0x00000028) gap in address space */
    volatile        uint32_t        CLK_EN_CTRL_SET             ; /*!< (@0x00000030) Clock Enable Control Register */
    volatile        uint32_t        CLK_EN_CTRL_CLR             ; /*!< (@0x00000034) Clock Enable Control Register */
    volatile        uint32_t        CLK_SLEEP_MSK_CNFG_SET      ; /*!< (@0x00000038) Clock Sleep Mask Configuration Register */
    volatile        uint32_t        CLK_SLEEP_MSK_CNFG_CLR      ; /*!< (@0x0000003C) Clock Sleep Mask Configuration Register */
    volatile        uint32_t        CLK_DEEP_SLEEP_MSK_CNFG_SET ; /*!< (@0x00000040) Clock Deep Sleep Mask Configuration Register */
    volatile        uint32_t        CLK_DEEP_SLEEP_MSK_CNFG_CLR ; /*!< (@0x00000044) Clock Deep Sleep Mask Configuration Register */
} CGU_t;


#define CGU_BASE (0x40002000u)                                                          /*!< cgu base address */

/** __CGU_BASE_PTR returns the base address of the peripheral.
 *
 * @return base address of peripheral's instance
 */
__CGU_INLINE uint32_t* __CGU_BASE_PTR(void)
{
    return (uint32_t*)(CGU_BASE);
}


/* -------------------------------------------------------------------------- */
/*                     ALPHA_CLK_DIV_CTRL member of CGU_t                     */
/* -------------------------------------------------------------------------- */

/** __CGU_ALPHA_CLK_DIV_CTRL__ADDRESS returns the address of member ALPHA_CLK_DIV_CTRL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of ALPHA_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t* __CGU_ALPHA_CLK_DIV_CTRL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, ALPHA_CLK_DIV_CTRL)));
}

/** CGU_ALPHA_CLK_DIV_CTRL__SET() sets ALPHA_CLK_DIV_CTRL to given value.
 *
 * When writing to ALPHA_CLK_DIV_CTRL, this is mandatory to use.
 *
 * @param value new value for ALPHA_CLK_DIV_CTRL
 */
__CGU_INLINE void CGU_ALPHA_CLK_DIV_CTRL__SET(uint32_t value)
{
    HAL_SET32(__CGU_ALPHA_CLK_DIV_CTRL__ADDRESS(), value);
}

/** CGU_ALPHA_CLK_DIV_CTRL__GET() gets ALPHA_CLK_DIV_CTRL's current value.
 *
 * When reading from ALPHA_CLK_DIV_CTRL, this is mandatory to use.
 *
 * @return current value of ALPHA_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_ALPHA_CLK_DIV_CTRL__GET(void)
{
    return HAL_GET32(__CGU_ALPHA_CLK_DIV_CTRL__ADDRESS());
}

/* ------------------ CGU.ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV ------------------ */

/**
<pre>
  CGU.ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV:

    This reset value generates a default clock frequency of



    hosc_clk/4 for clk_alpha

</pre> */

#define CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Pos              0                                                                      /*!< Right-most bit position of alpha_clk_div in CGU.ALPHA_CLK_DIV_CTRL */
#define CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Msk              (0x0000001FUL << CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Pos)           /*!< Mask for alpha_clk_div in CGU.ALPHA_CLK_DIV_CTRL */
#define CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Shift(v)         (((v) << CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Pos) & CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Msk) /*!< Shift value 'v' into alpha_clk_div and mask 'v' to fit it into alpha_clk_div field */

/** CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__SET() sets ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV to given value.
 *
 * When writing to ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV, this is recommended to use.
 *
 * @param bf_value new value for ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV
 */
__CGU_INLINE void CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_ALPHA_CLK_DIV_CTRL__GET();
    reg = (reg & ~CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Msk);
    reg = (reg | (CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Shift((uint32_t)bf_value)));
    CGU_ALPHA_CLK_DIV_CTRL__SET(reg);
}

/** CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__GET() gets ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV's current value.
 *
 * When reading from ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV, this is recommended to use.
 *
 * @return current value of ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__GET(void)
{
    uint32_t reg = CGU_ALPHA_CLK_DIV_CTRL__GET();
    reg = (reg & CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Msk);
    reg = (reg >> CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/** CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__MODIFY() modifies ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV.
 *
 * This is recommended to use when setting more than one bitfield of CGU.ALPHA_CLK_DIV_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.ALPHA_CLK_DIV_CTRL
 * @param bf_value new value for ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV
 * @return new value of CGU.ALPHA_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Msk);
    reg = (reg | (CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__EXTRACT() extracts ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.ALPHA_CLK_DIV_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.ALPHA_CLK_DIV_CTRL
 * @return current value of ALPHA_CLK_DIV_CTRL.ALPHA_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Msk);
    reg = (reg >> CGU_ALPHA_CLK_DIV_CTRL__ALPHA_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      CPU_CLK_DIV_CTRL member of CGU_t                      */
/* -------------------------------------------------------------------------- */

/** __CGU_CPU_CLK_DIV_CTRL__ADDRESS returns the address of member CPU_CLK_DIV_CTRL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CPU_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t* __CGU_CPU_CLK_DIV_CTRL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CPU_CLK_DIV_CTRL)));
}

/** CGU_CPU_CLK_DIV_CTRL__SET() sets CPU_CLK_DIV_CTRL to given value.
 *
 * When writing to CPU_CLK_DIV_CTRL, this is mandatory to use.
 *
 * @param value new value for CPU_CLK_DIV_CTRL
 */
__CGU_INLINE void CGU_CPU_CLK_DIV_CTRL__SET(uint32_t value)
{
    HAL_SET32(__CGU_CPU_CLK_DIV_CTRL__ADDRESS(), value);
}

/** CGU_CPU_CLK_DIV_CTRL__GET() gets CPU_CLK_DIV_CTRL's current value.
 *
 * When reading from CPU_CLK_DIV_CTRL, this is mandatory to use.
 *
 * @return current value of CPU_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_CPU_CLK_DIV_CTRL__GET(void)
{
    return HAL_GET32(__CGU_CPU_CLK_DIV_CTRL__ADDRESS());
}

/* -------------------- CGU.CPU_CLK_DIV_CTRL.CPUCLK_DIV -------------------- */

/**
<pre>
  CGU.CPU_CLK_DIV_CTRL.CPUCLK_DIV:

    This reset value set the cpu_clk equal to alpha_clk (Divisor



    value is 1, when configuration = 0).

</pre> */

#define CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Pos                   0                                                                      /*!< Right-most bit position of cpuclk_div in CGU.CPU_CLK_DIV_CTRL */
#define CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Msk                   (0x0000001FUL << CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Pos)                /*!< Mask for cpuclk_div in CGU.CPU_CLK_DIV_CTRL */
#define CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Shift(v)              (((v) << CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Pos) & CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Msk) /*!< Shift value 'v' into cpuclk_div and mask 'v' to fit it into cpuclk_div field */

/** CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__SET() sets CPU_CLK_DIV_CTRL.CPUCLK_DIV to given value.
 *
 * When writing to CPU_CLK_DIV_CTRL.CPUCLK_DIV, this is recommended to use.
 *
 * @param bf_value new value for CPU_CLK_DIV_CTRL.CPUCLK_DIV
 */
__CGU_INLINE void CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CPU_CLK_DIV_CTRL__GET();
    reg = (reg & ~CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Msk);
    reg = (reg | (CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Shift((uint32_t)bf_value)));
    CGU_CPU_CLK_DIV_CTRL__SET(reg);
}

/** CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__GET() gets CPU_CLK_DIV_CTRL.CPUCLK_DIV's current value.
 *
 * When reading from CPU_CLK_DIV_CTRL.CPUCLK_DIV, this is recommended to use.
 *
 * @return current value of CPU_CLK_DIV_CTRL.CPUCLK_DIV
 */
__CGU_INLINE uint32_t CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__GET(void)
{
    uint32_t reg = CGU_CPU_CLK_DIV_CTRL__GET();
    reg = (reg & CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Msk);
    reg = (reg >> CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Pos);
    return (uint32_t)reg;
}

/** CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__MODIFY() modifies CPU_CLK_DIV_CTRL.CPUCLK_DIV.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CPU_CLK_DIV_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CPU_CLK_DIV_CTRL
 * @param bf_value new value for CPU_CLK_DIV_CTRL.CPUCLK_DIV
 * @return new value of CGU.CPU_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Msk);
    reg = (reg | (CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__EXTRACT() extracts CPU_CLK_DIV_CTRL.CPUCLK_DIV.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CPU_CLK_DIV_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CPU_CLK_DIV_CTRL
 * @return current value of CPU_CLK_DIV_CTRL.CPUCLK_DIV
 */
__CGU_INLINE uint32_t CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Msk);
    reg = (reg >> CGU_CPU_CLK_DIV_CTRL__CPUCLK_DIV__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      KRN_CLK_DIV_CTRL member of CGU_t                      */
/* -------------------------------------------------------------------------- */

/** __CGU_KRN_CLK_DIV_CTRL__ADDRESS returns the address of member KRN_CLK_DIV_CTRL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of KRN_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t* __CGU_KRN_CLK_DIV_CTRL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, KRN_CLK_DIV_CTRL)));
}

/** CGU_KRN_CLK_DIV_CTRL__SET() sets KRN_CLK_DIV_CTRL to given value.
 *
 * When writing to KRN_CLK_DIV_CTRL, this is mandatory to use.
 *
 * @param value new value for KRN_CLK_DIV_CTRL
 */
__CGU_INLINE void CGU_KRN_CLK_DIV_CTRL__SET(uint32_t value)
{
    HAL_SET32(__CGU_KRN_CLK_DIV_CTRL__ADDRESS(), value);
}

/** CGU_KRN_CLK_DIV_CTRL__GET() gets KRN_CLK_DIV_CTRL's current value.
 *
 * When reading from KRN_CLK_DIV_CTRL, this is mandatory to use.
 *
 * @return current value of KRN_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__GET(void)
{
    return HAL_GET32(__CGU_KRN_CLK_DIV_CTRL__ADDRESS());
}

/* ---------------- CGU.KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV ---------------- */

/**
<pre>
  CGU.KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV:

    This reset value set the cpu_clk equal to alpha_clk (Divisor



    value is 1, when configuration = 0).

</pre> */

#define CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Pos           25                                                                     /*!< Right-most bit position of otp_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Msk           (0x0000001FUL << CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Pos)        /*!< Mask for otp_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Shift(v)      (((v) << CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Pos) & CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Msk) /*!< Shift value 'v' into otp_kernel_clk_div and mask 'v' to fit it into otp_kernel_clk_div field */

/** CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__SET() sets KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV to given value.
 *
 * When writing to KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @param bf_value new value for KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV
 */
__CGU_INLINE void CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    CGU_KRN_CLK_DIV_CTRL__SET(reg);
}

/** CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__GET() gets KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV's current value.
 *
 * When reading from KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @return current value of KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__GET(void)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/** CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__MODIFY() modifies KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV.
 *
 * This is recommended to use when setting more than one bitfield of CGU.KRN_CLK_DIV_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @param bf_value new value for KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV
 * @return new value of CGU.KRN_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__EXTRACT() extracts KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.KRN_CLK_DIV_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @return current value of KRN_CLK_DIV_CTRL.OTP_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__OTP_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/* --------------- CGU.KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV --------------- */

/**
<pre>
  CGU.KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV:

    This reset value set the cpu_clk equal to alpha_clk (Divisor



    value is 1, when configuration = 0).

</pre> */

#define CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Pos         20                                                                     /*!< Right-most bit position of pmbus_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Msk         (0x0000001FUL << CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Pos)      /*!< Mask for pmbus_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Shift(v)    (((v) << CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Pos) & CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Msk) /*!< Shift value 'v' into pmbus_kernel_clk_div and mask 'v' to fit it into pmbus_kernel_clk_div field */

/** CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__SET() sets KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV to given value.
 *
 * When writing to KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @param bf_value new value for KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV
 */
__CGU_INLINE void CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    CGU_KRN_CLK_DIV_CTRL__SET(reg);
}

/** CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__GET() gets KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV's current value.
 *
 * When reading from KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @return current value of KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__GET(void)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/** CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__MODIFY() modifies KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV.
 *
 * This is recommended to use when setting more than one bitfield of CGU.KRN_CLK_DIV_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @param bf_value new value for KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV
 * @return new value of CGU.KRN_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__EXTRACT() extracts KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.KRN_CLK_DIV_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @return current value of KRN_CLK_DIV_CTRL.PMBUS_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__PMBUS_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV ---------------- */

/**
<pre>
  CGU.KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV:

    This reset value set the cpu_clk equal to alpha_clk (Divisor



    value is 1, when configuration = 0).

</pre> */

#define CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Pos           15                                                                     /*!< Right-most bit position of wdt_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Msk           (0x0000001FUL << CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Pos)        /*!< Mask for wdt_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Shift(v)      (((v) << CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Pos) & CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Msk) /*!< Shift value 'v' into wdt_kernel_clk_div and mask 'v' to fit it into wdt_kernel_clk_div field */

/** CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__SET() sets KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV to given value.
 *
 * When writing to KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @param bf_value new value for KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV
 */
__CGU_INLINE void CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    CGU_KRN_CLK_DIV_CTRL__SET(reg);
}

/** CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__GET() gets KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV's current value.
 *
 * When reading from KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @return current value of KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__GET(void)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/** CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__MODIFY() modifies KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV.
 *
 * This is recommended to use when setting more than one bitfield of CGU.KRN_CLK_DIV_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @param bf_value new value for KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV
 * @return new value of CGU.KRN_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__EXTRACT() extracts KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.KRN_CLK_DIV_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @return current value of KRN_CLK_DIV_CTRL.WDT_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__WDT_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV -------------- */

/**
<pre>
  CGU.KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV:

    This reset value set the cpu_clk equal to alpha_clk (Divisor



    value is 1, when configuration = 0).

</pre> */

#define CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Pos       10                                                                     /*!< Right-most bit position of dtimer3_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Msk       (0x0000001FUL << CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Pos)    /*!< Mask for dtimer3_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Shift(v)  (((v) << CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Pos) & CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Msk) /*!< Shift value 'v' into dtimer3_kernel_clk_div and mask 'v' to fit it into dtimer3_kernel_clk_div field */

/** CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__SET() sets KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV to given value.
 *
 * When writing to KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @param bf_value new value for KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV
 */
__CGU_INLINE void CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    CGU_KRN_CLK_DIV_CTRL__SET(reg);
}

/** CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__GET() gets KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV's current value.
 *
 * When reading from KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @return current value of KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__GET(void)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/** CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__MODIFY() modifies KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV.
 *
 * This is recommended to use when setting more than one bitfield of CGU.KRN_CLK_DIV_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @param bf_value new value for KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV
 * @return new value of CGU.KRN_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__EXTRACT() extracts KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.KRN_CLK_DIV_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @return current value of KRN_CLK_DIV_CTRL.DTIMER3_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__DTIMER3_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV -------------- */

/**
<pre>
  CGU.KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV:

    This reset value set the cpu_clk equal to alpha_clk (Divisor



    value is 1, when configuration = 0).

</pre> */

#define CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Pos       5                                                                      /*!< Right-most bit position of dtimer2_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Msk       (0x0000001FUL << CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Pos)    /*!< Mask for dtimer2_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Shift(v)  (((v) << CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Pos) & CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Msk) /*!< Shift value 'v' into dtimer2_kernel_clk_div and mask 'v' to fit it into dtimer2_kernel_clk_div field */

/** CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__SET() sets KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV to given value.
 *
 * When writing to KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @param bf_value new value for KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV
 */
__CGU_INLINE void CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    CGU_KRN_CLK_DIV_CTRL__SET(reg);
}

/** CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__GET() gets KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV's current value.
 *
 * When reading from KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @return current value of KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__GET(void)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/** CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__MODIFY() modifies KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV.
 *
 * This is recommended to use when setting more than one bitfield of CGU.KRN_CLK_DIV_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @param bf_value new value for KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV
 * @return new value of CGU.KRN_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__EXTRACT() extracts KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.KRN_CLK_DIV_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @return current value of KRN_CLK_DIV_CTRL.DTIMER2_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__DTIMER2_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV -------------- */

/**
<pre>
  CGU.KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV:

    This reset value set the cpu_clk equal to alpha_clk (Divisor



    value is 1, when configuration = 0).

</pre> */

#define CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Pos       0                                                                      /*!< Right-most bit position of dtimer1_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Msk       (0x0000001FUL << CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Pos)    /*!< Mask for dtimer1_kernel_clk_div in CGU.KRN_CLK_DIV_CTRL */
#define CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Shift(v)  (((v) << CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Pos) & CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Msk) /*!< Shift value 'v' into dtimer1_kernel_clk_div and mask 'v' to fit it into dtimer1_kernel_clk_div field */

/** CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__SET() sets KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV to given value.
 *
 * When writing to KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @param bf_value new value for KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV
 */
__CGU_INLINE void CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    CGU_KRN_CLK_DIV_CTRL__SET(reg);
}

/** CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__GET() gets KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV's current value.
 *
 * When reading from KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV, this is recommended to use.
 *
 * @return current value of KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__GET(void)
{
    uint32_t reg = CGU_KRN_CLK_DIV_CTRL__GET();
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/** CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__MODIFY() modifies KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV.
 *
 * This is recommended to use when setting more than one bitfield of CGU.KRN_CLK_DIV_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @param bf_value new value for KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV
 * @return new value of CGU.KRN_CLK_DIV_CTRL
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Msk);
    reg = (reg | (CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__EXTRACT() extracts KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.KRN_CLK_DIV_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.KRN_CLK_DIV_CTRL
 * @return current value of KRN_CLK_DIV_CTRL.DTIMER1_KERNEL_CLK_DIV
 */
__CGU_INLINE uint32_t CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Msk);
    reg = (reg >> CGU_KRN_CLK_DIV_CTRL__DTIMER1_KERNEL_CLK_DIV__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        CLKOUT_CTRL member of CGU_t                        */
/* -------------------------------------------------------------------------- */

/** __CGU_CLKOUT_CTRL__ADDRESS returns the address of member CLKOUT_CTRL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CLKOUT_CTRL
 */
__CGU_INLINE uint32_t* __CGU_CLKOUT_CTRL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CLKOUT_CTRL)));
}

/** CGU_CLKOUT_CTRL__SET() sets CLKOUT_CTRL to given value.
 *
 * When writing to CLKOUT_CTRL, this is mandatory to use.
 *
 * @param value new value for CLKOUT_CTRL
 */
__CGU_INLINE void CGU_CLKOUT_CTRL__SET(uint32_t value)
{
    HAL_SET32(__CGU_CLKOUT_CTRL__ADDRESS(), value);
}

/** CGU_CLKOUT_CTRL__GET() gets CLKOUT_CTRL's current value.
 *
 * When reading from CLKOUT_CTRL, this is mandatory to use.
 *
 * @return current value of CLKOUT_CTRL
 */
__CGU_INLINE uint32_t CGU_CLKOUT_CTRL__GET(void)
{
    return HAL_GET32(__CGU_CLKOUT_CTRL__ADDRESS());
}

/* ------------------------ CGU.CLKOUT_CTRL.CLKOUT_G ------------------------ */

/**
<pre>
  CGU.CLKOUT_CTRL.CLKOUT_G:

    1: Clockout is live

</pre> */

#define CGU_CLKOUT_CTRL__CLKOUT_G__Pos                          8                                                                      /*!< Right-most bit position of clkout_g in CGU.CLKOUT_CTRL */
#define CGU_CLKOUT_CTRL__CLKOUT_G__Msk                          (0x00000001UL << CGU_CLKOUT_CTRL__CLKOUT_G__Pos)                       /*!< Mask for clkout_g in CGU.CLKOUT_CTRL */
#define CGU_CLKOUT_CTRL__CLKOUT_G__Shift(v)                     (((v) << CGU_CLKOUT_CTRL__CLKOUT_G__Pos) & CGU_CLKOUT_CTRL__CLKOUT_G__Msk) /*!< Shift value 'v' into clkout_g and mask 'v' to fit it into clkout_g field */

/** CGU_CLKOUT_CTRL__CLKOUT_G__SET() sets CLKOUT_CTRL.CLKOUT_G to given value.
 *
 * When writing to CLKOUT_CTRL.CLKOUT_G, this is recommended to use.
 *
 * @param bf_value new value for CLKOUT_CTRL.CLKOUT_G
 */
__CGU_INLINE void CGU_CLKOUT_CTRL__CLKOUT_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLKOUT_CTRL__GET();
    reg = (reg & ~CGU_CLKOUT_CTRL__CLKOUT_G__Msk);
    reg = (reg | (CGU_CLKOUT_CTRL__CLKOUT_G__Shift((uint32_t)bf_value)));
    CGU_CLKOUT_CTRL__SET(reg);
}

/** CGU_CLKOUT_CTRL__CLKOUT_G__GET() gets CLKOUT_CTRL.CLKOUT_G's current value.
 *
 * When reading from CLKOUT_CTRL.CLKOUT_G, this is recommended to use.
 *
 * @return current value of CLKOUT_CTRL.CLKOUT_G
 */
__CGU_INLINE uint32_t CGU_CLKOUT_CTRL__CLKOUT_G__GET(void)
{
    uint32_t reg = CGU_CLKOUT_CTRL__GET();
    reg = (reg & CGU_CLKOUT_CTRL__CLKOUT_G__Msk);
    reg = (reg >> CGU_CLKOUT_CTRL__CLKOUT_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLKOUT_CTRL__CLKOUT_G__MODIFY() modifies CLKOUT_CTRL.CLKOUT_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLKOUT_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLKOUT_CTRL
 * @param bf_value new value for CLKOUT_CTRL.CLKOUT_G
 * @return new value of CGU.CLKOUT_CTRL
 */
__CGU_INLINE uint32_t CGU_CLKOUT_CTRL__CLKOUT_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLKOUT_CTRL__CLKOUT_G__Msk);
    reg = (reg | (CGU_CLKOUT_CTRL__CLKOUT_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLKOUT_CTRL__CLKOUT_G__EXTRACT() extracts CLKOUT_CTRL.CLKOUT_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLKOUT_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLKOUT_CTRL
 * @return current value of CLKOUT_CTRL.CLKOUT_G
 */
__CGU_INLINE uint32_t CGU_CLKOUT_CTRL__CLKOUT_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLKOUT_CTRL__CLKOUT_G__Msk);
    reg = (reg >> CGU_CLKOUT_CTRL__CLKOUT_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLKOUT_CTRL.CLKOUT_MUX_DIV --------------------- */

/**
<pre>
  CGU.CLKOUT_CTRL.CLKOUT_MUX_DIV:

    clkout = clkout_mux/(2^div)

</pre> */

#define CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Pos                    4                                                                      /*!< Right-most bit position of clkout_mux_div in CGU.CLKOUT_CTRL */
#define CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Msk                    (0x0000000FUL << CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Pos)                 /*!< Mask for clkout_mux_div in CGU.CLKOUT_CTRL */
#define CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Shift(v)               (((v) << CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Pos) & CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Msk) /*!< Shift value 'v' into clkout_mux_div and mask 'v' to fit it into clkout_mux_div field */

/** CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__SET() sets CLKOUT_CTRL.CLKOUT_MUX_DIV to given value.
 *
 * When writing to CLKOUT_CTRL.CLKOUT_MUX_DIV, this is recommended to use.
 *
 * @param bf_value new value for CLKOUT_CTRL.CLKOUT_MUX_DIV
 */
__CGU_INLINE void CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLKOUT_CTRL__GET();
    reg = (reg & ~CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Msk);
    reg = (reg | (CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Shift((uint32_t)bf_value)));
    CGU_CLKOUT_CTRL__SET(reg);
}

/** CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__GET() gets CLKOUT_CTRL.CLKOUT_MUX_DIV's current value.
 *
 * When reading from CLKOUT_CTRL.CLKOUT_MUX_DIV, this is recommended to use.
 *
 * @return current value of CLKOUT_CTRL.CLKOUT_MUX_DIV
 */
__CGU_INLINE uint32_t CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__GET(void)
{
    uint32_t reg = CGU_CLKOUT_CTRL__GET();
    reg = (reg & CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Msk);
    reg = (reg >> CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Pos);
    return (uint32_t)reg;
}

/** CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__MODIFY() modifies CLKOUT_CTRL.CLKOUT_MUX_DIV.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLKOUT_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLKOUT_CTRL
 * @param bf_value new value for CLKOUT_CTRL.CLKOUT_MUX_DIV
 * @return new value of CGU.CLKOUT_CTRL
 */
__CGU_INLINE uint32_t CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Msk);
    reg = (reg | (CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__EXTRACT() extracts CLKOUT_CTRL.CLKOUT_MUX_DIV.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLKOUT_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLKOUT_CTRL
 * @return current value of CLKOUT_CTRL.CLKOUT_MUX_DIV
 */
__CGU_INLINE uint32_t CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Msk);
    reg = (reg >> CGU_CLKOUT_CTRL__CLKOUT_MUX_DIV__Pos);
    return (uint32_t)reg;
}

/* ----------------------- CGU.CLKOUT_CTRL.CLKOUT_MUX ----------------------- */

/**
<pre>
  CGU.CLKOUT_CTRL.CLKOUT_MUX:

    Clock out (clkout_mux) selection.

</pre> */

/*lint -parent(uint32_t, cgu_clkout_ctrl__clkout_mux_t) -strong(AJX)*/
typedef enum cgu_clkout_ctrl__clkout_mux_e                                                                                             /*!< Clock out (clkout_mux) selection. */
{
    cgu_clkout_ctrl__clkout_mux_s0 = 0x0u,                                                                                             /*!<      Select alpha_clk output */
    cgu_clkout_ctrl__clkout_mux_s1 = 0x1u,                                                                                             /*!<      Select cpu_clk output */
    cgu_clkout_ctrl__clkout_mux_s2 = 0x2u,                                                                                             /*!<      Select otp1_w_clk2 output */
    cgu_clkout_ctrl__clkout_mux_s3 = 0x3u,                                                                                             /*!<      Select otp2_w_clk2 output */
    cgu_clkout_ctrl__clkout_mux_s4 = 0x4u,                                                                                             /*!<      Select wdt_kernel_clk output */
    cgu_clkout_ctrl__clkout_mux_s5 = 0x5u,                                                                                             /*!<      Select dtimer_kernel_clk output */
    cgu_clkout_ctrl__clkout_mux_s6 = 0x6u,                                                                                             /*!<      Select bif_reg_clk output */
    cgu_clkout_ctrl__clkout_mux_s7 = 0x7u,                                                                                             /*!<      Select bif_per_clk output */
    cgu_clkout_ctrl__clkout_mux_s8 = 0x8u,                                                                                             /*!<      Select bif_per_clk output */
    cgu_clkout_ctrl__clkout_mux_s9 = 0x9u,                                                                                             /*!<      Select bif_per_clk output */
    cgu_clkout_ctrl__clkout_mux_s10 = 0xau,                                                                                            /*!<      Select bif_per_clk output */
    cgu_clkout_ctrl__clkout_mux_s11 = 0xbu,                                                                                            /*!<      Select bif_per_clk output */
    cgu_clkout_ctrl__clkout_mux_s12 = 0xcu,                                                                                            /*!<      Select bif_per_clk output */
    cgu_clkout_ctrl__clkout_mux_s13 = 0xdu,                                                                                            /*!<      Select bif_per_clk output */
    cgu_clkout_ctrl__clkout_mux_s14 = 0xeu,                                                                                            /*!<      Select bif_per_clk output */
    cgu_clkout_ctrl__clkout_mux_s15 = 0xfu                                                                                             /*!<      Select bif_per_clk output */
} cgu_clkout_ctrl__clkout_mux_t;

#define CGU_CLKOUT_CTRL__CLKOUT_MUX__Pos                        0                                                                      /*!< Right-most bit position of clkout_mux in CGU.CLKOUT_CTRL */
#define CGU_CLKOUT_CTRL__CLKOUT_MUX__Msk                        (0x0000000FUL << CGU_CLKOUT_CTRL__CLKOUT_MUX__Pos)                     /*!< Mask for clkout_mux in CGU.CLKOUT_CTRL */
#define CGU_CLKOUT_CTRL__CLKOUT_MUX__Shift(v)                   (((v) << CGU_CLKOUT_CTRL__CLKOUT_MUX__Pos) & CGU_CLKOUT_CTRL__CLKOUT_MUX__Msk) /*!< Shift value 'v' into clkout_mux and mask 'v' to fit it into clkout_mux field */

/** CGU_CLKOUT_CTRL__CLKOUT_MUX__SET() sets CLKOUT_CTRL.CLKOUT_MUX to given value.
 *
 * When writing to CLKOUT_CTRL.CLKOUT_MUX, this is recommended to use.
 *
 * @param bf_value new value for CLKOUT_CTRL.CLKOUT_MUX
 */
__CGU_INLINE void CGU_CLKOUT_CTRL__CLKOUT_MUX__SET(cgu_clkout_ctrl__clkout_mux_t bf_value)
{
    uint32_t reg = CGU_CLKOUT_CTRL__GET();
    reg = (reg & ~CGU_CLKOUT_CTRL__CLKOUT_MUX__Msk);
    reg = (reg | (CGU_CLKOUT_CTRL__CLKOUT_MUX__Shift((uint32_t)bf_value)));
    CGU_CLKOUT_CTRL__SET(reg);
}

/** CGU_CLKOUT_CTRL__CLKOUT_MUX__GET() gets CLKOUT_CTRL.CLKOUT_MUX's current value.
 *
 * When reading from CLKOUT_CTRL.CLKOUT_MUX, this is recommended to use.
 *
 * @return current value of CLKOUT_CTRL.CLKOUT_MUX
 */
__CGU_INLINE cgu_clkout_ctrl__clkout_mux_t CGU_CLKOUT_CTRL__CLKOUT_MUX__GET(void)
{
    uint32_t reg = CGU_CLKOUT_CTRL__GET();
    reg = (reg & CGU_CLKOUT_CTRL__CLKOUT_MUX__Msk);
    reg = (reg >> CGU_CLKOUT_CTRL__CLKOUT_MUX__Pos);
    return (cgu_clkout_ctrl__clkout_mux_t)reg;
}

/** CGU_CLKOUT_CTRL__CLKOUT_MUX__MODIFY() modifies CLKOUT_CTRL.CLKOUT_MUX.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLKOUT_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLKOUT_CTRL
 * @param bf_value new value for CLKOUT_CTRL.CLKOUT_MUX
 * @return new value of CGU.CLKOUT_CTRL
 */
__CGU_INLINE uint32_t CGU_CLKOUT_CTRL__CLKOUT_MUX__MODIFY(uint32_t reg, cgu_clkout_ctrl__clkout_mux_t bf_value)
{
    reg = (reg & ~CGU_CLKOUT_CTRL__CLKOUT_MUX__Msk);
    reg = (reg | (CGU_CLKOUT_CTRL__CLKOUT_MUX__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLKOUT_CTRL__CLKOUT_MUX__EXTRACT() extracts CLKOUT_CTRL.CLKOUT_MUX.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLKOUT_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLKOUT_CTRL
 * @return current value of CLKOUT_CTRL.CLKOUT_MUX
 */
__CGU_INLINE cgu_clkout_ctrl__clkout_mux_t CGU_CLKOUT_CTRL__CLKOUT_MUX__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLKOUT_CTRL__CLKOUT_MUX__Msk);
    reg = (reg >> CGU_CLKOUT_CTRL__CLKOUT_MUX__Pos);
    return (cgu_clkout_ctrl__clkout_mux_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                        CLK_EN_CTRL member of CGU_t                        */
/* -------------------------------------------------------------------------- */

/** __CGU_CLK_EN_CTRL__ADDRESS returns the address of member CLK_EN_CTRL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CLK_EN_CTRL
 */
__CGU_INLINE uint32_t* __CGU_CLK_EN_CTRL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CLK_EN_CTRL)));
}

/** CGU_CLK_EN_CTRL__SET() sets CLK_EN_CTRL to given value.
 *
 * When writing to CLK_EN_CTRL, this is mandatory to use.
 *
 * @param value new value for CLK_EN_CTRL
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__SET(uint32_t value)
{
    HAL_SET32(__CGU_CLK_EN_CTRL__ADDRESS(), value);
}

/** CGU_CLK_EN_CTRL__GET() gets CLK_EN_CTRL's current value.
 *
 * When reading from CLK_EN_CTRL, this is mandatory to use.
 *
 * @return current value of CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__GET(void)
{
    return HAL_GET32(__CGU_CLK_EN_CTRL__ADDRESS());
}

/* -------------------- CGU.CLK_EN_CTRL.OTP_KERNEL_CLK_G -------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.OTP_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Pos                  27                                                                     /*!< Right-most bit position of otp_kernel_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Msk                  (0x00000001UL << CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Pos)               /*!< Mask for otp_kernel_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Shift(v)             (((v) << CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into otp_kernel_clk_g and mask 'v' to fit it into otp_kernel_clk_g field */

/** CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__SET() sets CLK_EN_CTRL.OTP_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.OTP_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.OTP_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__GET() gets CLK_EN_CTRL.OTP_KERNEL_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.OTP_KERNEL_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.OTP_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL.OTP_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.OTP_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL.OTP_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.OTP_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__OTP_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL.PMBUS_KERNEL_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.PMBUS_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Pos                26                                                                     /*!< Right-most bit position of pmbus_kernel_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Msk                (0x00000001UL << CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Pos)             /*!< Mask for pmbus_kernel_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Shift(v)           (((v) << CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into pmbus_kernel_clk_g and mask 'v' to fit it into pmbus_kernel_clk_g field */

/** CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__SET() sets CLK_EN_CTRL.PMBUS_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.PMBUS_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.PMBUS_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__GET() gets CLK_EN_CTRL.PMBUS_KERNEL_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.PMBUS_KERNEL_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.PMBUS_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL.PMBUS_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.PMBUS_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL.PMBUS_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.PMBUS_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__PMBUS_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Pos              25                                                                     /*!< Right-most bit position of dtimer3_kernel_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Msk              (0x00000001UL << CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Pos)           /*!< Mask for dtimer3_kernel_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Shift(v)         (((v) << CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into dtimer3_kernel_clk_g and mask 'v' to fit it into dtimer3_kernel_clk_g field */

/** CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__SET() sets CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__GET() gets CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.DTIMER3_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER3_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Pos              24                                                                     /*!< Right-most bit position of dtimer2_kernel_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Msk              (0x00000001UL << CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Pos)           /*!< Mask for dtimer2_kernel_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Shift(v)         (((v) << CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into dtimer2_kernel_clk_g and mask 'v' to fit it into dtimer2_kernel_clk_g field */

/** CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__SET() sets CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__GET() gets CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.DTIMER2_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER2_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Pos              23                                                                     /*!< Right-most bit position of dtimer1_kernel_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Msk              (0x00000001UL << CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Pos)           /*!< Mask for dtimer1_kernel_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Shift(v)         (((v) << CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into dtimer1_kernel_clk_g and mask 'v' to fit it into dtimer1_kernel_clk_g field */

/** CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__SET() sets CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__GET() gets CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.DTIMER1_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER1_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------------- CGU.CLK_EN_CTRL.GPIO1_CLK_G ---------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.GPIO1_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__GPIO1_CLK_G__Pos                       22                                                                     /*!< Right-most bit position of gpio1_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__GPIO1_CLK_G__Msk                       (0x00000001UL << CGU_CLK_EN_CTRL__GPIO1_CLK_G__Pos)                    /*!< Mask for gpio1_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__GPIO1_CLK_G__Shift(v)                  (((v) << CGU_CLK_EN_CTRL__GPIO1_CLK_G__Pos) & CGU_CLK_EN_CTRL__GPIO1_CLK_G__Msk) /*!< Shift value 'v' into gpio1_clk_g and mask 'v' to fit it into gpio1_clk_g field */

/** CGU_CLK_EN_CTRL__GPIO1_CLK_G__SET() sets CLK_EN_CTRL.GPIO1_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.GPIO1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.GPIO1_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__GPIO1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__GPIO1_CLK_G__GET() gets CLK_EN_CTRL.GPIO1_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.GPIO1_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__GPIO1_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__GPIO1_CLK_G__MODIFY() modifies CLK_EN_CTRL.GPIO1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.GPIO1_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__GPIO1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__GPIO1_CLK_G__EXTRACT() extracts CLK_EN_CTRL.GPIO1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__GPIO1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------------- CGU.CLK_EN_CTRL.GPIO0_CLK_G ---------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.GPIO0_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__GPIO0_CLK_G__Pos                       21                                                                     /*!< Right-most bit position of gpio0_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__GPIO0_CLK_G__Msk                       (0x00000001UL << CGU_CLK_EN_CTRL__GPIO0_CLK_G__Pos)                    /*!< Mask for gpio0_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__GPIO0_CLK_G__Shift(v)                  (((v) << CGU_CLK_EN_CTRL__GPIO0_CLK_G__Pos) & CGU_CLK_EN_CTRL__GPIO0_CLK_G__Msk) /*!< Shift value 'v' into gpio0_clk_g and mask 'v' to fit it into gpio0_clk_g field */

/** CGU_CLK_EN_CTRL__GPIO0_CLK_G__SET() sets CLK_EN_CTRL.GPIO0_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.GPIO0_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.GPIO0_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__GPIO0_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__GPIO0_CLK_G__GET() gets CLK_EN_CTRL.GPIO0_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.GPIO0_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__GPIO0_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__GPIO0_CLK_G__MODIFY() modifies CLK_EN_CTRL.GPIO0_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.GPIO0_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__GPIO0_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__GPIO0_CLK_G__EXTRACT() extracts CLK_EN_CTRL.GPIO0_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__GPIO0_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------------- CGU.CLK_EN_CTRL.WDT_CLK_G ----------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.WDT_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__WDT_CLK_G__Pos                         20                                                                     /*!< Right-most bit position of wdt_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__WDT_CLK_G__Msk                         (0x00000001UL << CGU_CLK_EN_CTRL__WDT_CLK_G__Pos)                      /*!< Mask for wdt_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__WDT_CLK_G__Shift(v)                    (((v) << CGU_CLK_EN_CTRL__WDT_CLK_G__Pos) & CGU_CLK_EN_CTRL__WDT_CLK_G__Msk) /*!< Shift value 'v' into wdt_clk_g and mask 'v' to fit it into wdt_clk_g field */

/** CGU_CLK_EN_CTRL__WDT_CLK_G__SET() sets CLK_EN_CTRL.WDT_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.WDT_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.WDT_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__WDT_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__WDT_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__WDT_CLK_G__GET() gets CLK_EN_CTRL.WDT_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.WDT_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__WDT_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__WDT_CLK_G__MODIFY() modifies CLK_EN_CTRL.WDT_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.WDT_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__WDT_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__WDT_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__WDT_CLK_G__EXTRACT() extracts CLK_EN_CTRL.WDT_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__WDT_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL.DTIMER3_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.DTIMER3_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Pos                     19                                                                     /*!< Right-most bit position of dtimer3_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Msk                     (0x00000001UL << CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Pos)                  /*!< Mask for dtimer3_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Shift(v)                (((v) << CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Pos) & CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Msk) /*!< Shift value 'v' into dtimer3_clk_g and mask 'v' to fit it into dtimer3_clk_g field */

/** CGU_CLK_EN_CTRL__DTIMER3_CLK_G__SET() sets CLK_EN_CTRL.DTIMER3_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.DTIMER3_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.DTIMER3_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__DTIMER3_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__DTIMER3_CLK_G__GET() gets CLK_EN_CTRL.DTIMER3_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.DTIMER3_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER3_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__DTIMER3_CLK_G__MODIFY() modifies CLK_EN_CTRL.DTIMER3_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.DTIMER3_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER3_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__DTIMER3_CLK_G__EXTRACT() extracts CLK_EN_CTRL.DTIMER3_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER3_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL.DTIMER2_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.DTIMER2_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Pos                     18                                                                     /*!< Right-most bit position of dtimer2_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Msk                     (0x00000001UL << CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Pos)                  /*!< Mask for dtimer2_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Shift(v)                (((v) << CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Pos) & CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Msk) /*!< Shift value 'v' into dtimer2_clk_g and mask 'v' to fit it into dtimer2_clk_g field */

/** CGU_CLK_EN_CTRL__DTIMER2_CLK_G__SET() sets CLK_EN_CTRL.DTIMER2_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.DTIMER2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.DTIMER2_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__DTIMER2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__DTIMER2_CLK_G__GET() gets CLK_EN_CTRL.DTIMER2_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.DTIMER2_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER2_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__DTIMER2_CLK_G__MODIFY() modifies CLK_EN_CTRL.DTIMER2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.DTIMER2_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__DTIMER2_CLK_G__EXTRACT() extracts CLK_EN_CTRL.DTIMER2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL.DTIMER1_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.DTIMER1_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Pos                     17                                                                     /*!< Right-most bit position of dtimer1_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Msk                     (0x00000001UL << CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Pos)                  /*!< Mask for dtimer1_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Shift(v)                (((v) << CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Pos) & CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Msk) /*!< Shift value 'v' into dtimer1_clk_g and mask 'v' to fit it into dtimer1_clk_g field */

/** CGU_CLK_EN_CTRL__DTIMER1_CLK_G__SET() sets CLK_EN_CTRL.DTIMER1_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.DTIMER1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.DTIMER1_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__DTIMER1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__DTIMER1_CLK_G__GET() gets CLK_EN_CTRL.DTIMER1_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.DTIMER1_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER1_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__DTIMER1_CLK_G__MODIFY() modifies CLK_EN_CTRL.DTIMER1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.DTIMER1_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__DTIMER1_CLK_G__EXTRACT() extracts CLK_EN_CTRL.DTIMER1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DTIMER1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL.BIF_PER_UART_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.BIF_PER_UART_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Pos                16                                                                     /*!< Right-most bit position of bif_per_uart_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Msk                (0x00000001UL << CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Pos)             /*!< Mask for bif_per_uart_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Shift(v)           (((v) << CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Pos) & CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Msk) /*!< Shift value 'v' into bif_per_uart_clk_g and mask 'v' to fit it into bif_per_uart_clk_g field */

/** CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__SET() sets CLK_EN_CTRL.BIF_PER_UART_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.BIF_PER_UART_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__GET() gets CLK_EN_CTRL.BIF_PER_UART_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__MODIFY() modifies CLK_EN_CTRL.BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.BIF_PER_UART_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__EXTRACT() extracts CLK_EN_CTRL.BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL.BIF_PER_I2C_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.BIF_PER_I2C_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Pos                 15                                                                     /*!< Right-most bit position of bif_per_i2c_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Pos)              /*!< Mask for bif_per_i2c_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Pos) & CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Msk) /*!< Shift value 'v' into bif_per_i2c_clk_g and mask 'v' to fit it into bif_per_i2c_clk_g field */

/** CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__SET() sets CLK_EN_CTRL.BIF_PER_I2C_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.BIF_PER_I2C_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__GET() gets CLK_EN_CTRL.BIF_PER_I2C_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__MODIFY() modifies CLK_EN_CTRL.BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.BIF_PER_I2C_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__EXTRACT() extracts CLK_EN_CTRL.BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL.BIF_PER_SSP_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.BIF_PER_SSP_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Pos                 14                                                                     /*!< Right-most bit position of bif_per_ssp_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Pos)              /*!< Mask for bif_per_ssp_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Pos) & CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Msk) /*!< Shift value 'v' into bif_per_ssp_clk_g and mask 'v' to fit it into bif_per_ssp_clk_g field */

/** CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__SET() sets CLK_EN_CTRL.BIF_PER_SSP_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.BIF_PER_SSP_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__GET() gets CLK_EN_CTRL.BIF_PER_SSP_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__MODIFY() modifies CLK_EN_CTRL.BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.BIF_PER_SSP_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__EXTRACT() extracts CLK_EN_CTRL.BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Pos               13                                                                     /*!< Right-most bit position of bif_per_pmbus_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Msk               (0x00000001UL << CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Pos)            /*!< Mask for bif_per_pmbus_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Shift(v)          (((v) << CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Pos) & CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Msk) /*!< Shift value 'v' into bif_per_pmbus_clk_g and mask 'v' to fit it into bif_per_pmbus_clk_g field */

/** CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__SET() sets CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__GET() gets CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__MODIFY() modifies CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__EXTRACT() extracts CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL.BIF_PER_SVID_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.BIF_PER_SVID_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Pos                12                                                                     /*!< Right-most bit position of bif_per_svid_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Msk                (0x00000001UL << CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Pos)             /*!< Mask for bif_per_svid_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Shift(v)           (((v) << CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Pos) & CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Msk) /*!< Shift value 'v' into bif_per_svid_clk_g and mask 'v' to fit it into bif_per_svid_clk_g field */

/** CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__SET() sets CLK_EN_CTRL.BIF_PER_SVID_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.BIF_PER_SVID_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__GET() gets CLK_EN_CTRL.BIF_PER_SVID_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__MODIFY() modifies CLK_EN_CTRL.BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.BIF_PER_SVID_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__EXTRACT() extracts CLK_EN_CTRL.BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL.BIF_REG_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.BIF_REG_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Pos                     11                                                                     /*!< Right-most bit position of bif_reg_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Msk                     (0x00000001UL << CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Pos)                  /*!< Mask for bif_reg_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Shift(v)                (((v) << CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Pos) & CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Msk) /*!< Shift value 'v' into bif_reg_clk_g and mask 'v' to fit it into bif_reg_clk_g field */

/** CGU_CLK_EN_CTRL__BIF_REG_CLK_G__SET() sets CLK_EN_CTRL.BIF_REG_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.BIF_REG_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.BIF_REG_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__BIF_REG_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__BIF_REG_CLK_G__GET() gets CLK_EN_CTRL.BIF_REG_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.BIF_REG_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_REG_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__BIF_REG_CLK_G__MODIFY() modifies CLK_EN_CTRL.BIF_REG_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.BIF_REG_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_REG_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__BIF_REG_CLK_G__EXTRACT() extracts CLK_EN_CTRL.BIF_REG_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__BIF_REG_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL.CNFG_DMA_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.CNFG_DMA_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Pos                    10                                                                     /*!< Right-most bit position of cnfg_dma_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Msk                    (0x00000001UL << CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Pos)                 /*!< Mask for cnfg_dma_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Shift(v)               (((v) << CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Pos) & CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Msk) /*!< Shift value 'v' into cnfg_dma_clk_g and mask 'v' to fit it into cnfg_dma_clk_g field */

/** CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__SET() sets CLK_EN_CTRL.CNFG_DMA_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.CNFG_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__GET() gets CLK_EN_CTRL.CNFG_DMA_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__MODIFY() modifies CLK_EN_CTRL.CNFG_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.CNFG_DMA_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__EXTRACT() extracts CLK_EN_CTRL.CNFG_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL.CNFG_OTP1_W_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.CNFG_OTP1_W_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Pos                 6                                                                      /*!< Right-most bit position of cnfg_otp1_w_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Pos)              /*!< Mask for cnfg_otp1_w_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Pos) & CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Msk) /*!< Shift value 'v' into cnfg_otp1_w_clk_g and mask 'v' to fit it into cnfg_otp1_w_clk_g field */

/** CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__SET() sets CLK_EN_CTRL.CNFG_OTP1_W_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.CNFG_OTP1_W_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__GET() gets CLK_EN_CTRL.CNFG_OTP1_W_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.CNFG_OTP1_W_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__MODIFY() modifies CLK_EN_CTRL.CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.CNFG_OTP1_W_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__EXTRACT() extracts CLK_EN_CTRL.CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__CNFG_OTP1_W_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------------- CGU.CLK_EN_CTRL.DMA_CLK_G ----------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.DMA_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__DMA_CLK_G__Pos                         5                                                                      /*!< Right-most bit position of dma_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DMA_CLK_G__Msk                         (0x00000001UL << CGU_CLK_EN_CTRL__DMA_CLK_G__Pos)                      /*!< Mask for dma_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__DMA_CLK_G__Shift(v)                    (((v) << CGU_CLK_EN_CTRL__DMA_CLK_G__Pos) & CGU_CLK_EN_CTRL__DMA_CLK_G__Msk) /*!< Shift value 'v' into dma_clk_g and mask 'v' to fit it into dma_clk_g field */

/** CGU_CLK_EN_CTRL__DMA_CLK_G__SET() sets CLK_EN_CTRL.DMA_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DMA_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__DMA_CLK_G__GET() gets CLK_EN_CTRL.DMA_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.DMA_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DMA_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__DMA_CLK_G__MODIFY() modifies CLK_EN_CTRL.DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.DMA_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__DMA_CLK_G__EXTRACT() extracts CLK_EN_CTRL.DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------------- CGU.CLK_EN_CTRL.AMBA_CLK_G ----------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.AMBA_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__AMBA_CLK_G__Pos                        4                                                                      /*!< Right-most bit position of amba_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__AMBA_CLK_G__Msk                        (0x00000001UL << CGU_CLK_EN_CTRL__AMBA_CLK_G__Pos)                     /*!< Mask for amba_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__AMBA_CLK_G__Shift(v)                   (((v) << CGU_CLK_EN_CTRL__AMBA_CLK_G__Pos) & CGU_CLK_EN_CTRL__AMBA_CLK_G__Msk) /*!< Shift value 'v' into amba_clk_g and mask 'v' to fit it into amba_clk_g field */

/** CGU_CLK_EN_CTRL__AMBA_CLK_G__SET() sets CLK_EN_CTRL.AMBA_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.AMBA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.AMBA_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__AMBA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__AMBA_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__AMBA_CLK_G__GET() gets CLK_EN_CTRL.AMBA_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.AMBA_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__AMBA_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__AMBA_CLK_G__MODIFY() modifies CLK_EN_CTRL.AMBA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.AMBA_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__AMBA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__AMBA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__AMBA_CLK_G__EXTRACT() extracts CLK_EN_CTRL.AMBA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__AMBA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------------- CGU.CLK_EN_CTRL.RAM2_CLK_G ----------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.RAM2_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__RAM2_CLK_G__Pos                        3                                                                      /*!< Right-most bit position of ram2_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__RAM2_CLK_G__Msk                        (0x00000001UL << CGU_CLK_EN_CTRL__RAM2_CLK_G__Pos)                     /*!< Mask for ram2_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__RAM2_CLK_G__Shift(v)                   (((v) << CGU_CLK_EN_CTRL__RAM2_CLK_G__Pos) & CGU_CLK_EN_CTRL__RAM2_CLK_G__Msk) /*!< Shift value 'v' into ram2_clk_g and mask 'v' to fit it into ram2_clk_g field */

/** CGU_CLK_EN_CTRL__RAM2_CLK_G__SET() sets CLK_EN_CTRL.RAM2_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.RAM2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.RAM2_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__RAM2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__RAM2_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__RAM2_CLK_G__GET() gets CLK_EN_CTRL.RAM2_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.RAM2_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__RAM2_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__RAM2_CLK_G__MODIFY() modifies CLK_EN_CTRL.RAM2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.RAM2_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__RAM2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__RAM2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__RAM2_CLK_G__EXTRACT() extracts CLK_EN_CTRL.RAM2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__RAM2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------------- CGU.CLK_EN_CTRL.RAM1_CLK_G ----------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.RAM1_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__RAM1_CLK_G__Pos                        2                                                                      /*!< Right-most bit position of ram1_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__RAM1_CLK_G__Msk                        (0x00000001UL << CGU_CLK_EN_CTRL__RAM1_CLK_G__Pos)                     /*!< Mask for ram1_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__RAM1_CLK_G__Shift(v)                   (((v) << CGU_CLK_EN_CTRL__RAM1_CLK_G__Pos) & CGU_CLK_EN_CTRL__RAM1_CLK_G__Msk) /*!< Shift value 'v' into ram1_clk_g and mask 'v' to fit it into ram1_clk_g field */

/** CGU_CLK_EN_CTRL__RAM1_CLK_G__SET() sets CLK_EN_CTRL.RAM1_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.RAM1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.RAM1_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__RAM1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__RAM1_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__RAM1_CLK_G__GET() gets CLK_EN_CTRL.RAM1_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.RAM1_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__RAM1_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__RAM1_CLK_G__MODIFY() modifies CLK_EN_CTRL.RAM1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.RAM1_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__RAM1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__RAM1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__RAM1_CLK_G__EXTRACT() extracts CLK_EN_CTRL.RAM1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__RAM1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------------- CGU.CLK_EN_CTRL.ROM_CLK_G ----------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.ROM_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__ROM_CLK_G__Pos                         1                                                                      /*!< Right-most bit position of rom_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__ROM_CLK_G__Msk                         (0x00000001UL << CGU_CLK_EN_CTRL__ROM_CLK_G__Pos)                      /*!< Mask for rom_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__ROM_CLK_G__Shift(v)                    (((v) << CGU_CLK_EN_CTRL__ROM_CLK_G__Pos) & CGU_CLK_EN_CTRL__ROM_CLK_G__Msk) /*!< Shift value 'v' into rom_clk_g and mask 'v' to fit it into rom_clk_g field */

/** CGU_CLK_EN_CTRL__ROM_CLK_G__SET() sets CLK_EN_CTRL.ROM_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.ROM_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.ROM_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__ROM_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__ROM_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__ROM_CLK_G__GET() gets CLK_EN_CTRL.ROM_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.ROM_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__ROM_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__ROM_CLK_G__MODIFY() modifies CLK_EN_CTRL.ROM_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.ROM_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__ROM_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__ROM_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__ROM_CLK_G__EXTRACT() extracts CLK_EN_CTRL.ROM_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__ROM_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------------- CGU.CLK_EN_CTRL.HOSC_CLK_G ----------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL.HOSC_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL__HOSC_CLK_G__Pos                        0                                                                      /*!< Right-most bit position of hosc_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__HOSC_CLK_G__Msk                        (0x00000001UL << CGU_CLK_EN_CTRL__HOSC_CLK_G__Pos)                     /*!< Mask for hosc_clk_g in CGU.CLK_EN_CTRL */
#define CGU_CLK_EN_CTRL__HOSC_CLK_G__Shift(v)                   (((v) << CGU_CLK_EN_CTRL__HOSC_CLK_G__Pos) & CGU_CLK_EN_CTRL__HOSC_CLK_G__Msk) /*!< Shift value 'v' into hosc_clk_g and mask 'v' to fit it into hosc_clk_g field */

/** CGU_CLK_EN_CTRL__HOSC_CLK_G__SET() sets CLK_EN_CTRL.HOSC_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL.HOSC_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL.HOSC_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL__HOSC_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & ~CGU_CLK_EN_CTRL__HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__HOSC_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_EN_CTRL__SET(reg);
}

/** CGU_CLK_EN_CTRL__HOSC_CLK_G__GET() gets CLK_EN_CTRL.HOSC_CLK_G's current value.
 *
 * When reading from CLK_EN_CTRL.HOSC_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_EN_CTRL.HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__HOSC_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_EN_CTRL__GET();
    reg = (reg & CGU_CLK_EN_CTRL__HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_EN_CTRL__HOSC_CLK_G__MODIFY() modifies CLK_EN_CTRL.HOSC_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @param bf_value new value for CLK_EN_CTRL.HOSC_CLK_G
 * @return new value of CGU.CLK_EN_CTRL
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__HOSC_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL__HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL__HOSC_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL__HOSC_CLK_G__EXTRACT() extracts CLK_EN_CTRL.HOSC_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL
 * @return current value of CLK_EN_CTRL.HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL__HOSC_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL__HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL__HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                     CLK_SLEEP_MSK_CNFG member of CGU_t                     */
/* -------------------------------------------------------------------------- */

/** __CGU_CLK_SLEEP_MSK_CNFG__ADDRESS returns the address of member CLK_SLEEP_MSK_CNFG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t* __CGU_CLK_SLEEP_MSK_CNFG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CLK_SLEEP_MSK_CNFG)));
}

/** CGU_CLK_SLEEP_MSK_CNFG__SET() sets CLK_SLEEP_MSK_CNFG to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG, this is mandatory to use.
 *
 * @param value new value for CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SET(uint32_t value)
{
    HAL_SET32(__CGU_CLK_SLEEP_MSK_CNFG__ADDRESS(), value);
}

/** CGU_CLK_SLEEP_MSK_CNFG__GET() gets CLK_SLEEP_MSK_CNFG's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG, this is mandatory to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__GET(void)
{
    return HAL_GET32(__CGU_CLK_SLEEP_MSK_CNFG__ADDRESS());
}

/* ----------------- CGU.CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Pos             22                                                                     /*!< Right-most bit position of se_gpio1_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Msk             (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Pos)          /*!< Mask for se_gpio1_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Shift(v)        (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Msk) /*!< Shift value 'v' into se_gpio1_clk_g and mask 'v' to fit it into se_gpio1_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Pos             21                                                                     /*!< Right-most bit position of se_gpio0_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Msk             (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Pos)          /*!< Mask for se_gpio0_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Shift(v)        (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Msk) /*!< Shift value 'v' into se_gpio0_clk_g and mask 'v' to fit it into se_gpio0_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Pos               20                                                                     /*!< Right-most bit position of se_wdt_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Msk               (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Pos)            /*!< Mask for se_wdt_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Shift(v)          (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Msk) /*!< Shift value 'v' into se_wdt_clk_g and mask 'v' to fit it into se_wdt_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Pos           19                                                                     /*!< Right-most bit position of se_dtimer3_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Msk           (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Pos)        /*!< Mask for se_dtimer3_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Shift(v)      (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Msk) /*!< Shift value 'v' into se_dtimer3_clk_g and mask 'v' to fit it into se_dtimer3_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Pos           18                                                                     /*!< Right-most bit position of se_dtimer2_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Msk           (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Pos)        /*!< Mask for se_dtimer2_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Shift(v)      (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Msk) /*!< Shift value 'v' into se_dtimer2_clk_g and mask 'v' to fit it into se_dtimer2_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Pos           17                                                                     /*!< Right-most bit position of se_dtimer1_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Msk           (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Pos)        /*!< Mask for se_dtimer1_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Shift(v)      (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Msk) /*!< Shift value 'v' into se_dtimer1_clk_g and mask 'v' to fit it into se_dtimer1_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Pos      16                                                                     /*!< Right-most bit position of se_bif_per_uart_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Msk      (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Pos)   /*!< Mask for se_bif_per_uart_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_uart_clk_g and mask 'v' to fit it into se_bif_per_uart_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Pos       15                                                                     /*!< Right-most bit position of se_bif_per_i2c_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Pos)    /*!< Mask for se_bif_per_i2c_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_i2c_clk_g and mask 'v' to fit it into se_bif_per_i2c_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Pos       14                                                                     /*!< Right-most bit position of se_bif_per_ssp_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Pos)    /*!< Mask for se_bif_per_ssp_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_ssp_clk_g and mask 'v' to fit it into se_bif_per_ssp_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G ------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Pos     13                                                                     /*!< Right-most bit position of se_bif_per_pmbus_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Msk     (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Pos)  /*!< Mask for se_bif_per_pmbus_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_pmbus_clk_g and mask 'v' to fit it into se_bif_per_pmbus_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Pos      12                                                                     /*!< Right-most bit position of se_bif_per_svid_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Msk      (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Pos)   /*!< Mask for se_bif_per_svid_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_svid_clk_g and mask 'v' to fit it into se_bif_per_svid_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Pos           11                                                                     /*!< Right-most bit position of se_bif_reg_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Msk           (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Pos)        /*!< Mask for se_bif_reg_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Shift(v)      (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Msk) /*!< Shift value 'v' into se_bif_reg_clk_g and mask 'v' to fit it into se_bif_reg_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Pos          10                                                                     /*!< Right-most bit position of se_cnfg_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Msk          (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Pos)       /*!< Mask for se_cnfg_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Shift(v)     (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Msk) /*!< Shift value 'v' into se_cnfg_dma_clk_g and mask 'v' to fit it into se_cnfg_dma_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Pos       6                                                                      /*!< Right-most bit position of se_cnfg_otp1_w_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Pos)    /*!< Mask for se_cnfg_otp1_w_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Msk) /*!< Shift value 'v' into se_cnfg_otp1_w_clk_g and mask 'v' to fit it into se_cnfg_otp1_w_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_CNFG_OTP1_W_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Pos               5                                                                      /*!< Right-most bit position of se_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Msk               (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Pos)            /*!< Mask for se_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Shift(v)          (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Msk) /*!< Shift value 'v' into se_dma_clk_g and mask 'v' to fit it into se_dma_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Pos              4                                                                      /*!< Right-most bit position of se_amba_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Msk              (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Pos)           /*!< Mask for se_amba_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Shift(v)         (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Msk) /*!< Shift value 'v' into se_amba_clk_g and mask 'v' to fit it into se_amba_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Pos              3                                                                      /*!< Right-most bit position of se_ram2_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Msk              (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Pos)           /*!< Mask for se_ram2_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Shift(v)         (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Msk) /*!< Shift value 'v' into se_ram2_clk_g and mask 'v' to fit it into se_ram2_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Pos              2                                                                      /*!< Right-most bit position of se_ram1_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Msk              (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Pos)           /*!< Mask for se_ram1_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Shift(v)         (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Msk) /*!< Shift value 'v' into se_ram1_clk_g and mask 'v' to fit it into se_ram1_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Pos               1                                                                      /*!< Right-most bit position of se_rom_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Msk               (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Pos)            /*!< Mask for se_rom_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Shift(v)          (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Msk) /*!< Shift value 'v' into se_rom_clk_g and mask 'v' to fit it into se_rom_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------ CGU.CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep if  CrossRefz  clock gating control has been enabled

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Pos              0                                                                      /*!< Right-most bit position of se_hosc_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Msk              (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Pos)           /*!< Mask for se_hosc_clk_g in CGU.CLK_SLEEP_MSK_CNFG */
#define CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Shift(v)         (((v) << CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Msk) /*!< Shift value 'v' into se_hosc_clk_g and mask 'v' to fit it into se_hosc_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__GET() gets CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G's current value.
 *
 * When reading from CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG
 * @return current value of CLK_SLEEP_MSK_CNFG.SE_HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG__SE_HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  CLK_DEEP_SLEEP_MSK_CNFG member of CGU_t                  */
/* -------------------------------------------------------------------------- */

/** __CGU_CLK_DEEP_SLEEP_MSK_CNFG__ADDRESS returns the address of member CLK_DEEP_SLEEP_MSK_CNFG.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t* __CGU_CLK_DEEP_SLEEP_MSK_CNFG__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CLK_DEEP_SLEEP_MSK_CNFG)));
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET() sets CLK_DEEP_SLEEP_MSK_CNFG to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG, this is mandatory to use.
 *
 * @param value new value for CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(uint32_t value)
{
    HAL_SET32(__CGU_CLK_DEEP_SLEEP_MSK_CNFG__ADDRESS(), value);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET() gets CLK_DEEP_SLEEP_MSK_CNFG's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG, this is mandatory to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET(void)
{
    return HAL_GET32(__CGU_CLK_DEEP_SLEEP_MSK_CNFG__ADDRESS());
}

/* -------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G -------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Pos       22                                                                     /*!< Right-most bit position of dse_gpio1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Msk       (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Pos)    /*!< Mask for dse_gpio1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Shift(v)  (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Msk) /*!< Shift value 'v' into dse_gpio1_clk_g and mask 'v' to fit it into dse_gpio1_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G -------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Pos       21                                                                     /*!< Right-most bit position of dse_gpio0_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Msk       (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Pos)    /*!< Mask for dse_gpio0_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Shift(v)  (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Msk) /*!< Shift value 'v' into dse_gpio0_clk_g and mask 'v' to fit it into dse_gpio0_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G --------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Pos         20                                                                     /*!< Right-most bit position of dse_wdt_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Msk         (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Pos)      /*!< Mask for dse_wdt_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Shift(v)    (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Msk) /*!< Shift value 'v' into dse_wdt_clk_g and mask 'v' to fit it into dse_wdt_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Pos     19                                                                     /*!< Right-most bit position of dse_dtimer3_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Msk     (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Pos)  /*!< Mask for dse_dtimer3_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Msk) /*!< Shift value 'v' into dse_dtimer3_clk_g and mask 'v' to fit it into dse_dtimer3_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Pos     18                                                                     /*!< Right-most bit position of dse_dtimer2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Msk     (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Pos)  /*!< Mask for dse_dtimer2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Msk) /*!< Shift value 'v' into dse_dtimer2_clk_g and mask 'v' to fit it into dse_dtimer2_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Pos     17                                                                     /*!< Right-most bit position of dse_dtimer1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Msk     (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Pos)  /*!< Mask for dse_dtimer1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Msk) /*!< Shift value 'v' into dse_dtimer1_clk_g and mask 'v' to fit it into dse_dtimer1_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Pos 16                                                                     /*!< Right-most bit position of dse_bif_per_uart_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Pos) /*!< Mask for dse_bif_per_uart_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_uart_clk_g and mask 'v' to fit it into dse_bif_per_uart_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Pos 15                                                                     /*!< Right-most bit position of dse_bif_per_i2c_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Pos) /*!< Mask for dse_bif_per_i2c_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_i2c_clk_g and mask 'v' to fit it into dse_bif_per_i2c_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Pos 14                                                                     /*!< Right-most bit position of dse_bif_per_ssp_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Pos) /*!< Mask for dse_bif_per_ssp_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_ssp_clk_g and mask 'v' to fit it into dse_bif_per_ssp_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G ---------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Pos 13                                                                     /*!< Right-most bit position of dse_bif_per_pmbus_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Pos) /*!< Mask for dse_bif_per_pmbus_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_pmbus_clk_g and mask 'v' to fit it into dse_bif_per_pmbus_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Pos 12                                                                     /*!< Right-most bit position of dse_bif_per_svid_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Pos) /*!< Mask for dse_bif_per_svid_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_svid_clk_g and mask 'v' to fit it into dse_bif_per_svid_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Pos     11                                                                     /*!< Right-most bit position of dse_bif_reg_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Msk     (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Pos)  /*!< Mask for dse_bif_reg_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_reg_clk_g and mask 'v' to fit it into dse_bif_reg_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Pos    10                                                                     /*!< Right-most bit position of dse_cnfg_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Msk    (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Pos) /*!< Mask for dse_cnfg_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Msk) /*!< Shift value 'v' into dse_cnfg_dma_clk_g and mask 'v' to fit it into dse_cnfg_dma_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Pos 9                                                                      /*!< Right-most bit position of dse_cnfg_otp2_w_clk2_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Pos) /*!< Mask for dse_cnfg_otp2_w_clk2_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Msk) /*!< Shift value 'v' into dse_cnfg_otp2_w_clk2_g and mask 'v' to fit it into dse_cnfg_otp2_w_clk2_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK2_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK2_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Pos 8                                                                      /*!< Right-most bit position of dse_cnfg_otp2_w_clk1_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Pos) /*!< Mask for dse_cnfg_otp2_w_clk1_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Msk) /*!< Shift value 'v' into dse_cnfg_otp2_w_clk1_g and mask 'v' to fit it into dse_cnfg_otp2_w_clk1_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP2_W_CLK1_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP2_W_CLK1_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Pos 7                                                                      /*!< Right-most bit position of dse_cnfg_otp1_w_clk2_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Pos) /*!< Mask for dse_cnfg_otp1_w_clk2_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Msk) /*!< Shift value 'v' into dse_cnfg_otp1_w_clk2_g and mask 'v' to fit it into dse_cnfg_otp1_w_clk2_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK2_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK2_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Pos 6                                                                      /*!< Right-most bit position of dse_cnfg_otp1_w_clk1_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Pos) /*!< Mask for dse_cnfg_otp1_w_clk1_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Msk) /*!< Shift value 'v' into dse_cnfg_otp1_w_clk1_g and mask 'v' to fit it into dse_cnfg_otp1_w_clk1_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_CNFG_OTP1_W_CLK1_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_CNFG_OTP1_W_CLK1_G__Pos);
    return (uint32_t)reg;
}

/* --------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G --------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Pos         5                                                                      /*!< Right-most bit position of dse_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Msk         (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Pos)      /*!< Mask for dse_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Shift(v)    (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Msk) /*!< Shift value 'v' into dse_dma_clk_g and mask 'v' to fit it into dse_dma_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G --------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Pos        4                                                                      /*!< Right-most bit position of dse_amba_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Msk        (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Pos)     /*!< Mask for dse_amba_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Shift(v)   (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Msk) /*!< Shift value 'v' into dse_amba_clk_g and mask 'v' to fit it into dse_amba_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G --------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Pos        3                                                                      /*!< Right-most bit position of dse_ram2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Msk        (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Pos)     /*!< Mask for dse_ram2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Shift(v)   (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Msk) /*!< Shift value 'v' into dse_ram2_clk_g and mask 'v' to fit it into dse_ram2_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G --------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Pos        2                                                                      /*!< Right-most bit position of dse_ram1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Msk        (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Pos)     /*!< Mask for dse_ram1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Shift(v)   (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Msk) /*!< Shift value 'v' into dse_ram1_clk_g and mask 'v' to fit it into dse_ram1_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G --------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Pos         1                                                                      /*!< Right-most bit position of dse_rom_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Msk         (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Pos)      /*!< Mask for dse_rom_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Shift(v)    (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Msk) /*!< Shift value 'v' into dse_rom_clk_g and mask 'v' to fit it into dse_rom_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G --------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep if  CrossRefz  clock gating control has been enabled

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Pos        0                                                                      /*!< Right-most bit position of dse_hosc_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Msk        (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Pos)     /*!< Mask for dse_hosc_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Shift(v)   (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Msk) /*!< Shift value 'v' into dse_hosc_clk_g and mask 'v' to fit it into dse_hosc_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Shift((uint32_t)bf_value)));
    CGU_CLK_DEEP_SLEEP_MSK_CNFG__SET(reg);
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__GET() gets CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G's current value.
 *
 * When reading from CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G, this is recommended to use.
 *
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__GET(void)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG__GET();
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG.DSE_HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG__DSE_HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  HOSC_SW_CLK_GATING_CTRL member of CGU_t                  */
/* -------------------------------------------------------------------------- */

/** __CGU_HOSC_SW_CLK_GATING_CTRL__ADDRESS returns the address of member HOSC_SW_CLK_GATING_CTRL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of HOSC_SW_CLK_GATING_CTRL
 */
__CGU_INLINE uint32_t* __CGU_HOSC_SW_CLK_GATING_CTRL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, HOSC_SW_CLK_GATING_CTRL)));
}

/** CGU_HOSC_SW_CLK_GATING_CTRL__SET() sets HOSC_SW_CLK_GATING_CTRL to given value.
 *
 * When writing to HOSC_SW_CLK_GATING_CTRL, this is mandatory to use.
 *
 * @param value new value for HOSC_SW_CLK_GATING_CTRL
 */
__CGU_INLINE void CGU_HOSC_SW_CLK_GATING_CTRL__SET(uint32_t value)
{
    HAL_SET32(__CGU_HOSC_SW_CLK_GATING_CTRL__ADDRESS(), value);
}

/** CGU_HOSC_SW_CLK_GATING_CTRL__GET() gets HOSC_SW_CLK_GATING_CTRL's current value.
 *
 * When reading from HOSC_SW_CLK_GATING_CTRL, this is mandatory to use.
 *
 * @return current value of HOSC_SW_CLK_GATING_CTRL
 */
__CGU_INLINE uint32_t CGU_HOSC_SW_CLK_GATING_CTRL__GET(void)
{
    return HAL_GET32(__CGU_HOSC_SW_CLK_GATING_CTRL__ADDRESS());
}

/* --------------- CGU.HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY --------------- */

/**
<pre>
  CGU.HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY:

    1: Clock  CrossRefz



    can be gated

</pre> */

#define CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Pos        0                                                                      /*!< Right-most bit position of kill_me_softly in CGU.HOSC_SW_CLK_GATING_CTRL */
#define CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Msk        (0x00000001UL << CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Pos)     /*!< Mask for kill_me_softly in CGU.HOSC_SW_CLK_GATING_CTRL */
#define CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Shift(v)   (((v) << CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Pos) & CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Msk) /*!< Shift value 'v' into kill_me_softly and mask 'v' to fit it into kill_me_softly field */

/** CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__SET() sets HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY to given value.
 *
 * When writing to HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY, this is recommended to use.
 *
 * @param bf_value new value for HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY
 */
__CGU_INLINE void CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_HOSC_SW_CLK_GATING_CTRL__GET();
    reg = (reg & ~CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Msk);
    reg = (reg | (CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Shift((uint32_t)bf_value)));
    CGU_HOSC_SW_CLK_GATING_CTRL__SET(reg);
}

/** CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__GET() gets HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY's current value.
 *
 * When reading from HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY, this is recommended to use.
 *
 * @return current value of HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY
 */
__CGU_INLINE uint32_t CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__GET(void)
{
    uint32_t reg = CGU_HOSC_SW_CLK_GATING_CTRL__GET();
    reg = (reg & CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Msk);
    reg = (reg >> CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Pos);
    return (uint32_t)reg;
}

/** CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__MODIFY() modifies HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY.
 *
 * This is recommended to use when setting more than one bitfield of CGU.HOSC_SW_CLK_GATING_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.HOSC_SW_CLK_GATING_CTRL
 * @param bf_value new value for HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY
 * @return new value of CGU.HOSC_SW_CLK_GATING_CTRL
 */
__CGU_INLINE uint32_t CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Msk);
    reg = (reg | (CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__EXTRACT() extracts HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.HOSC_SW_CLK_GATING_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.HOSC_SW_CLK_GATING_CTRL
 * @return current value of HOSC_SW_CLK_GATING_CTRL.KILL_ME_SOFTLY
 */
__CGU_INLINE uint32_t CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Msk);
    reg = (reg >> CGU_HOSC_SW_CLK_GATING_CTRL__KILL_ME_SOFTLY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                  HOSC_HW_CLK_GATING_CTRL member of CGU_t                  */
/* -------------------------------------------------------------------------- */

/** __CGU_HOSC_HW_CLK_GATING_CTRL__ADDRESS returns the address of member HOSC_HW_CLK_GATING_CTRL.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of HOSC_HW_CLK_GATING_CTRL
 */
__CGU_INLINE uint32_t* __CGU_HOSC_HW_CLK_GATING_CTRL__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, HOSC_HW_CLK_GATING_CTRL)));
}

/** CGU_HOSC_HW_CLK_GATING_CTRL__SET() sets HOSC_HW_CLK_GATING_CTRL to given value.
 *
 * When writing to HOSC_HW_CLK_GATING_CTRL, this is mandatory to use.
 *
 * @param value new value for HOSC_HW_CLK_GATING_CTRL
 */
__CGU_INLINE void CGU_HOSC_HW_CLK_GATING_CTRL__SET(uint32_t value)
{
    HAL_SET32(__CGU_HOSC_HW_CLK_GATING_CTRL__ADDRESS(), value);
}

/** CGU_HOSC_HW_CLK_GATING_CTRL__GET() gets HOSC_HW_CLK_GATING_CTRL's current value.
 *
 * When reading from HOSC_HW_CLK_GATING_CTRL, this is mandatory to use.
 *
 * @return current value of HOSC_HW_CLK_GATING_CTRL
 */
__CGU_INLINE uint32_t CGU_HOSC_HW_CLK_GATING_CTRL__GET(void)
{
    return HAL_GET32(__CGU_HOSC_HW_CLK_GATING_CTRL__ADDRESS());
}

/* --------------- CGU.HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY --------------- */

/**
<pre>
  CGU.HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY:

    1: Clock  CrossRefz



    can be gated

</pre> */

#define CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Pos        0                                                                      /*!< Right-most bit position of kill_me_hardly in CGU.HOSC_HW_CLK_GATING_CTRL */
#define CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Msk        (0x00000001UL << CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Pos)     /*!< Mask for kill_me_hardly in CGU.HOSC_HW_CLK_GATING_CTRL */
#define CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Shift(v)   (((v) << CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Pos) & CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Msk) /*!< Shift value 'v' into kill_me_hardly and mask 'v' to fit it into kill_me_hardly field */

/** CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__SET() sets HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY to given value.
 *
 * When writing to HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY, this is recommended to use.
 *
 * @param bf_value new value for HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY
 */
__CGU_INLINE void CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_HOSC_HW_CLK_GATING_CTRL__GET();
    reg = (reg & ~CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Msk);
    reg = (reg | (CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Shift((uint32_t)bf_value)));
    CGU_HOSC_HW_CLK_GATING_CTRL__SET(reg);
}

/** CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__GET() gets HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY's current value.
 *
 * When reading from HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY, this is recommended to use.
 *
 * @return current value of HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY
 */
__CGU_INLINE uint32_t CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__GET(void)
{
    uint32_t reg = CGU_HOSC_HW_CLK_GATING_CTRL__GET();
    reg = (reg & CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Msk);
    reg = (reg >> CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Pos);
    return (uint32_t)reg;
}

/** CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__MODIFY() modifies HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY.
 *
 * This is recommended to use when setting more than one bitfield of CGU.HOSC_HW_CLK_GATING_CTRL.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.HOSC_HW_CLK_GATING_CTRL
 * @param bf_value new value for HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY
 * @return new value of CGU.HOSC_HW_CLK_GATING_CTRL
 */
__CGU_INLINE uint32_t CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Msk);
    reg = (reg | (CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__EXTRACT() extracts HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.HOSC_HW_CLK_GATING_CTRL.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.HOSC_HW_CLK_GATING_CTRL
 * @return current value of HOSC_HW_CLK_GATING_CTRL.KILL_ME_HARDLY
 */
__CGU_INLINE uint32_t CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Msk);
    reg = (reg >> CGU_HOSC_HW_CLK_GATING_CTRL__KILL_ME_HARDLY__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                          SPARE_FF member of CGU_t                          */
/* -------------------------------------------------------------------------- */

/** __CGU_SPARE_FF__ADDRESS returns the address of member SPARE_FF.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of SPARE_FF
 */
__CGU_INLINE uint32_t* __CGU_SPARE_FF__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, SPARE_FF)));
}

/** CGU_SPARE_FF__SET() sets SPARE_FF to given value.
 *
 * When writing to SPARE_FF, this is mandatory to use.
 *
 * @param value new value for SPARE_FF
 */
__CGU_INLINE void CGU_SPARE_FF__SET(uint32_t value)
{
    HAL_SET32(__CGU_SPARE_FF__ADDRESS(), value);
}

/** CGU_SPARE_FF__GET() gets SPARE_FF's current value.
 *
 * When reading from SPARE_FF, this is mandatory to use.
 *
 * @return current value of SPARE_FF
 */
__CGU_INLINE uint32_t CGU_SPARE_FF__GET(void)
{
    return HAL_GET32(__CGU_SPARE_FF__ADDRESS());
}

/* ------------------------- CGU.SPARE_FF.SPARE_FF ------------------------- */

/**
<pre>
  CGU.SPARE_FF.SPARE_FF:

    Spare Register

</pre> */

#define CGU_SPARE_FF__SPARE_FF__Pos                             0                                                                      /*!< Right-most bit position of SPARE_FF in CGU.SPARE_FF */
#define CGU_SPARE_FF__SPARE_FF__Msk                             (0xFFFFFFFFUL << CGU_SPARE_FF__SPARE_FF__Pos)                          /*!< Mask for SPARE_FF in CGU.SPARE_FF */
#define CGU_SPARE_FF__SPARE_FF__Shift(v)                        (((v) << CGU_SPARE_FF__SPARE_FF__Pos) & CGU_SPARE_FF__SPARE_FF__Msk)   /*!< Shift value 'v' into SPARE_FF and mask 'v' to fit it into SPARE_FF field */

/** CGU_SPARE_FF__SPARE_FF__SET() sets SPARE_FF.SPARE_FF to given value.
 *
 * When writing to SPARE_FF.SPARE_FF, this is recommended to use.
 *
 * @param bf_value new value for SPARE_FF.SPARE_FF
 */
__CGU_INLINE void CGU_SPARE_FF__SPARE_FF__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_SPARE_FF__GET();
    reg = (reg & ~CGU_SPARE_FF__SPARE_FF__Msk);
    reg = (reg | (CGU_SPARE_FF__SPARE_FF__Shift((uint32_t)bf_value)));
    CGU_SPARE_FF__SET(reg);
}

/** CGU_SPARE_FF__SPARE_FF__GET() gets SPARE_FF.SPARE_FF's current value.
 *
 * When reading from SPARE_FF.SPARE_FF, this is recommended to use.
 *
 * @return current value of SPARE_FF.SPARE_FF
 */
__CGU_INLINE uint32_t CGU_SPARE_FF__SPARE_FF__GET(void)
{
    uint32_t reg = CGU_SPARE_FF__GET();
    reg = (reg & CGU_SPARE_FF__SPARE_FF__Msk);
    reg = (reg >> CGU_SPARE_FF__SPARE_FF__Pos);
    return (uint32_t)reg;
}

/** CGU_SPARE_FF__SPARE_FF__MODIFY() modifies SPARE_FF.SPARE_FF.
 *
 * This is recommended to use when setting more than one bitfield of CGU.SPARE_FF.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.SPARE_FF
 * @param bf_value new value for SPARE_FF.SPARE_FF
 * @return new value of CGU.SPARE_FF
 */
__CGU_INLINE uint32_t CGU_SPARE_FF__SPARE_FF__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_SPARE_FF__SPARE_FF__Msk);
    reg = (reg | (CGU_SPARE_FF__SPARE_FF__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_SPARE_FF__SPARE_FF__EXTRACT() extracts SPARE_FF.SPARE_FF.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.SPARE_FF.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.SPARE_FF
 * @return current value of SPARE_FF.SPARE_FF
 */
__CGU_INLINE uint32_t CGU_SPARE_FF__SPARE_FF__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_SPARE_FF__SPARE_FF__Msk);
    reg = (reg >> CGU_SPARE_FF__SPARE_FF__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      CLK_EN_CTRL_SET member of CGU_t                      */
/* -------------------------------------------------------------------------- */

/** __CGU_CLK_EN_CTRL_SET__ADDRESS returns the address of member CLK_EN_CTRL_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t* __CGU_CLK_EN_CTRL_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CLK_EN_CTRL_SET)));
}

/** CGU_CLK_EN_CTRL_SET__SET() sets CLK_EN_CTRL_SET to given value.
 *
 * When writing to CLK_EN_CTRL_SET, this is mandatory to use.
 *
 * @param value new value for CLK_EN_CTRL_SET
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__SET(uint32_t value)
{
    HAL_SET32(__CGU_CLK_EN_CTRL_SET__ADDRESS(), value);
}


/* ------------------ CGU.CLK_EN_CTRL_SET.OTP_KERNEL_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.OTP_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Pos              27                                                                     /*!< Right-most bit position of otp_kernel_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Msk              (0x00000001UL << CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Pos)           /*!< Mask for otp_kernel_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Shift(v)         (((v) << CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into otp_kernel_clk_g and mask 'v' to fit it into otp_kernel_clk_g field */

/** CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__SET() sets CLK_EN_CTRL_SET.OTP_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.OTP_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.OTP_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.OTP_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.OTP_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.OTP_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.OTP_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__OTP_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_SET.PMBUS_KERNEL_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.PMBUS_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Pos            26                                                                     /*!< Right-most bit position of pmbus_kernel_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Msk            (0x00000001UL << CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Pos)         /*!< Mask for pmbus_kernel_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Shift(v)       (((v) << CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into pmbus_kernel_clk_g and mask 'v' to fit it into pmbus_kernel_clk_g field */

/** CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__SET() sets CLK_EN_CTRL_SET.PMBUS_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.PMBUS_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.PMBUS_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.PMBUS_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.PMBUS_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.PMBUS_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.PMBUS_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__PMBUS_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_EN_CTRL_SET.DTIMER3_KERNEL_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.DTIMER3_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Pos          25                                                                     /*!< Right-most bit position of dtimer3_kernel_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Msk          (0x00000001UL << CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Pos)       /*!< Mask for dtimer3_kernel_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Shift(v)     (((v) << CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into dtimer3_kernel_clk_g and mask 'v' to fit it into dtimer3_kernel_clk_g field */

/** CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__SET() sets CLK_EN_CTRL_SET.DTIMER3_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.DTIMER3_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER3_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.DTIMER3_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER3_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.DTIMER3_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.DTIMER3_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__DTIMER3_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_EN_CTRL_SET.DTIMER2_KERNEL_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.DTIMER2_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Pos          24                                                                     /*!< Right-most bit position of dtimer2_kernel_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Msk          (0x00000001UL << CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Pos)       /*!< Mask for dtimer2_kernel_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Shift(v)     (((v) << CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into dtimer2_kernel_clk_g and mask 'v' to fit it into dtimer2_kernel_clk_g field */

/** CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__SET() sets CLK_EN_CTRL_SET.DTIMER2_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.DTIMER2_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER2_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.DTIMER2_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER2_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.DTIMER2_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.DTIMER2_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__DTIMER2_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_EN_CTRL_SET.DTIMER1_KERNEL_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.DTIMER1_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Pos          23                                                                     /*!< Right-most bit position of dtimer1_kernel_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Msk          (0x00000001UL << CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Pos)       /*!< Mask for dtimer1_kernel_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Shift(v)     (((v) << CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into dtimer1_kernel_clk_g and mask 'v' to fit it into dtimer1_kernel_clk_g field */

/** CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__SET() sets CLK_EN_CTRL_SET.DTIMER1_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.DTIMER1_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER1_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.DTIMER1_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER1_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.DTIMER1_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.DTIMER1_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__DTIMER1_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------- CGU.CLK_EN_CTRL_SET.GPIO1_CLK_G -------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.GPIO1_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Pos                   22                                                                     /*!< Right-most bit position of gpio1_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Msk                   (0x00000001UL << CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Pos)                /*!< Mask for gpio1_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Shift(v)              (((v) << CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Msk) /*!< Shift value 'v' into gpio1_clk_g and mask 'v' to fit it into gpio1_clk_g field */

/** CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__SET() sets CLK_EN_CTRL_SET.GPIO1_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.GPIO1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.GPIO1_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.GPIO1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.GPIO1_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.GPIO1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------- CGU.CLK_EN_CTRL_SET.GPIO0_CLK_G -------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.GPIO0_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Pos                   21                                                                     /*!< Right-most bit position of gpio0_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Msk                   (0x00000001UL << CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Pos)                /*!< Mask for gpio0_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Shift(v)              (((v) << CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Msk) /*!< Shift value 'v' into gpio0_clk_g and mask 'v' to fit it into gpio0_clk_g field */

/** CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__SET() sets CLK_EN_CTRL_SET.GPIO0_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.GPIO0_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.GPIO0_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.GPIO0_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.GPIO0_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.GPIO0_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_SET.WDT_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.WDT_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Pos                     20                                                                     /*!< Right-most bit position of wdt_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Msk                     (0x00000001UL << CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Pos)                  /*!< Mask for wdt_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Shift(v)                (((v) << CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Msk) /*!< Shift value 'v' into wdt_clk_g and mask 'v' to fit it into wdt_clk_g field */

/** CGU_CLK_EN_CTRL_SET__WDT_CLK_G__SET() sets CLK_EN_CTRL_SET.WDT_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.WDT_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.WDT_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__WDT_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__WDT_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.WDT_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.WDT_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__WDT_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__WDT_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.WDT_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__WDT_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL_SET.DTIMER3_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.DTIMER3_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Pos                 19                                                                     /*!< Right-most bit position of dtimer3_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Pos)              /*!< Mask for dtimer3_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Msk) /*!< Shift value 'v' into dtimer3_clk_g and mask 'v' to fit it into dtimer3_clk_g field */

/** CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__SET() sets CLK_EN_CTRL_SET.DTIMER3_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.DTIMER3_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER3_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.DTIMER3_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER3_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.DTIMER3_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL_SET.DTIMER2_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.DTIMER2_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Pos                 18                                                                     /*!< Right-most bit position of dtimer2_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Pos)              /*!< Mask for dtimer2_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Msk) /*!< Shift value 'v' into dtimer2_clk_g and mask 'v' to fit it into dtimer2_clk_g field */

/** CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__SET() sets CLK_EN_CTRL_SET.DTIMER2_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.DTIMER2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER2_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.DTIMER2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER2_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.DTIMER2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL_SET.DTIMER1_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.DTIMER1_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Pos                 17                                                                     /*!< Right-most bit position of dtimer1_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Pos)              /*!< Mask for dtimer1_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Msk) /*!< Shift value 'v' into dtimer1_clk_g and mask 'v' to fit it into dtimer1_clk_g field */

/** CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__SET() sets CLK_EN_CTRL_SET.DTIMER1_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.DTIMER1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER1_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.DTIMER1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.DTIMER1_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.DTIMER1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_SET.BIF_PER_UART_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.BIF_PER_UART_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Pos            16                                                                     /*!< Right-most bit position of bif_per_uart_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Msk            (0x00000001UL << CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Pos)         /*!< Mask for bif_per_uart_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Shift(v)       (((v) << CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Msk) /*!< Shift value 'v' into bif_per_uart_clk_g and mask 'v' to fit it into bif_per_uart_clk_g field */

/** CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__SET() sets CLK_EN_CTRL_SET.BIF_PER_UART_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_PER_UART_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_PER_UART_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_SET.BIF_PER_I2C_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.BIF_PER_I2C_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Pos             15                                                                     /*!< Right-most bit position of bif_per_i2c_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Msk             (0x00000001UL << CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Pos)          /*!< Mask for bif_per_i2c_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Shift(v)        (((v) << CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Msk) /*!< Shift value 'v' into bif_per_i2c_clk_g and mask 'v' to fit it into bif_per_i2c_clk_g field */

/** CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__SET() sets CLK_EN_CTRL_SET.BIF_PER_I2C_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_PER_I2C_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_PER_I2C_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_SET.BIF_PER_SSP_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.BIF_PER_SSP_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Pos             14                                                                     /*!< Right-most bit position of bif_per_ssp_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Msk             (0x00000001UL << CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Pos)          /*!< Mask for bif_per_ssp_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Shift(v)        (((v) << CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Msk) /*!< Shift value 'v' into bif_per_ssp_clk_g and mask 'v' to fit it into bif_per_ssp_clk_g field */

/** CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__SET() sets CLK_EN_CTRL_SET.BIF_PER_SSP_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_PER_SSP_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_PER_SSP_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_EN_CTRL_SET.BIF_PER_PMBUS_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.BIF_PER_PMBUS_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Pos           13                                                                     /*!< Right-most bit position of bif_per_pmbus_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Msk           (0x00000001UL << CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Pos)        /*!< Mask for bif_per_pmbus_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Shift(v)      (((v) << CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Msk) /*!< Shift value 'v' into bif_per_pmbus_clk_g and mask 'v' to fit it into bif_per_pmbus_clk_g field */

/** CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__SET() sets CLK_EN_CTRL_SET.BIF_PER_PMBUS_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_PER_PMBUS_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_SET.BIF_PER_SVID_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.BIF_PER_SVID_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Pos            12                                                                     /*!< Right-most bit position of bif_per_svid_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Msk            (0x00000001UL << CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Pos)         /*!< Mask for bif_per_svid_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Shift(v)       (((v) << CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Msk) /*!< Shift value 'v' into bif_per_svid_clk_g and mask 'v' to fit it into bif_per_svid_clk_g field */

/** CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__SET() sets CLK_EN_CTRL_SET.BIF_PER_SVID_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_PER_SVID_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_PER_SVID_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL_SET.BIF_REG_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.BIF_REG_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Pos                 11                                                                     /*!< Right-most bit position of bif_reg_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Pos)              /*!< Mask for bif_reg_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Msk) /*!< Shift value 'v' into bif_reg_clk_g and mask 'v' to fit it into bif_reg_clk_g field */

/** CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__SET() sets CLK_EN_CTRL_SET.BIF_REG_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.BIF_REG_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_REG_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.BIF_REG_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.BIF_REG_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.BIF_REG_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL_SET.CNFG_DMA_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.CNFG_DMA_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Pos                10                                                                     /*!< Right-most bit position of cnfg_dma_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Msk                (0x00000001UL << CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Pos)             /*!< Mask for cnfg_dma_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Shift(v)           (((v) << CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Msk) /*!< Shift value 'v' into cnfg_dma_clk_g and mask 'v' to fit it into cnfg_dma_clk_g field */

/** CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__SET() sets CLK_EN_CTRL_SET.CNFG_DMA_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.CNFG_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.CNFG_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.CNFG_DMA_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.CNFG_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_SET.CNFG_OTP1_W_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.CNFG_OTP1_W_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Pos             6                                                                      /*!< Right-most bit position of cnfg_otp1_w_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Msk             (0x00000001UL << CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Pos)          /*!< Mask for cnfg_otp1_w_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Shift(v)        (((v) << CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Msk) /*!< Shift value 'v' into cnfg_otp1_w_clk_g and mask 'v' to fit it into cnfg_otp1_w_clk_g field */

/** CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__SET() sets CLK_EN_CTRL_SET.CNFG_OTP1_W_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.CNFG_OTP1_W_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.CNFG_OTP1_W_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__CNFG_OTP1_W_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_SET.DMA_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.DMA_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Pos                     5                                                                      /*!< Right-most bit position of dma_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Msk                     (0x00000001UL << CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Pos)                  /*!< Mask for dma_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Shift(v)                (((v) << CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Msk) /*!< Shift value 'v' into dma_clk_g and mask 'v' to fit it into dma_clk_g field */

/** CGU_CLK_EN_CTRL_SET__DMA_CLK_G__SET() sets CLK_EN_CTRL_SET.DMA_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__DMA_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.DMA_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__DMA_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_SET.AMBA_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.AMBA_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Pos                    4                                                                      /*!< Right-most bit position of amba_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Msk                    (0x00000001UL << CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Pos)                 /*!< Mask for amba_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Shift(v)               (((v) << CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Msk) /*!< Shift value 'v' into amba_clk_g and mask 'v' to fit it into amba_clk_g field */

/** CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__SET() sets CLK_EN_CTRL_SET.AMBA_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.AMBA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.AMBA_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.AMBA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.AMBA_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.AMBA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_SET.RAM2_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.RAM2_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Pos                    3                                                                      /*!< Right-most bit position of ram2_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Msk                    (0x00000001UL << CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Pos)                 /*!< Mask for ram2_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Shift(v)               (((v) << CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Msk) /*!< Shift value 'v' into ram2_clk_g and mask 'v' to fit it into ram2_clk_g field */

/** CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__SET() sets CLK_EN_CTRL_SET.RAM2_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.RAM2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.RAM2_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.RAM2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.RAM2_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.RAM2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_SET.RAM1_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.RAM1_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Pos                    2                                                                      /*!< Right-most bit position of ram1_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Msk                    (0x00000001UL << CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Pos)                 /*!< Mask for ram1_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Shift(v)               (((v) << CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Msk) /*!< Shift value 'v' into ram1_clk_g and mask 'v' to fit it into ram1_clk_g field */

/** CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__SET() sets CLK_EN_CTRL_SET.RAM1_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.RAM1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.RAM1_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.RAM1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.RAM1_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.RAM1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_SET.ROM_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.ROM_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Pos                     1                                                                      /*!< Right-most bit position of rom_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Msk                     (0x00000001UL << CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Pos)                  /*!< Mask for rom_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Shift(v)                (((v) << CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Msk) /*!< Shift value 'v' into rom_clk_g and mask 'v' to fit it into rom_clk_g field */

/** CGU_CLK_EN_CTRL_SET__ROM_CLK_G__SET() sets CLK_EN_CTRL_SET.ROM_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.ROM_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.ROM_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__ROM_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__ROM_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.ROM_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.ROM_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__ROM_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__ROM_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.ROM_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__ROM_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_SET.HOSC_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_SET.HOSC_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Pos                    0                                                                      /*!< Right-most bit position of hosc_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Msk                    (0x00000001UL << CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Pos)                 /*!< Mask for hosc_clk_g in CGU.CLK_EN_CTRL_SET */
#define CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Shift(v)               (((v) << CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Pos) & CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Msk) /*!< Shift value 'v' into hosc_clk_g and mask 'v' to fit it into hosc_clk_g field */

/** CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__SET() sets CLK_EN_CTRL_SET.HOSC_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_SET.HOSC_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_SET.HOSC_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_SET__SET(reg);
}


/** CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__MODIFY() modifies CLK_EN_CTRL_SET.HOSC_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @param bf_value new value for CLK_EN_CTRL_SET.HOSC_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_SET
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__EXTRACT() extracts CLK_EN_CTRL_SET.HOSC_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_SET
 * @return current value of CLK_EN_CTRL_SET.HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_SET__HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                      CLK_EN_CTRL_CLR member of CGU_t                      */
/* -------------------------------------------------------------------------- */

/** __CGU_CLK_EN_CTRL_CLR__ADDRESS returns the address of member CLK_EN_CTRL_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t* __CGU_CLK_EN_CTRL_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CLK_EN_CTRL_CLR)));
}

/** CGU_CLK_EN_CTRL_CLR__SET() sets CLK_EN_CTRL_CLR to given value.
 *
 * When writing to CLK_EN_CTRL_CLR, this is mandatory to use.
 *
 * @param value new value for CLK_EN_CTRL_CLR
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__SET(uint32_t value)
{
    HAL_SET32(__CGU_CLK_EN_CTRL_CLR__ADDRESS(), value);
}


/* ------------------ CGU.CLK_EN_CTRL_CLR.OTP_KERNEL_CLK_G ------------------ */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.OTP_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Pos              27                                                                     /*!< Right-most bit position of otp_kernel_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Msk              (0x00000001UL << CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Pos)           /*!< Mask for otp_kernel_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Shift(v)         (((v) << CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into otp_kernel_clk_g and mask 'v' to fit it into otp_kernel_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__SET() sets CLK_EN_CTRL_CLR.OTP_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.OTP_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.OTP_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.OTP_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.OTP_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.OTP_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.OTP_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__OTP_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_CLR.PMBUS_KERNEL_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.PMBUS_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Pos            26                                                                     /*!< Right-most bit position of pmbus_kernel_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Msk            (0x00000001UL << CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Pos)         /*!< Mask for pmbus_kernel_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Shift(v)       (((v) << CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into pmbus_kernel_clk_g and mask 'v' to fit it into pmbus_kernel_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__SET() sets CLK_EN_CTRL_CLR.PMBUS_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.PMBUS_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.PMBUS_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.PMBUS_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.PMBUS_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.PMBUS_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.PMBUS_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__PMBUS_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_EN_CTRL_CLR.DTIMER3_KERNEL_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.DTIMER3_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Pos          25                                                                     /*!< Right-most bit position of dtimer3_kernel_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Msk          (0x00000001UL << CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Pos)       /*!< Mask for dtimer3_kernel_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Shift(v)     (((v) << CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into dtimer3_kernel_clk_g and mask 'v' to fit it into dtimer3_kernel_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__SET() sets CLK_EN_CTRL_CLR.DTIMER3_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.DTIMER3_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER3_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.DTIMER3_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER3_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.DTIMER3_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.DTIMER3_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__DTIMER3_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_EN_CTRL_CLR.DTIMER2_KERNEL_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.DTIMER2_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Pos          24                                                                     /*!< Right-most bit position of dtimer2_kernel_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Msk          (0x00000001UL << CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Pos)       /*!< Mask for dtimer2_kernel_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Shift(v)     (((v) << CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into dtimer2_kernel_clk_g and mask 'v' to fit it into dtimer2_kernel_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__SET() sets CLK_EN_CTRL_CLR.DTIMER2_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.DTIMER2_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER2_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.DTIMER2_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER2_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.DTIMER2_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.DTIMER2_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__DTIMER2_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_EN_CTRL_CLR.DTIMER1_KERNEL_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.DTIMER1_KERNEL_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Pos          23                                                                     /*!< Right-most bit position of dtimer1_kernel_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Msk          (0x00000001UL << CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Pos)       /*!< Mask for dtimer1_kernel_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Shift(v)     (((v) << CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Msk) /*!< Shift value 'v' into dtimer1_kernel_clk_g and mask 'v' to fit it into dtimer1_kernel_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__SET() sets CLK_EN_CTRL_CLR.DTIMER1_KERNEL_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.DTIMER1_KERNEL_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER1_KERNEL_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.DTIMER1_KERNEL_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER1_KERNEL_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.DTIMER1_KERNEL_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.DTIMER1_KERNEL_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__DTIMER1_KERNEL_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------- CGU.CLK_EN_CTRL_CLR.GPIO1_CLK_G -------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.GPIO1_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Pos                   22                                                                     /*!< Right-most bit position of gpio1_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Msk                   (0x00000001UL << CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Pos)                /*!< Mask for gpio1_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Shift(v)              (((v) << CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Msk) /*!< Shift value 'v' into gpio1_clk_g and mask 'v' to fit it into gpio1_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__SET() sets CLK_EN_CTRL_CLR.GPIO1_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.GPIO1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.GPIO1_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.GPIO1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.GPIO1_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.GPIO1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------- CGU.CLK_EN_CTRL_CLR.GPIO0_CLK_G -------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.GPIO0_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Pos                   21                                                                     /*!< Right-most bit position of gpio0_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Msk                   (0x00000001UL << CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Pos)                /*!< Mask for gpio0_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Shift(v)              (((v) << CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Msk) /*!< Shift value 'v' into gpio0_clk_g and mask 'v' to fit it into gpio0_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__SET() sets CLK_EN_CTRL_CLR.GPIO0_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.GPIO0_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.GPIO0_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.GPIO0_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.GPIO0_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.GPIO0_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_CLR.WDT_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.WDT_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Pos                     20                                                                     /*!< Right-most bit position of wdt_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Msk                     (0x00000001UL << CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Pos)                  /*!< Mask for wdt_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Shift(v)                (((v) << CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Msk) /*!< Shift value 'v' into wdt_clk_g and mask 'v' to fit it into wdt_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__SET() sets CLK_EN_CTRL_CLR.WDT_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.WDT_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.WDT_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.WDT_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.WDT_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.WDT_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL_CLR.DTIMER3_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.DTIMER3_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Pos                 19                                                                     /*!< Right-most bit position of dtimer3_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Pos)              /*!< Mask for dtimer3_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Msk) /*!< Shift value 'v' into dtimer3_clk_g and mask 'v' to fit it into dtimer3_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__SET() sets CLK_EN_CTRL_CLR.DTIMER3_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.DTIMER3_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER3_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.DTIMER3_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER3_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.DTIMER3_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL_CLR.DTIMER2_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.DTIMER2_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Pos                 18                                                                     /*!< Right-most bit position of dtimer2_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Pos)              /*!< Mask for dtimer2_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Msk) /*!< Shift value 'v' into dtimer2_clk_g and mask 'v' to fit it into dtimer2_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__SET() sets CLK_EN_CTRL_CLR.DTIMER2_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.DTIMER2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER2_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.DTIMER2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER2_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.DTIMER2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL_CLR.DTIMER1_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.DTIMER1_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Pos                 17                                                                     /*!< Right-most bit position of dtimer1_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Pos)              /*!< Mask for dtimer1_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Msk) /*!< Shift value 'v' into dtimer1_clk_g and mask 'v' to fit it into dtimer1_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__SET() sets CLK_EN_CTRL_CLR.DTIMER1_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.DTIMER1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER1_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.DTIMER1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.DTIMER1_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.DTIMER1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_CLR.BIF_PER_UART_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.BIF_PER_UART_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Pos            16                                                                     /*!< Right-most bit position of bif_per_uart_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Msk            (0x00000001UL << CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Pos)         /*!< Mask for bif_per_uart_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Shift(v)       (((v) << CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Msk) /*!< Shift value 'v' into bif_per_uart_clk_g and mask 'v' to fit it into bif_per_uart_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__SET() sets CLK_EN_CTRL_CLR.BIF_PER_UART_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_PER_UART_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_PER_UART_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_CLR.BIF_PER_I2C_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.BIF_PER_I2C_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Pos             15                                                                     /*!< Right-most bit position of bif_per_i2c_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Msk             (0x00000001UL << CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Pos)          /*!< Mask for bif_per_i2c_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Shift(v)        (((v) << CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Msk) /*!< Shift value 'v' into bif_per_i2c_clk_g and mask 'v' to fit it into bif_per_i2c_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__SET() sets CLK_EN_CTRL_CLR.BIF_PER_I2C_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_PER_I2C_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_PER_I2C_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_CLR.BIF_PER_SSP_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.BIF_PER_SSP_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Pos             14                                                                     /*!< Right-most bit position of bif_per_ssp_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Msk             (0x00000001UL << CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Pos)          /*!< Mask for bif_per_ssp_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Shift(v)        (((v) << CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Msk) /*!< Shift value 'v' into bif_per_ssp_clk_g and mask 'v' to fit it into bif_per_ssp_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__SET() sets CLK_EN_CTRL_CLR.BIF_PER_SSP_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_PER_SSP_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_PER_SSP_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_EN_CTRL_CLR.BIF_PER_PMBUS_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.BIF_PER_PMBUS_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Pos           13                                                                     /*!< Right-most bit position of bif_per_pmbus_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Msk           (0x00000001UL << CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Pos)        /*!< Mask for bif_per_pmbus_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Shift(v)      (((v) << CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Msk) /*!< Shift value 'v' into bif_per_pmbus_clk_g and mask 'v' to fit it into bif_per_pmbus_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__SET() sets CLK_EN_CTRL_CLR.BIF_PER_PMBUS_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_PER_PMBUS_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_CLR.BIF_PER_SVID_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.BIF_PER_SVID_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Pos            12                                                                     /*!< Right-most bit position of bif_per_svid_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Msk            (0x00000001UL << CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Pos)         /*!< Mask for bif_per_svid_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Shift(v)       (((v) << CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Msk) /*!< Shift value 'v' into bif_per_svid_clk_g and mask 'v' to fit it into bif_per_svid_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__SET() sets CLK_EN_CTRL_CLR.BIF_PER_SVID_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_PER_SVID_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_PER_SVID_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL_CLR.BIF_REG_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.BIF_REG_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Pos                 11                                                                     /*!< Right-most bit position of bif_reg_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Msk                 (0x00000001UL << CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Pos)              /*!< Mask for bif_reg_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Shift(v)            (((v) << CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Msk) /*!< Shift value 'v' into bif_reg_clk_g and mask 'v' to fit it into bif_reg_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__SET() sets CLK_EN_CTRL_CLR.BIF_REG_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.BIF_REG_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_REG_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.BIF_REG_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.BIF_REG_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.BIF_REG_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------------- CGU.CLK_EN_CTRL_CLR.CNFG_DMA_CLK_G ------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.CNFG_DMA_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Pos                10                                                                     /*!< Right-most bit position of cnfg_dma_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Msk                (0x00000001UL << CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Pos)             /*!< Mask for cnfg_dma_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Shift(v)           (((v) << CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Msk) /*!< Shift value 'v' into cnfg_dma_clk_g and mask 'v' to fit it into cnfg_dma_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__SET() sets CLK_EN_CTRL_CLR.CNFG_DMA_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.CNFG_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.CNFG_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.CNFG_DMA_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.CNFG_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------------- CGU.CLK_EN_CTRL_CLR.CNFG_OTP1_W_CLK_G ----------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.CNFG_OTP1_W_CLK_G:

    1: Clock  CrossRefz



    and  CrossRefz  are live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Pos             6                                                                      /*!< Right-most bit position of cnfg_otp1_w_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Msk             (0x00000001UL << CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Pos)          /*!< Mask for cnfg_otp1_w_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Shift(v)        (((v) << CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Msk) /*!< Shift value 'v' into cnfg_otp1_w_clk_g and mask 'v' to fit it into cnfg_otp1_w_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__SET() sets CLK_EN_CTRL_CLR.CNFG_OTP1_W_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.CNFG_OTP1_W_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.CNFG_OTP1_W_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__CNFG_OTP1_W_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_CLR.DMA_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.DMA_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Pos                     5                                                                      /*!< Right-most bit position of dma_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Msk                     (0x00000001UL << CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Pos)                  /*!< Mask for dma_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Shift(v)                (((v) << CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Msk) /*!< Shift value 'v' into dma_clk_g and mask 'v' to fit it into dma_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__SET() sets CLK_EN_CTRL_CLR.DMA_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.DMA_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_CLR.AMBA_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.AMBA_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Pos                    4                                                                      /*!< Right-most bit position of amba_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Msk                    (0x00000001UL << CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Pos)                 /*!< Mask for amba_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Shift(v)               (((v) << CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Msk) /*!< Shift value 'v' into amba_clk_g and mask 'v' to fit it into amba_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__SET() sets CLK_EN_CTRL_CLR.AMBA_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.AMBA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.AMBA_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.AMBA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.AMBA_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.AMBA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_CLR.RAM2_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.RAM2_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Pos                    3                                                                      /*!< Right-most bit position of ram2_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Msk                    (0x00000001UL << CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Pos)                 /*!< Mask for ram2_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Shift(v)               (((v) << CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Msk) /*!< Shift value 'v' into ram2_clk_g and mask 'v' to fit it into ram2_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__SET() sets CLK_EN_CTRL_CLR.RAM2_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.RAM2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.RAM2_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.RAM2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.RAM2_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.RAM2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_CLR.RAM1_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.RAM1_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Pos                    2                                                                      /*!< Right-most bit position of ram1_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Msk                    (0x00000001UL << CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Pos)                 /*!< Mask for ram1_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Shift(v)               (((v) << CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Msk) /*!< Shift value 'v' into ram1_clk_g and mask 'v' to fit it into ram1_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__SET() sets CLK_EN_CTRL_CLR.RAM1_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.RAM1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.RAM1_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.RAM1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.RAM1_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.RAM1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_CLR.ROM_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.ROM_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Pos                     1                                                                      /*!< Right-most bit position of rom_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Msk                     (0x00000001UL << CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Pos)                  /*!< Mask for rom_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Shift(v)                (((v) << CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Msk) /*!< Shift value 'v' into rom_clk_g and mask 'v' to fit it into rom_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__SET() sets CLK_EN_CTRL_CLR.ROM_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.ROM_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.ROM_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.ROM_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.ROM_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.ROM_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------------- CGU.CLK_EN_CTRL_CLR.HOSC_CLK_G --------------------- */

/**
<pre>
  CGU.CLK_EN_CTRL_CLR.HOSC_CLK_G:

    1: Clock  CrossRefz



    is live

</pre> */

#define CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Pos                    0                                                                      /*!< Right-most bit position of hosc_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Msk                    (0x00000001UL << CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Pos)                 /*!< Mask for hosc_clk_g in CGU.CLK_EN_CTRL_CLR */
#define CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Shift(v)               (((v) << CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Pos) & CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Msk) /*!< Shift value 'v' into hosc_clk_g and mask 'v' to fit it into hosc_clk_g field */

/** CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__SET() sets CLK_EN_CTRL_CLR.HOSC_CLK_G to given value.
 *
 * When writing to CLK_EN_CTRL_CLR.HOSC_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_EN_CTRL_CLR.HOSC_CLK_G
 */
__CGU_INLINE void CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_EN_CTRL_CLR__SET(reg);
}


/** CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__MODIFY() modifies CLK_EN_CTRL_CLR.HOSC_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_EN_CTRL_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @param bf_value new value for CLK_EN_CTRL_CLR.HOSC_CLK_G
 * @return new value of CGU.CLK_EN_CTRL_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__EXTRACT() extracts CLK_EN_CTRL_CLR.HOSC_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_EN_CTRL_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_EN_CTRL_CLR
 * @return current value of CLK_EN_CTRL_CLR.HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_EN_CTRL_CLR__HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   CLK_SLEEP_MSK_CNFG_SET member of CGU_t                   */
/* -------------------------------------------------------------------------- */

/** __CGU_CLK_SLEEP_MSK_CNFG_SET__ADDRESS returns the address of member CLK_SLEEP_MSK_CNFG_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t* __CGU_CLK_SLEEP_MSK_CNFG_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CLK_SLEEP_MSK_CNFG_SET)));
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SET() sets CLK_SLEEP_MSK_CNFG_SET to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET, this is mandatory to use.
 *
 * @param value new value for CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SET(uint32_t value)
{
    HAL_SET32(__CGU_CLK_SLEEP_MSK_CNFG_SET__ADDRESS(), value);
}


/* --------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_GPIO1_CLK_G --------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_GPIO1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Pos         22                                                                     /*!< Right-most bit position of se_gpio1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Msk         (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Pos)      /*!< Mask for se_gpio1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Shift(v)    (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Msk) /*!< Shift value 'v' into se_gpio1_clk_g and mask 'v' to fit it into se_gpio1_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_GPIO1_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_GPIO1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_GPIO1_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_GPIO1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_GPIO1_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_GPIO1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_GPIO0_CLK_G --------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_GPIO0_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Pos         21                                                                     /*!< Right-most bit position of se_gpio0_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Msk         (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Pos)      /*!< Mask for se_gpio0_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Shift(v)    (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Msk) /*!< Shift value 'v' into se_gpio0_clk_g and mask 'v' to fit it into se_gpio0_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_GPIO0_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_GPIO0_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_GPIO0_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_GPIO0_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_GPIO0_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_GPIO0_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_WDT_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_WDT_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Pos           20                                                                     /*!< Right-most bit position of se_wdt_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Msk           (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Pos)        /*!< Mask for se_wdt_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Shift(v)      (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Msk) /*!< Shift value 'v' into se_wdt_clk_g and mask 'v' to fit it into se_wdt_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_WDT_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_WDT_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_WDT_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_WDT_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_WDT_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_WDT_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER3_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER3_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Pos       19                                                                     /*!< Right-most bit position of se_dtimer3_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Pos)    /*!< Mask for se_dtimer3_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Msk) /*!< Shift value 'v' into se_dtimer3_clk_g and mask 'v' to fit it into se_dtimer3_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER3_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER3_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER3_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER3_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER3_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER3_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER2_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Pos       18                                                                     /*!< Right-most bit position of se_dtimer2_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Pos)    /*!< Mask for se_dtimer2_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Msk) /*!< Shift value 'v' into se_dtimer2_clk_g and mask 'v' to fit it into se_dtimer2_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER2_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER2_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER2_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER1_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Pos       17                                                                     /*!< Right-most bit position of se_dtimer1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Pos)    /*!< Mask for se_dtimer1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Msk) /*!< Shift value 'v' into se_dtimer1_clk_g and mask 'v' to fit it into se_dtimer1_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER1_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER1_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER1_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_UART_CLK_G ------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_UART_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Pos  16                                                                     /*!< Right-most bit position of se_bif_per_uart_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Msk  (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Pos) /*!< Mask for se_bif_per_uart_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_uart_clk_g and mask 'v' to fit it into se_bif_per_uart_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_UART_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_UART_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_I2C_CLK_G ------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_I2C_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Pos   15                                                                     /*!< Right-most bit position of se_bif_per_i2c_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Msk   (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Pos) /*!< Mask for se_bif_per_i2c_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_i2c_clk_g and mask 'v' to fit it into se_bif_per_i2c_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_I2C_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_I2C_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SSP_CLK_G ------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SSP_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Pos   14                                                                     /*!< Right-most bit position of se_bif_per_ssp_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Msk   (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Pos) /*!< Mask for se_bif_per_ssp_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_ssp_clk_g and mask 'v' to fit it into se_bif_per_ssp_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SSP_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SSP_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_PMBUS_CLK_G ----------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_PMBUS_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Pos 13                                                                     /*!< Right-most bit position of se_bif_per_pmbus_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Msk (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Pos) /*!< Mask for se_bif_per_pmbus_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_pmbus_clk_g and mask 'v' to fit it into se_bif_per_pmbus_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_PMBUS_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_PMBUS_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SVID_CLK_G ------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SVID_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Pos  12                                                                     /*!< Right-most bit position of se_bif_per_svid_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Msk  (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Pos) /*!< Mask for se_bif_per_svid_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_svid_clk_g and mask 'v' to fit it into se_bif_per_svid_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SVID_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SVID_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_REG_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_BIF_REG_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Pos       11                                                                     /*!< Right-most bit position of se_bif_reg_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Pos)    /*!< Mask for se_bif_reg_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Msk) /*!< Shift value 'v' into se_bif_reg_clk_g and mask 'v' to fit it into se_bif_reg_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_BIF_REG_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_BIF_REG_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_REG_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_BIF_REG_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_BIF_REG_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_BIF_REG_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_DMA_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Pos      10                                                                     /*!< Right-most bit position of se_cnfg_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Msk      (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Pos)   /*!< Mask for se_cnfg_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Msk) /*!< Shift value 'v' into se_cnfg_dma_clk_g and mask 'v' to fit it into se_cnfg_dma_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_DMA_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_DMA_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_OTP1_W_CLK_G ------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_OTP1_W_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Pos   6                                                                      /*!< Right-most bit position of se_cnfg_otp1_w_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Msk   (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Pos) /*!< Mask for se_cnfg_otp1_w_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Msk) /*!< Shift value 'v' into se_cnfg_otp1_w_clk_g and mask 'v' to fit it into se_cnfg_otp1_w_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_OTP1_W_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_OTP1_W_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_OTP1_W_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_CNFG_OTP1_W_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_DMA_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Pos           5                                                                      /*!< Right-most bit position of se_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Msk           (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Pos)        /*!< Mask for se_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Shift(v)      (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Msk) /*!< Shift value 'v' into se_dma_clk_g and mask 'v' to fit it into se_dma_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_DMA_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_DMA_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_AMBA_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_AMBA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Pos          4                                                                      /*!< Right-most bit position of se_amba_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Msk          (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Pos)       /*!< Mask for se_amba_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Shift(v)     (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Msk) /*!< Shift value 'v' into se_amba_clk_g and mask 'v' to fit it into se_amba_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_AMBA_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_AMBA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_AMBA_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_AMBA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_AMBA_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_AMBA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_RAM2_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_RAM2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Pos          3                                                                      /*!< Right-most bit position of se_ram2_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Msk          (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Pos)       /*!< Mask for se_ram2_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Shift(v)     (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Msk) /*!< Shift value 'v' into se_ram2_clk_g and mask 'v' to fit it into se_ram2_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_RAM2_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_RAM2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_RAM2_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_RAM2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_RAM2_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_RAM2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_RAM1_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_RAM1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Pos          2                                                                      /*!< Right-most bit position of se_ram1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Msk          (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Pos)       /*!< Mask for se_ram1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Shift(v)     (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Msk) /*!< Shift value 'v' into se_ram1_clk_g and mask 'v' to fit it into se_ram1_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_RAM1_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_RAM1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_RAM1_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_RAM1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_RAM1_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_RAM1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_ROM_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_ROM_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Pos           1                                                                      /*!< Right-most bit position of se_rom_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Msk           (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Pos)        /*!< Mask for se_rom_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Shift(v)      (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Msk) /*!< Shift value 'v' into se_rom_clk_g and mask 'v' to fit it into se_rom_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_ROM_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_ROM_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_ROM_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_ROM_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_ROM_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_ROM_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_SET.SE_HOSC_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_SET.SE_HOSC_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep if  CrossRefz  clock gating control has been enabled

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Pos          0                                                                      /*!< Right-most bit position of se_hosc_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Msk          (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Pos)       /*!< Mask for se_hosc_clk_g in CGU.CLK_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Shift(v)     (((v) << CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Msk) /*!< Shift value 'v' into se_hosc_clk_g and mask 'v' to fit it into se_hosc_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_SET.SE_HOSC_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_SET.SE_HOSC_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_HOSC_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_SET.SE_HOSC_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_SET.SE_HOSC_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_SET.SE_HOSC_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_SLEEP_MSK_CNFG_SET.SE_HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_SET__SE_HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                   CLK_SLEEP_MSK_CNFG_CLR member of CGU_t                   */
/* -------------------------------------------------------------------------- */

/** __CGU_CLK_SLEEP_MSK_CNFG_CLR__ADDRESS returns the address of member CLK_SLEEP_MSK_CNFG_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t* __CGU_CLK_SLEEP_MSK_CNFG_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CLK_SLEEP_MSK_CNFG_CLR)));
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SET() sets CLK_SLEEP_MSK_CNFG_CLR to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR, this is mandatory to use.
 *
 * @param value new value for CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(uint32_t value)
{
    HAL_SET32(__CGU_CLK_SLEEP_MSK_CNFG_CLR__ADDRESS(), value);
}


/* --------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO1_CLK_G --------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Pos         22                                                                     /*!< Right-most bit position of se_gpio1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Msk         (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Pos)      /*!< Mask for se_gpio1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Shift(v)    (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Msk) /*!< Shift value 'v' into se_gpio1_clk_g and mask 'v' to fit it into se_gpio1_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO1_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO1_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO1_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO0_CLK_G --------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO0_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Pos         21                                                                     /*!< Right-most bit position of se_gpio0_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Msk         (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Pos)      /*!< Mask for se_gpio0_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Shift(v)    (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Msk) /*!< Shift value 'v' into se_gpio0_clk_g and mask 'v' to fit it into se_gpio0_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO0_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO0_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO0_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO0_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO0_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO0_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_WDT_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_WDT_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Pos           20                                                                     /*!< Right-most bit position of se_wdt_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Msk           (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Pos)        /*!< Mask for se_wdt_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Shift(v)      (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Msk) /*!< Shift value 'v' into se_wdt_clk_g and mask 'v' to fit it into se_wdt_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_WDT_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_WDT_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_WDT_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_WDT_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_WDT_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_WDT_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER3_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER3_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Pos       19                                                                     /*!< Right-most bit position of se_dtimer3_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Pos)    /*!< Mask for se_dtimer3_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Msk) /*!< Shift value 'v' into se_dtimer3_clk_g and mask 'v' to fit it into se_dtimer3_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER3_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER3_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER3_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER3_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER3_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER3_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER2_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Pos       18                                                                     /*!< Right-most bit position of se_dtimer2_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Pos)    /*!< Mask for se_dtimer2_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Msk) /*!< Shift value 'v' into se_dtimer2_clk_g and mask 'v' to fit it into se_dtimer2_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER2_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER2_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER2_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER1_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Pos       17                                                                     /*!< Right-most bit position of se_dtimer1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Pos)    /*!< Mask for se_dtimer1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Msk) /*!< Shift value 'v' into se_dtimer1_clk_g and mask 'v' to fit it into se_dtimer1_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER1_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER1_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER1_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_UART_CLK_G ------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_UART_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Pos  16                                                                     /*!< Right-most bit position of se_bif_per_uart_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Msk  (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Pos) /*!< Mask for se_bif_per_uart_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_uart_clk_g and mask 'v' to fit it into se_bif_per_uart_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_UART_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_UART_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_I2C_CLK_G ------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_I2C_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Pos   15                                                                     /*!< Right-most bit position of se_bif_per_i2c_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Msk   (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Pos) /*!< Mask for se_bif_per_i2c_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_i2c_clk_g and mask 'v' to fit it into se_bif_per_i2c_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_I2C_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_I2C_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SSP_CLK_G ------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SSP_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Pos   14                                                                     /*!< Right-most bit position of se_bif_per_ssp_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Msk   (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Pos) /*!< Mask for se_bif_per_ssp_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_ssp_clk_g and mask 'v' to fit it into se_bif_per_ssp_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SSP_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SSP_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_PMBUS_CLK_G ----------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_PMBUS_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Pos 13                                                                     /*!< Right-most bit position of se_bif_per_pmbus_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Msk (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Pos) /*!< Mask for se_bif_per_pmbus_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_pmbus_clk_g and mask 'v' to fit it into se_bif_per_pmbus_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_PMBUS_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_PMBUS_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SVID_CLK_G ------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SVID_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Pos  12                                                                     /*!< Right-most bit position of se_bif_per_svid_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Msk  (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Pos) /*!< Mask for se_bif_per_svid_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Msk) /*!< Shift value 'v' into se_bif_per_svid_clk_g and mask 'v' to fit it into se_bif_per_svid_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SVID_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SVID_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_REG_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_REG_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Pos       11                                                                     /*!< Right-most bit position of se_bif_reg_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Msk       (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Pos)    /*!< Mask for se_bif_reg_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Shift(v)  (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Msk) /*!< Shift value 'v' into se_bif_reg_clk_g and mask 'v' to fit it into se_bif_reg_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_REG_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_REG_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_REG_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_REG_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_REG_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_REG_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_DMA_CLK_G -------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Pos      10                                                                     /*!< Right-most bit position of se_cnfg_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Msk      (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Pos)   /*!< Mask for se_cnfg_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Msk) /*!< Shift value 'v' into se_cnfg_dma_clk_g and mask 'v' to fit it into se_cnfg_dma_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_DMA_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_DMA_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_OTP1_W_CLK_G ------------ */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_OTP1_W_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Pos   6                                                                      /*!< Right-most bit position of se_cnfg_otp1_w_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Msk   (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Pos) /*!< Mask for se_cnfg_otp1_w_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Shift(v) (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Msk) /*!< Shift value 'v' into se_cnfg_otp1_w_clk_g and mask 'v' to fit it into se_cnfg_otp1_w_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_OTP1_W_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_OTP1_W_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_OTP1_W_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_CNFG_OTP1_W_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_DMA_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Pos           5                                                                      /*!< Right-most bit position of se_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Msk           (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Pos)        /*!< Mask for se_dma_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Shift(v)      (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Msk) /*!< Shift value 'v' into se_dma_clk_g and mask 'v' to fit it into se_dma_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_DMA_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_DMA_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_AMBA_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_AMBA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Pos          4                                                                      /*!< Right-most bit position of se_amba_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Msk          (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Pos)       /*!< Mask for se_amba_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Shift(v)     (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Msk) /*!< Shift value 'v' into se_amba_clk_g and mask 'v' to fit it into se_amba_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_AMBA_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_AMBA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_AMBA_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_AMBA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_AMBA_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_AMBA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_RAM2_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_RAM2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Pos          3                                                                      /*!< Right-most bit position of se_ram2_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Msk          (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Pos)       /*!< Mask for se_ram2_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Shift(v)     (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Msk) /*!< Shift value 'v' into se_ram2_clk_g and mask 'v' to fit it into se_ram2_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_RAM2_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_RAM2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_RAM2_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_RAM2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_RAM2_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_RAM2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_RAM1_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_RAM1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Pos          2                                                                      /*!< Right-most bit position of se_ram1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Msk          (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Pos)       /*!< Mask for se_ram1_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Shift(v)     (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Msk) /*!< Shift value 'v' into se_ram1_clk_g and mask 'v' to fit it into se_ram1_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_RAM1_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_RAM1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_RAM1_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_RAM1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_RAM1_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_RAM1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_ROM_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_ROM_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Pos           1                                                                      /*!< Right-most bit position of se_rom_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Msk           (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Pos)        /*!< Mask for se_rom_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Shift(v)      (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Msk) /*!< Shift value 'v' into se_rom_clk_g and mask 'v' to fit it into se_rom_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_ROM_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_ROM_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_ROM_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_ROM_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_ROM_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_ROM_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ---------------- CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_HOSC_CLK_G ---------------- */

/**
<pre>
  CGU.CLK_SLEEP_MSK_CNFG_CLR.SE_HOSC_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep if  CrossRefz  clock gating control has been enabled

</pre> */

#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Pos          0                                                                      /*!< Right-most bit position of se_hosc_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Msk          (0x00000001UL << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Pos)       /*!< Mask for se_hosc_clk_g in CGU.CLK_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Shift(v)     (((v) << CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Pos) & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Msk) /*!< Shift value 'v' into se_hosc_clk_g and mask 'v' to fit it into se_hosc_clk_g field */

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__SET() sets CLK_SLEEP_MSK_CNFG_CLR.SE_HOSC_CLK_G to given value.
 *
 * When writing to CLK_SLEEP_MSK_CNFG_CLR.SE_HOSC_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_HOSC_CLK_G
 */
__CGU_INLINE void CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__MODIFY() modifies CLK_SLEEP_MSK_CNFG_CLR.SE_HOSC_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_SLEEP_MSK_CNFG_CLR.SE_HOSC_CLK_G
 * @return new value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__EXTRACT() extracts CLK_SLEEP_MSK_CNFG_CLR.SE_HOSC_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_SLEEP_MSK_CNFG_CLR.SE_HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_SLEEP_MSK_CNFG_CLR__SE_HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                CLK_DEEP_SLEEP_MSK_CNFG_SET member of CGU_t                */
/* -------------------------------------------------------------------------- */

/** __CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__ADDRESS returns the address of member CLK_DEEP_SLEEP_MSK_CNFG_SET.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t* __CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CLK_DEEP_SLEEP_MSK_CNFG_SET)));
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET, this is mandatory to use.
 *
 * @param value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(uint32_t value)
{
    HAL_SET32(__CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__ADDRESS(), value);
}


/* ------------ CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO1_CLK_G ------------ */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Pos   22                                                                     /*!< Right-most bit position of dse_gpio1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Msk   (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Pos) /*!< Mask for dse_gpio1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Msk) /*!< Shift value 'v' into dse_gpio1_clk_g and mask 'v' to fit it into dse_gpio1_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO1_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO1_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO1_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO0_CLK_G ------------ */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO0_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Pos   21                                                                     /*!< Right-most bit position of dse_gpio0_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Msk   (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Pos) /*!< Mask for dse_gpio0_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Msk) /*!< Shift value 'v' into dse_gpio0_clk_g and mask 'v' to fit it into dse_gpio0_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO0_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO0_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO0_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO0_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO0_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO0_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_WDT_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_WDT_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Pos     20                                                                     /*!< Right-most bit position of dse_wdt_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Msk     (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Pos)  /*!< Mask for dse_wdt_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Msk) /*!< Shift value 'v' into dse_wdt_clk_g and mask 'v' to fit it into dse_wdt_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_WDT_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_WDT_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_WDT_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_WDT_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_WDT_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_WDT_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER3_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER3_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Pos 19                                                                     /*!< Right-most bit position of dse_dtimer3_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Pos) /*!< Mask for dse_dtimer3_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Msk) /*!< Shift value 'v' into dse_dtimer3_clk_g and mask 'v' to fit it into dse_dtimer3_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER3_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER3_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER3_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER3_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER3_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER3_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER2_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Pos 18                                                                     /*!< Right-most bit position of dse_dtimer2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Pos) /*!< Mask for dse_dtimer2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Msk) /*!< Shift value 'v' into dse_dtimer2_clk_g and mask 'v' to fit it into dse_dtimer2_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER2_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER2_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER2_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER1_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Pos 17                                                                     /*!< Right-most bit position of dse_dtimer1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Pos) /*!< Mask for dse_dtimer1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Msk) /*!< Shift value 'v' into dse_dtimer1_clk_g and mask 'v' to fit it into dse_dtimer1_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER1_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER1_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER1_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_UART_CLK_G --------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_UART_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Pos 16                                                                     /*!< Right-most bit position of dse_bif_per_uart_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Pos) /*!< Mask for dse_bif_per_uart_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_uart_clk_g and mask 'v' to fit it into dse_bif_per_uart_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_UART_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_UART_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_I2C_CLK_G --------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_I2C_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Pos 15                                                                     /*!< Right-most bit position of dse_bif_per_i2c_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Pos) /*!< Mask for dse_bif_per_i2c_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_i2c_clk_g and mask 'v' to fit it into dse_bif_per_i2c_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_I2C_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_I2C_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SSP_CLK_G --------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SSP_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Pos 14                                                                     /*!< Right-most bit position of dse_bif_per_ssp_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Pos) /*!< Mask for dse_bif_per_ssp_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_ssp_clk_g and mask 'v' to fit it into dse_bif_per_ssp_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SSP_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SSP_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_PMBUS_CLK_G -------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_PMBUS_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Pos 13                                                                     /*!< Right-most bit position of dse_bif_per_pmbus_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Pos) /*!< Mask for dse_bif_per_pmbus_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_pmbus_clk_g and mask 'v' to fit it into dse_bif_per_pmbus_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_PMBUS_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_PMBUS_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SVID_CLK_G --------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SVID_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Pos 12                                                                     /*!< Right-most bit position of dse_bif_per_svid_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Pos) /*!< Mask for dse_bif_per_svid_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_svid_clk_g and mask 'v' to fit it into dse_bif_per_svid_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SVID_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SVID_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_REG_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_REG_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Pos 11                                                                     /*!< Right-most bit position of dse_bif_reg_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Pos) /*!< Mask for dse_bif_reg_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_reg_clk_g and mask 'v' to fit it into dse_bif_reg_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_REG_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_REG_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_REG_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_REG_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_REG_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_REG_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_DMA_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Pos 10                                                                     /*!< Right-most bit position of dse_cnfg_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Pos) /*!< Mask for dse_cnfg_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Msk) /*!< Shift value 'v' into dse_cnfg_dma_clk_g and mask 'v' to fit it into dse_cnfg_dma_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_DMA_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_DMA_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_OTP1_W_CLK_G --------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_OTP1_W_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Pos 6                                                                      /*!< Right-most bit position of dse_cnfg_otp1_w_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Pos) /*!< Mask for dse_cnfg_otp1_w_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Msk) /*!< Shift value 'v' into dse_cnfg_otp1_w_clk_g and mask 'v' to fit it into dse_cnfg_otp1_w_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_OTP1_W_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_OTP1_W_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_OTP1_W_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_CNFG_OTP1_W_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DMA_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Pos     5                                                                      /*!< Right-most bit position of dse_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Msk     (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Pos)  /*!< Mask for dse_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Msk) /*!< Shift value 'v' into dse_dma_clk_g and mask 'v' to fit it into dse_dma_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DMA_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DMA_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_AMBA_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_AMBA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Pos    4                                                                      /*!< Right-most bit position of dse_amba_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Msk    (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Pos) /*!< Mask for dse_amba_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Msk) /*!< Shift value 'v' into dse_amba_clk_g and mask 'v' to fit it into dse_amba_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_AMBA_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_AMBA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_AMBA_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_AMBA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_AMBA_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_AMBA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM2_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Pos    3                                                                      /*!< Right-most bit position of dse_ram2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Msk    (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Pos) /*!< Mask for dse_ram2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Msk) /*!< Shift value 'v' into dse_ram2_clk_g and mask 'v' to fit it into dse_ram2_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM2_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM2_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM2_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM1_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Pos    2                                                                      /*!< Right-most bit position of dse_ram1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Msk    (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Pos) /*!< Mask for dse_ram1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Msk) /*!< Shift value 'v' into dse_ram1_clk_g and mask 'v' to fit it into dse_ram1_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM1_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM1_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM1_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_ROM_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_ROM_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Pos     1                                                                      /*!< Right-most bit position of dse_rom_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Msk     (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Pos)  /*!< Mask for dse_rom_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Msk) /*!< Shift value 'v' into dse_rom_clk_g and mask 'v' to fit it into dse_rom_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_ROM_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_ROM_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_ROM_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_ROM_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_ROM_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_ROM_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_HOSC_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_HOSC_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep if  CrossRefz  clock gating control has been enabled

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Pos    0                                                                      /*!< Right-most bit position of dse_hosc_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Msk    (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Pos) /*!< Mask for dse_hosc_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Msk) /*!< Shift value 'v' into dse_hosc_clk_g and mask 'v' to fit it into dse_hosc_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_HOSC_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_HOSC_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_HOSC_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_HOSC_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_HOSC_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_HOSC_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_SET
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_SET.DSE_HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_SET__DSE_HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------------------------------------------------------------------------- */
/*                CLK_DEEP_SLEEP_MSK_CNFG_CLR member of CGU_t                */
/* -------------------------------------------------------------------------- */

/** __CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__ADDRESS returns the address of member CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 *
 * As indicated by the __ prefix, this is not intended for use by the FW. It is
 * here for readability only.
 *
 * @return address of CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t* __CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__ADDRESS(void)
{
    return (uint32_t*)((uint32_t)__CGU_BASE_PTR() + (uint32_t)(offsetof(CGU_t, CLK_DEEP_SLEEP_MSK_CNFG_CLR)));
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR, this is mandatory to use.
 *
 * @param value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(uint32_t value)
{
    HAL_SET32(__CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__ADDRESS(), value);
}


/* ------------ CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO1_CLK_G ------------ */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Pos   22                                                                     /*!< Right-most bit position of dse_gpio1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Msk   (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Pos) /*!< Mask for dse_gpio1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Msk) /*!< Shift value 'v' into dse_gpio1_clk_g and mask 'v' to fit it into dse_gpio1_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO1_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO1_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO1_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------ CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO0_CLK_G ------------ */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO0_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Pos   21                                                                     /*!< Right-most bit position of dse_gpio0_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Msk   (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Pos) /*!< Mask for dse_gpio0_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Msk) /*!< Shift value 'v' into dse_gpio0_clk_g and mask 'v' to fit it into dse_gpio0_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO0_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO0_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO0_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO0_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO0_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO0_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_GPIO0_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_GPIO0_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_WDT_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_WDT_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Pos     20                                                                     /*!< Right-most bit position of dse_wdt_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Msk     (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Pos)  /*!< Mask for dse_wdt_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Msk) /*!< Shift value 'v' into dse_wdt_clk_g and mask 'v' to fit it into dse_wdt_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_WDT_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_WDT_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_WDT_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_WDT_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_WDT_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_WDT_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_WDT_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_WDT_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER3_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER3_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Pos 19                                                                     /*!< Right-most bit position of dse_dtimer3_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Pos) /*!< Mask for dse_dtimer3_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Msk) /*!< Shift value 'v' into dse_dtimer3_clk_g and mask 'v' to fit it into dse_dtimer3_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER3_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER3_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER3_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER3_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER3_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER3_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER3_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER3_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER2_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Pos 18                                                                     /*!< Right-most bit position of dse_dtimer2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Pos) /*!< Mask for dse_dtimer2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Msk) /*!< Shift value 'v' into dse_dtimer2_clk_g and mask 'v' to fit it into dse_dtimer2_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER2_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER2_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER2_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER1_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in dep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Pos 17                                                                     /*!< Right-most bit position of dse_dtimer1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Pos) /*!< Mask for dse_dtimer1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Msk) /*!< Shift value 'v' into dse_dtimer1_clk_g and mask 'v' to fit it into dse_dtimer1_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER1_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER1_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER1_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DTIMER1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DTIMER1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_UART_CLK_G --------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_UART_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Pos 16                                                                     /*!< Right-most bit position of dse_bif_per_uart_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Pos) /*!< Mask for dse_bif_per_uart_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_uart_clk_g and mask 'v' to fit it into dse_bif_per_uart_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_UART_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_UART_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_UART_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_UART_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_UART_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_UART_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_I2C_CLK_G --------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_I2C_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Pos 15                                                                     /*!< Right-most bit position of dse_bif_per_i2c_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Pos) /*!< Mask for dse_bif_per_i2c_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_i2c_clk_g and mask 'v' to fit it into dse_bif_per_i2c_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_I2C_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_I2C_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_I2C_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_I2C_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_I2C_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_I2C_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SSP_CLK_G --------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SSP_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Pos 14                                                                     /*!< Right-most bit position of dse_bif_per_ssp_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Pos) /*!< Mask for dse_bif_per_ssp_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_ssp_clk_g and mask 'v' to fit it into dse_bif_per_ssp_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SSP_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SSP_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SSP_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SSP_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SSP_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SSP_CLK_G__Pos);
    return (uint32_t)reg;
}

/* -------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_PMBUS_CLK_G -------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_PMBUS_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Pos 13                                                                     /*!< Right-most bit position of dse_bif_per_pmbus_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Pos) /*!< Mask for dse_bif_per_pmbus_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_pmbus_clk_g and mask 'v' to fit it into dse_bif_per_pmbus_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_PMBUS_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_PMBUS_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_PMBUS_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_PMBUS_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_PMBUS_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_PMBUS_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SVID_CLK_G --------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SVID_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Pos 12                                                                     /*!< Right-most bit position of dse_bif_per_svid_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Pos) /*!< Mask for dse_bif_per_svid_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_per_svid_clk_g and mask 'v' to fit it into dse_bif_per_svid_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SVID_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SVID_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SVID_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SVID_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_PER_SVID_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_PER_SVID_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_REG_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_REG_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Pos 11                                                                     /*!< Right-most bit position of dse_bif_reg_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Pos) /*!< Mask for dse_bif_reg_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Msk) /*!< Shift value 'v' into dse_bif_reg_clk_g and mask 'v' to fit it into dse_bif_reg_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_REG_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_REG_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_REG_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_REG_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_REG_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_REG_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_BIF_REG_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_BIF_REG_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ----------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_DMA_CLK_G ----------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Pos 10                                                                     /*!< Right-most bit position of dse_cnfg_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Pos) /*!< Mask for dse_cnfg_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Msk) /*!< Shift value 'v' into dse_cnfg_dma_clk_g and mask 'v' to fit it into dse_cnfg_dma_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_DMA_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_DMA_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* --------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_OTP1_W_CLK_G --------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_OTP1_W_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Pos 6                                                                      /*!< Right-most bit position of dse_cnfg_otp1_w_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Msk (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Pos) /*!< Mask for dse_cnfg_otp1_w_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Msk) /*!< Shift value 'v' into dse_cnfg_otp1_w_clk_g and mask 'v' to fit it into dse_cnfg_otp1_w_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_OTP1_W_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_OTP1_W_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_OTP1_W_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_OTP1_W_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_CNFG_OTP1_W_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_CNFG_OTP1_W_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DMA_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DMA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Pos     5                                                                      /*!< Right-most bit position of dse_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Msk     (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Pos)  /*!< Mask for dse_dma_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Msk) /*!< Shift value 'v' into dse_dma_clk_g and mask 'v' to fit it into dse_dma_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DMA_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DMA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DMA_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DMA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DMA_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DMA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_DMA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_DMA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_AMBA_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_AMBA_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Pos    4                                                                      /*!< Right-most bit position of dse_amba_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Msk    (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Pos) /*!< Mask for dse_amba_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Msk) /*!< Shift value 'v' into dse_amba_clk_g and mask 'v' to fit it into dse_amba_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_AMBA_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_AMBA_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_AMBA_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_AMBA_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_AMBA_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_AMBA_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_AMBA_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_AMBA_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM2_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM2_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Pos    3                                                                      /*!< Right-most bit position of dse_ram2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Msk    (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Pos) /*!< Mask for dse_ram2_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Msk) /*!< Shift value 'v' into dse_ram2_clk_g and mask 'v' to fit it into dse_ram2_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM2_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM2_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM2_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM2_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM2_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM2_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM2_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM2_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM1_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM1_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Pos    2                                                                      /*!< Right-most bit position of dse_ram1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Msk    (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Pos) /*!< Mask for dse_ram1_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Msk) /*!< Shift value 'v' into dse_ram1_clk_g and mask 'v' to fit it into dse_ram1_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM1_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM1_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM1_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM1_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM1_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM1_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_RAM1_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_RAM1_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_ROM_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_ROM_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Pos     1                                                                      /*!< Right-most bit position of dse_rom_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Msk     (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Pos)  /*!< Mask for dse_rom_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Msk) /*!< Shift value 'v' into dse_rom_clk_g and mask 'v' to fit it into dse_rom_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_ROM_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_ROM_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_ROM_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_ROM_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_ROM_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_ROM_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_ROM_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_ROM_CLK_G__Pos);
    return (uint32_t)reg;
}

/* ------------- CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_HOSC_CLK_G ------------- */

/**
<pre>
  CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_HOSC_CLK_G:

    1: Clock  CrossRefz



    is gated when CM0 is in deep sleep if  CrossRefz  clock gating control has been enabled

</pre> */

#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Pos    0                                                                      /*!< Right-most bit position of dse_hosc_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Msk    (0x00000001UL << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Pos) /*!< Mask for dse_hosc_clk_g in CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR */
#define CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Shift(v) (((v) << CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Pos) & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Msk) /*!< Shift value 'v' into dse_hosc_clk_g and mask 'v' to fit it into dse_hosc_clk_g field */

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__SET() sets CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_HOSC_CLK_G to given value.
 *
 * When writing to CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_HOSC_CLK_G, this is recommended to use.
 *
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_HOSC_CLK_G
 */
__CGU_INLINE void CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__SET(uint32_t bf_value)
{
    uint32_t reg = CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Shift((uint32_t)bf_value);
    CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__SET(reg);
}


/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__MODIFY() modifies CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_HOSC_CLK_G.
 *
 * This is recommended to use when setting more than one bitfield of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * Multiple subsequent xxx__MODIFY inlines are aggregated into one
 * by the compiler's optimization stage.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @param bf_value new value for CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_HOSC_CLK_G
 * @return new value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__MODIFY(uint32_t reg, uint32_t bf_value)
{
    reg = (reg & ~CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Msk);
    reg = (reg | (CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Shift((uint32_t)bf_value)));
    return reg;
}

/** CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__EXTRACT() extracts CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_HOSC_CLK_G.
 *
 * This is recommended to use when extracting more than one bitfield from CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR.
 * It avoids multiple time-consuming bus accesses.
 *
 * @param reg current value of CGU.CLK_DEEP_SLEEP_MSK_CNFG_CLR
 * @return current value of CLK_DEEP_SLEEP_MSK_CNFG_CLR.DSE_HOSC_CLK_G
 */
__CGU_INLINE uint32_t CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__EXTRACT(uint32_t reg)
{
    reg = (reg & CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Msk);
    reg = (reg >> CGU_CLK_DEEP_SLEEP_MSK_CNFG_CLR__DSE_HOSC_CLK_G__Pos);
    return (uint32_t)reg;
}

/** @} */ /* End of group cgu block */


/** @} */ /* End of group SHASTA */

/** @} */ /* End of group Infineon */

#endif /* _SHASTA_HAL_CGU_H_ */
