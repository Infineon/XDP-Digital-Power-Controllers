#!/usr/bin/python

USAGE = '''
patch_bin2sim_hex: Converts one or multiple patch binary files into a
hex data file for the RTL simulation.

The odd 128 Bit rows could be bit inverted, as required for an OTP data content
file. This inversion is enabled by the option '-i'.

The tool also inverts the data of the odd 128 Bit data rows (e.g. row 1, 3, 5...).
The data of even OTP raws are unchanged

Usage:
   python patch_bin2sim_hex.py [options] <binary_files>

Options:
   -h, --help              Print this help message and exit.

   -o <output_file>        Output hex data file (OTP | RAM download file)
   
   -i                      Invert the odd data rows (128-Bit rows)

   -s <offset>             Offset address inside the OTP where to start
                           (default offset = 0).

   -c                      Generate data comments for each output line

Arguments:
    <binary_files>         On or multiple patch binary files can
                           be provided. The file are read in given order.
'''

import sys
from array import array

otpFile = None
otpOffset = 0
data_comment = False
odd_rows_inverted = False

def raw_lsb_msb_invert(a):
    '''
    This function fill ups the binary array with empty dummy bytes
    till the size is a multiple of the OTP row size (row size = 16 Bytes).

    Afterwards the bytes within the row are swapped that the raw starts
    with the MSB Byte and ends with the LSB Byte.

    The binary array is given as function parameter, and the converted
    array is returned.
    '''
    a2 = array('B')

    #generate a copy of the given array 'a'
    # avoids that the given array object is manipulated
    a2.fromstring(a.tostring())

    b = array('B')

    endOfBinary = False
    insertOffset = 0

    while endOfBinary == False:
        for i in range(16):
            try:
                elem = a2.pop(0)
            except:
                #no bytes left in the input array
                endOfBinary = True
                b.insert(insertOffset, 0) #fill up the 16 byte row with empty bytes
            else:
                b.insert(insertOffset, elem)

        insertOffset += 16 #go to the next raw

    return b

def invert_odd_raw_bytes(a):
    '''
    Binary inverts the data Bytes of odd OTP raws (row size = 16 Bytes).

    The binary array is given as function parameter, and the converted
    array is returned.
    '''
    a2 = array('B')

    #generate a copy of the given array 'a'
    # avoids that the given array object is manipulated
    a2.fromstring(a.tostring())

    b = array('B')

    i = 0
    endOfBinary = False
    while endOfBinary == False:
        try:
            elem = a2.pop(0)
        except:
            #no bytes left in the input array
            endOfBinary = True
        else:
            if i & 0x10:
                elem = elem ^ 0xFF
            b.append(elem)
        i += 1

    return b

def otp_file_write(filename, a, comment):
    '''
    Write the given binary array eleme 'a' to the OTP data content file 'filename'
    '''
    f = open(filename, 'w')
    f.write("// memory data file (generated by 'patch_bin2sim_hex.py')\n")
    i = 0
    for elem in a:
        hexByte = "%02x" % elem
        if i >= 16:
            i = 0
            # EOL
            # insert comment string and CR
            text = ""
            if len(comment) > 0:
                text = " //" + comment.pop(0)
            f.write(text + "\n")
        f.write(hexByte)
        i += 1

    if len(comment) > 0:
        #write the last comment for the remaining bytes
        f.write(" //" + comment.pop(0))

    f.write("\n")
    f.close()

def data_comment_generate(a):
    '''
    This function generates an string array which contains dat file
    specific comments.
    Each comment string represents the binary data of the function argument array.
    '''
    str = []
    intro = "Data: "
    new_string = intro
    index = 0
    for elem in a:
        byte_string = " 0x%02X" % elem
        new_string += byte_string

        index += 1
        if index >= 16:
            str.append(new_string)
            new_string = intro
            index = 0

    if len(new_string) > 0:
        str.append(new_string)

    return str

def bin2otp(binFileList = []):
    '''
    Reads the patch bin files and generates the OTP data file.
    '''
    
    global data_comment
    global odd_rows_inverted
   
    a = array('B')

    #insert dummy bytes till offset
    for i in range(otpOffset):
        a.append(0)

    #append the data bytes of the binary data files
    for name in binFileList:
        f = open(name, 'rb')
        try:
            a.fromfile(f, 1000000)
        except:
            pass
        f.close()


    #generate a copy of the given array 'a'
    # This array is used ot printout the comments in each output dat file. The comment
    # should contain the origin data bytes (not inverted and no MSB/LSB swap
    a2 = array('B')
    a2.fromstring(a.tostring())

    comment_list = []
    if data_comment == True:
        #generate a comment list
        comment_list = data_comment_generate(a2)

    #invert raw based byte order MSB Byte first, LSB Byte last
    a = raw_lsb_msb_invert(a)

    if odd_rows_inverted is True:
        #invert the odd OTP rows (1 row = 128 Bit = 16 Byte)
        a = invert_odd_raw_bytes(a)

    #write the data to the output file
    otp_file_write(otpFile, a, comment_list)

    return 0

def main():
    import getopt

    global otpFile
    global otpOffset
    global data_comment
    global odd_rows_inverted

    args = None

    try:
        opts, args = getopt.getopt(sys.argv[1:], "chio:s:", ["help"])
        for o, a in opts:
            if o in ("-h", "--help"):
                print(USAGE)
                return 0
            elif o in ("-i"):
                odd_rows_inverted=True
            elif o in ("-o"):
                otpFile=a
            elif o in ("-c"):
                data_comment = True
            elif o in ("-s"):
                otpOffset=int(a)

        if otpFile is None:
            raise getopt.GetoptError('OTP data output file not specified')

    except getopt.GetoptError, msg:
        txt = 'ERROR: '+str(msg)  # that's required to get not-so-dumb result from 2to3 tool
        print(txt)
        print(USAGE)
        return 2

    try:
        return bin2otp(args)
    except IOError, e:
        import errno
        if e.errno not in (0, errno.EPIPE):
            raise

if __name__ == '__main__':
    import sys
    sys.exit(main())
